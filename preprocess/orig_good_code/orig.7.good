<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> import numpy as np <NEWLINE> <NL> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> products = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> dp = np . zeros ( W + 1 , dtype = np . int64 ) <NEWLINE> for can_w , can_v in products : <NEWLINE> <INDENT> dp [ can_w : ] = np . maximum ( dp [ can_w : ] , dp [ : - can_w ] + can_v ) <NEWLINE> <NL> <DEDENT> print ( np . max ( dp ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
C1 = str ( input ( ) ) <NEWLINE> C2 = str ( input ( ) ) <NEWLINE> <NL> if C1 [ 0 ] == C2 [ - 1 ] and C1 [ 1 ] == C2 [ - 2 ] and C1 [ 2 ] == C2 [ - 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> ans = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import copy <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = [ [ ] * w for _ in range ( h ) ] <NEWLINE> white = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> t = input ( ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if t [ j ] == <STRING> : <NEWLINE> <INDENT> white += 1 <NEWLINE> s [ i ] . append ( 10 ** 5 ) <NEWLINE> <DEDENT> elif t [ j ] == <STRING> : <NEWLINE> <INDENT> s [ i ] . append ( t [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> now = [ 0 , 0 ] <NEWLINE> steps = [ ] <NEWLINE> steps . append ( now ) <NEWLINE> direction = [ ] <NEWLINE> s [ 0 ] [ 0 ] = 0 <NEWLINE> a = [ 2 ] <NEWLINE> while len ( steps ) > 0 : <NEWLINE> <INDENT> now = copy . copy ( steps [ 0 ] ) <NEWLINE> if s [ now [ 0 ] ] [ now [ 1 ] ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in [ [ 0 , 1 ] , [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] : <NEWLINE> <INDENT> now = copy . copy ( steps [ 0 ] ) <NEWLINE> if now [ 0 ] + k [ 0 ] >= 0 and now [ 0 ] + k [ 0 ] < h : <NEWLINE> <INDENT> now [ 0 ] += k [ 0 ] <NEWLINE> if now [ 1 ] + k [ 1 ] >= 0 and now [ 1 ] + k [ 1 ] < w : <NEWLINE> <INDENT> now [ 1 ] += k [ 1 ] <NEWLINE> if s [ now [ 0 ] ] [ now [ 1 ] ] == 10 ** 5 : <NEWLINE> <INDENT> if not [ now [ 0 ] , now [ 1 ] ] in steps : <NEWLINE> <INDENT> steps . append ( [ now [ 0 ] , now [ 1 ] ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if s [ steps [ 0 ] [ 0 ] ] [ steps [ 0 ] [ 1 ] ] > 10 ** 4 : <NEWLINE> <INDENT> direction = [ ] <NEWLINE> for l in [ [ 0 , 1 ] , [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] : <NEWLINE> <INDENT> if steps [ 0 ] [ 0 ] + l [ 0 ] >= 0 and steps [ 0 ] [ 0 ] + l [ 0 ] < h and steps [ 0 ] [ 1 ] + l [ 1 ] < w and steps [ 0 ] [ 1 ] + l [ 1 ] >= 0 and s [ steps [ 0 ] [ 0 ] + l [ 0 ] ] [ steps [ 0 ] [ 1 ] + l [ 1 ] ] != <STRING> : <NEWLINE> <INDENT> s [ steps [ 0 ] [ 0 ] ] [ steps [ 0 ] [ 1 ] ] = min ( s [ steps [ 0 ] [ 0 ] + l [ 0 ] ] [ steps [ 0 ] [ 1 ] + l [ 1 ] ] + 1 , s [ steps [ 0 ] [ 0 ] ] [ steps [ 0 ] [ 1 ] ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> steps . pop ( 0 ) <NEWLINE> <DEDENT> if s [ h - 1 ] [ w - 1 ] == <STRING> or s [ h - 1 ] [ w - 1 ] == 10 ** 5 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( white - 1 - s [ h - 1 ] [ w - 1 ] ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n , m = [ int ( w ) for w in input ( ) . split ( ) ] <NEWLINE> ls = [ [ int ( w ) for w in input ( ) . split ( ) ] for _ in range ( n ) ] <NEWLINE> lp = [ [ int ( w ) for w in input ( ) . split ( ) ] for _ in range ( m ) ] <NEWLINE> <NL> for a , b in ls : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> dist = 10e10 <NEWLINE> for i , ( c , d ) in enumerate ( lp ) : <NEWLINE> <INDENT> d = abs ( a - c ) + abs ( b - d ) <NEWLINE> if d < dist : <NEWLINE> <INDENT> ans = i <NEWLINE> dist = d <NEWLINE> <DEDENT> <DEDENT> print ( ans + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> A_ = sorted ( A ) <NEWLINE> max1 = A_ [ - 1 ] <NEWLINE> max2 = A_ [ - 2 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == max1 : <NEWLINE> <INDENT> print ( max2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max1 ) <NEWLINE> <DEDENT> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> m = [ ] <NEWLINE> for _ in range ( h ) : m . append ( list ( input ( ) ) ) <NEWLINE> black = 0 <NEWLINE> white = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if m [ i ] [ j ] == <STRING> : black += 1 <NEWLINE> <DEDENT> <DEDENT> white = h * w - black <NEWLINE> node = [ [ 0 , 0 , 1 ] ] <NEWLINE> dx , dy = [ - 1 , 0 , 1 , 0 ] , [ 0 , 1 , 0 , - 1 ] <NEWLINE> while node : <NEWLINE> <INDENT> temp = node . pop ( 0 ) <NEWLINE> if temp [ 0 ] == h - 1 and temp [ 1 ] == w - 1 : <NEWLINE> <INDENT> print ( h * w - black - temp [ 2 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> m [ temp [ 0 ] ] [ temp [ 1 ] ] = <STRING> <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if 0 <= temp [ 0 ] + dx [ i ] < h and 0 <= temp [ 1 ] + dy [ i ] < w : <NEWLINE> <INDENT> if m [ temp [ 0 ] + dx [ i ] ] [ temp [ 1 ] + dy [ i ] ] == <STRING> : <NEWLINE> <INDENT> node . append ( [ temp [ 0 ] + dx [ i ] , temp [ 1 ] + dy [ i ] , temp [ 2 ] + 1 ] ) <NEWLINE> m [ temp [ 0 ] + dx [ i ] ] [ temp [ 1 ] + dy [ i ] ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
import bisect as bs <NEWLINE> N , K = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> A = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> f = lambda X , x : bs . bisect_right ( X , x ) - bs . bisect_left ( X , x ) <NEWLINE> cnt = sorted ( [ f ( A , a ) for a in set ( A ) ] , reverse = True ) <NEWLINE> vrt = len ( cnt ) <NEWLINE> print ( sum ( cnt [ K : ] ) if vrt > K else 0 ) <NEWLINE>
a = list ( input ( ) ) <NEWLINE> <NL> sign = <STRING> <NEWLINE> <NL> for i in range ( 2 ) : <COMMENT> <NEWLINE> <INDENT> for j in range ( 2 ) : <COMMENT> <NEWLINE> <INDENT> for k in range ( 2 ) : <COMMENT> <NEWLINE> <INDENT> if eval ( a [ 0 ] + sign [ i ] + a [ 1 ] + sign [ j ] + a [ 2 ] + sign [ k ] + a [ 3 ] ) == 7 : <NEWLINE> <INDENT> print ( str ( a [ 0 ] + sign [ i ] + a [ 1 ] + sign [ j ] + a [ 2 ] + sign [ k ] + a [ 3 ] ) + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> if S - i - j <= K and 0 <= S - i - j : ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> law_ans = 0 <NEWLINE> absminA = float ( <STRING> ) <NEWLINE> for a in A : <NEWLINE> <INDENT> law_ans += abs ( a ) <NEWLINE> absminA = min ( absminA , abs ( a ) ) <NEWLINE> <NL> <NL> <DEDENT> cnt_neg = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> cnt_neg += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt_0 = A . count ( 0 ) <NEWLINE> <NL> if cnt_0 == 0 : <NEWLINE> <INDENT> if cnt_neg % 2 == 0 : <NEWLINE> <INDENT> print ( law_ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( law_ans - 2 * absminA ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( law_ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l_ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l_ls . sort ( ) <NEWLINE> def check ( a , b , c ) : <NEWLINE> <INDENT> return abs ( a - b ) < c < a + b <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> short = l_ls [ i ] <NEWLINE> num = 0 <NEWLINE> r = i + 1 <NEWLINE> for l in range ( i + 1 , n ) : <NEWLINE> <INDENT> while r + 1 < n and check ( short , l_ls [ l ] , l_ls [ r + 1 ] ) : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> num += r - l <NEWLINE> if r == l : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> <DEDENT> ans += num <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> <NL> def merge ( array ) : <COMMENT> <NEWLINE> <INDENT> mid = len ( array ) <COMMENT> <NEWLINE> if mid > 1 : <COMMENT> <NEWLINE> <INDENT> left = merge ( array [ : ( mid // 2 ) ] ) <COMMENT> <NEWLINE> right = merge ( array [ ( mid // 2 ) : ] ) <COMMENT> <NEWLINE> array = [ ] <COMMENT> <NEWLINE> while len ( left ) != 0 and len ( right ) != 0 : <COMMENT> <NEWLINE> <INDENT> if left [ 0 ] < right [ 0 ] : <COMMENT> <NEWLINE> <INDENT> array . append ( left . pop ( 0 ) ) <COMMENT> <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> array . append ( right . pop ( 0 ) ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> if len ( left ) != 0 : <COMMENT> <NEWLINE> <INDENT> array . extend ( left ) <COMMENT> <NEWLINE> <DEDENT> elif len ( right ) != 0 : <COMMENT> <NEWLINE> <INDENT> array . extend ( right ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> return array <NEWLINE> <NL> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> S . append ( a ) <NEWLINE> <DEDENT> L = merge ( S ) <NEWLINE> <NL> ans = - L [ 0 ] + L [ n - 1 ] <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> if - L [ i ] + L [ i + k - 1 ] < ans : <NEWLINE> <INDENT> ans = - L [ i ] + L [ i + k - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> def comb ( n , r ) : <NEWLINE> <INDENT> if n - r >= 0 : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> print ( comb ( n - k + 1 , i ) * comb ( k - 1 , i - 1 ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] - 1 ) <NEWLINE> a . append ( a [ i ] + 1 ) <NEWLINE> <NL> <DEDENT> cc = collections . Counter ( a ) <NEWLINE> ans = max ( list ( cc . values ( ) ) ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> dp = [ 0 ] * ( 100200 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> for i in range ( X + 1 ) : <NEWLINE> <INDENT> if dp [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( 6 ) : <NEWLINE> <INDENT> dp [ i + 100 + j ] = 1 <NEWLINE> if i + 100 + j == X : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE>
def cal ( ) : <NEWLINE> <INDENT> import queue <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> cost = [ [ - 1 ] * w for _ in range ( h ) ] <NEWLINE> INF = float ( <STRING> ) <NEWLINE> count , ans = 0 , INF <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] != <STRING> : <NEWLINE> <INDENT> cost [ i ] [ j ] = INF <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> q = queue . Queue ( ) <NEWLINE> q . put ( ( 0 , 0 , 1 ) ) <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> c0 , c1 , c2 = q . get ( ) <NEWLINE> s [ c0 ] [ c1 ] = <STRING> <NEWLINE> if c0 == h - 1 and c1 == w - 1 : <NEWLINE> <INDENT> return h * w - count - c2 <NEWLINE> <DEDENT> for i , j in ( ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ) : <NEWLINE> <INDENT> x , y = c0 + i , c1 + j <NEWLINE> if 0 <= x < h and 0 <= y < w : <NEWLINE> <INDENT> if s [ x ] [ y ] != <STRING> and cost [ x ] [ y ] == INF : <NEWLINE> <INDENT> cost [ x ] [ y ] = c2 + 1 <NEWLINE> q . put ( ( x , y , c2 + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> ans = cal ( ) <NEWLINE> if ans == float ( <STRING> ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> if n == 2 : <NEWLINE> <INDENT> print ( a [ 1 ] , a [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> x = a [ - 1 ] <NEWLINE> index = bisect . bisect_left ( a [ : n - 1 ] , x / 2 ) <NEWLINE> <NL> ans = [ ] <NEWLINE> ans . append ( [ abs ( x / 2 - a [ index - 1 ] ) , a [ index - 1 ] ] ) <NEWLINE> ans . append ( [ abs ( x / 2 - a [ index ] ) , a [ index ] ] ) <NEWLINE> ans . append ( [ abs ( x / 2 - a [ index + 1 ] ) , a [ index + 1 ] ] ) <NEWLINE> <NL> ans . sort ( ) <NEWLINE> <NL> print ( x , ans [ 0 ] [ 1 ] ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( A , min ( B , A + K - 1 ) + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( max ( B - K + 1 , A + K ) , B + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
a , b , c = input ( ) . split ( ) <NEWLINE> <NL> a = int ( a ) <NEWLINE> c = int ( c ) <NEWLINE> <NL> if b == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) + c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - c ) <NEWLINE> <DEDENT>
n = str ( input ( ) ) <NEWLINE> if n [ 0 ] == n [ 1 ] == n [ 2 ] or n [ 1 ] == n [ 2 ] == n [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = { } <NEWLINE> for v in a : <NEWLINE> <INDENT> if v in dic : <NEWLINE> <INDENT> dic [ v ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ v ] = 1 <NEWLINE> <DEDENT> <DEDENT> key = [ v for v in dic . keys ( ) ] <NEWLINE> key . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> for v in key : <NEWLINE> <INDENT> num = dic [ v ] <NEWLINE> if num > 0 : <NEWLINE> <INDENT> for i in reversed ( range ( 1 , 32 ) ) : <NEWLINE> <INDENT> target = 2 ** i <NEWLINE> if 2 * v < target : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if target < v : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> u = target - v <NEWLINE> if v == u : <NEWLINE> <INDENT> z = dic [ v ] // 2 <NEWLINE> ans += z <NEWLINE> dic [ v ] -= 2 * z <NEWLINE> <DEDENT> elif u in dic : <NEWLINE> <INDENT> x , y = dic [ v ] , dic [ u ] <NEWLINE> z = 0 <NEWLINE> if x < y : <NEWLINE> <INDENT> z = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = y <NEWLINE> <DEDENT> dic [ v ] -= z <NEWLINE> dic [ u ] -= z <NEWLINE> ans += z <NEWLINE> <DEDENT> if dic [ v ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> def substring ( S ) : <NEWLINE> <INDENT> N = len ( S ) <NEWLINE> ls = [ ] <NEWLINE> for i in range ( 1 , min ( 6 , N + 1 ) ) : <NEWLINE> <INDENT> for j in range ( 0 , N - i + 1 ) : <NEWLINE> <INDENT> ls . append ( S [ j : j + i ] ) <NEWLINE> <DEDENT> <DEDENT> setls = set ( ls ) <NEWLINE> ls = list ( setls ) <NEWLINE> ls . sort ( ) <NEWLINE> return ls <NEWLINE> <DEDENT> print ( substring ( s ) [ K - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( input ( ) . split ( ) ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> B = A [ : : - 1 ] <NEWLINE> print ( <STRING> . join ( B [ : : 2 ] ) + <STRING> + <STRING> . join ( A [ : : 2 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = A [ : : - 1 ] <NEWLINE> A = A [ 1 : : 2 ] <NEWLINE> print ( <STRING> . join ( B [ : : 2 ] ) + <STRING> + <STRING> . join ( A [ : ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> xyh = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> if xyh [ 0 ] [ 2 ] : <NEWLINE> <INDENT> x , y , h = xyh [ 0 ] <NEWLINE> <DEDENT> if xyh [ 1 ] [ 2 ] : <NEWLINE> <INDENT> x , y , h = xyh [ 1 ] <NEWLINE> <DEDENT> if xyh [ - 1 ] [ 2 ] : <NEWLINE> <INDENT> x , y , h = xyh [ - 1 ] <NEWLINE> <DEDENT> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> k = h + abs ( i - x ) + abs ( j - y ) <NEWLINE> if all ( h == max ( k - abs ( i - x ) - abs ( j - y ) , 0 ) for x , y , h in xyh ) : <NEWLINE> <INDENT> print ( i , j , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> l1 = list ( int ( l ) + i - 1 for i in range ( 1 , n + 1 ) ) <NEWLINE> n1 = sum ( l1 ) <NEWLINE> ans = min ( l1 , key = abs ) <NEWLINE> <NL> print ( n1 - ( ans ) ) <NEWLINE>
import numpy as np <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l . append ( ( 1 + p [ i ] ) / 2 ) <NEWLINE> <NL> <DEDENT> a = [ 0 ] * N <NEWLINE> a [ 0 ] = l [ 0 ] <NEWLINE> for i in range ( 1 , len ( l ) ) : <NEWLINE> <INDENT> a [ i ] = a [ i - 1 ] + l [ i ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( K , len ( l ) ) : <NEWLINE> <INDENT> ans = max ( ans , a [ i ] - a [ i - K ] ) <NEWLINE> <NL> <DEDENT> if N == 1 or N - K == 0 : <NEWLINE> <INDENT> print ( max ( a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> if N [ 1 : ] == <STRING> * ( len ( N ) - 1 ) : <NEWLINE> <INDENT> ans = int ( N [ 0 ] ) + ( 9 * ( len ( N ) - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = int ( N [ 0 ] ) + 9 * ( len ( N ) - 1 ) - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , T = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ 0 ] * n <NEWLINE> t = [ 0 ] * n <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c [ i ] , t [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> if t [ i ] <= T : <NEWLINE> <INDENT> ans . append ( c [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( ans ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( min ( ans ) ) <NEWLINE>
from sys import setrecursionlimit <NEWLINE> <NL> def find ( parent , i ) : <NEWLINE> <INDENT> t = parent [ i ] <NEWLINE> if t < 0 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> t = find ( parent , t ) <NEWLINE> parent [ i ] = t <NEWLINE> return t <NEWLINE> <NL> <DEDENT> def unite ( parent , i , j ) : <NEWLINE> <INDENT> i = find ( parent , i ) <NEWLINE> j = find ( parent , j ) <NEWLINE> if i == j : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> parent [ j ] += parent [ i ] <NEWLINE> parent [ i ] = j <NEWLINE> <NL> <DEDENT> setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ [ int ( c ) - 1 for c in input ( ) . split ( ) ] for _ in range ( M ) ] <NEWLINE> <NL> parent = [ - 1 ] * N <NEWLINE> inconvenience = N * ( N - 1 ) // 2 <NEWLINE> result = [ ] <NEWLINE> for a , b in AB [ : : - 1 ] : <NEWLINE> <INDENT> result . append ( inconvenience ) <NEWLINE> pa , pb = find ( parent , a ) , find ( parent , b ) <NEWLINE> if pa != pb : <NEWLINE> <INDENT> inconvenience -= parent [ pa ] * parent [ pb ] <NEWLINE> <DEDENT> unite ( parent , a , b ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( result ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> print ( result [ i ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> h . sort ( reverse = True ) <NEWLINE> t = 0 <NEWLINE> <NL> del h [ 0 : k ] <NEWLINE> <NL> if len ( h ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t += sum ( h ) <NEWLINE> print ( t ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> s = input ( ) <NEWLINE> for j in s : <NEWLINE> <INDENT> temp += ( 12 ** ( ord ( j ) - ord ( <STRING> ) + 1 ) ) <NEWLINE> <DEDENT> dic . setdefault ( temp , 0 ) <NEWLINE> dic [ temp ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> res = 0 <NEWLINE> for i in dic : <NEWLINE> <INDENT> if dic [ i ] >= 2 : <NEWLINE> <INDENT> res += ( ( dic [ i ] * ( dic [ i ] - 1 ) ) // 2 ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> s = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> Max = sum ( s ) <NEWLINE> s . sort ( ) <NEWLINE> <NL> if Max % 10 == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] % 10 != 0 : <NEWLINE> <INDENT> Max -= s [ i ] <NEWLINE> <DEDENT> if Max % 10 != 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if Max % 10 == 0 : <NEWLINE> <INDENT> Max = 0 <NEWLINE> <NL> <DEDENT> print ( Max ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> butnum = { } <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> butnum [ i ] = int ( input ( ) ) <NEWLINE> <DEDENT> pushbut = 1 <NEWLINE> pushedbut = [ ] <NEWLINE> jud = 0 <NEWLINE> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> pushbut = butnum [ pushbut ] <NEWLINE> if pushbut == 2 : <NEWLINE> <INDENT> print ( j ) <NEWLINE> jud = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if jud == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> cumsum = [ 0 ] * N <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i - 1 ] == <STRING> and S [ i ] == <STRING> : <NEWLINE> <INDENT> cumsum [ i ] = cumsum [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cumsum [ i ] = cumsum [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( cumsum [ r - 1 ] - cumsum [ l - 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = sorted ( d ) <NEWLINE> print ( d [ N // 2 ] - d [ ( N // 2 ) - 1 ] ) <NEWLINE>
import sys , math , collections , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> min_child = 2 <NEWLINE> max_child = 2 <NEWLINE> <NL> for i in range ( K - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if math . ceil ( min_child / A [ i ] ) > 0 and math . floor ( max_child / A [ i ] ) > 0 and math . floor ( max_child / A [ i ] ) - math . ceil ( min_child / A [ i ] ) >= 0 : <NEWLINE> <INDENT> min_child = math . ceil ( min_child / A [ i ] ) * A [ i ] <NEWLINE> max_child = math . floor ( max_child / A [ i ] ) * A [ i ] + A [ i ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( min_child , max_child ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> lsab = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> lsab . append ( [ a , b ] ) <NEWLINE> <DEDENT> lscd = [ ] <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> lscd . append ( [ c , d ] ) <NEWLINE> <NL> <DEDENT> lsans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> max1 = 4 * 10 ** 8 + 100 <NEWLINE> ans = 0 <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> dis = abs ( lsab [ i ] [ 0 ] - lscd [ j ] [ 0 ] ) + abs ( lsab [ i ] [ 1 ] - lscd [ j ] [ 1 ] ) <NEWLINE> if dis < max1 : <NEWLINE> <INDENT> ans = j + 1 <NEWLINE> max1 = dis <NEWLINE> <DEDENT> <DEDENT> lsans . append ( ans ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( lsans [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> sign = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans [ 0 ] += sign * a <NEWLINE> sign *= - 1 <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans [ i ] = 2 * A [ 0 ] - ans [ i - 1 ] <NEWLINE> <NL> t = A . pop ( 0 ) <NEWLINE> A . append ( t ) <NEWLINE> <NL> <DEDENT> print ( * ans ) <NEWLINE>
import heapq as hp <NEWLINE> import numpy as np <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = np . array ( [ list ( input ( ) ) for _ in range ( h ) ] ) <NEWLINE> s = np . pad ( s , 1 , <STRING> ) <NEWLINE> visited = np . zeros_like ( s , dtype = np . bool ) <NEWLINE> <NL> judge = np . inf <NEWLINE> <NL> q = [ ] <NEWLINE> hp . heappush ( q , ( 0 , 1 , 1 ) ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> cnt , y , x = hp . heappop ( q ) <NEWLINE> if y == h and x == w : <NEWLINE> <INDENT> judge = cnt <NEWLINE> break <NEWLINE> <DEDENT> for dy , dx in [ [ 0 , 1 ] , [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] : <NEWLINE> <INDENT> ny , nx = y + dy , x + dx <NEWLINE> if s [ ny , nx ] == <STRING> and not visited [ ny , nx ] : <NEWLINE> <INDENT> visited [ ny , nx ] = True <NEWLINE> hp . heappush ( q , ( cnt + 1 , ny , nx ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if judge == np . inf : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( s == <STRING> ) . sum ( ) - judge - 1 ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> import sys <NEWLINE> <NL> N , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> T = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> T . sort ( ) <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> <NL> if T [ 0 ] + K >= T [ - 1 ] : <NEWLINE> <INDENT> if N % C == 0 : <NEWLINE> <INDENT> print ( N // C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N // C + 1 ) <NEWLINE> <DEDENT> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> t = bisect . bisect_right ( T , T [ i ] + K ) <NEWLINE> if t - i > C : <NEWLINE> <INDENT> i += C <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = t <NEWLINE> <DEDENT> ans += 1 <NEWLINE> if i == N - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> if i > N - 1 : <NEWLINE> <INDENT> i = N - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from numpy import * <NEWLINE> N , M , * U = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> T = array ( U [ N : ] ) <NEWLINE> p = ones ( M + 1 , dtype = <STRING> ) <NEWLINE> for s in U [ : N ] : p [ 1 : ] = ( ( p [ : - 1 ] * ( s == T ) ) . cumsum ( ) + p [ 1 : ] ) % ( 10 ** 9 + 7 ) <NEWLINE> print ( p [ - 1 ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> pre = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> p , y = map ( int , input ( ) . split ( ) ) <NEWLINE> pre [ p - 1 ] . append ( [ y , _ , p ] ) <NEWLINE> <DEDENT> for p in range ( n ) : <NEWLINE> <INDENT> pre [ p ] . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> for i in range ( len ( pre [ p ] ) ) : <NEWLINE> <INDENT> pre [ p ] [ i ] . append ( i ) <NEWLINE> <DEDENT> <DEDENT> lis = [ ] <NEWLINE> for i in pre : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> lis . append ( j ) <NEWLINE> <DEDENT> <DEDENT> lis . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> for i in lis : print ( <STRING> . format ( i [ 2 ] , i [ 3 ] + 1 ) ) <NEWLINE>
N = input ( ) <NEWLINE> N = int ( N ) <NEWLINE> S = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> and S [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( 10 ) : <NEWLINE> <INDENT> for y in range ( 10 ) : <NEWLINE> <INDENT> hantei = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if x != int ( S [ i ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if y != int ( S [ j ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> hantei . append ( S [ k ] ) <NEWLINE> <DEDENT> ans += len ( Counter ( hantei ) ) <NEWLINE> break <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> a = set ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s = int ( input ( ) ) <NEWLINE> a . add ( s ) <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % mod <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if len ( set ( a ) ) == 1 and a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if N % 3 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> import collections <NEWLINE> sa = list ( set ( a ) ) <NEWLINE> sa . sort ( ) <NEWLINE> B = collections . Counter ( a ) <NEWLINE> <NL> if len ( sa ) == 2 and 0 in sa : <NEWLINE> <INDENT> if B [ 0 ] == N // 3 and B [ sa [ 1 ] ] == N * 2 // 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if len ( sa ) != 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if B [ sa [ 0 ] ] == B [ sa [ 1 ] ] == B [ sa [ 2 ] ] : <NEWLINE> <INDENT> print ( <STRING> if sa [ 0 ] ^ sa [ 1 ] == sa [ 2 ] else <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = 1 <NEWLINE> ans = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if i == n : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
from bisect import bisect_left , bisect_right <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> cnt += bisect_left ( A , b ) * ( N - bisect_right ( C , b ) ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ans = ( 1 + ( N - 1 ) ) * ( N - 1 ) // 2 <NEWLINE> <NL> print ( ans ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> a . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> n = 0 <NEWLINE> ans = [ ] <NEWLINE> for y in range ( H ) : <NEWLINE> <INDENT> if y % 2 == 0 : <NEWLINE> <INDENT> for x in range ( W - 1 ) : <NEWLINE> <INDENT> if a [ y ] [ x ] & 1 : <NEWLINE> <INDENT> a [ y ] [ x + 1 ] += 1 <NEWLINE> n += 1 <NEWLINE> ans . append ( <STRING> . format ( y + 1 , x + 1 , y + 1 , x + 2 ) ) <NEWLINE> <DEDENT> <DEDENT> if y != H - 1 and ( a [ y ] [ W - 1 ] & 1 ) : <NEWLINE> <INDENT> a [ y + 1 ] [ W - 1 ] += 1 <NEWLINE> n += 1 <NEWLINE> ans . append ( <STRING> . format ( y + 1 , W , y + 2 , W ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for x in range ( W - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if a [ y ] [ x ] & 1 : <NEWLINE> <INDENT> a [ y ] [ x - 1 ] += 1 <NEWLINE> n += 1 <NEWLINE> ans . append ( <STRING> . format ( y + 1 , x + 1 , y + 1 , x ) ) <NEWLINE> <DEDENT> <DEDENT> if y != H - 1 and ( a [ y ] [ 0 ] & 1 ) : <NEWLINE> <INDENT> a [ y + 1 ] [ 0 ] += 1 <NEWLINE> n += 1 <NEWLINE> ans . append ( <STRING> . format ( y + 1 , 1 , y + 2 , 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( n ) <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> min_i = 1 <NEWLINE> max_i = n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> min_i = max ( min_i , l ) <NEWLINE> max_i = min ( max_i , r ) <NEWLINE> <NL> <DEDENT> if max_i - min_i >= 0 : <NEWLINE> <INDENT> print ( max_i - min_i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
g = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] <NEWLINE> <NL> tmp = input ( ) . split ( <STRING> ) <NEWLINE> print ( <STRING> ) if g [ int ( tmp [ 0 ] ) - 1 ] == g [ int ( tmp [ 1 ] ) - 1 ] else print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> B = sorted ( A ) [ : N - 1 ] <NEWLINE> m = max ( A ) <NEWLINE> n = A . index ( max ( A ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i != n : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( B ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> gates = [ ] <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> gates = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> min_data = 0 <NEWLINE> max_data = 10 ** 5 + 1 <NEWLINE> <NL> for gate in gates : <NEWLINE> <INDENT> if min_data < gate [ 0 ] : <NEWLINE> <INDENT> min_data = min ( gate ) <NEWLINE> <DEDENT> if max_data > gate [ 1 ] : <NEWLINE> <INDENT> max_data = max ( gate ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( list ( range ( min_data , max_data + 1 ) ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> def expected_val ( limit ) : <NEWLINE> <INDENT> return ( 1 + limit ) / 2 <NEWLINE> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> lst = [ 0 ] <NEWLINE> res = 0 <NEWLINE> for p in P : <NEWLINE> <COMMENT> <NL> <INDENT> res += expected_val ( p ) <NEWLINE> lst . append ( res ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> res = lst [ i + K ] - lst [ i ] <NEWLINE> ans = res if res > ans else ans <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> push , pop = heapq . heappush , heapq . heappop <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def modify ( ) : <NEWLINE> <INDENT> heapq . heapify ( a ) <NEWLINE> <NL> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> bc . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> for b , c in bc : <NEWLINE> <INDENT> for _ in range ( b ) : <NEWLINE> <INDENT> p = pop ( a ) <NEWLINE> if p < c : <NEWLINE> <INDENT> push ( a , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> push ( a , p ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> modify ( ) <NEWLINE> print ( sum ( a ) ) <NEWLINE>
<COMMENT> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> s . append ( list ( <STRING> for i in range ( w + 2 ) ) ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s . append ( list ( <STRING> + input ( ) + <STRING> ) ) <NEWLINE> <DEDENT> s . append ( list ( <STRING> for i in range ( w + 2 ) ) ) <NEWLINE> ans = [ [ 0 for j in range ( w ) ] for i in range ( h ) ] <NEWLINE> <NL> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> if s [ i ] [ j ] != <STRING> : <NEWLINE> <INDENT> for m in range ( i - 1 , i + 2 ) : <NEWLINE> <INDENT> for n in range ( j - 1 , j + 2 ) : <NEWLINE> <INDENT> if s [ m ] [ n ] == <STRING> : <NEWLINE> <INDENT> ans [ i - 1 ] [ j - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans [ i - 1 ] [ j - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> ans [ i ] [ j ] = str ( ans [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> . join ( ans [ i ] ) ) <NEWLINE> <DEDENT>
def totalcost_recur ( i , cost , N , lookup ) : <NEWLINE> <INDENT> if i >= N : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if i in lookup : <NEWLINE> <INDENT> return lookup [ i ] <NEWLINE> <DEDENT> option1 = abs ( cost [ i ] - cost [ i + 1 ] ) + totalcost_recur ( i + 1 , cost , N , lookup ) <NEWLINE> ans = option1 <NEWLINE> if i + 2 <= N : <NEWLINE> <INDENT> option2 = abs ( cost [ i ] - cost [ i + 2 ] ) + totalcost_recur ( i + 2 , cost , N , lookup ) <NEWLINE> ans = min ( option2 , ans ) <NEWLINE> <DEDENT> lookup [ i ] = ans <NEWLINE> return ans <NEWLINE> <NL> <NL> <NL> <DEDENT> def totalcost_dp ( cost , N ) : <NEWLINE> <INDENT> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 1 ] = 0 <NEWLINE> dp [ 2 ] = abs ( cost [ 2 ] - cost [ 1 ] ) <NEWLINE> i = 3 <NEWLINE> while i <= N : <NEWLINE> <INDENT> option1 = dp [ i - 1 ] + abs ( cost [ i ] - cost [ i - 1 ] ) <NEWLINE> option2 = dp [ i - 2 ] + abs ( cost [ i ] - cost [ i - 2 ] ) <NEWLINE> dp [ i ] = min ( option1 , option2 ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> return dp [ N ] <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> cost = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cost = [ 0 ] + cost <NEWLINE> lookup = { } <NEWLINE> <NL> print ( totalcost_dp ( cost , n ) ) <NEWLINE>
import math <NEWLINE> from itertools import groupby <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = [ <STRING> . join ( sorted ( input ( ) ) ) for i in range ( N ) ] <NEWLINE> sizes = [ len ( list ( v ) ) for k , v in groupby ( sorted ( S ) ) ] <NEWLINE> <NL> <NL> def combinations_count ( n , r ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <NL> <DEDENT> ans = sum ( [ combinations_count ( size , 2 ) for size in sizes ] ) <NEWLINE> print ( ans ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 1 <NEWLINE> var = var2 = 0 <NEWLINE> c = l [ 0 ] <NEWLINE> for i in l [ 1 : ] : <NEWLINE> <INDENT> if c < i : <NEWLINE> <INDENT> var = 1 <NEWLINE> <DEDENT> elif c > i : <NEWLINE> <INDENT> var2 = 1 <NEWLINE> <DEDENT> if var == 1 and var2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> var = var2 = 0 <NEWLINE> <DEDENT> c = i <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
( h , n ) , * t = [ list ( map ( int , o . split ( ) ) ) for o in open ( 0 ) ] <NEWLINE> d = [ 0 ] * ( h + 9999 ) <NEWLINE> for i in range ( 1 , h + 1 ) : d [ i ] = min ( d [ i - a ] + b for a , b in t ) <NEWLINE> print ( d [ h ] ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans1 = 0 <NEWLINE> ans2 = 0 <NEWLINE> ans3 = 0 <NEWLINE> <NL> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( i , k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - i - j <= k and j <= s - i - j : <NEWLINE> <INDENT> if i == j == s - i - j : <NEWLINE> <INDENT> ans1 += 1 <NEWLINE> <DEDENT> elif i == s - i - j or i == j or j == s - i - j : <NEWLINE> <INDENT> ans2 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans3 += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans1 + ans2 * 3 + ans3 * 6 ) <NEWLINE> <COMMENT> <NL>
N = int ( input ( ) ) <NEWLINE> d = [ ] <NEWLINE> visited = [ False for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> d . append ( int ( input ( ) ) - 1 ) <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif cnt >= N : <NEWLINE> <INDENT> cnt = - 1 <NEWLINE> break <NEWLINE> <DEDENT> elif visited [ i ] : <NEWLINE> <INDENT> cnt = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited [ i ] = True <NEWLINE> cnt += 1 <NEWLINE> i = d [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> b1 = [ ] <NEWLINE> b2 = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> b1 . append ( b ) <NEWLINE> <DEDENT> if b == n : <NEWLINE> <INDENT> b2 . append ( a ) <NEWLINE> <DEDENT> <DEDENT> if len ( b1 ) + len ( b2 ) == len ( list ( set ( b1 + b2 ) ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def get_input ( ) -> tuple : <NEWLINE> <INDENT> <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> return N , A , B , C <NEWLINE> <NL> <NL> <DEDENT> def get_lb ( l : list , key : int ) -> int : <NEWLINE> <INDENT> <STRING> <NEWLINE> low = - 1 <NEWLINE> high = len ( l ) <NEWLINE> while 1 < high - low : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> guess = l [ mid ] <NEWLINE> if guess > key : <NEWLINE> <INDENT> high = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid <NEWLINE> <DEDENT> <DEDENT> return high <NEWLINE> <NL> <NL> <DEDENT> def get_ub ( l : list , key : int ) -> int : <NEWLINE> <INDENT> <STRING> <NEWLINE> low = - 1 <NEWLINE> high = len ( l ) <NEWLINE> while 1 < high - low : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> guess = l [ mid ] <NEWLINE> if guess < key : <NEWLINE> <INDENT> low = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> high = mid <NEWLINE> <DEDENT> <DEDENT> return low <NEWLINE> <NL> <NL> <DEDENT> def main ( N : int , A : list , B : list , C : list ) -> None : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> A = sorted ( A ) <NEWLINE> B = sorted ( B ) <NEWLINE> C = sorted ( C ) <NEWLINE> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B_i = B [ i ] <NEWLINE> ans += ( get_ub ( A , B_i ) + 1 ) * ( N - get_lb ( C , B_i ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> N , A , B , C = get_input ( ) <NEWLINE> <NL> <COMMENT> <NL> main ( N , A , B , C ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def lcm ( X , Y ) : <NEWLINE> <INDENT> x = X <NEWLINE> y = Y <NEWLINE> if y > x : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> while x % y != 0 : <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <DEDENT> return X * Y // y <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> LCM = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> Q = lcm ( LCM , A [ i ] ) <NEWLINE> cnt *= Q // LCM <NEWLINE> LCM = Q <NEWLINE> cnt += Q // A [ i ] <NEWLINE> <DEDENT> print ( cnt % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> al = list ( int ( input ( ) ) for _ in range ( n ) ) <NEWLINE> num = [ 0 ] * n <NEWLINE> i = 0 <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if al [ i ] == 2 : <NEWLINE> <INDENT> print ( cnt + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if num [ al [ i ] - 1 ] == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num [ al [ i ] - 1 ] += 1 <NEWLINE> i = al [ i ] - 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> prime_list = factorization ( p ) <NEWLINE> ans = 1 <NEWLINE> for x in prime_list : <NEWLINE> <INDENT> ans *= x [ 0 ] ** ( x [ 1 ] // n ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> N = len ( S ) <NEWLINE> p = S [ 0 ] <NEWLINE> c = 0 <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( K // 2 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if len ( set ( S ) ) == 1 : <NEWLINE> <INDENT> print ( N * K // 2 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i ] == p : <NEWLINE> <INDENT> c += 1 <NEWLINE> p = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = S [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = c * K <NEWLINE> if S [ 0 ] == S [ - 1 ] : <NEWLINE> <INDENT> p = S [ 0 ] <NEWLINE> c = 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if p == S [ i ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> d = 1 <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if p == S [ - i ] : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( c % 2 ) * ( d % 2 ) == 1 : <NEWLINE> <INDENT> ans += K - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = input ( ) <NEWLINE> for i in range ( a + b + 1 ) : <NEWLINE> <INDENT> if i == a : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if int ( s [ i ] ) < 0 or 9 < int ( s [ i ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> inf = float ( <STRING> ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> alst = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> alst [ i ] [ i ] = inf <NEWLINE> <NL> <DEDENT> sm = 0 <NEWLINE> token = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> for k in range ( n ) : <NEWLINE> <INDENT> if alst [ i ] [ k ] + alst [ k ] [ j ] > alst [ i ] [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif alst [ i ] [ k ] + alst [ k ] [ j ] == alst [ i ] [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> token = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> sm += alst [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if token : sm = - 1 <NEWLINE> <NL> print ( sm ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from itertools import groupby , accumulate , product , permutations , combinations <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( reverse = True ) <NEWLINE> ans = sum ( L [ : K ] ) <NEWLINE> return ans <NEWLINE> <DEDENT> print ( solve ( ) ) <NEWLINE>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if any ( i % 2 == 0 for i in [ A , B , C ] ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( A * B , B * C , C * A ) ) <NEWLINE> <DEDENT>
s = input ( ) . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in s [ : : - 1 ] : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> ans += cnt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> x = a [ - 1 ] <NEWLINE> ans = a [ - 1 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> x = a [ - 1 - i ] <NEWLINE> <DEDENT> e = x - 1 <NEWLINE> if e > a [ - 1 - i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> elif e < a [ - 1 - i ] : <NEWLINE> <INDENT> x = a [ - 1 - i ] <NEWLINE> ans += a [ - 1 - i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> <DEDENT> if x == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import numpy as np <NEWLINE> <NL> <COMMENT> <NL> <NL> def check ( a , b , c ) : <NEWLINE> <INDENT> flag = True <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> if c [ i ] [ j ] != a [ i ] + b [ j ] : <NEWLINE> <INDENT> flag = False <NEWLINE> return flag <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return flag <NEWLINE> <NL> <DEDENT> c = [ ] <NEWLINE> c . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> c . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> c . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> arr_c = np . array ( c ) <NEWLINE> a_max = np . amax ( arr_c , axis = 1 ) <NEWLINE> b_max = np . amax ( arr_c , axis = 0 ) <NEWLINE> <NL> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if len ( list ( range ( 0 , a_max [ i ] + 1 , 1 ) ) ) == 0 : <NEWLINE> <INDENT> a . append ( [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( list ( range ( 0 , a_max [ i ] + 1 , 1 ) ) ) <NEWLINE> <NL> <DEDENT> if len ( list ( range ( 0 , b_max [ i ] + 1 , 1 ) ) ) == 0 : <NEWLINE> <INDENT> b . append ( [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( list ( range ( 0 , b_max [ i ] + 1 , 1 ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> cnt = 0 <NEWLINE> for a0 in a [ 0 ] : <NEWLINE> <INDENT> for b0 in b [ 0 ] : <NEWLINE> <INDENT> if c [ 0 ] [ 0 ] != a0 + b0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for a1 in a [ 1 ] : <NEWLINE> <INDENT> if c [ 1 ] [ 0 ] != a1 + b0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for b1 in b [ 1 ] : <NEWLINE> <INDENT> if c [ 0 ] [ 1 ] != a0 + b1 or c [ 1 ] [ 1 ] != a1 + b1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for a2 in a [ 2 ] : <NEWLINE> <INDENT> if c [ 2 ] [ 0 ] != a2 + b0 or c [ 2 ] [ 1 ] != a2 + b1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for b2 in b [ 2 ] : <NEWLINE> <INDENT> if c [ 0 ] [ 2 ] != a0 + b2 or c [ 1 ] [ 2 ] != a1 + b2 or c [ 2 ] [ 2 ] != a2 + b2 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <NL> g = None <NEWLINE> memo = None <NEWLINE> <NL> <NL> def f ( x ) : <NEWLINE> <INDENT> if memo [ x ] == - 1 : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for y in g [ x ] : <NEWLINE> <INDENT> ret = max ( ret , f ( y ) + 1 ) <NEWLINE> <DEDENT> memo [ x ] = ret <NEWLINE> <DEDENT> return memo [ x ] <NEWLINE> <NL> <NL> <DEDENT> def resolve ( in_ ) : <NEWLINE> <INDENT> global g , memo <NEWLINE> n , m = map ( int , next ( in_ ) . split ( ) ) <NEWLINE> _g = defaultdict ( list ) <NEWLINE> for line in in_ : <NEWLINE> <INDENT> x , y = map ( int , line . split ( ) ) <NEWLINE> _g [ x - 1 ] . append ( y - 1 ) <NEWLINE> <DEDENT> g = _g <NEWLINE> memo = [ - 1 ] * 100000 <NEWLINE> return max ( f ( i ) for i in range ( n ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> sys . setrecursionlimit ( 1000000 ) <NEWLINE> ans = resolve ( sys . stdin . buffer ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> prev = <STRING> <NEWLINE> curr = <STRING> <NEWLINE> for s in S : <NEWLINE> <INDENT> curr += s <NEWLINE> if prev != curr : <NEWLINE> <INDENT> ans += 1 <NEWLINE> prev = curr <NEWLINE> curr = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> from bisect import bisect_left <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ld = deque ( l ) <NEWLINE> cnt = 0 <NEWLINE> for a in range ( n - 2 ) : <NEWLINE> <INDENT> l_a = ld . popleft ( ) <NEWLINE> for b in range ( a + 1 , n - 1 ) : <NEWLINE> <INDENT> cnt += bisect_left ( l , l_a + l [ b ] ) - b - 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from collections import deque , defaultdict <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> ref = defaultdict ( list ) <NEWLINE> q = deque ( [ ] ) <NEWLINE> visited = set ( ) <NEWLINE> inf = 10 ** 10 <NEWLINE> dist = [ - inf ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> ref [ ( a , b ) ] = k <NEWLINE> <NL> <NL> <DEDENT> def dfs ( u ) : <NEWLINE> <INDENT> q . append ( u ) <NEWLINE> while q : <NEWLINE> <INDENT> v = q . pop ( ) <NEWLINE> visited . add ( v ) <NEWLINE> for x in g [ v ] : <NEWLINE> <INDENT> if x not in visited : <NEWLINE> <INDENT> if ref [ ( v , x ) ] != [ ] : <NEWLINE> <INDENT> y = ref . get ( ( v , x ) ) <NEWLINE> if dist [ x ] == - inf : <NEWLINE> <INDENT> dist [ x ] = dist [ v ] + y <NEWLINE> <DEDENT> elif dist [ x ] != dist [ v ] + y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> y = ref . get ( ( x , v ) ) <NEWLINE> if dist [ x ] == - inf : <NEWLINE> <INDENT> dist [ x ] = dist [ v ] - y <NEWLINE> <DEDENT> elif dist [ v ] != dist [ x ] + y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> q . append ( x ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i not in visited : <NEWLINE> <INDENT> dist [ i ] = 1 <NEWLINE> dfs ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ab = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> ab . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> a , b = ab [ i ] [ 0 ] , ab [ i ] [ 1 ] <NEWLINE> num = a + cnt <NEWLINE> if num % b == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> amari = num % b <NEWLINE> cnt += b - amari <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( range ( 1 , N + 1 ) ) <NEWLINE> <NL> A = dict ( zip ( A , B ) ) <NEWLINE> A = sorted ( A . items ( ) ) <NEWLINE> ans = [ str ( x [ 1 ] ) for x in A ] <NEWLINE> <NL> <NL> print ( <STRING> . join ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = len ( lst ) <NEWLINE> lst = list ( set ( lst ) ) <NEWLINE> y = len ( lst ) <NEWLINE> <NL> if ( x == y ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> N = int ( input ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a - 1 ] . append ( [ c , b - 1 ] ) <NEWLINE> G [ b - 1 ] . append ( [ c , a - 1 ] ) <NEWLINE> <DEDENT> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def dijkstra ( s , N , G ) : <NEWLINE> <INDENT> d = [ float ( <STRING> ) ] * N <NEWLINE> d [ s ] = 0 <NEWLINE> hq = [ [ 0 , s ] ] <NEWLINE> heapq . heapify ( hq ) <NEWLINE> while len ( hq ) > 0 : <NEWLINE> <INDENT> v , i = heapq . heappop ( hq ) <NEWLINE> if d [ i ] < v : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for c , j in G [ i ] : <NEWLINE> <INDENT> if d [ j ] > d [ i ] + c : <NEWLINE> <INDENT> d [ j ] = d [ i ] + c <NEWLINE> heapq . heappush ( hq , [ d [ j ] , j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> D = dijkstra ( K - 1 , N , G ) <NEWLINE> <NL> dist = [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> dist [ i ] = D [ x - 1 ] + D [ y - 1 ] <NEWLINE> <NL> <DEDENT> for d in dist : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT>
N , Ma , Mb = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> sum_a = 0 <NEWLINE> sum_b = 0 <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> sum_a += a <NEWLINE> sum_b += b <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <DEDENT> inf = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> dp = [ [ [ inf ] * ( sum_b + 1 ) for _ in range ( sum_a + 1 ) ] for _ in range ( N + 1 ) ] <NEWLINE> <NL> dp [ 0 ] [ 0 ] [ 0 ] = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for sa in range ( sum_a ) : <NEWLINE> <INDENT> for sb in range ( sum_b ) : <NEWLINE> <INDENT> if sa - A [ i ] >= 0 and sb - B [ i ] >= 0 : <NEWLINE> <INDENT> dp [ i + 1 ] [ sa ] [ sb ] = min ( dp [ i ] [ sa - A [ i ] ] <NEWLINE> <INDENT> [ sb - B [ i ] ] + C [ i ] , dp [ i ] [ sa ] [ sb ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] [ sa ] [ sb ] = min ( dp [ i ] [ sa ] [ sb ] , dp [ i + 1 ] [ sa ] [ sb ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = inf <NEWLINE> for i in range ( 1 , sum_a + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , sum_b + 1 ) : <NEWLINE> <INDENT> if Ma * j == Mb * i : <NEWLINE> <INDENT> ans = min ( ans , dp [ N ] [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans if ans != inf else - 1 ) <NEWLINE>
import bisect <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> a . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( bisect . bisect ( a , r - 1.5 ) - bisect . bisect ( a , l - 1.5 ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> D , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> if N != 100 : <NEWLINE> <INDENT> print ( N * ( 100 ** D ) ) <NEWLINE> <DEDENT> elif N == 100 : <NEWLINE> <INDENT> print ( ( N + 1 ) * 100 ** D ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> point = [ 0 ] * n <NEWLINE> total_b = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> point [ i ] = a + b <NEWLINE> total_b += b <NEWLINE> <NL> <DEDENT> point . sort ( reverse = True ) <NEWLINE> <NL> sum_t = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> sum_t += point [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum_t - total_b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> v_even = [ 0 ] * 100000 <NEWLINE> v_odd = [ 0 ] * 100000 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> v_even [ v [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v_odd [ v [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> res1 = max ( v_even ) <NEWLINE> res2 = max ( v_odd ) <NEWLINE> if v_even . index ( res1 ) == v_odd . index ( res2 ) : <NEWLINE> <INDENT> if res1 > res2 : <NEWLINE> <INDENT> v_odd [ v_odd . index ( res2 ) ] = 0 <NEWLINE> res2 = max ( v_odd ) <NEWLINE> <DEDENT> elif res2 > res1 : <NEWLINE> <INDENT> v_even [ v_even . index ( res1 ) ] = 0 <NEWLINE> res1 = max ( v_even ) <NEWLINE> <DEDENT> elif res1 == res2 : <NEWLINE> <INDENT> v_odd [ v_odd . index ( res2 ) ] = 0 <NEWLINE> v_even [ v_even . index ( res1 ) ] = 0 <NEWLINE> res3 = max ( v_even ) <NEWLINE> res4 = max ( v_odd ) <NEWLINE> if res3 > res4 : <NEWLINE> <INDENT> res1 = res3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res2 = res4 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( n // 2 - res1 + n // 2 - res2 ) <NEWLINE>
<COMMENT> <NL> import collections <NEWLINE> import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = [ <STRING> . join ( sorted ( input ( ) ) ) for i in range ( N ) ] <NEWLINE> cnt = collections . Counter ( S ) <NEWLINE> ans = 0 <NEWLINE> for v in cnt . values ( ) : <NEWLINE> <INDENT> if v != 1 : <NEWLINE> <INDENT> ans += math . factorial ( v ) // ( math . factorial ( v - 2 ) * 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import fractions <NEWLINE> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res , ans = [ ] , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> res . append ( abs ( a [ i ] - x ) ) <NEWLINE> <DEDENT> if len ( res ) > 3 : <NEWLINE> <INDENT> D = fractions . gcd ( res [ 0 ] , res [ 1 ] ) <NEWLINE> for j in range ( 2 , len ( res ) - 2 ) : <NEWLINE> <INDENT> D = fractions . gcd ( D , res [ j ] ) <NEWLINE> <DEDENT> ans = D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( res ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> same = False <NEWLINE> import math <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i ] == S [ i - 1 ] : <NEWLINE> <INDENT> same = True <NEWLINE> <DEDENT> elif same and S [ i ] != S [ i - 1 ] : <NEWLINE> <INDENT> A [ i ] = 1 <NEWLINE> same = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> same = False <NEWLINE> A [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( A ) + 1 ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> H = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> H . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> H . sort ( ) <NEWLINE> ans = 10 ** 9 <NEWLINE> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , H [ i + K - 1 ] - H [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> person = int ( input ( ) ) <NEWLINE> lst [ person - 1 ] += 1 <NEWLINE> <DEDENT> for p in range ( n ) : <NEWLINE> <INDENT> temp = k - q + lst [ p ] <NEWLINE> if temp <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> M = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> M_sorted = [ <STRING> . join ( sorted ( m ) ) for m in M ] <NEWLINE> d = { } <NEWLINE> ans = 0 <NEWLINE> <NL> for m in M_sorted : <NEWLINE> <INDENT> d . setdefault ( m , 0 ) <NEWLINE> ans += d [ m ] <NEWLINE> d [ m ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , T = map ( int , input ( ) . split ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = T <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if t [ i + 1 ] - t [ i ] >= T : <NEWLINE> <INDENT> ans += T <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> ans += t [ i + 1 ] - t [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> P = [ ] <NEWLINE> S = [ ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> P . append ( int ( p ) ) <NEWLINE> S . append ( s ) <NEWLINE> <NL> <DEDENT> AC = np . zeros ( N ) <NEWLINE> WA = np . zeros ( N ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> if AC [ P [ i ] - 1 ] == 0 : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> WA [ P [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> AC [ P [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> WA [ AC == 0 ] = 0 <NEWLINE> <NL> print ( int ( sum ( AC ) ) , int ( sum ( WA ) ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> s = [ ] <NEWLINE> g = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if 1 == L [ i ] [ 0 ] : <NEWLINE> <INDENT> s . append ( L [ i ] [ 1 ] ) <NEWLINE> <DEDENT> if 1 == L [ i ] [ 1 ] : <NEWLINE> <INDENT> s . append ( L [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> if N == L [ i ] [ 0 ] : <NEWLINE> <INDENT> g . append ( L [ i ] [ 1 ] ) <NEWLINE> <DEDENT> if N == L [ i ] [ 1 ] : <NEWLINE> <INDENT> g . append ( L [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if set ( g ) & set ( s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> S_h = list ( input ( ) ) <NEWLINE> S . append ( S_h ) <NEWLINE> <NL> <DEDENT> d = [ - 1 , 1 ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if S [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> ls = [ ] <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> for j in range ( 2 ) : <NEWLINE> <INDENT> hs = h + d [ i ] <NEWLINE> ws = w + d [ j ] <NEWLINE> if 0 <= hs < H and 0 <= ws < W : <NEWLINE> <INDENT> ls . append ( S [ hs ] [ w ] ) <NEWLINE> ls . append ( S [ h ] [ ws ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if <STRING> not in ls : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1 << 25 ) <NEWLINE> read = sys . stdin . readline <NEWLINE> ra = range <NEWLINE> enu = enumerate <NEWLINE> <NL> <NL> def exit ( * argv , ** kwarg ) : <NEWLINE> <INDENT> print ( * argv , ** kwarg ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> def mina ( * argv , sub = 1 ) : return list ( map ( lambda x : x - sub , argv ) ) <NEWLINE> <COMMENT> <NL> <NL> <NL> def a_int ( ) : return int ( read ( ) ) <NEWLINE> <NL> <NL> def ints ( ) : return list ( map ( int , read ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def read_col ( H ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> ret . append ( list ( map ( int , read ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> return tuple ( map ( list , zip ( * ret ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def read_tuple ( H ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> ret . append ( tuple ( map ( int , read ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def read_matrix ( H ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> ret . append ( list ( map ( int , read ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> return ret <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> N , W_max = ints ( ) <NEWLINE> W , V = read_col ( N ) <NEWLINE> W = np . array ( W , dtype = np . int64 ) <NEWLINE> V = np . array ( V , dtype = np . int64 ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def solve ( N , W_max , W , V ) : <NEWLINE> <INDENT> V_max = np . sum ( V ) + 1 <NEWLINE> dp = np . full ( ( N + 1 , V_max ) , 10 ** 12 , dtype = np . int64 ) <NEWLINE> <COMMENT> <NL> dp [ 0 , 0 ] = 0 <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> dp [ i + 1 , : ] = np . minimum ( dp [ i + 1 , : ] , dp [ i , : ] ) <NEWLINE> for j in range ( V_max ) : <NEWLINE> <INDENT> jv = j + V [ i ] <NEWLINE> if jv >= V_max : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp [ i + 1 , jv ] = min ( dp [ i + 1 , jv ] , dp [ i , j ] + W [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for j in range ( V_max - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if np . any ( dp [ : , j ] <= W_max ) : <NEWLINE> <INDENT> print ( j ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> solve ( N , W_max , W , V ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> ans . append ( input ( ) ) <NEWLINE> <DEDENT> for j in ans : <NEWLINE> <INDENT> print ( j ) <NEWLINE> print ( j ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> <NL> MOD = 10 ** 4 + 7 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> d = deque ( [ ] ) <NEWLINE> for a in A : <NEWLINE> <INDENT> l = - 1 <NEWLINE> r = len ( d ) <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> m = l + ( r - l ) // 2 <NEWLINE> if d [ m ] >= a : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = m <NEWLINE> <DEDENT> <DEDENT> if r == 0 : <NEWLINE> <INDENT> d . appendleft ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ r - 1 ] = a <NEWLINE> <DEDENT> <DEDENT> print ( len ( d ) ) <NEWLINE>
n , m = ( int ( xi ) for xi in input ( ) . split ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> diff = [ ] <NEWLINE> a0 = 0 <NEWLINE> if m > 0 : <NEWLINE> <INDENT> a1 = int ( input ( ) ) <NEWLINE> a . append ( a1 ) <NEWLINE> diff . append ( a1 + 1 ) <NEWLINE> <NL> if m > 1 : <NEWLINE> <INDENT> for xi in range ( m - 1 ) : <NEWLINE> <INDENT> a0 = a1 <NEWLINE> a1 = int ( input ( ) ) <NEWLINE> a . append ( a1 ) <NEWLINE> diff . append ( a1 - a0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if a1 == n - 1 : <NEWLINE> <INDENT> diff . append ( n - a1 + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff . append ( n - a1 + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if n == 1 : diff . append ( n + 1 ) <NEWLINE> diff . append ( n + 2 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> p = [ 0 ] <NEWLINE> p . append ( 1 ) <NEWLINE> p . append ( 1 ) <NEWLINE> for xi in range ( 3 , max ( diff ) + 2 ) : <NEWLINE> <INDENT> add = ( p [ xi - 1 ] + p [ xi - 2 ] ) % 1_000_000_007 <NEWLINE> p . append ( add ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> out = 1 <NEWLINE> for xi in range ( len ( diff ) ) : <NEWLINE> <INDENT> out *= p [ diff [ xi ] - 1 ] <NEWLINE> <NL> <DEDENT> print ( out % 1_000_000_007 ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> count = 0 <NEWLINE> R_1 = [ - 1 for i in range ( 26 ) ] <NEWLINE> R_2 = [ - 1 for i in range ( 26 ) ] <NEWLINE> <NL> answer = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> r1 = ord ( S [ i ] ) - 97 <NEWLINE> r2 = ord ( T [ i ] ) - 97 <NEWLINE> if R_1 [ r1 ] >= 0 : <NEWLINE> <INDENT> if r2 != R_1 [ r1 ] : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if R_2 [ r2 ] >= 0 : <NEWLINE> <INDENT> if r1 != R_2 [ r2 ] : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if R_1 [ r1 ] < 0 : <NEWLINE> <INDENT> R_1 [ r1 ] = r2 <NEWLINE> <DEDENT> if R_2 [ r2 ] < 0 : <NEWLINE> <INDENT> R_2 [ r2 ] = r1 <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
import numpy as np <NEWLINE> <NL> D , G , * pc = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> pc = list ( zip ( * [ iter ( pc ) ] * 2 ) ) <NEWLINE> p , c = np . array ( [ ] ) , np . array ( [ ] ) <NEWLINE> for ( x , y ) in pc : <NEWLINE> <INDENT> p = np . append ( p , x ) <NEWLINE> c = np . append ( c , y ) <NEWLINE> <NL> <DEDENT> import numpy as np <NEWLINE> import math <NEWLINE> <NL> base_points = np . array ( [ i * 100 for i in range ( 1 , D + 1 ) ] ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for i in range ( 2 ** D ) : <NEWLINE> <INDENT> bit_flag = np . array ( list ( map ( int , format ( i , <STRING> % D ) ) ) ) <NEWLINE> points = sum ( bit_flag * ( c + p * base_points ) ) <NEWLINE> solved_num = sum ( bit_flag * p ) <NEWLINE> <NL> if points >= G : <NEWLINE> <INDENT> ans . append ( solved_num ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> remained = G - points <NEWLINE> remained_problems = sorted ( ( bit_flag == False ) * np . array ( range ( 1 , D + 1 ) ) , reverse = True ) <NEWLINE> i = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if remained <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> highest_p = remained_problems [ i ] <NEWLINE> <NL> if math . ceil ( remained / ( highest_p * 100 ) ) <= p [ highest_p - 1 ] : <NEWLINE> <INDENT> solved_num += math . ceil ( remained / ( highest_p * 100 ) ) <NEWLINE> remained -= ( math . ceil ( remained / ( highest_p * 100 ) ) * highest_p * 100 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> solved_num += p [ highest_p - 1 ] <NEWLINE> remained -= ( highest_p * 100 * p [ highest_p - 1 ] + c [ highest_p - 1 ] ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans . append ( solved_num ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( min ( ans ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = { } <NEWLINE> for d in D : <NEWLINE> <INDENT> if d not in p : <NEWLINE> <INDENT> p [ d ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p [ d ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for t in T : <NEWLINE> <INDENT> if t not in p : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if p [ t ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> p [ t ] -= 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = deque ( ) <NEWLINE> for i in range ( 1 , 200001 ) : <NEWLINE> <INDENT> d . append ( i ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == d [ 0 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> d . popleft ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if count == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - count ) <NEWLINE> <DEDENT>
a , b , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> n = a + i <NEWLINE> if n > b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans . append ( n ) <NEWLINE> <NL> <DEDENT> st = b - k + 1 <NEWLINE> st = max ( st , ans [ - 1 ] + 1 ) <NEWLINE> for i in range ( st , b + 1 ) : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> g = [ set ( ) for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a - 1 ] . add ( b - 1 ) <NEWLINE> g [ b - 1 ] . add ( a - 1 ) <NEWLINE> <NL> <DEDENT> def dfs ( s ) : <NEWLINE> <INDENT> visited = [ - 1 ] * n <NEWLINE> visited [ s ] = 0 <NEWLINE> temp = [ s ] <NEWLINE> lst = [ ] <NEWLINE> while temp : <NEWLINE> <INDENT> p = temp . pop ( ) <NEWLINE> for a in g [ p ] : <NEWLINE> <INDENT> if visited [ a ] != - 1 : continue <NEWLINE> visited [ a ] = visited [ p ] + 1 <NEWLINE> temp . append ( a ) <NEWLINE> <DEDENT> <DEDENT> return visited <NEWLINE> <NL> <DEDENT> lst0 = dfs ( 0 ) <NEWLINE> lstn = dfs ( n - 1 ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if lst0 [ i ] <= lstn [ i ] : cnt += 1 <NEWLINE> <NL> <DEDENT> if cnt > n - cnt : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
def z_alg ( S ) : <NEWLINE> <INDENT> N = len ( S ) <NEWLINE> Z = [ 0 ] * N <NEWLINE> Z [ 0 ] = N <NEWLINE> i , j = 1 , 0 <NEWLINE> while i < N : <NEWLINE> <INDENT> while i + j < N and S [ j ] == S [ i + j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> Z [ i ] = j <NEWLINE> if j == 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> continue <NEWLINE> <DEDENT> k = 1 <NEWLINE> while i + k < N and k + Z [ k ] < j : <NEWLINE> <INDENT> Z [ i + k ] = Z [ k ] <NEWLINE> k += 1 <NEWLINE> <DEDENT> i += k <NEWLINE> j -= k <NEWLINE> <DEDENT> return Z <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> REP_S = <STRING> <NEWLINE> target_len = len ( S ) + len ( T ) - 1 <NEWLINE> while len ( REP_S ) < target_len : <NEWLINE> <INDENT> REP_S += S <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> T_REP_S = T + REP_S <NEWLINE> z = z_alg ( T_REP_S ) <NEWLINE> location_list = list ( ) <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if z [ i + len ( T ) ] >= len ( T ) : <NEWLINE> <INDENT> location_list . append ( i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if len ( location_list ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> node_flag_list = [ 0 ] * len ( S ) <NEWLINE> for n in location_list : <NEWLINE> <INDENT> node_flag_list [ n ] = 1 <NEWLINE> <DEDENT> depth_list = [ - 1 ] * len ( S ) <NEWLINE> for n in location_list : <NEWLINE> <INDENT> if depth_list [ n ] >= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cur_node = n <NEWLINE> d , has_loop = 0 , False <NEWLINE> while node_flag_list [ cur_node ] == 1 : <NEWLINE> <INDENT> depth_list [ cur_node ] = d <NEWLINE> d += 1 <NEWLINE> cur_node = ( cur_node + len ( T ) ) % len ( S ) <NEWLINE> if cur_node == n : <NEWLINE> <INDENT> has_loop = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if has_loop : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( depth_list ) + 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> from heapq import heapify , heappush <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> def hl ( ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> heapify ( ret ) <NEWLINE> return ret <NEWLINE> <DEDENT> d = defaultdict ( hl ) <NEWLINE> for x in s : <NEWLINE> <INDENT> heappush ( d [ x [ 0 ] ] , - x [ 1 ] ) <NEWLINE> heappush ( d [ x [ 1 ] ] , - x [ 0 ] ) <NEWLINE> <DEDENT> for e in d [ 1 ] : <NEWLINE> <INDENT> if d [ - e ] [ 0 ] == - n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - i - j <= K : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
S = input ( ) <NEWLINE> L = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] in L : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> ans = max ( ans , cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , * A = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> one = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a & ( 1 << i ) : <NEWLINE> <INDENT> one += 1 <NEWLINE> <DEDENT> <DEDENT> ans = ( ans + one * ( N - one ) * ( 1 << i ) ) % MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> a = set ( a ) <NEWLINE> <NL> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for now in range ( 0 , n + 1 ) : <NEWLINE> <INDENT> for next_step in range ( now + 1 , min ( n + 1 , now + 3 ) ) : <NEWLINE> <INDENT> if not next_step in a : <NEWLINE> <INDENT> dp [ next_step ] += dp [ now ] <NEWLINE> dp [ next_step ] %= 1000000007 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n >= m : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> x . sort ( ) <NEWLINE> d = x [ - 1 ] - x [ 0 ] <NEWLINE> y = [ ] <NEWLINE> for i in range ( m - 1 ) : <NEWLINE> <INDENT> y . append ( x [ i + 1 ] - x [ i ] ) <NEWLINE> <DEDENT> y . sort ( reverse = True ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> d -= y [ i ] <NEWLINE> <DEDENT> print ( d ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> countS = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> countS [ i + 1 ] = countS [ i ] <NEWLINE> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> countS [ i + 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( countS [ r - 1 ] - countS [ l - 1 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // math . gcd ( a , b ) <NEWLINE> <NL> <DEDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> e = lcm ( c , d ) <NEWLINE> <NL> total = b - ( a - 1 ) <NEWLINE> cc = b // c - ( a - 1 ) // c <NEWLINE> dd = b // d - ( a - 1 ) // d <NEWLINE> ee = b // e - ( a - 1 ) // e <NEWLINE> <NL> ans = total - cc - dd + ee <NEWLINE> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for d in range ( 61 ) : <NEWLINE> <COMMENT> <NL> <INDENT> x = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if ( a >> d ) & 1 : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> ans += x * ( n - x ) * 2 ** d <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> p2D = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> def II ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def SI ( ) : return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> md = 10 ** 9 + 7 <NEWLINE> n = II ( ) <NEWLINE> aa = LI ( ) <NEWLINE> cs = [ 0 ] <NEWLINE> for a in aa : cs . append ( cs [ - 1 ] ^ a ) <NEWLINE> <COMMENT> <NL> <NL> cnt = { } <NEWLINE> cnt0 = [ 1 ] * len ( cs ) <NEWLINE> for i , s in enumerate ( cs [ 1 : ] , 1 ) : <NEWLINE> <INDENT> if s == 0 : <NEWLINE> <INDENT> cnt0 [ i ] = cnt0 [ i - 1 ] + 1 <NEWLINE> <DEDENT> elif s in cnt : <NEWLINE> <INDENT> cnt0 [ i ] = cnt0 [ i - 1 ] <NEWLINE> c0 = cnt0 [ i ] - cnt0 [ cnt [ s ] [ 2 ] ] <NEWLINE> cnt [ s ] [ 0 ] = ( cnt [ s ] [ 0 ] + cnt [ s ] [ 1 ] * c0 ) % md <NEWLINE> cnt [ s ] [ 1 ] = ( cnt [ s ] [ 1 ] + cnt [ s ] [ 0 ] ) % md <NEWLINE> cnt [ s ] [ 2 ] = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt0 [ i ] = cnt0 [ i - 1 ] <NEWLINE> cnt [ s ] = [ 1 , 1 , i ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if cs [ - 1 ] == 0 : ans = sum ( v [ 1 ] for v in cnt . values ( ) ) + pow ( 2 , cnt0 [ - 1 ] - 2 , md ) <NEWLINE> else : ans = cnt [ cs [ - 1 ] ] [ 0 ] <NEWLINE> print ( ans % md ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> if ans not in a : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> if i == ans : <NEWLINE> <INDENT> ans += 1 <NEWLINE> continue <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> <NL> rui = [ 0 ] * ( n + 1 ) <NEWLINE> tmp = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> rui [ i ] = tmp <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> print ( rui [ lr [ i ] [ 1 ] - 1 ] - rui [ lr [ i ] [ 0 ] - 1 ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for d in range ( 60 ) : <NEWLINE> <COMMENT> <NL> <INDENT> x = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if ( a >> d ) & 1 : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> ans += x * ( n - x ) * 2 ** d <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> n , l = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> S = [ input ( ) for i in range ( 0 , n ) ] <NEWLINE> print ( <STRING> . join ( sorted ( S ) ) ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = set ( [ int ( input ( ) ) for _ in range ( M ) ] ) <NEWLINE> <NL> lis = [ 0 ] * ( N + 1 ) <NEWLINE> lis [ 0 ] = 1 <NEWLINE> <NL> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> lis [ i ] = ( lis [ i - 1 ] + lis [ i - 2 ] ) % ( 10 ** 9 + 7 ) <NEWLINE> if i in A : <NEWLINE> <INDENT> lis [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( lis [ N ] ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def comb ( a , b ) : <NEWLINE> <INDENT> comb = 1 <NEWLINE> chld = 1 <NEWLINE> for i in range ( b ) : <NEWLINE> <INDENT> comb = comb * ( a - i ) % mod <NEWLINE> chld = chld * ( b - i ) % mod <NEWLINE> <DEDENT> return ( comb * pow ( chld , mod - 2 , mod ) ) % mod <NEWLINE> <DEDENT> if ( x + y ) % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nm = ( x + y ) // 3 <NEWLINE> n = y - nm <NEWLINE> m = x - nm <NEWLINE> if n >= 0 and m >= 0 : <NEWLINE> <INDENT> print ( comb ( n + m , m ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> s = input ( ) <NEWLINE> <NL> res = 0 <NEWLINE> <NL> search = [ ( <STRING> + str ( s ) ) [ - 3 : ] for s in range ( 0 , 1000 ) ] <NEWLINE> <NL> for v in search : <NEWLINE> <INDENT> tmp = s <NEWLINE> if v [ 0 ] in tmp : <NEWLINE> <INDENT> tmp = tmp [ tmp . index ( v [ 0 ] ) + 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if v [ 1 ] in tmp : <NEWLINE> <INDENT> tmp = tmp [ tmp . index ( v [ 1 ] ) + 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if v [ 2 ] in tmp : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> tmp_s = { i for i in range ( A , A + K ) } <NEWLINE> tmp_l = { i for i in range ( B + 1 - K , B + 1 ) } <NEWLINE> <NL> ans = list ( tmp_s . union ( tmp_l ) ) <NEWLINE> ans = [ i for i in ans if A <= i <= B ] <NEWLINE> ans . sort ( ) <NEWLINE> <NL> print ( * ans , sep = <STRING> ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> v = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> for a in range ( min ( n , k ) + 1 ) : <NEWLINE> <INDENT> pa , va = v [ : a ] , v [ a : ] <NEWLINE> for b in range ( min ( n , k ) - a + 1 ) : <NEWLINE> <INDENT> pb = pa + va [ - b : ] if b > 0 else pa <NEWLINE> pb . sort ( ) <NEWLINE> s = sum ( pb ) <NEWLINE> ans = max ( s , ans ) <NEWLINE> for c in range ( min ( k - a - b , a + b ) ) : <NEWLINE> <INDENT> s -= pb [ c ] <NEWLINE> ans = max ( s , ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , Y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for y in range ( N + 1 ) : <NEWLINE> <INDENT> for w in range ( N + 1 ) : <NEWLINE> <INDENT> if y * 10000 + w * 5000 + ( N - y - w ) * 1000 == Y and N - y - w >= 0 : <NEWLINE> <INDENT> ans = str ( y ) + <STRING> + str ( w ) + <STRING> + str ( N - y - w ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
from numba import njit <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> <NL> @ njit <NEWLINE> def f ( ) : <NEWLINE> <INDENT> for h in range ( 1 , 3501 ) : <NEWLINE> <INDENT> for n in range ( 1 , 3501 ) : <NEWLINE> <INDENT> x = 4 * h * n - N * n - N * h <NEWLINE> if x != 0 and N * h * n % x == 0 : <NEWLINE> <INDENT> w = N * h * n // x <NEWLINE> if w >= 1 : <NEWLINE> <INDENT> return h , n , w <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( * f ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> c = 0 <NEWLINE> if len ( S ) > 2 : <NEWLINE> <INDENT> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> if S [ i - 1 ] == <STRING> and S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 2020202020 <NEWLINE> a = 0 <NEWLINE> b = sum ( s ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a += s [ i ] <NEWLINE> b -= s [ i ] <NEWLINE> ans = min ( ans , abs ( a - b ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from math import gcd , pi , sqrt <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import itertools <NEWLINE> from collections import Counter , deque <NEWLINE> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = i_input ( ) <NEWLINE> l = [ i_list ( ) for i in range ( n ) ] <NEWLINE> <NL> L = [ ] <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> if i [ 2 ] != 0 : <NEWLINE> <INDENT> L . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if len ( L ) == 1 : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , L [ 0 ] ) ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for x in range ( 101 ) : <NEWLINE> <INDENT> for y in range ( 101 ) : <NEWLINE> <INDENT> H = L [ 0 ] [ 2 ] + abs ( x - L [ 0 ] [ 0 ] ) + abs ( y - L [ 0 ] [ 1 ] ) <NEWLINE> flg = True <NEWLINE> for x1 , y1 , h1 in L [ 1 : ] : <NEWLINE> <INDENT> if h1 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> if H != h1 + abs ( x - x1 ) + abs ( y - y1 ) : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg == True : <NEWLINE> <INDENT> ans = [ x , y ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> H = L [ 0 ] [ 2 ] + abs ( ans [ 0 ] - L [ 0 ] [ 0 ] ) + abs ( ans [ 1 ] - L [ 0 ] [ 1 ] ) <NEWLINE> print ( <STRING> . join ( map ( str , ans ) ) + <STRING> + str ( H ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def ans120 ( A : int , B : int , K : int ) : <NEWLINE> <INDENT> if A >= B : <NEWLINE> <INDENT> n = A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = B <NEWLINE> <DEDENT> ans_list = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if A % i == 0 and B % i == 0 : <NEWLINE> <INDENT> ans_list . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return ans_list [ - K ] <NEWLINE> <NL> <DEDENT> print ( ans120 ( A , B , K ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> power = 1 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> power *= i <NEWLINE> power %= mod <NEWLINE> <DEDENT> print ( power ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> xyh = [ ] <NEWLINE> x0 , y0 , h0 = None , None , None <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , y , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if h > 0 and x0 is None : <NEWLINE> <INDENT> x0 , y0 , h0 = x , y , h <NEWLINE> <DEDENT> xyh . append ( [ x , y , h ] ) <NEWLINE> <NL> <DEDENT> for cx in range ( 101 ) : <NEWLINE> <INDENT> for cy in range ( 101 ) : <NEWLINE> <INDENT> h = h0 + abs ( x0 - cx ) + abs ( y0 - cy ) <NEWLINE> done = True <NEWLINE> for xk , yk , hk in xyh : <NEWLINE> <INDENT> h_ = max ( h - abs ( xk - cx ) - abs ( yk - cy ) , 0 ) <NEWLINE> if h_ != hk : <NEWLINE> <INDENT> done = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if done : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> m = 0 <NEWLINE> ans = <STRING> <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> m = i + 1 <NEWLINE> ans = s [ i ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if k < m : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif m == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( ans ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> Info = [ [ ] for T in range ( 0 , N ) ] <NEWLINE> for I in range ( 0 , N ) : <NEWLINE> <INDENT> Info [ I ] = [ int ( T ) for T in input ( ) . split ( ) ] <NEWLINE> <DEDENT> Info = sorted ( Info , reverse = True , key = lambda X : X [ 2 ] ) <NEWLINE> for CX in range ( 0 , 101 ) : <NEWLINE> <INDENT> for CY in range ( 0 , 101 ) : <NEWLINE> <INDENT> Flag = True <NEWLINE> BaseH = abs ( Info [ 0 ] [ 0 ] - CX ) + abs ( Info [ 0 ] [ 1 ] - CY ) + Info [ 0 ] [ 2 ] <NEWLINE> for I in range ( 1 , N ) : <NEWLINE> <INDENT> if max ( BaseH - abs ( Info [ I ] [ 0 ] - CX ) - abs ( Info [ I ] [ 1 ] - CY ) , 0 ) != Info [ I ] [ 2 ] : <NEWLINE> <INDENT> Flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if Flag : <NEWLINE> <INDENT> Ans = [ str ( CX ) , str ( CY ) , str ( BaseH ) ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if Flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( Ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> history = set ( ) <NEWLINE> now = 0 <NEWLINE> cnt = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if now in history : <NEWLINE> <INDENT> cnt = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> history . add ( now ) <NEWLINE> now = a [ now ] - 1 <NEWLINE> if now == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <COMMENT> <NL> t = [ ] <NEWLINE> t . append ( s [ 0 ] ) <NEWLINE> x = s [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if x != s [ i ] : <NEWLINE> <INDENT> t . append ( s [ i ] ) <NEWLINE> x = s [ i ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> j = 0 <NEWLINE> t = deque ( t ) <NEWLINE> while j < k : <NEWLINE> <INDENT> if len ( t ) <= 2 : <NEWLINE> <INDENT> print ( n - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> t . popleft ( ) <NEWLINE> t . popleft ( ) <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> print ( n - 1 - ( len ( t ) - 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> from collections import Counter <NEWLINE> a = [ ] <NEWLINE> while p % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> p //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f <= p : <NEWLINE> <INDENT> if p % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> p //= f <NEWLINE> <DEDENT> elif f * f > p : <NEWLINE> <INDENT> a . append ( p ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> c = Counter ( a ) <NEWLINE> ans = 1 <NEWLINE> for k , v in c . items ( ) : <NEWLINE> <INDENT> if v >= n : <NEWLINE> <INDENT> ans *= k ** ( v // n ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import OrderedDict <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> N , Q = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> connection = { i : set ( ) for i in range ( 1 , N + 1 ) } <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> connection [ a ] . add ( b ) <NEWLINE> connection [ b ] . add ( a ) <NEWLINE> <COMMENT> <NL> <DEDENT> point = { i : 0 for i in range ( 1 , N + 1 ) } <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> p , x = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> point [ p ] += x <NEWLINE> <NL> <DEDENT> def DFS ( now , prev = - 1 ) : <NEWLINE> <INDENT> for next in connection [ now ] : <NEWLINE> <INDENT> if next == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> point [ next ] += point [ now ] <NEWLINE> DFS ( next , now ) <NEWLINE> <NL> <DEDENT> <DEDENT> DFS ( 1 ) <NEWLINE> print ( * point . values ( ) ) <NEWLINE>
import math <NEWLINE> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( lcm ( a , b ) ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = np . array ( input ( ) . split ( ) , np . int32 ) <NEWLINE> <NL> P [ : ] += 1 <NEWLINE> Pcum = np . zeros ( N + 1 , np . int32 ) <NEWLINE> Pcum [ 1 : ] = np . cumsum ( P ) <NEWLINE> length_K_sums = Pcum [ K : ] - Pcum [ : - K ] <NEWLINE> print ( length_K_sums . max ( ) / 2 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> def fib ( q ) : <NEWLINE> <INDENT> fibonacci = [ 0 , 1 ] <NEWLINE> for i in range ( 2 , q ) : <NEWLINE> <INDENT> fibonacci . append ( fibonacci [ i - 2 ] + fibonacci [ i - 1 ] ) <NEWLINE> <DEDENT> return fibonacci [ q - 1 ] <NEWLINE> <DEDENT> n , m = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> a = [ ] <NEWLINE> a . append ( - 1 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> a . append ( n + 1 ) <NEWLINE> out = 1 <NEWLINE> c = 10 ** 9 + 7 <NEWLINE> for i in range ( m + 1 ) : <NEWLINE> <INDENT> out *= int ( fib ( a [ i + 1 ] - a [ i ] ) ) <NEWLINE> <DEDENT> out %= c <NEWLINE> print ( out ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> n = 10 ** 9 + 7 <NEWLINE> power = math . factorial ( N ) <NEWLINE> print ( power % n ) <NEWLINE>
maxa = 0 <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ 0 ] * 100000 <NEWLINE> for i in L : <NEWLINE> <INDENT> c [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , 99999 ) : <NEWLINE> <INDENT> s = c [ i ] + c [ i - 1 ] + c [ i + 1 ] <NEWLINE> maxa = max ( maxa , s ) <NEWLINE> <DEDENT> print ( maxa ) <NEWLINE>
import heapq <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( A ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a = heapq . heappop ( A ) <NEWLINE> heapq . heappush ( A , - ( - a // 2 ) ) <NEWLINE> <DEDENT> print ( - sum ( A ) ) <NEWLINE>
def integerCards ( n , m , alist , bclist ) : <NEWLINE> <NL> <INDENT> count = 0 <NEWLINE> alist . sort ( ) <NEWLINE> bclist . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> for b , c in bclist : <NEWLINE> <INDENT> for _ in range ( b ) : <NEWLINE> <INDENT> if alist [ count ] < c : <NEWLINE> <INDENT> alist [ count ] = c <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if count == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if count == n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return sum ( alist ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bclist = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> print ( integerCards ( n , m , alist , bclist ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1 << 30 ) <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> def dfs ( x , score ) : <NEWLINE> <INDENT> for y in Tree [ x ] : <NEWLINE> <INDENT> if Parent [ x ] != y : <NEWLINE> <INDENT> Parent [ y ] = x <NEWLINE> score [ y ] += score [ x ] <NEWLINE> dfs ( y , score ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> Tree = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> Parent = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> Tree [ a ] . append ( b ) <NEWLINE> Tree [ b ] . append ( a ) <NEWLINE> <DEDENT> score = [ 0 ] * ( N + 1 ) <NEWLINE> for j in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> score [ p ] += x <NEWLINE> <DEDENT> dfs ( 1 , score ) <NEWLINE> print ( * score [ 1 : ] , end = <STRING> ) <NEWLINE>
from collections import defaultdict <NEWLINE> import itertools <NEWLINE> d = defaultdict ( int ) <NEWLINE> x = <STRING> <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> d [ x [ i ] ] = i + 1 <NEWLINE> <DEDENT> x = [ 0 ] * 5 <NEWLINE> def sub ( a , b ) : <NEWLINE> <INDENT> return abs ( a [ 0 ] - b [ 0 ] ) + abs ( a [ 1 ] - b [ 1 ] ) <NEWLINE> <NL> <DEDENT> H , W , D = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( H ) ] <NEWLINE> N = H * W <NEWLINE> P = [ 0 ] * ( N ) <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> P [ A [ h ] [ w ] - 1 ] = ( h , w ) <NEWLINE> <DEDENT> <DEDENT> X = [ ] <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> _ = [ 0 ] + [ sub ( P [ i % N ] , P [ i - D ] ) for i in range ( d + D , N + D , D ) ] <NEWLINE> cumsum = list ( itertools . accumulate ( _ ) ) <NEWLINE> X . append ( cumsum ) <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> l , r = l - 1 , r - 1 <NEWLINE> g = l % D <NEWLINE> if l > r : <NEWLINE> <INDENT> r += N <NEWLINE> ans = X [ g ] [ - 1 ] - X [ g ] [ l // D ] <NEWLINE> ans += X [ g ] [ r // D ] - X [ g ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = X [ g ] [ r // D ] - X [ g ] [ l // D ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> d = collections . Counter ( l ) <NEWLINE> ans = 0 <NEWLINE> for v in d . values ( ) : <NEWLINE> <INDENT> if v % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
O = input ( ) <NEWLINE> E = input ( ) <NEWLINE> N = len ( E ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += O [ i ] + E [ i ] <NEWLINE> <DEDENT> if len ( O ) - len ( E ) == 1 : <NEWLINE> <INDENT> ans += O [ - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> epsilon = 5 * 10 ** ( - 7 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> xys = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> xs , ys = zip ( * xys ) <NEWLINE> <NL> lsd = 0 <COMMENT> <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> sd = ( xs [ i ] - xs [ j ] ) ** 2 + ( ys [ i ] - ys [ j ] ) ** 2 <NEWLINE> if lsd < sd : <NEWLINE> <INDENT> lsd = sd <NEWLINE> farthest_2_points = ( i , j ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> p , q = farthest_2_points <NEWLINE> center_x = ( xs [ p ] + xs [ q ] ) / 2 <NEWLINE> center_y = ( ys [ p ] + ys [ q ] ) / 2 <NEWLINE> all_in_circle = True <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( xs [ i ] - center_x ) ** 2 + ( ys [ i ] - center_y ) ** 2 > lsd / 4 + epsilon : <NEWLINE> <INDENT> all_in_circle = False <NEWLINE> <NL> <DEDENT> <DEDENT> if all_in_circle : <NEWLINE> <COMMENT> <NL> <INDENT> print ( lsd ** 0.5 / 2 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> smallest_radius = 10 ** 9 <NEWLINE> for p in range ( 0 , N ) : <NEWLINE> <INDENT> for q in range ( p + 1 , N ) : <NEWLINE> <INDENT> for r in range ( q + 1 , N ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> pq = ( ( xs [ q ] - xs [ p ] ) ** 2 + ( ys [ q ] - ys [ p ] ) ** 2 ) ** 0.5 <NEWLINE> v1x = xs [ p ] - xs [ r ] <NEWLINE> v1y = ys [ p ] - ys [ r ] <NEWLINE> v2x = xs [ q ] - xs [ r ] <NEWLINE> v2y = ys [ q ] - ys [ r ] <NEWLINE> vec1_len = ( v1x ** 2 + v1y ** 2 ) ** 0.5 <NEWLINE> vec2_len = ( v2x ** 2 + v2y ** 2 ) ** 0.5 <NEWLINE> vecs_dot = v1x * v2x + v1y * v2y <NEWLINE> theta = math . acos ( min ( 1.0 , max ( - 1.0 , vecs_dot / ( vec1_len * vec2_len ) ) ) ) <NEWLINE> if theta == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> radius = pq / ( 2 * math . sin ( theta ) ) <NEWLINE> <NL> <COMMENT> <NL> det = v1x * v2y - v1y * v2x <NEWLINE> if det == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> center_x = xs [ r ] + ( v2y * vec1_len ** 2 + ( - v1y ) * vec2_len ** 2 ) / ( 2 * ( det ) ) <NEWLINE> center_y = ys [ r ] + ( ( - v2x ) * vec1_len ** 2 + v1x * vec2_len ** 2 ) / ( 2 * ( det ) ) <NEWLINE> all_in_circle = True <NEWLINE> for s in range ( N ) : <NEWLINE> <INDENT> if ( ( xs [ s ] - center_x ) ** 2 + ( ys [ s ] - center_y ) ** 2 ) ** 0.5 > radius + epsilon : <NEWLINE> <INDENT> all_in_circle = False <NEWLINE> <DEDENT> <DEDENT> if all_in_circle : <NEWLINE> <INDENT> smallest_radius = min ( smallest_radius , radius ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( smallest_radius ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> frag = [ True for _ in range ( n ) ] <NEWLINE> frag [ 0 ] = False <NEWLINE> ans = 0 <NEWLINE> now = 1 <NEWLINE> while ( now != 2 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> now = a [ now - 1 ] <NEWLINE> if ( frag [ now - 1 ] ) : <NEWLINE> <INDENT> frag [ now - 1 ] = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < 0 and b < 0 : <NEWLINE> <INDENT> if ( b - a + 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif a <= 0 and b >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> s = list ( S ) <NEWLINE> p = [ ] <NEWLINE> q = [ ] <NEWLINE> ans = [ 0 for i in range ( len ( s ) ) ] <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> p . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> q . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if len ( p ) > 0 : <NEWLINE> <INDENT> if ( p [ 0 ] - q [ 0 ] ) % 2 == 0 : <NEWLINE> <INDENT> ans [ q [ 0 ] ] = - ( - ( p [ 0 ] + 1 ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ q [ 0 ] ] = ( p [ 0 ] + 1 ) // 2 <NEWLINE> <DEDENT> ans [ q [ 0 ] + 1 ] = p [ 0 ] + 1 - ans [ q [ 0 ] ] <NEWLINE> for i in range ( len ( p ) - 1 ) : <NEWLINE> <INDENT> if ( p [ i + 1 ] - q [ i + 1 ] ) % 2 == 0 : <NEWLINE> <INDENT> ans [ q [ i + 1 ] ] = - ( - ( p [ i + 1 ] - p [ i ] ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ q [ i + 1 ] ] = ( p [ i + 1 ] - p [ i ] ) // 2 <NEWLINE> <DEDENT> ans [ q [ i + 1 ] + 1 ] = p [ i + 1 ] - p [ i ] - ans [ q [ i + 1 ] ] <NEWLINE> <DEDENT> if ( len ( s ) + 1 - q [ - 1 ] ) % 2 == 0 : <NEWLINE> <INDENT> ans [ q [ - 1 ] ] = - ( - ( len ( s ) - p [ - 1 ] - 1 ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ q [ - 1 ] ] = ( len ( s ) - p [ - 1 ] - 1 ) // 2 <NEWLINE> <DEDENT> ans [ q [ - 1 ] + 1 ] = len ( s ) - p [ - 1 ] - 1 - ans [ q [ - 1 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( len ( s ) + 1 - q [ - 1 ] ) % 2 == 0 : <NEWLINE> <INDENT> ans [ q [ - 1 ] ] = - ( - ( len ( s ) ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ q [ - 1 ] ] = ( len ( s ) ) // 2 <NEWLINE> <DEDENT> ans [ q [ - 1 ] + 1 ] = len ( s ) - ans [ q [ - 1 ] ] <NEWLINE> <DEDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( M - 1 ) : <NEWLINE> <INDENT> H , I = map ( int , input ( ) . split ( ) ) <NEWLINE> if H > L : <NEWLINE> <INDENT> L = H <NEWLINE> <DEDENT> if R > I : <NEWLINE> <INDENT> R = I <NEWLINE> <DEDENT> if R < L : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if R < L : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = list ( range ( L , R + 1 ) ) <NEWLINE> print ( len ( ans ) ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> dp = [ 0 for _ in range ( X + 110 ) ] <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( X + 1 ) : <NEWLINE> <INDENT> if dp [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i + 100 ] = 1 <NEWLINE> dp [ i + 101 ] = 1 <NEWLINE> dp [ i + 102 ] = 1 <NEWLINE> dp [ i + 103 ] = 1 <NEWLINE> dp [ i + 104 ] = 1 <NEWLINE> dp [ i + 105 ] = 1 <NEWLINE> <DEDENT> print ( dp [ X ] ) <NEWLINE>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> d = c [ b - 1 ] . swapcase ( ) <NEWLINE> c [ b - 1 ] = d <NEWLINE> c = <STRING> . join ( c ) <NEWLINE> print ( c ) <NEWLINE>
<COMMENT> <NL> <NL> def solve ( x ) : <NEWLINE> <INDENT> if x >= 2000 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> memo = [ True ] + [ False ] * x <NEWLINE> <NL> def dp ( k ) : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> for i in range ( 100 , 106 ) : <NEWLINE> <INDENT> if k - i >= 0 and memo [ k - i ] : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( x ) : <NEWLINE> <INDENT> memo [ i + 1 ] = dp ( i + 1 ) <NEWLINE> <DEDENT> return memo [ x ] <NEWLINE> <NL> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> X = int ( input ( ) ) <NEWLINE> print ( int ( solve ( X ) ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import Counter <NEWLINE> import sys <NEWLINE> <NL> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> n = I ( ) <NEWLINE> d = LI ( ) <NEWLINE> m = I ( ) <NEWLINE> t = LI ( ) <NEWLINE> d . sort ( ) <NEWLINE> t . sort ( ) <NEWLINE> c_t = Counter ( t ) <NEWLINE> c_d = Counter ( d ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans = <STRING> <NEWLINE> i = 0 <NEWLINE> c_d = dict ( [ ( k , v ) for k , v in c_d . items ( ) if k in c_t . keys ( ) ] ) <NEWLINE> if len ( c_d ) != len ( c_t ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for ( k_t , v_t ) , ( k_d , v_d ) in zip ( c_t . items ( ) , c_d . items ( ) ) : <NEWLINE> <INDENT> if v_t > v_d : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> if ( a == 0 ) : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> return gcd ( b % a , a ) <NEWLINE> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a // gcd ( a , b ) * b <NEWLINE> <DEDENT> t = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> while ( t != 0 ) : <NEWLINE> <INDENT> t -= 1 <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = lcm ( ans , n ) <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> from collections import defaultdict <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> self . all_group_member = defaultdict ( list ) <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> self . all_group_member [ self . find ( i ) ] . append ( i ) <NEWLINE> <DEDENT> return self . all_group_member <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> uf = UnionFind ( h * w ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if i != h - 1 : <NEWLINE> <INDENT> if s [ i ] [ j ] != s [ i + 1 ] [ j ] : <NEWLINE> <INDENT> uf . union ( ( i * w ) + j , ( i * w ) + j + w ) <NEWLINE> <DEDENT> <DEDENT> if j != w - 1 : <NEWLINE> <INDENT> if s [ i ] [ j ] != s [ i ] [ j + 1 ] : <NEWLINE> <INDENT> uf . union ( ( i * w ) + j , ( i * w ) + j + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for item in uf . all_group_members ( ) . values ( ) : <NEWLINE> <INDENT> A = 0 <NEWLINE> B = 0 <NEWLINE> for grid in item : <NEWLINE> <INDENT> i , j = divmod ( grid , w ) <NEWLINE> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> A += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += 1 <NEWLINE> <DEDENT> <DEDENT> ans += A * B <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> from collections import defaultdict <NEWLINE> l , r = s [ : n ] , s [ - 1 : - n - 1 : - 1 ] <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> a = { j for j in range ( n ) if ( i >> j ) % 2 } <NEWLINE> d [ ( <STRING> . join ( l [ p ] for p in sorted ( list ( a ) ) ) , <STRING> . join ( l [ o ] for o in range ( n ) if o not in a ) ) ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> a = { j for j in range ( n ) if ( i >> j ) % 2 } <NEWLINE> ans += d [ ( <STRING> . join ( r [ p ] for p in sorted ( list ( a ) ) ) , <STRING> . join ( r [ o ] for o in range ( n ) if o not in a ) ) ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> num = [ 0 , 1 ] <NEWLINE> pattern = list ( itertools . product ( num , repeat = n ) ) <NEWLINE> lists = [ ] <NEWLINE> switches = [ 1 ] * n <NEWLINE> onoff = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> lists . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> key_value = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for l in pattern : <NEWLINE> <INDENT> switches = list ( l ) <NEWLINE> onoff = [ 0 ] * m <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for k in lists [ j ] [ 1 : ] : <NEWLINE> <INDENT> if switches [ k - 1 ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count % 2 == key_value [ j ] : <NEWLINE> <INDENT> onoff [ j ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if not 0 in onoff : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if r - l >= 2018 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_ij = 2018 <NEWLINE> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> min_ij = min ( min_ij , ( ( i % 2019 ) * ( j % 2019 ) ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> print ( min_ij ) <NEWLINE> <DEDENT>
nums = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> <NL> flag = 7 <NEWLINE> while flag >= 0 : <NEWLINE> <INDENT> S = [ ] <NEWLINE> total = nums [ 0 ] <NEWLINE> bin_str = format ( flag , <STRING> ) <NEWLINE> for i , bit in enumerate ( bin_str , 1 ) : <NEWLINE> <INDENT> if int ( bit ) : <NEWLINE> <INDENT> total += nums [ i ] <NEWLINE> S . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total -= nums [ i ] <NEWLINE> S . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if total == 7 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> flag -= 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> set_a = set ( make_divisors ( A ) ) <NEWLINE> set_b = set ( make_divisors ( B ) ) <NEWLINE> set_ab = set_a . intersection ( set_b ) <NEWLINE> <NL> list_ab = list ( set_ab ) <NEWLINE> list_ab . sort ( ) <NEWLINE> <COMMENT> <NL> <NL> print ( list_ab [ - K ] ) <NEWLINE>
t = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> t . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> s = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> s . append ( t [ i ] % 10 ) <NEWLINE> <NL> <DEDENT> o = 5 <NEWLINE> p = 10 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if s [ i ] > 0 : <NEWLINE> <INDENT> if p > s [ i ] : <NEWLINE> <INDENT> o = i <NEWLINE> p = s [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> m = 0 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if i != o : <NEWLINE> <INDENT> if s [ i ] == 0 : <NEWLINE> <INDENT> m += t [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m += t [ i ] - t [ i ] % 10 + 10 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if o != 5 : <NEWLINE> <INDENT> m += t [ o ] <NEWLINE> <DEDENT> print ( m ) <NEWLINE>
from sys import stdin , stdout <NEWLINE> <NL> import bisect <NEWLINE> <NL> import math <NEWLINE> <NL> def st ( ) : <NEWLINE> <INDENT> return list ( stdin . readline ( ) . strip ( ) ) <NEWLINE> <NL> <DEDENT> def inp ( ) : <NEWLINE> <INDENT> return int ( stdin . readline ( ) ) <NEWLINE> <NL> <DEDENT> def li ( ) : <NEWLINE> <INDENT> return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def mp ( ) : <NEWLINE> <INDENT> return map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def pr ( n ) : <NEWLINE> <INDENT> stdout . write ( str ( n ) + <STRING> ) <NEWLINE> <NL> <DEDENT> def soe ( limit ) : <NEWLINE> <INDENT> l = [ 1 ] * ( limit + 1 ) <NEWLINE> prime = [ ] <NEWLINE> for i in range ( 2 , limit + 1 ) : <NEWLINE> <INDENT> if l [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , limit + 1 , i ) : <NEWLINE> <INDENT> l [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 2 , limit + 1 ) : <NEWLINE> <INDENT> if l [ i ] : <NEWLINE> <INDENT> prime . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return prime <NEWLINE> <NL> <DEDENT> def segsoe ( low , high ) : <NEWLINE> <INDENT> limit = int ( high ** 0.5 ) + 1 <NEWLINE> prime = soe ( limit ) <NEWLINE> n = high - low + 1 <NEWLINE> l = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( len ( prime ) ) : <NEWLINE> <INDENT> lowlimit = ( low // prime [ i ] ) * prime [ i ] <NEWLINE> if lowlimit < low : <NEWLINE> <INDENT> lowlimit += prime [ i ] <NEWLINE> <DEDENT> if lowlimit == prime [ i ] : <NEWLINE> <INDENT> lowlimit += prime [ i ] <NEWLINE> <DEDENT> for j in range ( lowlimit , high + 1 , prime [ i ] ) : <NEWLINE> <INDENT> l [ j - low ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( low , high + 1 ) : <NEWLINE> <INDENT> if not l [ i - low ] : <NEWLINE> <INDENT> if i != 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a = a % b <NEWLINE> b , a = a , b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def power ( a , n ) : <NEWLINE> <INDENT> r = 1 <NEWLINE> while n : <NEWLINE> <INDENT> if n & 1 : <NEWLINE> <INDENT> r = ( r * a ) <NEWLINE> <DEDENT> a *= a <NEWLINE> n = n >> 1 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> def check ( n , s ) : <NEWLINE> <INDENT> v = str ( n ) <NEWLINE> for i in v : <NEWLINE> <INDENT> if i in s : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> l = [ ] <NEWLINE> s = input ( ) <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> or i == <STRING> : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( l ) > 0 : <NEWLINE> <INDENT> l . pop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( l ) ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> for _ in range ( 1 ) : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <NL> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( list ( A ) ) <NEWLINE> <NL> import bisect <NEWLINE> <NL> ans = A [ - 1 ] / 2 <NEWLINE> b = bisect . bisect_left ( A , ans ) <NEWLINE> <NL> if abs ( ans - A [ b ] ) < abs ( ans - A [ max ( 0 , b - 1 ) ] ) : <NEWLINE> <INDENT> print ( A [ - 1 ] , A [ b ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A [ - 1 ] , A [ b - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = [ 0 ] * N <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> C [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * C ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> si = input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> sorted_s = <STRING> . join ( sorted ( Counter ( si ) . elements ( ) ) ) <NEWLINE> if sorted_s in dic : <NEWLINE> <INDENT> ans += dic [ sorted_s ] <NEWLINE> dic [ sorted_s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ sorted_s ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> listcost = [ ] <NEWLINE> <NL> for i in range ( min ( a ) , max ( a ) + 1 ) : <NEWLINE> <INDENT> cost = 0 <NEWLINE> for j in a : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> cost += ( i - j ) ** 2 <NEWLINE> <DEDENT> <DEDENT> listcost . append ( cost ) <NEWLINE> <DEDENT> print ( min ( listcost ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> import bisect <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> s_L = sorted ( L ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> ans += bisect . bisect_left ( s_L , s_L [ i ] + s_L [ j ] ) - j - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> sortli = sorted ( li ) <NEWLINE> print ( <STRING> . join ( sortli ) ) <NEWLINE>
N , x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if x < min ( A ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> A . sort ( ) <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> while x > 0 and ans < N : <NEWLINE> <INDENT> if x >= A [ i ] : <NEWLINE> <INDENT> x -= A [ i ] <NEWLINE> ans += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if x > 0 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> r = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> pm = np . array ( [ 1 , - 1 ] * ( n // 2 ) + [ 1 ] ) <NEWLINE> <NL> <NL> d = [ ] <NEWLINE> tmp = sum ( r * pm ) <NEWLINE> d . append ( str ( tmp ) ) <NEWLINE> tmp -= r [ 0 ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> tmp = r [ i ] - tmp <NEWLINE> d . append ( str ( tmp ) ) <NEWLINE> tmp -= r [ i + 1 ] <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( d ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> if K == 1 : print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> factorial = [ 1 for i in range ( N + 1 ) ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i == 1 : factorial [ i ] = 1 <NEWLINE> else : factorial [ i ] = factorial [ i - 1 ] * i % mod <NEWLINE> <NL> <DEDENT> def comb ( n , k ) : <NEWLINE> <INDENT> return factorial [ n ] * pow ( factorial [ n - k ] * factorial [ k ] , - 1 , mod ) <NEWLINE> <NL> <DEDENT> A1 = sorted ( A ) <NEWLINE> A2 = A1 [ : : - 1 ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> ans += ( A2 [ i ] - A1 [ i ] ) * comb ( N - i - 1 , K - 1 ) <NEWLINE> <DEDENT> ans %= mod <NEWLINE> <NL> print ( ans ) <NEWLINE> <DEDENT>
colorn = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> color = colorn [ 0 : 3 ] <NEWLINE> n = colorn [ - 1 ] <NEWLINE> color . sort ( ) <NEWLINE> <NL> a , b , c = color [ 2 ] , color [ 1 ] , color [ 0 ] <NEWLINE> <NL> a_max = n // a <NEWLINE> cnt = 0 <NEWLINE> ip , jp , kp = - 1 , - 1 , - 1 <NEWLINE> <NL> for i in range ( a_max + 1 ) : <NEWLINE> <INDENT> b_max = ( n - a * i ) // b <NEWLINE> d = n - a * i <NEWLINE> flag = 0 <NEWLINE> for j in range ( b_max + 1 ) : <NEWLINE> <INDENT> c_max = ( n - a * i - b * j ) // c <NEWLINE> for k in range ( c_max , c_max + 2 ) : <NEWLINE> <INDENT> if a * i + b * j + c * k == n : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if ip == i : <NEWLINE> <INDENT> dj = j - jp <NEWLINE> cnt += ( ( d // b - j ) // dj ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ip , jp , kp = i , j , k <NEWLINE> <DEDENT> <DEDENT> elif a * i + b * j + c * k > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = float ( <STRING> ) <NEWLINE> S = sum ( A ) <NEWLINE> T = [ ] <NEWLINE> T . append ( A [ 0 ] ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> T . append ( T [ i - 1 ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> if N == 2 : <NEWLINE> <INDENT> ans = abs ( A [ 0 ] - A [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> ans = min ( ans , abs ( S - 2 * T [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def saiki ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> tmp = 0 <NEWLINE> if n <= 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> tmp = int ( n / 2 ) <NEWLINE> return saiki ( tmp ) * 2 + 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> h = int ( input ( ) ) <NEWLINE> print ( saiki ( h ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> sorted_A = sorted ( A ) <NEWLINE> [ print ( sorted_A [ - 2 ] if sorted_A [ - 1 ] == A [ i ] else sorted_A [ - 1 ] ) for i in range ( N ) ] <NEWLINE>
<COMMENT> <NL> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> maze = [ [ ] for _ in range ( H ) ] <NEWLINE> <NL> num_black = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> temp = input ( ) <NEWLINE> for j in temp : <NEWLINE> <INDENT> maze [ i ] . append ( j ) <NEWLINE> if j == <STRING> : <NEWLINE> <INDENT> num_black += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> import copy , collections <NEWLINE> <NL> maze_copy = copy . deepcopy ( maze ) <NEWLINE> color = [ [ <STRING> ] * W for _ in range ( H ) ] <NEWLINE> <NL> <NL> X , Y = 0 , 0 <NEWLINE> vec = [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ] <NEWLINE> color [ Y ] [ X ] = <STRING> <NEWLINE> que = collections . deque ( ) <NEWLINE> maze_copy [ Y ] [ X ] = 1 <NEWLINE> que . append ( [ Y , X ] ) <NEWLINE> <NL> while len ( que ) != 0 : <NEWLINE> <INDENT> u = que . popleft ( ) <NEWLINE> for y , x in vec : <NEWLINE> <INDENT> temp_x = u [ 1 ] + x <NEWLINE> temp_y = u [ 0 ] + y <NEWLINE> if ( 0 <= temp_x < W and 0 <= temp_y < H <NEWLINE> <INDENT> and maze_copy [ temp_y ] [ temp_x ] == <STRING> and color [ temp_y ] [ temp_x ] == <STRING> ) : <NEWLINE> color [ temp_y ] [ temp_x ] = <STRING> <NEWLINE> maze_copy [ temp_y ] [ temp_x ] = maze_copy [ u [ 0 ] ] [ u [ 1 ] ] + 1 <NEWLINE> que . append ( [ temp_y , temp_x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if maze_copy [ - 1 ] [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( W * H - num_black - maze_copy [ - 1 ] [ - 1 ] ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> PS = [ line . split ( ) for line in readlines ( ) ] <NEWLINE> <NL> AC = [ False ] * ( N + 1 ) <NEWLINE> WA_cnt = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> penal = 0 <NEWLINE> for p , s in PS : <NEWLINE> <INDENT> p = int ( p ) <NEWLINE> if AC [ p ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> WA_cnt [ p ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> AC [ p ] = True <NEWLINE> penal += WA_cnt [ p ] <NEWLINE> <NL> <DEDENT> <DEDENT> ac = sum ( AC ) <NEWLINE> print ( ac , penal ) <NEWLINE>
import math <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> gcd = math . gcd ( A , B ) <NEWLINE> ans = [ 1 ] <NEWLINE> while gcd % 2 == 0 : <NEWLINE> <INDENT> ans . append ( 2 ) <NEWLINE> gcd = gcd // 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= gcd : <NEWLINE> <INDENT> if gcd % f == 0 : <NEWLINE> <INDENT> ans . append ( f ) <NEWLINE> gcd = gcd // f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if gcd != 1 : <NEWLINE> <INDENT> ans . append ( gcd ) <NEWLINE> <DEDENT> print ( len ( set ( ans ) ) ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 2019 <NEWLINE> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> if i % 2019 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( l , r + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , r + 1 ) : <NEWLINE> <INDENT> if c > ( j * k % 2019 ) : <NEWLINE> <INDENT> c = ( j * k % 2019 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def LPP ( ) : <NEWLINE> <INDENT> n , m = map ( int , readline ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , readline ( ) . split ( ) ) <NEWLINE> s -= 1 <NEWLINE> t -= 1 <NEWLINE> edges [ s ] . append ( t ) <NEWLINE> <DEDENT> dp = [ - 1 ] * n <NEWLINE> def dfs ( s ) : <NEWLINE> <INDENT> if dp [ s ] != - 1 : <NEWLINE> <INDENT> return dp [ s ] <NEWLINE> <DEDENT> if len ( edges [ s ] ) == 0 : <NEWLINE> <INDENT> dp [ s ] = 0 <NEWLINE> return 0 <NEWLINE> <DEDENT> res = 0 <NEWLINE> for t in edges [ s ] : <NEWLINE> <INDENT> res = max ( res , dfs ( t ) + 1 ) <NEWLINE> <DEDENT> dp [ s ] = res <NEWLINE> return res <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> dfs ( i ) <NEWLINE> <DEDENT> print ( max ( dp ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> LPP ( ) <NEWLINE> <NL>
import heapq <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> <NL> heapq . heapify ( A ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> heapq . heappush ( A , ( - ( ( - heapq . heappop ( A ) ) // 2 ) ) ) <NEWLINE> <DEDENT> print ( - sum ( A ) ) <NEWLINE>
q = int ( input ( ) ) <NEWLINE> <NL> L = [ True ] * ( 10 ** 5 + 1 ) <NEWLINE> <NL> L [ 0 ] , L [ 1 ] = False , False <NEWLINE> <NL> for i in range ( 2 , int ( ( 10 ** 5 ) ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if not L [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> j = 2 <NEWLINE> while i * j <= 10 ** 5 : <NEWLINE> <INDENT> L [ i * j ] = False <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> A = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( 1 , 10 ** 5 + 1 ) : <NEWLINE> <INDENT> if L [ i ] and L [ ( i + 1 ) // 2 ] : <NEWLINE> <INDENT> A [ i ] = A [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ i ] = A [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if l == r : <NEWLINE> <INDENT> if L [ l ] and L [ ( l + 1 ) // 2 ] : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if L [ l ] and L [ ( l + 1 ) // 2 ] : <NEWLINE> <INDENT> print ( A [ r ] - A [ l - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A [ r ] - A [ l ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = ( n + 1 ) * ( n // 2 ) - n <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> ans += n // 2 + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> s = input ( ) . split ( ) <NEWLINE> n = int ( s [ 0 ] ) <NEWLINE> m = int ( s [ 1 ] ) <NEWLINE> l = 0 <NEWLINE> r = float ( <STRING> ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = max ( l , s [ 0 ] ) <NEWLINE> r = min ( r , s [ 1 ] ) <NEWLINE> <DEDENT> a = r - l <NEWLINE> if a >= 0 : <NEWLINE> <INDENT> print ( a + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> import heapq <NEWLINE> <NL> def dijkstra ( s , edge ) : <NEWLINE> <COMMENT> <NL> <INDENT> d = [ float ( <STRING> ) ] * n <NEWLINE> used = [ True ] * n <COMMENT> <NEWLINE> d [ s ] = 0 <NEWLINE> used [ s ] = False <NEWLINE> edgelist = [ ] <NEWLINE> for e in edge [ s ] : <NEWLINE> <INDENT> heapq . heappush ( edgelist , e ) <NEWLINE> <DEDENT> while len ( edgelist ) : <NEWLINE> <INDENT> minedge = heapq . heappop ( edgelist ) <NEWLINE> <COMMENT> <NL> if not used [ minedge [ 1 ] ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v = minedge [ 1 ] <NEWLINE> d [ v ] = minedge [ 0 ] <NEWLINE> used [ v ] = False <NEWLINE> for e in edge [ v ] : <NEWLINE> <INDENT> if used [ e [ 1 ] ] : <NEWLINE> <INDENT> heapq . heappush ( edgelist , [ e [ 0 ] + d [ v ] , e [ 1 ] ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> n , m , s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> s , t = s - 1 , t - 1 <NEWLINE> edge1 = [ [ ] for _ in range ( n ) ] <NEWLINE> edge2 = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> u , v , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edge1 [ u - 1 ] . append ( [ a , v - 1 ] ) <NEWLINE> edge1 [ v - 1 ] . append ( [ a , u - 1 ] ) <NEWLINE> edge2 [ u - 1 ] . append ( [ b , v - 1 ] ) <NEWLINE> edge2 [ v - 1 ] . append ( [ b , u - 1 ] ) <NEWLINE> <DEDENT> d1 = dijkstra ( s , edge1 ) <NEWLINE> d2 = dijkstra ( t , edge2 ) <NEWLINE> INF = 10 ** 15 <NEWLINE> ans = [ INF ] * n <NEWLINE> ans [ n - 1 ] = int ( d1 [ n - 1 ] + d2 [ n - 1 ] ) <NEWLINE> for i in range ( n - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> tmp = int ( d1 [ i ] + d2 [ i ] ) <NEWLINE> ans [ i ] = min ( tmp , ans [ i + 1 ] ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( INF - ans [ i ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> d = { } <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> if d . get ( A [ n ] ) == None : <NEWLINE> <INDENT> d [ A [ n ] ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ A [ n ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> dn = sorted ( d . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> if K >= len ( d ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> for n in range ( len ( dn ) ) : <NEWLINE> <INDENT> ans += dn [ n ] [ 1 ] <NEWLINE> cnt += 1 <NEWLINE> if cnt == len ( d ) - K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> list_A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list_B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list_C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list_A . sort ( ) <NEWLINE> list_B . sort ( ) <NEWLINE> list_C . sort ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b = list_B [ i ] <NEWLINE> left = bisect . bisect_left ( list_A , b ) <NEWLINE> right = n - bisect . bisect_right ( list_C , b ) <NEWLINE> ans += left * right <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 for _ in range ( W + 1 ) ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( W , 0 , - 1 ) : <NEWLINE> <INDENT> if i >= w : <NEWLINE> <INDENT> a = dp [ i ] <NEWLINE> b = dp [ i - w ] + v <NEWLINE> if a > b : <NEWLINE> <INDENT> dp [ i ] = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = b <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = lcm ( C , D ) <NEWLINE> <NL> temp = l - ( l // C + l // D - 1 ) <NEWLINE> <NL> a = ( A - 1 ) % l <NEWLINE> b = B % l <NEWLINE> <NL> aa = ( A - 1 ) // l <NEWLINE> bb = B // l <NEWLINE> <NL> tempA = a - ( a // C + a // D - 1 ) <NEWLINE> tempB = b - ( b // C + b // D - 1 ) <NEWLINE> <NL> <NL> ans = temp * bb + tempB - ( temp * aa + tempA ) <NEWLINE> <NL> <NL> print ( ans ) <NEWLINE>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> T [ i + 1 ] = T [ i ] + ( 1 if S [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( T [ R - 1 ] - T [ L - 1 ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = [ ] <NEWLINE> l = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> cnt . append ( - 1 ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> cnt [ l [ i ] ] = 0 <NEWLINE> <DEDENT> cnt [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if cnt [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ i ] = cnt [ i - 1 ] <NEWLINE> if i > 1 : <NEWLINE> <INDENT> cnt [ i ] += cnt [ i - 2 ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt [ n ] % 1000000007 ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> mn = p [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if mn > p [ i ] : <NEWLINE> <INDENT> mn = p [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> from itertools import accumulate <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , k , * p = map ( int , read ( ) . split ( ) ) <NEWLINE> p2 = [ ( 1 + pe ) / 2 for pe in p ] <NEWLINE> p2a = tuple ( accumulate ( p2 ) ) <NEWLINE> r = p2a [ k - 1 ] <NEWLINE> for i1 in range ( k , n ) : <NEWLINE> <INDENT> r = max ( r , p2a [ i1 ] - p2a [ i1 - k ] ) <NEWLINE> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> cnt = 0 <NEWLINE> for m in range ( 1000 ) : <NEWLINE> <INDENT> m = str ( m ) . zfill ( 3 ) <NEWLINE> j = 0 <NEWLINE> for i in m : <NEWLINE> <INDENT> if i not in s [ j : ] : break <NEWLINE> j += s [ j : ] . index ( i ) + 1 <NEWLINE> <DEDENT> else : cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> tree = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ A ] . append ( B ) <NEWLINE> tree [ B ] . append ( A ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> def dfs ( u , par ) : <NEWLINE> <INDENT> visited [ u ] = True <NEWLINE> ret = 1 <NEWLINE> for v in tree [ u ] : <NEWLINE> <INDENT> if not visited [ v ] : <NEWLINE> <INDENT> ret += dfs ( v , u ) <NEWLINE> <NL> <DEDENT> <DEDENT> if par > 0 : <NEWLINE> <INDENT> tree_dic [ ( u , par ) ] = ret <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> visited = [ False ] * ( N + 1 ) <NEWLINE> tree_dic = { } <NEWLINE> dfs ( 1 , 0 ) <NEWLINE> <COMMENT> <NL> <NL> bumbo = pow ( 2 , N , MOD ) <NEWLINE> bunshi = ( pow ( 2 , N , MOD ) - 1 - N * pow ( 2 , N - 1 , MOD ) ) % MOD <NEWLINE> for x in tree_dic . values ( ) : <NEWLINE> <INDENT> term = ( pow ( 2 , x , MOD ) - 1 ) * ( pow ( 2 , N - x , MOD ) - 1 ) <NEWLINE> bunshi += term <NEWLINE> bunshi %= MOD <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> answer = bunshi * pow ( bumbo , MOD - 2 , MOD ) <NEWLINE> answer %= MOD <NEWLINE> print ( answer ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> sr = s . replace ( <STRING> , <STRING> ) <NEWLINE> if sr == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> elif sr != sr [ : : - 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> cur_l = 0 <NEWLINE> cur_r = n - 1 <NEWLINE> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> while cur_l < cur_r : <NEWLINE> <INDENT> while s [ cur_l ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> cur_l += 1 <NEWLINE> <DEDENT> while s [ cur_r ] != s [ cur_l ] : <NEWLINE> <INDENT> cur_r -= 1 <NEWLINE> cnt -= 1 <NEWLINE> <DEDENT> ans += abs ( cnt ) <NEWLINE> cur_l += 1 <NEWLINE> cur_r -= 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> cnt = N - 1 <NEWLINE> for i in range ( 1 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> cnt = min ( cnt , N // i + i - 2 ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from math import * <NEWLINE> <NL> def gcd ( x , y ) : <NEWLINE> <INDENT> while y != 0 : <NEWLINE> <INDENT> ( x , y ) = ( y , x % y ) <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def lcm ( x , y ) : <NEWLINE> <INDENT> return x * y // gcd ( x , y ) <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> mod = 1000000000 + 7 <NEWLINE> <NL> k = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> k = lcm ( k , x ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> ans += k // x <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> py = [ list ( map ( int , input ( ) . split ( ) ) ) + [ i ] for i in range ( M ) ] <NEWLINE> py . sort ( ) <NEWLINE> P = py [ 0 ] [ 0 ] <NEWLINE> c = 0 <NEWLINE> ans = [ ] <NEWLINE> for p , y , i in py : <NEWLINE> <INDENT> if p == P : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = p <NEWLINE> c = 1 <NEWLINE> <DEDENT> ansc = str ( c ) <NEWLINE> ansp = str ( p ) <NEWLINE> anser = <STRING> * ( 6 - len ( ansp ) ) + ansp + <STRING> * ( 6 - len ( ansc ) ) + ansc <NEWLINE> ans . append ( [ i , anser ] ) <NEWLINE> <DEDENT> ans . sort ( ) <NEWLINE> for i , anser in ans : <NEWLINE> <INDENT> print ( anser ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> east = S . count ( <STRING> ) <NEWLINE> west = 0 <NEWLINE> <NL> <NL> res = 1000000 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> east -= 1 <NEWLINE> <DEDENT> res = min ( res , east + west ) <NEWLINE> if S [ i ] == <STRING> : <NEWLINE> <INDENT> west += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import collections <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> px = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> c = [ [ ] for _ in range ( n ) ] <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> a , b = a - 1 , b - 1 <NEWLINE> c [ a ] . append ( b ) <NEWLINE> c [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> point = [ 0 ] * n <NEWLINE> for p , x in px : <NEWLINE> <INDENT> point [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> parents = [ 0 ] * n <NEWLINE> ans = [ 0 ] * n <NEWLINE> q = collections . deque ( ) <NEWLINE> q . append ( 0 ) <NEWLINE> while q : <NEWLINE> <INDENT> v = q . pop ( ) <NEWLINE> ans [ v ] = ans [ parents [ v ] ] + point [ v ] <NEWLINE> for i in c [ v ] : <NEWLINE> <INDENT> if i == parents [ v ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> parents [ i ] = v <NEWLINE> q . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( list ( map ( str , ans ) ) ) ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> a = ( n * m ) // math . gcd ( n , m ) <NEWLINE> b0 = [ i * ( a // n ) + 1 for i in range ( n ) ] <NEWLINE> b1 = [ i * ( a // m ) + 1 for i in range ( m ) ] <NEWLINE> b2 = set ( b0 ) <NEWLINE> b3 = set ( b1 ) <NEWLINE> <NL> for j , i in enumerate ( b0 ) : <NEWLINE> <INDENT> if i in b3 : <NEWLINE> <INDENT> if s [ j ] != t [ b1 . index ( i ) ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for j , i in enumerate ( b1 ) : <NEWLINE> <INDENT> if i in b2 : <NEWLINE> <INDENT> if s [ b0 . index ( i ) ] != t [ j ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
a , b , c = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> print ( a [ 0 ] . upper ( ) + b [ 0 ] . upper ( ) + c [ 0 ] . upper ( ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = [ [ 0 ] for _ in range ( n + 1 ) ] <NEWLINE> d1 = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d [ a ] . append ( b ) <NEWLINE> d [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> d1 [ p ] += x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> vi = [ - 1 for _ in range ( n + 1 ) ] <NEWLINE> <NL> def dfs ( x , i ) : <NEWLINE> <INDENT> vi [ x ] = i + d1 [ x ] <NEWLINE> for m in d [ x ] : <NEWLINE> <INDENT> if vi [ m ] == - 1 and m != 0 : <NEWLINE> <INDENT> dfs ( m , vi [ x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 1 , 0 ) <NEWLINE> <NL> <NL> print ( * vi [ 1 : ] ) <NEWLINE>
<NL> def is_triangle ( a , b , c ) : <NEWLINE> <INDENT> if a >= b + c : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> if b >= a + c : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> if c >= a + b : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> L = list ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> L . sort ( reverse = True ) <NEWLINE> <NL> count = 0 <NEWLINE> for a_i in range ( N - 2 ) : <NEWLINE> <INDENT> b_i = a_i + 1 <NEWLINE> c_i = 1 <NEWLINE> while b_i + c_i < N : <NEWLINE> <NL> <INDENT> if not is_triangle ( L [ a_i ] , L [ b_i ] , L [ - c_i ] ) : <NEWLINE> <INDENT> c_i += 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> count += ( N - b_i - c_i ) <NEWLINE> b_i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> adj_matrix = [ [ 0 ] * N for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> adj_matrix [ a - 1 ] [ b - 1 ] = 1 <NEWLINE> adj_matrix [ b - 1 ] [ a - 1 ] = 1 <NEWLINE> <NL> <DEDENT> def dfs ( v , used ) : <NEWLINE> <INDENT> if not False in used : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if not adj_matrix [ v ] [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if used [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> used [ i ] = True <NEWLINE> ans += dfs ( i , used ) <NEWLINE> used [ i ] = False <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> used = [ False ] * N <NEWLINE> used [ 0 ] = True <NEWLINE> <NL> print ( dfs ( 0 , used ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b == 1 : print ( 0 ) <NEWLINE> elif a == b : print ( 1 ) <NEWLINE> else : <NEWLINE> <INDENT> if ( b - 1 ) % ( a - 1 ) > 0 : print ( ( b - 1 ) // ( a - 1 ) + 1 ) <NEWLINE> else : print ( ( b - 1 ) // ( a - 1 ) ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b , c = [ ] , [ ] , [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( A ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if a [ i ] [ 1 ] == n : <NEWLINE> <INDENT> b . append ( a [ i ] [ 0 ] ) <NEWLINE> <DEDENT> elif a [ i ] [ 0 ] == 1 : <NEWLINE> <INDENT> c . append ( a [ i ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( set ( b ) & set ( c ) ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> check = list ( s ) <NEWLINE> n = len ( s ) <NEWLINE> cntb = 0 <NEWLINE> for i in check : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> cntb += 1 <NEWLINE> <DEDENT> <DEDENT> minus = sum ( [ i + 1 for i in range ( n ) if check [ i ] == <STRING> ] ) <NEWLINE> plus = sum ( range ( n - cntb + 1 , n + 1 ) ) <NEWLINE> print ( plus - minus ) <NEWLINE>
N , K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i < K : <NEWLINE> <INDENT> P . append ( str ( S ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if S < 10 ** 9 : <NEWLINE> <INDENT> P . append ( str ( S + 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P . append ( str ( 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( P ) ) <NEWLINE>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = 0 <NEWLINE> i = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> <NL> while d <= X : <NEWLINE> <INDENT> ans += 1 <NEWLINE> d += L [ i ] <NEWLINE> i += 1 <NEWLINE> if i == N : <NEWLINE> <INDENT> if d <= X : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from math import gcd , pi , sqrt <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import itertools <NEWLINE> from collections import Counter , deque <NEWLINE> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> k , s = i_map ( ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if 0 <= z <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , X = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> x . append ( X ) <NEWLINE> x . sort ( ) <NEWLINE> <NL> d = [ ] <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> d . append ( x [ n ] - x [ n - 1 ] ) <NEWLINE> <NL> <DEDENT> def gcd ( a , b ) : <NEWLINE> <INDENT> x = max ( a , b ) <NEWLINE> y = min ( a , b ) <NEWLINE> tmp = x % y <NEWLINE> if tmp == 0 : <NEWLINE> <INDENT> return y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( y , tmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( d ) <= 1 : <NEWLINE> <INDENT> print ( d [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D = d [ 0 ] <NEWLINE> for i in range ( 1 , len ( d ) ) : <NEWLINE> <INDENT> D = gcd ( D , d [ i ] ) <NEWLINE> <DEDENT> print ( D ) <NEWLINE> <DEDENT>
def solve ( s ) : <NEWLINE> <INDENT> n = len ( s ) <NEWLINE> res = 0 <NEWLINE> i = 0 <NEWLINE> num = 0 <NEWLINE> while i < n - 1 : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> num += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> elif s [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> res += num <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = 0 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> print ( solve ( s ) ) <NEWLINE>
import numpy as np <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A1 = np . zeros ( n , dtype = bool ) <NEWLINE> Ai = np . zeros ( n , dtype = bool ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> A1 [ b - 1 ] = True <NEWLINE> <DEDENT> if b == n : <NEWLINE> <INDENT> Ai [ a - 1 ] = True <NEWLINE> <DEDENT> <DEDENT> if np . any ( Ai [ A1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> x_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x_lst . sort ( ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> minimum = abs ( x_lst [ 0 ] - x ) <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> minimum = abs ( x_lst [ 1 ] - x_lst [ 0 ] ) <NEWLINE> lst = [ abs ( x_lst [ 1 ] - x ) , abs ( x_lst [ 0 ] - x ) ] <NEWLINE> lst . sort ( ) <NEWLINE> lst . reverse ( ) <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> if minimum % lst [ i ] == 0 : <NEWLINE> <INDENT> minimum = lst [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> lst1 = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i != n - 1 : <NEWLINE> <INDENT> lst1 . append ( abs ( x_lst [ i + 1 ] - x_lst [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> minimum = math . gcd ( lst1 [ 0 ] , lst1 [ 1 ] ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if i != n - 2 : <NEWLINE> <INDENT> minimum = min ( minimum , math . gcd ( lst1 [ i ] , lst1 [ i + 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> lst2 = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lst2 . append ( abs ( x_lst [ i ] - x ) ) <NEWLINE> <NL> <DEDENT> lst2 . sort ( ) <NEWLINE> lst2 . reverse ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if minimum % lst2 [ i ] == 0 : <NEWLINE> <INDENT> minimum = lst2 [ i ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( minimum ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> <NL> <NL> def dfs ( s ) : <NEWLINE> <INDENT> for i in to [ s ] : <NEWLINE> <INDENT> if not toflag [ i ] : <NEWLINE> <INDENT> toflag [ i ] = True <NEWLINE> dfs ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def rdfs ( s ) : <NEWLINE> <INDENT> for i in ot [ s ] : <NEWLINE> <INDENT> if not otflag [ i ] : <NEWLINE> <INDENT> otflag [ i ] = True <NEWLINE> rdfs ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def bellman_ford ( ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> upd = False <NEWLINE> for a , b , c in edges : <NEWLINE> <INDENT> if d [ b ] > d [ a ] + c : <NEWLINE> <INDENT> upd = True <NEWLINE> d [ b ] = d [ a ] + c <NEWLINE> <DEDENT> <DEDENT> if not upd : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i == n - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b , c = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> edges . append ( [ a , b , - ( c + 1 - p ) ] ) <NEWLINE> to [ a ] . append ( b ) <NEWLINE> ot [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> toflag [ 0 ] = True <NEWLINE> otflag [ n - 1 ] = True <NEWLINE> dfs ( 0 ) <COMMENT> <NEWLINE> rdfs ( n - 1 ) <COMMENT> <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b , c = edges [ i ] <NEWLINE> if toflag [ a ] and otflag [ a ] and toflag [ b ] and otflag [ b ] : continue ; <NEWLINE> edges [ i ] = [ 0 , 0 , 0 ] <NEWLINE> <NL> <DEDENT> d [ 0 ] = 0 <NEWLINE> bellman_ford ( ) <NEWLINE> print ( max ( 0 , - d [ - 1 ] ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m , p = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ ] <NEWLINE> to = [ [ ] for i in range ( n ) ] <NEWLINE> ot = [ [ ] for i in range ( n ) ] <NEWLINE> toflag = [ False ] * n <NEWLINE> otflag = [ False ] * n <NEWLINE> d = [ 10 ** 9 ] * n <NEWLINE> main ( ) <NEWLINE> <DEDENT>
from operator import itemgetter <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> yp = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p_ , y_ = map ( int , input ( ) . split ( ) ) <NEWLINE> yp . append ( [ y_ , p_ , i + 1 ] ) <NEWLINE> <DEDENT> py = sorted ( yp ) <NEWLINE> ken = [ 0 ] * n <NEWLINE> res = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ken [ py [ i ] [ 1 ] - 1 ] += 1 <NEWLINE> p , q , r = py [ i ] [ 1 ] , ken [ py [ i ] [ 1 ] - 1 ] , py [ i ] [ 2 ] <NEWLINE> res . append ( [ p , q , r ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> res . sort ( key = itemgetter ( 2 ) ) <NEWLINE> <COMMENT> <NL> for i in range ( m ) : <NEWLINE> <INDENT> ans1 = [ 0 ] * ( 6 - len ( str ( res [ i ] [ 0 ] ) ) ) <NEWLINE> ans1 . append ( res [ i ] [ 0 ] ) <NEWLINE> ans2 = [ 0 ] * ( 6 - len ( str ( res [ i ] [ 1 ] ) ) ) <NEWLINE> ans2 . append ( res [ i ] [ 1 ] ) <NEWLINE> print ( * ans1 , * ans2 , sep = <STRING> ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def search ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> pos = deque ( [ ] ) <NEWLINE> <NL> D = [ [ True ] * ( W + 2 ) ] <COMMENT> <NEWLINE> D += [ [ True ] + [ False ] * W + [ True ] for i in range ( H ) ] <COMMENT> <NEWLINE> D . append ( [ True ] * ( W + 2 ) ) <COMMENT> <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> maze = input ( ) <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> if maze [ j ] == <STRING> : <NEWLINE> <INDENT> pos . append ( [ i + 1 , j + 1 , 0 ] ) <NEWLINE> D [ i + 1 ] [ j + 1 ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while len ( pos ) > 0 : <COMMENT> <NEWLINE> <INDENT> h , w , depth = pos . popleft ( ) <NEWLINE> if not D [ h + 1 ] [ w ] : <NEWLINE> <INDENT> pos . append ( [ h + 1 , w , depth + 1 ] ) <NEWLINE> D [ h + 1 ] [ w ] = True <NEWLINE> <NL> <DEDENT> if not D [ h - 1 ] [ w ] : <NEWLINE> <INDENT> pos . append ( [ h - 1 , w , depth + 1 ] ) <NEWLINE> D [ h - 1 ] [ w ] = True <NEWLINE> <NL> <DEDENT> if not D [ h ] [ w + 1 ] : <NEWLINE> <INDENT> pos . append ( [ h , w + 1 , depth + 1 ] ) <NEWLINE> D [ h ] [ w + 1 ] = True <NEWLINE> <NL> <DEDENT> if not D [ h ] [ w - 1 ] : <NEWLINE> <INDENT> pos . append ( [ h , w - 1 , depth + 1 ] ) <NEWLINE> D [ h ] [ w - 1 ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> return depth <NEWLINE> <NL> <DEDENT> print ( search ( ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ls = [ ] <NEWLINE> for i in range ( 1 , int ( m ** ( 1 / 2 ) ) + 1 ) : <NEWLINE> <INDENT> if m % i == 0 : <NEWLINE> <INDENT> ls . append ( i ) <NEWLINE> ls . append ( m // i ) <NEWLINE> <DEDENT> <DEDENT> ls = sorted ( list ( set ( ls ) ) , reverse = True ) <NEWLINE> for j in ls : <NEWLINE> <INDENT> if j * n <= m : <NEWLINE> <INDENT> print ( j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> import numpy as np <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N - 1 ) ] <NEWLINE> P = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> link = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> link [ A [ i ] [ 0 ] - 1 ] . append ( A [ i ] [ 1 ] - 1 ) <NEWLINE> link [ A [ i ] [ 1 ] - 1 ] . append ( A [ i ] [ 0 ] - 1 ) <NEWLINE> <NL> <NL> <DEDENT> ans = [ 0 for _ in range ( N ) ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> ans [ P [ i ] [ 0 ] - 1 ] += P [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> dist = [ - 1 for _ in range ( N ) ] <NEWLINE> dist [ 0 ] = 0 <NEWLINE> d = deque ( [ 0 ] ) <NEWLINE> while d : <NEWLINE> <INDENT> now = d . pop ( ) <NEWLINE> for i in range ( len ( link [ now ] ) ) : <NEWLINE> <INDENT> if dist [ link [ now ] [ i ] ] == - 1 : <NEWLINE> <INDENT> ans [ link [ now ] [ i ] ] += ans [ now ] <NEWLINE> dist [ link [ now ] [ i ] ] = 0 <NEWLINE> d . append ( link [ now ] [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i != N - 1 : <NEWLINE> <INDENT> print ( ans [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> l , r = [ 0 ] * N , [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> l [ b - 1 ] = 1 <NEWLINE> <DEDENT> if b == N : <NEWLINE> <INDENT> r [ a - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if l [ i ] + r [ i ] == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def is_valid ( ) : <NEWLINE> <INDENT> x_removed_S = S . replace ( <STRING> , <STRING> ) <NEWLINE> M = len ( x_removed_S ) <NEWLINE> for i in range ( M // 2 ) : <NEWLINE> <INDENT> if x_removed_S [ i ] != x_removed_S [ M - i - 1 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> if is_valid ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> left , right = 0 , N - 1 <NEWLINE> while left < right : <NEWLINE> <INDENT> if S [ left ] == S [ right ] : <NEWLINE> <INDENT> left += 1 <NEWLINE> right -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif S [ left ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> left += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> right -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> al = <STRING> <NEWLINE> AL = al . upper ( ) <NEWLINE> <NL> n , m = I ( ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> a += [ list ( input ( ) ) ] <NEWLINE> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> b += [ list ( input ( ) ) ] <NEWLINE> <NL> <DEDENT> for i in range ( n - m + 1 ) : <NEWLINE> <INDENT> for j in range ( n - m + 1 ) : <NEWLINE> <INDENT> if [ k [ j : m + j ] for k in a [ i : m + i ] ] == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> a = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> print ( a [ ( ( a . index ( S ) + 1 ) ) % 3 ] ) <NEWLINE>
from math import * <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ a [ 0 ] ] <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> l . append ( gcd ( a [ i ] , l [ i - 1 ] ) ) <NEWLINE> <NL> <DEDENT> ans = l [ n - 2 ] <NEWLINE> r = a [ n - 1 ] <NEWLINE> for i in range ( n - 2 , 0 , - 1 ) : <NEWLINE> <INDENT> r = gcd ( r , a [ i + 1 ] ) <NEWLINE> ans = max ( ans , gcd ( l [ i - 1 ] , r ) ) <NEWLINE> <DEDENT> ans = max ( ans , gcd ( r , a [ 1 ] ) ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sorted_a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sorted_a . append ( [ a [ i ] , i ] ) <NEWLINE> <NL> <DEDENT> sorted_a . sort ( ) <NEWLINE> <COMMENT> <NL> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( sorted_a [ i ] [ 1 ] + 1 ) <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> map = { ( chr ( ord ( <STRING> ) + i ) ) : ( 26 - i ) % 26 for i in range ( 26 ) } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if k >= map [ s [ i ] ] : <NEWLINE> <INDENT> k -= map [ s [ i ] ] <NEWLINE> s [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if k > 0 : <NEWLINE> <INDENT> s [ n - 1 ] = chr ( ( ord ( s [ n - 1 ] ) + k % 26 ) % 123 ) <NEWLINE> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE>
from collections import deque <NEWLINE> S = deque ( list ( map ( int , list ( input ( ) ) ) ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> while S : <NEWLINE> <INDENT> if S [ 0 ] == 1 : <NEWLINE> <INDENT> S . popleft ( ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> result = 1 if K <= i else S [ 0 ] <NEWLINE> print ( result ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> div_flg = False <NEWLINE> inc_flg = False <NEWLINE> dec_flg = False <NEWLINE> ans = 0 <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if inc_flg : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if A [ i ] <= A [ i + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> inc_flg = False <NEWLINE> div_flg = False <NEWLINE> <DEDENT> <DEDENT> elif dec_flg : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if A [ i ] >= A [ i + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dec_flg = False <NEWLINE> div_flg = False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> div_flg = True <NEWLINE> <DEDENT> elif i == N - 1 : <NEWLINE> <INDENT> if not div_flg : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> if not div_flg : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> div_flg = True <NEWLINE> continue <NEWLINE> <DEDENT> elif A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> if not div_flg : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> inc_flg = True <NEWLINE> continue <NEWLINE> <DEDENT> elif A [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> if not div_flg : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> dec_flg = True <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 110000 ) <COMMENT> <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( 110000 ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph [ x ] . append ( y ) <NEWLINE> <NL> <DEDENT> dp_memo = [ - 1 ] * 110000 <NEWLINE> <NL> def dp ( v ) : <NEWLINE> <INDENT> if dp_memo [ v ] != - 1 : <NEWLINE> <INDENT> return dp_memo [ v ] <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> for item in graph [ v ] : <NEWLINE> <INDENT> ret = max ( ret , dp ( item ) + 1 ) <NEWLINE> <NL> <DEDENT> dp_memo [ v ] = ret <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , dp ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> s = deque ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> while len ( s ) > 1 : <NEWLINE> <INDENT> if s [ 0 ] == s [ - 1 ] : <NEWLINE> <INDENT> s . pop ( ) <NEWLINE> s . popleft ( ) <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> s . popleft ( ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> elif s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> s . pop ( ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
def num ( ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * ( y + 1 ) <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( y , w - 1 , - 1 ) : <NEWLINE> <INDENT> num = dp [ j - w ] + v <NEWLINE> if num > dp [ j ] : <NEWLINE> <INDENT> dp [ j ] = num <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <DEDENT> num ( ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> table = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> list . sort ( table ) <NEWLINE> if num == 2 : <NEWLINE> <INDENT> if table [ 0 ] == table [ 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , num - 1 ) : <NEWLINE> <INDENT> if num == 2 : <NEWLINE> <INDENT> if table [ 0 ] == table [ 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> elif table [ i ] == table [ i + 1 ] or table [ i - 1 ] == table [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if count == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> V = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> eve = V [ 0 : : 2 ] <NEWLINE> odd = V [ 1 : : 2 ] <NEWLINE> cntEve = collections . Counter ( eve ) <NEWLINE> cntOdd = collections . Counter ( odd ) <NEWLINE> <NL> if cntEve . most_common ( ) [ 0 ] [ 0 ] == cntOdd . most_common ( ) [ 0 ] [ 0 ] : <NEWLINE> <INDENT> if len ( cntEve ) == 1 and len ( cntOdd ) > 1 : <NEWLINE> <INDENT> ans = N - max ( cntEve . most_common ( ) [ 0 ] [ 1 ] , cntOdd . most_common ( ) [ 0 ] [ 1 ] ) - cntOdd . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <DEDENT> elif len ( cntEve ) > 1 and len ( cntOdd ) == 1 : <NEWLINE> <INDENT> ans = N - max ( cntEve . most_common ( ) [ 0 ] [ 1 ] , cntOdd . most_common ( ) [ 0 ] [ 1 ] ) - cntEve . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <DEDENT> elif len ( cntEve ) == 1 and len ( cntOdd ) == 1 : <NEWLINE> <INDENT> ans = N - max ( cntEve . most_common ( ) [ 0 ] [ 1 ] , cntOdd . most_common ( ) [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = N - max ( cntEve . most_common ( ) [ 0 ] [ 1 ] , cntOdd . most_common ( ) [ 0 ] [ 1 ] ) - max ( cntEve . most_common ( ) [ 1 ] [ 1 ] , cntOdd . most_common ( ) [ 1 ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = N - int ( cntEve . most_common ( ) [ 0 ] [ 1 ] ) - int ( cntOdd . most_common ( ) [ 0 ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> from collections import defaultdict <NEWLINE> from heapq import heappush , heappop <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> INF = 10 ** 9 + 1 <COMMENT> <NEWLINE> <NL> <NL> def debug ( * x ) : <NEWLINE> <INDENT> print ( * x ) <NEWLINE> <NL> <NL> <DEDENT> def solve0 ( N , M , edges ) : <NEWLINE> <INDENT> path = edges . copy ( ) <NEWLINE> exists = 1 <NEWLINE> for i in range ( 2 , M + 1 ) : <NEWLINE> <INDENT> next_path = defaultdict ( set ) <NEWLINE> for v1 in path : <NEWLINE> <INDENT> for v2 in path [ v1 ] : <NEWLINE> <INDENT> if edges [ v2 ] : <NEWLINE> <INDENT> next_path [ v1 ] . update ( edges [ v2 ] ) <NEWLINE> exists = i <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if exists != i : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <DEDENT> path = next_path <NEWLINE> <DEDENT> return exists <NEWLINE> <NL> <NL> <DEDENT> def solve ( N , M , edges ) : <NEWLINE> <INDENT> longest = { } <NEWLINE> <NL> def get_longest ( start ) : <NEWLINE> <INDENT> if longest . get ( start ) != None : <NEWLINE> <INDENT> return longest [ start ] <NEWLINE> <NL> <DEDENT> next_edges = edges . get ( start ) <NEWLINE> if not next_edges : <NEWLINE> <INDENT> ret = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = max ( get_longest ( v ) for v in edges [ start ] ) + 1 <NEWLINE> <DEDENT> longest [ start ] = ret <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> return max ( get_longest ( v ) for v in edges ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( N , M , edges ) : <NEWLINE> <INDENT> import numba <NEWLINE> longest = [ - 1 ] * ( N + 1 ) <NEWLINE> <NL> def intlist ( xs ) : <NEWLINE> <INDENT> if xs : <NEWLINE> <INDENT> return list ( xs ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return numba . typed . List ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> edges = [ intlist ( edges [ k ] ) for k in range ( N + 1 ) ] <NEWLINE> @ numba . njit <NEWLINE> def get_longest ( start , edges ) : <NEWLINE> <INDENT> if longest [ start ] != - 1 : <NEWLINE> <INDENT> return longest [ start ] <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> for v in edges [ start ] : <NEWLINE> <INDENT> x = get_longest ( v , edges ) + 1 <NEWLINE> if x > ret : <NEWLINE> <INDENT> ret = x <NEWLINE> <DEDENT> <DEDENT> longest [ start ] = ret <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> for v in range ( N + 1 ) : <NEWLINE> <INDENT> x = get_longest ( v , edges ) <NEWLINE> if x > ret : <NEWLINE> <INDENT> ret = x <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def solve ( N , M , edges ) : <NEWLINE> <INDENT> longest = [ - 1 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if not edges [ i ] : <NEWLINE> <INDENT> longest [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> def get_longest ( start ) : <NEWLINE> <INDENT> next = edges [ start ] <NEWLINE> for v in next : <NEWLINE> <INDENT> if longest [ v ] == - 1 : <NEWLINE> <INDENT> longest [ v ] = get_longest ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> ret = max ( longest [ v ] for v in next ) + 1 <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if longest [ i ] == - 1 : <NEWLINE> <INDENT> longest [ i ] = get_longest ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> return max ( longest [ v ] for v in edges ) <NEWLINE> <NL> <NL> <DEDENT> T1 = <STRING> <NEWLINE> <NL> T2 = <STRING> <NEWLINE> <NL> T3 = <STRING> <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = defaultdict ( set ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> v1 , v2 = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ v1 ] . add ( v2 ) <NEWLINE> <NL> <DEDENT> print ( solve ( N , M , edges ) ) <NEWLINE> <NL> <NL> <DEDENT> def _test ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> <NL> <NL> <DEDENT> def as_input ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import io <NEWLINE> global read , input <NEWLINE> f = io . StringIO ( s . strip ( ) ) <NEWLINE> input = f . readline <NEWLINE> read = f . read <NEWLINE> <NL> <NL> <DEDENT> USE_NUMBA = False <NEWLINE> if ( USE_NUMBA and sys . argv [ - 1 ] == <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , solve . __doc__ . strip ( ) . split ( ) [ 0 ] ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <NL> if ( USE_NUMBA and sys . argv [ - 1 ] != <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> from my_module import solve <COMMENT> <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> _test ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] != <STRING> and len ( sys . argv ) == 2 : <NEWLINE> <COMMENT> <NL> <INDENT> input_as_file = open ( sys . argv [ 1 ] ) <NEWLINE> input = input_as_file . buffer . readline <NEWLINE> read = input_as_file . buffer . read <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( lambda x : x * ( - 1 ) , a ) ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> while m > 0 : <NEWLINE> <INDENT> ma = heapq . heappop ( a ) * ( - 1 ) <NEWLINE> ma //= 2 <NEWLINE> heapq . heappush ( a , ma * ( - 1 ) ) <NEWLINE> m -= 1 <NEWLINE> <DEDENT> print ( sum ( a ) * ( - 1 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = [ i for i in range ( 1 , int ( N ** .5 ) + 1 ) ] [ : : - 1 ] <NEWLINE> for i in P : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> print ( len ( str ( N // i ) ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> E = int ( input ( ) ) <NEWLINE> X = [ A % 10 , B % 10 , C % 10 , D % 10 , E % 10 ] <NEWLINE> minimum = 100 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if X [ i ] != 0 : <NEWLINE> <INDENT> minimum = min ( minimum , X [ i ] ) <NEWLINE> <DEDENT> <DEDENT> Y = [ A , B , C , D , E ] <NEWLINE> if minimum == 100 : <NEWLINE> <INDENT> minimum = 0 <NEWLINE> <DEDENT> last = X . index ( minimum ) <NEWLINE> time = 0 <NEWLINE> import math <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if i != last : <NEWLINE> <INDENT> time = time + 10 * math . ceil ( Y [ i ] / 10 ) <NEWLINE> <DEDENT> <DEDENT> if X == [ 0 , 0 , 0 , 0 , 0 ] : <NEWLINE> <INDENT> print ( sum ( Y ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( time + Y [ last ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def eratosthenes ( n ) : <NEWLINE> <INDENT> era_list = [ 1 ] * ( n + 1 ) <NEWLINE> era_list [ 0 ] = 0 ; era_list [ 1 ] = 0 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if era_list [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = i + i <NEWLINE> while j <= n : <NEWLINE> <INDENT> era_list [ j ] = 0 <NEWLINE> j += i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return era_list <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> PN = eratosthenes ( 100001 ) <NEWLINE> TF = [ 0 ] * 100001 <NEWLINE> <NL> for i in range ( 1 , 100001 , 2 ) : <NEWLINE> <INDENT> if PN [ i ] == 1 and PN [ int ( ( i + 1 ) / 2 ) ] == 1 : <NEWLINE> <INDENT> TF [ i ] = 1 + TF [ i - 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> TF [ i ] = TF [ i - 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( 1 , Q + 1 ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> Ans = TF [ r ] - TF [ l - 2 ] <NEWLINE> print ( Ans ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> field = <STRING> <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> field += input ( ) <NEWLINE> <NL> <DEDENT> def bfs ( start ) : <NEWLINE> <INDENT> dist = [ 0 ] * ( H * W ) <NEWLINE> q = deque ( [ start ] ) <NEWLINE> while q : <NEWLINE> <INDENT> p = q . popleft ( ) <NEWLINE> c = dist [ p ] + 1 <NEWLINE> if p - W != start and p - W >= 0 and field [ p - W ] == <STRING> and dist [ p - W ] == 0 : <NEWLINE> <INDENT> dist [ p - W ] = c <NEWLINE> q . append ( p - W ) <NEWLINE> <DEDENT> if p + W != start and p + W < H * W and field [ p + W ] == <STRING> and dist [ p + W ] == 0 : <NEWLINE> <INDENT> dist [ p + W ] = c <NEWLINE> q . append ( p + W ) <NEWLINE> <DEDENT> if p - 1 != start and p - 1 >= 0 and field [ p - 1 ] == <STRING> and dist [ p - 1 ] == 0 and p % W != 0 : <NEWLINE> <INDENT> dist [ p - 1 ] = c <NEWLINE> q . append ( p - 1 ) <NEWLINE> <DEDENT> if p + 1 != start and p + 1 < H * W and field [ p + 1 ] == <STRING> and dist [ p + 1 ] == 0 and p % W != W - 1 : <NEWLINE> <INDENT> dist [ p + 1 ] = c <NEWLINE> q . append ( p + 1 ) <NEWLINE> <DEDENT> <DEDENT> return dist [ p ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for s in range ( H * W ) : <NEWLINE> <INDENT> if field [ s ] == <STRING> : <NEWLINE> <INDENT> ans = max ( ans , bfs ( s ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> def ii ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def mi ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def li2 ( N ) : return [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> def dp2 ( ini , i , j ) : return [ [ ini ] * i for _ in range ( j ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = ii ( ) <NEWLINE> V = li ( ) <NEWLINE> C = li ( ) <NEWLINE> <NL> sa = [ V [ i ] - C [ i ] for i in range ( N ) if V [ i ] - C [ i ] > 0 ] <NEWLINE> <NL> print ( sum ( sa ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in A : <NEWLINE> <INDENT> if j >> i & 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> ans += pow ( 2 , i , mod ) * c * ( N - c ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nu1 = 2 <NEWLINE> nu2 = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> nu3 = nu1 + nu2 <NEWLINE> nu1 = nu2 <NEWLINE> nu2 = nu3 <NEWLINE> <DEDENT> <DEDENT> print ( nu3 ) <NEWLINE>
import math <NEWLINE> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x == a ** 2 * b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif 2 * x <= ( a ** 2 ) * b : <NEWLINE> <INDENT> print ( math . degrees ( math . atan ( ( b ** 2 ) * a / ( 2 * x ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 90 - math . degrees ( math . atan ( ( a ** 3 ) / ( 2 * ( ( a ** 2 ) * b - x ) ) ) ) ) <NEWLINE> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> ans = <STRING> <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , H - 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , W - 1 ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> and s [ i ] [ j + 1 ] == s [ i + 1 ] [ j ] == s [ i ] [ j - 1 ] == s [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> max_len = 0 <NEWLINE> j = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> while j < n and s [ i : j ] in s [ j : ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> max_len = max ( max_len , j - i - 1 ) <NEWLINE> <NL> <DEDENT> print ( max_len ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , w = map ( int , input ( ) . split ( ) ) <NEWLINE> wv = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> dp = [ 0 ] * ( w + 1 ) <NEWLINE> for wi , vi in wv : <NEWLINE> <INDENT> for sum_w in range ( w , wi - 1 , - 1 ) : <NEWLINE> <INDENT> v = dp [ sum_w - wi ] + vi <NEWLINE> if dp [ sum_w ] < v : <NEWLINE> <INDENT> dp [ sum_w ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ w ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> C = defaultdict ( int ) <NEWLINE> for a in A : <NEWLINE> <INDENT> C [ a ] += 1 <NEWLINE> <DEDENT> C = sorted ( C . items ( ) , key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> rods = [ ] <NEWLINE> for k , v in C : <NEWLINE> <INDENT> if v >= 4 : <NEWLINE> <INDENT> rods . append ( k ) <NEWLINE> rods . append ( k ) <NEWLINE> break <NEWLINE> <DEDENT> if v >= 2 : <NEWLINE> <INDENT> rods . append ( k ) <NEWLINE> <DEDENT> if len ( rods ) == 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if len ( rods ) >= 2 : <NEWLINE> <INDENT> ans = rods [ 0 ] * rods [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> n = int ( s ) <NEWLINE> <NL> answer = [ ] <NEWLINE> <NL> x = 1 <NEWLINE> answer . append ( x ) <NEWLINE> <NL> while ( x * x <= n ) : <NEWLINE> <INDENT> x += 1 <NEWLINE> answer . append ( x * x ) <NEWLINE> <NL> <DEDENT> p = answer . pop ( ) <NEWLINE> if p == 1 : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = answer . pop ( ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> c_dic = { } <NEWLINE> for i in a : <NEWLINE> <INDENT> if i not in c_dic : <NEWLINE> <INDENT> c_dic [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c_dic [ i ] += 1 <NEWLINE> <NL> <DEDENT> if i + 1 not in c_dic : <NEWLINE> <INDENT> c_dic [ i + 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c_dic [ i + 1 ] += 1 <NEWLINE> <NL> <DEDENT> if i - 1 not in c_dic : <NEWLINE> <INDENT> c_dic [ i - 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c_dic [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( c_dic . values ( ) ) ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( A - K , B ) <NEWLINE> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> print ( 0 , B + A - K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> ls = len ( S ) <NEWLINE> odd_list = [ ] <NEWLINE> result = <STRING> <NEWLINE> <NL> while ls > 0 : <NEWLINE> <INDENT> ls -= 1 <NEWLINE> if ls % 2 == 0 : <NEWLINE> <INDENT> odd_list . append ( ls ) <NEWLINE> <DEDENT> <DEDENT> odd_list = sorted ( odd_list ) <NEWLINE> <COMMENT> <NL> <NL> for i in odd_list : <NEWLINE> <INDENT> result = result + S [ i ] <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> b = Counter ( a ) . values ( ) <NEWLINE> c = [ x for x in b if x % 2 != 0 ] <NEWLINE> print ( len ( c ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> rabit = input ( ) . split ( <STRING> ) <NEWLINE> skip = [ ] <NEWLINE> num = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> n = int ( rabit [ i ] ) <NEWLINE> if n < i + 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if int ( rabit [ n - 1 ] ) == i + 1 : <NEWLINE> <INDENT> num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> x = len ( str ( n ) ) <NEWLINE> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( 1 , 26 ) : <NEWLINE> <INDENT> cnt += n // ( ( 5 ** i ) * 2 ) <NEWLINE> <NL> <NL> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> upper = ( N - 1 ) * ( N - 2 ) // 2 <NEWLINE> if upper < K : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = upper - K <NEWLINE> edges = [ ] <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> edges . append ( ( 1 , i ) ) <NEWLINE> <DEDENT> j = 2 <NEWLINE> while diff > 0 : <NEWLINE> <INDENT> k = j + 1 <NEWLINE> while k <= N and diff > 0 : <NEWLINE> <INDENT> edges . append ( ( j , k ) ) <NEWLINE> k += 1 <NEWLINE> diff -= 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> print ( len ( edges ) ) <NEWLINE> for e in edges : <NEWLINE> <INDENT> print ( * e ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> from collections import Counter <NEWLINE> MOD = 998244353 <NEWLINE> <NL> <NL> def solve ( n , d ) : <NEWLINE> <INDENT> if d [ 0 ] != 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> dc = Counter ( d ) <NEWLINE> if dc [ 0 ] > 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> res = 1 <NEWLINE> k = 1 <NEWLINE> dmax = max ( d ) <NEWLINE> while k <= dmax : <NEWLINE> <INDENT> res *= dc [ k - 1 ] ** dc [ k ] <NEWLINE> res %= MOD <NEWLINE> k += 1 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> print ( solve ( N , d ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> from collections import deque <NEWLINE> from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> M = [ input ( ) [ : - 1 ] for _ in range ( H ) ] <NEWLINE> <NL> def bfs ( start ) : <NEWLINE> <INDENT> dist = [ [ float ( <STRING> ) ] * W for _ in range ( H ) ] <NEWLINE> dist [ start [ 0 ] ] [ start [ 1 ] ] = 0 <NEWLINE> <NL> is_visited = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> q = deque ( [ start ] ) <NEWLINE> max_ = 0 <NEWLINE> <NL> while len ( q ) : <NEWLINE> <INDENT> now_h , now_w = q . popleft ( ) <NEWLINE> if M [ now_h ] [ now_w ] == <STRING> : <NEWLINE> <INDENT> return <NEWLINE> <COMMENT> <NL> <DEDENT> is_visited [ now_h ] [ now_w ] = float ( <STRING> ) <NEWLINE> for next_h , next_w in ( ( now_h + 1 , now_w ) , <NEWLINE> <INDENT> ( now_h - 1 , now_w ) , <NEWLINE> ( now_h , now_w - 1 ) , <NEWLINE> ( now_h , now_w + 1 ) ) : <NEWLINE> <NL> if not ( 0 <= next_h < H ) or not ( 0 <= next_w < W ) or ( dist [ next_h ] [ next_w ] != float ( <STRING> ) ) or M [ next_h ] [ next_w ] == <STRING> : <NEWLINE> <COMMENT> <NL> continue <NEWLINE> <NL> dist [ next_h ] [ next_w ] = dist [ now_h ] [ now_w ] + 1 <NEWLINE> max_ = max ( max_ , dist [ next_h ] [ next_w ] ) <NEWLINE> q . append ( ( next_h , next_w ) ) <NEWLINE> <DEDENT> <DEDENT> return max_ <NEWLINE> <NL> <DEDENT> max_ = 0 <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if M [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> max_ = max ( bfs ( ( h , w ) ) , max_ ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max_ ) <NEWLINE> <NL> <NL> <DEDENT> if ( __name__ == <STRING> ) : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> ans [ a - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ans [ i ] > q - k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> w = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if ( s [ i ] == <STRING> ) : <NEWLINE> <INDENT> ans += i - w <NEWLINE> w += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from functools import reduce <NEWLINE> from math import gcd <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> N = int ( readline ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> lcm = reduce ( lambda x , y : x * y // gcd ( x , y ) , A ) <NEWLINE> ans = 0 <NEWLINE> ans = sum ( lcm // x for x in A ) <NEWLINE> print ( ans % mod ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def RD ( ) : return sys . stdin . read ( ) <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MF ( ) : return map ( float , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LF ( ) : return list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> def TI ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = MI ( ) <NEWLINE> p = LI ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> p [ i ] = p [ i ] / 2 + 0.5 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ans = sum ( p [ : k ] ) <NEWLINE> now = sum ( p [ : k ] ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> now = now - p [ i ] + p [ i + k ] <NEWLINE> ans = max ( ans , now ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> <NL> def dfs ( current , node_vals , seen , to ) : <NEWLINE> <INDENT> for next in to [ current ] : <NEWLINE> <INDENT> if not seen [ next ] : <NEWLINE> <INDENT> node_vals [ next ] += node_vals [ current ] <NEWLINE> seen [ next ] = 1 <NEWLINE> dfs ( next , node_vals , seen , to ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> N , Q = map ( int , sysread ( ) . split ( ) ) <NEWLINE> to = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , sysread ( ) . split ( ) ) <NEWLINE> to [ a ] . append ( b ) <NEWLINE> to [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> node_vals = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , sysread ( ) . split ( ) ) <NEWLINE> node_vals [ p ] += x <NEWLINE> <NL> <DEDENT> seen = [ 0 ] * ( N + 1 ) <NEWLINE> seen [ 1 ] = 1 <NEWLINE> dfs ( 1 , node_vals , seen , to ) <NEWLINE> <NL> node_vals = [ str ( v ) for v in node_vals ] <NEWLINE> print ( <STRING> . join ( node_vals [ 1 : ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> x = int ( n ** 0.5 ) <NEWLINE> while n % x != 0 : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> print ( max ( len ( str ( x ) ) , len ( str ( n // x ) ) ) ) <NEWLINE>
import math <NEWLINE> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> count1 = 0 <NEWLINE> count2 = 0 <NEWLINE> ans1 = B - B // C - B // D + B // ( ( C * D ) // math . gcd ( C , D ) ) <NEWLINE> A = A - 1 <NEWLINE> ans2 = A - A // C - A // D + A // ( ( C * D ) // math . gcd ( C , D ) ) <NEWLINE> print ( ans1 - ans2 ) <NEWLINE>
alphabeta = <STRING> <NEWLINE> all_str = set ( alphabeta ) <NEWLINE> str = input ( ) <NEWLINE> str = set ( str ) <NEWLINE> <NL> <NL> use = all_str - str <NEWLINE> if use == set ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sorted ( use ) [ 0 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> rate = set ( ) <NEWLINE> free = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a < 3200 : <NEWLINE> <INDENT> rate . add ( a // 400 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> free += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( rate ) == 0 : <NEWLINE> <INDENT> color_min , color_max = 1 , n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> color_min , color_max = len ( rate ) , len ( rate ) + free <NEWLINE> <NL> <DEDENT> print ( color_min , color_max ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = sorted ( x ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] <= y [ n // 2 - 1 ] : <NEWLINE> <INDENT> print ( y [ n // 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y [ n // 2 - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> time_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = int ( input ( ) ) <NEWLINE> <NL> drink_num_time = [ ] <NEWLINE> drink_time = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> drink_num_time . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> normal_time = sum ( time_list ) <NEWLINE> <NL> <NL> for i in range ( m ) : <NEWLINE> <INDENT> drink_time . append ( normal_time + drink_num_time [ i ] [ 1 ] - time_list [ ( drink_num_time [ i ] [ 0 ] ) - 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> print ( drink_time [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ 0 ] * ( 10 ** 5 + 2 ) <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> S [ a ] = i + 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if n == N + 1 or n == N : <NEWLINE> <INDENT> print ( S [ n ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ n ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> h = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> memo = [ - 1 ] * n <NEWLINE> <NL> def dp ( i ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if i < 0 : <NEWLINE> <INDENT> return 10 ** 10 <NEWLINE> <DEDENT> if memo [ i ] != - 1 : <NEWLINE> <INDENT> return memo [ i ] <NEWLINE> <DEDENT> if i == 1 : <NEWLINE> <INDENT> memo [ i ] = abs ( h [ i ] - h [ i - 1 ] ) <NEWLINE> return memo [ i ] <NEWLINE> <DEDENT> memo [ i ] = min ( dp ( i - 1 ) + abs ( h [ i ] - h [ i - 1 ] ) , dp ( i - 2 ) + abs ( h [ i ] - h [ i - 2 ] ) ) <NEWLINE> return memo [ i ] <NEWLINE> <NL> <DEDENT> print ( dp ( n - 1 ) ) <NEWLINE>
from heapq import nlargest <NEWLINE> import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> l1 , l2 = nlargest ( 2 , a ) <NEWLINE> <NL> if l1 == l2 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( l1 ) <NEWLINE> <DEDENT> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> if i == l1 : <NEWLINE> <INDENT> print ( l2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l1 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> cnt = 0 <NEWLINE> i = 1 <NEWLINE> while ( i < n - 1 ) : <NEWLINE> <INDENT> if ( s [ i - 1 ] == <STRING> and s [ i ] == <STRING> and s [ i + 1 ] == <STRING> ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> d = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d [ i ] = 0 <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d [ a - 1 ] += 1 <NEWLINE> d [ b - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( 0 , N - 2 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> if S [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import numpy as np <NEWLINE> n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( [ k ] * n ) <NEWLINE> a -= q <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> n = 1 <NEWLINE> L = [ ] <NEWLINE> if a * b < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a + b > 0 or ( a - b ) % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> l = [ 1 ] <NEWLINE> bot = 1 <NEWLINE> flag = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> bot = a [ bot - 1 ] <NEWLINE> if bot == 2 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import math <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> N = math . factorial ( n ) <NEWLINE> if abs ( n - m ) > 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif abs ( n - m ) == 0 : <NEWLINE> <INDENT> print ( 2 * N * N % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT> elif n > m : <NEWLINE> <INDENT> print ( ( N * N // n ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N * N * m % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT>
import re <NEWLINE> print ( <STRING> if re . match ( <STRING> , input ( ) ) else <STRING> ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> A = Counter ( a ) <NEWLINE> s = set ( a ) <NEWLINE> S = sorted ( list ( s ) ) <NEWLINE> S . reverse ( ) <NEWLINE> h = 0 <NEWLINE> w = 0 <NEWLINE> for i in S : <NEWLINE> <INDENT> res = A [ i ] <NEWLINE> if res >= 4 : <NEWLINE> <INDENT> if h == 0 : <NEWLINE> <INDENT> h = i <NEWLINE> <DEDENT> if w == 0 : <NEWLINE> <INDENT> w = i <NEWLINE> <DEDENT> <DEDENT> elif 2 <= res < 4 : <NEWLINE> <INDENT> if w == 0 : <NEWLINE> <INDENT> w = i <NEWLINE> <DEDENT> elif w != 0 and h == 0 : <NEWLINE> <INDENT> h = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( h * w ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ - 1 ] * N <COMMENT> <NEWLINE> dp [ N - 1 ] = 0 <NEWLINE> <NL> def rec_memo ( i ) : <NEWLINE> <INDENT> if dp [ i ] >= 0 : <NEWLINE> <INDENT> return dp [ i ] <NEWLINE> <NL> <DEDENT> if i == N - 2 : <NEWLINE> <INDENT> dp [ i ] = rec_memo ( i + 1 ) + abs ( h [ i + 1 ] - h [ i ] ) <NEWLINE> return dp [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = min ( rec_memo ( i + 1 ) + abs ( h [ i + 1 ] - h [ i ] ) , rec_memo ( i + 2 ) + abs ( h [ i + 2 ] - h [ i ] ) ) <NEWLINE> return dp [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( rec_memo ( 0 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = n <NEWLINE> q = 2 * ( 10 ** 5 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> q = min ( p [ i ] , q ) <NEWLINE> if not p [ i ] <= q : <NEWLINE> <INDENT> m -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
import heapq <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> n_list = map ( int , input ( ) . split ( ) ) <NEWLINE> n_dic = { } <NEWLINE> for n in n_list : <NEWLINE> <INDENT> n_dic . setdefault ( n , 0 ) <NEWLINE> n_dic [ n ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> n_dic . setdefault ( c , 0 ) <NEWLINE> n_dic [ c ] += b <NEWLINE> <NL> <DEDENT> com_list = [ ] <NEWLINE> <NL> for score , num in n_dic . items ( ) : <NEWLINE> <INDENT> heapq . heappush ( com_list , ( - score , num ) ) <NEWLINE> <NL> <DEDENT> taken = 0 <NEWLINE> result = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> score , num = heapq . heappop ( com_list ) <NEWLINE> score = - score <NEWLINE> if N - taken > num : <NEWLINE> <INDENT> result += score * num <NEWLINE> taken += num <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += score * ( N - taken ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import math <COMMENT> <NEWLINE> import heapq <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> price = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> price = [ - i for i in price ] <NEWLINE> <NL> heapq . heapify ( price ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> sm = heapq . heappop ( price ) <NEWLINE> sm = - ( - sm // 2 ) <NEWLINE> heapq . heappush ( price , sm ) <NEWLINE> <NL> <DEDENT> price = [ - i for i in price ] <NEWLINE> <NL> print ( sum ( price ) ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( min ( k , len ( s ) ) ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> ans = int ( s [ i ] ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> step_n , max_jump = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> step_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp_table = [ math . inf ] * ( step_n ) <NEWLINE> dp_table [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , step_n ) : <NEWLINE> <INDENT> min_from = max ( 0 , i - max_jump ) <NEWLINE> dp_table [ i ] = min ( dp_table [ j ] + abs ( step_list [ i ] - step_list [ j ] ) for j in range ( min_from , i ) ) <NEWLINE> <NL> <DEDENT> print ( dp_table [ step_n - 1 ] ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> <NL> P = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> cnt = 1 <NEWLINE> min_num = P [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if P [ i ] <= min_num : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> min_num = P [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from pprint import pprint <NEWLINE> import numpy as np <NEWLINE> import numba as nb <NEWLINE> @ nb . njit <NEWLINE> def Knapsack1 ( n , w , wl , vl ) : <NEWLINE> <INDENT> dp = np . zeros ( shape = ( n + 1 , w + 1 ) , dtype = np . int64 ) <NEWLINE> for wsum in range ( 1 , w + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if wsum >= wl [ i ] : <NEWLINE> <INDENT> if dp [ i ] [ wsum ] < dp [ i ] [ wsum - wl [ i ] ] + vl [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ i + 1 ] [ wsum ] = dp [ i ] [ wsum - wl [ i ] ] + vl [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] [ wsum ] = dp [ i ] [ wsum ] <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] [ wsum ] = dp [ i ] [ wsum ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] [ - 1 ] ) <NEWLINE> <NL> <DEDENT> n , w = map ( int , input ( ) . split ( ) ) <NEWLINE> wv = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> wv . sort ( key = lambda x : ( x [ 1 ] , x [ 0 ] ) ) <NEWLINE> wv = np . array ( wv ) <NEWLINE> wv = wv . T <NEWLINE> wl = wv [ 0 ] <NEWLINE> vl = wv [ 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> Knapsack1 ( n , w , wl , vl ) <NEWLINE>
S = input ( ) <NEWLINE> if S [ 0 ] == S [ 1 ] == S [ 2 ] or S [ 1 ] == S [ 2 ] == S [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <COMMENT> <NL> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( abs ( x [ 0 ] - X ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> x . sort ( ) <NEWLINE> <COMMENT> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if x [ i ] < X and x [ i + 1 ] > X : <NEWLINE> <INDENT> x = x [ : i + 1 ] + [ X ] + x [ i + 1 : ] <NEWLINE> break <NEWLINE> <DEDENT> elif x [ i ] >= X : <NEWLINE> <INDENT> x = [ X ] + x <NEWLINE> break <NEWLINE> <DEDENT> elif x [ i + 1 ] <= X : <NEWLINE> <INDENT> x = x + [ X ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( x ) >= 3 : <NEWLINE> <INDENT> base = math . gcd ( x [ 1 ] - x [ 0 ] , x [ 2 ] - x [ 1 ] ) <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> diff = x [ i + 1 ] - x [ i ] <NEWLINE> base = math . gcd ( base , diff ) <NEWLINE> <DEDENT> print ( base ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x [ 1 ] - x [ 0 ] ) <NEWLINE> <DEDENT>
<NL> def solve ( ) : <NEWLINE> <INDENT> t = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] <NEWLINE> <DEDENT> <DEDENT> for j in range ( Q ) : <NEWLINE> <INDENT> print ( t [ lr [ j ] [ 1 ] - 1 ] - t [ lr [ j ] [ 0 ] - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = input ( ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> solve ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> x = ( n * ( n - 1 ) ) // 2 <NEWLINE> print ( x ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> <NL> <DEDENT> A2 = sorted ( A ) <NEWLINE> mx1 = A2 [ - 1 ] <NEWLINE> mx2 = A2 [ - 2 ] <NEWLINE> ind = A . index ( mx1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i != ind : <NEWLINE> <INDENT> print ( mx1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mx2 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> l . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> m = max ( l ) <NEWLINE> mc = l . count ( m ) <NEWLINE> tin = set ( l ) <NEWLINE> if len ( tin ) == 1 : <NEWLINE> <INDENT> s = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = sorted ( tin ) [ - 2 ] <NEWLINE> <DEDENT> for i in l : <NEWLINE> <INDENT> if i == m : <NEWLINE> <INDENT> if mc > 1 : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) [ : : - 1 ] <NEWLINE> dp = [ [ 0 , 0 ] for i in range ( len ( n ) + 1 ) ] <NEWLINE> dp [ 0 ] [ 1 ] = 1 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> dp [ i + 1 ] [ 0 ] = min ( dp [ i ] [ 0 ] + int ( n [ i ] ) , dp [ i ] [ 1 ] - int ( n [ i ] ) + 10 ) <NEWLINE> dp [ i + 1 ] [ 1 ] = min ( dp [ i ] [ 0 ] + int ( n [ i ] ) + 1 , dp [ i ] [ 1 ] - int ( n [ i ] ) + 9 ) <NEWLINE> <DEDENT> print ( dp [ len ( n ) ] [ 0 ] ) <NEWLINE>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= 2 * C : <NEWLINE> <INDENT> if B >= 2 * C : <NEWLINE> <INDENT> print ( 2 * C * max ( X , Y ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * C * X + B * max ( 0 , ( Y - X ) ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> elif B >= 2 * C : <NEWLINE> <INDENT> print ( 2 * C * Y + A * max ( 0 , ( X - Y ) ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A * X + B * Y <NEWLINE> for i in range ( 1 , min ( X , Y ) + 1 ) : <NEWLINE> <INDENT> p = A * ( X - i ) + B * ( Y - i ) + 2 * C * i <NEWLINE> ans = min ( ans , p ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import heapq <NEWLINE> a = list ( map ( lambda x : x * ( - 1 ) , a ) ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> b = heapq . heappop ( a ) <NEWLINE> heapq . heappush ( a , - ( - b // 2 ) ) <NEWLINE> <NL> <DEDENT> print ( sum ( a ) * ( - 1 ) ) <NEWLINE>
import sys <NEWLINE> <NL> def II ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def TI ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def RN ( N ) : return [ input ( ) . strip ( ) for i in range ( N ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = II ( ) <NEWLINE> P = LI ( ) <NEWLINE> ans = 0 <NEWLINE> min = N + 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if P [ i ] < min : <NEWLINE> <INDENT> ans += 1 <NEWLINE> min = P [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> <NL> while M : <NEWLINE> <INDENT> A [ - 1 ] //= 2 <NEWLINE> M -= 1 <NEWLINE> i = - 2 <NEWLINE> while M and ( - N <= i and A [ i ] >= A [ - 1 ] ) : <NEWLINE> <INDENT> A [ i ] //= 2 <NEWLINE> M -= 1 <NEWLINE> i -= 1 <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> <NL> <DEDENT> print ( sum ( A ) ) <NEWLINE>
import numpy as np <NEWLINE> N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( Q ) ] <NEWLINE> <NL> if K - Q <= 0 : <NEWLINE> <INDENT> L = [ K - Q for i in range ( N ) ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> L [ A [ i ] - 1 ] = L [ A [ i ] - 1 ] + 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if L [ i ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> print ( S . count ( <STRING> ) ) <NEWLINE>
import time <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> stime = time . time ( ) <NEWLINE> F = [ 0 ] * ( n + 1 ) <NEWLINE> F [ 0 ] = 1 <NEWLINE> F [ 1 ] = 2 <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD <NEWLINE> <NL> <DEDENT> etime = time . time ( ) <NEWLINE> <NL> <NL> a = [ 0 ] * ( n + 1 ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> <NL> <DEDENT> io = - 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if 0 != a [ i ] : <NEWLINE> <INDENT> io = i + 1 <NEWLINE> if 0 != a [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a [ i + 1 ] and i - io > 1 : <NEWLINE> <INDENT> ans *= F [ i - io - 1 ] % MOD <NEWLINE> s = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i = n - 1 <NEWLINE> if i - io > 0 : <NEWLINE> <INDENT> ans *= F [ i - io - 1 ] % MOD <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( int ( input ( ) ) for _ in range ( n ) ) <NEWLINE> aa = sorted ( a . copy ( ) ) <NEWLINE> mx , sd = aa [ n - 1 ] , aa [ n - 2 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> print ( mx if i < mx else sd ) <NEWLINE> <DEDENT>
import statistics <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_i = [ A [ i ] - i - 1 for i in range ( N ) ] <NEWLINE> b = statistics . median_high ( A_i ) <NEWLINE> print ( sum ( abs ( a - b ) for a in A_i ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> import math <NEWLINE> import copy <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = np . array ( list ( range ( 1 , N + 1 ) ) ) <NEWLINE> B = np . array ( sorted ( A - r ) ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> for i in range ( max ( N // 2 - 1 , 0 ) , min ( N // 2 + 2 , N ) ) : <NEWLINE> <INDENT> c = list ( map ( abs , ( B - B [ i ] ) ) ) <NEWLINE> ans = min ( ans , sum ( c ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> x = len ( S ) <NEWLINE> if <STRING> in S : <NEWLINE> <INDENT> y0 = S . count ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y0 = 0 <NEWLINE> <DEDENT> if <STRING> in S : <NEWLINE> <INDENT> y1 = S . count ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y1 = 0 <NEWLINE> <NL> <DEDENT> d = abs ( y0 - y1 ) <NEWLINE> print ( x - d ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> main = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> total = sum ( main ) <NEWLINE> beg = 0 <NEWLINE> final = float ( <STRING> ) <NEWLINE> for i in range ( len ( main ) - 1 ) : <NEWLINE> <INDENT> beg += main [ i ] <NEWLINE> total -= main [ i ] <NEWLINE> final = min ( final , abs ( beg - total ) ) <NEWLINE> <NL> <DEDENT> print ( final ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ] <NEWLINE> M = [ ] <NEWLINE> <NL> for n in range ( A , min ( A + K , B + 1 ) ) : <NEWLINE> <INDENT> L . append ( n ) <NEWLINE> <NL> <DEDENT> for n in range ( max ( A , B - K ) , B + 1 ) : <NEWLINE> <INDENT> M . append ( n ) <NEWLINE> <NL> <DEDENT> L = sorted ( set ( L [ : K ] + M [ - K : ] ) ) <NEWLINE> <NL> print ( * L , sep = <STRING> ) <NEWLINE>
a = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> print ( a [ input ( ) ] ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> lis = { } <NEWLINE> counter = 0 <NEWLINE> N = int ( input ( ) . rstrip ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> str = <STRING> . join ( sorted ( list ( input ( ) . rstrip ( ) ) ) ) <NEWLINE> if str in lis : <NEWLINE> <INDENT> lis [ str ] += 1 <NEWLINE> counter += lis [ str ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis [ str ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> def bfs ( start ) : <NEWLINE> <INDENT> q = deque ( [ [ start ] ] ) <NEWLINE> visited = set ( ) <NEWLINE> while q : <NEWLINE> <INDENT> path = q . popleft ( ) <NEWLINE> i , j = path [ - 1 ] <NEWLINE> if ( i , j ) == ( H - 1 , W - 1 ) : <NEWLINE> <INDENT> return path <NEWLINE> <DEDENT> for di , dj in [ ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ] : <NEWLINE> <INDENT> ni , nj = i + di , j + dj <NEWLINE> if ( <NEWLINE> <INDENT> 0 <= ni < H <NEWLINE> and 0 <= nj < W <NEWLINE> and field [ ni ] [ nj ] != <STRING> <NEWLINE> and ( ni , nj ) not in visited <NEWLINE> <DEDENT> ) : <NEWLINE> <INDENT> q . append ( path + [ ( ni , nj ) ] ) <NEWLINE> visited . add ( ( ni , nj ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> field = [ input ( ) for _ in range ( H ) ] <NEWLINE> shortest_path = bfs ( ( 0 , 0 ) ) <NEWLINE> if shortest_path is None : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if field [ i ] [ j ] == <STRING> and ( i , j ) not in shortest_path : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> chars = sorted ( set ( S ) ) <NEWLINE> checked = set ( ) <NEWLINE> <NL> <NL> def dfs ( s ) : <NEWLINE> <INDENT> for c in chars : <NEWLINE> <INDENT> if len ( checked ) >= K : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> next_s = s + c <NEWLINE> if next_s not in checked and next_s in S : <NEWLINE> <INDENT> checked . add ( next_s ) <NEWLINE> if len ( checked ) == K : <NEWLINE> <INDENT> print ( next_s ) <NEWLINE> return <NEWLINE> <DEDENT> elif len ( next_s ) <= len ( S ) : <NEWLINE> <INDENT> dfs ( next_s ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dfs ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> i = str ( i ) . zfill ( 3 ) <NEWLINE> f = True <NEWLINE> x = - 1 <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> x = s . find ( i [ j ] , x + 1 ) <NEWLINE> f = f and bool ( x >= 0 ) <NEWLINE> <DEDENT> ans += f <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> ones = S . count ( <STRING> ) <NEWLINE> zeros = S . count ( <STRING> ) <NEWLINE> print ( min ( ones , zeros ) * 2 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> class Counter ( dict ) : <NEWLINE> <INDENT> def __missing__ ( self , i ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> class BoolDict ( dict ) : <NEWLINE> <INDENT> def __missing__ ( self , i ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> passed = 0 <NEWLINE> penalties = Counter ( ) <NEWLINE> <NL> ac = BoolDict ( ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> if not ac [ p ] : <NEWLINE> <INDENT> if s == <STRING> : penalties [ p ] += 1 <NEWLINE> elif s == <STRING> : <NEWLINE> <INDENT> passed += 1 <NEWLINE> ac [ p ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> x = 0 <NEWLINE> for i in penalties : <NEWLINE> <INDENT> if ac [ i ] : <NEWLINE> <INDENT> x += penalties [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( passed , x ) <NEWLINE>
s = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> str_list = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> str_list . append ( s [ i : i + j + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> str_list = sorted ( list ( set ( str_list ) ) ) <NEWLINE> <COMMENT> <NL> ans = str_list [ K - 1 ] <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> check = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> check [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> [ print ( x , end = <STRING> ) for x in check ] <NEWLINE>
def myfunc ( N ) : <NEWLINE> <INDENT> if ( N <= 1 ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return 2 * myfunc ( int ( N / 2 ) ) + 1 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> print ( myfunc ( N ) ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> x3 = ( 10 ** 9 - s % 10 ** 9 ) % 10 ** 9 <NEWLINE> y3 = ( s + x3 ) // 10 ** 9 <NEWLINE> print ( 0 , 0 , 10 ** 9 , 1 , x3 , y3 ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> T = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> T . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> ans = T [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans = ans * T [ i ] // math . gcd ( ans , T [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
o = input ( ) <NEWLINE> e = input ( ) <NEWLINE> O = len ( o ) <NEWLINE> E = len ( e ) <NEWLINE> a = [ ] <NEWLINE> if O == E : <NEWLINE> <INDENT> for i in range ( O ) : <NEWLINE> <INDENT> a . append ( o [ i ] + e [ i ] ) <NEWLINE> <DEDENT> b = <STRING> . join ( a ) <NEWLINE> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( E ) : <NEWLINE> <INDENT> a . append ( o [ i ] + e [ i ] ) <NEWLINE> <DEDENT> a . append ( o [ O - 1 ] ) <NEWLINE> b = <STRING> . join ( a ) <NEWLINE> print ( b ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def calc ( x ) : <NEWLINE> <INDENT> if x < D + 1 : <NEWLINE> <INDENT> mv [ x ] = 0 <NEWLINE> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = d [ x ] [ 0 ] <NEWLINE> q = d [ x ] [ 1 ] <NEWLINE> r = d [ x - D ] [ 0 ] <NEWLINE> s = d [ x - D ] [ 1 ] <NEWLINE> tmp = abs ( p - r ) + abs ( q - s ) <NEWLINE> ret = tmp + calc ( x - D ) <NEWLINE> mv [ x ] = ret <NEWLINE> return ret <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> H , W , D = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( H ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> d = dict ( ) <NEWLINE> z = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> for b in a : <NEWLINE> <INDENT> p = z // W <NEWLINE> q = z % W <NEWLINE> d [ b ] = ( p , q ) <NEWLINE> z += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> mv = [ 0 ] * ( H * W + 1 ) <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> calc ( H * W - i ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> L = [ 0 ] * Q <NEWLINE> R = [ 0 ] * Q <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( mv [ R ] - mv [ L ] ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mid = 0 <NEWLINE> diff = float ( <STRING> ) <NEWLINE> total = sum ( A ) <NEWLINE> p = 0 <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if abs ( total - p ) < diff : <NEWLINE> <INDENT> diff = abs ( total - p ) <NEWLINE> mid = i <NEWLINE> <DEDENT> p += A [ i ] <NEWLINE> total -= A [ i ] <NEWLINE> <DEDENT> front = A [ : mid ] <NEWLINE> back = A [ mid : ] <NEWLINE> print ( abs ( sum ( front ) - sum ( back ) ) ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> u , v , w = [ 0 ] * ( N - 1 ) , [ 0 ] * ( N - 1 ) , [ 0 ] * ( N - 1 ) <NEWLINE> n = [ - 1 ] * N <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> n [ i ] = [ 0 ] * 4 <NEWLINE> n [ i ] [ 1 ] = [ ] <NEWLINE> n [ i ] [ 2 ] = [ ] <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u [ i ] , v [ i ] , w [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n [ u [ i ] - 1 ] [ 1 ] . append ( v [ i ] - 1 ) <NEWLINE> n [ v [ i ] - 1 ] [ 1 ] . append ( u [ i ] - 1 ) <NEWLINE> n [ u [ i ] - 1 ] [ 2 ] . append ( w [ i ] % 2 ) <NEWLINE> n [ v [ i ] - 1 ] [ 2 ] . append ( w [ i ] % 2 ) <NEWLINE> <NL> <DEDENT> stack = [ u [ 0 ] - 1 ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> num = stack . pop ( ) <NEWLINE> n [ num ] [ 3 ] = 1 <NEWLINE> for i in range ( len ( n [ num ] [ 1 ] ) ) : <NEWLINE> <INDENT> if n [ n [ num ] [ 1 ] [ i ] ] [ 3 ] == 0 : <NEWLINE> <INDENT> stack . append ( n [ num ] [ 1 ] [ i ] ) <NEWLINE> if n [ num ] [ 2 ] [ i ] == 0 : <NEWLINE> <INDENT> n [ n [ num ] [ 1 ] [ i ] ] [ 0 ] = n [ num ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n [ n [ num ] [ 1 ] [ i ] ] [ 0 ] = - 1 * n [ num ] [ 0 ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( stack ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in n : <NEWLINE> <INDENT> print ( i [ 0 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> lank = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if 1 <= a [ i ] <= 399 : <NEWLINE> <INDENT> lank [ 0 ] = 1 <NEWLINE> <DEDENT> elif 400 <= a [ i ] <= 799 : <NEWLINE> <INDENT> lank [ 1 ] = 1 <NEWLINE> <DEDENT> elif 800 <= a [ i ] <= 1199 : <NEWLINE> <INDENT> lank [ 2 ] = 1 <NEWLINE> <DEDENT> elif 1200 <= a [ i ] <= 1599 : <NEWLINE> <INDENT> lank [ 3 ] = 1 <NEWLINE> <DEDENT> elif 1600 <= a [ i ] <= 1999 : <NEWLINE> <INDENT> lank [ 4 ] = 1 <NEWLINE> <DEDENT> elif 2000 <= a [ i ] <= 2399 : <NEWLINE> <INDENT> lank [ 5 ] = 1 <NEWLINE> <DEDENT> elif 2400 <= a [ i ] <= 2799 : <NEWLINE> <INDENT> lank [ 6 ] = 1 <NEWLINE> <DEDENT> elif 2800 <= a [ i ] <= 3199 : <NEWLINE> <INDENT> lank [ 7 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> number_min = max ( 1 , lank . count ( 1 ) ) <NEWLINE> number_max = lank . count ( 1 ) + cnt <NEWLINE> <NL> print ( number_min , number_max ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ <STRING> ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x = a [ i ] <NEWLINE> b = ans [ a [ i ] - 1 ] <NEWLINE> c = str ( i + 1 ) <NEWLINE> ans [ a [ i ] - 1 ] = str ( i + 1 ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> acgt = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i in acgt : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> ans = max ( cnt , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> store_list = [ ] <NEWLINE> dictA = { } <NEWLINE> ans_list = [ 1 ] * n <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> s_list = list ( s ) <NEWLINE> s_list . sort ( ) <NEWLINE> a = tuple ( s_list ) <NEWLINE> dictA . setdefault ( a , 0 ) <NEWLINE> dictA [ a ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> total = 0 <NEWLINE> for value in dictA . values ( ) : <NEWLINE> <INDENT> total += value * ( value - 1 ) / 2 <NEWLINE> <NL> <DEDENT> print ( int ( total ) ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> <NL> if A > B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif B > A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> a = b = - 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> a , b = i + 1 , i + 2 <NEWLINE> break <NEWLINE> <DEDENT> elif i + 2 < n and s [ i ] == s [ i + 2 ] : <NEWLINE> <INDENT> a , b = i + 1 , i + 3 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans %= ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = np . array ( [ list ( input ( ) ) for _ in range ( H ) ] ) == <STRING> <COMMENT> <NEWLINE> <NL> up = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> down = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> left = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> right = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> <NL> for i in range ( H - 1 ) : <NEWLINE> <INDENT> up [ i + 1 , : ] = ( up [ i , : ] + 1 ) * S [ i , : ] <COMMENT> <NEWLINE> <DEDENT> for i in range ( H - 1 ) : <COMMENT> <NEWLINE> <INDENT> down [ H - 2 - i , : ] = ( down [ H - 1 - i , : ] + 1 ) * S [ H - 1 - i , : ] <NEWLINE> <DEDENT> for i in range ( W - 1 ) : <NEWLINE> <INDENT> left [ : , i + 1 ] = ( left [ : , i ] + 1 ) * S [ : , i ] <NEWLINE> <DEDENT> for i in range ( W - 1 ) : <NEWLINE> <INDENT> right [ : , W - 2 - i ] = ( right [ : , W - 1 - i ] + 1 ) * S [ : , W - 1 - i ] <NEWLINE> <NL> <DEDENT> print ( ( ( up + down + left + right ) * S ) . max ( ) + 1 ) <COMMENT> <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> B . append ( K - Q ) <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> B [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> if B [ j ] >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> actividad = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> puntos = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> actividad . append ( puntos ) <NEWLINE> <NL> <DEDENT> primer_puntos = [ 0 ] * 3 <NEWLINE> <NL> for i in range ( len ( primer_puntos ) ) : <NEWLINE> <INDENT> primer_puntos [ i ] = actividad [ 0 ] [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> siguiente = [ 0 ] * 3 <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 3 ) : <NEWLINE> <INDENT> if j != k : <NEWLINE> <INDENT> siguiente [ j ] = max ( siguiente [ j ] , primer_puntos [ k ] + actividad [ i ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> primer_puntos = siguiente <NEWLINE> <NL> <DEDENT> print ( max ( primer_puntos ) ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( 0 , n ) : <NEWLINE> <INDENT> if ab [ _ ] [ 2 ] != 0 : <NEWLINE> <INDENT> x = ab [ _ ] [ 0 ] <NEWLINE> y = ab [ _ ] [ 1 ] <NEWLINE> h = ab [ _ ] [ 2 ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> f = True <NEWLINE> l = abs ( i - x ) + abs ( j - y ) + h <NEWLINE> for k in range ( 0 , n ) : <NEWLINE> <INDENT> dx = ab [ k ] [ 0 ] <NEWLINE> dy = ab [ k ] [ 1 ] <NEWLINE> dh = ab [ k ] [ 2 ] <NEWLINE> if max ( l - abs ( i - dx ) - abs ( j - dy ) , 0 ) == dh : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = False <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> ansx = i <NEWLINE> ansy = j <NEWLINE> ansr = l <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( str ( ansx ) + <STRING> + str ( ansy ) + <STRING> + str ( ansr ) ) <NEWLINE>
nk = input ( ) . split ( ) <NEWLINE> index = int ( nk [ 1 ] ) - 1 <NEWLINE> s = input ( ) <NEWLINE> c = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if c == index : print ( i . lower ( ) , end = <STRING> ) <NEWLINE> else : print ( i , end = <STRING> ) <NEWLINE> c += 1 <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> lan = [ <STRING> . join ( sorted ( input ( ) ) ) for n in range ( N ) ] <NEWLINE> <COMMENT> <NL> lans = collections . Counter ( lan ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> for si in set ( lan ) : <NEWLINE> <INDENT> n = lans [ si ] <NEWLINE> ans += n * ( n - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> from copy import deepcopy <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> t = ( ( 0 , 1 ) , ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ) <NEWLINE> m = 0 <NEWLINE> for sy in range ( h ) : <NEWLINE> <INDENT> for sx in range ( w ) : <NEWLINE> <INDENT> if s [ sy ] [ sx ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ss = deepcopy ( s ) <NEWLINE> ss [ sy ] [ sx ] = <STRING> <NEWLINE> q = deque ( [ ( 0 , sy , sx ) ] ) <NEWLINE> max_cost = 0 <NEWLINE> my , mx = 0 , 0 <NEWLINE> while ( q ) : <NEWLINE> <INDENT> cost , y , x = q . popleft ( ) <NEWLINE> max_cost = max ( max_cost , cost ) <NEWLINE> cost += 1 <NEWLINE> for i , j in t : <NEWLINE> <INDENT> ny = y + i <NEWLINE> nx = x + j <NEWLINE> if 0 <= ny < h and 0 <= nx < w : <NEWLINE> <INDENT> if ss [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> q . append ( ( cost , ny , nx ) ) <NEWLINE> ss [ ny ] [ nx ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> m = max ( m , max_cost ) <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> stones = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> inf = 10 ** 9 <NEWLINE> dp = [ inf ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for t in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> step = i + t <NEWLINE> if step < n : <NEWLINE> <INDENT> v = dp [ i ] + abs ( stones [ i ] - stones [ step ] ) <NEWLINE> if v < dp [ step ] : <NEWLINE> <INDENT> dp [ step ] = v <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> n_a = a // x <NEWLINE> n_b = b // x <NEWLINE> if a % x == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> ans += n_b - n_a <NEWLINE> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> h = sum ( [ i for i in range ( 1 , b - a + 1 ) ] ) <NEWLINE> print ( h - b ) <NEWLINE>
<NL> import heapq as he <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( lambda x : x * ( - 1 ) , a ) ) <NEWLINE> he . heapify ( a ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> he . heappush ( a , he . heappop ( a ) * ( - 1 ) // 2 * ( - 1 ) ) <NEWLINE> <NL> <DEDENT> print ( sum ( a ) * ( - 1 ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] , dp [ 1 ] = 1 , 1 <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> dp [ a ] = - 1 <NEWLINE> <NL> <DEDENT> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> if dp [ i + 2 ] == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if dp [ i ] == - 1 and dp [ i + 1 ] == - 1 : <NEWLINE> <INDENT> dp [ i + 2 ] = - 1 <NEWLINE> <DEDENT> elif dp [ i ] == - 1 : <NEWLINE> <INDENT> dp [ i + 2 ] = dp [ i + 1 ] <NEWLINE> <DEDENT> elif dp [ i + 1 ] == - 1 : <NEWLINE> <INDENT> dp [ i + 2 ] = dp [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 2 ] = dp [ i ] + dp [ i + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ n ] % ( 10 ** 9 + 7 ) if dp [ n ] != - 1 else 0 ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> N , M , Q = MAP ( ) <NEWLINE> LR = [ LIST ( ) for _ in range ( M ) ] <NEWLINE> pq = [ LIST ( ) for _ in range ( Q ) ] <NEWLINE> <NL> x = [ [ 0 ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> <NL> for L , R in LR : <NEWLINE> <INDENT> x [ L ] [ R ] += 1 <NEWLINE> <NL> <DEDENT> for l in range ( N + 1 ) : <NEWLINE> <INDENT> x [ l ] = list ( accumulate ( x [ l ] ) ) <NEWLINE> <NL> <DEDENT> for l in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for r in range ( N + 1 ) : <NEWLINE> <INDENT> x [ l ] [ r ] += x [ l - 1 ] [ r ] <NEWLINE> <NL> <DEDENT> <DEDENT> for p , q in pq : <NEWLINE> <INDENT> print ( x [ q ] [ q ] - x [ q ] [ p - 1 ] - x [ p - 1 ] [ q ] + x [ p - 1 ] [ p - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT>
import sys <NEWLINE> <NL> N = int ( sys . stdin . readline ( ) ) <NEWLINE> P = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i , p_i in enumerate ( P ) : <NEWLINE> <INDENT> if p_i == i + 1 : <NEWLINE> <INDENT> if i + 1 == N : <NEWLINE> <INDENT> P [ i ] , P [ i - 1 ] = P [ i - 1 ] , P [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P [ i + 1 ] , P [ i ] = P [ i ] , P [ i + 1 ] <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> class Combi ( ) : <NEWLINE> <INDENT> def __init__ ( self , N , mod ) : <NEWLINE> <INDENT> self . power = [ 1 for _ in range ( N + 1 ) ] <NEWLINE> self . rev = [ 1 for _ in range ( N + 1 ) ] <NEWLINE> self . mod = mod <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> self . power [ i ] = ( self . power [ i - 1 ] * i ) % self . mod <NEWLINE> <DEDENT> self . rev [ N ] = pow ( self . power [ N ] , self . mod - 2 , self . mod ) <NEWLINE> for j in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> self . rev [ j - 1 ] = ( self . rev [ j ] * j ) % self . mod <NEWLINE> <NL> <DEDENT> <DEDENT> def com ( self , K , R ) : <NEWLINE> <INDENT> if K < R : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( ( self . power [ K ] ) * ( self . rev [ K - R ] ) * ( self . rev [ R ] ) ) % self . mod <NEWLINE> <NL> <DEDENT> <DEDENT> def pom ( self , K , R ) : <NEWLINE> <INDENT> if K < R : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( self . power [ K ] ) * ( self . rev [ K - R ] ) % self . mod <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> mod = 10 ** 9 + 7 <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> c = Combi ( N , mod ) <NEWLINE> <NL> ans = 0 <NEWLINE> if K == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> ans += c . com ( i , K - 1 ) * a <NEWLINE> ans -= c . com ( N - 1 - i , K - 1 ) * a <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> s = input ( ) <NEWLINE> <NL> flg = False <NEWLINE> lst = [ ] <NEWLINE> <NL> for i in range ( len ( s ) - 2 ) : <NEWLINE> <INDENT> if ( s [ i ] == s [ i + 1 ] ) : <NEWLINE> <INDENT> flg = True <NEWLINE> lst . append ( i + 1 ) <NEWLINE> lst . append ( i + 2 ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( s [ i ] == s [ i + 2 ] ) : <NEWLINE> <INDENT> flg = True <NEWLINE> lst . append ( i + 1 ) <NEWLINE> lst . append ( i + 3 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if not ( lst ) : <NEWLINE> <INDENT> if ( s [ len ( s ) - 1 ] == s [ len ( s ) - 2 ] ) : <NEWLINE> <INDENT> lst . append ( len ( s ) - 1 ) <NEWLINE> lst . append ( len ( s ) ) <NEWLINE> flg = True <NEWLINE> <NL> <DEDENT> <DEDENT> if ( flg ) : <NEWLINE> <INDENT> print ( * lst ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 , - 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> A = np . array ( A , dtype = np . int64 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> mask = 1 <NEWLINE> <NL> for i in range ( 60 ) : <NEWLINE> <INDENT> ones = np . count_nonzero ( A & mask ) <NEWLINE> ans += ( ones * ( N - ones ) % MOD ) * ( mask % MOD ) <NEWLINE> ans %= MOD <NEWLINE> mask <<= 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def i ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 10 ** 9 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N = i ( ) <NEWLINE> S = [ l ( ) for _ in range ( N ) ] <NEWLINE> ans = 0 <NEWLINE> pq = [ ] <NEWLINE> for i in S : <NEWLINE> <INDENT> for j in S : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> pq . append ( ( i [ 0 ] - j [ 0 ] , i [ 1 ] - j [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> for p , q in set ( pq ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in S : <NEWLINE> <INDENT> for j in S : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( i [ 0 ] - j [ 0 ] , i [ 1 ] - j [ 1 ] ) == ( p , q ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <DEDENT> print ( N - ans ) <NEWLINE>
import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> <NL> A = [ 1 ] <NEWLINE> for b in range ( 2 , 32 ) : <NEWLINE> <INDENT> for p in range ( 2 , 10 ) : <NEWLINE> <INDENT> if b ** p > X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif b ** p not in A : <NEWLINE> <INDENT> A . append ( b ** p ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( A ) ) <NEWLINE> <NL>
import numpy <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = numpy . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] % 2 == 0 : <NEWLINE> <INDENT> x = a [ i ] <NEWLINE> while True : <NEWLINE> <INDENT> if x % 2 != 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x / 2 <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = input ( ) <NEWLINE> M = input ( ) <NEWLINE> N = list ( str ( N ) ) <NEWLINE> M = list ( str ( M ) ) <NEWLINE> ans = [ ] <NEWLINE> if len ( N ) > len ( M ) : <NEWLINE> <INDENT> for i in range ( len ( N ) - 1 ) : <NEWLINE> <INDENT> ans . append ( N [ i ] ) <NEWLINE> ans . append ( M [ i ] ) <NEWLINE> <DEDENT> ans . append ( N [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> ans . append ( N [ i ] ) <NEWLINE> ans . append ( M [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> zero_pad = <STRING> * ( W + 2 ) <NEWLINE> s = [ ] <NEWLINE> s . append ( zero_pad ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> s . append ( <STRING> + input ( ) + <STRING> ) <NEWLINE> <DEDENT> s . append ( zero_pad ) <NEWLINE> <NL> for h in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for w in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if s [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> if s [ h - 1 ] [ w ] == <STRING> and s [ h + 1 ] [ w ] == <STRING> and s [ h ] [ w - 1 ] == <STRING> and s [ h ] [ w + 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = [ input ( ) for i in range ( n ) ] <NEWLINE> c = collections . Counter ( l ) <NEWLINE> ans = 0 <NEWLINE> <NL> for x , y in c . items ( ) : <NEWLINE> <INDENT> if y % 2 != 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N , start = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> _x = [ int ( y ) for y in input ( ) . split ( ) ] <NEWLINE> x = [ 0 for y in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x [ i ] = abs ( _x [ i ] - start ) <NEWLINE> <DEDENT> g = x [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> g = math . gcd ( g , x [ i ] ) <NEWLINE> <DEDENT> print ( g ) <NEWLINE> ans = 1 <NEWLINE>
n , m , q_ = map ( int , input ( ) . split ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> pq = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q_ ) ] <NEWLINE> from collections import defaultdict <NEWLINE> dmap = defaultdict ( int ) <NEWLINE> smap = defaultdict ( int ) <NEWLINE> ssmap = defaultdict ( int ) <NEWLINE> for l , r in lr : <NEWLINE> <INDENT> if ( l , r ) in dmap : <NEWLINE> <INDENT> dmap [ ( l , r ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dmap [ ( l , r ) ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for j in range ( i , n + 1 ) : <NEWLINE> <INDENT> if ( i , j ) in dmap : <NEWLINE> <INDENT> tmp += dmap [ ( i , j ) ] <NEWLINE> <DEDENT> smap [ ( i , j ) ] = tmp <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> tmp += smap [ ( j , i ) ] <NEWLINE> ssmap [ ( j , i ) ] = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> for p , q in pq : <NEWLINE> <INDENT> ans = ssmap [ ( q , q ) ] - ssmap [ ( p - 1 , q ) ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
from itertools import combinations_with_replacement <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> dd = set ( list ( range ( 10 ) ) ) - set ( d ) <NEWLINE> <NL> x = str ( n ) <NEWLINE> lst = [ ] <NEWLINE> dd = list ( dd ) <NEWLINE> dd . sort ( ) <NEWLINE> sel = [ ] <NEWLINE> for i in dd : <NEWLINE> <INDENT> if int ( x [ 0 ] ) <= i and len ( sel ) < 3 : sel . append ( i * 10 ** ( len ( x ) - 1 ) ) <NEWLINE> <DEDENT> if len ( sel ) < 2 : <NEWLINE> <INDENT> if len ( dd ) == 1 : <NEWLINE> <INDENT> sel . append ( ( dd [ 0 ] * 10 + dd [ 0 ] ) * 10 ** ( len ( x ) - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if dd [ 0 ] != 0 : <NEWLINE> <INDENT> sel . append ( ( dd [ 0 ] * 10 + dd [ 0 ] ) * 10 ** ( len ( x ) - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sel . append ( ( dd [ 1 ] * 10 + dd [ 0 ] ) * 10 ** ( len ( x ) - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for j in sel : <NEWLINE> <INDENT> for l in combinations_with_replacement ( dd , len ( x ) - 1 ) : <NEWLINE> <INDENT> cnt = j <NEWLINE> for i in range ( len ( x ) - 1 ) : <NEWLINE> <INDENT> cnt += 10 ** ( len ( x ) - i - 2 ) * l [ i ] <NEWLINE> <DEDENT> if cnt >= n : lst . append ( cnt ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( lst ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> for k in range ( 1 , N + 2 ) : <NEWLINE> <INDENT> sn = k - 1 <NEWLINE> if k * sn != 2 * N : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> print ( k ) <NEWLINE> s = [ [ 0 ] * sn for _ in range ( sn ) ] <NEWLINE> for i in range ( sn ) : <NEWLINE> <INDENT> s [ i ] [ i ] = s [ i - 1 ] [ i - 1 ] + ( i + 1 ) <NEWLINE> for j in range ( i + 1 , sn ) : <NEWLINE> <INDENT> s [ i ] [ j ] = s [ i ] [ j - 1 ] + j <NEWLINE> s [ j ] [ i ] = s [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> s . append ( [ s [ i ] [ i ] for i in range ( sn ) ] ) <NEWLINE> for x in s : <NEWLINE> <INDENT> print ( sn , <STRING> . join ( map ( str , x ) ) ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , bisect <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heappush , heappop <NEWLINE> import numpy as np <NEWLINE> from scipy . sparse . csgraph import shortest_path , floyd_warshall , dijkstra , bellman_ford , johnson <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> stdin = sys . stdin <NEWLINE> <NL> ni = lambda : int ( ns ( ) ) <NEWLINE> nf = lambda : float ( ns ( ) ) <NEWLINE> na = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> nb = lambda : list ( map ( float , stdin . readline ( ) . split ( ) ) ) <NEWLINE> ns = lambda : stdin . readline ( ) . rstrip ( ) <COMMENT> <NEWLINE> <NL> N , C = na ( ) <NEWLINE> D = [ na ( ) for _ in range ( C ) ] <NEWLINE> c = [ na ( ) for _ in range ( N ) ] <NEWLINE> <NL> z = { } <NEWLINE> o = { } <NEWLINE> t = { } <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> q = ( i + j ) % 3 <NEWLINE> now = c [ i - 1 ] [ j - 1 ] - 1 <NEWLINE> if q == 0 : <NEWLINE> <INDENT> if now not in z . keys ( ) : <NEWLINE> <INDENT> z [ now ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z [ now ] += 1 <NEWLINE> <DEDENT> <DEDENT> if q == 1 : <NEWLINE> <INDENT> if now not in o . keys ( ) : <NEWLINE> <INDENT> o [ now ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> o [ now ] += 1 <NEWLINE> <DEDENT> <DEDENT> if q == 2 : <NEWLINE> <INDENT> if now not in t . keys ( ) : <NEWLINE> <INDENT> t [ now ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ now ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = inf <NEWLINE> for i , j , l in itertools . permutations ( range ( C ) , 3 ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for k , v in z . items ( ) : <NEWLINE> <INDENT> tmp += v * D [ k ] [ i ] <NEWLINE> <DEDENT> for k , v in o . items ( ) : <NEWLINE> <INDENT> tmp += v * D [ k ] [ j ] <NEWLINE> <DEDENT> for k , v in t . items ( ) : <NEWLINE> <INDENT> tmp += v * D [ k ] [ l ] <NEWLINE> <DEDENT> ans = min ( tmp , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p , S = input ( ) . split ( ) <NEWLINE> s [ int ( p ) - 1 ] += [ S ] <NEWLINE> <DEDENT> print ( sum ( <STRING> in si for si in s ) , end = <STRING> ) <NEWLINE> print ( sum ( si [ : si . index ( <STRING> ) ] . count ( <STRING> ) if <STRING> in si else 0 for si in s ) ) <NEWLINE>
from math import gcd <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> L = N * M // gcd ( N , M ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if M * i % N == 0 : <NEWLINE> <INDENT> j = M * i // N <NEWLINE> if S [ i ] != T [ j ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( L ) <NEWLINE>
<NL> def solve ( ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> if H [ i ] > H [ i + 1 ] : <NEWLINE> <INDENT> H [ i ] -= 1 <NEWLINE> if H [ i ] > H [ i + 1 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> if H [ i - 1 ] > H [ i ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> elif H [ i - 1 ] <= H [ i ] - 1 : <NEWLINE> <INDENT> H [ i ] -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> solve ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AC = [ 0 for i in range ( N ) ] <NEWLINE> WA = [ 0 for i in range ( N ) ] <NEWLINE> a = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> p , S = input ( ) . split ( ) <NEWLINE> p = int ( p ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> AC [ p - 1 ] = 1 <NEWLINE> a [ p - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if AC [ p - 1 ] == 0 : <NEWLINE> <INDENT> WA [ p - 1 ] += 1 <NEWLINE> a [ p - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> c = sum ( AC ) <NEWLINE> wa = sum ( WA ) - sum ( a ) <NEWLINE> print ( c , wa , sep = <STRING> ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> S = sorted ( [ int ( input ( ) ) for _ in range ( N ) ] ) <NEWLINE> <NL> non_10s = None <NEWLINE> for s in S : <NEWLINE> <INDENT> if s % 10 != 0 : <NEWLINE> <INDENT> non_10s = s <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> answer = sum ( S ) <NEWLINE> <NL> if answer % 10 == 0 and non_10s != None : <NEWLINE> <INDENT> answer -= non_10s <NEWLINE> <DEDENT> elif answer % 10 == 0 : <NEWLINE> <INDENT> answer = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = answer <NEWLINE> <DEDENT> print ( answer ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> dp = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> dp [ i - 1 ] = - 1 <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> if dp [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif dp [ 0 ] == - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if dp [ 1 ] >= 0 and dp [ 0 ] >= 0 : <NEWLINE> <INDENT> dp [ 0 ] = 1 <NEWLINE> dp [ 1 ] = 2 <NEWLINE> <DEDENT> elif dp [ 1 ] == - 1 and dp [ 0 ] >= 0 : <NEWLINE> <INDENT> dp [ 0 ] = 1 <NEWLINE> <DEDENT> elif dp [ 1 ] >= 0 and dp [ 0 ] == - 1 : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for j in range ( 2 , n ) : <NEWLINE> <INDENT> if dp [ j ] >= 0 : <NEWLINE> <INDENT> if dp [ j - 1 ] >= 0 and dp [ j - 2 ] >= 0 : <NEWLINE> <INDENT> dp [ j ] = dp [ j - 1 ] + dp [ j - 2 ] <NEWLINE> <DEDENT> elif dp [ j - 1 ] == - 1 and dp [ j - 2 ] >= 0 : <NEWLINE> <INDENT> dp [ j ] = dp [ j - 2 ] <NEWLINE> <DEDENT> elif dp [ j - 1 ] >= 0 and dp [ j - 2 ] == - 1 : <NEWLINE> <INDENT> dp [ j ] = dp [ j - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n - 1 ] % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) + [ 0 ] <NEWLINE> dist = [ abs ( a [ i ] - a [ i - 1 ] ) for i in range ( 1 , n + 2 ) ] <NEWLINE> total = sum ( dist ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ i ] = total - dist [ i ] - dist [ i + 1 ] + abs ( a [ i ] - a [ i + 2 ] ) <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = [ k - q ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> c [ int ( input ( ) ) ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if c [ i ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from math import ceil <NEWLINE> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> l = 0 <NEWLINE> r = max ( h ) <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for i in range ( n ) : res += ceil ( max ( 0 , ( h [ i ] - b * x ) ) / ( a - b ) ) <NEWLINE> return res <= x <NEWLINE> <NL> <DEDENT> while l + 1 < r : <NEWLINE> <INDENT> m = ( l + r ) // 2 <NEWLINE> if f ( m ) : r = m <NEWLINE> else : l = m <NEWLINE> <DEDENT> print ( r ) <NEWLINE>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> l . sort ( ) <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> c_i = bisect . bisect_left ( l , l [ i ] + l [ j ] ) <NEWLINE> if c_i > j : <NEWLINE> <INDENT> ans += c_i - j - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def dwacon5th_prelims_b ( ) : <NEWLINE> <INDENT> n , k = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> B = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> cum = 0 <NEWLINE> for a in A [ i : ] : <NEWLINE> <INDENT> cum += a <NEWLINE> B . append ( cum ) <NEWLINE> <DEDENT> <DEDENT> B . sort ( reverse = True ) <NEWLINE> <NL> bit = [ 0 ] * 41 <NEWLINE> cand = B . copy ( ) <NEWLINE> for i in range ( 40 , - 1 , - 1 ) : <NEWLINE> <INDENT> nx = [ ] <NEWLINE> for b in cand : <NEWLINE> <INDENT> if ( b >> i ) & 1 : nx . append ( b ) <NEWLINE> <DEDENT> if len ( nx ) >= k : <NEWLINE> <INDENT> cand = nx . copy ( ) <NEWLINE> bit [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = int ( <STRING> . join ( [ str ( x ) for x in reversed ( bit ) ] ) , base = 2 ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> dwacon5th_prelims_b ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> r = <STRING> <NEWLINE> t2 = T + T <NEWLINE> <NL> if set ( S ) == set ( T ) : <NEWLINE> <INDENT> if t2 . count ( S ) > 0 : <NEWLINE> <INDENT> r = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> r = <STRING> <NEWLINE> <NL> <DEDENT> print ( r ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> ret = 0 <NEWLINE> pos = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ret += i - pos <NEWLINE> pos += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
from operator import mul <NEWLINE> from functools import reduce <NEWLINE> <NL> <NL> def cmb ( n , r ) : <NEWLINE> <INDENT> if n < r : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( n - r , r ) <NEWLINE> if r == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> numer = reduce ( mul , range ( n , n - r , - 1 ) ) <NEWLINE> denom = reduce ( mul , range ( 1 , r + 1 ) ) <NEWLINE> return numer // denom % INF <NEWLINE> <NL> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> INF = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> print ( cmb ( K - 1 , i - 1 ) * cmb ( N - K + 1 , i ) % INF ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> def solve ( h , w , a ) : <NEWLINE> <INDENT> used = [ [ True ] * ( w + 2 ) for _ in range ( h + 2 ) ] <NEWLINE> que = deque ( ) <NEWLINE> for r in range ( h ) : <NEWLINE> <INDENT> used [ r + 1 ] [ 1 : - 1 ] = map ( lambda _ : _ == <STRING> , a [ r ] ) <NEWLINE> for c in range ( w ) : <NEWLINE> <INDENT> if a [ r ] [ c ] == <STRING> : <NEWLINE> <INDENT> que . append ( ( r + 1 , c + 1 , 0 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> neighbors = [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> while que : <NEWLINE> <INDENT> r , c , k = que . popleft ( ) <NEWLINE> for dr , dc in neighbors : <NEWLINE> <INDENT> nr , nc = r + dr , c + dc <NEWLINE> if not used [ nr ] [ nc ] : <NEWLINE> <INDENT> que . append ( ( nr , nc , k + 1 ) ) <NEWLINE> used [ nr ] [ nc ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return k <NEWLINE> <NL> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ input ( ) for _ in range ( h ) ] <NEWLINE> print ( solve ( h , w , a ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . p = [ i for i in range ( n ) ] <NEWLINE> self . components = n <COMMENT> <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . p [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . p [ x ] = self . root ( self . p [ x ] ) <NEWLINE> return self . p [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x , y = self . root ( x ) , self . root ( y ) <NEWLINE> if x != y : <NEWLINE> <INDENT> self . p [ x ] = y <NEWLINE> self . components -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return ( self . root ( x ) == self . root ( y ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> X , Y = [ ] , [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> X . append ( [ x , i ] ) <NEWLINE> Y . append ( [ y , i ] ) <NEWLINE> <NL> <DEDENT> X . sort ( ) <NEWLINE> Y . sort ( ) <NEWLINE> <NL> edges = [ ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> edges . append ( [ X [ i + 1 ] [ 0 ] - X [ i ] [ 0 ] , X [ i ] [ 1 ] , X [ i + 1 ] [ 1 ] ] ) <NEWLINE> edges . append ( [ Y [ i + 1 ] [ 0 ] - Y [ i ] [ 0 ] , Y [ i ] [ 1 ] , Y [ i + 1 ] [ 1 ] ] ) <NEWLINE> <DEDENT> edges . sort ( ) <NEWLINE> <NL> UF = UnionFind ( N ) <NEWLINE> ans = 0 <NEWLINE> for cost , s , t in edges : <NEWLINE> <INDENT> if UF . same ( s , t ) : continue <NEWLINE> <NL> UF . unite ( s , t ) <NEWLINE> ans += cost <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num = [ i for i in range ( 1 , n + 1 ) ] <NEWLINE> <NL> order = dict ( zip ( num , a ) ) <NEWLINE> <NL> order2 = sorted ( order . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( order2 [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( [ str ( n ) for n in ans ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a_ = int ( input ( ) ) <NEWLINE> if a_ not in a : <NEWLINE> <INDENT> a [ a_ ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ a_ ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if a [ i ] % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> tree = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> tree [ a ] . append ( b ) <NEWLINE> tree [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> p -= 1 <NEWLINE> ans [ p ] += x <NEWLINE> <NL> <DEDENT> checked = [ False ] * n <NEWLINE> checked [ 0 ] = True <NEWLINE> <NL> <NL> def function ( now , count ) : <NEWLINE> <INDENT> ans [ now ] += count <NEWLINE> for i in tree [ now ] : <NEWLINE> <INDENT> if checked [ i ] == False : <NEWLINE> <INDENT> checked [ i ] = True <NEWLINE> function ( i , ans [ now ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> function ( 0 , 0 ) <NEWLINE> <NL> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> li = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( s ) + 1 ) : <NEWLINE> <INDENT> if j - i <= 6 : <NEWLINE> <INDENT> li += [ s [ i : j ] ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> li2 = set ( li ) <NEWLINE> li3 = sorted ( li2 ) <NEWLINE> print ( li3 [ k - 1 ] ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def solve ( a , lvl , prev , dp ) : <NEWLINE> <INDENT> if ( prev , lvl ) in dp : return dp [ ( prev , lvl ) ] <NEWLINE> if lvl == len ( a ) - 1 : <NEWLINE> <INDENT> if prev == 0 : return max ( a [ - 1 ] [ 1 ] , a [ - 1 ] [ 2 ] ) <NEWLINE> if prev == 1 : return max ( a [ - 1 ] [ 0 ] , a [ - 1 ] [ 2 ] ) <NEWLINE> if prev == 2 : return max ( a [ - 1 ] [ 0 ] , a [ - 1 ] [ 1 ] ) <NEWLINE> <DEDENT> if prev == - 1 : <NEWLINE> <INDENT> p = a [ 0 ] [ 0 ] + solve ( a , lvl + 1 , 0 , dp ) <NEWLINE> q = a [ 0 ] [ 1 ] + solve ( a , lvl + 1 , 1 , dp ) <NEWLINE> r = a [ 0 ] [ 2 ] + solve ( a , lvl + 1 , 2 , dp ) <NEWLINE> return max ( p , q , r ) <NEWLINE> <DEDENT> dp [ ( prev , lvl ) ] = max ( a [ lvl ] [ ( prev + 1 ) % 3 ] + solve ( a , lvl + 1 , ( prev + 1 ) % 3 , dp ) , a [ lvl ] [ ( prev - 1 ) % 3 ] + solve ( a , lvl + 1 , ( prev - 1 ) % 3 , dp ) ) <NEWLINE> return dp [ ( prev , lvl ) ] <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( max ( a [ 0 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( solve ( a , 0 , - 1 , { } ) ) <NEWLINE> <DEDENT> <DEDENT>
h , w = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> dp = [ [ 0 for i in range ( w ) ] for j in range ( h ) ] <NEWLINE> mod = 1e9 + 7 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if i == 0 and j == 0 : <NEWLINE> <INDENT> dp [ 0 ] [ 0 ] = 1 if ( s [ j ] == <STRING> ) else 0 <NEWLINE> <DEDENT> elif i == 0 : <NEWLINE> <INDENT> dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] if ( s [ j ] == <STRING> ) else 0 <NEWLINE> <DEDENT> elif j == 0 : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] if ( s [ 0 ] == <STRING> ) else 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] % mod + dp [ i ] [ j - 1 ] % mod ) % mod if s [ j ] == <STRING> else 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( int ( dp [ h - 1 ] [ w - 1 ] % mod ) ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> xlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( abs ( xlist [ 0 ] - x ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ylist = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ylist . append ( abs ( xlist [ i ] - x ) ) <NEWLINE> <DEDENT> from functools import reduce <NEWLINE> from math import gcd <NEWLINE> print ( reduce ( gcd , ylist ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lmax , rmin = 0 , n <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> lmax = max ( lmax , l ) <NEWLINE> rmin = min ( rmin , r ) <NEWLINE> <NL> <DEDENT> print ( ( rmin - lmax ) + 1 if ( rmin - lmax ) + 1 > 0 else 0 ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> dna = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> res = [ 0 ] <NEWLINE> x = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] in dna : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += [ x ] <NEWLINE> x = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max ( x , max ( res ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> print ( ( n * ( n - 1 ) ) // 2 ) <NEWLINE> <NL>
import sys <NEWLINE> lines = [ s . rstrip ( <STRING> ) for s in sys . stdin . readlines ( ) ] <NEWLINE> input = lines . pop ( 0 ) <NEWLINE> acgt = tuple ( <STRING> ) <NEWLINE> max_num_list = [ ] <NEWLINE> max_num = 0 <NEWLINE> for c in input : <NEWLINE> <INDENT> if c in acgt : <NEWLINE> <INDENT> max_num += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_num_list . append ( max_num ) <NEWLINE> max_num = 0 <NEWLINE> <DEDENT> <DEDENT> max_num_list . append ( max_num ) <NEWLINE> print ( max ( max_num_list ) ) <NEWLINE>
n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 0 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , n + 1 - i ) : <NEWLINE> <INDENT> k = max ( 0 , n - i - j ) <NEWLINE> if 10000 * i + 5000 * j + 1000 * k == y : <NEWLINE> <INDENT> print ( i , j , k ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> import os <NEWLINE> import itertools <NEWLINE> import string <NEWLINE> import heapq <NEWLINE> import _collections <NEWLINE> from collections import Counter <NEWLINE> from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from functools import lru_cache <NEWLINE> import bisect <NEWLINE> import re <NEWLINE> import queue <NEWLINE> import decimal <NEWLINE> <NL> <NL> class Scanner ( ) : <NEWLINE> <INDENT> @ staticmethod <NEWLINE> def int ( ) : <NEWLINE> <INDENT> return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def string ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def map_int ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in Scanner . string ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def string_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . string ( ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def int_list_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . map_int ( ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def int_cols_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . int ( ) for i in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Math ( ) : <NEWLINE> <INDENT> @ staticmethod <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return Math . gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // Math . gcd ( a , b ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def divisor ( n ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> i = 1 <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> res . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def round_up ( a , b ) : <NEWLINE> <INDENT> return - ( - a // b ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def is_prime ( n ) : <NEWLINE> <INDENT> if n < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if n == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> d = int ( n ** 0.5 ) + 1 <NEWLINE> for i in range ( 3 , d + 1 , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def fact ( N ) : <NEWLINE> <INDENT> res = { } <NEWLINE> tmp = N <NEWLINE> for i in range ( 2 , int ( N ** 0.5 + 1 ) + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while tmp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> tmp //= i <NEWLINE> <DEDENT> if cnt > 0 : <NEWLINE> <INDENT> res [ i ] = cnt <NEWLINE> <DEDENT> <DEDENT> if tmp != 1 : <NEWLINE> <INDENT> res [ tmp ] = 1 <NEWLINE> <DEDENT> if res == { } : <NEWLINE> <INDENT> res [ N ] = 1 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def pop_count ( x ) : <NEWLINE> <INDENT> x = x - ( ( x >> 1 ) & 0x5555555555555555 ) <NEWLINE> x = ( x & 0x3333333333333333 ) + ( ( x >> 2 ) & 0x3333333333333333 ) <NEWLINE> x = ( x + ( x >> 4 ) ) & 0x0f0f0f0f0f0f0f0f <NEWLINE> x = x + ( x >> 8 ) <NEWLINE> x = x + ( x >> 16 ) <NEWLINE> x = x + ( x >> 32 ) <NEWLINE> return x & 0x0000007f <NEWLINE> <NL> <NL> <DEDENT> MOD = int ( 1e09 ) + 7 <NEWLINE> INF = int ( 1e15 ) <NEWLINE> <NL> <NL> class Edge : <NEWLINE> <INDENT> def __init__ ( self , to_ , id_ ) : <NEWLINE> <INDENT> self . to = to_ <NEWLINE> self . id = id_ <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = None <NEWLINE> G = None <NEWLINE> K = None <NEWLINE> <NL> <NL> def dfs ( to , c ) : <NEWLINE> <INDENT> global G <NEWLINE> global ans <NEWLINE> nc = c % K + 1 <NEWLINE> for g in G [ to ] : <NEWLINE> <INDENT> if ans [ g . id ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ g . id ] = nc <NEWLINE> dfs ( g . to , nc ) <NEWLINE> nc = nc % K + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> global G <NEWLINE> global ans <NEWLINE> global K <NEWLINE> N = Scanner . int ( ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x , y = Scanner . map_int ( ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> G [ x ] . append ( Edge ( y , i ) ) <NEWLINE> G [ y ] . append ( Edge ( x , i ) ) <NEWLINE> <NL> <DEDENT> K = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> K = max ( K , len ( G [ i ] ) ) <NEWLINE> <NL> <DEDENT> ans = [ - 1 for _ in range ( N - 1 ) ] <NEWLINE> dfs ( 0 , 0 ) <NEWLINE> print ( K ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> solve ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> if R - L >= 2019 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = R * R <NEWLINE> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , ( i * j ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> X [ A [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> L = <STRING> . join ( [ str ( i ) for i in X ] ) <NEWLINE> print ( L ) <NEWLINE>
from itertools import permutations <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> nec = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> nec . append ( [ i , j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if len ( nec ) == h + w - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
s = input ( ) <NEWLINE> cons = 0 <NEWLINE> ans = [ 0 ] * ( len ( s ) ) <NEWLINE> left = 0 <NEWLINE> right = 0 <NEWLINE> check1 = True <NEWLINE> check2 = False <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if check1 == True and s [ i ] == <STRING> : <NEWLINE> <INDENT> cons = i <NEWLINE> check1 = False <NEWLINE> check2 = True <NEWLINE> <DEDENT> if check2 == True and ( s [ i ] == <STRING> or i == len ( s ) - 1 ) : <NEWLINE> <INDENT> right = i - 1 <NEWLINE> if i == len ( s ) - 1 : <NEWLINE> <INDENT> right += 1 <NEWLINE> <DEDENT> dum = s [ left : right + 1 ] <NEWLINE> dum_index = dum . index ( <STRING> ) <NEWLINE> dum_len = len ( dum ) <NEWLINE> div , mod = divmod ( dum_len , 2 ) <NEWLINE> if dum_index % 2 == 0 : <NEWLINE> <INDENT> ans [ cons ] = div + mod <NEWLINE> ans [ cons - 1 ] = div <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ cons ] = div <NEWLINE> ans [ cons - 1 ] = div + mod <NEWLINE> <NL> <DEDENT> check1 = True <NEWLINE> check2 = False <NEWLINE> left = right + 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a_l = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> <NL> dp = [ 1 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if 1 not in a_l : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <DEDENT> if n > 1 : <NEWLINE> <INDENT> for i in a_l : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> if 2 not in a_l : <NEWLINE> <INDENT> dp [ 2 ] = dp [ 0 ] + dp [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 2 ] = 0 <NEWLINE> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if dp [ i ] != 0 : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % 1000000007 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
from collections import deque <NEWLINE> import itertools <NEWLINE> def bfs ( G , visited , sy , sx ) : <NEWLINE> <INDENT> queue = deque ( [ [ sy , sx ] ] ) <NEWLINE> visited [ sy ] [ sx ] = 0 <NEWLINE> while queue : <NEWLINE> <INDENT> y , x = queue . popleft ( ) <NEWLINE> if ( y , x ) == ( H - 1 , W - 1 ) : <NEWLINE> <INDENT> return visited [ y ] [ x ] <NEWLINE> <DEDENT> for j , k in ( [ 1 , 0 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ) : <NEWLINE> <INDENT> tmp_y , tmp_x = y + j , x + k <NEWLINE> if 0 <= tmp_y <= H - 1 and 0 <= tmp_x <= W - 1 and G [ tmp_y ] [ tmp_x ] != <STRING> : <NEWLINE> <INDENT> if visited [ tmp_y ] [ tmp_x ] == - 1 : <NEWLINE> <INDENT> visited [ tmp_y ] [ tmp_x ] = visited [ y ] [ x ] + 1 <NEWLINE> queue . append ( [ tmp_y , tmp_x ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return - 1 <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> sy , sx = 0 , 0 <NEWLINE> dist = 0 <NEWLINE> visited = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> dist = bfs ( G , visited , sy , sx ) <NEWLINE> if dist == - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( list ( itertools . chain . from_iterable ( G ) ) . count ( <STRING> ) - dist - 1 ) <NEWLINE> <DEDENT> <DEDENT>
s = str ( input ( ) ) <NEWLINE> if <STRING> in s and <STRING> in s : <NEWLINE> <INDENT> if s . find ( <STRING> ) < s . rfind ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT>
N , Q = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> S = input ( ) . rstrip ( ) <NEWLINE> a = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i > 1 : <NEWLINE> <INDENT> a [ i ] = a [ i - 1 ] <NEWLINE> <DEDENT> if i != 0 and S [ i - 1 ] == <STRING> and S [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> print ( a [ r - 1 ] - a [ l - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 for _ in range ( n ) ] <NEWLINE> gra = [ [ ] for _ in range ( n ) ] <NEWLINE> visited = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> gra [ a - 1 ] . append ( b - 1 ) <NEWLINE> gra [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> def dfs ( st ) : <NEWLINE> <INDENT> temp = gra [ st ] <NEWLINE> for i in temp : <NEWLINE> <INDENT> if visited [ i ] == 0 : <NEWLINE> <INDENT> visited [ i ] += 1 <NEWLINE> ans [ i ] += ans [ st ] <NEWLINE> dfs ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> visited [ 0 ] += 1 <NEWLINE> dfs ( 0 ) <NEWLINE> <NL> for h in range ( n ) : <NEWLINE> <INDENT> ans [ h ] = str ( ans [ h ] ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
from bisect import * <NEWLINE> S = list ( str ( input ( ) ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> alp = list ( <STRING> ) <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> b = bisect_left ( alp , S [ i ] ) <NEWLINE> <NL> if i == len ( S ) - 1 : <NEWLINE> <INDENT> S [ i ] = alp [ ( b + K ) % 26 ] <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif 26 - b <= K : <NEWLINE> <INDENT> K -= ( 26 - b ) <NEWLINE> S [ i ] = <STRING> <NEWLINE> <DEDENT> if K == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( S ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> res_graph = [ [ 1 , i ] for i in range ( 2 , n + 1 ) ] <NEWLINE> res = ( n - 1 ) * ( n - 2 ) // 2 <NEWLINE> <NL> if ( k > ( n - 2 ) * ( n - 1 ) // 2 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> tmp_edge = 2 <NEWLINE> while res != k : <NEWLINE> <INDENT> tmp = 1 <NEWLINE> for i in range ( n - tmp_edge ) : <NEWLINE> <INDENT> res_graph . append ( [ tmp_edge , tmp + tmp_edge ] ) <NEWLINE> res -= 1 <NEWLINE> tmp += 1 <NEWLINE> if res == k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> tmp_edge += 1 <NEWLINE> <NL> <DEDENT> print ( len ( res_graph ) ) <NEWLINE> for i , j in res_graph : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> from math import gcd <NEWLINE> <COMMENT> <NL> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> return x * y // gcd ( x , y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def solve ( n , m , s , t ) : <NEWLINE> <INDENT> L = lcm ( n , m ) <NEWLINE> G = gcd ( n , m ) <NEWLINE> s_interval = L // n <NEWLINE> t_interval = L // m <NEWLINE> for i in range ( G ) : <NEWLINE> <INDENT> if s [ i * n // G ] != t [ i * m // G ] : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return L <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> print ( solve ( N , M , s , t ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> G = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a ] . append ( [ b , c ] ) <NEWLINE> G [ b ] . append ( [ a , c ] ) <NEWLINE> <NL> <DEDENT> q , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> D = [ None ] * ( n + 1 ) <NEWLINE> <NL> def dfs ( x , d ) : <NEWLINE> <INDENT> D [ x ] = d <NEWLINE> for yy , dd in G [ x ] : <NEWLINE> <INDENT> if D [ yy ] is not None : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( yy , dd + d ) <NEWLINE> <DEDENT> <DEDENT> dfs ( k , 0 ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( D [ x ] + D [ y ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> power = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> power = power * i % mod <NEWLINE> <DEDENT> print ( power ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> rep = s . replace ( <STRING> , <STRING> ) <NEWLINE> if len ( rep ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s . index ( rep [ 0 ] ) < k : <NEWLINE> <INDENT> print ( rep [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( 0 , 10 ) : <NEWLINE> <INDENT> if str ( i ) in s [ : - 2 ] : <NEWLINE> <INDENT> index_1 = s . index ( str ( i ) ) <NEWLINE> <NL> for j in range ( 0 , 10 ) : <NEWLINE> <INDENT> if str ( j ) in s [ index_1 + 1 : - 1 ] : <NEWLINE> <INDENT> index_2 = s [ index_1 + 1 : - 1 ] . index ( str ( j ) ) + index_1 + 1 <NEWLINE> <NL> for k in range ( 0 , 10 ) : <NEWLINE> <INDENT> if str ( k ) in s [ index_2 + 1 : ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
A = input ( ) <NEWLINE> <NL> Alphabet = list ( <STRING> ) <NEWLINE> <NL> N = len ( A ) <NEWLINE> ans = N * ( N - 1 ) / 2 + 1 <NEWLINE> <NL> for i in Alphabet : <NEWLINE> <INDENT> z = 0 <NEWLINE> for j in range ( len ( A ) ) : <NEWLINE> <INDENT> if i == A [ j ] : <NEWLINE> <INDENT> z += 1 <NEWLINE> <DEDENT> <DEDENT> if z > 1 : <NEWLINE> <INDENT> ans -= z * ( z - 1 ) / 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : - x , map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> heapq . heapify ( A ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> mx = heapq . heappop ( A ) <NEWLINE> heapq . heappush ( A , mx / 2 ) <NEWLINE> <DEDENT> print ( sum ( [ int ( - a ) for a in A ] ) ) <NEWLINE>
H , W , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> A = list ( ) <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w , a in enumerate ( map ( int , input ( ) . split ( ) ) ) : <NEWLINE> <INDENT> A . append ( [ a , h , w ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> A = sorted ( A , key = lambda x : x [ 0 ] ) <NEWLINE> <NL> B = [ 0 ] * ( H * W ) <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> while i + D < W * H : <NEWLINE> <INDENT> B [ i + D ] = B [ i ] + abs ( A [ i ] [ 1 ] - A [ i + D ] [ 1 ] ) + abs ( A [ i ] [ 2 ] - A [ i + D ] [ 2 ] ) <NEWLINE> i += D <NEWLINE> <NL> <DEDENT> <DEDENT> for q in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( B [ ~ - r ] - B [ ~ - l ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> visited = { 1 , } <NEWLINE> old = 1 <NEWLINE> count = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> new = a [ old - 1 ] <NEWLINE> count += 1 <NEWLINE> if new in visited : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if new == 2 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> old = new <NEWLINE> visited . add ( new ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if ( i == 0 ) : <NEWLINE> <INDENT> ans = b [ a [ 0 ] - 1 ] <NEWLINE> y = a [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = a [ i ] <NEWLINE> if ( x - y == 1 ) : <NEWLINE> <INDENT> ans = ans + b [ x - 1 ] + c [ y - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + b [ x - 1 ] <NEWLINE> <DEDENT> y = x <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> height = h [ 0 ] <NEWLINE> l = [ ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if h [ i ] <= height : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> height = h [ i ] <NEWLINE> l . append ( cnt ) <NEWLINE> <DEDENT> print ( max ( l ) ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> lt = len ( T ) <NEWLINE> ls = len ( S ) <NEWLINE> S += <STRING> * lt <NEWLINE> <NL> if ls < lt : <NEWLINE> <INDENT> flg = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( ls - lt + 1 , - 1 , - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> flg = 1 <NEWLINE> for j in range ( i , i + lt ) : <NEWLINE> <INDENT> s = S [ j ] <NEWLINE> <COMMENT> <NL> if s == <STRING> : continue <NEWLINE> if s == <STRING> or s != T [ j - i ] : <NEWLINE> <INDENT> flg = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( ( S [ 0 : i ] + T + S [ i + lt : ls ] ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( m ) ] <NEWLINE> l = [ 1 ] * ( n + 1 ) <NEWLINE> for j in a : <NEWLINE> <INDENT> l [ j ] = 0 <NEWLINE> <DEDENT> x = 10 ** 9 + 7 <NEWLINE> if m > n // 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if 1 not in a : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if l [ i ] : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % x <NEWLINE> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <DEDENT>
s = [ int ( i ) for i in list ( input ( ) ) ] <NEWLINE> <NL> print ( 2 * min ( s . count ( 1 ) , s . count ( 0 ) ) ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( 0 , A - K ) , max ( 0 , B - max ( 0 , K - A ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> from math import gcd <NEWLINE> cou = 0 <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> b = n // i - 1 <NEWLINE> if b >= 2 and n // b == n % b : <NEWLINE> <INDENT> cou += b <NEWLINE> <NL> <DEDENT> if i > 2 : <NEWLINE> <INDENT> c = i - 1 <NEWLINE> if n // c == n % c : <NEWLINE> <INDENT> cou += c <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cou ) <NEWLINE>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> L = sorted ( [ int ( n ) for n in input ( ) . split ( ) ] ) <NEWLINE> <COMMENT> <NL> <NL> count = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> b = L [ : i ] <NEWLINE> c = L [ i + 1 : ] <NEWLINE> for j in b : <NEWLINE> <INDENT> count += bisect . bisect_left ( c , L [ i ] + j ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 3 * 10 ** 8 <NEWLINE> <NL> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> a = x [ i ] <NEWLINE> b = x [ i + k - 1 ] <NEWLINE> t = min ( abs ( a ) + abs ( b - a ) , abs ( b ) + abs ( b - a ) ) <NEWLINE> if m > t : <NEWLINE> <INDENT> m = t <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string <NEWLINE> from collections import defaultdict as D <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> import os <NEWLINE> from operator import mul <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def _S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( _S ( ) ) <NEWLINE> def LS ( ) : return list ( _S ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , LS ( ) ) ) <NEWLINE> <NL> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> inputFile = basename_without_ext = os . path . splitext ( os . path . basename ( __file__ ) ) [ 0 ] + <STRING> <NEWLINE> sys . stdin = open ( inputFile , <STRING> ) <NEWLINE> <DEDENT> INF = float ( <STRING> ) <NEWLINE> IINF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> l , r = LI ( ) <NEWLINE> m = 2019 <NEWLINE> <NL> end = min ( l + 2019 , r ) <NEWLINE> <NL> ar = [ ] <NEWLINE> for i in range ( l , end ) : <NEWLINE> <INDENT> for j in range ( i + 1 , end + 1 ) : <NEWLINE> <INDENT> ar . append ( ( i * j ) % m ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( ar ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
n , t = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c , tt = map ( int , input ( ) . split ( ) ) <NEWLINE> if tt > t : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> li . append ( c ) <NEWLINE> <DEDENT> if len ( li ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( li ) ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> md = 0 <NEWLINE> j = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> while j < n : <NEWLINE> <INDENT> if A [ j ] - A [ i ] <= 2 : <NEWLINE> <INDENT> md = max ( j - i , md ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( md + 1 ) <NEWLINE> <NL>
h = int ( input ( ) ) <NEWLINE> layer = 0 <NEWLINE> branch_set = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if h > 1 : <NEWLINE> <INDENT> h //= 2 <NEWLINE> layer += 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , layer ) : <NEWLINE> <INDENT> branch_set += 2 ** i <NEWLINE> <NL> <DEDENT> print ( branch_set + 2 ** layer ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> h . sort ( ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> for i in range ( len ( h ) - k + 1 ) : <NEWLINE> <INDENT> ma = h [ i + k - 1 ] <NEWLINE> mi = h [ i ] <NEWLINE> ans = min ( ans , ma - mi ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> y = ( a ** 2 ) * b <NEWLINE> h = x / ( a ** 2 ) <NEWLINE> <NL> def get_angle_from_sides ( a , b , c ) : <NEWLINE> <INDENT> return math . acos ( ( a ** 2 + b ** 2 - c ** 2 ) / ( 2 * a * b ) ) <NEWLINE> <NL> <DEDENT> def checkio ( a , b , c ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> angles = [ get_angle_from_sides ( * abc ) for abc in ( ( a , b , c ) , ( b , c , a ) , ( c , a , b ) ) ] <NEWLINE> result = sorted ( ( math . degrees ( a ) ) for a in angles ) <NEWLINE> return [ 0 , 0 , 0 ] if 0 in result else result <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> return [ 0 , 0 , 0 ] <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> if y == x : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif y / 2 <= x : <NEWLINE> <INDENT> if a >= 2 * ( b - h ) : <NEWLINE> <INDENT> m = checkio ( a , 2 * ( b - h ) , math . sqrt ( a ** 2 + ( 2 * ( b - h ) ) ** 2 ) ) <NEWLINE> count = m [ 0 ] <NEWLINE> <DEDENT> elif a < 2 * ( b - h ) : <NEWLINE> <INDENT> m = checkio ( a , 2 * ( b - h ) , math . sqrt ( a ** 2 + ( 2 * ( b - h ) ) ** 2 ) ) <NEWLINE> count = m [ 1 ] <NEWLINE> <DEDENT> <DEDENT> elif y / 2 > x : <NEWLINE> <INDENT> z = 2 * x / ( a * b ) <NEWLINE> if b >= z : <NEWLINE> <INDENT> m = checkio ( b , z , math . sqrt ( b ** 2 + ( z ) ** 2 ) ) <NEWLINE> count = m [ 1 ] <NEWLINE> <DEDENT> elif b < z : <NEWLINE> <INDENT> m = checkio ( b , z , math . sqrt ( b ** 2 + ( z ) ** 2 ) ) <NEWLINE> count = m [ 0 ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> numlist = range ( 1000 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in numlist : <NEWLINE> <INDENT> num = str ( i ) <NEWLINE> if len ( num ) == 1 : <NEWLINE> <INDENT> num = <STRING> + num <NEWLINE> <DEDENT> if len ( num ) == 2 : <NEWLINE> <INDENT> num = <STRING> + num <NEWLINE> <DEDENT> if num [ 0 ] in S [ : N - 1 ] : <NEWLINE> <INDENT> num1 = S . index ( num [ 0 ] ) <NEWLINE> if num [ 1 ] in S [ num1 + 1 : N - 1 ] : <NEWLINE> <INDENT> S2 = S [ num1 + 1 : N - 1 ] <NEWLINE> num2 = S2 . index ( num [ 1 ] ) + num1 + 1 <NEWLINE> if num [ 2 ] in S [ num2 + 1 : ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> if S - i - j >= 0 and S - i - j <= K : <NEWLINE> <INDENT> res += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> S = readline ( ) . strip ( ) <NEWLINE> K = int ( readline ( ) ) <NEWLINE> <NL> subs = set ( ) <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , min ( len ( S ) + 1 , i + K + 1 ) ) : <NEWLINE> <INDENT> subs . add ( S [ i : j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> subs = sorted ( subs ) <NEWLINE> print ( subs [ K - 1 ] ) <NEWLINE> <NL> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def Convert ( N ) : <NEWLINE> <INDENT> if N > 0 : return <STRING> <NEWLINE> else : return <STRING> <NEWLINE> <NL> <DEDENT> N , K , Q = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> Win = [ K - Q ] * N <NEWLINE> for T in range ( 0 , Q ) : <NEWLINE> <INDENT> Win [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( list ( map ( Convert , Win ) ) ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> A = list ( sorted ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> counter = defaultdict ( int ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> counter [ C ] += B <NEWLINE> <DEDENT> c_list = list ( sorted ( counter . keys ( ) , reverse = True ) ) <NEWLINE> <NL> <COMMENT> <NL> moves = [ ] <NEWLINE> n = 0 <NEWLINE> for c in c_list : <NEWLINE> <INDENT> b = counter [ c ] <NEWLINE> if n + b < N : <NEWLINE> <INDENT> p = b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = N - n <NEWLINE> <DEDENT> for i in range ( p ) : <NEWLINE> <INDENT> moves . append ( c ) <NEWLINE> <DEDENT> if len ( moves ) >= N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> siz = min ( N , len ( moves ) ) <NEWLINE> for i in range ( siz ) : <NEWLINE> <COMMENT> <NL> <INDENT> A [ i ] = max ( A [ i ] , moves [ i ] ) <NEWLINE> <NL> <DEDENT> print ( sum ( A ) ) <NEWLINE>
import collections <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> cum_sum = [ 0 ] <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> cum_sum . append ( cum_sum [ i ] + ( 1 + p [ i ] ) / 2 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N - K + 2 ) : <NEWLINE> <INDENT> temp = cum_sum [ i + K - 1 ] - cum_sum [ i - 1 ] <NEWLINE> <COMMENT> <NL> ans = max ( ans , temp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * a ) <NEWLINE>
from scipy . special import comb <NEWLINE> from collections import Counter as C <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ 0 ] * ( n + 1 ) <NEWLINE> tmp = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> l [ i + 1 ] = tmp + a [ i ] <NEWLINE> tmp = l [ i + 1 ] <NEWLINE> <NL> <DEDENT> c = C ( l ) <NEWLINE> ans = 0 <NEWLINE> <NL> for v in c . values ( ) : <NEWLINE> <INDENT> ans += comb ( v , 2 , exact = True ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> wv = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] ) <NEWLINE> dp = np . zeros ( [ N + 1 , W + 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> dp [ i ] [ : wv [ i - 1 ] [ 0 ] ] = dp [ i - 1 ] [ : wv [ i - 1 ] [ 0 ] ] <NEWLINE> dp [ i ] [ wv [ i - 1 ] [ 0 ] : ] = np . maximum ( dp [ i - 1 ] [ wv [ i - 1 ] [ 0 ] : ] , dp [ i - 1 ] [ : W + 1 - wv [ i - 1 ] [ 0 ] ] + wv [ i - 1 ] [ 1 ] ) <NEWLINE> <DEDENT> print ( int ( dp [ - 1 , - 1 ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 1 + ( i - 1 ) / 2 for i in p ] <NEWLINE> l = sum ( a [ : k ] ) <NEWLINE> ans = l <NEWLINE> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> l = l - a [ i - 1 ] + a [ k + i - 1 ] <NEWLINE> ans = max ( ans , l ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> steps = [ ] <NEWLINE> <NL> for x in range ( int ( n ** 0.5 ) ) : <NEWLINE> <INDENT> if n % ( x + 1 ) == 0 : <NEWLINE> <INDENT> steps . append ( x + n // ( x + 1 ) - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( steps ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> t0 , a0 = 1 , 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> t1 , a1 = map ( int , input ( ) . split ( ) ) <NEWLINE> f0 = t0 // t1 <NEWLINE> if t0 % t1 != 0 : f0 += 1 <NEWLINE> f1 = a0 // a1 <NEWLINE> if a0 % a1 != 0 : f1 += 1 <NEWLINE> f = max ( f0 , f1 ) <NEWLINE> t0 , a0 = t1 * f , a1 * f <NEWLINE> <NL> <DEDENT> print ( t0 + a0 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( 26 ) : <NEWLINE> <INDENT> for j in range ( 15 ) : <NEWLINE> <INDENT> if 4 * i + 7 * j == n : <NEWLINE> <INDENT> count += 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if count == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> from bisect import bisect_left <NEWLINE> import sys <NEWLINE> n , * s = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> t = sorted ( s ) <NEWLINE> for ss in s : <NEWLINE> <INDENT> x = bisect_left ( t , ss ) <NEWLINE> if x == n - 1 : <NEWLINE> <INDENT> print ( t [ - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t [ - 1 ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
from collections import deque <NEWLINE> from copy import deepcopy <NEWLINE> <NL> <NL> def bfs ( table , i , j , h , w ) : <NEWLINE> <INDENT> dq = deque ( ) <NEWLINE> ans = 0 <NEWLINE> dq . append ( ( i , j , 0 ) ) <COMMENT> <NEWLINE> table [ i ] [ j ] = <STRING> <NEWLINE> while dq : <NEWLINE> <INDENT> x , y , dis = dq . popleft ( ) <NEWLINE> ans = max ( ans , dis ) <NEWLINE> if x > 0 and ( x - 1 , y ) and table [ x - 1 ] [ y ] != <STRING> : <NEWLINE> <INDENT> dq . append ( ( x - 1 , y , dis + 1 ) ) <NEWLINE> table [ x - 1 ] [ y ] = <STRING> <NEWLINE> <DEDENT> if x < h - 1 and ( x + 1 , y ) and table [ x + 1 ] [ y ] != <STRING> : <NEWLINE> <INDENT> dq . append ( ( x + 1 , y , dis + 1 ) ) <NEWLINE> table [ x + 1 ] [ y ] = <STRING> <NEWLINE> <DEDENT> if y > 0 and ( x , y - 1 ) and table [ x ] [ y - 1 ] != <STRING> : <NEWLINE> <INDENT> dq . append ( ( x , y - 1 , dis + 1 ) ) <NEWLINE> table [ x ] [ y - 1 ] = <STRING> <NEWLINE> <DEDENT> if y < w - 1 and ( x , y + 1 ) and table [ x ] [ y + 1 ] != <STRING> : <NEWLINE> <INDENT> dq . append ( ( x , y + 1 , dis + 1 ) ) <NEWLINE> table [ x ] [ y + 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> h , w = [ int ( i ) for i in input ( ) . strip ( ) . split ( ) ] <NEWLINE> grid = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if grid [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> _grid = deepcopy ( grid ) <NEWLINE> max_path = bfs ( _grid , i , j , h , w ) <NEWLINE> ans = max ( ans , max_path ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> def itrsum ( arr ) : <NEWLINE> <INDENT> n = len ( arr ) <NEWLINE> tri = np . array ( [ [ i >= j for i in range ( n ) ] for j in range ( n + 1 ) ] ) <NEWLINE> return np . dot ( tri , arr ) . astype ( <STRING> ) <NEWLINE> <DEDENT> n , w = map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> t = [ list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> w1 = t [ 0 ] [ 0 ] <NEWLINE> <COMMENT> <NL> arr = [ [ x for x in t if x [ 0 ] == w1 + i ] for i in range ( 4 ) ] <NEWLINE> arr = [ l for l in arr ] <NEWLINE> lenarr = list ( map ( len , arr ) ) <NEWLINE> arr0 = [ itrsum ( np . array ( sorted ( [ x [ 0 ] for x in l ] ) , dtype = <STRING> ) ) for l in arr ] <NEWLINE> arr1 = [ itrsum ( np . array ( sorted ( [ x [ 1 ] for x in l ] ) , dtype = <STRING> ) ) for l in arr ] <NEWLINE> <COMMENT> <NL> arr = np . array ( arr ) <NEWLINE> arrw = 0 <NEWLINE> arrv = 0 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> arrw = np . ravel ( arr0 [ i ] . reshape ( lenarr [ i ] + 1 , 1 ) + np . array ( [ arrw ] ) ) <NEWLINE> arrv = np . ravel ( arr1 [ i ] . reshape ( lenarr [ i ] + 1 , 1 ) + np . array ( [ arrv ] ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ansarr = arrv [ arrw <= w ] <NEWLINE> print ( np . max ( ansarr ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> p [ x - 1 ] . append ( y - 1 ) <NEWLINE> <NL> <DEDENT> f = [ - 1 for _ in range ( n ) ] <NEWLINE> <NL> def calc ( x ) : <NEWLINE> <INDENT> if f [ x ] != - 1 : <NEWLINE> <INDENT> return f [ x ] <NEWLINE> <DEDENT> if len ( p [ x ] ) == 0 : <NEWLINE> <INDENT> f [ x ] = 0 <NEWLINE> return 0 <NEWLINE> <DEDENT> f [ x ] = max ( [ calc ( i ) for i in p [ x ] ] ) + 1 <NEWLINE> return f [ x ] <NEWLINE> <NL> <DEDENT> m = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if f [ i ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> m = max ( m , calc ( i ) ) <NEWLINE> <DEDENT> print ( m ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = 1 <NEWLINE> c = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if S == a [ j ] : <NEWLINE> <INDENT> S += 1 <NEWLINE> <DEDENT> elif S != a [ j ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> if c == N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> T = A = 1 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> total = T + A <NEWLINE> x = - ( - total // ( a + t ) ) <NEWLINE> x = max ( x , - ( - T // t ) ) <NEWLINE> x = max ( x , - ( - A // a ) ) <NEWLINE> T = t * x <NEWLINE> A = a * x <NEWLINE> <NL> <DEDENT> print ( T + A ) <NEWLINE>
import sys <NEWLINE> <NL> def biser ( lst , func ) : <NEWLINE> <INDENT> n = len ( lst ) <NEWLINE> nh = n // 2 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> if func ( lst [ 0 ] ) : <NEWLINE> <INDENT> return lst [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> if func ( lst [ nh ] ) : <NEWLINE> <INDENT> return biser ( lst [ nh : ] , func ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return biser ( lst [ : nh ] , func ) <NEWLINE> <NL> <DEDENT> <DEDENT> def mkns ( a , s , m ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> return s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( ( ( s + 1 ) << a ) | s ) & m <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ss = [ 0 ] * ( N + 1 ) <NEWLINE> pm = ( 1 << K ) - 1 <NEWLINE> mask = lambda c : ( 1 << K ) - ( 1 << c ) <NEWLINE> nn = 0 <NEWLINE> def isunnec ( i ) : <NEWLINE> <INDENT> if a [ i ] >= K : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if a [ j ] >= K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ss [ i ] = ( ( ( ss [ i ] + 1 ) << a [ j ] ) | ss [ i ] ) & pm <NEWLINE> <COMMENT> <NL> <DEDENT> if ss [ i ] & mask ( K - a [ i ] ) == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] >= K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ss [ i + 1 ] = ( ( ( ss [ i ] + 1 ) << a [ i ] ) | ss [ i ] ) & pm <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> nn = biser ( list ( range ( N ) ) , isunnec ) + 1 <NEWLINE> <COMMENT> <NL> print ( nn ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> B = [ A [ i ] - A [ i - 1 ] for i in range ( 1 , N ) ] <NEWLINE> ans = 0 <NEWLINE> flag = False <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if B [ i ] != 0 : <NEWLINE> <INDENT> first = B [ i ] <NEWLINE> flag = True <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if first * B [ i ] >= 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> j = i + 1 <NEWLINE> while j <= N - 2 : <NEWLINE> <INDENT> if B [ j ] != 0 : <NEWLINE> <INDENT> first = B [ j ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans + 1 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( m - 1 ) : <NEWLINE> <NL> <INDENT> nl , nr = map ( int , input ( ) . split ( ) ) <NEWLINE> if l < nl : <NEWLINE> <INDENT> l = nl <NEWLINE> <DEDENT> if r > nr : <NEWLINE> <INDENT> r = nr <NEWLINE> <DEDENT> <DEDENT> print ( max ( r - l + 1 , 0 ) ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if a * a * b == x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> import math <NEWLINE> if 2 * x / ( a * b ) >= a : <NEWLINE> <INDENT> ans = a / ( 2 * b - 2 * x / ( a ** 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 2 * x / ( a * b ** 2 ) <NEWLINE> <DEDENT> print ( 90 - math . degrees ( math . atan ( ans ) ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def f ( A , B , n ) : <NEWLINE> <INDENT> judge = B - A <NEWLINE> <NL> if judge % 2 == 0 : <NEWLINE> <INDENT> n += judge // 2 <NEWLINE> return ( n ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if abs ( A - 1 ) < abs ( N - B ) : <NEWLINE> <INDENT> if A == 1 : <NEWLINE> <INDENT> A = A <NEWLINE> B -= 1 <NEWLINE> n += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B -= A - 1 <NEWLINE> n += A - 1 <NEWLINE> A -= A - 1 <NEWLINE> <DEDENT> return f ( A , B , n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if B == N : <NEWLINE> <INDENT> B = B <NEWLINE> A += 1 <NEWLINE> n += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A += abs ( N - B ) <NEWLINE> n += abs ( N - B ) <NEWLINE> B += abs ( N - B ) <NEWLINE> <DEDENT> return f ( A , B , n ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( f ( A , B , 0 ) ) <NEWLINE>
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( x2 - ( y2 - y1 ) , y2 + ( x2 - x1 ) , x1 - ( y2 - y1 ) , y1 + ( x2 - x1 ) ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a - 1 ] . append ( b - 1 ) <NEWLINE> edges [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <NL> <DEDENT> colors = [ 0 ] * n <NEWLINE> def dfs ( v , color ) : <NEWLINE> <INDENT> colors [ v ] = color <NEWLINE> for to in edges [ v ] : <NEWLINE> <INDENT> if colors [ to ] == color : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if colors [ to ] == 0 and ( not dfs ( to , - color ) ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if dfs ( 0 , 1 ) : <NEWLINE> <INDENT> x = colors . count ( 1 ) <NEWLINE> print ( x * ( n - x ) - m ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( n * ( n - 1 ) // 2 - m ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L_list = [ ] <NEWLINE> R_list = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> L_list . append ( A ) <NEWLINE> R_list . append ( B ) <NEWLINE> <NL> <DEDENT> if max ( L_list ) > min ( R_list ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( R_list ) - max ( L_list ) + 1 ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> class BIT : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . size = n <NEWLINE> self . tree = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> <DEDENT> def sum ( self , i ) : <NEWLINE> <COMMENT> <NL> <INDENT> s = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> s += self . tree [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return s <NEWLINE> <COMMENT> <NL> <DEDENT> def add ( self , i , x ) : <NEWLINE> <INDENT> while i <= self . size : <NEWLINE> <INDENT> self . tree [ i ] += x <NEWLINE> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> bit = BIT ( 2001 ) <NEWLINE> count = [ 0 ] * ( 2001 ) <NEWLINE> t = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = a [ i ] <NEWLINE> count [ x ] += 1 <NEWLINE> t . append ( i - bit . sum ( x ) ) <NEWLINE> bit . add ( x , 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 2001 ) : <NEWLINE> <INDENT> count [ i ] += count [ i - 1 ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = k * ( 2 * t [ i ] + ( k - 1 ) % mod * count [ a [ i ] - 1 ] ) // 2 <NEWLINE> ans = ( ans + x ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> def agcd ( l ) : <NEWLINE> <INDENT> a = math . gcd ( l [ 0 ] , l [ 1 ] ) <NEWLINE> for i in range ( 2 , len ( l ) ) : <NEWLINE> <INDENT> a = math . gcd ( a , l [ i ] ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ abs ( i - X ) for i in list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> <NL> print ( agcd ( x ) if 1 < N else x [ 0 ] ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * l ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
MM = input ( ) . split ( ) <NEWLINE> A = int ( MM [ 0 ] ) <NEWLINE> B = int ( MM [ 1 ] ) <NEWLINE> list1 = [ ] <NEWLINE> for i in range ( A ) : <NEWLINE> <INDENT> aa = input ( ) <NEWLINE> if <STRING> * B == aa : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list1 . append ( list ( aa ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( B ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( len ( list1 ) ) : <NEWLINE> <INDENT> if list1 [ j ] [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count == 0 : <NEWLINE> <INDENT> for j in range ( len ( list1 ) ) : <NEWLINE> <NL> <INDENT> list1 [ j ] [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in list1 : <NEWLINE> <INDENT> if <STRING> in i : <NEWLINE> <INDENT> i . remove ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in list1 : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> if j != <STRING> : <NEWLINE> <INDENT> print ( j , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> Nums = [ ] <NEWLINE> now = 1 <COMMENT> <NEWLINE> cnt = 0 <COMMENT> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == str ( now ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Nums . append ( cnt ) <NEWLINE> now = 1 - now <COMMENT> <NEWLINE> cnt = 1 <NEWLINE> <DEDENT> <DEDENT> if cnt != 0 : <NEWLINE> <INDENT> Nums . append ( cnt ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if len ( Nums ) % 2 == 0 : <NEWLINE> <INDENT> Nums . append ( 0 ) <NEWLINE> <NL> <DEDENT> Add = 2 * K + 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> sum = [ 0 ] * ( len ( Nums ) + 1 ) <NEWLINE> for i in range ( len ( Nums ) ) : <NEWLINE> <INDENT> sum [ i + 1 ] = sum [ i ] + Nums [ i ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( 0 , len ( Nums ) , 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> left = i <NEWLINE> right = min ( i + Add , len ( Nums ) ) <NEWLINE> tmp = sum [ right ] - sum [ left ] <NEWLINE> ans = max ( tmp , ans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> abc = [ int ( input ( ) ) for _ in range ( 5 ) ] <NEWLINE> tmp = 9 <NEWLINE> ans = 0 <NEWLINE> ii = 0 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> tmpp = min ( tmp , ( abc [ i ] - 1 ) % 10 ) <NEWLINE> if tmp != tmpp : <NEWLINE> <INDENT> tmp = tmpp <NEWLINE> ii = i <NEWLINE> <DEDENT> <DEDENT> for i in range ( 5 ) : <NEWLINE> <INDENT> if i == ii : <NEWLINE> <INDENT> ans += abc [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ( math . ceil ( abc [ i ] / 10 ) ) * 10 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> A = int ( s [ 0 ] ) <NEWLINE> B = int ( s [ 1 ] ) <NEWLINE> C = int ( s [ 2 ] ) <NEWLINE> D = int ( s [ 3 ] ) <NEWLINE> <NL> flag = [ 0 ] * 3 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> flag [ 0 ] = ( i >> 2 ) & 1 <NEWLINE> flag [ 1 ] = ( i >> 1 ) & 1 <NEWLINE> flag [ 2 ] = ( i ) & 1 <NEWLINE> <NL> tmp = A + ( - 1 ) ** flag [ 0 ] * B + ( - 1 ) ** flag [ 1 ] * C + ( - 1 ) ** flag [ 2 ] * D <NEWLINE> if tmp == 7 : <NEWLINE> <INDENT> ans = s [ 0 ] <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> if flag [ j ] : <NEWLINE> <INDENT> ans += <STRING> + s [ j + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> + s [ j + 1 ] <NEWLINE> <DEDENT> <DEDENT> ans += <STRING> <NEWLINE> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def digit_sum ( n , b ) : <NEWLINE> <INDENT> if b == 1 : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> res = 0 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> res += n % b <NEWLINE> n //= b <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> <NL> ans = - 1 <NEWLINE> if n == s : <NEWLINE> <INDENT> ans = n + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for b in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if digit_sum ( n , b ) == s : <NEWLINE> <INDENT> ans = b <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for p in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> b = ( n - s ) // p + 1 <NEWLINE> if b >= 2 and digit_sum ( n , b ) == s : <NEWLINE> <INDENT> if ans == - 1 : <NEWLINE> <INDENT> ans = b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( ans , b ) <NEWLINE> <NL> <DEDENT> <DEDENT> if b >= 1 and digit_sum ( n , b + 1 ) == s : <NEWLINE> <INDENT> if ans == - 1 : <NEWLINE> <INDENT> ans = b + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( ans , b + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mon = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mon . sort ( reverse = True ) <NEWLINE> <NL> print ( sum ( mon [ k : ] ) ) <NEWLINE>
import sys <NEWLINE> import string <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> s = list ( S ) <NEWLINE> array = string . ascii_uppercase <NEWLINE> <NL> if not ( 0 <= N <= 26 ) : sys . exit ( ) <NEWLINE> if not ( 1 <= len ( s ) <= 10 ** 4 ) : sys . exit ( ) <NEWLINE> if not S . isupper ( ) : sys . exit ( ) <NEWLINE> <NL> for I in s : <NEWLINE> <INDENT> if array . index ( I ) + N <= 25 : <NEWLINE> <INDENT> print ( array [ array . index ( I ) + N ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( array [ ( array . index ( I ) + N ) - 26 ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from functools import lru_cache <NEWLINE> import sys <NEWLINE> <NL> iMaxStackSize = 5000000 <NEWLINE> sys . setrecursionlimit ( iMaxStackSize ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> heights = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> @ lru_cache ( None ) <NEWLINE> def solve ( i ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if i + 2 >= len ( heights ) : <NEWLINE> <INDENT> return abs ( heights [ i + 1 ] - heights [ i ] ) <NEWLINE> <DEDENT> option1 = abs ( heights [ i ] - heights [ i + 1 ] ) <NEWLINE> option1 += solve ( i + 1 ) <NEWLINE> option2 = abs ( heights [ i ] - heights [ i + 2 ] ) <NEWLINE> option2 += solve ( i + 2 ) <NEWLINE> return min ( option1 , option2 ) <NEWLINE> <NL> <DEDENT> print ( solve ( 0 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> d = int ( n / 2 ) <NEWLINE> r = l [ d ] - l [ d - 1 ] <NEWLINE> print ( r ) <NEWLINE>
<COMMENT> <NL> n = input ( ) <NEWLINE> keta = len ( n ) <NEWLINE> c = n [ 0 ] <NEWLINE> ans = int ( c ) + 9 * ( keta - 1 ) <NEWLINE> if n [ 1 : ] != ( <STRING> * ( keta - 1 ) ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( len ( [ 1 for z in range ( k + 1 ) for y in range ( k + 1 ) if 0 <= s - z - y <= k ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_list . sort ( ) <NEWLINE> a_counter = { } <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> for a in a_list : <NEWLINE> <INDENT> if a in a_counter . keys ( ) : <NEWLINE> <INDENT> a_counter [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_counter [ a ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> data_error = False <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( 1 , n , 2 ) : <NEWLINE> <INDENT> if i not in a_counter . keys ( ) : <NEWLINE> <INDENT> data_error = True <NEWLINE> break <NEWLINE> <DEDENT> if a_counter [ i ] != 2 : <NEWLINE> <INDENT> data_error = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , n , 2 ) : <NEWLINE> <INDENT> if i not in a_counter . keys ( ) : <NEWLINE> <INDENT> data_error = True <NEWLINE> <DEDENT> if a_counter [ i ] != 2 : <NEWLINE> <INDENT> if i == 0 and a_counter [ 0 ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> data_error = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if data_error : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 2 ** ( int ( n / 2 ) ) <NEWLINE> ans %= MOD <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> count = [ 0 ] * N <NEWLINE> i = 0 <NEWLINE> <NL> while ( True ) : <NEWLINE> <INDENT> count [ i ] += 1 <NEWLINE> i = a [ i ] - 1 <NEWLINE> if i == 1 : <NEWLINE> <INDENT> print ( sum ( count ) ) <NEWLINE> break <NEWLINE> <DEDENT> if count [ i ] == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> yaku = [ ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> if i in yaku : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if N / i <= i : <NEWLINE> <INDENT> yaku . append ( i ) <NEWLINE> break <NEWLINE> <DEDENT> yaku . append ( i ) <NEWLINE> yaku . append ( N // i ) <NEWLINE> <DEDENT> elif N / i < i : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> yaku . sort ( ) <NEWLINE> ans = str ( yaku [ len ( yaku ) // 2 ] ) <NEWLINE> print ( len ( ans ) ) <NEWLINE>
from collections import Counter <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AD = sorted ( list ( Counter ( A ) . values ( ) ) ) <NEWLINE> print ( sum ( AD [ : len ( AD ) - k ] ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> white = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> s = str ( input ( ) ) <NEWLINE> S . append ( s ) <NEWLINE> white += s . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> def main ( h , w ) : <NEWLINE> <INDENT> global H <NEWLINE> global W <NEWLINE> global S <NEWLINE> global l <NEWLINE> tmp = [ ] <NEWLINE> if h < H - 1 : <NEWLINE> <INDENT> if ( S [ h + 1 ] [ w ] == <STRING> ) and ( [ h + 1 , w ] not in l ) : <NEWLINE> <INDENT> tmp . append ( [ h + 1 , w ] ) <NEWLINE> <DEDENT> <DEDENT> if w < W - 1 : <NEWLINE> <INDENT> if ( S [ h ] [ w + 1 ] == <STRING> ) and ( [ h , w + 1 ] not in l ) : <NEWLINE> <INDENT> tmp . append ( [ h , w + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if 0 < h : <NEWLINE> <INDENT> if ( S [ h - 1 ] [ w ] == <STRING> ) and ( [ h - 1 , w ] not in l ) : <NEWLINE> <INDENT> tmp . append ( [ h - 1 , w ] ) <NEWLINE> <DEDENT> <DEDENT> if 0 < w : <NEWLINE> <INDENT> if ( S [ h ] [ w - 1 ] == <STRING> ) and ( [ h , w - 1 ] not in l ) : <NEWLINE> <INDENT> tmp . append ( [ h , w - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> return tmp <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> l = [ [ 0 , 0 ] ] <NEWLINE> tmp = [ [ 0 , 0 ] ] <NEWLINE> for i in range ( 10000 ) : <NEWLINE> <INDENT> t = [ ] <NEWLINE> for n in tmp : <NEWLINE> <INDENT> u = main ( n [ 0 ] , n [ 1 ] ) <NEWLINE> l += u <NEWLINE> t += u <NEWLINE> <DEDENT> if t == [ ] : <NEWLINE> <INDENT> ans = white + 1 <NEWLINE> <DEDENT> elif [ H - 1 , W - 1 ] in t : <NEWLINE> <INDENT> ans = i + 2 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = t <NEWLINE> <DEDENT> <DEDENT> print ( white - ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] != L : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if N == 1 and A [ 0 ] == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif 1 not in A : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> Pushed = [ False ] * N <NEWLINE> Pushed [ 0 ] = True <NEWLINE> i = 0 <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> i = A [ i ] - 1 <NEWLINE> cnt += 1 <NEWLINE> if Pushed [ i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> Pushed [ i ] = True <NEWLINE> if i == 1 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> if abs ( n - m ) == 0 : <NEWLINE> <INDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> ans = 2 * ( ans ** 2 ) <NEWLINE> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> elif abs ( n - m ) == 1 : <NEWLINE> <INDENT> for i in range ( 1 , min ( n + 1 , m + 1 ) ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> ans = max ( n , m ) * ( ans ** 2 ) <NEWLINE> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> len_s = len ( s ) <NEWLINE> L = [ ] <NEWLINE> m = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( len_s - i + 1 ) : <NEWLINE> <INDENT> if s [ j : j + i ] not in L : <NEWLINE> <INDENT> L . append ( s [ j : j + i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> L . sort ( ) <NEWLINE> print ( L [ k - 1 ] ) <NEWLINE>
from math import factorial <NEWLINE> N = factorial ( int ( input ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> i = 2 <NEWLINE> <NL> while i * i <= N : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> while N % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> N //= i <NEWLINE> <DEDENT> ans *= cnt <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> if N != 1 : <NEWLINE> <INDENT> ans *= 2 <NEWLINE> <DEDENT> print ( int ( ans % mod ) ) <NEWLINE>
import math <NEWLINE> from math import gcd , pi , sqrt <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import itertools <NEWLINE> from collections import Counter , deque <NEWLINE> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> a , b = i_map ( ) <NEWLINE> <NL> def prime_decomposition ( n ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> table = [ ] <NEWLINE> while i * i <= n : <COMMENT> <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> n //= i <NEWLINE> table . append ( i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if n > 1 : <NEWLINE> <INDENT> table . append ( n ) <NEWLINE> <DEDENT> return table <NEWLINE> <NL> <DEDENT> a = set ( prime_decomposition ( a ) ) <NEWLINE> b = set ( prime_decomposition ( b ) ) <NEWLINE> print ( len ( a & b ) + 1 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> S1 = set ( [ ] ) <NEWLINE> S2 = set ( [ ] ) <NEWLINE> S3 = set ( [ ] ) <NEWLINE> for i in S : <NEWLINE> <INDENT> for s3 in S2 : <NEWLINE> <INDENT> S3 . add ( s3 + i ) <NEWLINE> <DEDENT> for s2 in S1 : <NEWLINE> <INDENT> S2 . add ( s2 + i ) <NEWLINE> <DEDENT> S1 . add ( i ) <NEWLINE> <DEDENT> print ( len ( S3 ) ) <NEWLINE>
s = input ( ) <NEWLINE> s = s . split ( <STRING> ) <NEWLINE> N = s [ 0 ] <NEWLINE> K = int ( s [ 1 ] ) <NEWLINE> <NL> s = input ( ) <NEWLINE> s = s . split ( <STRING> ) <NEWLINE> ds = [ int ( digit ) for digit in s ] <NEWLINE> <NL> minNum = min ( [ digit for digit in range ( 0 , 10 ) if digit not in ds ] ) <NEWLINE> nonZerominNum = min ( [ digit for digit in range ( 1 , 10 ) if digit not in ds ] ) <NEWLINE> maxNum = max ( [ digit for digit in range ( 0 , 10 ) if digit not in ds ] ) <NEWLINE> <NL> digits = [ int ( digit ) for digit in N ] <NEWLINE> <NL> result = N <NEWLINE> for index in range ( 0 , len ( digits ) ) : <NEWLINE> <INDENT> digit = digits [ index ] <NEWLINE> if digit in ds : <NEWLINE> <INDENT> i = index <NEWLINE> if digit > maxNum : <NEWLINE> <INDENT> i = index - 1 <NEWLINE> while i >= 0 and digits [ i ] == maxNum : <NEWLINE> <INDENT> i -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if i < 0 : <NEWLINE> <INDENT> result = str ( nonZerominNum ) + ( str ( minNum ) * len ( N ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> biggerDigit = min ( [ d for d in range ( 0 , 10 ) if d not in ds and d > digits [ i ] ] ) <NEWLINE> digits [ i ] = biggerDigit <NEWLINE> for j in range ( i + 1 , len ( digits ) ) : <NEWLINE> <INDENT> digits [ j ] = minNum <NEWLINE> <DEDENT> result = <STRING> . join ( [ str ( digit ) for digit in digits ] ) <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
from bisect import bisect as list_bisect <NEWLINE> max2 = lambda x , y : x if x > y else y <NEWLINE> min2 = lambda x , y : x if x < y else y <NEWLINE> <NL> def bisect ( ng , ok , judge , eps = 1 ) : <NEWLINE> <INDENT> while abs ( ng - ok ) > eps : <NEWLINE> <INDENT> m = ( ng + ok ) // 2 <NEWLINE> if judge ( m ) : <NEWLINE> <INDENT> ok = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = m <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <DEDENT> N , M , V , P = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> k = N - P <NEWLINE> def judge ( i ) : <NEWLINE> <INDENT> if i >= k : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> a = A [ i ] <NEWLINE> if a + M < A [ k ] : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> r = 0 <NEWLINE> for v in A [ i + 1 : k + 1 ] : <NEWLINE> <INDENT> r += a + M - v <NEWLINE> <DEDENT> return r >= ( V - P - i ) * M <NEWLINE> <NL> <DEDENT> i = bisect ( - 1 , N - 1 , judge ) <NEWLINE> print ( N - i ) <NEWLINE>
import bisect , copy <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = copy . copy ( a ) <NEWLINE> ans = [ ] <NEWLINE> num = 1 <NEWLINE> count = 0 <NEWLINE> while num != n : <NEWLINE> <INDENT> if max ( a ) < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while a [ num - 1 ] > a [ num ] : <NEWLINE> <INDENT> a2 = copy . copy ( a ) <NEWLINE> a2 . sort ( ) <NEWLINE> temp = a [ num - 1 ] - a [ num ] <NEWLINE> temp2 = bisect . bisect_left ( a2 , temp ) <NEWLINE> if temp2 == n : <NEWLINE> <INDENT> temp2 -= 1 <NEWLINE> <DEDENT> ans . append ( [ a . index ( a2 [ temp2 ] ) + 1 , num + 1 ] ) <NEWLINE> a [ num ] += a2 [ temp2 ] <NEWLINE> count += 1 <NEWLINE> if count == n * 2 + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> num += 1 <NEWLINE> if count == n * 2 + 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans2 = [ ] <NEWLINE> num = n - 2 <NEWLINE> count2 = 0 <NEWLINE> while num != - 1 : <NEWLINE> <INDENT> if min ( b ) > 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ num ] > b [ num + 1 ] : <NEWLINE> <INDENT> b2 = copy . copy ( b ) <NEWLINE> b2 . sort ( ) <NEWLINE> temp = b [ num + 1 ] - b [ num ] <NEWLINE> temp2 = bisect . bisect_right ( b2 , temp ) <NEWLINE> if temp2 == 0 : <NEWLINE> <INDENT> temp2 += 1 <NEWLINE> <DEDENT> ans2 . append ( [ b . index ( b2 [ temp2 - 1 ] ) + 1 , num + 1 ] ) <NEWLINE> b [ num ] += b2 [ temp2 - 1 ] <NEWLINE> count2 += 1 <NEWLINE> if count2 == n * 2 + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> num -= 1 <NEWLINE> if count2 == n * 2 + 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( ans ) == 0 and len ( ans2 ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif len ( ans ) == 0 : <NEWLINE> <INDENT> print ( len ( ans2 ) ) <NEWLINE> for i in ans2 : <NEWLINE> <INDENT> print ( i [ 0 ] , i [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> elif len ( ans2 ) == 0 : <NEWLINE> <INDENT> print ( len ( ans ) ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i [ 0 ] , i [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if len ( ans ) > len ( ans2 ) : <NEWLINE> <INDENT> print ( len ( ans2 ) ) <NEWLINE> for i in ans2 : <NEWLINE> <INDENT> print ( i [ 0 ] , i [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( ans ) ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i [ 0 ] , i [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import collections <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( <STRING> ) ] <NEWLINE> CA = collections . Counter ( A ) <NEWLINE> minA = min ( A ) <NEWLINE> maxA = max ( A ) <NEWLINE> X = [ CA [ i ] for i in range ( minA , maxA + 1 ) ] <NEWLINE> if len ( X ) == 1 : <NEWLINE> <INDENT> print ( X [ 0 ] ) <NEWLINE> return 0 <NEWLINE> <DEDENT> if len ( X ) == 2 : <NEWLINE> <INDENT> print ( X [ 0 ] + X [ 1 ] ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> Y = [ X [ j ] + X [ j + 1 ] + X [ j + 2 ] for j in range ( len ( X ) - 2 ) ] <NEWLINE> print ( max ( Y ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from heapq import heappop , heappush <NEWLINE> from math import sqrt <NEWLINE> def distf ( xyr , i , j ) : <NEWLINE> <INDENT> x , y , r = xyr [ i ] <NEWLINE> x1 , y1 , r1 = xyr [ j ] <NEWLINE> d = max ( 0 , sqrt ( ( x - x1 ) ** 2 + ( y - y1 ) ** 2 ) - r - r1 ) <NEWLINE> return d <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> xs , ys , xt , yt = map ( int , input ( ) . split ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> xyr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> xyr . append ( [ xs , ys , 0 ] ) <NEWLINE> xyr . append ( [ xt , yt , 0 ] ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> dist = [ [ inf ] * ( n + 2 ) for _ in range ( n + 2 ) ] <NEWLINE> for i in range ( n + 2 ) : <NEWLINE> <INDENT> dist [ i ] [ i ] = 0 <NEWLINE> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 2 ) : <NEWLINE> <INDENT> dist [ i ] [ j ] = distf ( xyr , i , j ) <NEWLINE> dist [ j ] [ i ] = dist [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> seen = [ inf ] * ( n + 2 ) <NEWLINE> seen [ n ] = 0 <NEWLINE> mi = set ( range ( n + 2 ) ) <NEWLINE> while mi : <NEWLINE> <INDENT> d , v = inf , - 1 <NEWLINE> for j in mi : <NEWLINE> <INDENT> if d > seen [ j ] : <NEWLINE> <INDENT> d = seen [ j ] <NEWLINE> v = j <NEWLINE> <DEDENT> <DEDENT> mi . remove ( v ) <NEWLINE> for nv in mi : <NEWLINE> <INDENT> nd = dist [ v ] [ nv ] <NEWLINE> if seen [ nv ] > seen [ v ] + nd : <NEWLINE> <INDENT> seen [ nv ] = seen [ v ] + nd <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( seen [ n + 1 ] ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - x - y <= k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> n = input ( ) <NEWLINE> m = [ 0 ] * a <NEWLINE> for i in range ( 1 , a ) : <NEWLINE> <INDENT> if n [ i - 1 : i + 1 ] == <STRING> : <NEWLINE> <INDENT> m [ i ] = m [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m [ i ] = m [ i - 1 ] <NEWLINE> <DEDENT> <DEDENT> for j in range ( b ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( m [ t - 1 ] - m [ s - 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> S = <STRING> + S + <STRING> <NEWLINE> ans = 0 <NEWLINE> E = 0 <NEWLINE> W = S . count ( <STRING> ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if S [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> E += 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> W -= 1 <NEWLINE> <DEDENT> tmp = E + W <NEWLINE> if tmp > ans : <NEWLINE> <INDENT> ans = tmp <NEWLINE> <DEDENT> <DEDENT> ans = N - 1 - ans <NEWLINE> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> d = [ [ ] for i in range ( 26 ) ] <NEWLINE> for i , c in enumerate ( S ) : <NEWLINE> <INDENT> d [ ord ( c ) - ord ( <STRING> ) ] . append ( i ) <NEWLINE> <DEDENT> d2 = [ [ ] for i in range ( 26 ) ] <NEWLINE> for i , c in enumerate ( T ) : <NEWLINE> <INDENT> d2 [ ord ( c ) - ord ( <STRING> ) ] . append ( i ) <NEWLINE> <DEDENT> print ( [ <STRING> , <STRING> ] [ set ( ( tuple ( x ) for x in d ) ) == set ( ( tuple ( x ) for x in d2 ) ) ] ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( A , min ( A + K , B + 1 ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( max ( A + K , B - K + 1 ) , B + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> e = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> e [ a ] . append ( b ) <NEWLINE> e [ b ] . append ( a ) <NEWLINE> <DEDENT> qv = int ( input ( ) ) <NEWLINE> Q = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( qv ) ] <NEWLINE> <NL> color = [ 0 ] * ( n + 1 ) <NEWLINE> used = [ - 1 ] * ( n + 1 ) <NEWLINE> <NL> for v , d , c in Q [ : : - 1 ] : <NEWLINE> <INDENT> if used [ v ] > d : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> q = deque ( [ [ v , d ] ] ) <NEWLINE> while q : <NEWLINE> <INDENT> now , dis = q . popleft ( ) <NEWLINE> if dis < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if color [ now ] == 0 : <NEWLINE> <INDENT> color [ now ] = c <NEWLINE> <DEDENT> for nex in e [ now ] : <NEWLINE> <INDENT> if used [ nex ] < dis - 1 : <NEWLINE> <INDENT> used [ nex ] = dis - 1 <NEWLINE> q . append ( [ nex , dis - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in color [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> M = 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if i ** 2 <= N : <NEWLINE> <INDENT> M = max ( M , i ** 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( M ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> es = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> u , v , w = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> es [ u - 1 ] . append ( [ v , w ] ) <NEWLINE> es [ v - 1 ] . append ( [ u , w ] ) <NEWLINE> <NL> <DEDENT> colors = [ 0 for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> def dfs ( v , color ) : <NEWLINE> <INDENT> colors [ v - 1 ] = color <NEWLINE> for i in es [ v - 1 ] : <NEWLINE> <INDENT> if i [ 1 ] % 2 == 0 and colors [ i [ 0 ] - 1 ] == 0 : <NEWLINE> <INDENT> dfs ( i [ 0 ] , color ) <NEWLINE> <DEDENT> elif i [ 1 ] % 2 == 1 and colors [ i [ 0 ] - 1 ] == 0 : <NEWLINE> <INDENT> dfs ( i [ 0 ] , ( - 1 ) * color ) <NEWLINE> <DEDENT> <DEDENT> return colors <NEWLINE> <NL> <NL> <DEDENT> a = dfs ( 1 , - 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main2 ( ) : <NEWLINE> <INDENT> numbers = [ ] <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> numbers = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> dp = [ 0 ] * n <NEWLINE> for number in numbers : <NEWLINE> <INDENT> for n in number : <NEWLINE> <INDENT> dp [ n - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for ans in dp : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> numbers = [ ] <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> numbers = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> dp = { } <NEWLINE> for number in numbers : <NEWLINE> <INDENT> for n in number : <NEWLINE> <INDENT> if n not in dp : <NEWLINE> <INDENT> dp [ n ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ n ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp ) <NEWLINE> for i in range ( 1 , len ( dp ) + 1 ) : <NEWLINE> <INDENT> print ( dp [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main2 ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> input = sys . stdin . readline <NEWLINE> a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + b <= k : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a < k : <NEWLINE> <INDENT> b = b - ( k - a ) <NEWLINE> a = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = a - k <NEWLINE> <DEDENT> print ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def LI ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> X , Y = LI ( ) <NEWLINE> a = 10 ** 18 // X <NEWLINE> if X == Y : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> elif X % Y == 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 2 , a + 1 ) : <NEWLINE> <INDENT> if X * i % Y == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans = X * i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = p [ 0 ] <NEWLINE> count = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if m >= p [ i ] : <NEWLINE> <INDENT> m = p [ i ] <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 6500 ) <NEWLINE> <NL> def find ( n ) : <NEWLINE> <INDENT> if d [ n ] < 0 : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ n ] = find ( d [ n ] ) <NEWLINE> return d [ n ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( a , b ) : <NEWLINE> <INDENT> a = find ( a ) <NEWLINE> b = find ( b ) <NEWLINE> if a == b : return False <NEWLINE> if d [ a ] <= d [ b ] : <NEWLINE> <INDENT> d [ a ] += d [ b ] <NEWLINE> d [ b ] = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ b ] += d [ a ] <NEWLINE> d [ a ] = b <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def members ( n ) : <NEWLINE> <INDENT> p = find ( n ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if find ( i ) == p : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def same ( a , b ) : <NEWLINE> <INDENT> if find ( a ) == find ( b ) : return True <NEWLINE> else : return False <NEWLINE> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = [ - 1 ] * N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x , y = x - 1 , y - 1 <NEWLINE> union ( x , y ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if same ( i , p [ i ] - 1 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> n = len ( s ) <NEWLINE> l = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] and l [ i ] == 0 : <NEWLINE> <INDENT> l [ i + 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if s . count ( s [ 0 ] ) == n : <NEWLINE> <INDENT> print ( n * k // 2 ) <NEWLINE> <DEDENT> elif s [ 0 ] != s [ - 1 ] : <NEWLINE> <INDENT> print ( sum ( l ) * k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> b = 0 <NEWLINE> ac = True <NEWLINE> bc = True <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ 0 ] and ac == True : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif s [ i ] != s [ 0 ] : <NEWLINE> <INDENT> ac = False <NEWLINE> <DEDENT> if s [ n - 1 - i ] == s [ n - 1 ] and bc == True : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> else : bc = False <NEWLINE> <DEDENT> sub = a // 2 + b // 2 - ( a + b ) // 2 <NEWLINE> print ( sum ( l ) * k - sub * ( k - 1 ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import bisect <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> in_n = lambda : int ( readline ( ) ) <NEWLINE> in_nn = lambda : map ( int , readline ( ) . split ( ) ) <NEWLINE> in_s = lambda : readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> in_nl = lambda : list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> in_nl2 = lambda H : [ in_nl ( ) for _ in range ( H ) ] <NEWLINE> in_map = lambda : [ s == ord ( <STRING> ) for s in readline ( ) if s != ord ( <STRING> ) ] <NEWLINE> in_map2 = lambda H : [ in_map ( ) for _ in range ( H ) ] <NEWLINE> in_all = lambda : map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> <NL> class Bit : <NEWLINE> <NL> <INDENT> def __init__ ( self , a ) : <NEWLINE> <INDENT> if hasattr ( a , <STRING> ) : <NEWLINE> <INDENT> le = len ( a ) <NEWLINE> self . n = 1 << le . bit_length ( ) <COMMENT> <NEWLINE> self . values = values = [ 0 ] * ( self . n + 1 ) <NEWLINE> values [ 1 : le + 1 ] = a [ : ] <NEWLINE> for i in range ( 1 , self . n ) : <NEWLINE> <INDENT> values [ i + ( i & - i ) ] += values [ i ] <NEWLINE> <DEDENT> <DEDENT> elif isinstance ( a , int ) : <NEWLINE> <INDENT> self . n = 1 << a . bit_length ( ) <NEWLINE> self . values = [ 0 ] * ( self . n + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise TypeError <NEWLINE> <NL> <DEDENT> <DEDENT> def add ( self , i , val ) : <NEWLINE> <INDENT> n , values = self . n , self . values <NEWLINE> while i <= n : <NEWLINE> <INDENT> values [ i ] += val <NEWLINE> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> def sum ( self , i ) : <COMMENT> <NEWLINE> <INDENT> values = self . values <NEWLINE> res = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> res += values [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def bisect_left ( self , v ) : <COMMENT> <NEWLINE> <INDENT> n , values = self . n , self . values <NEWLINE> if v > values [ n ] : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> i , step = 0 , n >> 1 <NEWLINE> while step : <NEWLINE> <INDENT> if values [ i + step ] < v : <NEWLINE> <INDENT> i += step <NEWLINE> v -= values [ i ] <NEWLINE> <DEDENT> step >>= 1 <NEWLINE> <DEDENT> return i + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> N , D , A = in_nn ( ) <NEWLINE> XH = sorted ( in_nl2 ( N ) ) <NEWLINE> X = [ 0 ] * N <NEWLINE> H = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x , h = XH [ i ] <NEWLINE> X [ i ] = x <NEWLINE> H [ i ] = h <NEWLINE> <NL> <DEDENT> bit = Bit ( N ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <NL> <INDENT> x , h = X [ i ] , H [ i ] <NEWLINE> j = bisect . bisect_right ( X , x + 2 * D ) <NEWLINE> cnt_bomb = bit . sum ( i + 1 ) <NEWLINE> <NL> h -= A * cnt_bomb <NEWLINE> if h <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> cnt = - ( - h // A ) <NEWLINE> ans += cnt <NEWLINE> bit . add ( i + 1 , cnt ) <NEWLINE> bit . add ( j + 1 , - cnt ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> from itertools import accumulate <NEWLINE> h , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ 0 ] * ( h * w + 1 ) <NEWLINE> b = [ 0 ] * ( h * w + 1 ) <NEWLINE> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> l = map ( int , input ( ) . split ( ) ) <NEWLINE> for j , k in enumerate ( l , 1 ) : <NEWLINE> <INDENT> a [ k ] = i <NEWLINE> b [ k ] = j <NEWLINE> <NL> <DEDENT> <DEDENT> c = [ 0 ] * ( h * w + 1 ) <NEWLINE> for i in range ( d + 1 , h * w + 1 ) : <NEWLINE> <INDENT> c [ i ] = c [ i - d ] + abs ( a [ i ] - a [ i - d ] ) + abs ( b [ i ] - b [ i - d ] ) <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> res = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> res . append ( c [ r ] - c [ l ] ) <NEWLINE> <NL> <DEDENT> ans = <STRING> . join ( map ( str , res ) ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> e = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> e . append ( p [ i ] + 1 ) <NEWLINE> <NL> <DEDENT> sum_e = [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> sum_e . append ( sum_e [ i - 1 ] + e [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> <NL> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans . append ( sum_e [ i + k ] - sum_e [ i ] ) <NEWLINE> <NL> <DEDENT> print ( max ( ans ) / 2 ) <NEWLINE>
H = int ( input ( ) ) <NEWLINE> <NL> if H == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> import math as m <NEWLINE> n = m . floor ( m . log2 ( H ) ) + 1 <NEWLINE> ans = ( 2 ** n ) - 1 <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL>
from collections import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> for i in l : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if d [ l [ i ] ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x = 2 ** ( l [ i ] . bit_length ( ) ) <NEWLINE> y = x - l [ i ] <NEWLINE> if y == l [ i ] : <NEWLINE> <INDENT> if d [ y ] >= 2 : <NEWLINE> <INDENT> d [ y ] -= 2 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if d [ y ] > 0 : <NEWLINE> <INDENT> d [ y ] -= 1 <NEWLINE> d [ l [ i ] ] -= 1 <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> H , W , D = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> num = { } <NEWLINE> for j in range ( H ) : <NEWLINE> <INDENT> tmp = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> for i , n in enumerate ( tmp ) : <NEWLINE> <INDENT> num [ n ] = ( i , j ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> S = [ 0 for _ in range ( H * W + D ) ] <NEWLINE> for i in range ( D + 1 , H * W + 1 ) : <NEWLINE> <INDENT> x , y = num [ i ] <NEWLINE> a , b = num [ i - D ] <NEWLINE> S [ i ] = S [ i - D ] + abs ( x - a ) + abs ( y - b ) <NEWLINE> <COMMENT> <NL> <DEDENT> Q = int ( sys . stdin . readline ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> L , R = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> r = L % D <NEWLINE> print ( S [ R ] - S [ L ] ) <NEWLINE> <DEDENT>
<NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> class BIT : <NEWLINE> <NL> <INDENT> def __init__ ( self , size ) : <NEWLINE> <INDENT> self . N = size <NEWLINE> self . bit = [ 0 ] * ( self . N + 1 ) <NEWLINE> <NL> <DEDENT> def getSum ( self , i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while 0 < i : <NEWLINE> <INDENT> s += self . bit [ i ] <NEWLINE> i -= i & - i <NEWLINE> <NL> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def getMax ( self , i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while 0 < i : <NEWLINE> <INDENT> s = max ( s , self . bit [ i ] ) <NEWLINE> i -= i & - i <NEWLINE> <NL> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def add ( self , i , val ) : <NEWLINE> <INDENT> while i <= self . N : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> self . bit [ i ] = max ( self . bit [ i ] , val ) <NEWLINE> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def LongestIncreaseSeaquence ( H , A ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> N = len ( H ) <NEWLINE> <COMMENT> <NL> lis = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> tree = BIT ( N ) <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> tree . add ( H [ n ] , tree . getMax ( H [ n ] ) + A [ n ] ) <NEWLINE> <NL> <DEDENT> lis = tree . getMax ( N ) <NEWLINE> <NL> return lis <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> print ( LongestIncreaseSeaquence ( H , A ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> num = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> k = S - i - j <NEWLINE> if 0 <= k <= K : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a_ = int ( input ( ) ) <NEWLINE> a . add ( a_ ) <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( n + 1 ) <NEWLINE> if 1 not in a : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> if 2 not in a and n != 1 : <NEWLINE> <INDENT> dp [ 2 ] = dp [ 1 ] + 1 <NEWLINE> <DEDENT> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i not in a : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ n ] % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ i + 1 ] = b [ i ] + a [ i ] <NEWLINE> <DEDENT> x = [ [ 0 , 0 ] for _ in range ( n - 3 ) ] <NEWLINE> j = 1 <NEWLINE> for i in range ( 2 , n - 1 ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if i == j + 1 : <NEWLINE> <INDENT> x [ i - 2 ] [ 0 ] = b [ j ] <NEWLINE> break <NEWLINE> <DEDENT> if abs ( b [ i ] - 2 * b [ j ] ) > abs ( b [ i ] - 2 * b [ j + 1 ] ) : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x [ i - 2 ] [ 0 ] = b [ j ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> j = n - 1 <NEWLINE> for i in range ( n - 2 , 1 , - 1 ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if i == j - 1 : <NEWLINE> <INDENT> x [ i - 2 ] [ 1 ] = b [ j ] <NEWLINE> break <NEWLINE> <DEDENT> if abs ( b [ n ] + b [ i ] - 2 * b [ j ] ) > abs ( b [ n ] + b [ i ] - 2 * b [ j - 1 ] ) : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x [ i - 2 ] [ 1 ] = b [ j ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 1145141919810 <NEWLINE> for i in range ( n - 3 ) : <NEWLINE> <INDENT> s = [ x [ i ] [ 0 ] , b [ i + 2 ] - x [ i ] [ 0 ] , x [ i ] [ 1 ] - b [ i + 2 ] , b [ n ] - x [ i ] [ 1 ] ] <NEWLINE> ans = min ( ans , max ( s ) - min ( s ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from math import sqrt <NEWLINE> from math import floor <NEWLINE> n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ p ] <NEWLINE> for i in range ( 2 , floor ( sqrt ( p ) ) + 1 ) : <NEWLINE> <INDENT> if p % i == 0 : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> l . append ( p // i ) <NEWLINE> <DEDENT> <DEDENT> l . sort ( ) <NEWLINE> s = [ 1 ] <NEWLINE> i = 0 <NEWLINE> while p > 1 : <NEWLINE> <INDENT> if p % l [ i ] == 0 : <NEWLINE> <INDENT> s . append ( l [ i ] ) <NEWLINE> p = p // l [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 1 <NEWLINE> x = s [ 0 ] <NEWLINE> y = 1 <NEWLINE> for i in s [ 1 : ] : <NEWLINE> <INDENT> if x == i : <NEWLINE> <INDENT> y += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while y >= n : <NEWLINE> <INDENT> ans *= x <NEWLINE> y -= n <NEWLINE> <DEDENT> x = i <NEWLINE> y = 1 <NEWLINE> <DEDENT> <DEDENT> while y >= n : <NEWLINE> <INDENT> ans *= x <NEWLINE> y -= n <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> a = 1 <NEWLINE> b = n - k + 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans = a * b % mod <NEWLINE> print ( ans ) <NEWLINE> a = a * ( k - 1 - i ) // ( i + 1 ) <NEWLINE> b = b * ( n - k - i ) // ( i + 2 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> answer = N * ( N - 1 ) // 2 <NEWLINE> <NL> print ( int ( answer ) ) <NEWLINE>
import sys <NEWLINE> from itertools import combinations <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> h , w , n = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ 0 ] * n <NEWLINE> mod = 10 ** 9 <NEWLINE> judge = dict ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( - 1 , 2 ) : <NEWLINE> <INDENT> for j in range ( - 1 , 2 ) : <NEWLINE> <INDENT> if a + i <= 1 or a + i >= h or b + j <= 1 or b + j >= w : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( a + i , b + j ) in judge : <NEWLINE> <INDENT> judge [ ( a + i , b + j ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> judge [ ( a + i , b + j ) ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = [ 0 ] * 10 <NEWLINE> <NL> for v in judge . values ( ) : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> ans [ 0 ] = ( h - 2 ) * ( w - 2 ) - sum ( ans [ 1 : ] ) <NEWLINE> <NL> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> <NL> def mapt ( fn , * args ) : <NEWLINE> <INDENT> return tuple ( map ( fn , * args ) ) <NEWLINE> <NL> <NL> <DEDENT> def Input ( ) : <NEWLINE> <INDENT> return mapt ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> a = sorted ( [ <STRING> . join ( sorted ( input ( ) ) ) for _ in range ( k ) ] ) <NEWLINE> d = Counter ( a ) <NEWLINE> return int ( sum ( val * ( val - 1 ) / 2 for val in d . values ( ) ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] == i + 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if i != n - 1 : <NEWLINE> <INDENT> p [ i ] , p [ i + 1 ] = p [ i + 1 ] , p [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> mi = n + 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> mi = min ( mi , p [ i ] ) <NEWLINE> <NL> if p [ i ] == mi : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> alist = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> import copy <NEWLINE> alist_copy = copy . copy ( alist ) <NEWLINE> <NL> alist_copy . sort ( ) <NEWLINE> max_value = alist_copy [ - 1 ] <NEWLINE> next_value = alist_copy [ - 2 ] <NEWLINE> for a in alist : <NEWLINE> <INDENT> if a == max_value : <NEWLINE> <INDENT> print ( next_value ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max_value ) <NEWLINE> <DEDENT> <DEDENT>
S = list ( input ( ) ) <NEWLINE> L = len ( S ) <NEWLINE> <NL> if L != 26 : <NEWLINE> <COMMENT> <NL> <INDENT> USED = [ False ] * 26 <NEWLINE> for s in S : <NEWLINE> <INDENT> USED [ ord ( s ) - 97 ] = True <NEWLINE> <NL> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> if not USED [ i ] : <NEWLINE> <INDENT> S . append ( chr ( 97 + i ) ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( S ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> prev = - 1 <NEWLINE> k = - 1 <NEWLINE> USED = [ ] <NEWLINE> for i in range ( 26 ) [ : : - 1 ] : <NEWLINE> <INDENT> d = ord ( S [ i ] ) - 97 <NEWLINE> if prev < d : <NEWLINE> <INDENT> prev = d <NEWLINE> USED . append ( S [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if k == - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nxt = min ( [ s for s in USED if s > S [ k ] ] ) <NEWLINE> S = S [ : k ] + [ nxt ] <NEWLINE> print ( <STRING> . join ( S ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = [ - 1 ] <NEWLINE> P += list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> mini = 10 ** 9 <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if P [ i ] <= mini : <NEWLINE> <INDENT> mini = P [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 500 * 500 ) <NEWLINE> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> edges = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N - 1 ) ] <NEWLINE> tree = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> <NL> for edge in edges : <NEWLINE> <INDENT> tree [ edge [ 0 ] ] . append ( [ edge [ 1 ] , edge [ 2 ] ] ) <NEWLINE> tree [ edge [ 1 ] ] . append ( [ edge [ 0 ] , edge [ 2 ] ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> depth = [ - 1 ] * ( N + 1 ) <NEWLINE> depth [ 1 ] = 0 <NEWLINE> <NL> def dfs ( tree , s ) : <NEWLINE> <INDENT> for l in tree [ s ] : <NEWLINE> <INDENT> if depth [ l [ 0 ] ] == - 1 : <NEWLINE> <INDENT> depth [ l [ 0 ] ] = depth [ s ] + l [ 1 ] <NEWLINE> dfs ( tree , l [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( tree , 1 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> for l in depth [ 1 : ] : <NEWLINE> <INDENT> if l % 2 == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> TNow , ANow = ( int ( T ) for T in input ( ) . split ( ) ) <NEWLINE> for TN in range ( 1 , N ) : <NEWLINE> <INDENT> TNext , ANext = ( int ( T ) for T in input ( ) . split ( ) ) <NEWLINE> Magn = max ( TNow // TNext + ( TNow % TNext != 0 ) , ANow // ANext + ( ANow % ANext != 0 ) ) <NEWLINE> TNow , ANow = TNext * Magn , ANext * Magn <NEWLINE> <DEDENT> print ( TNow + ANow ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , M = LI ( ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = LI_ ( ) <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] <NEWLINE> visited = [ False ] * N <NEWLINE> def dfs ( c , depth ) : <NEWLINE> <INDENT> visited [ c ] = True <NEWLINE> if depth == N - 1 : <NEWLINE> <INDENT> ans [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for n in G [ c ] : <NEWLINE> <INDENT> if not visited [ n ] : <NEWLINE> <INDENT> dfs ( n , depth + 1 ) <NEWLINE> visited [ n ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , 0 ) <NEWLINE> <NL> print ( ans [ 0 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
M = int ( input ( ) ) <NEWLINE> k , g = 0 , 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> d , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k += c <NEWLINE> g += c * d <NEWLINE> <DEDENT> print ( ( g - 1 ) // 9 + ( k - 1 ) ) <NEWLINE>
N , T = map ( int , ( list ( input ( ) . split ( ) ) ) ) <NEWLINE> cost = 1001 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> c , t = map ( int , ( list ( input ( ) . split ( ) ) ) ) <NEWLINE> if t <= T : <NEWLINE> <INDENT> cost = min ( cost , c ) <NEWLINE> <DEDENT> <DEDENT> if cost == 1001 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cost ) <NEWLINE> <NL> <DEDENT>
s = str ( input ( ) ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> def leftmore ( ln ) : <NEWLINE> <INDENT> ret = [ 0 ] <NEWLINE> cur = 0 <NEWLINE> for c in ln : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> cur += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cur = 0 <NEWLINE> <NL> <DEDENT> ret . append ( cur ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def rightless ( ln ) : <NEWLINE> <INDENT> revl = reversed ( ln ) <NEWLINE> ret = [ 0 ] <NEWLINE> cur = 0 <NEWLINE> for c in revl : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> cur += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cur = 0 <NEWLINE> <DEDENT> ret . append ( cur ) <NEWLINE> <DEDENT> return list ( reversed ( ret ) ) <NEWLINE> <NL> <DEDENT> lm = leftmore ( s ) <NEWLINE> rl = rightless ( s ) <NEWLINE> for i in range ( len ( s ) + 1 ) : <NEWLINE> <INDENT> ans += max ( lm [ i ] , rl [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> kai = [ 0 ] <NEWLINE> for i in range ( 1 , 1001 ) : <NEWLINE> <INDENT> kai . append ( kai [ i - 1 ] + i ) <NEWLINE> <DEDENT> ka = [ 0 ] + [ kai [ i ] / i for i in range ( 1 , len ( kai ) ) ] <NEWLINE> lis = [ ka [ i ] for i in li ] <NEWLINE> <NL> ans = sum ( lis [ : k ] ) <NEWLINE> mx = ans <NEWLINE> for i in range ( len ( li ) - k ) : <NEWLINE> <INDENT> ans -= lis [ i ] <NEWLINE> ans += lis [ i + k ] <NEWLINE> mx = max ( ans , mx ) <NEWLINE> <DEDENT> print ( mx ) <NEWLINE>
s = input ( ) <NEWLINE> p = int ( s ) <NEWLINE> <NL> x = 1 <NEWLINE> <NL> numbers = [ ] <NEWLINE> <NL> while ( x <= p ) : <NEWLINE> <INDENT> x *= 2 <NEWLINE> numbers . append ( x ) <NEWLINE> <NL> <DEDENT> if p == 1 : <NEWLINE> <INDENT> answer = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = numbers . pop ( ) <NEWLINE> answer = numbers . pop ( ) <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> s = 1 <NEWLINE> ans = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> s *= i <NEWLINE> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> k = 1 <NEWLINE> while s % i == 0 : <NEWLINE> <INDENT> s = s // i <NEWLINE> k += 1 <NEWLINE> <DEDENT> ans *= k <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> num = ord ( s [ i ] ) + n <NEWLINE> if num > 90 : <NEWLINE> <INDENT> num -= 26 <NEWLINE> <DEDENT> ans . append ( chr ( num ) ) <NEWLINE> <DEDENT> ans = <STRING> . join ( ans ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import math <NEWLINE> def is_prime ( n ) : <NEWLINE> <INDENT> if n == 1 : return False <NEWLINE> for k in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % k == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> data = [ 0 ] * 10 ** 5 <NEWLINE> <COMMENT> <NL> for i in range ( 1 , 10 ** 5 + 1 ) : <NEWLINE> <INDENT> if is_prime ( i ) and is_prime ( ( i + 1 ) // 2 ) : <NEWLINE> <INDENT> data [ i - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cumulative_sum = [ 0 ] * 10 ** 5 <NEWLINE> cumulative_sum [ 0 ] = data [ 0 ] <NEWLINE> for i in range ( 10 ** 5 - 1 ) : <NEWLINE> <INDENT> cumulative_sum [ i + 1 ] += cumulative_sum [ i ] + data [ i + 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> cumulative_sum = [ 0 ] + cumulative_sum <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( cumulative_sum [ r ] - cumulative_sum [ l - 1 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT>
import sys , math , collections , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = input ( ) . rstrip ( ) <NEWLINE> <NL> ori_num = 0 <NEWLINE> turn_num = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> if S [ i - 1 ] == <STRING> and S [ i ] == <STRING> : <NEWLINE> <INDENT> ori_num += 1 <NEWLINE> <DEDENT> if S [ i - 1 ] != S [ i ] : <NEWLINE> <INDENT> turn_num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if i < N - 1 : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ori_num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if turn_num >= 2 * K : <NEWLINE> <INDENT> ori_num += 2 * K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = turn_num // 2 <NEWLINE> num2 = turn_num % 2 <NEWLINE> ori_num += 2 * num + num2 <NEWLINE> <NL> <DEDENT> print ( ori_num ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> X , Y , C = [ ] , [ ] , [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , y , c = input ( ) . split ( ) <NEWLINE> X . append ( int ( x ) % ( 2 * k ) ) <NEWLINE> Y . append ( int ( y ) % ( 2 * k ) ) <NEWLINE> C . append ( c == <STRING> ) <NEWLINE> <DEDENT> G = [ [ 0 ] * k for _ in range ( k ) ] <NEWLINE> cnt = 0 <NEWLINE> for x , y , c in zip ( X , Y , C ) : <NEWLINE> <INDENT> if ( x >= k and y < k ) or ( x < k and y >= k ) : <NEWLINE> <INDENT> x += k <NEWLINE> c ^= 1 <NEWLINE> <DEDENT> x %= k <NEWLINE> y %= k <NEWLINE> G [ x ] [ y ] += ( - 1 ) ** c <NEWLINE> cnt += c <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> for j in range ( k - 1 ) : <NEWLINE> <INDENT> G [ i ] [ j + 1 ] += G [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> for j in range ( k ) : <NEWLINE> <INDENT> for i in range ( k - 1 ) : <NEWLINE> <INDENT> G [ i + 1 ] [ j ] += G [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> temp = G [ k - 1 ] [ k - 1 ] - G [ i ] [ k - 1 ] - G [ k - 1 ] [ j ] + G [ i ] [ j ] * 2 + cnt <NEWLINE> ans = max ( ans , temp , n - temp ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , D , E , F = ( int ( T ) for T in input ( ) . split ( ) ) <NEWLINE> SugM = 0 <NEWLINE> WatM = 100 * A <NEWLINE> for TA in range ( 0 , ( F // 100 ) + 1 ) : <NEWLINE> <INDENT> for TB in range ( 0 , ( F // 100 ) + 1 ) : <NEWLINE> <INDENT> if TA == TB == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Water = TA * 100 * A + TB * 100 * B <NEWLINE> RestW = F - Water <NEWLINE> if RestW >= 0 : <NEWLINE> <INDENT> for TC in range ( 0 , RestW + 1 ) : <NEWLINE> <INDENT> for TD in range ( 0 , RestW + 1 ) : <NEWLINE> <INDENT> Suger = TC * C + TD * D <NEWLINE> RestS = RestW - Suger <NEWLINE> if RestS >= 0 and Water >= ( 100 * Suger ) / E : <NEWLINE> <INDENT> if Suger / ( Suger + Water ) > SugM / ( SugM + WatM ) : <NEWLINE> <INDENT> SugM = Suger <NEWLINE> WatM = Water <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . format ( WatM + SugM , SugM ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 1 <NEWLINE> ans = 0 <NEWLINE> if b == 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 21 ) : <NEWLINE> <INDENT> c = c - 1 + a <NEWLINE> if c >= b : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = sorted ( list ( set ( input ( ) ) ) ) <NEWLINE> <NL> alphabet = list ( <STRING> ) <NEWLINE> <NL> for i in range ( len ( alphabet ) ) : <NEWLINE> <INDENT> if alphabet [ i ] not in S : <NEWLINE> <INDENT> print ( alphabet [ i ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> from itertools import accumulate , islice <NEWLINE> from bisect import bisect_left <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> xs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ys = list ( accumulate ( xs ) ) <NEWLINE> zs , total = ys [ : - 1 ] , ys [ - 1 ] <NEWLINE> <NL> res = max ( xs ) - min ( xs ) <NEWLINE> for i , z in islice ( enumerate ( zs ) , 1 , n - 1 ) : <NEWLINE> <INDENT> j = bisect_left ( zs , z // 2 ) <NEWLINE> splits = ( ( zs [ j + k ] , z - zs [ j + k ] ) for k in ( - 1 , 0 , 1 ) if 0 <= j + k <= i ) <NEWLINE> a , b = min ( splits , key = lambda s : abs ( s [ 0 ] - s [ 1 ] ) ) <NEWLINE> <NL> j = bisect_left ( zs , ( total - z ) // 2 + z ) <NEWLINE> splits = ( ( zs [ j + k ] - z , total - zs [ j + k ] ) <NEWLINE> <INDENT> for k in ( - 1 , 0 , 1 ) if i <= j + k <= n - 2 ) <NEWLINE> <DEDENT> c , d = min ( splits , key = lambda s : abs ( s [ 0 ] - s [ 1 ] ) ) <NEWLINE> <NL> minn , _ , _ , maxx = sorted ( ( a , b , c , d ) ) <NEWLINE> if maxx - minn < res : <NEWLINE> <INDENT> res = maxx - minn <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ ] <NEWLINE> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> x . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( x [ - k ] ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> X , Y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if ( X + Y ) % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( ( 2 * X - Y ) // 3 ) <NEWLINE> m = int ( ( 2 * Y - X ) // 3 ) <NEWLINE> <NL> if n < 0 or m < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> def comb ( n , k ) : <NEWLINE> <INDENT> c = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> c *= n - i <NEWLINE> c %= MOD <NEWLINE> <DEDENT> d = 1 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> d *= i <NEWLINE> d %= MOD <NEWLINE> <DEDENT> return ( c * pow ( d , MOD - 2 , MOD ) ) % MOD <NEWLINE> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> result = comb ( n + m , n ) <NEWLINE> print ( result ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> def divisor ( N ) : <NEWLINE> <INDENT> lst = [ ] <NEWLINE> for i in range ( 2 , math . ceil ( math . sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> lst . append ( i ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> return lst <NEWLINE> <NL> <DEDENT> ans = divisor ( N ) <NEWLINE> <COMMENT> <NL> if N == 2 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if len ( ans ) > 0 : <NEWLINE> <INDENT> A = ans [ - 1 ] <NEWLINE> if A * A < N : <NEWLINE> <INDENT> B = int ( N / A ) <NEWLINE> print ( A + B - 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * A - 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( N - 1 ) <NEWLINE> <NL> <DEDENT> <STRING> <NEWLINE> <NL>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L , R = [ 0 ] * M , [ 0 ] * M <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> L [ m ] , R [ m ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> print ( max ( min ( R ) - max ( L ) + 1 , 0 ) ) <NEWLINE>
from functools import reduce <NEWLINE> from math import gcd <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> _ = int ( input ( ) ) <NEWLINE> la = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def inv ( a ) : <NEWLINE> <INDENT> return pow ( a , MOD - 2 , MOD ) <NEWLINE> <NL> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // gcd ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> def addmod ( a , b ) : <NEWLINE> <INDENT> return ( a + b ) % MOD <NEWLINE> <NL> <NL> <DEDENT> l = reduce ( lcm , la ) % MOD <NEWLINE> answer = reduce ( addmod , ( l * inv ( a ) for a in la ) , 0 ) <NEWLINE> print ( answer ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> ans = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <COMMENT> <NL> if ( 0 == int ( s [ : 2 ] ) or 13 <= int ( s [ : 2 ] ) ) and ( 0 == int ( s [ - 2 : ] ) or 13 <= int ( s [ - 2 : ] ) ) : <NEWLINE> <INDENT> print ( ans [ 3 ] ) <NEWLINE> <DEDENT> if 0 < int ( s [ : 2 ] ) <= 12 and 0 < int ( s [ - 2 : ] ) <= 12 : <NEWLINE> <INDENT> print ( ans [ 2 ] ) <NEWLINE> <DEDENT> elif 0 < int ( s [ : 2 ] ) <= 12 : <NEWLINE> <INDENT> print ( ans [ 1 ] ) <NEWLINE> <DEDENT> elif 0 < int ( s [ - 2 : ] ) <= 12 : <NEWLINE> <INDENT> print ( ans [ 0 ] ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = [ 0 ] * 9 <NEWLINE> for i in a : <NEWLINE> <INDENT> x = min ( i // 400 , 8 ) <NEWLINE> if x >= 8 : <NEWLINE> <INDENT> cnt [ 8 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ x ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if sum ( cnt [ : 8 ] ) == 0 : <NEWLINE> <INDENT> l = 1 <NEWLINE> r = cnt [ 8 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = sum ( cnt [ : 8 ] ) <NEWLINE> r = l + cnt [ 8 ] <NEWLINE> <DEDENT> print ( l , r ) <NEWLINE>
s = input ( ) <NEWLINE> m = int ( s [ 5 : 7 ] ) <NEWLINE> if m <= 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> import numba as nb <NEWLINE> import numpy as np <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> @ nb . njit ( <STRING> , cache = True ) <NEWLINE> def solve ( H , N , AB ) : <NEWLINE> <INDENT> INF = 10 ** 18 <NEWLINE> dp = [ INF ] * ( H + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A , B = AB [ i ] <NEWLINE> for d in range ( H + 1 ) : <NEWLINE> <INDENT> if d < A : <NEWLINE> <INDENT> dp [ d ] = min ( dp [ d ] , B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ d ] = min ( dp [ d ] , dp [ d - A ] + B ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = dp [ - 1 ] <NEWLINE> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = np . zeros ( shape = ( N , 2 ) , dtype = np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> AB [ i ] = input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> ans = solve ( H , N , AB ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> count = 1 <NEWLINE> ans = 0 <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> A . sort ( ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if count % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> count = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if count % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> n , m = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = [ - int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> heapq . heapify ( a ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> value = heapq . heappop ( a ) <NEWLINE> value /= 2 <NEWLINE> heapq . heappush ( a , value ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = int ( - a [ i ] ) <NEWLINE> <DEDENT> print ( sum ( a ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N >= M : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X = sorted ( X ) <NEWLINE> list = [ X [ i ] - X [ i - 1 ] for i in range ( 1 , M ) ] <NEWLINE> list = sorted ( list ) <NEWLINE> list1 = list [ : M - N ] <NEWLINE> print ( sum ( list1 ) ) <NEWLINE> <DEDENT>
import sys , math , collections , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , K , S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if S == 10 ** 9 : <NEWLINE> <INDENT> ans = [ 10 ** 9 - 1 ] * N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = [ 10 ** 9 ] * N <NEWLINE> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> ans [ i ] = S <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> left = set ( ) <NEWLINE> right = set ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> left . add ( l ) <NEWLINE> right . add ( r ) <NEWLINE> <DEDENT> mini = max ( left ) <NEWLINE> maxi = min ( right ) <NEWLINE> print ( len ( range ( mini , maxi + 1 ) ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> class UnionFind : <NEWLINE> <COMMENT> <NL> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . par = [ i for i in range ( n ) ] <NEWLINE> self . rank = [ 0 ] * n <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . rank [ x ] < self . rank [ y ] : <NEWLINE> <INDENT> self . par [ x ] = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ y ] = x <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ x ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , K , L = map ( int , input ( ) . split ( ) ) <NEWLINE> roads = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( K ) ] <NEWLINE> trains = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( L ) ] <NEWLINE> <NL> uf_road = UnionFind ( N ) <NEWLINE> uf_train = UnionFind ( N ) <NEWLINE> <NL> for road in roads : <NEWLINE> <INDENT> x , y = road <NEWLINE> uf_road . unite ( x - 1 , y - 1 ) <NEWLINE> <NL> <DEDENT> for train in trains : <NEWLINE> <INDENT> x , y = train <NEWLINE> uf_train . unite ( x - 1 , y - 1 ) <NEWLINE> <NL> <DEDENT> pairs = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> pairs . append ( ( uf_road . find ( i ) , uf_train . find ( i ) ) ) <NEWLINE> <NL> <DEDENT> cnt = Counter ( pairs ) <NEWLINE> <NL> ans = [ cnt [ pair ] for pair in pairs ] <NEWLINE> print ( * ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( 1 , math . floor ( math . sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> ans . append ( i + N // i - 2 ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> result = math . factorial ( n ) <NEWLINE> <NL> <NL> dividor = 10 ** 9 + 7 <NEWLINE> print ( result % dividor ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s [ i ] = sorted ( s [ i ] ) <NEWLINE> s [ i ] = <STRING> . join ( s [ i ] ) <NEWLINE> <NL> <DEDENT> t = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] in t : <NEWLINE> <INDENT> t [ s [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ s [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( t [ k ] * ( t [ k ] - 1 ) // 2 for k in t ) ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> <COMMENT> <NL> adj = [ [ ] for j in range ( N ) ] <NEWLINE> for edge in edges : <NEWLINE> <INDENT> x , y = edge <NEWLINE> adj [ x - 1 ] . append ( y ) <NEWLINE> adj [ y - 1 ] . append ( x ) <NEWLINE> <NL> <DEDENT> color = [ 0 ] * N <NEWLINE> <NL> <COMMENT> <NL> def dfs ( node , c ) : <NEWLINE> <INDENT> color [ node - 1 ] = c <NEWLINE> for i in adj [ node - 1 ] : <NEWLINE> <INDENT> if c == color [ i - 1 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if color [ i - 1 ] == 0 and not dfs ( i , - c ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if dfs ( 1 , 1 ) : <NEWLINE> <INDENT> black = color . count ( 1 ) <NEWLINE> white = N - black <NEWLINE> print ( black * white - M ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N * ( N - 1 ) // 2 - M ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> b = - 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == b : <NEWLINE> <INDENT> if ans != 0 : <NEWLINE> <INDENT> ans *= i <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = i <NEWLINE> b = - 1 <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> b = i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> ans = min ( S . count ( <STRING> ) , S . count ( <STRING> ) ) <NEWLINE> <NL> print ( ans * 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans += min ( A [ N - i ] , B [ N - 1 - i ] ) <NEWLINE> if B [ N - i - 1 ] > A [ N - i ] : <NEWLINE> <INDENT> ans += min ( A [ N - i - 1 ] , B [ N - 1 - i ] - A [ N - i ] ) <NEWLINE> A [ N - i - 1 ] -= min ( A [ N - i - 1 ] , B [ N - 1 - i ] - A [ N - i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> fn = 0 <NEWLINE> for i in N : <NEWLINE> <INDENT> fn += int ( i ) <NEWLINE> <NL> <DEDENT> print ( <STRING> if int ( N ) % fn == 0 else <STRING> ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A [ a ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if A [ 1 ] == 0 : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N ] % 1000000007 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> s = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s [ i + 1 ] = s [ i ] + a [ i ] <NEWLINE> <DEDENT> for l in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for i in range ( n - l + 1 ) : <NEWLINE> <INDENT> j = i + l <NEWLINE> dp [ i ] [ j ] = s [ j ] - s [ i ] + min ( dp [ i ] [ k ] + dp [ k ] [ j ] for k in range ( i + 1 , j ) ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ 0 ] [ n ] ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( h ) ] <NEWLINE> <NL> is_used = [ [ False ] * w for _ in range ( h ) ] <NEWLINE> <NL> di = [ + 1 , 0 , - 1 , 0 ] <NEWLINE> dj = [ 0 , + 1 , 0 , - 1 ] <NEWLINE> <NL> <NL> def dfs ( i , j ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> cnt_w , cnt_b = 0 , 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt_w , cnt_b = 1 , 0 <NEWLINE> <NL> <DEDENT> for k in range ( 4 ) : <NEWLINE> <INDENT> ni = i + di [ k ] <NEWLINE> nj = j + dj [ k ] <NEWLINE> if ni < 0 or ni >= h or nj < 0 or nj >= w : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if is_used [ ni ] [ nj ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ i ] [ j ] == s [ ni ] [ nj ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> is_used [ ni ] [ nj ] = True <NEWLINE> cw , cb = dfs ( ni , nj ) <NEWLINE> cnt_w += cw <NEWLINE> cnt_b += cb <NEWLINE> <DEDENT> return ( cnt_w , cnt_b ) <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if not is_used [ i ] [ j ] : <NEWLINE> <INDENT> is_used [ i ] [ j ] = True <NEWLINE> cnt_w , cnt_b = dfs ( i , j ) <NEWLINE> ans += cnt_w * cnt_b <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = set ( a ) <NEWLINE> <NL> d = { } <NEWLINE> for i in s : <NEWLINE> <INDENT> d [ i ] = 0 <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in d : <NEWLINE> <INDENT> c = d [ i ] <NEWLINE> if c < i : <NEWLINE> <INDENT> ans += c <NEWLINE> <DEDENT> elif c >= i : <NEWLINE> <INDENT> ans += c - i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> l = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if k <= l else s [ l ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> s1 = 0 <NEWLINE> s2 = 0 <NEWLINE> <NL> at = - 1 <NEWLINE> atc = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if at == a : <NEWLINE> <INDENT> atc += 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if atc >= 4 : <NEWLINE> <INDENT> s1 = at <NEWLINE> s2 = at <NEWLINE> <DEDENT> elif atc >= 2 : <NEWLINE> <INDENT> s2 = s1 <NEWLINE> s1 = at <NEWLINE> <NL> <DEDENT> at = a <NEWLINE> atc = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if atc >= 4 : <NEWLINE> <INDENT> s1 = at <NEWLINE> s2 = at <NEWLINE> <DEDENT> elif atc >= 2 : <NEWLINE> <INDENT> s2 = s1 <NEWLINE> s1 = at <NEWLINE> <NL> <DEDENT> print ( s1 * s2 ) <NEWLINE>
from collections import Counter <NEWLINE> import sys <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ list ( map ( str , input ( ) . rstrip ( ) ) ) for _ in range ( h ) ] <NEWLINE> <NL> arr = sum ( arr , [ ] ) <NEWLINE> <NL> c = Counter ( arr ) <NEWLINE> c = list ( c . values ( ) ) <NEWLINE> <NL> if h % 2 == 0 and w % 2 == 0 : <NEWLINE> <INDENT> ans = all ( [ x % 4 == 0 for x in c ] ) <COMMENT> <NEWLINE> <NL> <DEDENT> elif h % 2 == 1 and w % 2 == 1 : <NEWLINE> <INDENT> even = ( h + w ) // 2 - 1 <COMMENT> <NEWLINE> odd_cnt = len ( [ x for x in c if x % 2 == 1 ] ) <NEWLINE> if odd_cnt != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> odd = sum ( [ x for x in c if x % 2 == 1 ] ) <NEWLINE> if odd % 4 == 3 : <NEWLINE> <INDENT> even -= 1 <NEWLINE> <DEDENT> c . remove ( odd ) <NEWLINE> <COMMENT> <NL> ans = True if sum ( [ x % 4 == 2 for x in c ] ) <= even else False <NEWLINE> ans &= all ( [ x % 4 == 0 for x in c if x % 4 != 2 ] ) <COMMENT> <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> even = h // 2 if h % 2 == 0 else w // 2 <COMMENT> <NEWLINE> <COMMENT> <NL> ans = True if sum ( [ x % 4 == 2 for x in c ] ) <= even else False <NEWLINE> ans &= all ( [ x % 4 == 0 for x in c if x % 4 != 2 ] ) <COMMENT> <NEWLINE> <NL> <DEDENT> print ( <STRING> if ans else <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> <NL> <DEDENT> AA = sorted ( A , reverse = True ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] != AA [ 0 ] : <NEWLINE> <INDENT> print ( AA [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( AA [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) . rstrip ( <STRING> ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ] <NEWLINE> now = 0 <NEWLINE> for x in range ( N ) : <NEWLINE> <INDENT> if A [ x ] == now + 1 : <NEWLINE> <INDENT> now += 1 <NEWLINE> <DEDENT> <DEDENT> if now == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - now ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> <NL> words = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> ans = <STRING> <NEWLINE> <NL> pointer = len ( s ) <NEWLINE> while pointer > 0 : <NEWLINE> <INDENT> if s [ pointer - 5 : pointer ] == list ( words [ 0 ] ) : <NEWLINE> <INDENT> pointer -= 5 <NEWLINE> <DEDENT> elif s [ pointer - 5 : pointer ] == list ( words [ 2 ] ) : <NEWLINE> <INDENT> pointer -= 5 <NEWLINE> <DEDENT> elif s [ pointer - 7 : pointer ] == list ( words [ 1 ] ) : <NEWLINE> <INDENT> pointer -= 7 <NEWLINE> <DEDENT> elif s [ pointer - 6 : pointer ] == list ( words [ 3 ] ) : <NEWLINE> <INDENT> pointer -= 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> i , ans = 1 , 0 <NEWLINE> <NL> while i ** 2 <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> num = n // i <NEWLINE> ans = max ( len ( str ( num ) ) , len ( str ( i ) ) ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sorted_x = sorted ( X ) <NEWLINE> <NL> l , r = sorted_x [ n // 2 ] , sorted_x [ n // 2 - 1 ] <NEWLINE> <NL> for x in X : <NEWLINE> <INDENT> if bisect . bisect_left ( sorted_x , x ) < n // 2 : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> <DEDENT>
import sys , re , os <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians , gcd <NEWLINE> from itertools import permutations , combinations , product , accumulate <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from functools import reduce <NEWLINE> from bisect import bisect_left , insort_left <NEWLINE> from heapq import heapify , heappush , heappop <NEWLINE> <NL> INPUT = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> INT = lambda : int ( INPUT ( ) ) <NEWLINE> MAP = lambda : map ( int , INPUT ( ) . split ( ) ) <NEWLINE> S_MAP = lambda : map ( str , INPUT ( ) . split ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , INPUT ( ) . split ( ) ) ) <NEWLINE> S_LIST = lambda : list ( map ( str , INPUT ( ) . split ( ) ) ) <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> s = INPUT ( ) <NEWLINE> t = INPUT ( ) <NEWLINE> <NL> s = [ ord ( i ) for i in sorted ( s ) ] <NEWLINE> t = [ ord ( i ) for i in sorted ( t ) ] <NEWLINE> t . reverse ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for x in s : <NEWLINE> <INDENT> if x < t [ cnt ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif x > t [ cnt ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt == len ( t ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> if len ( s ) < len ( t ) else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 2 ) ] <NEWLINE> <NL> <COMMENT> <NL> element = set ( A [ 0 ] + A [ 1 ] ) <NEWLINE> if len ( element ) == 1 : <NEWLINE> <INDENT> print ( list ( element ) [ 0 ] * ( N + 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = 0 <NEWLINE> for d in range ( N ) : <NEWLINE> <INDENT> if d == 0 : <NEWLINE> <INDENT> sum_num = A [ 0 ] [ 0 ] + sum ( A [ 1 ] ) <NEWLINE> <DEDENT> elif d == N - 1 : <NEWLINE> <INDENT> sum_num = sum ( A [ 0 ] ) + A [ 1 ] [ N - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum_num = sum ( A [ 0 ] [ : d + 1 ] ) + sum ( A [ 1 ] [ d : ] ) <NEWLINE> <DEDENT> if res < sum_num : <NEWLINE> <INDENT> res = sum_num <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> from math import gcd <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> mod = 1000000007 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lcm = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> lcm = lcm * i // gcd ( lcm , i ) <NEWLINE> <DEDENT> lcm %= mod <NEWLINE> <NL> ans = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans += lcm * pow ( i , mod - 2 , mod ) <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
