n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = len ( a ) <NEWLINE> a = set ( a ) <NEWLINE> n = len ( a ) <NEWLINE> if m == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if X < A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10 ) <NEWLINE> <DEDENT>
n_max = 10 ** 5 + 10 <NEWLINE> sieve = [ 0 , 0 ] + [ 1 ] * n_max <NEWLINE> m = 2 <NEWLINE> while m * m <= n_max : <NEWLINE> <INDENT> if sieve [ m ] : <NEWLINE> <INDENT> for n in range ( 2 * m , n_max , m ) : <NEWLINE> <INDENT> sieve [ n ] = 0 <NEWLINE> <DEDENT> <DEDENT> m += 1 <NEWLINE> <NL> <DEDENT> ok = [ 0 ] * n_max <NEWLINE> cums = [ 0 ] <NEWLINE> for n in range ( n_max ) : <NEWLINE> <INDENT> if sieve [ n ] and sieve [ ( n + 1 ) // 2 ] : <NEWLINE> <INDENT> ok [ n ] = 1 <NEWLINE> <DEDENT> cums . append ( cums [ - 1 ] + ok [ n ] ) <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( cums [ r + 1 ] - cums [ l ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> la = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> la [ l [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> ans = [ str ( j ) for j in la ] <NEWLINE> ans = <STRING> . join ( ans ) <NEWLINE> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> h = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> total = 0 <NEWLINE> while h > 0 : <NEWLINE> <INDENT> total += 2 ** c <NEWLINE> h = h // 2 <NEWLINE> if h == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> total += 2 ** c <NEWLINE> break <NEWLINE> <DEDENT> c += 1 <NEWLINE> <DEDENT> print ( total ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
import numpy as np <NEWLINE> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dist = np . zeros ( N + 1 , dtype = int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> dist [ i + 1 ] = dist [ i ] + L [ i ] <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> count = 0 <NEWLINE> while dist [ i ] <= X : <NEWLINE> <INDENT> count += 1 <NEWLINE> i += 1 <NEWLINE> if i == N + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <STRING> <NEWLINE>
S = input ( ) <NEWLINE> <NL> def solve ( S ) : <NEWLINE> <INDENT> buf = [ 1 ] * len ( S ) <NEWLINE> <NL> for i in range ( len ( buf ) - 2 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> buf [ i + 2 ] += buf [ i ] <NEWLINE> buf [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( buf ) - 1 , 1 , - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> buf [ i - 2 ] += buf [ i ] <NEWLINE> buf [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> return <STRING> . join ( map ( str , buf ) ) <NEWLINE> <NL> <DEDENT> print ( solve ( S ) ) <NEWLINE>
S = input ( ) <NEWLINE> l = len ( S ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 2 ** ( l - 1 ) ) : <NEWLINE> <INDENT> T = S [ 0 ] <NEWLINE> for j in range ( l - 1 ) : <NEWLINE> <INDENT> if i >> j & 1 : <NEWLINE> <INDENT> T = T + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T = T + <STRING> <NEWLINE> <DEDENT> T = T + S [ j + 1 ] <NEWLINE> <DEDENT> if eval ( T ) == 7 : <NEWLINE> <INDENT> print ( T + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> coins = [ 100 , 101 , 102 , 103 , 104 , 105 ] <NEWLINE> dp = [ int ( i % coins [ 0 ] == 0 ) for i in range ( N + 1 ) ] <NEWLINE> for coin in coins [ 1 : ] : <NEWLINE> <INDENT> for i in range ( coin , N + 1 ) : <NEWLINE> <INDENT> dp [ i ] += dp [ i - coin ] <NEWLINE> <DEDENT> <DEDENT> if dp [ - 1 ] != 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) <NEWLINE> frog_lst = list ( map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) ) <NEWLINE> frog_jump_lst = [ ] <NEWLINE> <NL> def frog_jump ( frog_jump_lst = [ ] , index = 0 ) : <NEWLINE> <INDENT> if not frog_jump_lst : <NEWLINE> <INDENT> frog_jump_lst . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now_pos = frog_lst [ index ] <NEWLINE> k = min ( K , len ( frog_jump_lst ) ) <NEWLINE> pattern = [ abs ( now_pos - frog_lst [ index - i ] ) + frog_jump_lst [ - i ] for i in range ( 1 , k + 1 ) ] <NEWLINE> frog_jump_lst . append ( min ( pattern ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> frog_jump ( frog_jump_lst , j ) <NEWLINE> <DEDENT> print ( frog_jump_lst [ - 1 ] ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> from heapq import heappop , heappush <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> from collections import deque <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> C = list ( sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) ) <NEWLINE> <NL> MAX = 2 * 10 ** 5 + 5 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> fac = [ 0 for i in range ( MAX ) ] <NEWLINE> finv = [ 0 for i in range ( MAX ) ] <NEWLINE> inv = [ 0 for i in range ( MAX ) ] <NEWLINE> <NL> def comInit ( mod ) : <NEWLINE> <INDENT> fac [ 0 ] , fac [ 1 ] = 1 , 1 <NEWLINE> finv [ 0 ] , finv [ 1 ] = 1 , 1 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> for i in range ( 2 , MAX ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i % mod <NEWLINE> inv [ i ] = mod - inv [ mod % i ] * ( mod // i ) % mod <NEWLINE> finv [ i ] = finv [ i - 1 ] * inv [ i ] % mod <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def com ( n , r , mod ) : <NEWLINE> <INDENT> if n < r : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if n < 0 or r < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return fac [ n ] * ( finv [ r ] * finv [ n - r ] % mod ) % mod <NEWLINE> <NL> <DEDENT> def p ( n , r , mod ) : <NEWLINE> <INDENT> return fac [ n ] * finv [ n - r ] % mod <NEWLINE> <NL> <DEDENT> comInit ( MOD ) <NEWLINE> <NL> ans = 0 <NEWLINE> pow_list = [ 1 ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> pow_list [ i ] = ( 2 * pow_list [ i - 1 ] ) % MOD <NEWLINE> <DEDENT> base = pow_list [ N ] <NEWLINE> for i , c in enumerate ( C ) : <NEWLINE> <INDENT> now = pow_list [ N - i - 1 ] <NEWLINE> tot = 0 <NEWLINE> if i >= 1 : <NEWLINE> <INDENT> tot = pow_list [ i ] + i * pow_list [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tot = pow_list [ i ] <NEWLINE> <DEDENT> ans += ( tot * now * c ) % MOD <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans * base % MOD ) <NEWLINE> <NL> <NL> <NL>
<COMMENT> <NL> from collections import deque , Counter <NEWLINE> from heapq import heappop , heappush <NEWLINE> from bisect import bisect_right <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> adj = [ [ ] for _ in range ( N ) ] <NEWLINE> ans = [ None ] * N <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> def dfs ( v , parent , c ) : <NEWLINE> <INDENT> ans [ v ] = c <NEWLINE> for u , w in adj [ v ] : <NEWLINE> <INDENT> if u == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( u , v , 1 - c ) if w & 1 else dfs ( u , v , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> adj [ u - 1 ] . append ( ( v - 1 , w ) ) <NEWLINE> adj [ v - 1 ] . append ( ( u - 1 , w ) ) <NEWLINE> <NL> <DEDENT> dfs ( 0 , - 1 , 1 ) <NEWLINE> [ print ( v ) for v in ans ] <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> five = 0 <NEWLINE> two = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> f = n // ( 2 * ( 5 ** i ) ) <NEWLINE> t = n // ( 2 ** i ) <NEWLINE> if f == t == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> five += f <NEWLINE> two += t <NEWLINE> <DEDENT> print ( min ( five , two ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i < int ( n / 2 ) : <NEWLINE> <INDENT> print ( a [ n - 2 * i - 1 ] , <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ 2 * i - n ] , <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i <= n // 2 : <NEWLINE> <INDENT> print ( a [ n - 2 * i - 1 ] , <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ 2 * i - n ] , <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> l = { } <NEWLINE> for _a in a : <NEWLINE> <INDENT> if _a in l : <NEWLINE> <INDENT> l . pop ( _a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . update ( <NEWLINE> <INDENT> { _a : True } <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( l ) ) <NEWLINE>
input ( ) <NEWLINE> V = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = V [ 0 ] <NEWLINE> for v in V [ 1 : ] : <NEWLINE> <INDENT> ans = ( ans + v ) / 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans , a , b = 0 , [ ] , [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( x + y ) <NEWLINE> b . append ( [ x , y ] ) <NEWLINE> <DEDENT> num = [ x for x in range ( n ) ] <NEWLINE> a , a0 = zip ( * sorted ( zip ( a , num ) ) ) <NEWLINE> a , a0 = list ( a ) , list ( a0 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> val = a0 . pop ( ) <NEWLINE> a . pop ( ) <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> ans += b [ val ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans -= b [ val ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> b = sorted ( set ( a ) ) <NEWLINE> count = 0 <NEWLINE> z = 0 <NEWLINE> for i in b : <NEWLINE> <INDENT> if i > n : <NEWLINE> <INDENT> count += n - z <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = a . count ( i ) <NEWLINE> if j < i : <NEWLINE> <INDENT> count += j <NEWLINE> z += j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += j - i <NEWLINE> z += j <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> a = int ( s [ 1 ] / 10000 ) <NEWLINE> b = int ( s [ 1 ] / 5000 ) <NEWLINE> c = int ( s [ 1 ] / 1000 ) <NEWLINE> for i in range ( 0 , a + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , b + 1 ) : <NEWLINE> <INDENT> if ( s [ 0 ] - i - j >= 0 ) : <NEWLINE> <INDENT> check = 10000 * i + 5000 * j + 1000 * ( s [ 0 ] - i - j ) <NEWLINE> if ( check == s [ 1 ] ) : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> ans . append ( j ) <NEWLINE> ans . append ( s [ 0 ] - i - j ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ( ans == [ ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( ans [ 0 ] , ans [ 1 ] , ans [ 2 ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> from collections import defaultdict , deque , Counter <NEWLINE> from copy import deepcopy <NEWLINE> from bisect import bisect , bisect_right , bisect_left <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> def RD ( ) : return input ( ) . rstrip ( ) <NEWLINE> def F ( ) : return float ( input ( ) . rstrip ( ) ) <NEWLINE> def I ( ) : return int ( input ( ) . rstrip ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MF ( ) : return map ( float , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def TI ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LF ( ) : return list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> def Init ( H , W , num ) : return [ [ num for i in range ( W ) ] for j in range ( H ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> L = [ LI ( ) for i in range ( N ) ] <NEWLINE> <NL> for x in range ( 101 ) : <NEWLINE> <INDENT> for y in range ( 101 ) : <NEWLINE> <INDENT> max_num = float ( <STRING> ) <NEWLINE> ans = 0 <NEWLINE> res = True <NEWLINE> for xn , yn , hn in L : <NEWLINE> <INDENT> if hn == 0 : <NEWLINE> <INDENT> max_num = min ( max_num , abs ( x - xn ) + abs ( y - yn ) ) <NEWLINE> if max_num == 0 : <NEWLINE> <INDENT> res = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> temp = abs ( x - xn ) + abs ( y - yn ) + hn <NEWLINE> if ans != 0 and ans != temp : <NEWLINE> <INDENT> res = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = temp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ( max_num >= 2 and ans == 0 ) or ans > max_num : <NEWLINE> <INDENT> res = False <NEWLINE> <NL> <DEDENT> if res : <NEWLINE> <INDENT> if ans != 0 : <NEWLINE> <INDENT> print ( x , y , ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x , y , 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import numpy as np <NEWLINE> from scipy . special import comb <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_sum = np . cumsum ( a ) <NEWLINE> <NL> <NL> re_list = { } <NEWLINE> re_list [ 0 ] = 1 <NEWLINE> for i in a_sum : <NEWLINE> <INDENT> re = i % m <NEWLINE> if re in re_list : <NEWLINE> <INDENT> re_list [ re ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re_list [ re ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for value in re_list . values ( ) : <NEWLINE> <INDENT> ans += comb ( value , 2 , exact = True ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import collections <NEWLINE> import fractions <NEWLINE> import itertools <NEWLINE> import functools <NEWLINE> import operator <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> c = collections . Counter ( a ) <NEWLINE> cnt = 0 <NEWLINE> for i in c : <NEWLINE> <INDENT> if c [ i ] % 2 == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
total , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def total_to_digits ( total ) : <NEWLINE> <INDENT> return map ( int , list ( str ( total ) ) ) <NEWLINE> <NL> <DEDENT> def find_lowest_denomination ( total , d ) : <NEWLINE> <INDENT> res = None <NEWLINE> for i in range ( total , 99999 ) : <NEWLINE> <INDENT> digits = list ( total_to_digits ( i ) ) <NEWLINE> if not ( set ( digits ) & set ( d ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> find_lowest_denomination ( total , d ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = [ 0 ] * n <NEWLINE> w = 0 <NEWLINE> c = 0 <NEWLINE> ac = set ( ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> p , s = map ( str , input ( ) . split ( ) ) <NEWLINE> p = int ( p ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> l [ p - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if p not in ac : <NEWLINE> <INDENT> c += 1 <NEWLINE> w += l [ p - 1 ] <NEWLINE> ac . add ( p ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( c , w ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) [ : : - 1 ] <NEWLINE> <NL> for n in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ n ] == A [ n + 1 ] : <NEWLINE> <INDENT> A [ n + 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ n ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> A = sorted ( A ) [ : : - 1 ] <NEWLINE> print ( A [ 0 ] * A [ 1 ] ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> pn1 = p - 1 <NEWLINE> <NL> ans = sum ( pn1 [ : K ] ) <NEWLINE> spb = ans <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> sp = spb - pn1 [ i ] + pn1 [ i + K ] <NEWLINE> <COMMENT> <NL> ans = max ( sp , ans ) <NEWLINE> spb = sp <NEWLINE> <DEDENT> print ( ans / 2 + K ) <NEWLINE> <NL>
import heapq as hq <NEWLINE> from itertools import accumulate <NEWLINE> from math import ceil <NEWLINE> N , H = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> ab . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> ab . sort ( key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> ma , mb = ab [ 0 ] <NEWLINE> q = [ ab [ i ] [ 1 ] for i in range ( 1 , N ) ] <NEWLINE> q . sort ( reverse = True ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> acc = [ 0 ] + list ( accumulate ( q , lambda x , y : x + y ) ) <NEWLINE> for l in range ( len ( q ) + 1 ) : <NEWLINE> <INDENT> h = H <NEWLINE> cnt = l <NEWLINE> h -= acc [ l ] <NEWLINE> if h <= 0 : <NEWLINE> <INDENT> ans = min ( ans , cnt ) <NEWLINE> continue <NEWLINE> <DEDENT> h -= mb <NEWLINE> cnt += 1 <NEWLINE> if h <= 0 : <NEWLINE> <INDENT> ans = min ( ans , cnt ) <NEWLINE> continue <NEWLINE> <DEDENT> cnt += ceil ( h / ma ) <NEWLINE> ans = min ( ans , cnt ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> T = list ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> a = ord ( <STRING> ) <NEWLINE> alf = [ ] <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> alf . append ( chr ( a ) ) <NEWLINE> a += 1 <NEWLINE> <NL> <DEDENT> SN = [ [ ] for i in range ( 26 ) ] <NEWLINE> TN = [ [ ] for i in range ( 26 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( 26 ) : <NEWLINE> <INDENT> if alf [ j ] == S [ i ] : <NEWLINE> <INDENT> SN [ j ] . append ( i ) <NEWLINE> <DEDENT> if alf [ j ] == T [ i ] : <NEWLINE> <INDENT> TN [ j ] . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> SN . sort ( ) <NEWLINE> TN . sort ( ) <NEWLINE> print ( <STRING> if SN == TN else <STRING> ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> <NL> def comb ( n , r ) : <NEWLINE> <INDENT> if ( r < 0 and r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % MOD <NEWLINE> <NL> <DEDENT> N = 10 ** 6 <NEWLINE> g1 = [ 1 , 1 ] <NEWLINE> g2 = [ 1 , 1 ] <NEWLINE> inverse = [ 0 , 1 ] <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % MOD ) <NEWLINE> inverse . append ( ( - inverse [ MOD % i ] * ( MOD // i ) ) % MOD ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % MOD ) <NEWLINE> <NL> <DEDENT> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if not ( X + Y ) % 3 : <NEWLINE> <INDENT> m = ( 2 * X - Y ) // 3 <NEWLINE> n = ( 2 * Y - X ) // 3 <NEWLINE> if n >= 0 and m >= 0 : <NEWLINE> <INDENT> print ( comb ( n + m , n ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> l1 = L // 2019 <NEWLINE> r1 = R // 2019 <NEWLINE> if l1 < r1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif l1 == r1 : <NEWLINE> <INDENT> res = [ ] <NEWLINE> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> res . append ( ( i * j ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( res ) ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = list ( range ( n ) ) <NEWLINE> self . size = [ 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <DEDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . size [ x ] < self . size [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . size [ x ] += self . size [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def sizeofset ( self , x ) : <NEWLINE> <INDENT> return self . size [ self . find ( x ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N + 1 ) <NEWLINE> <NL> cnt = ( N ) * ( N - 1 ) // 2 <NEWLINE> L = [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( M ) ] <NEWLINE> ans = [ ] <NEWLINE> <NL> for a , b in L [ : : - 1 ] : <NEWLINE> <INDENT> ans . append ( cnt ) <NEWLINE> if not uf . same ( a , b ) : <NEWLINE> <INDENT> cnt -= uf . sizeofset ( a ) * uf . sizeofset ( b ) <NEWLINE> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> <DEDENT> for x in ans [ : : - 1 ] : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors , upper_divisors <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> low , up = make_divisors ( n ) <NEWLINE> if len ( low ) != 1 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> print ( low [ - 1 ] + up [ - 1 ] - 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - 1 ) <NEWLINE> <DEDENT>
def readinput ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> return n , l <NEWLINE> <NL> <DEDENT> def main ( n , a ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> hist = [ 0 ] * 61 <NEWLINE> bs = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> s = bin ( a [ i ] ) [ 2 : ] <NEWLINE> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> hist [ len ( s ) - j - 1 ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> sum = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> b = 1 <NEWLINE> for j in range ( 61 ) : <NEWLINE> <INDENT> sum = ( sum + ( hist [ j ] * ( n - hist [ j ] ) * b ) % MOD ) % MOD <NEWLINE> b *= 2 <NEWLINE> <NL> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , l = readinput ( ) <NEWLINE> ans = main ( n , l ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 20202020200 <NEWLINE> sum_A = 0 <NEWLINE> sum_B = sum ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum_A += A [ i ] <NEWLINE> sum_B -= A [ i ] <NEWLINE> tmp = abs ( sum_A - sum_B ) <NEWLINE> if tmp < ans : <NEWLINE> <INDENT> ans = tmp <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ 0 for i in range ( 10 ** 5 + 2 ) ] <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> cnt [ i + 1 ] += 1 <NEWLINE> cnt [ i + 2 ] += 1 <NEWLINE> <NL> <DEDENT> print ( max ( cnt ) ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> def Eratosthenes ( x ) : <NEWLINE> <INDENT> lis = [ int ( i ) for i in range ( 2 , x ) ] <NEWLINE> <COMMENT> <NL> res = list ( ) <NEWLINE> while lis : <NEWLINE> <INDENT> a = lis . pop ( 0 ) <NEWLINE> res . append ( a ) <NEWLINE> lis = [ i for i in lis if i % a != 0 ] <NEWLINE> <COMMENT> <NL> <DEDENT> return res <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> lis = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 , 101 , 103 , 107 , 109 , 113 , 127 , 131 , 137 , 139 , 149 , 151 , 157 , 163 , 167 , 173 , 179 , 181 , 191 , 193 , 197 , 199 , 211 , 223 , 227 , 229 , 233 , 239 , 241 , 251 , 257 , 263 , 269 , 271 , 277 , 281 , 283 , 293 , 307 , 311 , 313 , 317 , 331 , 337 , 347 , 349 , 353 , 359 , 367 , 373 , 379 , 383 , 389 , 397 , 401 , 409 , 419 , 421 , 431 , 433 , 439 , 443 , 449 , 457 , 461 , 463 , 467 , 479 , 487 , 491 , 499 , 503 , 509 , 521 , 523 , 541 , 547 , 557 , 563 , 569 , 571 , 577 , 587 , 593 , 599 , 601 , 607 , 613 , 617 , 619 , 631 , 641 , 643 , 647 , 653 , 659 , 661 , 673 , 677 , 683 , 691 , 701 , 709 , 719 , 727 , 733 , 739 , 743 , 751 , 757 , 761 , 769 , 773 , 787 , 797 , 809 , 811 , 821 , 823 , 827 , 829 , 839 , 853 , 857 , 859 , 863 , 877 , 881 , 883 , 887 , 907 , 911 , 919 , 929 , 937 , 941 , 947 , 953 , 967 , 971 , 977 , 983 , 991 , 997 , 1009 , 1013 , 1019 , 1021 , 1031 , 1033 , 1039 , 1049 , 1051 , 1061 , 1063 , 1069 , 1087 , 1091 , 1093 , 1097 , 1103 , 1109 , 1117 , 1123 , 1129 , 1151 , 1153 , 1163 , 1171 , 1181 , 1187 , 1193 , 1201 , 1213 , 1217 , 1223 , 1229 , 1231 , 1237 , 1249 , 1259 , 1277 , 1279 , 1283 , 1289 , 1291 , 1297 , 1301 , 1303 , 1307 , 1319 , 1321 , 1327 , 1361 , 1367 , 1373 , 1381 , 1399 , 1409 , 1423 , 1427 , 1429 , 1433 , 1439 , 1447 , 1451 , 1453 , 1459 , 1471 , 1481 , 1483 , 1487 , 1489 , 1493 , 1499 , 1511 , 1523 , 1531 , 1543 , 1549 , 1553 , 1559 , 1567 , 1571 , 1579 , 1583 , 1597 , 1601 , 1607 , 1609 , 1613 , 1619 , 1621 , 1627 , 1637 , 1657 , 1663 , 1667 , 1669 , 1693 , 1697 , 1699 , 1709 , 1721 , 1723 , 1733 , 1741 , 1747 , 1753 , 1759 , 1777 , 1783 , 1787 , 1789 , 1801 , 1811 , 1823 , 1831 , 1847 , 1861 , 1867 , 1871 , 1873 , 1877 , 1879 , 1889 , 1901 , 1907 , 1913 , 1931 , 1933 , 1949 , 1951 , 1973 , 1979 , 1987 , 1993 , 1997 , 1999 , 2003 , 2011 , 2017 , 2027 , 2029 , 2039 , 2053 , 2063 , 2069 , 2081 , 2083 , 2087 , 2089 , 2099 , 2111 , 2113 , 2129 , 2131 , 2137 , 2141 , 2143 , 2153 , 2161 , 2179 , 2203 , 2207 , 2213 , 2221 , 2237 , 2239 , 2243 , 2251 , 2267 , 2269 , 2273 , 2281 , 2287 , 2293 , 2297 , 2309 , 2311 , 2333 , 2339 , 2341 , 2347 , 2351 , 2357 , 2371 , 2377 , 2381 , 2383 , 2389 , 2393 , 2399 , 2411 , 2417 , 2423 , 2437 , 2441 , 2447 , 2459 , 2467 , 2473 , 2477 , 2503 , 2521 , 2531 , 2539 , 2543 , 2549 , 2551 , 2557 , 2579 , 2591 , 2593 , 2609 , 2617 , 2621 , 2633 , 2647 , 2657 , 2659 , 2663 , 2671 , 2677 , 2683 , 2687 , 2689 , 2693 , 2699 , 2707 , 2711 , 2713 , 2719 , 2729 , 2731 , 2741 , 2749 , 2753 , 2767 , 2777 , 2789 , 2791 , 2797 , 2801 , 2803 , 2819 , 2833 , 2837 , 2843 , 2851 , 2857 , 2861 , 2879 , 2887 , 2897 , 2903 , 2909 , 2917 , 2927 , 2939 , 2953 , 2957 , 2963 , 2969 , 2971 , 2999 , 3001 , 3011 , 3019 , 3023 , 3037 , 3041 , 3049 , 3061 , 3067 , 3079 , 3083 , 3089 , 3109 , 3119 , 3121 , 3137 , 3163 , 3167 , 3169 , 3181 , 3187 , 3191 , 3203 , 3209 , 3217 , 3221 , 3229 , 3251 , 3253 , 3257 , 3259 , 3271 , 3299 , 3301 , 3307 , 3313 , 3319 , 3323 , 3329 , 3331 , 3343 , 3347 , 3359 , 3361 , 3371 , 3373 , 3389 , 3391 , 3407 , 3413 , 3433 , 3449 , 3457 , 3461 , 3463 , 3467 , 3469 , 3491 , 3499 , 3511 , 3517 , 3527 , 3529 , 3533 , 3539 , 3541 , 3547 , 3557 , 3559 , 3571 , 3581 , 3583 , 3593 , 3607 , 3613 , 3617 , 3623 , 3631 , 3637 , 3643 , 3659 , 3671 , 3673 , 3677 , 3691 , 3697 , 3701 , 3709 , 3719 , 3727 , 3733 , 3739 , 3761 , 3767 , 3769 , 3779 , 3793 , 3797 , 3803 , 3821 , 3823 , 3833 , 3847 , 3851 , 3853 , 3863 , 3877 , 3881 , 3889 , 3907 , 3911 , 3917 , 3919 , 3923 , 3929 , 3931 , 3943 , 3947 , 3967 , 3989 , 4001 , 4003 , 4007 , 4013 , 4019 , 4021 , 4027 , 4049 , 4051 , 4057 , 4073 , 4079 , 4091 , 4093 , 4099 , 4111 , 4127 , 4129 , 4133 , 4139 , 4153 , 4157 , 4159 , 4177 , 4201 , 4211 , 4217 , 4219 , 4229 , 4231 , 4241 , 4243 , 4253 , 4259 , 4261 , 4271 , 4273 , 4283 , 4289 , 4297 , 4327 , 4337 , 4339 , 4349 , 4357 , 4363 , 4373 , 4391 , 4397 , 4409 , 4421 , 4423 , 4441 , 4447 , 4451 , 4457 , 4463 , 4481 , 4483 , 4493 , 4507 , 4513 , 4517 , 4519 , 4523 , 4547 , 4549 , 4561 , 4567 , 4583 , 4591 , 4597 , 4603 , 4621 , 4637 , 4639 , 4643 , 4649 , 4651 , 4657 , 4663 , 4673 , 4679 , 4691 , 4703 , 4721 , 4723 , 4729 , 4733 , 4751 , 4759 , 4783 , 4787 , 4789 , 4793 , 4799 , 4801 , 4813 , 4817 , 4831 , 4861 , 4871 , 4877 , 4889 , 4903 , 4909 , 4919 , 4931 , 4933 , 4937 , 4943 , 4951 , 4957 , 4967 , 4969 , 4973 , 4987 , 4993 , 4999 , 5003 , 5009 , 5011 , 5021 , 5023 , 5039 , 5051 , 5059 , 5077 , 5081 , 5087 , 5099 , 5101 , 5107 , 5113 , 5119 , 5147 , 5153 , 5167 , 5171 , 5179 , 5189 , 5197 , 5209 , 5227 , 5231 , 5233 , 5237 , 5261 , 5273 , 5279 , 5281 , 5297 , 5303 , 5309 , 5323 , 5333 , 5347 , 5351 , 5381 , 5387 , 5393 , 5399 , 5407 , 5413 , 5417 , 5419 , 5431 , 5437 , 5441 , 5443 , 5449 , 5471 , 5477 , 5479 , 5483 , 5501 , 5503 , 5507 , 5519 , 5521 , 5527 , 5531 , 5557 , 5563 , 5569 , 5573 , 5581 , 5591 , 5623 , 5639 , 5641 , 5647 , 5651 , 5653 , 5657 , 5659 , 5669 , 5683 , 5689 , 5693 , 5701 , 5711 , 5717 , 5737 , 5741 , 5743 , 5749 , 5779 , 5783 , 5791 , 5801 , 5807 , 5813 , 5821 , 5827 , 5839 , 5843 , 5849 , 5851 , 5857 , 5861 , 5867 , 5869 , 5879 , 5881 , 5897 , 5903 , 5923 , 5927 , 5939 , 5953 , 5981 , 5987 , 6007 , 6011 , 6029 , 6037 , 6043 , 6047 , 6053 , 6067 , 6073 , 6079 , 6089 , 6091 , 6101 , 6113 , 6121 , 6131 , 6133 , 6143 , 6151 , 6163 , 6173 , 6197 , 6199 , 6203 , 6211 , 6217 , 6221 , 6229 , 6247 , 6257 , 6263 , 6269 , 6271 , 6277 , 6287 , 6299 , 6301 , 6311 , 6317 , 6323 , 6329 , 6337 , 6343 , 6353 , 6359 , 6361 , 6367 , 6373 , 6379 , 6389 , 6397 , 6421 , 6427 , 6449 , 6451 , 6469 , 6473 , 6481 , 6491 , 6521 , 6529 , 6547 , 6551 , 6553 , 6563 , 6569 , 6571 , 6577 , 6581 , 6599 , 6607 , 6619 , 6637 , 6653 , 6659 , 6661 , 6673 , 6679 , 6689 , 6691 , 6701 , 6703 , 6709 , 6719 , 6733 , 6737 , 6761 , 6763 , 6779 , 6781 , 6791 , 6793 , 6803 , 6823 , 6827 , 6829 , 6833 , 6841 , 6857 , 6863 , 6869 , 6871 , 6883 , 6899 , 6907 , 6911 , 6917 , 6947 , 6949 , 6959 , 6961 , 6967 , 6971 , 6977 , 6983 , 6991 , 6997 , 7001 , 7013 , 7019 , 7027 , 7039 , 7043 , 7057 , 7069 , 7079 , 7103 , 7109 , 7121 , 7127 , 7129 , 7151 , 7159 , 7177 , 7187 , 7193 , 7207 , 7211 , 7213 , 7219 , 7229 , 7237 , 7243 , 7247 , 7253 , 7283 , 7297 , 7307 , 7309 , 7321 , 7331 , 7333 , 7349 , 7351 , 7369 , 7393 , 7411 , 7417 , 7433 , 7451 , 7457 , 7459 , 7477 , 7481 , 7487 , 7489 , 7499 , 7507 , 7517 , 7523 , 7529 , 7537 , 7541 , 7547 , 7549 , 7559 , 7561 , 7573 , 7577 , 7583 , 7589 , 7591 , 7603 , 7607 , 7621 , 7639 , 7643 , 7649 , 7669 , 7673 , 7681 , 7687 , 7691 , 7699 , 7703 , 7717 , 7723 , 7727 , 7741 , 7753 , 7757 , 7759 , 7789 , 7793 , 7817 , 7823 , 7829 , 7841 , 7853 , 7867 , 7873 , 7877 , 7879 , 7883 , 7901 , 7907 , 7919 , 7927 , 7933 , 7937 , 7949 , 7951 , 7963 , 7993 , 8009 , 8011 , 8017 , 8039 , 8053 , 8059 , 8069 , 8081 , 8087 , 8089 , 8093 , 8101 , 8111 , 8117 , 8123 , 8147 , 8161 , 8167 , 8171 , 8179 , 8191 , 8209 , 8219 , 8221 , 8231 , 8233 , 8237 , 8243 , 8263 , 8269 , 8273 , 8287 , 8291 , 8293 , 8297 , 8311 , 8317 , 8329 , 8353 , 8363 , 8369 , 8377 , 8387 , 8389 , 8419 , 8423 , 8429 , 8431 , 8443 , 8447 , 8461 , 8467 , 8501 , 8513 , 8521 , 8527 , 8537 , 8539 , 8543 , 8563 , 8573 , 8581 , 8597 , 8599 , 8609 , 8623 , 8627 , 8629 , 8641 , 8647 , 8663 , 8669 , 8677 , 8681 , 8689 , 8693 , 8699 , 8707 , 8713 , 8719 , 8731 , 8737 , 8741 , 8747 , 8753 , 8761 , 8779 , 8783 , 8803 , 8807 , 8819 , 8821 , 8831 , 8837 , 8839 , 8849 , 8861 , 8863 , 8867 , 8887 , 8893 , 8923 , 8929 , 8933 , 8941 , 8951 , 8963 , 8969 , 8971 , 8999 , 9001 , 9007 , 9011 , 9013 , 9029 , 9041 , 9043 , 9049 , 9059 , 9067 , 9091 , 9103 , 9109 , 9127 , 9133 , 9137 , 9151 , 9157 , 9161 , 9173 , 9181 , 9187 , 9199 , 9203 , 9209 , 9221 , 9227 , 9239 , 9241 , 9257 , 9277 , 9281 , 9283 , 9293 , 9311 , 9319 , 9323 , 9337 , 9341 , 9343 , 9349 , 9371 , 9377 , 9391 , 9397 , 9403 , 9413 , 9419 , 9421 , 9431 , 9433 , 9437 , 9439 , 9461 , 9463 , 9467 , 9473 , 9479 , 9491 , 9497 , 9511 , 9521 , 9533 , 9539 , 9547 , 9551 , 9587 , 9601 , 9613 , 9619 , 9623 , 9629 , 9631 , 9643 , 9649 , 9661 , 9677 , 9679 , 9689 , 9697 , 9719 , 9721 , 9733 , 9739 , 9743 , 9749 , 9767 , 9769 , 9781 , 9787 , 9791 , 9803 , 9811 , 9817 , 9829 , 9833 , 9839 , 9851 , 9857 , 9859 , 9871 , 9883 , 9887 , 9901 , 9907 , 9923 , 9929 , 9931 , 9941 , 9949 , 9967 , 9973 , 10007 , 10009 , 10037 , 10039 , 10061 , 10067 , 10069 , 10079 , 10091 , 10093 , 10099 , 10103 , 10111 , 10133 , 10139 , 10141 , 10151 , 10159 , 10163 , 10169 , 10177 , 10181 , 10193 , 10211 , 10223 , 10243 , 10247 , 10253 , 10259 , 10267 , 10271 , 10273 , 10289 , 10301 , 10303 , 10313 , 10321 , 10331 , 10333 , 10337 , 10343 , 10357 , 10369 , 10391 , 10399 , 10427 , 10429 , 10433 , 10453 , 10457 , 10459 , 10463 , 10477 , 10487 , 10499 , 10501 , 10513 , 10529 , 10531 , 10559 , 10567 , 10589 , 10597 , 10601 , 10607 , 10613 , 10627 , 10631 , 10639 , 10651 , 10657 , 10663 , 10667 , 10687 , 10691 , 10709 , 10711 , 10723 , 10729 , 10733 , 10739 , 10753 , 10771 , 10781 , 10789 , 10799 , 10831 , 10837 , 10847 , 10853 , 10859 , 10861 , 10867 , 10883 , 10889 , 10891 , 10903 , 10909 , 10937 , 10939 , 10949 , 10957 , 10973 , 10979 , 10987 , 10993 , 11003 , 11027 , 11047 , 11057 , 11059 , 11069 , 11071 , 11083 , 11087 , 11093 , 11113 , 11117 , 11119 , 11131 , 11149 , 11159 , 11161 , 11171 , 11173 , 11177 , 11197 , 11213 , 11239 , 11243 , 11251 , 11257 , 11261 , 11273 , 11279 , 11287 , 11299 , 11311 , 11317 , 11321 , 11329 , 11351 , 11353 , 11369 , 11383 , 11393 , 11399 , 11411 , 11423 , 11437 , 11443 , 11447 , 11467 , 11471 , 11483 , 11489 , 11491 , 11497 , 11503 , 11519 , 11527 , 11549 , 11551 , 11579 , 11587 , 11593 , 11597 , 11617 , 11621 , 11633 , 11657 , 11677 , 11681 , 11689 , 11699 , 11701 , 11717 , 11719 , 11731 , 11743 , 11777 , 11779 , 11783 , 11789 , 11801 , 11807 , 11813 , 11821 , 11827 , 11831 , 11833 , 11839 , 11863 , 11867 , 11887 , 11897 , 11903 , 11909 , 11923 , 11927 , 11933 , 11939 , 11941 , 11953 , 11959 , 11969 , 11971 , 11981 , 11987 , 12007 , 12011 , 12037 , 12041 , 12043 , 12049 , 12071 , 12073 , 12097 , 12101 , 12107 , 12109 , 12113 , 12119 , 12143 , 12149 , 12157 , 12161 , 12163 , 12197 , 12203 , 12211 , 12227 , 12239 , 12241 , 12251 , 12253 , 12263 , 12269 , 12277 , 12281 , 12289 , 12301 , 12323 , 12329 , 12343 , 12347 , 12373 , 12377 , 12379 , 12391 , 12401 , 12409 , 12413 , 12421 , 12433 , 12437 , 12451 , 12457 , 12473 , 12479 , 12487 , 12491 , 12497 , 12503 , 12511 , 12517 , 12527 , 12539 , 12541 , 12547 , 12553 , 12569 , 12577 , 12583 , 12589 , 12601 , 12611 , 12613 , 12619 , 12637 , 12641 , 12647 , 12653 , 12659 , 12671 , 12689 , 12697 , 12703 , 12713 , 12721 , 12739 , 12743 , 12757 , 12763 , 12781 , 12791 , 12799 , 12809 , 12821 , 12823 , 12829 , 12841 , 12853 , 12889 , 12893 , 12899 , 12907 , 12911 , 12917 , 12919 , 12923 , 12941 , 12953 , 12959 , 12967 , 12973 , 12979 , 12983 , 13001 , 13003 , 13007 , 13009 , 13033 , 13037 , 13043 , 13049 , 13063 , 13093 , 13099 , 13103 , 13109 , 13121 , 13127 , 13147 , 13151 , 13159 , 13163 , 13171 , 13177 , 13183 , 13187 , 13217 , 13219 , 13229 , 13241 , 13249 , 13259 , 13267 , 13291 , 13297 , 13309 , 13313 , 13327 , 13331 , 13337 , 13339 , 13367 , 13381 , 13397 , 13399 , 13411 , 13417 , 13421 , 13441 , 13451 , 13457 , 13463 , 13469 , 13477 , 13487 , 13499 , 13513 , 13523 , 13537 , 13553 , 13567 , 13577 , 13591 , 13597 , 13613 , 13619 , 13627 , 13633 , 13649 , 13669 , 13679 , 13681 , 13687 , 13691 , 13693 , 13697 , 13709 , 13711 , 13721 , 13723 , 13729 , 13751 , 13757 , 13759 , 13763 , 13781 , 13789 , 13799 , 13807 , 13829 , 13831 , 13841 , 13859 , 13873 , 13877 , 13879 , 13883 , 13901 , 13903 , 13907 , 13913 , 13921 , 13931 , 13933 , 13963 , 13967 , 13997 , 13999 , 14009 , 14011 , 14029 , 14033 , 14051 , 14057 , 14071 , 14081 , 14083 , 14087 , 14107 , 14143 , 14149 , 14153 , 14159 , 14173 , 14177 , 14197 , 14207 , 14221 , 14243 , 14249 , 14251 , 14281 , 14293 , 14303 , 14321 , 14323 , 14327 , 14341 , 14347 , 14369 , 14387 , 14389 , 14401 , 14407 , 14411 , 14419 , 14423 , 14431 , 14437 , 14447 , 14449 , 14461 , 14479 , 14489 , 14503 , 14519 , 14533 , 14537 , 14543 , 14549 , 14551 , 14557 , 14561 , 14563 , 14591 , 14593 , 14621 , 14627 , 14629 , 14633 , 14639 , 14653 , 14657 , 14669 , 14683 , 14699 , 14713 , 14717 , 14723 , 14731 , 14737 , 14741 , 14747 , 14753 , 14759 , 14767 , 14771 , 14779 , 14783 , 14797 , 14813 , 14821 , 14827 , 14831 , 14843 , 14851 , 14867 , 14869 , 14879 , 14887 , 14891 , 14897 , 14923 , 14929 , 14939 , 14947 , 14951 , 14957 , 14969 , 14983 , 15013 , 15017 , 15031 , 15053 , 15061 , 15073 , 15077 , 15083 , 15091 , 15101 , 15107 , 15121 , 15131 , 15137 , 15139 , 15149 , 15161 , 15173 , 15187 , 15193 , 15199 , 15217 , 15227 , 15233 , 15241 , 15259 , 15263 , 15269 , 15271 , 15277 , 15287 , 15289 , 15299 , 15307 , 15313 , 15319 , 15329 , 15331 , 15349 , 15359 , 15361 , 15373 , 15377 , 15383 , 15391 , 15401 , 15413 , 15427 , 15439 , 15443 , 15451 , 15461 , 15467 , 15473 , 15493 , 15497 , 15511 , 15527 , 15541 , 15551 , 15559 , 15569 , 15581 , 15583 , 15601 , 15607 , 15619 , 15629 , 15641 , 15643 , 15647 , 15649 , 15661 , 15667 , 15671 , 15679 , 15683 , 15727 , 15731 , 15733 , 15737 , 15739 , 15749 , 15761 , 15767 , 15773 , 15787 , 15791 , 15797 , 15803 , 15809 , 15817 , 15823 , 15859 , 15877 , 15881 , 15887 , 15889 , 15901 , 15907 , 15913 , 15919 , 15923 , 15937 , 15959 , 15971 , 15973 , 15991 , 16001 , 16007 , 16033 , 16057 , 16061 , 16063 , 16067 , 16069 , 16073 , 16087 , 16091 , 16097 , 16103 , 16111 , 16127 , 16139 , 16141 , 16183 , 16187 , 16189 , 16193 , 16217 , 16223 , 16229 , 16231 , 16249 , 16253 , 16267 , 16273 , 16301 , 16319 , 16333 , 16339 , 16349 , 16361 , 16363 , 16369 , 16381 , 16411 , 16417 , 16421 , 16427 , 16433 , 16447 , 16451 , 16453 , 16477 , 16481 , 16487 , 16493 , 16519 , 16529 , 16547 , 16553 , 16561 , 16567 , 16573 , 16603 , 16607 , 16619 , 16631 , 16633 , 16649 , 16651 , 16657 , 16661 , 16673 , 16691 , 16693 , 16699 , 16703 , 16729 , 16741 , 16747 , 16759 , 16763 , 16787 , 16811 , 16823 , 16829 , 16831 , 16843 , 16871 , 16879 , 16883 , 16889 , 16901 , 16903 , 16921 , 16927 , 16931 , 16937 , 16943 , 16963 , 16979 , 16981 , 16987 , 16993 , 17011 , 17021 , 17027 , 17029 , 17033 , 17041 , 17047 , 17053 , 17077 , 17093 , 17099 , 17107 , 17117 , 17123 , 17137 , 17159 , 17167 , 17183 , 17189 , 17191 , 17203 , 17207 , 17209 , 17231 , 17239 , 17257 , 17291 , 17293 , 17299 , 17317 , 17321 , 17327 , 17333 , 17341 , 17351 , 17359 , 17377 , 17383 , 17387 , 17389 , 17393 , 17401 , 17417 , 17419 , 17431 , 17443 , 17449 , 17467 , 17471 , 17477 , 17483 , 17489 , 17491 , 17497 , 17509 , 17519 , 17539 , 17551 , 17569 , 17573 , 17579 , 17581 , 17597 , 17599 , 17609 , 17623 , 17627 , 17657 , 17659 , 17669 , 17681 , 17683 , 17707 , 17713 , 17729 , 17737 , 17747 , 17749 , 17761 , 17783 , 17789 , 17791 , 17807 , 17827 , 17837 , 17839 , 17851 , 17863 , 17881 , 17891 , 17903 , 17909 , 17911 , 17921 , 17923 , 17929 , 17939 , 17957 , 17959 , 17971 , 17977 , 17981 , 17987 , 17989 , 18013 , 18041 , 18043 , 18047 , 18049 , 18059 , 18061 , 18077 , 18089 , 18097 , 18119 , 18121 , 18127 , 18131 , 18133 , 18143 , 18149 , 18169 , 18181 , 18191 , 18199 , 18211 , 18217 , 18223 , 18229 , 18233 , 18251 , 18253 , 18257 , 18269 , 18287 , 18289 , 18301 , 18307 , 18311 , 18313 , 18329 , 18341 , 18353 , 18367 , 18371 , 18379 , 18397 , 18401 , 18413 , 18427 , 18433 , 18439 , 18443 , 18451 , 18457 , 18461 , 18481 , 18493 , 18503 , 18517 , 18521 , 18523 , 18539 , 18541 , 18553 , 18583 , 18587 , 18593 , 18617 , 18637 , 18661 , 18671 , 18679 , 18691 , 18701 , 18713 , 18719 , 18731 , 18743 , 18749 , 18757 , 18773 , 18787 , 18793 , 18797 , 18803 , 18839 , 18859 , 18869 , 18899 , 18911 , 18913 , 18917 , 18919 , 18947 , 18959 , 18973 , 18979 , 19001 , 19009 , 19013 , 19031 , 19037 , 19051 , 19069 , 19073 , 19079 , 19081 , 19087 , 19121 , 19139 , 19141 , 19157 , 19163 , 19181 , 19183 , 19207 , 19211 , 19213 , 19219 , 19231 , 19237 , 19249 , 19259 , 19267 , 19273 , 19289 , 19301 , 19309 , 19319 , 19333 , 19373 , 19379 , 19381 , 19387 , 19391 , 19403 , 19417 , 19421 , 19423 , 19427 , 19429 , 19433 , 19441 , 19447 , 19457 , 19463 , 19469 , 19471 , 19477 , 19483 , 19489 , 19501 , 19507 , 19531 , 19541 , 19543 , 19553 , 19559 , 19571 , 19577 , 19583 , 19597 , 19603 , 19609 , 19661 , 19681 , 19687 , 19697 , 19699 , 19709 , 19717 , 19727 , 19739 , 19751 , 19753 , 19759 , 19763 , 19777 , 19793 , 19801 , 19813 , 19819 , 19841 , 19843 , 19853 , 19861 , 19867 , 19889 , 19891 , 19913 , 19919 , 19927 , 19937 , 19949 , 19961 , 19963 , 19973 , 19979 , 19991 , 19993 , 19997 , 20011 , 20021 , 20023 , 20029 , 20047 , 20051 , 20063 , 20071 , 20089 , 20101 , 20107 , 20113 , 20117 , 20123 , 20129 , 20143 , 20147 , 20149 , 20161 , 20173 , 20177 , 20183 , 20201 , 20219 , 20231 , 20233 , 20249 , 20261 , 20269 , 20287 , 20297 , 20323 , 20327 , 20333 , 20341 , 20347 , 20353 , 20357 , 20359 , 20369 , 20389 , 20393 , 20399 , 20407 , 20411 , 20431 , 20441 , 20443 , 20477 , 20479 , 20483 , 20507 , 20509 , 20521 , 20533 , 20543 , 20549 , 20551 , 20563 , 20593 , 20599 , 20611 , 20627 , 20639 , 20641 , 20663 , 20681 , 20693 , 20707 , 20717 , 20719 , 20731 , 20743 , 20747 , 20749 , 20753 , 20759 , 20771 , 20773 , 20789 , 20807 , 20809 , 20849 , 20857 , 20873 , 20879 , 20887 , 20897 , 20899 , 20903 , 20921 , 20929 , 20939 , 20947 , 20959 , 20963 , 20981 , 20983 , 21001 , 21011 , 21013 , 21017 , 21019 , 21023 , 21031 , 21059 , 21061 , 21067 , 21089 , 21101 , 21107 , 21121 , 21139 , 21143 , 21149 , 21157 , 21163 , 21169 , 21179 , 21187 , 21191 , 21193 , 21211 , 21221 , 21227 , 21247 , 21269 , 21277 , 21283 , 21313 , 21317 , 21319 , 21323 , 21341 , 21347 , 21377 , 21379 , 21383 , 21391 , 21397 , 21401 , 21407 , 21419 , 21433 , 21467 , 21481 , 21487 , 21491 , 21493 , 21499 , 21503 , 21517 , 21521 , 21523 , 21529 , 21557 , 21559 , 21563 , 21569 , 21577 , 21587 , 21589 , 21599 , 21601 , 21611 , 21613 , 21617 , 21647 , 21649 , 21661 , 21673 , 21683 , 21701 , 21713 , 21727 , 21737 , 21739 , 21751 , 21757 , 21767 , 21773 , 21787 , 21799 , 21803 , 21817 , 21821 , 21839 , 21841 , 21851 , 21859 , 21863 , 21871 , 21881 , 21893 , 21911 , 21929 , 21937 , 21943 , 21961 , 21977 , 21991 , 21997 , 22003 , 22013 , 22027 , 22031 , 22037 , 22039 , 22051 , 22063 , 22067 , 22073 , 22079 , 22091 , 22093 , 22109 , 22111 , 22123 , 22129 , 22133 , 22147 , 22153 , 22157 , 22159 , 22171 , 22189 , 22193 , 22229 , 22247 , 22259 , 22271 , 22273 , 22277 , 22279 , 22283 , 22291 , 22303 , 22307 , 22343 , 22349 , 22367 , 22369 , 22381 , 22391 , 22397 , 22409 , 22433 , 22441 , 22447 , 22453 , 22469 , 22481 , 22483 , 22501 , 22511 , 22531 , 22541 , 22543 , 22549 , 22567 , 22571 , 22573 , 22613 , 22619 , 22621 , 22637 , 22639 , 22643 , 22651 , 22669 , 22679 , 22691 , 22697 , 22699 , 22709 , 22717 , 22721 , 22727 , 22739 , 22741 , 22751 , 22769 , 22777 , 22783 , 22787 , 22807 , 22811 , 22817 , 22853 , 22859 , 22861 , 22871 , 22877 , 22901 , 22907 , 22921 , 22937 , 22943 , 22961 , 22963 , 22973 , 22993 , 23003 , 23011 , 23017 , 23021 , 23027 , 23029 , 23039 , 23041 , 23053 , 23057 , 23059 , 23063 , 23071 , 23081 , 23087 , 23099 , 23117 , 23131 , 23143 , 23159 , 23167 , 23173 , 23189 , 23197 , 23201 , 23203 , 23209 , 23227 , 23251 , 23269 , 23279 , 23291 , 23293 , 23297 , 23311 , 23321 , 23327 , 23333 , 23339 , 23357 , 23369 , 23371 , 23399 , 23417 , 23431 , 23447 , 23459 , 23473 , 23497 , 23509 , 23531 , 23537 , 23539 , 23549 , 23557 , 23561 , 23563 , 23567 , 23581 , 23593 , 23599 , 23603 , 23609 , 23623 , 23627 , 23629 , 23633 , 23663 , 23669 , 23671 , 23677 , 23687 , 23689 , 23719 , 23741 , 23743 , 23747 , 23753 , 23761 , 23767 , 23773 , 23789 , 23801 , 23813 , 23819 , 23827 , 23831 , 23833 , 23857 , 23869 , 23873 , 23879 , 23887 , 23893 , 23899 , 23909 , 23911 , 23917 , 23929 , 23957 , 23971 , 23977 , 23981 , 23993 , 24001 , 24007 , 24019 , 24023 , 24029 , 24043 , 24049 , 24061 , 24071 , 24077 , 24083 , 24091 , 24097 , 24103 , 24107 , 24109 , 24113 , 24121 , 24133 , 24137 , 24151 , 24169 , 24179 , 24181 , 24197 , 24203 , 24223 , 24229 , 24239 , 24247 , 24251 , 24281 , 24317 , 24329 , 24337 , 24359 , 24371 , 24373 , 24379 , 24391 , 24407 , 24413 , 24419 , 24421 , 24439 , 24443 , 24469 , 24473 , 24481 , 24499 , 24509 , 24517 , 24527 , 24533 , 24547 , 24551 , 24571 , 24593 , 24611 , 24623 , 24631 , 24659 , 24671 , 24677 , 24683 , 24691 , 24697 , 24709 , 24733 , 24749 , 24763 , 24767 , 24781 , 24793 , 24799 , 24809 , 24821 , 24841 , 24847 , 24851 , 24859 , 24877 , 24889 , 24907 , 24917 , 24919 , 24923 , 24943 , 24953 , 24967 , 24971 , 24977 , 24979 , 24989 , 25013 , 25031 , 25033 , 25037 , 25057 , 25073 , 25087 , 25097 , 25111 , 25117 , 25121 , 25127 , 25147 , 25153 , 25163 , 25169 , 25171 , 25183 , 25189 , 25219 , 25229 , 25237 , 25243 , 25247 , 25253 , 25261 , 25301 , 25303 , 25307 , 25309 , 25321 , 25339 , 25343 , 25349 , 25357 , 25367 , 25373 , 25391 , 25409 , 25411 , 25423 , 25439 , 25447 , 25453 , 25457 , 25463 , 25469 , 25471 , 25523 , 25537 , 25541 , 25561 , 25577 , 25579 , 25583 , 25589 , 25601 , 25603 , 25609 , 25621 , 25633 , 25639 , 25643 , 25657 , 25667 , 25673 , 25679 , 25693 , 25703 , 25717 , 25733 , 25741 , 25747 , 25759 , 25763 , 25771 , 25793 , 25799 , 25801 , 25819 , 25841 , 25847 , 25849 , 25867 , 25873 , 25889 , 25903 , 25913 , 25919 , 25931 , 25933 , 25939 , 25943 , 25951 , 25969 , 25981 , 25997 , 25999 , 26003 , 26017 , 26021 , 26029 , 26041 , 26053 , 26083 , 26099 , 26107 , 26111 , 26113 , 26119 , 26141 , 26153 , 26161 , 26171 , 26177 , 26183 , 26189 , 26203 , 26209 , 26227 , 26237 , 26249 , 26251 , 26261 , 26263 , 26267 , 26293 , 26297 , 26309 , 26317 , 26321 , 26339 , 26347 , 26357 , 26371 , 26387 , 26393 , 26399 , 26407 , 26417 , 26423 , 26431 , 26437 , 26449 , 26459 , 26479 , 26489 , 26497 , 26501 , 26513 , 26539 , 26557 , 26561 , 26573 , 26591 , 26597 , 26627 , 26633 , 26641 , 26647 , 26669 , 26681 , 26683 , 26687 , 26693 , 26699 , 26701 , 26711 , 26713 , 26717 , 26723 , 26729 , 26731 , 26737 , 26759 , 26777 , 26783 , 26801 , 26813 , 26821 , 26833 , 26839 , 26849 , 26861 , 26863 , 26879 , 26881 , 26891 , 26893 , 26903 , 26921 , 26927 , 26947 , 26951 , 26953 , 26959 , 26981 , 26987 , 26993 , 27011 , 27017 , 27031 , 27043 , 27059 , 27061 , 27067 , 27073 , 27077 , 27091 , 27103 , 27107 , 27109 , 27127 , 27143 , 27179 , 27191 , 27197 , 27211 , 27239 , 27241 , 27253 , 27259 , 27271 , 27277 , 27281 , 27283 , 27299 , 27329 , 27337 , 27361 , 27367 , 27397 , 27407 , 27409 , 27427 , 27431 , 27437 , 27449 , 27457 , 27479 , 27481 , 27487 , 27509 , 27527 , 27529 , 27539 , 27541 , 27551 , 27581 , 27583 , 27611 , 27617 , 27631 , 27647 , 27653 , 27673 , 27689 , 27691 , 27697 , 27701 , 27733 , 27737 , 27739 , 27743 , 27749 , 27751 , 27763 , 27767 , 27773 , 27779 , 27791 , 27793 , 27799 , 27803 , 27809 , 27817 , 27823 , 27827 , 27847 , 27851 , 27883 , 27893 , 27901 , 27917 , 27919 , 27941 , 27943 , 27947 , 27953 , 27961 , 27967 , 27983 , 27997 , 28001 , 28019 , 28027 , 28031 , 28051 , 28057 , 28069 , 28081 , 28087 , 28097 , 28099 , 28109 , 28111 , 28123 , 28151 , 28163 , 28181 , 28183 , 28201 , 28211 , 28219 , 28229 , 28277 , 28279 , 28283 , 28289 , 28297 , 28307 , 28309 , 28319 , 28349 , 28351 , 28387 , 28393 , 28403 , 28409 , 28411 , 28429 , 28433 , 28439 , 28447 , 28463 , 28477 , 28493 , 28499 , 28513 , 28517 , 28537 , 28541 , 28547 , 28549 , 28559 , 28571 , 28573 , 28579 , 28591 , 28597 , 28603 , 28607 , 28619 , 28621 , 28627 , 28631 , 28643 , 28649 , 28657 , 28661 , 28663 , 28669 , 28687 , 28697 , 28703 , 28711 , 28723 , 28729 , 28751 , 28753 , 28759 , 28771 , 28789 , 28793 , 28807 , 28813 , 28817 , 28837 , 28843 , 28859 , 28867 , 28871 , 28879 , 28901 , 28909 , 28921 , 28927 , 28933 , 28949 , 28961 , 28979 , 29009 , 29017 , 29021 , 29023 , 29027 , 29033 , 29059 , 29063 , 29077 , 29101 , 29123 , 29129 , 29131 , 29137 , 29147 , 29153 , 29167 , 29173 , 29179 , 29191 , 29201 , 29207 , 29209 , 29221 , 29231 , 29243 , 29251 , 29269 , 29287 , 29297 , 29303 , 29311 , 29327 , 29333 , 29339 , 29347 , 29363 , 29383 , 29387 , 29389 , 29399 , 29401 , 29411 , 29423 , 29429 , 29437 , 29443 , 29453 , 29473 , 29483 , 29501 , 29527 , 29531 , 29537 , 29567 , 29569 , 29573 , 29581 , 29587 , 29599 , 29611 , 29629 , 29633 , 29641 , 29663 , 29669 , 29671 , 29683 , 29717 , 29723 , 29741 , 29753 , 29759 , 29761 , 29789 , 29803 , 29819 , 29833 , 29837 , 29851 , 29863 , 29867 , 29873 , 29879 , 29881 , 29917 , 29921 , 29927 , 29947 , 29959 , 29983 , 29989 , 30011 , 30013 , 30029 , 30047 , 30059 , 30071 , 30089 , 30091 , 30097 , 30103 , 30109 , 30113 , 30119 , 30133 , 30137 , 30139 , 30161 , 30169 , 30181 , 30187 , 30197 , 30203 , 30211 , 30223 , 30241 , 30253 , 30259 , 30269 , 30271 , 30293 , 30307 , 30313 , 30319 , 30323 , 30341 , 30347 , 30367 , 30389 , 30391 , 30403 , 30427 , 30431 , 30449 , 30467 , 30469 , 30491 , 30493 , 30497 , 30509 , 30517 , 30529 , 30539 , 30553 , 30557 , 30559 , 30577 , 30593 , 30631 , 30637 , 30643 , 30649 , 30661 , 30671 , 30677 , 30689 , 30697 , 30703 , 30707 , 30713 , 30727 , 30757 , 30763 , 30773 , 30781 , 30803 , 30809 , 30817 , 30829 , 30839 , 30841 , 30851 , 30853 , 30859 , 30869 , 30871 , 30881 , 30893 , 30911 , 30931 , 30937 , 30941 , 30949 , 30971 , 30977 , 30983 , 31013 , 31019 , 31033 , 31039 , 31051 , 31063 , 31069 , 31079 , 31081 , 31091 , 31121 , 31123 , 31139 , 31147 , 31151 , 31153 , 31159 , 31177 , 31181 , 31183 , 31189 , 31193 , 31219 , 31223 , 31231 , 31237 , 31247 , 31249 , 31253 , 31259 , 31267 , 31271 , 31277 , 31307 , 31319 , 31321 , 31327 , 31333 , 31337 , 31357 , 31379 , 31387 , 31391 , 31393 , 31397 , 31469 , 31477 , 31481 , 31489 , 31511 , 31513 , 31517 , 31531 , 31541 , 31543 , 31547 , 31567 , 31573 , 31583 , 31601 , 31607 , 31627 , 31643 , 31649 , 31657 , 31663 , 31667 , 31687 , 31699 , 31721 , 31723 , 31727 , 31729 , 31741 , 31751 , 31769 , 31771 , 31793 , 31799 , 31817 , 31847 , 31849 , 31859 , 31873 , 31883 , 31891 , 31907 , 31957 , 31963 , 31973 , 31981 , 31991 , 32003 , 32009 , 32027 , 32029 , 32051 , 32057 , 32059 , 32063 , 32069 , 32077 , 32083 , 32089 , 32099 , 32117 , 32119 , 32141 , 32143 , 32159 , 32173 , 32183 , 32189 , 32191 , 32203 , 32213 , 32233 , 32237 , 32251 , 32257 , 32261 , 32297 , 32299 , 32303 , 32309 , 32321 , 32323 , 32327 , 32341 , 32353 , 32359 , 32363 , 32369 , 32371 , 32377 , 32381 , 32401 , 32411 , 32413 , 32423 , 32429 , 32441 , 32443 , 32467 , 32479 , 32491 , 32497 , 32503 , 32507 , 32531 , 32533 , 32537 , 32561 , 32563 , 32569 , 32573 , 32579 , 32587 , 32603 , 32609 , 32611 , 32621 , 32633 , 32647 , 32653 , 32687 , 32693 , 32707 , 32713 , 32717 , 32719 , 32749 , 32771 , 32779 , 32783 , 32789 , 32797 , 32801 , 32803 , 32831 , 32833 , 32839 , 32843 , 32869 , 32887 , 32909 , 32911 , 32917 , 32933 , 32939 , 32941 , 32957 , 32969 , 32971 , 32983 , 32987 , 32993 , 32999 , 33013 , 33023 , 33029 , 33037 , 33049 , 33053 , 33071 , 33073 , 33083 , 33091 , 33107 , 33113 , 33119 , 33149 , 33151 , 33161 , 33179 , 33181 , 33191 , 33199 , 33203 , 33211 , 33223 , 33247 , 33287 , 33289 , 33301 , 33311 , 33317 , 33329 , 33331 , 33343 , 33347 , 33349 , 33353 , 33359 , 33377 , 33391 , 33403 , 33409 , 33413 , 33427 , 33457 , 33461 , 33469 , 33479 , 33487 , 33493 , 33503 , 33521 , 33529 , 33533 , 33547 , 33563 , 33569 , 33577 , 33581 , 33587 , 33589 , 33599 , 33601 , 33613 , 33617 , 33619 , 33623 , 33629 , 33637 , 33641 , 33647 , 33679 , 33703 , 33713 , 33721 , 33739 , 33749 , 33751 , 33757 , 33767 , 33769 , 33773 , 33791 , 33797 , 33809 , 33811 , 33827 , 33829 , 33851 , 33857 , 33863 , 33871 , 33889 , 33893 , 33911 , 33923 , 33931 , 33937 , 33941 , 33961 , 33967 , 33997 , 34019 , 34031 , 34033 , 34039 , 34057 , 34061 , 34123 , 34127 , 34129 , 34141 , 34147 , 34157 , 34159 , 34171 , 34183 , 34211 , 34213 , 34217 , 34231 , 34253 , 34259 , 34261 , 34267 , 34273 , 34283 , 34297 , 34301 , 34303 , 34313 , 34319 , 34327 , 34337 , 34351 , 34361 , 34367 , 34369 , 34381 , 34403 , 34421 , 34429 , 34439 , 34457 , 34469 , 34471 , 34483 , 34487 , 34499 , 34501 , 34511 , 34513 , 34519 , 34537 , 34543 , 34549 , 34583 , 34589 , 34591 , 34603 , 34607 , 34613 , 34631 , 34649 , 34651 , 34667 , 34673 , 34679 , 34687 , 34693 , 34703 , 34721 , 34729 , 34739 , 34747 , 34757 , 34759 , 34763 , 34781 , 34807 , 34819 , 34841 , 34843 , 34847 , 34849 , 34871 , 34877 , 34883 , 34897 , 34913 , 34919 , 34939 , 34949 , 34961 , 34963 , 34981 , 35023 , 35027 , 35051 , 35053 , 35059 , 35069 , 35081 , 35083 , 35089 , 35099 , 35107 , 35111 , 35117 , 35129 , 35141 , 35149 , 35153 , 35159 , 35171 , 35201 , 35221 , 35227 , 35251 , 35257 , 35267 , 35279 , 35281 , 35291 , 35311 , 35317 , 35323 , 35327 , 35339 , 35353 , 35363 , 35381 , 35393 , 35401 , 35407 , 35419 , 35423 , 35437 , 35447 , 35449 , 35461 , 35491 , 35507 , 35509 , 35521 , 35527 , 35531 , 35533 , 35537 , 35543 , 35569 , 35573 , 35591 , 35593 , 35597 , 35603 , 35617 , 35671 , 35677 , 35729 , 35731 , 35747 , 35753 , 35759 , 35771 , 35797 , 35801 , 35803 , 35809 , 35831 , 35837 , 35839 , 35851 , 35863 , 35869 , 35879 , 35897 , 35899 , 35911 , 35923 , 35933 , 35951 , 35963 , 35969 , 35977 , 35983 , 35993 , 35999 , 36007 , 36011 , 36013 , 36017 , 36037 , 36061 , 36067 , 36073 , 36083 , 36097 , 36107 , 36109 , 36131 , 36137 , 36151 , 36161 , 36187 , 36191 , 36209 , 36217 , 36229 , 36241 , 36251 , 36263 , 36269 , 36277 , 36293 , 36299 , 36307 , 36313 , 36319 , 36341 , 36343 , 36353 , 36373 , 36383 , 36389 , 36433 , 36451 , 36457 , 36467 , 36469 , 36473 , 36479 , 36493 , 36497 , 36523 , 36527 , 36529 , 36541 , 36551 , 36559 , 36563 , 36571 , 36583 , 36587 , 36599 , 36607 , 36629 , 36637 , 36643 , 36653 , 36671 , 36677 , 36683 , 36691 , 36697 , 36709 , 36713 , 36721 , 36739 , 36749 , 36761 , 36767 , 36779 , 36781 , 36787 , 36791 , 36793 , 36809 , 36821 , 36833 , 36847 , 36857 , 36871 , 36877 , 36887 , 36899 , 36901 , 36913 , 36919 , 36923 , 36929 , 36931 , 36943 , 36947 , 36973 , 36979 , 36997 , 37003 , 37013 , 37019 , 37021 , 37039 , 37049 , 37057 , 37061 , 37087 , 37097 , 37117 , 37123 , 37139 , 37159 , 37171 , 37181 , 37189 , 37199 , 37201 , 37217 , 37223 , 37243 , 37253 , 37273 , 37277 , 37307 , 37309 , 37313 , 37321 , 37337 , 37339 , 37357 , 37361 , 37363 , 37369 , 37379 , 37397 , 37409 , 37423 , 37441 , 37447 , 37463 , 37483 , 37489 , 37493 , 37501 , 37507 , 37511 , 37517 , 37529 , 37537 , 37547 , 37549 , 37561 , 37567 , 37571 , 37573 , 37579 , 37589 , 37591 , 37607 , 37619 , 37633 , 37643 , 37649 , 37657 , 37663 , 37691 , 37693 , 37699 , 37717 , 37747 , 37781 , 37783 , 37799 , 37811 , 37813 , 37831 , 37847 , 37853 , 37861 , 37871 , 37879 , 37889 , 37897 , 37907 , 37951 , 37957 , 37963 , 37967 , 37987 , 37991 , 37993 , 37997 , 38011 , 38039 , 38047 , 38053 , 38069 , 38083 , 38113 , 38119 , 38149 , 38153 , 38167 , 38177 , 38183 , 38189 , 38197 , 38201 , 38219 , 38231 , 38237 , 38239 , 38261 , 38273 , 38281 , 38287 , 38299 , 38303 , 38317 , 38321 , 38327 , 38329 , 38333 , 38351 , 38371 , 38377 , 38393 , 38431 , 38447 , 38449 , 38453 , 38459 , 38461 , 38501 , 38543 , 38557 , 38561 , 38567 , 38569 , 38593 , 38603 , 38609 , 38611 , 38629 , 38639 , 38651 , 38653 , 38669 , 38671 , 38677 , 38693 , 38699 , 38707 , 38711 , 38713 , 38723 , 38729 , 38737 , 38747 , 38749 , 38767 , 38783 , 38791 , 38803 , 38821 , 38833 , 38839 , 38851 , 38861 , 38867 , 38873 , 38891 , 38903 , 38917 , 38921 , 38923 , 38933 , 38953 , 38959 , 38971 , 38977 , 38993 , 39019 , 39023 , 39041 , 39043 , 39047 , 39079 , 39089 , 39097 , 39103 , 39107 , 39113 , 39119 , 39133 , 39139 , 39157 , 39161 , 39163 , 39181 , 39191 , 39199 , 39209 , 39217 , 39227 , 39229 , 39233 , 39239 , 39241 , 39251 , 39293 , 39301 , 39313 , 39317 , 39323 , 39341 , 39343 , 39359 , 39367 , 39371 , 39373 , 39383 , 39397 , 39409 , 39419 , 39439 , 39443 , 39451 , 39461 , 39499 , 39503 , 39509 , 39511 , 39521 , 39541 , 39551 , 39563 , 39569 , 39581 , 39607 , 39619 , 39623 , 39631 , 39659 , 39667 , 39671 , 39679 , 39703 , 39709 , 39719 , 39727 , 39733 , 39749 , 39761 , 39769 , 39779 , 39791 , 39799 , 39821 , 39827 , 39829 , 39839 , 39841 , 39847 , 39857 , 39863 , 39869 , 39877 , 39883 , 39887 , 39901 , 39929 , 39937 , 39953 , 39971 , 39979 , 39983 , 39989 , 40009 , 40013 , 40031 , 40037 , 40039 , 40063 , 40087 , 40093 , 40099 , 40111 , 40123 , 40127 , 40129 , 40151 , 40153 , 40163 , 40169 , 40177 , 40189 , 40193 , 40213 , 40231 , 40237 , 40241 , 40253 , 40277 , 40283 , 40289 , 40343 , 40351 , 40357 , 40361 , 40387 , 40423 , 40427 , 40429 , 40433 , 40459 , 40471 , 40483 , 40487 , 40493 , 40499 , 40507 , 40519 , 40529 , 40531 , 40543 , 40559 , 40577 , 40583 , 40591 , 40597 , 40609 , 40627 , 40637 , 40639 , 40693 , 40697 , 40699 , 40709 , 40739 , 40751 , 40759 , 40763 , 40771 , 40787 , 40801 , 40813 , 40819 , 40823 , 40829 , 40841 , 40847 , 40849 , 40853 , 40867 , 40879 , 40883 , 40897 , 40903 , 40927 , 40933 , 40939 , 40949 , 40961 , 40973 , 40993 , 41011 , 41017 , 41023 , 41039 , 41047 , 41051 , 41057 , 41077 , 41081 , 41113 , 41117 , 41131 , 41141 , 41143 , 41149 , 41161 , 41177 , 41179 , 41183 , 41189 , 41201 , 41203 , 41213 , 41221 , 41227 , 41231 , 41233 , 41243 , 41257 , 41263 , 41269 , 41281 , 41299 , 41333 , 41341 , 41351 , 41357 , 41381 , 41387 , 41389 , 41399 , 41411 , 41413 , 41443 , 41453 , 41467 , 41479 , 41491 , 41507 , 41513 , 41519 , 41521 , 41539 , 41543 , 41549 , 41579 , 41593 , 41597 , 41603 , 41609 , 41611 , 41617 , 41621 , 41627 , 41641 , 41647 , 41651 , 41659 , 41669 , 41681 , 41687 , 41719 , 41729 , 41737 , 41759 , 41761 , 41771 , 41777 , 41801 , 41809 , 41813 , 41843 , 41849 , 41851 , 41863 , 41879 , 41887 , 41893 , 41897 , 41903 , 41911 , 41927 , 41941 , 41947 , 41953 , 41957 , 41959 , 41969 , 41981 , 41983 , 41999 , 42013 , 42017 , 42019 , 42023 , 42043 , 42061 , 42071 , 42073 , 42083 , 42089 , 42101 , 42131 , 42139 , 42157 , 42169 , 42179 , 42181 , 42187 , 42193 , 42197 , 42209 , 42221 , 42223 , 42227 , 42239 , 42257 , 42281 , 42283 , 42293 , 42299 , 42307 , 42323 , 42331 , 42337 , 42349 , 42359 , 42373 , 42379 , 42391 , 42397 , 42403 , 42407 , 42409 , 42433 , 42437 , 42443 , 42451 , 42457 , 42461 , 42463 , 42467 , 42473 , 42487 , 42491 , 42499 , 42509 , 42533 , 42557 , 42569 , 42571 , 42577 , 42589 , 42611 , 42641 , 42643 , 42649 , 42667 , 42677 , 42683 , 42689 , 42697 , 42701 , 42703 , 42709 , 42719 , 42727 , 42737 , 42743 , 42751 , 42767 , 42773 , 42787 , 42793 , 42797 , 42821 , 42829 , 42839 , 42841 , 42853 , 42859 , 42863 , 42899 , 42901 , 42923 , 42929 , 42937 , 42943 , 42953 , 42961 , 42967 , 42979 , 42989 , 43003 , 43013 , 43019 , 43037 , 43049 , 43051 , 43063 , 43067 , 43093 , 43103 , 43117 , 43133 , 43151 , 43159 , 43177 , 43189 , 43201 , 43207 , 43223 , 43237 , 43261 , 43271 , 43283 , 43291 , 43313 , 43319 , 43321 , 43331 , 43391 , 43397 , 43399 , 43403 , 43411 , 43427 , 43441 , 43451 , 43457 , 43481 , 43487 , 43499 , 43517 , 43541 , 43543 , 43573 , 43577 , 43579 , 43591 , 43597 , 43607 , 43609 , 43613 , 43627 , 43633 , 43649 , 43651 , 43661 , 43669 , 43691 , 43711 , 43717 , 43721 , 43753 , 43759 , 43777 , 43781 , 43783 , 43787 , 43789 , 43793 , 43801 , 43853 , 43867 , 43889 , 43891 , 43913 , 43933 , 43943 , 43951 , 43961 , 43963 , 43969 , 43973 , 43987 , 43991 , 43997 , 44017 , 44021 , 44027 , 44029 , 44041 , 44053 , 44059 , 44071 , 44087 , 44089 , 44101 , 44111 , 44119 , 44123 , 44129 , 44131 , 44159 , 44171 , 44179 , 44189 , 44201 , 44203 , 44207 , 44221 , 44249 , 44257 , 44263 , 44267 , 44269 , 44273 , 44279 , 44281 , 44293 , 44351 , 44357 , 44371 , 44381 , 44383 , 44389 , 44417 , 44449 , 44453 , 44483 , 44491 , 44497 , 44501 , 44507 , 44519 , 44531 , 44533 , 44537 , 44543 , 44549 , 44563 , 44579 , 44587 , 44617 , 44621 , 44623 , 44633 , 44641 , 44647 , 44651 , 44657 , 44683 , 44687 , 44699 , 44701 , 44711 , 44729 , 44741 , 44753 , 44771 , 44773 , 44777 , 44789 , 44797 , 44809 , 44819 , 44839 , 44843 , 44851 , 44867 , 44879 , 44887 , 44893 , 44909 , 44917 , 44927 , 44939 , 44953 , 44959 , 44963 , 44971 , 44983 , 44987 , 45007 , 45013 , 45053 , 45061 , 45077 , 45083 , 45119 , 45121 , 45127 , 45131 , 45137 , 45139 , 45161 , 45179 , 45181 , 45191 , 45197 , 45233 , 45247 , 45259 , 45263 , 45281 , 45289 , 45293 , 45307 , 45317 , 45319 , 45329 , 45337 , 45341 , 45343 , 45361 , 45377 , 45389 , 45403 , 45413 , 45427 , 45433 , 45439 , 45481 , 45491 , 45497 , 45503 , 45523 , 45533 , 45541 , 45553 , 45557 , 45569 , 45587 , 45589 , 45599 , 45613 , 45631 , 45641 , 45659 , 45667 , 45673 , 45677 , 45691 , 45697 , 45707 , 45737 , 45751 , 45757 , 45763 , 45767 , 45779 , 45817 , 45821 , 45823 , 45827 , 45833 , 45841 , 45853 , 45863 , 45869 , 45887 , 45893 , 45943 , 45949 , 45953 , 45959 , 45971 , 45979 , 45989 , 46021 , 46027 , 46049 , 46051 , 46061 , 46073 , 46091 , 46093 , 46099 , 46103 , 46133 , 46141 , 46147 , 46153 , 46171 , 46181 , 46183 , 46187 , 46199 , 46219 , 46229 , 46237 , 46261 , 46271 , 46273 , 46279 , 46301 , 46307 , 46309 , 46327 , 46337 , 46349 , 46351 , 46381 , 46399 , 46411 , 46439 , 46441 , 46447 , 46451 , 46457 , 46471 , 46477 , 46489 , 46499 , 46507 , 46511 , 46523 , 46549 , 46559 , 46567 , 46573 , 46589 , 46591 , 46601 , 46619 , 46633 , 46639 , 46643 , 46649 , 46663 , 46679 , 46681 , 46687 , 46691 , 46703 , 46723 , 46727 , 46747 , 46751 , 46757 , 46769 , 46771 , 46807 , 46811 , 46817 , 46819 , 46829 , 46831 , 46853 , 46861 , 46867 , 46877 , 46889 , 46901 , 46919 , 46933 , 46957 , 46993 , 46997 , 47017 , 47041 , 47051 , 47057 , 47059 , 47087 , 47093 , 47111 , 47119 , 47123 , 47129 , 47137 , 47143 , 47147 , 47149 , 47161 , 47189 , 47207 , 47221 , 47237 , 47251 , 47269 , 47279 , 47287 , 47293 , 47297 , 47303 , 47309 , 47317 , 47339 , 47351 , 47353 , 47363 , 47381 , 47387 , 47389 , 47407 , 47417 , 47419 , 47431 , 47441 , 47459 , 47491 , 47497 , 47501 , 47507 , 47513 , 47521 , 47527 , 47533 , 47543 , 47563 , 47569 , 47581 , 47591 , 47599 , 47609 , 47623 , 47629 , 47639 , 47653 , 47657 , 47659 , 47681 , 47699 , 47701 , 47711 , 47713 , 47717 , 47737 , 47741 , 47743 , 47777 , 47779 , 47791 , 47797 , 47807 , 47809 , 47819 , 47837 , 47843 , 47857 , 47869 , 47881 , 47903 , 47911 , 47917 , 47933 , 47939 , 47947 , 47951 , 47963 , 47969 , 47977 , 47981 , 48017 , 48023 , 48029 , 48049 , 48073 , 48079 , 48091 , 48109 , 48119 , 48121 , 48131 , 48157 , 48163 , 48179 , 48187 , 48193 , 48197 , 48221 , 48239 , 48247 , 48259 , 48271 , 48281 , 48299 , 48311 , 48313 , 48337 , 48341 , 48353 , 48371 , 48383 , 48397 , 48407 , 48409 , 48413 , 48437 , 48449 , 48463 , 48473 , 48479 , 48481 , 48487 , 48491 , 48497 , 48523 , 48527 , 48533 , 48539 , 48541 , 48563 , 48571 , 48589 , 48593 , 48611 , 48619 , 48623 , 48647 , 48649 , 48661 , 48673 , 48677 , 48679 , 48731 , 48733 , 48751 , 48757 , 48761 , 48767 , 48779 , 48781 , 48787 , 48799 , 48809 , 48817 , 48821 , 48823 , 48847 , 48857 , 48859 , 48869 , 48871 , 48883 , 48889 , 48907 , 48947 , 48953 , 48973 , 48989 , 48991 , 49003 , 49009 , 49019 , 49031 , 49033 , 49037 , 49043 , 49057 , 49069 , 49081 , 49103 , 49109 , 49117 , 49121 , 49123 , 49139 , 49157 , 49169 , 49171 , 49177 , 49193 , 49199 , 49201 , 49207 , 49211 , 49223 , 49253 , 49261 , 49277 , 49279 , 49297 , 49307 , 49331 , 49333 , 49339 , 49363 , 49367 , 49369 , 49391 , 49393 , 49409 , 49411 , 49417 , 49429 , 49433 , 49451 , 49459 , 49463 , 49477 , 49481 , 49499 , 49523 , 49529 , 49531 , 49537 , 49547 , 49549 , 49559 , 49597 , 49603 , 49613 , 49627 , 49633 , 49639 , 49663 , 49667 , 49669 , 49681 , 49697 , 49711 , 49727 , 49739 , 49741 , 49747 , 49757 , 49783 , 49787 , 49789 , 49801 , 49807 , 49811 , 49823 , 49831 , 49843 , 49853 , 49871 , 49877 , 49891 , 49919 , 49921 , 49927 , 49937 , 49939 , 49943 , 49957 , 49991 , 49993 , 49999 , 50021 , 50023 , 50033 , 50047 , 50051 , 50053 , 50069 , 50077 , 50087 , 50093 , 50101 , 50111 , 50119 , 50123 , 50129 , 50131 , 50147 , 50153 , 50159 , 50177 , 50207 , 50221 , 50227 , 50231 , 50261 , 50263 , 50273 , 50287 , 50291 , 50311 , 50321 , 50329 , 50333 , 50341 , 50359 , 50363 , 50377 , 50383 , 50387 , 50411 , 50417 , 50423 , 50441 , 50459 , 50461 , 50497 , 50503 , 50513 , 50527 , 50539 , 50543 , 50549 , 50551 , 50581 , 50587 , 50591 , 50593 , 50599 , 50627 , 50647 , 50651 , 50671 , 50683 , 50707 , 50723 , 50741 , 50753 , 50767 , 50773 , 50777 , 50789 , 50821 , 50833 , 50839 , 50849 , 50857 , 50867 , 50873 , 50891 , 50893 , 50909 , 50923 , 50929 , 50951 , 50957 , 50969 , 50971 , 50989 , 50993 , 51001 , 51031 , 51043 , 51047 , 51059 , 51061 , 51071 , 51109 , 51131 , 51133 , 51137 , 51151 , 51157 , 51169 , 51193 , 51197 , 51199 , 51203 , 51217 , 51229 , 51239 , 51241 , 51257 , 51263 , 51283 , 51287 , 51307 , 51329 , 51341 , 51343 , 51347 , 51349 , 51361 , 51383 , 51407 , 51413 , 51419 , 51421 , 51427 , 51431 , 51437 , 51439 , 51449 , 51461 , 51473 , 51479 , 51481 , 51487 , 51503 , 51511 , 51517 , 51521 , 51539 , 51551 , 51563 , 51577 , 51581 , 51593 , 51599 , 51607 , 51613 , 51631 , 51637 , 51647 , 51659 , 51673 , 51679 , 51683 , 51691 , 51713 , 51719 , 51721 , 51749 , 51767 , 51769 , 51787 , 51797 , 51803 , 51817 , 51827 , 51829 , 51839 , 51853 , 51859 , 51869 , 51871 , 51893 , 51899 , 51907 , 51913 , 51929 , 51941 , 51949 , 51971 , 51973 , 51977 , 51991 , 52009 , 52021 , 52027 , 52051 , 52057 , 52067 , 52069 , 52081 , 52103 , 52121 , 52127 , 52147 , 52153 , 52163 , 52177 , 52181 , 52183 , 52189 , 52201 , 52223 , 52237 , 52249 , 52253 , 52259 , 52267 , 52289 , 52291 , 52301 , 52313 , 52321 , 52361 , 52363 , 52369 , 52379 , 52387 , 52391 , 52433 , 52453 , 52457 , 52489 , 52501 , 52511 , 52517 , 52529 , 52541 , 52543 , 52553 , 52561 , 52567 , 52571 , 52579 , 52583 , 52609 , 52627 , 52631 , 52639 , 52667 , 52673 , 52691 , 52697 , 52709 , 52711 , 52721 , 52727 , 52733 , 52747 , 52757 , 52769 , 52783 , 52807 , 52813 , 52817 , 52837 , 52859 , 52861 , 52879 , 52883 , 52889 , 52901 , 52903 , 52919 , 52937 , 52951 , 52957 , 52963 , 52967 , 52973 , 52981 , 52999 , 53003 , 53017 , 53047 , 53051 , 53069 , 53077 , 53087 , 53089 , 53093 , 53101 , 53113 , 53117 , 53129 , 53147 , 53149 , 53161 , 53171 , 53173 , 53189 , 53197 , 53201 , 53231 , 53233 , 53239 , 53267 , 53269 , 53279 , 53281 , 53299 , 53309 , 53323 , 53327 , 53353 , 53359 , 53377 , 53381 , 53401 , 53407 , 53411 , 53419 , 53437 , 53441 , 53453 , 53479 , 53503 , 53507 , 53527 , 53549 , 53551 , 53569 , 53591 , 53593 , 53597 , 53609 , 53611 , 53617 , 53623 , 53629 , 53633 , 53639 , 53653 , 53657 , 53681 , 53693 , 53699 , 53717 , 53719 , 53731 , 53759 , 53773 , 53777 , 53783 , 53791 , 53813 , 53819 , 53831 , 53849 , 53857 , 53861 , 53881 , 53887 , 53891 , 53897 , 53899 , 53917 , 53923 , 53927 , 53939 , 53951 , 53959 , 53987 , 53993 , 54001 , 54011 , 54013 , 54037 , 54049 , 54059 , 54083 , 54091 , 54101 , 54121 , 54133 , 54139 , 54151 , 54163 , 54167 , 54181 , 54193 , 54217 , 54251 , 54269 , 54277 , 54287 , 54293 , 54311 , 54319 , 54323 , 54331 , 54347 , 54361 , 54367 , 54371 , 54377 , 54401 , 54403 , 54409 , 54413 , 54419 , 54421 , 54437 , 54443 , 54449 , 54469 , 54493 , 54497 , 54499 , 54503 , 54517 , 54521 , 54539 , 54541 , 54547 , 54559 , 54563 , 54577 , 54581 , 54583 , 54601 , 54617 , 54623 , 54629 , 54631 , 54647 , 54667 , 54673 , 54679 , 54709 , 54713 , 54721 , 54727 , 54751 , 54767 , 54773 , 54779 , 54787 , 54799 , 54829 , 54833 , 54851 , 54869 , 54877 , 54881 , 54907 , 54917 , 54919 , 54941 , 54949 , 54959 , 54973 , 54979 , 54983 , 55001 , 55009 , 55021 , 55049 , 55051 , 55057 , 55061 , 55073 , 55079 , 55103 , 55109 , 55117 , 55127 , 55147 , 55163 , 55171 , 55201 , 55207 , 55213 , 55217 , 55219 , 55229 , 55243 , 55249 , 55259 , 55291 , 55313 , 55331 , 55333 , 55337 , 55339 , 55343 , 55351 , 55373 , 55381 , 55399 , 55411 , 55439 , 55441 , 55457 , 55469 , 55487 , 55501 , 55511 , 55529 , 55541 , 55547 , 55579 , 55589 , 55603 , 55609 , 55619 , 55621 , 55631 , 55633 , 55639 , 55661 , 55663 , 55667 , 55673 , 55681 , 55691 , 55697 , 55711 , 55717 , 55721 , 55733 , 55763 , 55787 , 55793 , 55799 , 55807 , 55813 , 55817 , 55819 , 55823 , 55829 , 55837 , 55843 , 55849 , 55871 , 55889 , 55897 , 55901 , 55903 , 55921 , 55927 , 55931 , 55933 , 55949 , 55967 , 55987 , 55997 , 56003 , 56009 , 56039 , 56041 , 56053 , 56081 , 56087 , 56093 , 56099 , 56101 , 56113 , 56123 , 56131 , 56149 , 56167 , 56171 , 56179 , 56197 , 56207 , 56209 , 56237 , 56239 , 56249 , 56263 , 56267 , 56269 , 56299 , 56311 , 56333 , 56359 , 56369 , 56377 , 56383 , 56393 , 56401 , 56417 , 56431 , 56437 , 56443 , 56453 , 56467 , 56473 , 56477 , 56479 , 56489 , 56501 , 56503 , 56509 , 56519 , 56527 , 56531 , 56533 , 56543 , 56569 , 56591 , 56597 , 56599 , 56611 , 56629 , 56633 , 56659 , 56663 , 56671 , 56681 , 56687 , 56701 , 56711 , 56713 , 56731 , 56737 , 56747 , 56767 , 56773 , 56779 , 56783 , 56807 , 56809 , 56813 , 56821 , 56827 , 56843 , 56857 , 56873 , 56891 , 56893 , 56897 , 56909 , 56911 , 56921 , 56923 , 56929 , 56941 , 56951 , 56957 , 56963 , 56983 , 56989 , 56993 , 56999 , 57037 , 57041 , 57047 , 57059 , 57073 , 57077 , 57089 , 57097 , 57107 , 57119 , 57131 , 57139 , 57143 , 57149 , 57163 , 57173 , 57179 , 57191 , 57193 , 57203 , 57221 , 57223 , 57241 , 57251 , 57259 , 57269 , 57271 , 57283 , 57287 , 57301 , 57329 , 57331 , 57347 , 57349 , 57367 , 57373 , 57383 , 57389 , 57397 , 57413 , 57427 , 57457 , 57467 , 57487 , 57493 , 57503 , 57527 , 57529 , 57557 , 57559 , 57571 , 57587 , 57593 , 57601 , 57637 , 57641 , 57649 , 57653 , 57667 , 57679 , 57689 , 57697 , 57709 , 57713 , 57719 , 57727 , 57731 , 57737 , 57751 , 57773 , 57781 , 57787 , 57791 , 57793 , 57803 , 57809 , 57829 , 57839 , 57847 , 57853 , 57859 , 57881 , 57899 , 57901 , 57917 , 57923 , 57943 , 57947 , 57973 , 57977 , 57991 , 58013 , 58027 , 58031 , 58043 , 58049 , 58057 , 58061 , 58067 , 58073 , 58099 , 58109 , 58111 , 58129 , 58147 , 58151 , 58153 , 58169 , 58171 , 58189 , 58193 , 58199 , 58207 , 58211 , 58217 , 58229 , 58231 , 58237 , 58243 , 58271 , 58309 , 58313 , 58321 , 58337 , 58363 , 58367 , 58369 , 58379 , 58391 , 58393 , 58403 , 58411 , 58417 , 58427 , 58439 , 58441 , 58451 , 58453 , 58477 , 58481 , 58511 , 58537 , 58543 , 58549 , 58567 , 58573 , 58579 , 58601 , 58603 , 58613 , 58631 , 58657 , 58661 , 58679 , 58687 , 58693 , 58699 , 58711 , 58727 , 58733 , 58741 , 58757 , 58763 , 58771 , 58787 , 58789 , 58831 , 58889 , 58897 , 58901 , 58907 , 58909 , 58913 , 58921 , 58937 , 58943 , 58963 , 58967 , 58979 , 58991 , 58997 , 59009 , 59011 , 59021 , 59023 , 59029 , 59051 , 59053 , 59063 , 59069 , 59077 , 59083 , 59093 , 59107 , 59113 , 59119 , 59123 , 59141 , 59149 , 59159 , 59167 , 59183 , 59197 , 59207 , 59209 , 59219 , 59221 , 59233 , 59239 , 59243 , 59263 , 59273 , 59281 , 59333 , 59341 , 59351 , 59357 , 59359 , 59369 , 59377 , 59387 , 59393 , 59399 , 59407 , 59417 , 59419 , 59441 , 59443 , 59447 , 59453 , 59467 , 59471 , 59473 , 59497 , 59509 , 59513 , 59539 , 59557 , 59561 , 59567 , 59581 , 59611 , 59617 , 59621 , 59627 , 59629 , 59651 , 59659 , 59663 , 59669 , 59671 , 59693 , 59699 , 59707 , 59723 , 59729 , 59743 , 59747 , 59753 , 59771 , 59779 , 59791 , 59797 , 59809 , 59833 , 59863 , 59879 , 59887 , 59921 , 59929 , 59951 , 59957 , 59971 , 59981 , 59999 , 60013 , 60017 , 60029 , 60037 , 60041 , 60077 , 60083 , 60089 , 60091 , 60101 , 60103 , 60107 , 60127 , 60133 , 60139 , 60149 , 60161 , 60167 , 60169 , 60209 , 60217 , 60223 , 60251 , 60257 , 60259 , 60271 , 60289 , 60293 , 60317 , 60331 , 60337 , 60343 , 60353 , 60373 , 60383 , 60397 , 60413 , 60427 , 60443 , 60449 , 60457 , 60493 , 60497 , 60509 , 60521 , 60527 , 60539 , 60589 , 60601 , 60607 , 60611 , 60617 , 60623 , 60631 , 60637 , 60647 , 60649 , 60659 , 60661 , 60679 , 60689 , 60703 , 60719 , 60727 , 60733 , 60737 , 60757 , 60761 , 60763 , 60773 , 60779 , 60793 , 60811 , 60821 , 60859 , 60869 , 60887 , 60889 , 60899 , 60901 , 60913 , 60917 , 60919 , 60923 , 60937 , 60943 , 60953 , 60961 , 61001 , 61007 , 61027 , 61031 , 61043 , 61051 , 61057 , 61091 , 61099 , 61121 , 61129 , 61141 , 61151 , 61153 , 61169 , 61211 , 61223 , 61231 , 61253 , 61261 , 61283 , 61291 , 61297 , 61331 , 61333 , 61339 , 61343 , 61357 , 61363 , 61379 , 61381 , 61403 , 61409 , 61417 , 61441 , 61463 , 61469 , 61471 , 61483 , 61487 , 61493 , 61507 , 61511 , 61519 , 61543 , 61547 , 61553 , 61559 , 61561 , 61583 , 61603 , 61609 , 61613 , 61627 , 61631 , 61637 , 61643 , 61651 , 61657 , 61667 , 61673 , 61681 , 61687 , 61703 , 61717 , 61723 , 61729 , 61751 , 61757 , 61781 , 61813 , 61819 , 61837 , 61843 , 61861 , 61871 , 61879 , 61909 , 61927 , 61933 , 61949 , 61961 , 61967 , 61979 , 61981 , 61987 , 61991 , 62003 , 62011 , 62017 , 62039 , 62047 , 62053 , 62057 , 62071 , 62081 , 62099 , 62119 , 62129 , 62131 , 62137 , 62141 , 62143 , 62171 , 62189 , 62191 , 62201 , 62207 , 62213 , 62219 , 62233 , 62273 , 62297 , 62299 , 62303 , 62311 , 62323 , 62327 , 62347 , 62351 , 62383 , 62401 , 62417 , 62423 , 62459 , 62467 , 62473 , 62477 , 62483 , 62497 , 62501 , 62507 , 62533 , 62539 , 62549 , 62563 , 62581 , 62591 , 62597 , 62603 , 62617 , 62627 , 62633 , 62639 , 62653 , 62659 , 62683 , 62687 , 62701 , 62723 , 62731 , 62743 , 62753 , 62761 , 62773 , 62791 , 62801 , 62819 , 62827 , 62851 , 62861 , 62869 , 62873 , 62897 , 62903 , 62921 , 62927 , 62929 , 62939 , 62969 , 62971 , 62981 , 62983 , 62987 , 62989 , 63029 , 63031 , 63059 , 63067 , 63073 , 63079 , 63097 , 63103 , 63113 , 63127 , 63131 , 63149 , 63179 , 63197 , 63199 , 63211 , 63241 , 63247 , 63277 , 63281 , 63299 , 63311 , 63313 , 63317 , 63331 , 63337 , 63347 , 63353 , 63361 , 63367 , 63377 , 63389 , 63391 , 63397 , 63409 , 63419 , 63421 , 63439 , 63443 , 63463 , 63467 , 63473 , 63487 , 63493 , 63499 , 63521 , 63527 , 63533 , 63541 , 63559 , 63577 , 63587 , 63589 , 63599 , 63601 , 63607 , 63611 , 63617 , 63629 , 63647 , 63649 , 63659 , 63667 , 63671 , 63689 , 63691 , 63697 , 63703 , 63709 , 63719 , 63727 , 63737 , 63743 , 63761 , 63773 , 63781 , 63793 , 63799 , 63803 , 63809 , 63823 , 63839 , 63841 , 63853 , 63857 , 63863 , 63901 , 63907 , 63913 , 63929 , 63949 , 63977 , 63997 , 64007 , 64013 , 64019 , 64033 , 64037 , 64063 , 64067 , 64081 , 64091 , 64109 , 64123 , 64151 , 64153 , 64157 , 64171 , 64187 , 64189 , 64217 , 64223 , 64231 , 64237 , 64271 , 64279 , 64283 , 64301 , 64303 , 64319 , 64327 , 64333 , 64373 , 64381 , 64399 , 64403 , 64433 , 64439 , 64451 , 64453 , 64483 , 64489 , 64499 , 64513 , 64553 , 64567 , 64577 , 64579 , 64591 , 64601 , 64609 , 64613 , 64621 , 64627 , 64633 , 64661 , 64663 , 64667 , 64679 , 64693 , 64709 , 64717 , 64747 , 64763 , 64781 , 64783 , 64793 , 64811 , 64817 , 64849 , 64853 , 64871 , 64877 , 64879 , 64891 , 64901 , 64919 , 64921 , 64927 , 64937 , 64951 , 64969 , 64997 , 65003 , 65011 , 65027 , 65029 , 65033 , 65053 , 65063 , 65071 , 65089 , 65099 , 65101 , 65111 , 65119 , 65123 , 65129 , 65141 , 65147 , 65167 , 65171 , 65173 , 65179 , 65183 , 65203 , 65213 , 65239 , 65257 , 65267 , 65269 , 65287 , 65293 , 65309 , 65323 , 65327 , 65353 , 65357 , 65371 , 65381 , 65393 , 65407 , 65413 , 65419 , 65423 , 65437 , 65447 , 65449 , 65479 , 65497 , 65519 , 65521 , 65537 , 65539 , 65543 , 65551 , 65557 , 65563 , 65579 , 65581 , 65587 , 65599 , 65609 , 65617 , 65629 , 65633 , 65647 , 65651 , 65657 , 65677 , 65687 , 65699 , 65701 , 65707 , 65713 , 65717 , 65719 , 65729 , 65731 , 65761 , 65777 , 65789 , 65809 , 65827 , 65831 , 65837 , 65839 , 65843 , 65851 , 65867 , 65881 , 65899 , 65921 , 65927 , 65929 , 65951 , 65957 , 65963 , 65981 , 65983 , 65993 , 66029 , 66037 , 66041 , 66047 , 66067 , 66071 , 66083 , 66089 , 66103 , 66107 , 66109 , 66137 , 66161 , 66169 , 66173 , 66179 , 66191 , 66221 , 66239 , 66271 , 66293 , 66301 , 66337 , 66343 , 66347 , 66359 , 66361 , 66373 , 66377 , 66383 , 66403 , 66413 , 66431 , 66449 , 66457 , 66463 , 66467 , 66491 , 66499 , 66509 , 66523 , 66529 , 66533 , 66541 , 66553 , 66569 , 66571 , 66587 , 66593 , 66601 , 66617 , 66629 , 66643 , 66653 , 66683 , 66697 , 66701 , 66713 , 66721 , 66733 , 66739 , 66749 , 66751 , 66763 , 66791 , 66797 , 66809 , 66821 , 66841 , 66851 , 66853 , 66863 , 66877 , 66883 , 66889 , 66919 , 66923 , 66931 , 66943 , 66947 , 66949 , 66959 , 66973 , 66977 , 67003 , 67021 , 67033 , 67043 , 67049 , 67057 , 67061 , 67073 , 67079 , 67103 , 67121 , 67129 , 67139 , 67141 , 67153 , 67157 , 67169 , 67181 , 67187 , 67189 , 67211 , 67213 , 67217 , 67219 , 67231 , 67247 , 67261 , 67271 , 67273 , 67289 , 67307 , 67339 , 67343 , 67349 , 67369 , 67391 , 67399 , 67409 , 67411 , 67421 , 67427 , 67429 , 67433 , 67447 , 67453 , 67477 , 67481 , 67489 , 67493 , 67499 , 67511 , 67523 , 67531 , 67537 , 67547 , 67559 , 67567 , 67577 , 67579 , 67589 , 67601 , 67607 , 67619 , 67631 , 67651 , 67679 , 67699 , 67709 , 67723 , 67733 , 67741 , 67751 , 67757 , 67759 , 67763 , 67777 , 67783 , 67789 , 67801 , 67807 , 67819 , 67829 , 67843 , 67853 , 67867 , 67883 , 67891 , 67901 , 67927 , 67931 , 67933 , 67939 , 67943 , 67957 , 67961 , 67967 , 67979 , 67987 , 67993 , 68023 , 68041 , 68053 , 68059 , 68071 , 68087 , 68099 , 68111 , 68113 , 68141 , 68147 , 68161 , 68171 , 68207 , 68209 , 68213 , 68219 , 68227 , 68239 , 68261 , 68279 , 68281 , 68311 , 68329 , 68351 , 68371 , 68389 , 68399 , 68437 , 68443 , 68447 , 68449 , 68473 , 68477 , 68483 , 68489 , 68491 , 68501 , 68507 , 68521 , 68531 , 68539 , 68543 , 68567 , 68581 , 68597 , 68611 , 68633 , 68639 , 68659 , 68669 , 68683 , 68687 , 68699 , 68711 , 68713 , 68729 , 68737 , 68743 , 68749 , 68767 , 68771 , 68777 , 68791 , 68813 , 68819 , 68821 , 68863 , 68879 , 68881 , 68891 , 68897 , 68899 , 68903 , 68909 , 68917 , 68927 , 68947 , 68963 , 68993 , 69001 , 69011 , 69019 , 69029 , 69031 , 69061 , 69067 , 69073 , 69109 , 69119 , 69127 , 69143 , 69149 , 69151 , 69163 , 69191 , 69193 , 69197 , 69203 , 69221 , 69233 , 69239 , 69247 , 69257 , 69259 , 69263 , 69313 , 69317 , 69337 , 69341 , 69371 , 69379 , 69383 , 69389 , 69401 , 69403 , 69427 , 69431 , 69439 , 69457 , 69463 , 69467 , 69473 , 69481 , 69491 , 69493 , 69497 , 69499 , 69539 , 69557 , 69593 , 69623 , 69653 , 69661 , 69677 , 69691 , 69697 , 69709 , 69737 , 69739 , 69761 , 69763 , 69767 , 69779 , 69809 , 69821 , 69827 , 69829 , 69833 , 69847 , 69857 , 69859 , 69877 , 69899 , 69911 , 69929 , 69931 , 69941 , 69959 , 69991 , 69997 , 70001 , 70003 , 70009 , 70019 , 70039 , 70051 , 70061 , 70067 , 70079 , 70099 , 70111 , 70117 , 70121 , 70123 , 70139 , 70141 , 70157 , 70163 , 70177 , 70181 , 70183 , 70199 , 70201 , 70207 , 70223 , 70229 , 70237 , 70241 , 70249 , 70271 , 70289 , 70297 , 70309 , 70313 , 70321 , 70327 , 70351 , 70373 , 70379 , 70381 , 70393 , 70423 , 70429 , 70439 , 70451 , 70457 , 70459 , 70481 , 70487 , 70489 , 70501 , 70507 , 70529 , 70537 , 70549 , 70571 , 70573 , 70583 , 70589 , 70607 , 70619 , 70621 , 70627 , 70639 , 70657 , 70663 , 70667 , 70687 , 70709 , 70717 , 70729 , 70753 , 70769 , 70783 , 70793 , 70823 , 70841 , 70843 , 70849 , 70853 , 70867 , 70877 , 70879 , 70891 , 70901 , 70913 , 70919 , 70921 , 70937 , 70949 , 70951 , 70957 , 70969 , 70979 , 70981 , 70991 , 70997 , 70999 , 71011 , 71023 , 71039 , 71059 , 71069 , 71081 , 71089 , 71119 , 71129 , 71143 , 71147 , 71153 , 71161 , 71167 , 71171 , 71191 , 71209 , 71233 , 71237 , 71249 , 71257 , 71261 , 71263 , 71287 , 71293 , 71317 , 71327 , 71329 , 71333 , 71339 , 71341 , 71347 , 71353 , 71359 , 71363 , 71387 , 71389 , 71399 , 71411 , 71413 , 71419 , 71429 , 71437 , 71443 , 71453 , 71471 , 71473 , 71479 , 71483 , 71503 , 71527 , 71537 , 71549 , 71551 , 71563 , 71569 , 71593 , 71597 , 71633 , 71647 , 71663 , 71671 , 71693 , 71699 , 71707 , 71711 , 71713 , 71719 , 71741 , 71761 , 71777 , 71789 , 71807 , 71809 , 71821 , 71837 , 71843 , 71849 , 71861 , 71867 , 71879 , 71881 , 71887 , 71899 , 71909 , 71917 , 71933 , 71941 , 71947 , 71963 , 71971 , 71983 , 71987 , 71993 , 71999 , 72019 , 72031 , 72043 , 72047 , 72053 , 72073 , 72077 , 72089 , 72091 , 72101 , 72103 , 72109 , 72139 , 72161 , 72167 , 72169 , 72173 , 72211 , 72221 , 72223 , 72227 , 72229 , 72251 , 72253 , 72269 , 72271 , 72277 , 72287 , 72307 , 72313 , 72337 , 72341 , 72353 , 72367 , 72379 , 72383 , 72421 , 72431 , 72461 , 72467 , 72469 , 72481 , 72493 , 72497 , 72503 , 72533 , 72547 , 72551 , 72559 , 72577 , 72613 , 72617 , 72623 , 72643 , 72647 , 72649 , 72661 , 72671 , 72673 , 72679 , 72689 , 72701 , 72707 , 72719 , 72727 , 72733 , 72739 , 72763 , 72767 , 72797 , 72817 , 72823 , 72859 , 72869 , 72871 , 72883 , 72889 , 72893 , 72901 , 72907 , 72911 , 72923 , 72931 , 72937 , 72949 , 72953 , 72959 , 72973 , 72977 , 72997 , 73009 , 73013 , 73019 , 73037 , 73039 , 73043 , 73061 , 73063 , 73079 , 73091 , 73121 , 73127 , 73133 , 73141 , 73181 , 73189 , 73237 , 73243 , 73259 , 73277 , 73291 , 73303 , 73309 , 73327 , 73331 , 73351 , 73361 , 73363 , 73369 , 73379 , 73387 , 73417 , 73421 , 73433 , 73453 , 73459 , 73471 , 73477 , 73483 , 73517 , 73523 , 73529 , 73547 , 73553 , 73561 , 73571 , 73583 , 73589 , 73597 , 73607 , 73609 , 73613 , 73637 , 73643 , 73651 , 73673 , 73679 , 73681 , 73693 , 73699 , 73709 , 73721 , 73727 , 73751 , 73757 , 73771 , 73783 , 73819 , 73823 , 73847 , 73849 , 73859 , 73867 , 73877 , 73883 , 73897 , 73907 , 73939 , 73943 , 73951 , 73961 , 73973 , 73999 , 74017 , 74021 , 74027 , 74047 , 74051 , 74071 , 74077 , 74093 , 74099 , 74101 , 74131 , 74143 , 74149 , 74159 , 74161 , 74167 , 74177 , 74189 , 74197 , 74201 , 74203 , 74209 , 74219 , 74231 , 74257 , 74279 , 74287 , 74293 , 74297 , 74311 , 74317 , 74323 , 74353 , 74357 , 74363 , 74377 , 74381 , 74383 , 74411 , 74413 , 74419 , 74441 , 74449 , 74453 , 74471 , 74489 , 74507 , 74509 , 74521 , 74527 , 74531 , 74551 , 74561 , 74567 , 74573 , 74587 , 74597 , 74609 , 74611 , 74623 , 74653 , 74687 , 74699 , 74707 , 74713 , 74717 , 74719 , 74729 , 74731 , 74747 , 74759 , 74761 , 74771 , 74779 , 74797 , 74821 , 74827 , 74831 , 74843 , 74857 , 74861 , 74869 , 74873 , 74887 , 74891 , 74897 , 74903 , 74923 , 74929 , 74933 , 74941 , 74959 , 75011 , 75013 , 75017 , 75029 , 75037 , 75041 , 75079 , 75083 , 75109 , 75133 , 75149 , 75161 , 75167 , 75169 , 75181 , 75193 , 75209 , 75211 , 75217 , 75223 , 75227 , 75239 , 75253 , 75269 , 75277 , 75289 , 75307 , 75323 , 75329 , 75337 , 75347 , 75353 , 75367 , 75377 , 75389 , 75391 , 75401 , 75403 , 75407 , 75431 , 75437 , 75479 , 75503 , 75511 , 75521 , 75527 , 75533 , 75539 , 75541 , 75553 , 75557 , 75571 , 75577 , 75583 , 75611 , 75617 , 75619 , 75629 , 75641 , 75653 , 75659 , 75679 , 75683 , 75689 , 75703 , 75707 , 75709 , 75721 , 75731 , 75743 , 75767 , 75773 , 75781 , 75787 , 75793 , 75797 , 75821 , 75833 , 75853 , 75869 , 75883 , 75913 , 75931 , 75937 , 75941 , 75967 , 75979 , 75983 , 75989 , 75991 , 75997 , 76001 , 76003 , 76031 , 76039 , 76079 , 76081 , 76091 , 76099 , 76103 , 76123 , 76129 , 76147 , 76157 , 76159 , 76163 , 76207 , 76213 , 76231 , 76243 , 76249 , 76253 , 76259 , 76261 , 76283 , 76289 , 76303 , 76333 , 76343 , 76367 , 76369 , 76379 , 76387 , 76403 , 76421 , 76423 , 76441 , 76463 , 76471 , 76481 , 76487 , 76493 , 76507 , 76511 , 76519 , 76537 , 76541 , 76543 , 76561 , 76579 , 76597 , 76603 , 76607 , 76631 , 76649 , 76651 , 76667 , 76673 , 76679 , 76697 , 76717 , 76733 , 76753 , 76757 , 76771 , 76777 , 76781 , 76801 , 76819 , 76829 , 76831 , 76837 , 76847 , 76871 , 76873 , 76883 , 76907 , 76913 , 76919 , 76943 , 76949 , 76961 , 76963 , 76991 , 77003 , 77017 , 77023 , 77029 , 77041 , 77047 , 77069 , 77081 , 77093 , 77101 , 77137 , 77141 , 77153 , 77167 , 77171 , 77191 , 77201 , 77213 , 77237 , 77239 , 77243 , 77249 , 77261 , 77263 , 77267 , 77269 , 77279 , 77291 , 77317 , 77323 , 77339 , 77347 , 77351 , 77359 , 77369 , 77377 , 77383 , 77417 , 77419 , 77431 , 77447 , 77471 , 77477 , 77479 , 77489 , 77491 , 77509 , 77513 , 77521 , 77527 , 77543 , 77549 , 77551 , 77557 , 77563 , 77569 , 77573 , 77587 , 77591 , 77611 , 77617 , 77621 , 77641 , 77647 , 77659 , 77681 , 77687 , 77689 , 77699 , 77711 , 77713 , 77719 , 77723 , 77731 , 77743 , 77747 , 77761 , 77773 , 77783 , 77797 , 77801 , 77813 , 77839 , 77849 , 77863 , 77867 , 77893 , 77899 , 77929 , 77933 , 77951 , 77969 , 77977 , 77983 , 77999 , 78007 , 78017 , 78031 , 78041 , 78049 , 78059 , 78079 , 78101 , 78121 , 78137 , 78139 , 78157 , 78163 , 78167 , 78173 , 78179 , 78191 , 78193 , 78203 , 78229 , 78233 , 78241 , 78259 , 78277 , 78283 , 78301 , 78307 , 78311 , 78317 , 78341 , 78347 , 78367 , 78401 , 78427 , 78437 , 78439 , 78467 , 78479 , 78487 , 78497 , 78509 , 78511 , 78517 , 78539 , 78541 , 78553 , 78569 , 78571 , 78577 , 78583 , 78593 , 78607 , 78623 , 78643 , 78649 , 78653 , 78691 , 78697 , 78707 , 78713 , 78721 , 78737 , 78779 , 78781 , 78787 , 78791 , 78797 , 78803 , 78809 , 78823 , 78839 , 78853 , 78857 , 78877 , 78887 , 78889 , 78893 , 78901 , 78919 , 78929 , 78941 , 78977 , 78979 , 78989 , 79031 , 79039 , 79043 , 79063 , 79087 , 79103 , 79111 , 79133 , 79139 , 79147 , 79151 , 79153 , 79159 , 79181 , 79187 , 79193 , 79201 , 79229 , 79231 , 79241 , 79259 , 79273 , 79279 , 79283 , 79301 , 79309 , 79319 , 79333 , 79337 , 79349 , 79357 , 79367 , 79379 , 79393 , 79397 , 79399 , 79411 , 79423 , 79427 , 79433 , 79451 , 79481 , 79493 , 79531 , 79537 , 79549 , 79559 , 79561 , 79579 , 79589 , 79601 , 79609 , 79613 , 79621 , 79627 , 79631 , 79633 , 79657 , 79669 , 79687 , 79691 , 79693 , 79697 , 79699 , 79757 , 79769 , 79777 , 79801 , 79811 , 79813 , 79817 , 79823 , 79829 , 79841 , 79843 , 79847 , 79861 , 79867 , 79873 , 79889 , 79901 , 79903 , 79907 , 79939 , 79943 , 79967 , 79973 , 79979 , 79987 , 79997 , 79999 , 80021 , 80039 , 80051 , 80071 , 80077 , 80107 , 80111 , 80141 , 80147 , 80149 , 80153 , 80167 , 80173 , 80177 , 80191 , 80207 , 80209 , 80221 , 80231 , 80233 , 80239 , 80251 , 80263 , 80273 , 80279 , 80287 , 80309 , 80317 , 80329 , 80341 , 80347 , 80363 , 80369 , 80387 , 80407 , 80429 , 80447 , 80449 , 80471 , 80473 , 80489 , 80491 , 80513 , 80527 , 80537 , 80557 , 80567 , 80599 , 80603 , 80611 , 80621 , 80627 , 80629 , 80651 , 80657 , 80669 , 80671 , 80677 , 80681 , 80683 , 80687 , 80701 , 80713 , 80737 , 80747 , 80749 , 80761 , 80777 , 80779 , 80783 , 80789 , 80803 , 80809 , 80819 , 80831 , 80833 , 80849 , 80863 , 80897 , 80909 , 80911 , 80917 , 80923 , 80929 , 80933 , 80953 , 80963 , 80989 , 81001 , 81013 , 81017 , 81019 , 81023 , 81031 , 81041 , 81043 , 81047 , 81049 , 81071 , 81077 , 81083 , 81097 , 81101 , 81119 , 81131 , 81157 , 81163 , 81173 , 81181 , 81197 , 81199 , 81203 , 81223 , 81233 , 81239 , 81281 , 81283 , 81293 , 81299 , 81307 , 81331 , 81343 , 81349 , 81353 , 81359 , 81371 , 81373 , 81401 , 81409 , 81421 , 81439 , 81457 , 81463 , 81509 , 81517 , 81527 , 81533 , 81547 , 81551 , 81553 , 81559 , 81563 , 81569 , 81611 , 81619 , 81629 , 81637 , 81647 , 81649 , 81667 , 81671 , 81677 , 81689 , 81701 , 81703 , 81707 , 81727 , 81737 , 81749 , 81761 , 81769 , 81773 , 81799 , 81817 , 81839 , 81847 , 81853 , 81869 , 81883 , 81899 , 81901 , 81919 , 81929 , 81931 , 81937 , 81943 , 81953 , 81967 , 81971 , 81973 , 82003 , 82007 , 82009 , 82013 , 82021 , 82031 , 82037 , 82039 , 82051 , 82067 , 82073 , 82129 , 82139 , 82141 , 82153 , 82163 , 82171 , 82183 , 82189 , 82193 , 82207 , 82217 , 82219 , 82223 , 82231 , 82237 , 82241 , 82261 , 82267 , 82279 , 82301 , 82307 , 82339 , 82349 , 82351 , 82361 , 82373 , 82387 , 82393 , 82421 , 82457 , 82463 , 82469 , 82471 , 82483 , 82487 , 82493 , 82499 , 82507 , 82529 , 82531 , 82549 , 82559 , 82561 , 82567 , 82571 , 82591 , 82601 , 82609 , 82613 , 82619 , 82633 , 82651 , 82657 , 82699 , 82721 , 82723 , 82727 , 82729 , 82757 , 82759 , 82763 , 82781 , 82787 , 82793 , 82799 , 82811 , 82813 , 82837 , 82847 , 82883 , 82889 , 82891 , 82903 , 82913 , 82939 , 82963 , 82981 , 82997 , 83003 , 83009 , 83023 , 83047 , 83059 , 83063 , 83071 , 83077 , 83089 , 83093 , 83101 , 83117 , 83137 , 83177 , 83203 , 83207 , 83219 , 83221 , 83227 , 83231 , 83233 , 83243 , 83257 , 83267 , 83269 , 83273 , 83299 , 83311 , 83339 , 83341 , 83357 , 83383 , 83389 , 83399 , 83401 , 83407 , 83417 , 83423 , 83431 , 83437 , 83443 , 83449 , 83459 , 83471 , 83477 , 83497 , 83537 , 83557 , 83561 , 83563 , 83579 , 83591 , 83597 , 83609 , 83617 , 83621 , 83639 , 83641 , 83653 , 83663 , 83689 , 83701 , 83717 , 83719 , 83737 , 83761 , 83773 , 83777 , 83791 , 83813 , 83833 , 83843 , 83857 , 83869 , 83873 , 83891 , 83903 , 83911 , 83921 , 83933 , 83939 , 83969 , 83983 , 83987 , 84011 , 84017 , 84047 , 84053 , 84059 , 84061 , 84067 , 84089 , 84121 , 84127 , 84131 , 84137 , 84143 , 84163 , 84179 , 84181 , 84191 , 84199 , 84211 , 84221 , 84223 , 84229 , 84239 , 84247 , 84263 , 84299 , 84307 , 84313 , 84317 , 84319 , 84347 , 84349 , 84377 , 84389 , 84391 , 84401 , 84407 , 84421 , 84431 , 84437 , 84443 , 84449 , 84457 , 84463 , 84467 , 84481 , 84499 , 84503 , 84509 , 84521 , 84523 , 84533 , 84551 , 84559 , 84589 , 84629 , 84631 , 84649 , 84653 , 84659 , 84673 , 84691 , 84697 , 84701 , 84713 , 84719 , 84731 , 84737 , 84751 , 84761 , 84787 , 84793 , 84809 , 84811 , 84827 , 84857 , 84859 , 84869 , 84871 , 84913 , 84919 , 84947 , 84961 , 84967 , 84977 , 84979 , 84991 , 85009 , 85021 , 85027 , 85037 , 85049 , 85061 , 85081 , 85087 , 85091 , 85093 , 85103 , 85109 , 85121 , 85133 , 85147 , 85159 , 85193 , 85199 , 85201 , 85213 , 85223 , 85229 , 85237 , 85243 , 85247 , 85259 , 85297 , 85303 , 85313 , 85331 , 85333 , 85361 , 85363 , 85369 , 85381 , 85411 , 85427 , 85429 , 85439 , 85447 , 85451 , 85453 , 85469 , 85487 , 85513 , 85517 , 85523 , 85531 , 85549 , 85571 , 85577 , 85597 , 85601 , 85607 , 85619 , 85621 , 85627 , 85639 , 85643 , 85661 , 85667 , 85669 , 85691 , 85703 , 85711 , 85717 , 85733 , 85751 , 85781 , 85793 , 85817 , 85819 , 85829 , 85831 , 85837 , 85843 , 85847 , 85853 , 85889 , 85903 , 85909 , 85931 , 85933 , 85991 , 85999 , 86011 , 86017 , 86027 , 86029 , 86069 , 86077 , 86083 , 86111 , 86113 , 86117 , 86131 , 86137 , 86143 , 86161 , 86171 , 86179 , 86183 , 86197 , 86201 , 86209 , 86239 , 86243 , 86249 , 86257 , 86263 , 86269 , 86287 , 86291 , 86293 , 86297 , 86311 , 86323 , 86341 , 86351 , 86353 , 86357 , 86369 , 86371 , 86381 , 86389 , 86399 , 86413 , 86423 , 86441 , 86453 , 86461 , 86467 , 86477 , 86491 , 86501 , 86509 , 86531 , 86533 , 86539 , 86561 , 86573 , 86579 , 86587 , 86599 , 86627 , 86629 , 86677 , 86689 , 86693 , 86711 , 86719 , 86729 , 86743 , 86753 , 86767 , 86771 , 86783 , 86813 , 86837 , 86843 , 86851 , 86857 , 86861 , 86869 , 86923 , 86927 , 86929 , 86939 , 86951 , 86959 , 86969 , 86981 , 86993 , 87011 , 87013 , 87037 , 87041 , 87049 , 87071 , 87083 , 87103 , 87107 , 87119 , 87121 , 87133 , 87149 , 87151 , 87179 , 87181 , 87187 , 87211 , 87221 , 87223 , 87251 , 87253 , 87257 , 87277 , 87281 , 87293 , 87299 , 87313 , 87317 , 87323 , 87337 , 87359 , 87383 , 87403 , 87407 , 87421 , 87427 , 87433 , 87443 , 87473 , 87481 , 87491 , 87509 , 87511 , 87517 , 87523 , 87539 , 87541 , 87547 , 87553 , 87557 , 87559 , 87583 , 87587 , 87589 , 87613 , 87623 , 87629 , 87631 , 87641 , 87643 , 87649 , 87671 , 87679 , 87683 , 87691 , 87697 , 87701 , 87719 , 87721 , 87739 , 87743 , 87751 , 87767 , 87793 , 87797 , 87803 , 87811 , 87833 , 87853 , 87869 , 87877 , 87881 , 87887 , 87911 , 87917 , 87931 , 87943 , 87959 , 87961 , 87973 , 87977 , 87991 , 88001 , 88003 , 88007 , 88019 , 88037 , 88069 , 88079 , 88093 , 88117 , 88129 , 88169 , 88177 , 88211 , 88223 , 88237 , 88241 , 88259 , 88261 , 88289 , 88301 , 88321 , 88327 , 88337 , 88339 , 88379 , 88397 , 88411 , 88423 , 88427 , 88463 , 88469 , 88471 , 88493 , 88499 , 88513 , 88523 , 88547 , 88589 , 88591 , 88607 , 88609 , 88643 , 88651 , 88657 , 88661 , 88663 , 88667 , 88681 , 88721 , 88729 , 88741 , 88747 , 88771 , 88789 , 88793 , 88799 , 88801 , 88807 , 88811 , 88813 , 88817 , 88819 , 88843 , 88853 , 88861 , 88867 , 88873 , 88883 , 88897 , 88903 , 88919 , 88937 , 88951 , 88969 , 88993 , 88997 , 89003 , 89009 , 89017 , 89021 , 89041 , 89051 , 89057 , 89069 , 89071 , 89083 , 89087 , 89101 , 89107 , 89113 , 89119 , 89123 , 89137 , 89153 , 89189 , 89203 , 89209 , 89213 , 89227 , 89231 , 89237 , 89261 , 89269 , 89273 , 89293 , 89303 , 89317 , 89329 , 89363 , 89371 , 89381 , 89387 , 89393 , 89399 , 89413 , 89417 , 89431 , 89443 , 89449 , 89459 , 89477 , 89491 , 89501 , 89513 , 89519 , 89521 , 89527 , 89533 , 89561 , 89563 , 89567 , 89591 , 89597 , 89599 , 89603 , 89611 , 89627 , 89633 , 89653 , 89657 , 89659 , 89669 , 89671 , 89681 , 89689 , 89753 , 89759 , 89767 , 89779 , 89783 , 89797 , 89809 , 89819 , 89821 , 89833 , 89839 , 89849 , 89867 , 89891 , 89897 , 89899 , 89909 , 89917 , 89923 , 89939 , 89959 , 89963 , 89977 , 89983 , 89989 , 90001 , 90007 , 90011 , 90017 , 90019 , 90023 , 90031 , 90053 , 90059 , 90067 , 90071 , 90073 , 90089 , 90107 , 90121 , 90127 , 90149 , 90163 , 90173 , 90187 , 90191 , 90197 , 90199 , 90203 , 90217 , 90227 , 90239 , 90247 , 90263 , 90271 , 90281 , 90289 , 90313 , 90353 , 90359 , 90371 , 90373 , 90379 , 90397 , 90401 , 90403 , 90407 , 90437 , 90439 , 90469 , 90473 , 90481 , 90499 , 90511 , 90523 , 90527 , 90529 , 90533 , 90547 , 90583 , 90599 , 90617 , 90619 , 90631 , 90641 , 90647 , 90659 , 90677 , 90679 , 90697 , 90703 , 90709 , 90731 , 90749 , 90787 , 90793 , 90803 , 90821 , 90823 , 90833 , 90841 , 90847 , 90863 , 90887 , 90901 , 90907 , 90911 , 90917 , 90931 , 90947 , 90971 , 90977 , 90989 , 90997 , 91009 , 91019 , 91033 , 91079 , 91081 , 91097 , 91099 , 91121 , 91127 , 91129 , 91139 , 91141 , 91151 , 91153 , 91159 , 91163 , 91183 , 91193 , 91199 , 91229 , 91237 , 91243 , 91249 , 91253 , 91283 , 91291 , 91297 , 91303 , 91309 , 91331 , 91367 , 91369 , 91373 , 91381 , 91387 , 91393 , 91397 , 91411 , 91423 , 91433 , 91453 , 91457 , 91459 , 91463 , 91493 , 91499 , 91513 , 91529 , 91541 , 91571 , 91573 , 91577 , 91583 , 91591 , 91621 , 91631 , 91639 , 91673 , 91691 , 91703 , 91711 , 91733 , 91753 , 91757 , 91771 , 91781 , 91801 , 91807 , 91811 , 91813 , 91823 , 91837 , 91841 , 91867 , 91873 , 91909 , 91921 , 91939 , 91943 , 91951 , 91957 , 91961 , 91967 , 91969 , 91997 , 92003 , 92009 , 92033 , 92041 , 92051 , 92077 , 92083 , 92107 , 92111 , 92119 , 92143 , 92153 , 92173 , 92177 , 92179 , 92189 , 92203 , 92219 , 92221 , 92227 , 92233 , 92237 , 92243 , 92251 , 92269 , 92297 , 92311 , 92317 , 92333 , 92347 , 92353 , 92357 , 92363 , 92369 , 92377 , 92381 , 92383 , 92387 , 92399 , 92401 , 92413 , 92419 , 92431 , 92459 , 92461 , 92467 , 92479 , 92489 , 92503 , 92507 , 92551 , 92557 , 92567 , 92569 , 92581 , 92593 , 92623 , 92627 , 92639 , 92641 , 92647 , 92657 , 92669 , 92671 , 92681 , 92683 , 92693 , 92699 , 92707 , 92717 , 92723 , 92737 , 92753 , 92761 , 92767 , 92779 , 92789 , 92791 , 92801 , 92809 , 92821 , 92831 , 92849 , 92857 , 92861 , 92863 , 92867 , 92893 , 92899 , 92921 , 92927 , 92941 , 92951 , 92957 , 92959 , 92987 , 92993 , 93001 , 93047 , 93053 , 93059 , 93077 , 93083 , 93089 , 93097 , 93103 , 93113 , 93131 , 93133 , 93139 , 93151 , 93169 , 93179 , 93187 , 93199 , 93229 , 93239 , 93241 , 93251 , 93253 , 93257 , 93263 , 93281 , 93283 , 93287 , 93307 , 93319 , 93323 , 93329 , 93337 , 93371 , 93377 , 93383 , 93407 , 93419 , 93427 , 93463 , 93479 , 93481 , 93487 , 93491 , 93493 , 93497 , 93503 , 93523 , 93529 , 93553 , 93557 , 93559 , 93563 , 93581 , 93601 , 93607 , 93629 , 93637 , 93683 , 93701 , 93703 , 93719 , 93739 , 93761 , 93763 , 93787 , 93809 , 93811 , 93827 , 93851 , 93871 , 93887 , 93889 , 93893 , 93901 , 93911 , 93913 , 93923 , 93937 , 93941 , 93949 , 93967 , 93971 , 93979 , 93983 , 93997 , 94007 , 94009 , 94033 , 94049 , 94057 , 94063 , 94079 , 94099 , 94109 , 94111 , 94117 , 94121 , 94151 , 94153 , 94169 , 94201 , 94207 , 94219 , 94229 , 94253 , 94261 , 94273 , 94291 , 94307 , 94309 , 94321 , 94327 , 94331 , 94343 , 94349 , 94351 , 94379 , 94397 , 94399 , 94421 , 94427 , 94433 , 94439 , 94441 , 94447 , 94463 , 94477 , 94483 , 94513 , 94529 , 94531 , 94541 , 94543 , 94547 , 94559 , 94561 , 94573 , 94583 , 94597 , 94603 , 94613 , 94621 , 94649 , 94651 , 94687 , 94693 , 94709 , 94723 , 94727 , 94747 , 94771 , 94777 , 94781 , 94789 , 94793 , 94811 , 94819 , 94823 , 94837 , 94841 , 94847 , 94849 , 94873 , 94889 , 94903 , 94907 , 94933 , 94949 , 94951 , 94961 , 94993 , 94999 , 95003 , 95009 , 95021 , 95027 , 95063 , 95071 , 95083 , 95087 , 95089 , 95093 , 95101 , 95107 , 95111 , 95131 , 95143 , 95153 , 95177 , 95189 , 95191 , 95203 , 95213 , 95219 , 95231 , 95233 , 95239 , 95257 , 95261 , 95267 , 95273 , 95279 , 95287 , 95311 , 95317 , 95327 , 95339 , 95369 , 95383 , 95393 , 95401 , 95413 , 95419 , 95429 , 95441 , 95443 , 95461 , 95467 , 95471 , 95479 , 95483 , 95507 , 95527 , 95531 , 95539 , 95549 , 95561 , 95569 , 95581 , 95597 , 95603 , 95617 , 95621 , 95629 , 95633 , 95651 , 95701 , 95707 , 95713 , 95717 , 95723 , 95731 , 95737 , 95747 , 95773 , 95783 , 95789 , 95791 , 95801 , 95803 , 95813 , 95819 , 95857 , 95869 , 95873 , 95881 , 95891 , 95911 , 95917 , 95923 , 95929 , 95947 , 95957 , 95959 , 95971 , 95987 , 95989 , 96001 , 96013 , 96017 , 96043 , 96053 , 96059 , 96079 , 96097 , 96137 , 96149 , 96157 , 96167 , 96179 , 96181 , 96199 , 96211 , 96221 , 96223 , 96233 , 96259 , 96263 , 96269 , 96281 , 96289 , 96293 , 96323 , 96329 , 96331 , 96337 , 96353 , 96377 , 96401 , 96419 , 96431 , 96443 , 96451 , 96457 , 96461 , 96469 , 96479 , 96487 , 96493 , 96497 , 96517 , 96527 , 96553 , 96557 , 96581 , 96587 , 96589 , 96601 , 96643 , 96661 , 96667 , 96671 , 96697 , 96703 , 96731 , 96737 , 96739 , 96749 , 96757 , 96763 , 96769 , 96779 , 96787 , 96797 , 96799 , 96821 , 96823 , 96827 , 96847 , 96851 , 96857 , 96893 , 96907 , 96911 , 96931 , 96953 , 96959 , 96973 , 96979 , 96989 , 96997 , 97001 , 97003 , 97007 , 97021 , 97039 , 97073 , 97081 , 97103 , 97117 , 97127 , 97151 , 97157 , 97159 , 97169 , 97171 , 97177 , 97187 , 97213 , 97231 , 97241 , 97259 , 97283 , 97301 , 97303 , 97327 , 97367 , 97369 , 97373 , 97379 , 97381 , 97387 , 97397 , 97423 , 97429 , 97441 , 97453 , 97459 , 97463 , 97499 , 97501 , 97511 , 97523 , 97547 , 97549 , 97553 , 97561 , 97571 , 97577 , 97579 , 97583 , 97607 , 97609 , 97613 , 97649 , 97651 , 97673 , 97687 , 97711 , 97729 , 97771 , 97777 , 97787 , 97789 , 97813 , 97829 , 97841 , 97843 , 97847 , 97849 , 97859 , 97861 , 97871 , 97879 , 97883 , 97919 , 97927 , 97931 , 97943 , 97961 , 97967 , 97973 , 97987 , 98009 , 98011 , 98017 , 98041 , 98047 , 98057 , 98081 , 98101 , 98123 , 98129 , 98143 , 98179 , 98207 , 98213 , 98221 , 98227 , 98251 , 98257 , 98269 , 98297 , 98299 , 98317 , 98321 , 98323 , 98327 , 98347 , 98369 , 98377 , 98387 , 98389 , 98407 , 98411 , 98419 , 98429 , 98443 , 98453 , 98459 , 98467 , 98473 , 98479 , 98491 , 98507 , 98519 , 98533 , 98543 , 98561 , 98563 , 98573 , 98597 , 98621 , 98627 , 98639 , 98641 , 98663 , 98669 , 98689 , 98711 , 98713 , 98717 , 98729 , 98731 , 98737 , 98773 , 98779 , 98801 , 98807 , 98809 , 98837 , 98849 , 98867 , 98869 , 98873 , 98887 , 98893 , 98897 , 98899 , 98909 , 98911 , 98927 , 98929 , 98939 , 98947 , 98953 , 98963 , 98981 , 98993 , 98999 , 99013 , 99017 , 99023 , 99041 , 99053 , 99079 , 99083 , 99089 , 99103 , 99109 , 99119 , 99131 , 99133 , 99137 , 99139 , 99149 , 99173 , 99181 , 99191 , 99223 , 99233 , 99241 , 99251 , 99257 , 99259 , 99277 , 99289 , 99317 , 99347 , 99349 , 99367 , 99371 , 99377 , 99391 , 99397 , 99401 , 99409 , 99431 , 99439 , 99469 , 99487 , 99497 , 99523 , 99527 , 99529 , 99551 , 99559 , 99563 , 99571 , 99577 , 99581 , 99607 , 99611 , 99623 , 99643 , 99661 , 99667 , 99679 , 99689 , 99707 , 99709 , 99713 , 99719 , 99721 , 99733 , 99761 , 99767 , 99787 , 99793 , 99809 , 99817 , 99823 , 99829 , 99833 , 99839 , 99859 , 99871 , 99877 , 99881 , 99901 , 99907 , 99923 , 99929 , 99961 , 99971 , 99989 , 99991 , 100003 ] <NEWLINE> for i in lis : <NEWLINE> <INDENT> if i >= N : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <STRING> <NEWLINE>
import re <NEWLINE> <NL> S = input ( ) <NEWLINE> L = <STRING> <NEWLINE> <NL> if re . match ( L , S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> ans = n * ( n - 1 ) // 2 <NEWLINE> <NL> <COMMENT> <NL> print ( ans ) <NEWLINE>
import sys <NEWLINE> S = input ( ) <NEWLINE> A = [ ] <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if s != <STRING> : A . append ( i ) <NEWLINE> <DEDENT> if not A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in range ( len ( A ) // 2 ) : <NEWLINE> <INDENT> if S [ A [ i ] ] != S [ A [ - i - 1 ] ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> ans = abs ( ( len ( S ) - 1 - A [ - 1 ] ) - A [ 0 ] ) <NEWLINE> for i in range ( len ( A ) // 2 ) : <NEWLINE> <INDENT> cnt = abs ( A [ i + 1 ] - A [ i ] - ( A [ - 1 - i ] - A [ - 2 - i ] ) ) <NEWLINE> ans += cnt <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 1 <NEWLINE> D = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> D += L [ i ] <NEWLINE> if D <= X : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> k = min ( k , b - a + 1 ) <NEWLINE> * al , = range ( a , a + k ) <NEWLINE> * al2 , = range ( b - k + 1 , b + 1 ) <NEWLINE> ans = al + al2 <NEWLINE> ans = list ( set ( ans ) ) <NEWLINE> ans . sort ( ) <NEWLINE> for i in ans : print ( i ) <NEWLINE> <NL>
import math <NEWLINE> x = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> <NL> def expo ( x , i ) : <NEWLINE> <INDENT> while x % i == 0 : <NEWLINE> <INDENT> x = x // i <NEWLINE> <DEDENT> if x == 1 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> if x > 4 : <NEWLINE> <INDENT> while x > 1 : <NEWLINE> <INDENT> for j in range ( 2 , int ( math . sqrt ( x ) ) + 1 ) : <NEWLINE> <INDENT> if expo ( x , j ) == True : <NEWLINE> <INDENT> print ( x ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if expo ( x , j ) == True : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * ( 2 ** n + 1 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> temp = 0 <NEWLINE> for i in c : <NEWLINE> <INDENT> temp += 2 ** ( i - 1 ) <NEWLINE> <DEDENT> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> if i != 0 and dp [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> t = i | temp <NEWLINE> if dp [ t ] == 0 : <NEWLINE> <INDENT> dp [ t ] = dp [ i ] + a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ t ] = min ( dp [ i ] + a , dp [ t ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = dp [ 2 ** n - 1 ] <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> dp = [ - 1 ] * N <NEWLINE> cnt = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> idx = bisect . bisect_left ( dp , a ) <NEWLINE> dp [ idx - 1 ] = a <NEWLINE> <DEDENT> print ( len ( dp [ bisect . bisect_left ( dp , 0 ) : ] ) ) <NEWLINE>
ss = input ( ) <NEWLINE> <NL> n = len ( ss ) <NEWLINE> arrs = [ ss [ 0 ] ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if len ( arrs [ - 1 ] ) == 2 : <NEWLINE> <INDENT> if arrs [ - 1 ] . endswith ( ss [ i ] ) : <NEWLINE> <INDENT> arrs . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arrs . append ( ss [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if arrs [ - 1 ] == ss [ i ] : <NEWLINE> <INDENT> arrs . append ( ss [ i : i + 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arrs . append ( ss [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> c = arrs . count ( <STRING> ) <NEWLINE> <NL> if arrs [ - 1 ] == arrs [ - 2 ] : <NEWLINE> <INDENT> ans = len ( arrs ) - 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = len ( arrs ) <NEWLINE> <DEDENT> print ( ans - c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> dp = [ float ( <STRING> ) ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if dp [ i ] == float ( <STRING> ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 1 , n // 6 + 1 ) : <NEWLINE> <INDENT> if i + 6 ** j > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp [ i + 6 ** j ] = min ( dp [ i + 6 ** j ] , dp [ i ] + 1 ) <NEWLINE> <DEDENT> for j in range ( 1 , n // 9 + 1 ) : <NEWLINE> <INDENT> if i + 9 ** j > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp [ i + 9 ** j ] = min ( dp [ i + 9 ** j ] , dp [ i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = n <NEWLINE> for i in range ( max ( 0 , n - 5 ) , n + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , dp [ i ] + n - i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = a * b <NEWLINE> if c % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> import math <NEWLINE> <NL> a , b , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ - math . inf ] <NEWLINE> t = [ - math . inf ] <NEWLINE> x = [ ] <NEWLINE> for _ in range ( a ) : <NEWLINE> <INDENT> s . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for _ in range ( b ) : <NEWLINE> <INDENT> t . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> x . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> s . append ( math . inf ) <NEWLINE> t . append ( math . inf ) <NEWLINE> <NL> for i in x : <NEWLINE> <INDENT> ws = abs ( s [ bisect . bisect ( s , i ) - 1 ] - i ) <NEWLINE> if ws != math . inf : <NEWLINE> <INDENT> ws += min ( abs ( t [ bisect . bisect ( t , s [ bisect . bisect ( s , i ) - 1 ] ) - 1 ] - s [ bisect . bisect ( s , i ) - 1 ] ) , abs ( t [ bisect . bisect ( t , s [ bisect . bisect ( s , i ) - 1 ] ) ] - s [ bisect . bisect ( s , i ) - 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ws = math . inf <NEWLINE> <NL> <DEDENT> es = abs ( s [ bisect . bisect ( s , i ) ] - i ) <NEWLINE> if es != math . inf : <NEWLINE> <INDENT> es += min ( abs ( t [ bisect . bisect ( t , s [ bisect . bisect ( s , i ) ] ) - 1 ] - s [ bisect . bisect ( s , i ) ] ) , abs ( t [ bisect . bisect ( t , s [ bisect . bisect ( s , i ) ] ) ] - s [ bisect . bisect ( s , i ) ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> es = math . inf <NEWLINE> <NL> <DEDENT> wt = abs ( t [ bisect . bisect ( t , i ) - 1 ] - i ) <NEWLINE> if wt != math . inf : <NEWLINE> <INDENT> wt += min ( abs ( s [ bisect . bisect ( s , t [ bisect . bisect ( t , i ) - 1 ] ) - 1 ] - t [ bisect . bisect ( t , i ) - 1 ] ) , abs ( s [ bisect . bisect ( s , t [ bisect . bisect ( t , i ) - 1 ] ) ] - t [ bisect . bisect ( t , i ) - 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wt = math . inf <NEWLINE> <NL> <DEDENT> et = abs ( t [ bisect . bisect ( t , i ) ] - i ) <NEWLINE> if et != math . inf : <NEWLINE> <INDENT> et += min ( abs ( s [ bisect . bisect ( s , t [ bisect . bisect ( t , i ) ] ) - 1 ] - t [ bisect . bisect ( t , i ) ] ) , abs ( s [ bisect . bisect ( s , t [ bisect . bisect ( t , i ) ] ) ] - t [ bisect . bisect ( t , i ) ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> et = math . inf <NEWLINE> <NL> <DEDENT> print ( min ( ws , es , wt , et ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def hcf ( l ) : <NEWLINE> <INDENT> return reduce ( math . gcd , l ) <NEWLINE> <DEDENT> gcd = hcf ( A ) <NEWLINE> m = max ( A ) <NEWLINE> if k % gcd == 0 and k <= m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> from heapq import heappop , heappush <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> EPS = 1e-8 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def mapline ( t = int ) : <NEWLINE> <INDENT> return map ( t , sysread ( ) . split ( ) ) <NEWLINE> <DEDENT> def mapread ( t = int ) : <NEWLINE> <INDENT> return map ( t , read ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def dfs ( c , to , cols , max_counts , pre_col = 0 ) : <NEWLINE> <INDENT> colors = set ( ) <NEWLINE> colors . add ( pre_col ) <NEWLINE> num = 1 <NEWLINE> for idx , n in to [ c ] : <NEWLINE> <INDENT> if cols [ idx ] : continue <NEWLINE> for i in range ( num , max_counts + 1 ) : <NEWLINE> <INDENT> if not i in colors : <NEWLINE> <INDENT> num = i <NEWLINE> cols [ idx ] = i <NEWLINE> colors . add ( i ) <NEWLINE> dfs ( n , to , cols , max_counts , i ) <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> N = int ( sysread ( ) ) <NEWLINE> to = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> cols = [ 0 ] * ( N - 1 ) <NEWLINE> counts = [ 0 for i in range ( N + 1 ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = mapline ( ) <NEWLINE> to [ a ] . append ( ( i , b ) ) <NEWLINE> to [ b ] . append ( ( i , a ) ) <NEWLINE> counts [ a ] += 1 <NEWLINE> counts [ b ] += 1 <NEWLINE> <NL> <DEDENT> max_counts = max ( counts ) <NEWLINE> print ( max_counts ) <NEWLINE> dfs ( 1 , to , cols , max_counts ) <NEWLINE> <NL> for c in cols : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if len ( s ) <= 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ 0 ] == s [ - 1 ] : <NEWLINE> <INDENT> del s [ 0 ] <NEWLINE> del s [ - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> del s [ 0 ] <NEWLINE> <DEDENT> elif s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> del s [ - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
input ( ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> D = [ 0 ] * ( 10 ** 7 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> D [ a - 1 ] += 1 <NEWLINE> D [ a ] += 1 <NEWLINE> D [ a + 1 ] += 1 <NEWLINE> <DEDENT> print ( max ( D ) ) <NEWLINE>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def mapint ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , M = mapint ( ) <NEWLINE> As = list ( mapint ( ) ) <NEWLINE> num_lis = [ 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] <NEWLINE> need_m = [ num_lis [ a - 1 ] for a in As ] <NEWLINE> dp = [ - 1 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for a , need in zip ( As , need_m ) : <NEWLINE> <INDENT> if need > i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif dp [ i - need ] == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif dp [ i - need ] == 0 : <NEWLINE> <INDENT> dp [ i ] = max ( dp [ i ] , a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = max ( dp [ i ] , dp [ i - need ] * 10 + a ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> while a [ i ] % 2 == 0 : <NEWLINE> <INDENT> a [ i ] = a [ i ] // 2 <NEWLINE> t += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> t = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( 1 if S [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <NL> <DEDENT> for j in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ 2 , 1 ] <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> a . append ( a [ i ] + a [ i + 1 ] ) <NEWLINE> <DEDENT> print ( a [ n ] ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> if i == <STRING> or i == <STRING> or i == <STRING> or i == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if cnt != 0 : <NEWLINE> <INDENT> l . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> l . append ( cnt ) <NEWLINE> print ( max ( l ) ) <NEWLINE>
import math <NEWLINE> from collections import Counter <NEWLINE> from sys import exit <NEWLINE> from itertools import product <NEWLINE> <NL> ii = lambda : int ( input ( ) ) <NEWLINE> mi = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> li = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = ii ( ) <NEWLINE> a = li ( ) <NEWLINE> <NL> cnt = Counter ( a ) <NEWLINE> ans = 0 <NEWLINE> for i , j in cnt . items ( ) : <NEWLINE> <INDENT> if i > j : <NEWLINE> <INDENT> ans += j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += j - i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = [ <STRING> . join ( sorted ( input ( ) ) ) for _ in range ( N ) ] <NEWLINE> T = Counter ( L ) . values ( ) <NEWLINE> print ( sum ( v * ( v - 1 ) // 2 for v in T ) ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( a , min ( a + k , b + 1 ) ) : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> for i in range ( max ( b - k + 1 , a ) , b + 1 ) : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> ans = sorted ( list ( set ( ans ) ) ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> tree = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ a ] . append ( [ b , i ] ) <NEWLINE> tree [ b ] . append ( [ a , i ] ) <NEWLINE> <DEDENT> queue = deque ( [ [ 1 , 0 ] ] ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> ans [ 1 ] = 1 <NEWLINE> visited = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> v , c = queue . popleft ( ) <NEWLINE> color = 1 <NEWLINE> for nv , i in tree [ v ] : <NEWLINE> <INDENT> if c == color : <NEWLINE> <INDENT> color += 1 <NEWLINE> <DEDENT> if visited [ i ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited [ i ] = 1 <NEWLINE> queue . append ( [ nv , color ] ) <NEWLINE> ans [ i ] = color <NEWLINE> color += 1 <NEWLINE> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ set ( [ ] ) for _ in range ( n ) ] <NEWLINE> <COMMENT> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> g [ a ] . add ( b ) <NEWLINE> <NL> <DEDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> s , t = s - 1 , t - 1 <NEWLINE> <NL> <COMMENT> <NL> q = deque ( ) <NEWLINE> level = [ [ - 1 ] * n for i in range ( 3 ) ] <NEWLINE> q . append ( ( s , 0 ) ) <NEWLINE> level [ 0 ] [ s ] = 0 <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> cur , hp = q . popleft ( ) <NEWLINE> lvl = level [ hp ] [ cur ] <NEWLINE> for i in g [ cur ] : <NEWLINE> <INDENT> if level [ ( hp + 1 ) % 3 ] [ i ] == - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> level [ ( hp + 1 ) % 3 ] [ i ] = lvl + 1 <NEWLINE> q . append ( ( i , ( hp + 1 ) % 3 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( level [ 0 ] [ t ] // 3 ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = 0 <NEWLINE> r = N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if L > l : <NEWLINE> <INDENT> l = L <NEWLINE> <NL> <DEDENT> if R < r : <NEWLINE> <INDENT> r = R <NEWLINE> <NL> <DEDENT> ans = r - l + 1 <NEWLINE> if ans < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> A , B , C = sorted ( A ) , sorted ( B ) , sorted ( C ) <NEWLINE> <NL> for b in B : <NEWLINE> <INDENT> a = bisect . bisect_left ( A , b ) <NEWLINE> c = bisect . bisect_right ( C , b ) <NEWLINE> ans += a * ( N - c ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , S = open ( 0 ) . read ( ) . split ( ) <NEWLINE> S = list ( map ( int , list ( S ) ) ) <NEWLINE> N = int ( N ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( 0 , 10 ) : <NEWLINE> <INDENT> for j in range ( 0 , 10 ) : <NEWLINE> <INDENT> for k in range ( 0 , 10 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = S . index ( i ) <NEWLINE> m = S [ n + 1 : ] . index ( j ) <NEWLINE> o = S [ n + m + 2 : ] . index ( k ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b . sort ( ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c . sort ( ) <NEWLINE> ans = 0 <NEWLINE> import bisect <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = bisect . bisect_left ( a , b [ i ] ) <NEWLINE> y = bisect . bisect_right ( c , b [ i ] ) <NEWLINE> ans += x * ( n - y ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> u , v = map ( int , readline ( ) . split ( ) ) <NEWLINE> G [ u - 1 ] . append ( v - 1 ) <NEWLINE> <DEDENT> S , T = map ( int , readline ( ) . split ( ) ) <NEWLINE> S -= 1 <NEWLINE> T -= 1 <NEWLINE> <NL> dist = [ [ - 1 ] * 3 for _ in range ( N ) ] <NEWLINE> dist [ S ] [ 0 ] = 0 <NEWLINE> queue = deque ( [ ( S , 0 ) ] ) <NEWLINE> while queue : <NEWLINE> <INDENT> v , step = queue . popleft ( ) <NEWLINE> if step == 0 and v == T : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for nv in G [ v ] : <NEWLINE> <INDENT> if dist [ nv ] [ ( step - 1 ) % 3 ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ nv ] [ ( step - 1 ) % 3 ] = dist [ v ] [ step ] + 1 <NEWLINE> queue . append ( ( nv , ( step - 1 ) % 3 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if dist [ T ] [ 0 ] == - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dist [ T ] [ 0 ] // 3 ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a - 1 ] . append ( b - 1 ) <NEWLINE> g [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> c = [ 0 ] * n <NEWLINE> <NL> for j in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> c [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> used = [ 0 ] * n <NEWLINE> used [ 0 ] = 1 <NEWLINE> <NL> def dfs ( x ) : <NEWLINE> <INDENT> cost = c [ x ] <NEWLINE> for nx in g [ x ] : <NEWLINE> <INDENT> if used [ nx ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> used [ nx ] = 1 <NEWLINE> c [ nx ] += cost <NEWLINE> dfs ( nx ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * c ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> adj = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> adj [ a ] . append ( b ) <NEWLINE> adj [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> def dfs ( v , p = - 1 ) : <NEWLINE> <INDENT> global ans <NEWLINE> <NL> res = 1 <NEWLINE> ts = [ ] <NEWLINE> for u in adj [ v ] : <NEWLINE> <INDENT> if ( u == p ) : continue <NEWLINE> t = dfs ( u , v ) <NEWLINE> res += t <NEWLINE> ts . append ( t ) <NEWLINE> <NL> <DEDENT> if p != - 1 : <NEWLINE> <INDENT> ts . append ( N - res ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> now = pows [ N - 1 ] - 1 <NEWLINE> for t in ts : <NEWLINE> <COMMENT> <NL> <INDENT> now -= pows [ t ] - 1 <NEWLINE> <DEDENT> ans += now <NEWLINE> return res <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> pows = [ 1 ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> pows [ i ] = ( pows [ i - 1 ] * 2 ) % MOD <NEWLINE> <NL> <DEDENT> dfs ( 1 ) <NEWLINE> print ( ( ans * pow ( pows [ N ] , MOD - 2 , MOD ) ) % MOD ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> CS = [ 0 ] <NEWLINE> cur = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if S [ i - 1 ] + S [ i ] == <STRING> : <NEWLINE> <INDENT> cur += 1 <NEWLINE> CS . append ( cur ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> CS . append ( cur ) <NEWLINE> <NL> <DEDENT> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( CS [ r - 1 ] - CS [ l - 1 ] ) <NEWLINE> <NL> <DEDENT>
import re <NEWLINE> sin = input ( ) <NEWLINE> match = re . findall ( <STRING> , sin ) <NEWLINE> m_len = [ len ( m ) for m in match ] <NEWLINE> print ( max ( m_len if m_len else <STRING> ) ) <NEWLINE>
import queue <NEWLINE> import numpy as np <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> maze = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> dir4 = [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] <NEWLINE> <NL> <NL> def solveMaze ( s ) : <NEWLINE> <INDENT> q = queue . Queue ( ) <NEWLINE> q . put ( [ s [ 0 ] , s [ 1 ] , 0 ] ) <NEWLINE> times = [ [ 999999999 for j in range ( W ) ] for i in range ( H ) ] <NEWLINE> tmpAns = 0 <NEWLINE> times [ s [ 0 ] ] [ s [ 1 ] ] = 0 <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> now = q . get ( ) <NEWLINE> tmpAns = max ( tmpAns , now [ 2 ] ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> nextH = now [ 0 ] + int ( dir4 [ i ] [ 0 ] ) <NEWLINE> nextW = now [ 1 ] + int ( dir4 [ i ] [ 1 ] ) <NEWLINE> nextTime = now [ 2 ] + 1 <NEWLINE> <NL> if nextH < 0 or nextH >= H or nextW < 0 or nextW >= W or maze [ nextH ] [ nextW ] == <STRING> or times [ nextH ] [ nextW ] <= nextTime : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> times [ nextH ] [ nextW ] = nextTime <NEWLINE> q . put ( [ nextH , nextW , nextTime ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return tmpAns <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for sH in range ( H ) : <NEWLINE> <INDENT> for sW in range ( W ) : <NEWLINE> <INDENT> if maze [ sH ] [ sW ] == <STRING> : <NEWLINE> <INDENT> ans = max ( ans , solveMaze ( [ sH , sW ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = Counter ( input ( ) ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> s &= Counter ( input ( ) ) <NEWLINE> <DEDENT> print ( <STRING> . join ( sorted ( s . elements ( ) ) ) ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> S = readline ( ) . rstrip ( ) <NEWLINE> gx , gy = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> C = [ ] <NEWLINE> <NL> import itertools <NEWLINE> for key , g in itertools . groupby ( S ) : <NEWLINE> <INDENT> C . append ( [ key , len ( list ( g ) ) ] ) <NEWLINE> <NL> <DEDENT> x , y = 0 , 0 <NEWLINE> ind = 0 <NEWLINE> if C [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> x += C [ 0 ] [ 1 ] <NEWLINE> ind = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> dirX = True <NEWLINE> now_x = { x } <NEWLINE> now_y = { y } <NEWLINE> for i in range ( ind , len ( C ) ) : <NEWLINE> <INDENT> if C [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> step = C [ i ] [ 1 ] <NEWLINE> if dirX : <NEWLINE> <INDENT> nex_x = set ( ) <NEWLINE> for n in now_x : <NEWLINE> <INDENT> nex_x . add ( n + step ) <NEWLINE> nex_x . add ( n - step ) <NEWLINE> <DEDENT> now_x = nex_x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nex_y = set ( ) <NEWLINE> for n in now_y : <NEWLINE> <INDENT> nex_y . add ( n + step ) <NEWLINE> nex_y . add ( n - step ) <NEWLINE> <DEDENT> now_y = nex_y <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if C [ i ] [ 1 ] % 2 == 1 : <NEWLINE> <INDENT> dirX ^= True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if gx in now_x and gy in now_y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , ( input ( ) for i in range ( N ) ) ) ) <NEWLINE> B = sorted ( A , reverse = True ) <NEWLINE> a = B [ 0 ] <NEWLINE> a1 = B [ 1 ] <NEWLINE> <NL> <NL> for x in A : <NEWLINE> <INDENT> if x != a : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a1 ) <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> N , K , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> root_road = [ - 1 ] * N <NEWLINE> root_train = [ - 1 ] * N <NEWLINE> <NL> <NL> def find_road ( x ) : <NEWLINE> <INDENT> if root_road [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <DEDENT> root_road [ x ] = find_road ( root_road [ x ] ) <NEWLINE> return root_road [ x ] <NEWLINE> <NL> <NL> <DEDENT> def union_road ( x , y ) : <NEWLINE> <INDENT> x = find_road ( x ) <NEWLINE> y = find_road ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> root_road [ x ] += root_road [ y ] <NEWLINE> root_road [ y ] = x <NEWLINE> <NL> <NL> <DEDENT> def same_road ( x , y ) : <NEWLINE> <INDENT> return find_road ( x ) == find_road ( y ) <NEWLINE> <NL> <NL> <DEDENT> def find_train ( x ) : <NEWLINE> <INDENT> if root_train [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <DEDENT> root_train [ x ] = find_train ( root_train [ x ] ) <NEWLINE> return root_train [ x ] <NEWLINE> <NL> <NL> <DEDENT> def union_train ( x , y ) : <NEWLINE> <INDENT> x = find_train ( x ) <NEWLINE> y = find_train ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> root_train [ x ] += root_train [ y ] <NEWLINE> root_train [ y ] = x <NEWLINE> <NL> <NL> <DEDENT> def same_train ( x , y ) : <NEWLINE> <INDENT> return find_train ( x ) == find_train ( y ) <NEWLINE> <NL> <NL> <DEDENT> dc = defaultdict ( list ) <NEWLINE> dt = defaultdict ( list ) <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> p -= 1 <NEWLINE> q -= 1 <NEWLINE> dc [ p ] . append ( q ) <NEWLINE> dc [ q ] . append ( p ) <NEWLINE> union_road ( p , q ) <NEWLINE> <NL> <DEDENT> for _ in range ( L ) : <NEWLINE> <INDENT> r , s = map ( int , input ( ) . split ( ) ) <NEWLINE> r -= 1 <NEWLINE> s -= 1 <NEWLINE> dt [ r ] . append ( s ) <NEWLINE> dt [ s ] . append ( r ) <NEWLINE> union_train ( r , s ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> dic = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( find_road ( i ) , find_train ( i ) ) not in dic : <NEWLINE> <INDENT> dic [ ( find_road ( i ) , find_train ( i ) ) ] = 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ ( find_road ( i ) , find_train ( i ) ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans . append ( dic [ ( find_road ( i ) , find_train ( i ) ) ] ) <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> a = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> <DEDENT> S = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if len ( S ) < 26 : <NEWLINE> <INDENT> for x in S : <NEWLINE> <INDENT> d [ x ] += 1 <NEWLINE> <DEDENT> for x in a : <NEWLINE> <INDENT> if d [ x ] == 0 : <NEWLINE> <INDENT> print ( S + x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i = 25 <NEWLINE> while S [ i - 1 ] > S [ i ] : <NEWLINE> <INDENT> i -= 1 <NEWLINE> <DEDENT> ss = sorted ( list ( S [ i - 1 : ] ) ) <NEWLINE> t = S [ i - 1 ] <NEWLINE> print ( S [ : i - 1 ] + ss [ ss . index ( t ) + 1 ] ) <NEWLINE> <DEDENT>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> yosen = 0 <NEWLINE> yosen_b = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and yosen < ( A + B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> yosen += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> and yosen < ( A + B ) and yosen_b <= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> yosen += 1 <NEWLINE> yosen_b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> from sys import stdin , stdout <NEWLINE> import sys <NEWLINE> from math import gcd , ceil , sqrt <NEWLINE> from collections import Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> ii1 = lambda : int ( stdin . readline ( ) . strip ( ) ) <NEWLINE> is1 = lambda : stdin . readline ( ) . strip ( ) <NEWLINE> iia = lambda : list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> isa = lambda : stdin . readline ( ) . strip ( ) . split ( ) <NEWLINE> mod = 1000000007 <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> n , m = iia ( ) <NEWLINE> dp = [ - 1 ] * ( n + 1 ) <NEWLINE> d = { } <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = iia ( ) <NEWLINE> d . setdefault ( a , [ ] ) . append ( b ) <NEWLINE> <NL> <DEDENT> def dfs ( cur ) : <NEWLINE> <INDENT> if dp [ cur ] != - 1 : <NEWLINE> <INDENT> return dp [ cur ] <NEWLINE> <DEDENT> t = 0 <NEWLINE> for i in d . get ( cur , [ ] ) : <NEWLINE> <INDENT> t = max ( 1 + dfs ( i ) , t ) <NEWLINE> <DEDENT> dp [ cur ] = t <NEWLINE> return dp [ cur ] <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> res = max ( res , dfs ( i ) ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> need = 0 <NEWLINE> stock = 0 <NEWLINE> for a , b in zip ( A , B ) : <NEWLINE> <INDENT> if a > b : need += ( a - b ) <NEWLINE> if b > a : stock += ( b - a ) // 2 <NEWLINE> <NL> <DEDENT> if stock >= need : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> gcd_l = [ 0 ] <NEWLINE> gcd_r = [ 0 ] <NEWLINE> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> gcd_l . append ( math . gcd ( gcd_l [ i ] , A [ i ] ) ) <NEWLINE> gcd_r . append ( math . gcd ( gcd_r [ i ] , A [ - ( i + 1 ) ] ) ) <NEWLINE> <NL> <DEDENT> gcd_r = gcd_r [ : : - 1 ] <NEWLINE> <NL> max_gcd = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> max_gcd = max ( max_gcd , math . gcd ( gcd_l [ i ] , gcd_r [ i + 1 ] ) ) <NEWLINE> <NL> <DEDENT> print ( max_gcd ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> query = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> query [ a - 1 ] . append ( ( b - 1 , c ) ) <NEWLINE> query [ b - 1 ] . append ( ( a - 1 , c ) ) <NEWLINE> <DEDENT> q , k = map ( int , input ( ) . split ( ) ) <NEWLINE> stack = deque ( [ ( k - 1 , 0 , - 1 ) ] ) <NEWLINE> dist = [ 0 ] * n <NEWLINE> while stack : <NEWLINE> <INDENT> now , cnt , per = stack . pop ( ) <NEWLINE> lis = query [ now ] <NEWLINE> dist [ now ] = cnt <NEWLINE> for nx , c in lis : <NEWLINE> <INDENT> if nx == per : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if c != 0 : <NEWLINE> <INDENT> stack . append ( ( nx , cnt + c , now ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( dist [ x - 1 ] + dist [ y - 1 ] ) <NEWLINE> <DEDENT>
import collections as cl <NEWLINE> N = int ( input ( ) ) <NEWLINE> x = [ ] <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> x . append ( a ) <NEWLINE> <NL> <DEDENT> d = cl . Counter ( x ) <NEWLINE> <NL> for i in d . values ( ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> n , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a = list ( map ( lambda x : int ( x ) * ( - 1 ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import heapq <NEWLINE> <NL> q_a = heapq . heapify ( a ) <NEWLINE> <NL> for m in range ( m ) : <NEWLINE> <INDENT> x = heapq . heappop ( a ) * ( - 1 ) <NEWLINE> heapq . heappush ( a , ( x // 2 ) * ( - 1 ) ) <NEWLINE> <NL> <DEDENT> print ( sum ( a ) * ( - 1 ) ) <NEWLINE>
a , b , c = input ( ) . split ( ) <NEWLINE> if a [ - 1 ] == b [ 0 ] and b [ - 1 ] == c [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> opt = [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> opt += [ min ( [ opt [ - j ] + abs ( h [ i - j ] - h [ i ] ) for j in range ( 1 , min ( i , k ) + 1 ) ] ) ] <NEWLINE> <DEDENT> print ( opt [ - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if p [ i ] == i + 1 : <NEWLINE> <INDENT> p [ i ] , p [ i + 1 ] = p [ i + 1 ] , p [ i ] <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if p [ N - 1 ] == N : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
o = input ( ) <NEWLINE> e = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( e ) ) : <NEWLINE> <INDENT> ans += o [ i ] + e [ i ] <NEWLINE> <NL> <DEDENT> if len ( o ) == len ( e ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans + o [ - 1 ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> set_A = set ( ) <NEWLINE> dp = [ 0 ] * n <NEWLINE> mod = pow ( 10 , 9 ) + 7 <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> set_A . add ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> if 1 not in set_A : <NEWLINE> <INDENT> dp [ 0 ] = 1 <NEWLINE> <DEDENT> if 2 not in set_A and n != 1 : <NEWLINE> <INDENT> dp [ 1 ] = 1 + dp [ 0 ] <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if i + 1 not in set_A : <NEWLINE> <INDENT> dp [ i ] += ( dp [ i - 1 ] + dp [ i - 2 ] ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> r , g , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> for ir in range ( n + 1 ) : <NEWLINE> <INDENT> vr = r * ir <NEWLINE> if vr > n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for ig in range ( n + 1 ) : <NEWLINE> <INDENT> vg = g * ig <NEWLINE> if vg + vr > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cb = n - vr - vg <NEWLINE> if cb % b == 0 : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> count_by_kw = Counter ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> dict = { } <NEWLINE> ans = 0 <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> a = sorted ( input ( ) ) <NEWLINE> b = <STRING> . join ( a ) <NEWLINE> if not b in dict : <NEWLINE> <INDENT> dict [ b ] = x <NEWLINE> l . append ( b ) <NEWLINE> count_by_kw [ b ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = count_by_kw [ b ] <NEWLINE> count_by_kw [ b ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for y in range ( len ( l ) ) : <NEWLINE> <INDENT> r = l [ y ] <NEWLINE> w = count_by_kw [ r ] <NEWLINE> ans += w * ( w - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
import copy <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> m = 0 <NEWLINE> S = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> if m < a : <NEWLINE> <INDENT> s = m <NEWLINE> m = a <NEWLINE> <DEDENT> elif s < a : <NEWLINE> <INDENT> s = a <NEWLINE> <NL> <DEDENT> <DEDENT> c = [ ] <NEWLINE> mL = 0 <NEWLINE> mR = 0 <NEWLINE> <COMMENT> <NL> <NL> <NL> for i , a in enumerate ( A ) : <NEWLINE> <COMMENT> <NL> <INDENT> if a == m : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = [ ( x + 1 ) / 2 for x in p ] <NEWLINE> q1 = sum ( q [ : k ] ) <NEWLINE> ans = q1 <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> x = q1 - q [ i ] + q [ i + k ] <NEWLINE> q1 = x <NEWLINE> if ans < x : <NEWLINE> <INDENT> ans = x <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> from itertools import accumulate <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> aaa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> acc = [ 0 ] + list ( accumulate ( aaa ) ) <NEWLINE> agg = Counter ( acc ) <NEWLINE> print ( sum ( v * ( v - 1 ) // 2 for v in agg . values ( ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> print ( N * ( N - 1 ) // 2 ) <NEWLINE>
from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> graph = defaultdict ( list ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( [ b , i ] ) <NEWLINE> graph [ b ] . append ( [ a , i ] ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * ( n - 1 ) <NEWLINE> <NL> q = deque ( [ [ 1 , 0 , 0 ] ] ) <NEWLINE> while q : <NEWLINE> <INDENT> v , pcol , root = q . popleft ( ) <NEWLINE> cnt = 1 <NEWLINE> for node in graph [ v ] : <NEWLINE> <INDENT> if node [ 0 ] == root : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if cnt == pcol : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> ans [ node [ 1 ] ] = cnt <NEWLINE> q . append ( [ node [ 0 ] , cnt , v ] ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> root = int ( N ** 0.5 ) <NEWLINE> for i in range ( root , - 1 , - 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( N / i + i - 2 ) ) <NEWLINE>
import math <NEWLINE> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> anslist = [ ] <NEWLINE> for i in range ( 1 , max ( A , B ) + 1 ) : <NEWLINE> <INDENT> if ( A % i == 0 ) & ( B % i == 0 ) : <NEWLINE> <INDENT> anslist . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( anslist [ 0 - K ] ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> from heapq import heappop , heappush <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> EPS = 1e-8 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def mapline ( t = int ) : <NEWLINE> <INDENT> return map ( t , sysread ( ) . split ( ) ) <NEWLINE> <DEDENT> def mapread ( t = int ) : <NEWLINE> <INDENT> return map ( t , read ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> N , * A = mapread ( ) <NEWLINE> ans = 1 <NEWLINE> current = [ 0 , 0 , 0 ] <NEWLINE> for a in A : <NEWLINE> <INDENT> transition = 0 <NEWLINE> cache = 0 <NEWLINE> for i , c in enumerate ( current ) : <NEWLINE> <INDENT> if c == a : <NEWLINE> <INDENT> transition += 1 <NEWLINE> cache = i <NEWLINE> <DEDENT> <DEDENT> ans *= transition <NEWLINE> ans %= mod <NEWLINE> current [ cache ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> line = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> line [ a - 1 ] . append ( b - 1 ) <NEWLINE> line [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> check = [ False ] * N <NEWLINE> <NL> def dfs ( now ) : <NEWLINE> <INDENT> global cnt <NEWLINE> global ans <NEWLINE> if cnt == N : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in line [ now ] : <NEWLINE> <INDENT> if check [ i ] == False : <NEWLINE> <INDENT> check [ i ] = True <NEWLINE> cnt += 1 <NEWLINE> dfs ( i ) <NEWLINE> check [ i ] = False <NEWLINE> cnt -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> check [ 0 ] = True <NEWLINE> cnt = 1 <NEWLINE> ans = 0 <NEWLINE> dfs ( 0 ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> ok = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if sum ( ok ) == 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ok [ int ( s [ i ] ) ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ok [ int ( s [ i ] ) ] = 1 <NEWLINE> nd = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if sum ( nd ) == 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if nd [ int ( s [ j ] ) ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> nd [ int ( s [ j ] ) ] = 1 <NEWLINE> rd = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> if sum ( rd ) == 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if rd [ int ( s [ k ] ) ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> rd [ int ( s [ k ] ) ] = 1 <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> if ( X + Y ) % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N = int ( ( 2 * Y - X ) / 3 ) <NEWLINE> M = int ( ( 2 * X - Y ) / 3 ) <NEWLINE> if N < 0 or M < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> if N == 0 or M == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> if N > 0 and M > 0 : <NEWLINE> <INDENT> List = [ 0 for i in range ( N + M ) ] <NEWLINE> List [ 0 ] = 1 <NEWLINE> for i in range ( N + M - 1 ) : <NEWLINE> <INDENT> List [ i + 1 ] = List [ i ] * ( i + 2 ) % mod <NEWLINE> <DEDENT> print ( List [ N + M - 1 ] * pow ( List [ N - 1 ] , mod - 2 , mod ) * pow ( List [ M - 1 ] , mod - 2 , mod ) % mod ) <NEWLINE> <DEDENT> <DEDENT>
from sys import setrecursionlimit <NEWLINE> setrecursionlimit ( 10 ** 7 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> uvw = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n - 1 ) ] <NEWLINE> d = [ - 1 for i in range ( n ) ] <NEWLINE> edge = [ [ ] for i in range ( n ) ] <NEWLINE> for u , v , w in uvw : <NEWLINE> <INDENT> edge [ u - 1 ] . append ( ( v - 1 , w ) ) <NEWLINE> edge [ v - 1 ] . append ( ( u - 1 , w ) ) <NEWLINE> <DEDENT> def dfs ( now , D ) : <NEWLINE> <INDENT> d [ now ] = D <NEWLINE> for i , j in edge [ now ] : <NEWLINE> <INDENT> if d [ i ] == - 1 : <NEWLINE> <INDENT> dfs ( i , D + j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , 0 ) <NEWLINE> for i in d : <NEWLINE> <INDENT> print ( i % 2 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N , K = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if K >= N : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> H . sort ( reverse = True ) <NEWLINE> del H [ 0 : K ] <NEWLINE> for i in range ( len ( H ) ) : <NEWLINE> <INDENT> ans += H [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def dfs ( tree , n , ans ) : <NEWLINE> <INDENT> for i in tree [ n ] : <NEWLINE> <INDENT> ans [ i ] += ans [ n ] <NEWLINE> tree [ i ] . remove ( n ) <NEWLINE> dfs ( tree , i , ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> px = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> g [ ab [ i ] [ 0 ] - 1 ] . append ( ab [ i ] [ 1 ] - 1 ) <NEWLINE> g [ ab [ i ] [ 1 ] - 1 ] . append ( ab [ i ] [ 0 ] - 1 ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> ans [ px [ i - 1 ] [ 0 ] - 1 ] += px [ i - 1 ] [ 1 ] <NEWLINE> <DEDENT> dfs ( g , 0 , ans ) <NEWLINE> <NL> print ( * ans ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a_p = a // x <NEWLINE> b_p = b // x <NEWLINE> <NL> if a % x == 0 : <NEWLINE> <INDENT> print ( b_p - a_p + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b_p - a_p ) <NEWLINE> <DEDENT>
o = input ( ) <NEWLINE> e = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( e ) ) : <NEWLINE> <INDENT> ans += o [ i ] + e [ i ] <NEWLINE> <DEDENT> if len ( o ) != len ( e ) : <NEWLINE> <INDENT> ans += o [ - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> import bisect <NEWLINE> l = [ [ ] for _ in range ( n ) ] <NEWLINE> l2 = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> p , y = map ( int , input ( ) . split ( ) ) <NEWLINE> bisect . insort_left ( l [ p - 1 ] , y ) <NEWLINE> l2 . append ( [ p , y ] ) <NEWLINE> <NL> <DEDENT> for m in l2 : <NEWLINE> <INDENT> print ( <STRING> . format ( m [ 0 ] ) + <STRING> . format ( bisect . bisect_left ( l [ m [ 0 ] - 1 ] , m [ 1 ] ) + 1 ) ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if 0 <= z <= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> M = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> M [ a ] . append ( b ) <NEWLINE> M [ b ] . append ( a ) <NEWLINE> <DEDENT> yes = <STRING> ; no = <STRING> <NEWLINE> <NL> for i in M [ 0 ] : <NEWLINE> <INDENT> if n - 1 in M [ i ] : <NEWLINE> <INDENT> print ( yes ) ; exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( no ) <NEWLINE> <NL>
n , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> r , s , p = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> t = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> dic = { <STRING> : s , <STRING> : r , <STRING> : p } <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans += dic [ t [ i ] ] <NEWLINE> <DEDENT> dic_ls = [ ] <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if t [ i ] != t [ i - k ] : <NEWLINE> <INDENT> ans += dic [ t [ i ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> subtree_size = [ 0 ] * n <NEWLINE> cnt = [ 0 ] * n <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> p -= 1 <NEWLINE> cnt [ p ] += x <NEWLINE> <DEDENT> ans = [ 0 ] * n <NEWLINE> <NL> def dfs ( G , v , p ) : <NEWLINE> <INDENT> ans [ v ] += cnt [ v ] <NEWLINE> for nv in G [ v ] : <NEWLINE> <INDENT> if nv == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt [ nv ] += cnt [ v ] <NEWLINE> dfs ( G , nv , v ) <NEWLINE> <NL> <DEDENT> subtree_size [ v ] = 1 <NEWLINE> for c in G [ v ] : <NEWLINE> <INDENT> if c == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> subtree_size [ v ] += subtree_size [ c ] <NEWLINE> <NL> <DEDENT> <DEDENT> root = 0 <NEWLINE> dfs ( G , root , - 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] , end = <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 , 0 ] <NEWLINE> ans_abs = 10 ** 200 <NEWLINE> <NL> A_sum = sum ( A ) <NEWLINE> A_1 = 0 <NEWLINE> A_2 = A_sum <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> A_1 += A [ i ] <NEWLINE> A_2 -= A [ i ] <NEWLINE> ans_abs = min ( ans_abs , abs ( A_1 - A_2 ) ) <NEWLINE> <NL> <DEDENT> print ( ans_abs ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xmod = [ y % m for y in x ] <NEWLINE> from collections import Counter <NEWLINE> cx = dict ( Counter ( x ) ) <NEWLINE> cxmod = dict ( Counter ( xmod ) ) <NEWLINE> keys = cxmod . keys ( ) <NEWLINE> ans1 , ans2 = 0 , 0 <COMMENT> <NEWLINE> for k in keys : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> ans1 += cxmod [ k ] // 2 <NEWLINE> cxmod [ k ] -= 2 * ( cxmod [ k ] // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k == m - k : <NEWLINE> <INDENT> ans1 += cxmod [ k ] // 2 <NEWLINE> cxmod [ k ] -= 2 * ( cxmod [ k ] // 2 ) <NEWLINE> <DEDENT> elif m - k in keys : <NEWLINE> <INDENT> tmp = min ( cxmod [ k ] , cxmod [ m - k ] ) <NEWLINE> ans1 += tmp <NEWLINE> cxmod [ k ] -= tmp <NEWLINE> cxmod [ m - k ] -= tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for k in cx : <NEWLINE> <INDENT> v = cx [ k ] <NEWLINE> if v >= 2 and cxmod [ k % m ] >= 2 : <NEWLINE> <INDENT> tmp = min ( v // 2 , cxmod [ k % m ] // 2 ) <NEWLINE> ans2 += tmp <NEWLINE> cxmod [ k % m ] -= tmp * 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans1 + ans2 ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
s = input ( ) <NEWLINE> cnt = len ( s ) <NEWLINE> <NL> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> if s [ 1 : ] == <STRING> * ( cnt - 1 ) : <NEWLINE> <INDENT> print ( 9 * cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 8 + 9 * ( cnt - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s [ 1 : ] == <STRING> * ( cnt - 1 ) : <NEWLINE> <INDENT> print ( int ( s [ 0 ] ) + 9 * ( cnt - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( int ( s [ 0 ] ) - 1 ) + 9 * ( cnt - 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> n , m , S , T = open ( 0 ) . read ( ) . split ( ) <NEWLINE> n , m = int ( n ) , int ( m ) <NEWLINE> l = n * m // gcd ( n , m ) <NEWLINE> <NL> d = { } <NEWLINE> t = l // n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d [ i * t ] = S [ i ] <NEWLINE> <DEDENT> t = l // m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if i * t not in d or d [ i * t ] == T [ i ] : <NEWLINE> <INDENT> d [ i * t ] = T [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 20000000 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ARR = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N - 1 ) ] <NEWLINE> <NL> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> BRR = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> <NL> <NL> <NL> def prepare ( arr , n ) : <NEWLINE> <INDENT> links = [ [ ] for i in range ( n ) ] <NEWLINE> depth = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> startNode = arr [ i ] [ 0 ] - 1 <NEWLINE> endNode = arr [ i ] [ 1 ] - 1 <NEWLINE> dist = arr [ i ] [ 2 ] <NEWLINE> <NL> links [ startNode ] . append ( ( endNode , dist ) ) <NEWLINE> links [ endNode ] . append ( ( startNode , dist ) ) <NEWLINE> <NL> <DEDENT> return links , depth <NEWLINE> <NL> <NL> <DEDENT> def dfs ( currentNode , parrentNode = - 1 , dist = 0 ) : <NEWLINE> <INDENT> childNodes = links [ currentNode ] <NEWLINE> depths [ currentNode ] = dist <NEWLINE> for ( childNode , childDistance ) in childNodes : <NEWLINE> <INDENT> if childNode == parrentNode : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> dfs ( childNode , currentNode , dist + childDistance ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> links , depths = prepare ( ARR , N ) <NEWLINE> <NL> dfs ( K - 1 ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> p1 = BRR [ i ] [ 0 ] - 1 <NEWLINE> p2 = BRR [ i ] [ 1 ] - 1 <NEWLINE> <NL> d1 = depths [ p1 ] <NEWLINE> d2 = depths [ p2 ] <NEWLINE> <NL> print ( d1 + d2 ) <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( A , min ( A + K , B + 1 ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for j in range ( max ( A + K , B - K + 1 ) , B + 1 ) : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = deque ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> B = deque ( ) <NEWLINE> cycle = n % 2 <NEWLINE> for a in A : <NEWLINE> <INDENT> if cycle % 2 == 1 : <NEWLINE> <INDENT> B . appendleft ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( a ) <NEWLINE> <DEDENT> cycle += 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( B ) ) <NEWLINE>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> curCoord = 0 <NEWLINE> n = 1 <NEWLINE> <NL> while ( curCoord <= X ) : <NEWLINE> <INDENT> n = n + 1 <NEWLINE> <NL> if ( n > N + 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> curCoord = curCoord + L [ n - 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - 1 ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> <NL> def f ( hito , zahyo ) : <NEWLINE> <INDENT> x [ hito ] = zahyo <NEWLINE> for tsugi in links [ hito ] : <NEWLINE> <INDENT> if x [ tsugi [ 0 ] ] == None : <NEWLINE> <INDENT> f ( tsugi [ 0 ] , zahyo + tsugi [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x [ tsugi [ 0 ] ] != zahyo + tsugi [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> links = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> l , r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> links [ l ] . append ( [ r , d ] ) <NEWLINE> links [ r ] . append ( [ l , - d ] ) <NEWLINE> <NL> <DEDENT> x = [ None ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if x [ i ] == None : <NEWLINE> <INDENT> f ( i , 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys , math <NEWLINE> from functools import lru_cache <NEWLINE> from collections import defaultdict <NEWLINE> from decimal import Decimal <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <DEDENT> def mi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def ii ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def i2 ( n ) : <NEWLINE> <INDENT> tmp = [ list ( mi ( ) ) for i in range ( n ) ] <NEWLINE> return [ list ( i ) for i in zip ( * tmp ) ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> l = [ 0 ] * 26 <NEWLINE> for c in S : <NEWLINE> <INDENT> l [ ord ( c ) - ord ( <STRING> ) ] += 1 <NEWLINE> <NL> <DEDENT> if len ( S ) < 26 : <NEWLINE> <INDENT> i = l . index ( 0 ) <NEWLINE> print ( S + chr ( i + ord ( <STRING> ) ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in range ( len ( S ) - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if S [ i - 1 ] < S [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> c = min ( S [ j ] for j in range ( i , len ( S ) ) if S [ j ] > S [ i - 1 ] ) <NEWLINE> print ( S [ : i - 1 ] + c ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = [ 0 ] * ( n ) <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <COMMENT> <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a - 1 ] . append ( b - 1 ) <NEWLINE> g [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a = a - 1 <NEWLINE> cnt [ a ] += b <NEWLINE> <NL> <DEDENT> def dfs ( now , prev = - 1 ) : <NEWLINE> <INDENT> for next in g [ now ] : <NEWLINE> <INDENT> if next == prev : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> cnt [ next ] += cnt [ now ] <NEWLINE> dfs ( next , now ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * cnt ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> <NL> def dfs ( n , seq ) : <NEWLINE> <INDENT> if seq [ n : ] in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> if seq [ n : n + 7 ] == <STRING> : <NEWLINE> <INDENT> if dfs ( n + 5 , seq ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif dfs ( n + 7 , seq ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> elif seq [ n : n + 5 ] == <STRING> : <NEWLINE> <INDENT> return dfs ( n + 5 , seq ) <NEWLINE> <NL> <DEDENT> elif seq [ n : n + 6 ] == <STRING> : <NEWLINE> <INDENT> return dfs ( n + 6 , seq ) <NEWLINE> <NL> <DEDENT> elif seq [ n : n + 5 ] == <STRING> : <NEWLINE> <INDENT> return dfs ( n + 5 , seq ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> if dfs ( 0 , S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ 0 ] + [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> done = { } <NEWLINE> ans = 0 <NEWLINE> now = A [ 1 ] <NEWLINE> while True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if now == 2 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> if done . get ( now ) == None : <NEWLINE> <INDENT> done [ now ] = True <NEWLINE> now = A [ now ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ int ( x ) for x in input ( ) ] <NEWLINE> <NL> dp_1 = [ False ] * 10 <NEWLINE> dp_2 = [ False ] * 100 <NEWLINE> dp_3 = [ False ] * 1000 <NEWLINE> <NL> for x in s : <NEWLINE> <INDENT> for i in range ( 100 ) : <NEWLINE> <INDENT> if dp_2 [ i ] : <NEWLINE> <INDENT> dp_3 [ i * 10 + x ] = True <NEWLINE> <DEDENT> <DEDENT> for i in range ( 10 ) : <NEWLINE> <INDENT> if dp_1 [ i ] : <NEWLINE> <INDENT> dp_2 [ i * 10 + x ] = True <NEWLINE> <DEDENT> <DEDENT> dp_1 [ x ] = True <NEWLINE> <NL> <DEDENT> print ( sum ( dp_3 ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> S = input ( ) <NEWLINE> ret = 0 <NEWLINE> <NL> <COMMENT> <NL> i = 0 <NEWLINE> while i < len ( S ) and S [ i ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> ret += i <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> n_up = 0 <NEWLINE> n_down = 0 <NEWLINE> while i < len ( S ) : <NEWLINE> <INDENT> n_up = 0 <NEWLINE> n_down = 0 <NEWLINE> while i < len ( S ) and S [ i ] == <STRING> : <NEWLINE> <INDENT> n_up += 1 <NEWLINE> i += 1 <NEWLINE> if i >= len ( S ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> while i < len ( S ) and S [ i ] == <STRING> : <NEWLINE> <INDENT> n_down += 1 <NEWLINE> i += 1 <NEWLINE> if i >= len ( S ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if n_up < n_down : <NEWLINE> <INDENT> n_up , n_down = n_down , n_up <NEWLINE> <NL> <DEDENT> ret += ( ( n_up + 1 ) * n_up ) // 2 <NEWLINE> ret += ( n_down * ( n_down - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( ret ) <NEWLINE>
n , a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> c -= 1 <NEWLINE> d -= 1 <NEWLINE> S = input ( ) <NEWLINE> <NL> if c < d : <NEWLINE> <INDENT> while b < d : <NEWLINE> <INDENT> if S [ b + 1 ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> elif b + 2 <= d and S [ b + 2 ] == <STRING> : <NEWLINE> <INDENT> b += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> while a < c : <NEWLINE> <INDENT> if S [ a + 1 ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif a + 2 <= c and S [ a + 2 ] == <STRING> : <NEWLINE> <INDENT> a += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> while a < c : <NEWLINE> <INDENT> if a + 1 == b and S [ a + 2 ] == <STRING> : <NEWLINE> <INDENT> a += 2 <NEWLINE> <DEDENT> elif a + 1 == b and a + 3 <= d and S [ a + 3 ] == <STRING> : <NEWLINE> <INDENT> b += 2 <NEWLINE> a += 1 <NEWLINE> <DEDENT> elif S [ a + 1 ] == <STRING> and a + 1 != b : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif a + 2 == b and a + 3 <= d and S [ a + 3 ] == <STRING> : <NEWLINE> <INDENT> a += 2 <NEWLINE> b += 1 <NEWLINE> <DEDENT> elif a + 2 == b and a + 4 <= d and S [ a + 4 ] == <STRING> : <NEWLINE> <INDENT> a += 2 <NEWLINE> b += 2 <NEWLINE> <DEDENT> elif S [ a + 2 ] == <STRING> and a + 2 != b : <NEWLINE> <INDENT> a += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> while b < d : <NEWLINE> <INDENT> if S [ b + 1 ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> elif b + 2 <= d and S [ b + 2 ] == <STRING> : <NEWLINE> <INDENT> b += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from heapq import heappop , heappush <NEWLINE> def main ( ) : <NEWLINE> <INDENT> def push ( i , j , k ) : <NEWLINE> <INDENT> nonlocal A , B , C , ADD <NEWLINE> if i >= x or j >= y or k >= z : return <NEWLINE> if ( i , j , k ) not in ADD : <NEWLINE> <INDENT> heappush ( H , ( A [ i ] + B [ j ] + C [ k ] , i , j , k ) ) <NEWLINE> ADD . add ( ( i , j , k ) ) <NEWLINE> <DEDENT> <DEDENT> x , y , z , k = map ( int , input ( ) . split ( ) ) <NEWLINE> INF = 10 ** 11 <NEWLINE> A = sorted ( list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) ) <NEWLINE> B = sorted ( list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) ) <NEWLINE> C = sorted ( list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) ) <NEWLINE> H = [ ] <NEWLINE> ADD = set ( ) <NEWLINE> push ( 0 , 0 , 0 ) <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> ans , i , j , k = heappop ( H ) <NEWLINE> push ( i + 1 , j , k ) <NEWLINE> push ( i , j + 1 , k ) <NEWLINE> push ( i , j , k + 1 ) <NEWLINE> print ( - ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = ( n ) * ( n - 1 ) // 2 <NEWLINE> print ( int ( ans ) ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , D , A = map ( int , input ( ) . split ( ) ) <NEWLINE> monster = { } <NEWLINE> X = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , h = map ( int , input ( ) . split ( ) ) <NEWLINE> monster [ x ] = h <NEWLINE> X . append ( x ) <NEWLINE> <NL> <DEDENT> X . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> q = deque ( [ ] ) <NEWLINE> <NL> acc_damage = 0 <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = X [ i ] <NEWLINE> h = monster [ x ] <NEWLINE> <NL> while q and q [ 0 ] [ 0 ] < x : <NEWLINE> <INDENT> p , damage = q . popleft ( ) <NEWLINE> acc_damage -= damage <NEWLINE> <NL> <DEDENT> if h - acc_damage <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> cnt = ( h - acc_damage + A - 1 ) // A <NEWLINE> ans += cnt <NEWLINE> acc_damage += cnt * A <NEWLINE> <NL> q . append ( ( x + 2 * D , cnt * A ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> def C ( T ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if h [ i ] > B * T : <NEWLINE> <INDENT> t += math . ceil ( ( h [ i ] - B * T ) / ( A - B ) ) <NEWLINE> <DEDENT> <DEDENT> if t <= T : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> False <NEWLINE> <DEDENT> <DEDENT> l , r = 0 , 10 ** 18 <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> if C ( mid ) : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> <NL> num = a [ 0 ] <NEWLINE> tmp = a [ 1 ] <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> if abs ( tmp - num / 2 ) >= abs ( a [ j ] - num / 2 ) : <NEWLINE> <INDENT> tmp = a [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans = [ num , tmp ] <NEWLINE> print ( * ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> B = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> C = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> import bisect as bs <NEWLINE> import numpy as np <NEWLINE> A . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> <COMMENT> <NL> B_a = np . array ( [ bs . bisect_left ( A , b ) for b in B ] ) <NEWLINE> B_c = np . array ( [ N - bs . bisect_right ( C , b ) for b in B ] ) <NEWLINE> ans = np . dot ( B_a , B_c ) <NEWLINE> print ( ans ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( reverse = True ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> <NL> <STRING> <NEWLINE> <NL> L . sort ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> target = L [ i ] + L [ j ] <NEWLINE> left = bisect_left ( L , target ) <COMMENT> <NEWLINE> ans += max ( 0 , left - j - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , t = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b <= t : <NEWLINE> <INDENT> ans . append ( a ) <NEWLINE> <DEDENT> <DEDENT> if len ( ans ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if v [ i ] > c [ i ] : <NEWLINE> <INDENT> ans += v [ i ] - c [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from copy import deepcopy <NEWLINE> import numpy as np <NEWLINE> readline = sys . stdin . readline <NEWLINE> read = sys . stdin . read <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( readline ( ) ) <NEWLINE> a = np . array ( [ list ( map ( int , l . split ( ) ) ) for l in read ( ) . splitlines ( ) ] ) <NEWLINE> cost = deepcopy ( a ) <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> arr = np . stack ( [ cost , [ cost [ k ] ] + np . transpose ( [ cost [ k ] ] ) ] ) <NEWLINE> cost = np . amin ( arr , axis = 0 ) <NEWLINE> <DEDENT> cost2 = deepcopy ( a ) <NEWLINE> f = np . sum ( cost < a ) <NEWLINE> if f : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> filt = np . sum ( [ ( [ cost [ k ] ] + np . transpose ( [ cost [ k ] ] ) ) == cost for k in range ( n ) ] , axis = 0 ) == 2 <NEWLINE> print ( np . sum ( a [ filt ] ) // 2 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> input_methods = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> using_method = 0 <NEWLINE> input_method = input_methods [ using_method ] <NEWLINE> <NL> tin = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> lin = lambda : list ( tin ( ) ) <NEWLINE> mod = 1000000007 <NEWLINE> <NL> <COMMENT> <NL> <NL> def cc ( al ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for ( c , s , f ) in al : <NEWLINE> <INDENT> if ret <= s : <NEWLINE> <INDENT> ret = s + c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> st = ( ( ret + f - 1 ) // f ) * f <NEWLINE> ret = st + c <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> al = [ lin ( ) for _ in range ( n - 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cc ( al [ i : ] ) <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> isTest = False <NEWLINE> <NL> def pa ( v ) : <NEWLINE> <INDENT> if isTest : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> def input_clipboard ( ) : <NEWLINE> <INDENT> import clipboard <NEWLINE> input_text = clipboard . get ( ) <NEWLINE> input_l = input_text . splitlines ( ) <NEWLINE> for l in input_l : <NEWLINE> <INDENT> yield l <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> if sys . platform == <STRING> : <NEWLINE> <INDENT> if input_method == input_methods [ 0 ] : <NEWLINE> <INDENT> ic = input_clipboard ( ) <NEWLINE> input = lambda : ic . __next__ ( ) <NEWLINE> <DEDENT> elif input_method == input_methods [ 1 ] : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> isTest = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ret = main ( ) <NEWLINE> if ret is not None : <NEWLINE> <INDENT> print ( ret ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) - 1 <NEWLINE> ans = ( 1 + n ) * ( n // 2 ) <NEWLINE> if n % 2 != 0 : <NEWLINE> <INDENT> ans += n // 2 + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> ans = [ [ <STRING> ] * w for _ in range ( h ) ] <NEWLINE> <NL> if h == 1 and w == 1 : <NEWLINE> <INDENT> if s [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif h == 1 : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ 0 ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans [ 0 ] [ j ] = s [ 0 ] [ max ( 0 , j - 1 ) : min ( w + 1 , j + 2 ) ] . count ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ 0 ] [ j ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif w == 1 : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if s [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ 0 ] = s [ i + 1 ] [ 0 ] . count ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] [ 0 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif i == h - 1 : <NEWLINE> <INDENT> if s [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ 0 ] = s [ i - 1 ] [ 0 ] . count ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] [ 0 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ 0 ] = s [ i - 1 ] [ 0 ] . count ( <STRING> ) + s [ i + 1 ] [ 0 ] . count ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] [ 0 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ j ] = s [ i ] [ max ( 0 , j - 1 ) : min ( w + 1 , j + 2 ) ] . count ( <STRING> ) + s [ i + 1 ] [ <NEWLINE> <INDENT> max ( 0 , j - 1 ) : min ( w + 1 , j + 2 ) ] . count ( <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] [ j ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif i == h - 1 : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ j ] = s [ i - 1 ] [ max ( 0 , j - 1 ) : min ( w + 1 , j + 2 ) ] . count ( <STRING> ) + s [ i ] [ max ( 0 , j - 1 ) : min ( w + 1 , <NEWLINE> <INDENT> j + 2 ) ] . count ( <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] [ j ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ j ] = s [ i - 1 ] [ max ( 0 , j - 1 ) : min ( w + 1 , j + 2 ) ] . count ( <STRING> ) + s [ i ] [ max ( 0 , j - 1 ) : min ( w + 1 , <NEWLINE> <INDENT> j + 2 ) ] . count ( <NEWLINE> <STRING> ) + s [ i + 1 ] [ max ( 0 , j - 1 ) : min ( w + 1 , j + 2 ) ] . count ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] [ j ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> [ print ( * k , sep = <STRING> ) for k in ans ] <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if d [ 0 ] != 0 or 0 in d [ 1 : ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> lis = [ 0 for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> lis [ d [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if lis [ i ] == 0 and lis [ i + 1 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> s = 1 <NEWLINE> <NL> i = 0 <NEWLINE> while i + 1 <= n - 1 and lis [ i + 1 ] != 0 : <NEWLINE> <INDENT> s = ( s * pow ( lis [ i ] , lis [ i + 1 ] , 998244353 ) ) % 998244353 <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> t = S [ K - 1 ] <NEWLINE> ans = <STRING> <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == t : <NEWLINE> <INDENT> ans += s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> s = sum ( a ) <NEWLINE> r = [ a [ 0 ] ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> r . append ( r [ i - 1 ] + a [ i ] ) <NEWLINE> <DEDENT> print ( min ( abs ( 2 * i - s ) for i in r ) ) <NEWLINE>
import numpy as np <NEWLINE> INT = lambda : int ( input ( ) ) <NEWLINE> INTM = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> STRM = lambda : map ( str , input ( ) . split ( ) ) <NEWLINE> STR = lambda : str ( input ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LISTS = lambda : list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> def do ( ) : <NEWLINE> <INDENT> n = INT ( ) <NEWLINE> a = np . array ( LIST ( ) ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( 70 ) : <NEWLINE> <INDENT> digit = np . sum ( ( a >> i ) & 1 ) <NEWLINE> ans += pow ( 2 , i , mod ) * ( ( ( n - digit ) * digit ) % mod ) % mod <NEWLINE> ans = ans % mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> do ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ 2 , 1 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> L = l [ i ] + l [ i + 1 ] <NEWLINE> l . append ( L ) <NEWLINE> <DEDENT> print ( l [ n ] ) <NEWLINE>
import numpy as np <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> s = [ ] <NEWLINE> p = np . array ( p ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum += ( 1 + p [ i ] ) / 2 <NEWLINE> s . append ( sum ) <NEWLINE> <COMMENT> <NL> <DEDENT> if k == n : <NEWLINE> <INDENT> print ( s [ - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> max = s [ k - 1 ] - s [ 0 ] <NEWLINE> for j in range ( 1 , n - k ) : <NEWLINE> <COMMENT> <NL> <INDENT> if max <= s [ j + k ] - s [ j ] : <NEWLINE> <INDENT> max = s [ j + k ] - s [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
def solve ( ) : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ a [ i ] for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> sum_e = 0 <NEWLINE> ans_e = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> sum_e += a [ i ] <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> if sum_e <= 0 : <NEWLINE> <INDENT> ans_e += abs ( sum_e ) + 1 <NEWLINE> sum_e += abs ( sum_e ) + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if sum_e >= 0 : <NEWLINE> <INDENT> ans_e += abs ( sum_e ) + 1 <NEWLINE> sum_e -= abs ( sum_e ) + 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> sum_o = 0 <NEWLINE> ans_o = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> sum_o += b [ i ] <NEWLINE> if i % 2 == 1 : <NEWLINE> <INDENT> if sum_o <= 0 : <NEWLINE> <INDENT> ans_o += abs ( sum_o ) + 1 <NEWLINE> sum_o += abs ( sum_o ) + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if sum_o >= 0 : <NEWLINE> <INDENT> ans_o += abs ( sum_o ) + 1 <NEWLINE> sum_o -= abs ( sum_o ) + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans_o <= ans_e : <NEWLINE> <INDENT> ans = ans_o <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans_e <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> A [ i ] += A [ i - 1 ] <NEWLINE> <DEDENT> A = Counter ( A ) <NEWLINE> k = 0 <NEWLINE> for j in A . values ( ) : <NEWLINE> <INDENT> k += j * ( j - 1 ) // 2 <NEWLINE> <DEDENT> k += A . get ( 0 , 0 ) <NEWLINE> print ( k ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> j = 2 <NEWLINE> <COMMENT> <NL> k = 1 <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> l = j + k <NEWLINE> j = k <NEWLINE> k = l <NEWLINE> <NL> <DEDENT> print ( l ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( a ) <NEWLINE> a . sort ( ) <NEWLINE> b = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> b |= b << i <NEWLINE> <NL> <DEDENT> b &= 2 ** ( s + 1 ) - 2 ** ( ( s - 1 ) // 2 ) <NEWLINE> while True : <NEWLINE> <INDENT> t = b & ( - b ) <NEWLINE> T = t . bit_length ( ) - 1 <NEWLINE> if ( s + 1 ) // 2 <= T <= s : <NEWLINE> <INDENT> print ( T ) <NEWLINE> break <NEWLINE> <DEDENT> b ^= t <NEWLINE> <DEDENT>
import heapq <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> AB = sorted ( AB , key = lambda x : x [ 0 ] ) <NEWLINE> <NL> x = 0 <NEWLINE> res = 0 <NEWLINE> <NL> hq = [ ] <NEWLINE> heapq . heapify ( hq ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> for j in range ( x , N ) : <NEWLINE> <INDENT> if AB [ j ] [ 0 ] > i + 1 : <NEWLINE> <INDENT> x = j <NEWLINE> break <NEWLINE> <DEDENT> heapq . heappush ( hq , AB [ j ] [ 1 ] * - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = N <NEWLINE> <NL> <DEDENT> if hq : <NEWLINE> <INDENT> res += heapq . heappop ( hq ) * - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> st = [ ] <NEWLINE> ch = [ ] <NEWLINE> def mht ( ax , ay , bx , by ) : <NEWLINE> <INDENT> return abs ( ax - bx ) + abs ( ay - by ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> st . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> ch . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in st : <NEWLINE> <INDENT> ax = i [ 0 ] <NEWLINE> ay = i [ 1 ] <NEWLINE> mn = 1000000000 <NEWLINE> for ( j , k ) in zip ( ch , range ( len ( ch ) ) ) : <NEWLINE> <INDENT> bx = j [ 0 ] <NEWLINE> by = j [ 1 ] <NEWLINE> mh = mht ( ax , ay , bx , by ) <NEWLINE> if mh < mn : <NEWLINE> <INDENT> mn = mh <NEWLINE> nm = k <NEWLINE> <DEDENT> <DEDENT> print ( nm + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> from collections import deque <NEWLINE> B = deque ( [ ] ) <NEWLINE> <NL> rev = False <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if not rev : <NEWLINE> <INDENT> B . append ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . appendleft ( A [ i ] ) <NEWLINE> <DEDENT> rev ^= True <NEWLINE> <NL> <DEDENT> if rev : <NEWLINE> <INDENT> B = list ( B ) [ : : - 1 ] <NEWLINE> <NL> <DEDENT> print ( * B ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> t = int ( 2 * n ** 0.5 ) <NEWLINE> ans = { i for i in range ( 1 , t + 1 ) } <NEWLINE> <NL> sum = t * ( t + 1 ) // 2 <NEWLINE> <NL> <NL> for i in range ( t , 0 , - 1 ) : <NEWLINE> <INDENT> if sum - i > n : <NEWLINE> <INDENT> ans . remove ( i ) <NEWLINE> sum -= i <NEWLINE> <DEDENT> elif sum - i == n : <NEWLINE> <INDENT> ans . remove ( i ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> m = s . count ( <STRING> ) <NEWLINE> p = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> p += ( n - m ) - ( i ) <NEWLINE> m -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - ( i + j ) <= K : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> ans = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += str ( b [ i ] ) + <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> import numpy as np <NEWLINE> ss = [ si + si for si in s ] <NEWLINE> ss = np . array ( ss + ss ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = ss [ i : i + n , : n ] <NEWLINE> if np . array_equal ( a , a . T ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans * n ) <NEWLINE>
from itertools import permutations <NEWLINE> import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> odd_nums = [ ] <NEWLINE> even_nums = [ ] <NEWLINE> for i , num in enumerate ( nums ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> even_nums . append ( num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> odd_nums . append ( num ) <NEWLINE> <NL> <DEDENT> <DEDENT> useable_nums = set ( nums ) <NEWLINE> even_length = len ( even_nums ) <NEWLINE> odd_length = len ( odd_nums ) <NEWLINE> even_counter = collections . Counter ( even_nums ) . most_common ( ) <NEWLINE> odd_counter = collections . Counter ( odd_nums ) . most_common ( ) <NEWLINE> even_counter . append ( ( 0 , 0 ) ) <NEWLINE> odd_counter . append ( ( 0 , 0 ) ) <NEWLINE> even_counter . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> odd_counter . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> min_ans = None <NEWLINE> if even_counter [ 0 ] [ 0 ] == odd_counter [ 0 ] [ 0 ] : <NEWLINE> <INDENT> min_ans = min ( ( odd_length - odd_counter [ 0 ] [ 1 ] ) + ( even_length - even_counter [ 1 ] [ 1 ] ) , <NEWLINE> <INDENT> ( odd_length - odd_counter [ 1 ] [ 1 ] ) + ( even_length - even_counter [ 0 ] [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <NL> <INDENT> min_ans = odd_length - odd_counter [ 0 ] [ 1 ] + even_length - even_counter [ 0 ] [ 1 ] <NEWLINE> <DEDENT> print ( min_ans ) <NEWLINE>
from math import atan , degrees <NEWLINE> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == a * b * b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x / a ** 2 <NEWLINE> if x >= b / 2 : <NEWLINE> <INDENT> print ( 90 - degrees ( atan ( a / ( 2 * b - 2 * x ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 90 - degrees ( atan ( 2 * a * x / b ** 2 ) ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = [ ( 1 , 2 ) , ( 2 , 5 ) , ( 3 , 5 ) , ( 4 , 4 ) , ( 5 , 5 ) , ( 6 , 6 ) , ( 7 , 3 ) , ( 8 , 7 ) , ( 9 , 6 ) ] <NEWLINE> B = [ ] <NEWLINE> for num , cost in L : <NEWLINE> <INDENT> if num in A : <NEWLINE> <INDENT> B . append ( [ num , cost ] ) <NEWLINE> <DEDENT> <DEDENT> B . sort ( key = lambda x : - x [ 0 ] ) <NEWLINE> dp = [ - f_inf ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for _ , cost in B : <NEWLINE> <INDENT> if i - cost == 0 : <NEWLINE> <INDENT> dp [ i ] = max ( dp [ i ] , dp [ 0 ] + 1 ) <NEWLINE> <DEDENT> elif i - cost > 0 and dp [ i - cost ] != 0 : <NEWLINE> <INDENT> dp [ i ] = max ( dp [ i ] , dp [ i - cost ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> j = 0 <NEWLINE> k = n <NEWLINE> res = <STRING> <NEWLINE> while k > 0 and j < m : <NEWLINE> <INDENT> num , cost = B [ j ] <NEWLINE> if k - cost >= 0 and dp [ k ] - dp [ k - cost ] == 1 : <NEWLINE> <INDENT> res += str ( num ) <NEWLINE> k -= cost <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> d = defaultdict ( list ) <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d [ a ] . append ( b ) <NEWLINE> d [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> c = defaultdict ( int ) <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> c [ p ] += x <NEWLINE> <NL> <DEDENT> ans = [ 0 for i in range ( N ) ] <NEWLINE> que = [ ( 1 , 0 , - 1 ) ] <NEWLINE> while len ( que ) > 0 : <NEWLINE> <INDENT> tmp = [ ] <NEWLINE> for v , x , par in que : <NEWLINE> <INDENT> x += c [ v ] <NEWLINE> ans [ v - 1 ] = str ( x ) <NEWLINE> for w in d [ v ] : <NEWLINE> <INDENT> if w != par : <NEWLINE> <INDENT> tmp . append ( ( w , x , v ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> que = tmp <NEWLINE> <NL> <DEDENT> print ( * ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> s = input ( ) . rstrip ( ) <NEWLINE> n = len ( s ) <NEWLINE> t = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> if s [ : i ] + s [ j : ] == t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = 0 <NEWLINE> lis = [ 0 ] * 1000 <NEWLINE> one = [ 0 ] * 10 <NEWLINE> two = [ 0 ] * 100 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> temp1 = int ( s [ i ] ) <NEWLINE> if one [ temp1 ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> one [ temp1 ] = 1 <NEWLINE> <NL> <DEDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> temp2 = int ( <STRING> . join ( [ s [ i ] , s [ j ] ] ) ) <NEWLINE> if two [ temp2 ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> two [ temp2 ] = 1 <NEWLINE> <NL> <DEDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> pin = int ( <STRING> . join ( [ s [ i ] , s [ j ] , s [ k ] ] ) ) <NEWLINE> if lis [ pin ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> lis [ pin ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools as it <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def I2 ( ) : return map ( int , sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ) <NEWLINE> def S ( ) : return str ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def L ( ) : return list ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def Intl ( ) : return [ int ( k ) for k in sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ] <NEWLINE> def Lx ( k ) : return list ( map ( lambda x : int ( x ) * - k , sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ) ) <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n , k = I2 ( ) <NEWLINE> h = [ I ( ) for _ in range ( n ) ] <NEWLINE> h . sort ( ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> a , b = h [ i ] , h [ i + k - 1 ] <NEWLINE> <COMMENT> <NL> ans = min ( ans , b - a ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k * 2 + a - 1 <= b : <NEWLINE> <INDENT> for i in range ( a , a + k ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
S = str ( input ( ) ) <NEWLINE> V = [ S . count ( <STRING> ) , S . count ( <STRING> ) , S . count ( <STRING> ) ] <NEWLINE> V . sort ( ) <NEWLINE> ans = <STRING> <NEWLINE> if V [ 2 ] - V [ 0 ] > 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> k = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( min ( [ S - i + 1 , K + 1 ] ) ) : <NEWLINE> <INDENT> if 0 <= S - i - j <= K : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( k ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ False ] * ( n + 1 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> a [ A ] = True <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> if not a [ 1 ] : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> if n > 1 : <NEWLINE> <INDENT> if not a [ 2 ] : <NEWLINE> <INDENT> dp [ 2 ] = dp [ 1 ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if not a [ i - 2 ] : <NEWLINE> <INDENT> dp [ i ] += dp [ i - 2 ] <NEWLINE> dp [ i ] %= mod <NEWLINE> <DEDENT> if not a [ i - 1 ] : <NEWLINE> <INDENT> dp [ i ] += dp [ i - 1 ] <NEWLINE> dp [ i ] %= mod <NEWLINE> <DEDENT> if a [ i ] : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ n ] % mod ) <NEWLINE>
import numpy as np <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> N = make_divisors ( np . gcd ( A , B ) ) <NEWLINE> N . sort ( reverse = True ) <NEWLINE> print ( N [ K - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> a = [ - 1 for _ in range ( 26 ) ] <NEWLINE> b = [ - 1 for _ in range ( 26 ) ] <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> num0 , num1 = a [ ord ( s [ i ] ) - 97 ] , b [ ord ( t [ i ] ) - 97 ] <NEWLINE> if num0 >= 0 : <NEWLINE> <INDENT> if chr ( num0 + 97 ) != t [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a [ ord ( s [ i ] ) - 97 ] = ord ( t [ i ] ) - 97 <NEWLINE> <NL> <DEDENT> if num1 >= 0 : <NEWLINE> <INDENT> if chr ( num1 + 97 ) != s [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> b [ ord ( t [ i ] ) - 97 ] = ord ( s [ i ] ) - 97 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> ns = len ( S ) <NEWLINE> nt = len ( T ) <NEWLINE> ans = [ ] <NEWLINE> i = 0 <NEWLINE> while i + nt <= ns : <NEWLINE> <INDENT> j = 0 <NEWLINE> while j < nt : <NEWLINE> <INDENT> if S [ i + j ] == <STRING> or S [ i + j ] == T [ j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if j == nt : <NEWLINE> <INDENT> A = S [ : i ] + T + S [ i + nt : ] <NEWLINE> A = A . replace ( <STRING> , <STRING> ) <NEWLINE> ans . append ( A ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> if ans : <NEWLINE> <INDENT> print ( sorted ( ans ) [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
MOD = 10 ** 9 + 7 <NEWLINE> table_len = 2 * 10 ** 6 + 10 <NEWLINE> <NL> fac = [ 1 , 1 ] <NEWLINE> for i in range ( 2 , table_len ) : <NEWLINE> <INDENT> fac . append ( fac [ - 1 ] * i % MOD ) <NEWLINE> <NL> <DEDENT> finv = [ 0 ] * table_len <NEWLINE> finv [ - 1 ] = pow ( fac [ - 1 ] , MOD - 2 , MOD ) <NEWLINE> for i in range ( table_len - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> finv [ i - 1 ] = finv [ i ] * i % MOD <NEWLINE> <NL> <DEDENT> def comb ( a , b ) : <NEWLINE> <INDENT> return fac [ a + b ] * finv [ a ] * finv [ b ] % MOD <NEWLINE> <NL> <NL> <DEDENT> r1 , c1 , r2 , c2 = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = ( comb ( r1 , c1 ) + comb ( r2 + 1 , c2 + 1 ) - comb ( r1 , c2 + 1 ) - comb ( r2 + 1 , c1 ) ) % MOD <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> so_list = [ 0 for i in range ( 10 ** 6 ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def fac ( n ) : <NEWLINE> <INDENT> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> if so_list [ i ] < cnt : <NEWLINE> <INDENT> so_list [ i ] = cnt <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <COMMENT> <NL> <INDENT> if so_list [ temp ] == 0 : <NEWLINE> <INDENT> so_list [ temp ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a1 = a [ i ] <NEWLINE> fac ( a1 ) <NEWLINE> <DEDENT> l = 1 <NEWLINE> for i in range ( len ( so_list ) ) : <NEWLINE> <INDENT> if so_list [ i ] != 0 : <NEWLINE> <INDENT> l *= pow ( i , so_list [ i ] , mod ) <NEWLINE> l %= mod <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for i in a : <NEWLINE> <INDENT> t = pow ( i , mod - 2 , mod ) <NEWLINE> ans += ( l * t ) % mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
import sys , math , collections , itertools , bisect <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Ds = set ( [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] ) - set ( D ) <NEWLINE> if 0 in Ds : <NEWLINE> <INDENT> can = list ( itertools . product ( Ds , repeat = 5 ) ) <NEWLINE> candi = [ ] <NEWLINE> for c in can : <NEWLINE> <INDENT> candi . append ( 10 ** 4 * c [ 0 ] + 10 ** 3 * c [ 1 ] + 10 ** 2 * c [ 2 ] + 10 ** 1 * c [ 3 ] + c [ 4 ] ) <NEWLINE> <DEDENT> candi = sorted ( candi ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Ds = Ds | set ( [ 0 ] ) <NEWLINE> can = list ( itertools . product ( Ds , repeat = 5 ) ) <NEWLINE> candi = [ ] <NEWLINE> for c in can : <NEWLINE> <INDENT> cs = ( 10 ** 4 * c [ 0 ] + 10 ** 3 * c [ 1 ] + 10 ** 2 * c [ 2 ] + 10 ** 1 * c [ 3 ] + c [ 4 ] ) <NEWLINE> s = list ( str ( cs ) ) <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> candi . append ( cs ) <NEWLINE> <DEDENT> <DEDENT> candi = sorted ( candi ) <NEWLINE> <NL> <DEDENT> print ( candi [ bisect . bisect_left ( candi , N ) ] ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> class WeightedUnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = [ i for i in range ( n ) ] <NEWLINE> self . rank = [ 0 ] * n <NEWLINE> <COMMENT> <NL> self . weight = [ 0 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = self . find ( self . parents [ x ] ) <NEWLINE> <COMMENT> <NL> self . weight [ x ] += self . weight [ self . parents [ x ] ] <NEWLINE> self . parents [ x ] = y <NEWLINE> return y <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y , w ) : <NEWLINE> <INDENT> rx = self . find ( x ) <NEWLINE> ry = self . find ( y ) <NEWLINE> <COMMENT> <NL> if self . rank [ rx ] < self . rank [ ry ] : <NEWLINE> <INDENT> self . parents [ rx ] = ry <NEWLINE> self . weight [ rx ] = w - self . weight [ x ] + self . weight [ y ] <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ ry ] = rx <NEWLINE> self . weight [ ry ] = - w - self . weight [ y ] + self . weight [ x ] <NEWLINE> <COMMENT> <NL> if self . rank [ rx ] == self . rank [ ry ] : <NEWLINE> <INDENT> self . rank [ rx ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def diff ( self , x , y ) : <NEWLINE> <INDENT> return self . weight [ x ] - self . weight [ y ] <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> uf = WeightedUnionFind ( N ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> l , r , d = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> l -= 1 <NEWLINE> r -= 1 <NEWLINE> if uf . same ( l , r ) : <NEWLINE> <INDENT> if uf . diff ( l , r ) != d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> uf . union ( l , r , d ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = eval ( input ( ) ) <NEWLINE> print ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> a = max ( A ) <NEWLINE> prime_num = [ 2 ] <NEWLINE> sgn = [ 0 for _ in range ( max ( int ( a ** 0.5 ) + 1 , 4 ) ) ] <NEWLINE> sgn [ 2 ] = 1 <NEWLINE> for k in range ( 3 , len ( sgn ) , 2 ) : <NEWLINE> <INDENT> if sgn [ k ] == 0 : <NEWLINE> <INDENT> prime_num . append ( k ) <NEWLINE> for j in range ( k , a + 1 , k ** 2 ) : <NEWLINE> <INDENT> sgn [ k ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> baisu = [ ] <NEWLINE> count = [ 0 for _ in range ( a + 1 ) ] <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> b = 0 + A [ k ] <NEWLINE> for p in prime_num : <NEWLINE> <INDENT> if p ** 2 <= b : <NEWLINE> <INDENT> if b % p == 0 : <NEWLINE> <INDENT> if count [ p ] == 0 : <NEWLINE> <INDENT> baisu . append ( p ) <NEWLINE> <DEDENT> c = 0 <NEWLINE> while b % p == 0 : <NEWLINE> <INDENT> b //= p <NEWLINE> c += 1 <NEWLINE> <DEDENT> if c > count [ p ] : <NEWLINE> <INDENT> count [ p ] = c <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if b != 1 : <NEWLINE> <INDENT> if count [ b ] == 0 : <NEWLINE> <INDENT> count [ b ] = 1 <NEWLINE> baisu . append ( b ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> product = 1 <NEWLINE> for item in baisu : <NEWLINE> <INDENT> product *= pow ( item , count [ item ] , mod ) <NEWLINE> product %= mod <NEWLINE> <NL> <DEDENT> b = mod - 2 <NEWLINE> blis = [ ] <NEWLINE> c = 0 <NEWLINE> while b > 0 : <NEWLINE> <INDENT> if b & 1 == 1 : <NEWLINE> <INDENT> blis . append ( c ) <NEWLINE> <DEDENT> c += 1 <NEWLINE> b >>= 1 <NEWLINE> <NL> <DEDENT> def modinv ( a ) : <NEWLINE> <INDENT> if a == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = 1 <NEWLINE> li = [ ] <NEWLINE> for _ in range ( c ) : <NEWLINE> <INDENT> li . append ( a % mod ) <NEWLINE> a = a * a % mod <NEWLINE> <DEDENT> for item in blis : <NEWLINE> <INDENT> res = res * li [ item ] % mod <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> ans += product * modinv ( A [ k ] ) <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A , B = [ ] , [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <DEDENT> A . reverse ( ) <NEWLINE> B . reverse ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for a , b in zip ( A , B ) : <NEWLINE> <INDENT> a += cnt <NEWLINE> cnt += math . ceil ( a / b ) * b - a <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
A , B , K = input ( ) . split ( <STRING> ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( B ) <NEWLINE> K = int ( K ) <NEWLINE> N = [ ] <NEWLINE> if B - A > K : <NEWLINE> <INDENT> for i in range ( A , A + K ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> N . append ( i ) <NEWLINE> <DEDENT> for i in range ( B - K + 1 , B + 1 ) : <NEWLINE> <INDENT> if not i in N : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i < A + K : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> elif i > B - K : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <COMMENT> <NL> def int1 ( x ) : return int ( x ) - 1 <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MI1 ( ) : return map ( int1 , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LI1 ( ) : return list ( map ( int1 , input ( ) . split ( ) ) ) <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def MS ( ) : return input ( ) . split ( ) <NEWLINE> def LS ( ) : return list ( input ( ) ) <NEWLINE> def LLS ( rows_number ) : return [ LS ( ) for _ in range ( rows_number ) ] <NEWLINE> def printlist ( lst , k = <STRING> ) : print ( k . join ( list ( map ( str , lst ) ) ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from bisect import bisect_left , bisect_right <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> N = II ( ) <NEWLINE> A = LI ( ) <NEWLINE> A = sorted ( A ) <NEWLINE> <NL> a = A [ - 1 ] <NEWLINE> mid = a / 2 <NEWLINE> diff = INF <NEWLINE> b = - 1 <NEWLINE> for j in A [ : - 1 ] : <NEWLINE> <INDENT> d = abs ( j - mid ) <NEWLINE> if d < diff : <NEWLINE> <INDENT> b = j <NEWLINE> diff = d <NEWLINE> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = list ( set ( ( A ) ) ) <NEWLINE> check = len ( a ) <NEWLINE> dff = check - K <NEWLINE> if dff <= 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> ans_list = [ 0 ] * check <NEWLINE> A . sort ( ) <NEWLINE> index = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <NL> <INDENT> if i >= 1 and A [ i ] != A [ i - 1 ] : <NEWLINE> <INDENT> index += 1 <NEWLINE> <DEDENT> ans_list [ index ] += 1 <NEWLINE> <DEDENT> ans_list . sort ( ) <NEWLINE> result = sum ( ans_list [ : dff ] ) <NEWLINE> print ( result ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> while b : a , b = b , a % b <NEWLINE> return a <NEWLINE> <DEDENT> def lcm ( c , d ) : return c * d // gcd ( c , d ) <NEWLINE> def div ( x ) : <NEWLINE> <INDENT> num = x <NEWLINE> num -= x // C <NEWLINE> num -= x // D <NEWLINE> num += x // lcm ( C , D ) <NEWLINE> return num <NEWLINE> <DEDENT> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( div ( B ) - div ( A - 1 ) ) <NEWLINE>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> from functools import reduce <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MAP1 ( ) : return map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n = INT ( ) <NEWLINE> Q = [ tuple ( MAP1 ( ) ) for _ in range ( n - 1 ) ] <NEWLINE> <NL> deg = [ 0 ] * n <NEWLINE> adj = [ [ ] for _ in range ( n ) ] <NEWLINE> color = dict ( ) <NEWLINE> <NL> for a , b in Q : <NEWLINE> <INDENT> deg [ a ] += 1 <NEWLINE> deg [ b ] += 1 <NEWLINE> adj [ a ] . append ( b ) <NEWLINE> adj [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> def dfs ( s , p ) : <NEWLINE> <INDENT> nouse = - 1 <NEWLINE> if p > - 1 : <NEWLINE> <INDENT> nouse = color [ ( min ( s , p ) , max ( s , p ) ) ] <NEWLINE> <DEDENT> c = 1 <NEWLINE> for t in adj [ s ] : <NEWLINE> <INDENT> if t == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if c == nouse : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> color [ ( min ( s , t ) , max ( s , t ) ) ] = c <NEWLINE> dfs ( t , s ) <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 1 , - 1 ) <NEWLINE> <NL> print ( max ( deg ) ) <NEWLINE> for a , b in Q : <NEWLINE> <INDENT> print ( color [ ( a , b ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 2000000 ) <NEWLINE> <NL> s = input ( ) <NEWLINE> <NL> def solve ( i ) : <NEWLINE> <INDENT> if i == 2 : <NEWLINE> <INDENT> if s [ i - 1 ] == s [ i ] : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return solve ( i - 1 ) + 1 <NEWLINE> <DEDENT> <DEDENT> if i == 1 : <NEWLINE> <INDENT> if s [ i - 1 ] == s [ i ] : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> <DEDENT> if i == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> if s [ i ] != s [ i - 1 ] : <NEWLINE> <INDENT> return solve ( i - 1 ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return solve ( i - 3 ) + 2 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( solve ( len ( s ) - 1 ) ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( - 1 if x % y == 0 else x ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans_l = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> tmp = s [ i ] + s [ i + 1 ] <NEWLINE> if tmp == <STRING> : <NEWLINE> <INDENT> ans_l [ i + 1 ] = ans_l [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_l [ i + 1 ] = ans_l [ i ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ans_l [ r - 1 ] - ans_l [ l - 1 ] ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> import numpy as np <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ list ( map ( str , input ( ) . rstrip ( ) ) ) for _ in range ( h ) ] <NEWLINE> <NL> arr = sum ( arr , [ ] ) <NEWLINE> <NL> arr = Counter ( arr ) <NEWLINE> arr = np . array ( list ( arr . values ( ) ) ) <NEWLINE> <NL> <NL> def solve ( arr ) : <NEWLINE> <COMMENT> <NL> <INDENT> if h % 2 == 0 and w % 2 == 0 : <NEWLINE> <INDENT> return np . all ( arr % 4 == 0 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> elif h % 2 == 1 and w % 2 == 1 : <NEWLINE> <INDENT> even = ( h + w ) // 2 - 1 <NEWLINE> if ( arr % 2 == 1 ) . sum ( ) != 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> odd = arr [ np . where ( arr % 2 == 1 ) ] . sum ( ) <NEWLINE> if odd % 4 == 3 : <NEWLINE> <INDENT> even -= 1 <NEWLINE> <DEDENT> arr = arr [ np . where ( arr != odd ) ] <NEWLINE> ans = ( arr % 4 == 2 ) . sum ( ) <= even <NEWLINE> ans &= np . all ( arr [ np . where ( arr % 4 != 2 ) ] % 4 == 0 ) <NEWLINE> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> even = h // 2 if h % 2 == 0 else w // 2 <NEWLINE> ans = ( arr % 4 == 2 ) . sum ( ) <= even <NEWLINE> ans &= np . all ( arr [ np . where ( arr % 4 != 2 ) ] % 4 == 0 ) <NEWLINE> return ans <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> if solve ( arr ) else <STRING> ) <NEWLINE>
s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> res = 0 <NEWLINE> if s * 2 <= c : <NEWLINE> <INDENT> res = s <NEWLINE> c -= s * 2 <NEWLINE> s = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += c // 2 <NEWLINE> c = 0 <NEWLINE> <NL> <DEDENT> if c : <NEWLINE> <INDENT> res += c // 4 <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( str , input ( ) ) ) <NEWLINE> li = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> answer = [ ] <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> for j in range ( len ( li ) ) : <NEWLINE> <INDENT> if S [ i ] == li [ j ] and j < len ( li ) - N : <NEWLINE> <INDENT> answer . append ( li [ j + N ] ) <NEWLINE> <DEDENT> elif S [ i ] == li [ j ] and j >= len ( li ) - N : <NEWLINE> <INDENT> answer . append ( li [ j + N - len ( li ) ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( answer ) ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . buffer . readline <NEWLINE> in_n = lambda : int ( input ( ) ) <NEWLINE> in_nn = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> in_s = lambda : input ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> in_map = lambda : [ s == ord ( <STRING> ) for s in input ( ) if s != ord ( <STRING> ) ] <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = 8 * 10 ** 18 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> N , M = in_nn ( ) <NEWLINE> X = list ( in_nn ( ) ) <NEWLINE> Y = list ( in_nn ( ) ) <NEWLINE> <NL> x_tsum = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x_tsum [ i + 1 ] += x_tsum [ i ] + X [ i ] <NEWLINE> x_tsum [ i + 1 ] %= MOD <NEWLINE> <NL> <DEDENT> x_sum = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> x_sum += X [ i ] * i - x_tsum [ i ] <NEWLINE> x_sum %= MOD <NEWLINE> <NL> <DEDENT> y_tsum = [ 0 ] * ( M + 1 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> y_tsum [ i + 1 ] += y_tsum [ i ] + Y [ i ] <NEWLINE> y_tsum [ i + 1 ] %= MOD <NEWLINE> <NL> <DEDENT> y_sum = 0 <NEWLINE> for i in range ( 1 , M ) : <NEWLINE> <INDENT> y_sum += Y [ i ] * i - y_tsum [ i ] <NEWLINE> y_sum %= MOD <NEWLINE> <NL> <DEDENT> print ( x_sum * y_sum % MOD ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> m = n <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <INDENT> while n > 0 : <NEWLINE> <NL> <INDENT> a = a + n % 10 <NEWLINE> n = n // 10 <NEWLINE> <DEDENT> if m % a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> B . sort ( key = lambda B : B [ 1 ] , reverse = True ) <NEWLINE> <NL> i = j = 0 <NEWLINE> ans = sum ( A ) <NEWLINE> while j < n : <NEWLINE> <INDENT> newv = B [ i ] [ 1 ] <NEWLINE> newc = min ( B [ i ] [ 0 ] , n - j ) <NEWLINE> if newv > A [ j ] : <NEWLINE> <INDENT> for k in range ( newc ) : <NEWLINE> <INDENT> if newv <= A [ j + k ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> ans += newv * ( k ) - sum ( A [ j : j + k ] ) <NEWLINE> i += 1 <NEWLINE> j += k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i >= m : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> l = <STRING> <NEWLINE> d = { } <NEWLINE> <NL> for i in range ( 26 ) : <NEWLINE> <INDENT> cnt = s . count ( l [ i ] ) <NEWLINE> pre = 0 <NEWLINE> if cnt > 0 : <NEWLINE> <INDENT> for j in range ( cnt ) : <NEWLINE> <INDENT> pos = s . find ( l [ i ] , pre ) <NEWLINE> pre = pos + 1 <NEWLINE> for m in range ( min ( len ( s ) - pos , k ) ) : <NEWLINE> <INDENT> if s [ pos : pos + m + 1 ] not in d : <NEWLINE> <INDENT> d [ s [ pos : pos + m + 1 ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if len ( d ) >= k : <NEWLINE> <INDENT> dl = [ ] <NEWLINE> for i in d . keys ( ) : <NEWLINE> <INDENT> dl . append ( i ) <NEWLINE> <DEDENT> dl . sort ( ) <NEWLINE> print ( dl [ k - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n = str ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> s += int ( n [ i ] ) <NEWLINE> <NL> <DEDENT> n = int ( n ) <NEWLINE> if n % s == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = [ input ( ) for _ in range ( 3 ) ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> S [ i ] = list ( S [ i ] ) <NEWLINE> <DEDENT> p = 0 <COMMENT> <NEWLINE> while True : <NEWLINE> <INDENT> if not S [ 0 ] and p == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if not S [ 1 ] and p == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if not S [ 2 ] and p == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> p_t = S [ p ] . pop ( 0 ) <NEWLINE> if p_t == <STRING> : <NEWLINE> <INDENT> p = 0 <NEWLINE> <DEDENT> elif p_t == <STRING> : <NEWLINE> <INDENT> p = 1 <NEWLINE> <DEDENT> elif p_t == <STRING> : <NEWLINE> <INDENT> p = 2 <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> H = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> reached = [ False ] * N <NEWLINE> <NL> max_count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if reached [ i ] == True : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( 0 , N - i - 1 ) : <NEWLINE> <INDENT> if H [ i + j + 1 ] <= H [ i + j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> reached [ i + j + 1 ] = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_count = max ( max_count , count ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> max_count = max ( max_count , count ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max_count ) <NEWLINE>
import sys , math <NEWLINE> from functools import lru_cache <NEWLINE> from collections import defaultdict <NEWLINE> from decimal import Decimal <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <DEDENT> def mi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def ii ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def i2 ( n ) : <NEWLINE> <INDENT> tmp = [ list ( mi ( ) ) for i in range ( n ) ] <NEWLINE> return [ list ( i ) for i in zip ( * tmp ) ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = mi ( ) <NEWLINE> S , T = [ list ( input ( ) ) , list ( input ( ) ) ] <NEWLINE> <NL> g = math . gcd ( N , M ) <NEWLINE> l = N * M // g <NEWLINE> <NL> for i in range ( g ) : <NEWLINE> <INDENT> if not ( S [ N // g * i ] == T [ M // g * i ] ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( l ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> nums = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> nums [ i ] += 1 <NEWLINE> <NL> <DEDENT> ans0 = nums [ 0 ] + nums [ 1 ] + nums [ 2 ] <NEWLINE> ans = ans0 <NEWLINE> for i in range ( 2 , 10 ** 5 - 1 ) : <NEWLINE> <INDENT> ans1 = ans0 - nums [ i - 2 ] + nums [ i + 1 ] <NEWLINE> ans = max ( ans , ans1 ) <NEWLINE> ans0 = ans1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> s = list ( input ( ) ) <NEWLINE> s = Counter ( s ) <NEWLINE> print ( min ( s [ <STRING> ] , s [ <STRING> ] ) * 2 ) <NEWLINE>
import copy <NEWLINE> import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = v [ 0 : : 2 ] <NEWLINE> b = v [ 1 : : 2 ] <NEWLINE> <NL> cnta = np . zeros ( 10 ** 5 + 1 , dtype = int ) <NEWLINE> cntb = np . zeros ( 10 ** 5 + 1 , dtype = int ) <NEWLINE> for i in range ( n // 2 ) : <NEWLINE> <INDENT> ca , cb = a [ i ] , b [ i ] <NEWLINE> cnta [ ca ] += 1 <NEWLINE> cntb [ cb ] += 1 <NEWLINE> <NL> <DEDENT> la = np . zeros ( ( 2 , 2 ) , dtype = int ) <NEWLINE> lb = np . zeros ( ( 2 , 2 ) , dtype = int ) <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> ia = cnta . argmax ( ) <NEWLINE> ib = cntb . argmax ( ) <NEWLINE> la [ i ] [ 0 ] , la [ i ] [ 1 ] = ia , cnta [ ia ] <NEWLINE> lb [ i ] [ 0 ] , lb [ i ] [ 1 ] = ib , cntb [ ib ] <NEWLINE> cnta [ ia ] = 0 <NEWLINE> cntb [ ib ] = 0 <NEWLINE> <NL> <DEDENT> if la [ 0 ] [ 0 ] != lb [ 0 ] [ 0 ] : <NEWLINE> <INDENT> ans = n // 2 - la [ 0 ] [ 1 ] + n // 2 - lb [ 0 ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( n // 2 - la [ 0 ] [ 1 ] + n // 2 - lb [ 1 ] [ 1 ] , n // 2 - la [ 1 ] [ 1 ] + n // 2 - lb [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) <NEWLINE> ws = [ ] <NEWLINE> for i in range ( f // 100 // a + 1 ) : <NEWLINE> <INDENT> for j in range ( f // 100 // b + 1 ) : <NEWLINE> <INDENT> w = 100 * ( a * i + b * j ) <NEWLINE> if 0 < w <= f : <NEWLINE> <INDENT> ws . append ( w ) <NEWLINE> <DEDENT> if w >= f : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ss = [ ] <NEWLINE> for i in range ( f * e // ( 100 + e ) // c + 1 ) : <NEWLINE> <INDENT> for j in range ( f * e // ( 100 + e ) // d + 1 ) : <NEWLINE> <INDENT> s = c * i + d * j <NEWLINE> if 0 <= s <= f * e // ( 100 + e ) : <NEWLINE> <INDENT> ss . append ( s ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> n = [ ] <NEWLINE> for w in ws : <NEWLINE> <INDENT> for s in ss : <NEWLINE> <INDENT> if w + s > f : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s > e * w // 100 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> n . append ( ( s / ( w + s ) , w + s , s ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> nmax = max ( n , key = lambda x : x [ 0 ] ) <NEWLINE> print ( nmax [ 1 ] , nmax [ 2 ] ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> s = [ str ( sorted ( input ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> cnt = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if s [ i ] in cnt : <NEWLINE> <INDENT> ans += cnt [ s [ i ] ] <NEWLINE> cnt [ s [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ s [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> counter = [ 0 ] * N <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a - 1 ] . append ( b - 1 ) <NEWLINE> G [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> counter [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> seen = [ False ] * N <NEWLINE> <NL> def dfs ( v , seen , G , counter ) : <NEWLINE> <INDENT> seen [ v ] = True <NEWLINE> for u in G [ v ] : <NEWLINE> <INDENT> if not seen [ u ] : <NEWLINE> <INDENT> counter [ u ] += counter [ v ] <NEWLINE> dfs ( u , seen , G , counter ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , seen , G , counter ) <NEWLINE> <NL> for c in counter : <NEWLINE> <INDENT> print ( c , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> k = S - j - i <NEWLINE> if k >= 0 and k <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> A . append ( a ) <NEWLINE> <NL> <DEDENT> B = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> b = input ( ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> idx = [ 0 , 0 ] <NEWLINE> while True : <NEWLINE> <INDENT> if idx [ 0 ] == N - 1 and idx [ 1 ] == N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if A [ idx [ 0 ] ] [ idx [ 1 ] ] == B [ 0 ] [ 0 ] : <NEWLINE> <INDENT> check = False <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> if 0 <= idx [ 0 ] + i < N and 0 <= idx [ 1 ] + j < N : <NEWLINE> <INDENT> if A [ idx [ 0 ] + i ] [ idx [ 1 ] + j ] != B [ i ] [ j ] : <NEWLINE> <INDENT> check = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> check = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if check : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if not check : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if idx [ 1 ] < N - 1 : <NEWLINE> <INDENT> idx [ 1 ] += 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx [ 0 ] += 1 <NEWLINE> idx [ 1 ] = 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT> if A [ - 1 ] [ - 1 ] == B [ 0 ] [ 0 ] and M == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> p = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> p = ( p * i ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( p ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> if ( n - 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( ( n * ( n - 1 ) // 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n * ( n - 2 ) // 2 + n // 2 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = { } <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> j = S [ i ] - 1 <NEWLINE> d [ i ] = j <NEWLINE> if j in d : <NEWLINE> <INDENT> if d [ j ] == i : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> out = 0 <NEWLINE> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> c . sort ( ) <NEWLINE> for i in b : <NEWLINE> <INDENT> na = bisect . bisect_left ( a , i ) <NEWLINE> nc = bisect . bisect ( c , i ) <NEWLINE> out += na * ( len ( c ) - nc ) <NEWLINE> <DEDENT> print ( out ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> edge = [ [ ] for _ in range ( n ) ] <NEWLINE> dist = [ - 1 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ x - 1 ] . append ( [ y - 1 , z ] ) <NEWLINE> edge [ y - 1 ] . append ( [ x - 1 , z ] ) <NEWLINE> <DEDENT> def dfs ( node , d ) : <NEWLINE> <INDENT> dist [ node ] = d <NEWLINE> for i in edge [ node ] : <NEWLINE> <INDENT> if dist [ i [ 0 ] ] == - 1 : <NEWLINE> <INDENT> dfs ( i [ 0 ] , d + i [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , 0 ) <NEWLINE> print ( * [ i % 2 for i in dist ] , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> minv = P [ 0 ] <COMMENT> <NEWLINE> for i in range ( 1 , len ( P ) ) : <NEWLINE> <INDENT> if minv > P [ i ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> minv = min ( minv , P [ i ] ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> status = 0 <NEWLINE> prev = a [ 0 ] <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> diff = i - prev <NEWLINE> <NL> if diff == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif diff > 0 : <NEWLINE> <INDENT> if status >= 0 : <NEWLINE> <INDENT> status = diff <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> status = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if status <= 0 : <NEWLINE> <INDENT> status = diff <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> status = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> prev = i <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( H ) ] <NEWLINE> seen = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> <NL> <NL> def rec ( h , w , seen ) : <NEWLINE> <INDENT> if S [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> res = [ 1 , 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = [ 0 , 1 ] <NEWLINE> <DEDENT> dh = [ - 1 , 1 , 0 , 0 ] <NEWLINE> dw = [ 0 , 0 , - 1 , 1 ] <NEWLINE> seen [ h ] [ w ] = 1 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> nh = h + dh [ i ] <NEWLINE> nw = w + dw [ i ] <NEWLINE> if 0 <= nh <= H - 1 and 0 <= nw <= W - 1 : <NEWLINE> <INDENT> if seen [ nh ] [ nw ] == 0 and S [ nh ] [ nw ] != S [ h ] [ w ] : <NEWLINE> <INDENT> r0 , r1 = rec ( nh , nw , seen ) <NEWLINE> res [ 0 ] += r0 <NEWLINE> res [ 1 ] += r1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if seen [ h ] [ w ] != 1 : <NEWLINE> <INDENT> t0 , t1 = rec ( h , w , seen ) <NEWLINE> ans += t0 * t1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . insert ( 0 , 0 ) <NEWLINE> A . append ( 0 ) <NEWLINE> _A = [ ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> _A . append ( abs ( A [ i ] - A [ i - 1 ] ) ) <NEWLINE> <DEDENT> _A . append ( abs ( 0 - A [ N ] ) ) <NEWLINE> S = sum ( _A ) <NEWLINE> <NL> <NL> for i in range ( 0 , N ) : <NEWLINE> <INDENT> allS = S <NEWLINE> allS -= ( _A [ i ] + _A [ i + 1 ] - abs ( A [ i + 2 ] - A [ i ] ) ) <NEWLINE> print ( allS ) <NEWLINE> <DEDENT>
s = input ( ) . strip ( ) <NEWLINE> t = input ( ) . strip ( ) <NEWLINE> <NL> ls = len ( s ) <NEWLINE> lt = len ( t ) <NEWLINE> v = <STRING> <NEWLINE> for i in range ( lt ) : <NEWLINE> <INDENT> v += s [ i ] + t [ i ] <NEWLINE> <DEDENT> if lt != ls : <NEWLINE> <INDENT> v += s [ - 1 ] <NEWLINE> <DEDENT> print ( v ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> s = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( <STRING> . join ( sorted ( input ( ) ) ) ) <NEWLINE> <NL> <DEDENT> t = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] in t : <NEWLINE> <INDENT> t [ s [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ s [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( t [ k ] * ( t [ k ] - 1 ) // 2 for k in t ) ) <COMMENT> <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> D = [ [ 0 ] * 2 for _ in range ( 101010 ) ] <NEWLINE> E = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> <NL> def dfs ( cur , pre , d , id ) : <NEWLINE> <INDENT> D [ cur ] [ id ] = d <NEWLINE> for nv in E [ cur ] : <NEWLINE> <INDENT> if nv != pre : <NEWLINE> <INDENT> dfs ( nv , cur , d + 1 , id ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> E [ x ] . append ( y ) <NEWLINE> E [ y ] . append ( x ) <NEWLINE> <DEDENT> dfs ( a , a , 0 , 0 ) <NEWLINE> dfs ( b , b , 0 , 1 ) <NEWLINE> max_d = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if D [ i ] [ 0 ] < D [ i ] [ 1 ] : <NEWLINE> <INDENT> max_d = max ( max_d , D [ i ] [ 1 ] - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( max_d ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = sum ( B ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] + 1 == A [ i + 1 ] : <NEWLINE> <INDENT> ans += C [ A [ i ] - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n , k , l = map ( int , input ( ) . split ( ) ) <NEWLINE> city1 = [ i for i in range ( n ) ] <NEWLINE> city2 = [ i for i in range ( n ) ] <NEWLINE> <NL> def root ( c , x ) : <NEWLINE> <INDENT> if x == c [ x ] : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ x ] = root ( c , c [ x ] ) <NEWLINE> return c [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( c , x , y ) : <NEWLINE> <INDENT> rx = root ( c , x ) <NEWLINE> ry = root ( c , y ) <NEWLINE> if rx > ry : <NEWLINE> <INDENT> c [ rx ] = ry <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ ry ] = rx <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> union ( city1 , a - 1 , b - 1 ) <NEWLINE> <DEDENT> for i in range ( l ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> union ( city2 , a - 1 , b - 1 ) <NEWLINE> <DEDENT> r = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> r . append ( ( root ( city1 , i ) , root ( city2 , i ) ) ) <NEWLINE> <DEDENT> c = Counter ( r ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = c [ r [ i ] ] <NEWLINE> if i == n - 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import fractions <NEWLINE> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst = [ 0 ] * N <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> lst [ i ] = x [ i ] - X <NEWLINE> <NL> <DEDENT> a = 0 <NEWLINE> for e in lst : <NEWLINE> <INDENT> a = fractions . gcd ( a , e ) <NEWLINE> <DEDENT> print ( abs ( a ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = [ ( A [ i ] , 1 ) for i in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> B , C = ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D . append ( ( C , B ) ) <NEWLINE> <NL> <DEDENT> D . sort ( ) <NEWLINE> D . reverse ( ) <NEWLINE> <NL> ans , left = 0 , N <NEWLINE> for ( i , j ) in D : <NEWLINE> <INDENT> use = min ( j , left ) <NEWLINE> ans += use * i <NEWLINE> left -= use <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> R , S , P = map ( int , input ( ) . split ( ) ) <NEWLINE> T = input ( ) <NEWLINE> score = { <STRING> : P , <STRING> : R , <STRING> : S } <NEWLINE> m = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> command = [ ] <NEWLINE> mm = [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> <NL> for i , t in enumerate ( T ) : <NEWLINE> <INDENT> if t == <STRING> : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> point = P <NEWLINE> <DEDENT> elif t == <STRING> : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> point = R <NEWLINE> <DEDENT> elif t == <STRING> : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> point = S <NEWLINE> <NL> <DEDENT> if ( i - K >= 0 ) and ( command [ i - K ] == c ) : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> point = 0 <NEWLINE> <NL> <DEDENT> ans += point <NEWLINE> command . append ( c ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> def get_input ( ) -> tuple : <NEWLINE> <INDENT> <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> return N , A , B , C <NEWLINE> <NL> <NL> <DEDENT> def get_lb ( l : list , key : int ) -> int : <NEWLINE> <INDENT> <STRING> <NEWLINE> low = - 1 <NEWLINE> high = len ( l ) <NEWLINE> while 1 < high - low : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> guess = l [ mid ] <NEWLINE> if guess > key : <NEWLINE> <INDENT> high = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid <NEWLINE> <DEDENT> <DEDENT> return high <NEWLINE> <NL> <NL> <DEDENT> def get_ub ( l : list , key : int ) -> int : <NEWLINE> <INDENT> <STRING> <NEWLINE> low = - 1 <NEWLINE> high = len ( l ) <NEWLINE> while 1 < high - low : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> guess = l [ mid ] <NEWLINE> if guess < key : <NEWLINE> <INDENT> low = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> high = mid <NEWLINE> <DEDENT> <DEDENT> return low <NEWLINE> <NL> <NL> <DEDENT> def main ( N : int , A : list , B : list , C : list ) -> None : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> A = sorted ( A ) <NEWLINE> B = sorted ( B ) <NEWLINE> C = sorted ( C ) <NEWLINE> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B_i = B [ i ] <NEWLINE> ans += ( get_ub ( A , B_i ) + 1 ) * ( N - get_lb ( C , B_i ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> N , A , B , C = get_input ( ) <NEWLINE> <NL> <COMMENT> <NL> main ( N , A , B , C ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> al = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> al_s = sorted ( al , reverse = True ) <NEWLINE> c = Counter ( al_s ) <NEWLINE> ck = list ( c . keys ( ) ) <NEWLINE> cv = list ( c . values ( ) ) <NEWLINE> <NL> <NL> for a in al : <NEWLINE> <INDENT> if a == ck [ 0 ] : <NEWLINE> <INDENT> if cv [ 0 ] == 1 : <NEWLINE> <INDENT> print ( ck [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ck [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ck [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , k + 1 , 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , k + 1 , 1 ) : <NEWLINE> <INDENT> if 0 <= s - i - j <= k : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def combinations_count ( n , r ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <DEDENT> import math <NEWLINE> from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ms = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> ms . reverse ( ) <NEWLINE> combs = combinations_count ( n , 2 ) <NEWLINE> res = deque ( [ combs ] ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for i in ms [ : - 1 ] : <NEWLINE> <INDENT> if not ( uf . same ( i [ 0 ] - 1 , i [ 1 ] - 1 ) ) : <NEWLINE> <INDENT> combs -= uf . size ( i [ 0 ] - 1 ) * uf . size ( i [ 1 ] - 1 ) <NEWLINE> <DEDENT> res . appendleft ( combs ) <NEWLINE> uf . union ( i [ 0 ] - 1 , i [ 1 ] - 1 ) <NEWLINE> <DEDENT> for i in res : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> magics = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> max_a = sorted ( magics , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 0 ] <NEWLINE> dp = [ 0 ] * ( h + max_a ) <NEWLINE> for i in range ( 1 , h + max_a ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + b for a , b in magics ) <NEWLINE> <DEDENT> print ( min ( dp [ h : ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> xn = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xn_s = sorted ( xn ) <NEWLINE> m1 = xn_s [ n // 2 - 1 ] <NEWLINE> m2 = xn_s [ n // 2 ] <NEWLINE> for x in xn : <NEWLINE> <INDENT> if x <= m1 : <NEWLINE> <INDENT> print ( m2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m1 ) <NEWLINE> <DEDENT> <DEDENT>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v . sort ( reverse = True ) <NEWLINE> a = v [ : A ] <NEWLINE> b = v [ : B ] <NEWLINE> avg = sum ( a ) / A <NEWLINE> print ( avg ) <NEWLINE> c = [ [ 0 ] * 51 for _ in range ( 51 ) ] <NEWLINE> c [ 0 ] [ 0 ] = 1 <NEWLINE> for i in range ( 50 ) : <NEWLINE> <INDENT> c [ i + 1 ] [ 0 ] = 1 <NEWLINE> c [ i + 1 ] [ i + 1 ] = 1 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> c [ i + 1 ] [ j + 1 ] = c [ i ] [ j ] + c [ i ] [ j + 1 ] <NEWLINE> <DEDENT> <DEDENT> if a [ 0 ] == a [ - 1 ] : <NEWLINE> <INDENT> ans = 0 <NEWLINE> x = v . count ( a [ 0 ] ) <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i <= x : <NEWLINE> <INDENT> ans += c [ x ] [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> x = v . count ( a [ - 1 ] ) <NEWLINE> y = a . count ( a [ - 1 ] ) <NEWLINE> ans = c [ x ] [ y ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = list ( set ( input ( ) ) ) <NEWLINE> S . sort ( ) <NEWLINE> import string <NEWLINE> switch = True <NEWLINE> A = list ( string . ascii_lowercase ) <NEWLINE> for i in A : <NEWLINE> <INDENT> if not i in S : <NEWLINE> <INDENT> print ( i ) <NEWLINE> switch = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if switch : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
h , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ [ ] for t in range ( h * w ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> ll = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> l [ ll [ j ] - 1 ] = [ i , j ] <NEWLINE> <NL> <DEDENT> <DEDENT> r = [ [ 0 ] for dd in range ( d ) ] <NEWLINE> for dd in range ( d ) : <NEWLINE> <INDENT> if dd == 0 : <NEWLINE> <INDENT> k = d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = dd <NEWLINE> <DEDENT> while k + d <= h * w : <NEWLINE> <INDENT> r [ dd ] . append ( r [ dd ] [ - 1 ] + abs ( l [ k + d - 1 ] [ 0 ] - l [ k - 1 ] [ 0 ] ) + abs ( l [ k + d - 1 ] [ 1 ] - l [ k - 1 ] [ 1 ] ) ) <NEWLINE> k += d <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> for qq in range ( q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a % d == 0 : <NEWLINE> <INDENT> p = d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = a % d <NEWLINE> <DEDENT> aa = ( a - p ) // d <NEWLINE> bb = ( b - p ) // d <NEWLINE> ans = r [ a % d ] [ bb ] - r [ a % d ] [ aa ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> import collections <NEWLINE> import fractions <NEWLINE> import itertools <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x . sort ( ) <NEWLINE> if n >= m : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = [ abs ( x [ i ] - x [ i + 1 ] ) for i in range ( m - 1 ) ] <NEWLINE> diff . sort ( reverse = True ) <NEWLINE> ans = sum ( diff ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans -= diff [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> import collections <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> q = [ [ int ( j ) for j in input ( ) . split ( ) ] for i in range ( M ) ] <NEWLINE> li = collections . defaultdict ( list ) <NEWLINE> <NL> for i , j in sorted ( q ) : <NEWLINE> <INDENT> li [ i ] . append ( j ) <NEWLINE> <NL> <DEDENT> for p , y in q : <NEWLINE> <INDENT> z = bisect . bisect ( li [ p ] , y ) <NEWLINE> print ( <STRING> . format ( p ) + <STRING> . format ( z ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> LI = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> N , M = LI ( ) <NEWLINE> XY = [ LI ( ) for _ in range ( M ) ] <NEWLINE> <NL> w = [ None ] * N <NEWLINE> links = [ [ ] for _ in range ( N ) ] <NEWLINE> visit = [ False ] * N <NEWLINE> <NL> <NL> def create_links ( ) : <NEWLINE> <INDENT> for x , y in XY : <NEWLINE> <INDENT> links [ x - 1 ] . append ( y - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def dfs ( u ) : <NEWLINE> <INDENT> visit [ u ] = True <NEWLINE> n = 0 <NEWLINE> for v in links [ u ] : <NEWLINE> <INDENT> if not visit [ v ] : <NEWLINE> <INDENT> w [ v ] = dfs ( v ) <NEWLINE> <DEDENT> n = max ( n , w [ v ] ) <NEWLINE> <DEDENT> return n + 1 <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> create_links ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if not visit [ i ] : <NEWLINE> <INDENT> w [ i ] = dfs ( i ) <NEWLINE> <DEDENT> <DEDENT> ans = max ( w ) - 1 <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> a_ = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> m = a_ [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = gcd ( m , a_ [ i ] ) <NEWLINE> <NL> <DEDENT> print ( m ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - x - y <= k : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> s = input ( ) . strip ( ) <NEWLINE> if len ( s ) == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> if len ( s ) == 2 and s [ 0 ] == s [ 1 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> dp = [ [ 0 ] * 2 for _ in range ( len ( s ) ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> dp [ 0 ] [ 0 ] = dp [ 0 ] [ 1 ] = 1 <NEWLINE> <COMMENT> <NL> if s [ 0 ] == s [ 1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] [ 0 ] = 2 <NEWLINE> dp [ 1 ] [ 1 ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( 2 , len ( s ) ) : <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if s [ i ] == s [ i - 1 ] : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] + 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] + 1 , dp [ i - 1 ] [ 1 ] + 1 ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if s [ i - 3 : i - 1 ] == s [ i - 1 : i + 1 ] : <NEWLINE> <INDENT> dp [ i ] [ 1 ] = dp [ i - 2 ] [ 0 ] + 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ 1 ] = max ( dp [ i - 2 ] [ 0 ] + 1 , dp [ i - 2 ] [ 1 ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( dp [ - 1 ] [ 0 ] , dp [ - 1 ] [ 1 ] ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> from collections import deque <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> Node = [ set ( ) for _ in range ( N ) ] <NEWLINE> Edge = { } <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> if b < a : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> Edge [ ( a , b ) ] = i <NEWLINE> Node [ a ] . add ( b ) <NEWLINE> Node [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> K = 0 <NEWLINE> for i , x in enumerate ( Node ) : <NEWLINE> <INDENT> if len ( x ) > K : <NEWLINE> <INDENT> K = len ( x ) <NEWLINE> top = i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> q = deque ( ) <NEWLINE> seen = [ False ] * ( N - 1 ) <NEWLINE> used = [ set ( ) for _ in range ( N ) ] <NEWLINE> q . append ( top ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> cur = q . popleft ( ) <NEWLINE> col = 1 <NEWLINE> for i in Node [ cur ] : <NEWLINE> <INDENT> if cur > i : <NEWLINE> <INDENT> ed = ( i , cur ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ed = ( cur , i ) <NEWLINE> <DEDENT> if seen [ Edge [ ed ] ] == False : <NEWLINE> <INDENT> while col in used [ cur ] or col in used [ i ] : <NEWLINE> <INDENT> col += 1 <NEWLINE> <DEDENT> seen [ Edge [ ed ] ] = col <NEWLINE> used [ cur ] . add ( col ) <NEWLINE> used [ i ] . add ( col ) <NEWLINE> q . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( K ) <NEWLINE> print ( <STRING> . join ( map ( str , seen ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , h , * ab = map ( int , read ( ) . split ( ) ) <NEWLINE> tops = max ( ab [ 0 : : 2 ] ) <NEWLINE> tlst = [ b for b in ab [ 1 : : 2 ] if b > tops ] <NEWLINE> tlst . sort ( reverse = True ) <NEWLINE> i = - 1 <NEWLINE> t = 0 <NEWLINE> for i , t in enumerate ( tlst ) : <NEWLINE> <INDENT> h -= t <NEWLINE> if h <= 0 : <NEWLINE> <INDENT> h = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( h // tops + ( h % tops > 0 ) + i + 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> break <NEWLINE> <DEDENT> elif i == N - 2 : print ( <STRING> ) <NEWLINE> <DEDENT>
patterns = [ None ] * ( 10 ** 5 + 10 ) <NEWLINE> patterns [ 0 ] = 1 <NEWLINE> patterns [ 1 ] = 1 <NEWLINE> calcurated_until = 1 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> def get_patterns ( n ) : <NEWLINE> <INDENT> global calcurated_until , patterns <NEWLINE> if patterns [ n ] is None : <NEWLINE> <INDENT> for i in range ( calcurated_until + 1 , n + 1 ) : <NEWLINE> <INDENT> patterns [ i ] = ( patterns [ i - 1 ] + patterns [ i - 2 ] ) % MOD <NEWLINE> <DEDENT> calcurated_until = n <NEWLINE> <COMMENT> <NL> <DEDENT> return patterns [ n ] <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ - 1 ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> A . append ( N + 1 ) <NEWLINE> <COMMENT> <NL> <NL> ans = 1 <NEWLINE> for a1 , a2 in zip ( A [ : - 1 ] , A [ 1 : ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> if a2 == a1 + 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans *= get_patterns ( a2 - a1 - 2 ) <NEWLINE> <COMMENT> <NL> ans %= MOD <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> solve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> power = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> power *= i <NEWLINE> power %= mod <NEWLINE> <NL> <DEDENT> print ( power % mod ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dp = np . zeros ( W + 1 , np . int64 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> np . maximum ( dp [ w : ] , dp [ : - w ] + v , out = dp [ w : ] ) <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
from collections import Counter as C <NEWLINE> <NL> _ = input ( ) <NEWLINE> a = C ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ ] <NEWLINE> for k , v in a . items ( ) : <NEWLINE> <INDENT> b . extend ( [ k ] * ( v // 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if 2 <= len ( b ) : <NEWLINE> <INDENT> b . sort ( ) <NEWLINE> print ( b [ - 1 ] * b [ - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> B = [ A [ i ] for i in range ( N ) if i % 2 == 0 ] <NEWLINE> C = [ A [ ( N - i - 1 ) ] for i in range ( N ) if ( N - i - 1 ) % 2 == 1 ] <NEWLINE> print ( * C + B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = [ A [ i ] for i in range ( N ) if i % 2 == 1 ] <NEWLINE> C = [ A [ ( N - i - 1 ) ] for i in range ( N ) if ( N - i - 1 ) % 2 == 0 ] <NEWLINE> print ( * C + B ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> mx = A [ 0 ] ; A = A [ 1 : ] <NEWLINE> mn = A [ 0 ] <NEWLINE> for a in A [ 1 : ] : <NEWLINE> <INDENT> if abs ( mn - mx / 2 ) > abs ( a - mx / 2 ) : <NEWLINE> <INDENT> mn = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( mx , mn ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import copy <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = copy . deepcopy ( a ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> l = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 2 , int ( a [ i ] ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if a [ i ] % j == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while a [ i ] % j == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> a [ i ] = a [ i ] // j <NEWLINE> <DEDENT> if l . get ( j ) == None : <NEWLINE> <INDENT> l [ j ] = cnt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ j ] = max ( cnt , l [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if a [ i ] != 1 : <NEWLINE> <INDENT> if l . get ( a [ i ] ) == None : <NEWLINE> <INDENT> l [ a [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> L = 1 <NEWLINE> for k in l . keys ( ) : <NEWLINE> <INDENT> L *= pow ( k , l [ k ] , mod ) <NEWLINE> <DEDENT> L = L % mod <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += L * pow ( A [ i ] , mod - 2 , mod ) % mod <NEWLINE> ans = ans % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> A_count = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> A_count += 1 <NEWLINE> <DEDENT> elif i == <STRING> or i == <STRING> : <NEWLINE> <INDENT> A_count = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += A_count <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> import bisect <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inda = bisect . bisect_left ( a , b [ i ] ) <NEWLINE> indc = bisect . bisect_right ( c , b [ i ] ) <NEWLINE> ans += inda * ( n - indc ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ai = a [ - 1 ] <NEWLINE> half_ai = ai // 2 <NEWLINE> <NL> i_left = bisect . bisect_left ( a , half_ai ) <NEWLINE> i_right = bisect . bisect_right ( a , half_ai ) <NEWLINE> if ( a [ i_left ] == half_ai ) : <NEWLINE> <INDENT> print ( ai , half_ai ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if ( i_left == i_right and i_left == 0 ) : <NEWLINE> <INDENT> print ( ai , a [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if ( abs ( half_ai - a [ i_left - 1 ] ) >= <NEWLINE> <INDENT> abs ( half_ai - a [ i_right ] ) and i_right != len ( a ) - 1 ) : <NEWLINE> print ( ai , a [ i_right ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ai , a [ i_left - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] += i + 1 <NEWLINE> ans [ a [ i ] - 1 ] = str ( ans [ a [ i ] - 1 ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def ev ( n ) : <NEWLINE> <INDENT> return n * ( n + 1 ) / ( 2 * n ) <NEWLINE> <NL> <DEDENT> q = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> q . append ( ev ( p [ i ] ) ) <NEWLINE> q [ i + 1 ] = q [ i ] + ev ( p [ i ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> tmp = 0 <NEWLINE> for j in range ( n - k + 1 ) : <NEWLINE> <INDENT> if tmp <= q [ j + k ] - q [ j ] : <NEWLINE> <INDENT> tmp = q [ j + k ] - q [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( tmp ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( A , min ( A + K , B + 1 ) ) : l . append ( i ) <NEWLINE> for i in range ( max ( B - K + 1 , A ) , B + 1 ) : l . append ( i ) <NEWLINE> l = sorted ( list ( set ( l ) ) ) <NEWLINE> for i in l : print ( i ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> for i in range ( min ( len ( s ) , k ) ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( 1 ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if N > M : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst . sort ( ) <NEWLINE> sum_1 = max ( lst ) - min ( lst ) <NEWLINE> D = [ ] <NEWLINE> for i in range ( 1 , M ) : <NEWLINE> <INDENT> D . append ( lst [ i ] - lst [ i - 1 ] ) <NEWLINE> <DEDENT> D . sort ( reverse = True ) <NEWLINE> sum_2 = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> sum_2 += D [ i ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> ans = sum_1 - sum_2 <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ [ int ( input ( ) ) , i ] for i in range ( n ) ] <NEWLINE> a . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 != a [ i ] [ 1 ] % 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> op = [ 0 ] * M <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> op [ i ] = ( c , b ) <NEWLINE> <NL> <DEDENT> op . sort ( reverse = True ) <NEWLINE> <NL> now = 0 <NEWLINE> flag = False <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> val , maisu = op [ i ] <NEWLINE> if now >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if A [ now ] < val : <NEWLINE> <INDENT> for j in range ( maisu ) : <NEWLINE> <INDENT> if now + j < N : <NEWLINE> <INDENT> if A [ now + j ] < val : <NEWLINE> <INDENT> A [ now + j ] = val <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> now += maisu <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> if m // 2 >= n : <NEWLINE> <INDENT> cnt += n <NEWLINE> m -= n * 2 <NEWLINE> print ( cnt + m // 4 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m // 2 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
from collections import defaultdict , deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> count = [ 0 ] * N <NEWLINE> parent = defaultdict ( int ) <NEWLINE> t = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> t [ a - 1 ] . append ( b ) <NEWLINE> t [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> count [ p - 1 ] += x <NEWLINE> <NL> <NL> <DEDENT> f = [ False ] * N <NEWLINE> q = deque ( [ 1 ] ) <NEWLINE> while ( q ) : <NEWLINE> <INDENT> n = q . popleft ( ) <NEWLINE> f [ n - 1 ] = True <NEWLINE> for i in t [ n - 1 ] : <NEWLINE> <INDENT> if f [ i - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q . append ( i ) <NEWLINE> count [ i - 1 ] += count [ n - 1 ] <NEWLINE> f [ i - 1 ] = True <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( * count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> training = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> training = i * training % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( training ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ k - q ] * n <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> winner_id = int ( input ( ) ) - 1 <NEWLINE> arr [ winner_id ] += 1 <NEWLINE> <NL> <DEDENT> for ele in arr : <NEWLINE> <INDENT> if ele > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> N , K , * XY = [ int ( _ ) for _ in open ( 0 ) . read ( ) . split ( ) ] <NEWLINE> XY = np . array ( XY , dtype = np . int64 ) . reshape ( ( N , 2 ) ) . T <NEWLINE> X = np . sort ( XY [ 0 ] ) <NEWLINE> Y = np . sort ( XY [ 1 ] ) <NEWLINE> <NL> @ njit <NEWLINE> def solve ( XY , X , Y ) : <NEWLINE> <INDENT> v = 4 * 10 ** 18 + 1 <NEWLINE> ans = np . array ( [ 0 , 0 , 0 , 0 ] , dtype = np . int64 ) <NEWLINE> for i1 in range ( N - 1 ) : <NEWLINE> <INDENT> x1 = X [ i1 ] <NEWLINE> for i2 in range ( i1 + 1 , N ) : <NEWLINE> <INDENT> x2 = X [ i2 ] <NEWLINE> for j1 in range ( N - 1 ) : <NEWLINE> <INDENT> y1 = Y [ j1 ] <NEWLINE> for j2 in range ( j1 + 1 , N ) : <NEWLINE> <INDENT> y2 = Y [ j2 ] <NEWLINE> if np . sum ( ( x1 <= XY [ 0 ] ) * ( XY [ 0 ] <= x2 ) * ( y1 <= XY [ 1 ] ) * ( XY [ 1 ] <= y2 ) ) < K : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v2 = ( x2 - x1 ) * ( y2 - y1 ) <NEWLINE> v = min ( v , v2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return v <NEWLINE> <NL> <DEDENT> ans = solve ( XY , X , Y ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> city = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s , p = input ( ) . split ( ) <NEWLINE> city . append ( [ s , int ( p ) , i + 1 ] ) <NEWLINE> <DEDENT> city . sort ( key = lambda city : ( city [ 0 ] , - city [ 1 ] ) ) <NEWLINE> <NL> for i in city : <NEWLINE> <INDENT> print ( i [ 2 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> from collections import deque <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> alist = [ False ] * N <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> alist [ int ( input ( ) ) - 1 ] = True <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> dp = deque ( [ 0 ] * 2 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> if N == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if alist [ 0 ] : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if alist [ i - 1 ] : <NEWLINE> <INDENT> dp . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp . append ( ( dp [ 0 ] + dp [ 1 ] ) % mod ) <NEWLINE> <DEDENT> dp . popleft ( ) <NEWLINE> <DEDENT> ans = dp [ - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL>
s = input ( ) <NEWLINE> s += <STRING> <NEWLINE> ans = <STRING> <NEWLINE> lst = [ ] <NEWLINE> for ss in s : <NEWLINE> <INDENT> if ss in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> ans += ss <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst . append ( len ( ans ) ) <NEWLINE> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( max ( lst ) ) <NEWLINE>
from collections import Counter <NEWLINE> import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = sorted ( D ) <NEWLINE> D_counter = Counter ( D ) <NEWLINE> <NL> <NL> M = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> T = sorted ( T ) <NEWLINE> T_counter = Counter ( T ) <NEWLINE> <NL> <NL> <NL> D_keylist = ( list ( D_counter . items ( ) ) ) <NEWLINE> <NL> T_keylist = ( list ( T_counter . keys ( ) ) ) <NEWLINE> T_Valuelist = ( list ( T_counter . values ( ) ) ) <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> T_index = 0 <NEWLINE> <NL> for i in D_keylist : <NEWLINE> <INDENT> D_key = i [ 0 ] <COMMENT> <NEWLINE> D_value = i [ 1 ] <COMMENT> <NEWLINE> <NL> T_key = T_keylist [ T_index ] <COMMENT> <NEWLINE> T_value = T_Valuelist [ T_index ] <COMMENT> <NEWLINE> <NL> <NL> if D_key == T_key and ( D_value >= T_value ) : <COMMENT> <NEWLINE> <INDENT> T_index = T_index + 1 <COMMENT> <NEWLINE> ans = ans + 1 <COMMENT> <NEWLINE> <NL> if T_index == M : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if len ( T_keylist ) == ans : <COMMENT> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> t = str ( input ( ) ) <NEWLINE> <NL> l = <STRING> <NEWLINE> <NL> ss = <STRING> . join ( sorted ( s ) ) <NEWLINE> st = <STRING> . join ( sorted ( t ) ) <NEWLINE> str = <STRING> . join ( sorted ( t , reverse = True ) ) <NEWLINE> <NL> if l . index ( str [ 0 ] ) > l . index ( ss [ 0 ] ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif len ( t ) > len ( s ) and ss in st : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( int ( input ( ) ) for i in range ( q ) ) <NEWLINE> add = [ 0 ] * n <NEWLINE> def func ( x ) : <NEWLINE> <INDENT> return k - q + x <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> add [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> point = list ( map ( func , add ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> if point [ _ ] <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> A = [ int ( input ( ) ) for _ in range ( M ) ] <NEWLINE> B = [ 1 ] * ( N + 1 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> B [ A [ i ] ] = 0 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i - 1 >= 0 : <NEWLINE> <INDENT> dp [ i + 1 ] = dp [ i ] * B [ i ] + dp [ i - 1 ] * B [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] = dp [ i ] * B [ i ] <NEWLINE> <DEDENT> dp [ i + 1 ] %= 10 ** 9 + 7 <NEWLINE> <DEDENT> print ( dp [ N ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 11 <NEWLINE> for a in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % a != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> b = n // a <NEWLINE> ans = min ( ans , max ( len ( str ( a ) ) , len ( str ( b ) ) ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
H , W , D = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( H ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> LR = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> pos = [ None ] * ( H * W ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> pos [ A [ i ] [ j ] - 1 ] = ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> d = [ 0 ] * ( H * W ) <NEWLINE> for i in range ( D , H * W ) : <NEWLINE> <INDENT> px , py = pos [ i - D ] <NEWLINE> x , y = pos [ i ] <NEWLINE> d [ i ] = d [ i - D ] + abs ( x - px ) + abs ( y - py ) <NEWLINE> <NL> <DEDENT> for l , r in LR : <NEWLINE> <INDENT> print ( d [ r - 1 ] - d [ l - 1 ] ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> b1 = 0 <NEWLINE> d = 0 <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = sorted ( B , reverse = True ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = sorted ( C ) <NEWLINE> D = [ ] <NEWLINE> E = [ ] <NEWLINE> <NL> for b in B : <NEWLINE> <INDENT> d = d + len ( C ) - bisect . bisect_right ( C , b ) <NEWLINE> D . append ( d ) <NEWLINE> <NL> <DEDENT> D = sorted ( D , reverse = True ) <NEWLINE> B = sorted ( B ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if 0 <= bisect . bisect_right ( B , a ) <= len ( D ) - 1 : <NEWLINE> <INDENT> ans += D [ bisect . bisect_right ( B , a ) ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> import sys <NEWLINE> <NL> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def depth ( adj , node , parent = None ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for child in adj [ node ] : <NEWLINE> <INDENT> if child == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> d = depth ( adj , child , node ) + 1 <NEWLINE> ret = max ( ret , d ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , U , V = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> U -= 1 <NEWLINE> V -= 1 <NEWLINE> adj = defaultdict ( list ) <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> A , B = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( <STRING> ) ) ) <NEWLINE> adj [ A ] . append ( B ) <NEWLINE> adj [ B ] . append ( A ) <NEWLINE> <NL> <DEDENT> path = [ - 1 ] * N <NEWLINE> <NL> def find_path_on_tree ( to_node , node , parent = None , d = 0 ) : <NEWLINE> <INDENT> if node == to_node : <NEWLINE> <INDENT> path [ d ] = node <NEWLINE> return True <NEWLINE> <DEDENT> for child in adj [ node ] : <NEWLINE> <INDENT> if child == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if not find_path_on_tree ( to_node , child , node , d + 1 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> path [ d ] = node <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> find_path_on_tree ( U , V ) <COMMENT> <NEWLINE> path = [ node for node in path if node != - 1 ] <NEWLINE> dist = len ( path ) - 1 <NEWLINE> partial_depth = depth ( adj , path [ ( dist // 2 ) + 1 ] , path [ dist // 2 ] ) <NEWLINE> print ( partial_depth + ( dist // 2 ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> clist = [ <STRING> . join ( sorted ( input ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> c = Counter ( clist ) <NEWLINE> <NL> print ( sum ( [ v * ( v - 1 ) // 2 for v in c . values ( ) ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> inf = 10 ** 9 <NEWLINE> dp = [ 0 ] + [ inf ] * N <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - 1 ] + abs ( h [ i ] - h [ i - 1 ] ) , dp [ i - 2 ] + abs ( h [ i ] - h [ i - 2 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
from itertools import accumulate <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = tuple ( accumulate ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = P [ K - 1 ] <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> ans = max ( P [ i + K ] - P [ i ] , ans ) <NEWLINE> <DEDENT> print ( ( ans + K ) / 2 ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> arr = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> arr . append ( a ) <NEWLINE> <DEDENT> c = collections . Counter ( arr ) <NEWLINE> ans = 0 <NEWLINE> for j in c . values ( ) : <NEWLINE> <INDENT> if j % 2 != 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> num = 1 <NEWLINE> div = int ( 1e9 ) + 7 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> num = num * i % div <NEWLINE> <DEDENT> print ( num ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> rest = x <NEWLINE> target = sorted ( a ) <NEWLINE> if sum ( target ) < x : <NEWLINE> <INDENT> print ( n - 1 ) <NEWLINE> <DEDENT> elif sum ( target ) == x : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> rest -= target [ i ] <NEWLINE> if rest < 0 : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> if rest == 0 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> B = sorted ( A , reverse = True ) <NEWLINE> x = B [ 1 ] <NEWLINE> y = B [ 0 ] <NEWLINE> m = A . index ( max ( A ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i == m : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> count = 0 <NEWLINE> if N == 3 : <NEWLINE> <INDENT> if S == <STRING> : <NEWLINE> <INDENT> count = 1 <NEWLINE> <DEDENT> <DEDENT> elif N > 3 : <NEWLINE> <INDENT> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> if S [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import collections as c <NEWLINE> n = [ c . Counter ( input ( ) ) for _ in range ( int ( input ( ) ) ) ] ; r = n [ 0 ] <NEWLINE> for i in range ( 1 , len ( n ) ) : r = r & n [ i ] <NEWLINE> print ( * sorted ( [ i * j for i , j in r . items ( ) ] ) , sep = <STRING> ) <NEWLINE>
from sys import stdin <NEWLINE> import collections <NEWLINE> <NL> N , M = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> A = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> A = collections . Counter ( A ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> B , C = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> A [ C ] += B <NEWLINE> <DEDENT> A = dict ( A ) <NEWLINE> A = dict ( sorted ( A . items ( ) ) ) <NEWLINE> <NL> S = 0 <NEWLINE> j = - 1 <NEWLINE> <NL> A_key = list ( A . keys ( ) ) <NEWLINE> A_value = list ( A . values ( ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if A_value [ j ] < N : <NEWLINE> <INDENT> S += A_value [ j ] * A_key [ j ] <NEWLINE> N -= A_value [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S += N * A_key [ j ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
import sys , math , collections , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> H , W , D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( H ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> LR = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> <NL> <NL> dict_map = { } <NEWLINE> for ih in range ( H ) : <NEWLINE> <INDENT> for iw in range ( W ) : <NEWLINE> <INDENT> dict_map [ A [ ih ] [ iw ] ] = ( ih , iw ) <NEWLINE> <NL> <DEDENT> <DEDENT> memo = [ - 1 ] * ( H * W + 1 ) <NEWLINE> for i in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> useMP = 0 <NEWLINE> direct = range ( i , H * W + 1 , D ) <NEWLINE> memo [ i ] = 0 <NEWLINE> for p in range ( len ( direct ) - 1 ) : <NEWLINE> <INDENT> x0 , y0 = dict_map [ direct [ p ] ] <NEWLINE> x1 , y1 = dict_map [ direct [ p + 1 ] ] <NEWLINE> dist = abs ( x0 - x1 ) + abs ( y0 - y1 ) <NEWLINE> useMP += dist <NEWLINE> memo [ direct [ p + 1 ] ] = useMP <NEWLINE> <NL> <DEDENT> <DEDENT> for q in range ( Q ) : <NEWLINE> <INDENT> L , R = LR [ q ] <NEWLINE> print ( memo [ R ] - memo [ L ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> d [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> d . sort ( ) <NEWLINE> <NL> print ( sum ( d [ : n - k + 1 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> button = [ 0 ] * N <NEWLINE> button [ 0 ] = 1 <NEWLINE> next_button = 1 <NEWLINE> i = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> button [ next_button - 1 ] = 2 <NEWLINE> next_button = A [ next_button - 1 ] <NEWLINE> if button [ next_button - 1 ] == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif next_button == 2 : <NEWLINE> <INDENT> i += 1 <NEWLINE> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> button [ next_button - 1 ] = 1 <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> nt = tuple ( range ( n ) ) <NEWLINE> kt = tuple ( range ( 1 , k + 1 ) ) <NEWLINE> h = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 10 ** 9 ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in nt : <NEWLINE> <INDENT> for j in kt : <NEWLINE> <INDENT> i_j = i + j <NEWLINE> if i_j < n : <NEWLINE> <INDENT> x = dp [ i ] + abs ( h [ i ] - h [ i_j ] ) <NEWLINE> if dp [ i_j ] > x : <NEWLINE> <INDENT> dp [ i_j ] = x <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> t = int ( n ** 0.5 ) <NEWLINE> while len ( l ) == 0 : <NEWLINE> <INDENT> if n % t == 0 : <NEWLINE> <INDENT> l . append ( ( t , n // t ) ) <NEWLINE> <DEDENT> t -= 1 <NEWLINE> <DEDENT> x , y = l [ 0 ] [ 0 ] , l [ 0 ] [ 1 ] <NEWLINE> ans = max ( len ( list ( str ( x ) ) ) , len ( list ( str ( y ) ) ) ) <NEWLINE> print ( ans ) <NEWLINE>
d = { } <NEWLINE> n = input ( ) <NEWLINE> aaa = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> ans = <STRING> <NEWLINE> for a in aaa : <NEWLINE> <INDENT> d [ a ] = d . get ( a , 0 ) + 1 <NEWLINE> if d [ a ] >= 2 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> d = [ s [ 0 ] ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> d . pop ( ) <NEWLINE> d . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . append ( s [ i ] ) <NEWLINE> <DEDENT> <DEDENT> q = <STRING> . join ( d ) <NEWLINE> cou = 0 <NEWLINE> cou_a = 0 <NEWLINE> l = len ( q ) <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> if q [ i ] == <STRING> : <NEWLINE> <INDENT> cou_a += 1 <NEWLINE> <DEDENT> elif q [ i ] == <STRING> : <NEWLINE> <INDENT> cou += cou_a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cou_a = 0 <NEWLINE> <DEDENT> <DEDENT> print ( cou ) <NEWLINE>
<NL> def resolve ( ) : <NEWLINE> <INDENT> N , D , A = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> AB . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> imos = [ 0 ] * ( N + 1 ) <NEWLINE> ans = 0 <NEWLINE> R = 0 <NEWLINE> for l in range ( N ) : <NEWLINE> <INDENT> if l : <NEWLINE> <INDENT> imos [ l ] += imos [ l - 1 ] <NEWLINE> <DEDENT> x = AB [ l ] [ 0 ] <NEWLINE> h = AB [ l ] [ 1 ] <NEWLINE> if imos [ l ] < h : <NEWLINE> <INDENT> R = max ( R , l + 1 ) <NEWLINE> while R < N and AB [ R ] [ 0 ] <= 2 * D + x : <NEWLINE> <INDENT> R += 1 <NEWLINE> <DEDENT> d = h - imos [ l ] <NEWLINE> cnt = ( d + A - 1 ) // A <NEWLINE> imos [ l ] += cnt * A <NEWLINE> imos [ R ] -= cnt * A <NEWLINE> ans += cnt <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
dish = [ int ( input ( ) ) for i in range ( 5 ) ] <NEWLINE> a = [ i % 10 for i in dish ] <NEWLINE> <NL> x = 10 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> x = min ( x , i ) <NEWLINE> <DEDENT> <DEDENT> if x == 10 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> y = a . index ( x ) <NEWLINE> l = dish . pop ( y ) <NEWLINE> <NL> time = [ ( i // 10 + 1 ) * 10 if i % 10 != 0 else i for i in dish ] <NEWLINE> <NL> ans = sum ( time ) + l <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> diff = [ a [ i ] - b [ i ] for i in range ( n ) ] <NEWLINE> if sum ( diff ) < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff . sort ( ) <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> for i in diff : <NEWLINE> <INDENT> if i < 0 : <NEWLINE> <INDENT> count += i <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in diff [ : : - 1 ] : <NEWLINE> <INDENT> if count >= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += i <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> import numba as nb <NEWLINE> import numpy as np <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> @ nb . njit ( <STRING> ) <NEWLINE> def chmax ( a , b ) : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return b <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> @ nb . njit ( <STRING> ) <NEWLINE> def solve ( N , W , wv ) : <NEWLINE> <INDENT> dp = [ [ 0 ] * ( W + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> w , v = wv [ i - 1 ] <NEWLINE> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if j < w : <NEWLINE> <INDENT> dp [ i ] [ j ] = dp [ i - 1 ] [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = chmax ( dp [ i - 1 ] [ j - w ] + v , dp [ i - 1 ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp [ - 1 ] [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> wv = np . zeros ( shape = ( N , 2 ) , dtype = np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> wv [ i ] = w , v <NEWLINE> <NL> <DEDENT> ans = solve ( N , W , wv ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) , dtype = np . int64 ) <NEWLINE> bc = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] , key = lambda x : - x [ 1 ] ) <NEWLINE> <NL> p = 0 <NEWLINE> for b , c in bc : <NEWLINE> <INDENT> a [ p : p + b ] = np . maximum ( a [ p : p + b ] , c ) <NEWLINE> p += b <NEWLINE> <DEDENT> print ( np . sum ( a ) ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> t = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <COMMENT> <NL> if n == 1 : <NEWLINE> <INDENT> print ( t [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> lcm = ( t [ i ] * t [ i + 1 ] ) // math . gcd ( t [ i ] , t [ i + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lcm = ( lcm * t [ i + 1 ] ) // math . gcd ( lcm , t [ i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( lcm ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> ans = make_divisors ( N ) <NEWLINE> result = [ ] <NEWLINE> if len ( ans ) % 2 == 0 : <NEWLINE> <INDENT> for i , j in zip ( range ( 0 , int ( len ( ans ) / 2 ) ) , reversed ( range ( int ( len ( ans ) / 2 ) , len ( ans ) ) ) ) : <NEWLINE> <INDENT> result . append ( int ( ans [ i ] + ans [ j ] ) - 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> x = ans [ int ( len ( ans ) / 2 ) ] <NEWLINE> result . append ( ( x - 1 ) * 2 ) <NEWLINE> <DEDENT> print ( min ( result ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( * A [ : : - 2 ] , * A [ N % 2 : : 2 ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * ( N ) <NEWLINE> dp [ 1 ] = abs ( h [ 0 ] - h [ 1 ] ) <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ j ] + abs ( h [ j ] - h [ i ] ) for j in range ( max ( 0 , i - K ) , i ) ) <NEWLINE> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = sorted ( zip ( B , A ) ) <NEWLINE> B , A = zip ( * C ) <NEWLINE> D = sorted ( ( a , i ) for i , a in enumerate ( A ) ) <NEWLINE> E , indices = zip ( * D ) <NEWLINE> for e , b in zip ( E , B ) : <NEWLINE> <INDENT> if e > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> S = { 0 } <NEWLINE> now = 0 <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> if indices [ now ] in S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> now = indices [ now ] <NEWLINE> S . add ( now ) <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if E [ i + 1 ] <= B [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import numpy as np <NEWLINE> def seachPrimeNum ( N ) : <NEWLINE> <INDENT> max = int ( np . sqrt ( N ) ) <NEWLINE> seachList = [ i for i in range ( 2 , N + 1 ) ] <NEWLINE> primeNum = [ ] <NEWLINE> while seachList [ 0 ] <= max : <NEWLINE> <INDENT> primeNum . append ( seachList [ 0 ] ) <NEWLINE> tmp = seachList [ 0 ] <NEWLINE> seachList = [ i for i in seachList if i % tmp != 0 ] <NEWLINE> <DEDENT> primeNum . extend ( seachList ) <NEWLINE> return primeNum <NEWLINE> <NL> <DEDENT> n = 10 ** 5 <NEWLINE> a = seachPrimeNum ( n ) <NEWLINE> b = [ ] <NEWLINE> y = 0 <NEWLINE> x = 0 <NEWLINE> while x <= 100000 : <NEWLINE> <INDENT> t = a [ y ] <NEWLINE> x = t * 2 - 1 <NEWLINE> b . append ( x ) <NEWLINE> y += 1 <NEWLINE> <NL> <DEDENT> c = set ( a ) & set ( b ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> r = [ 0 for _ in range ( 100000 ) ] <NEWLINE> for f in c : <NEWLINE> <INDENT> r [ f ] = 1 <NEWLINE> <DEDENT> for g in range ( len ( r ) - 1 ) : <NEWLINE> <INDENT> r [ g + 1 ] = r [ g ] + r [ g + 1 ] <NEWLINE> <NL> <DEDENT> for p in range ( q ) : <NEWLINE> <INDENT> w , z = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( r [ z ] - r [ w - 1 ] ) <NEWLINE> <NL> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> d = defaultdict ( list ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> d [ int ( S [ i ] ) ] . append ( i ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for n1 in range ( 10 ) : <NEWLINE> <INDENT> if not d [ n1 ] : continue <NEWLINE> for n2 in range ( 10 ) : <NEWLINE> <INDENT> if not d [ n2 ] : continue <NEWLINE> if d [ n1 ] [ 0 ] > d [ n2 ] [ - 1 ] : continue <NEWLINE> for n3 in range ( 10 ) : <NEWLINE> <INDENT> if not d [ n3 ] : continue <NEWLINE> if d [ n1 ] [ 0 ] > d [ n3 ] [ - 1 ] or d [ n2 ] [ 0 ] > d [ n3 ] [ - 1 ] : continue <NEWLINE> for idx in d [ n2 ] : <NEWLINE> <INDENT> if idx > d [ n1 ] [ 0 ] and idx < d [ n3 ] [ - 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P2 = P [ K : ] <NEWLINE> <NL> max_sum = 0 <NEWLINE> sum_ = sum ( P [ : K ] ) <NEWLINE> <NL> for p , q in zip ( P , P2 ) : <NEWLINE> <INDENT> max_sum = max ( max_sum , sum_ ) <NEWLINE> sum_ += q - p <NEWLINE> <NL> <DEDENT> max_sum = max ( max_sum , sum_ ) <NEWLINE> <NL> res = ( max_sum + K ) / 2 <NEWLINE> print ( res ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 2 * 2 * 10 ** 5 ) <NEWLINE> <NL> def dfs ( i , p , edges , num ) : <NEWLINE> <NL> <INDENT> for j in edges [ i ] : <NEWLINE> <INDENT> if ( j != p ) : <NEWLINE> <NL> <INDENT> num [ j ] += num [ i ] <NEWLINE> <NL> dfs ( j , i , edges , num ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <DEDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> edges = [ [ ] for i in range ( N ) ] <NEWLINE> num = [ 0 ] * N <NEWLINE> <NL> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a0 , b0 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> edges [ a0 - 1 ] . append ( b0 - 1 ) <NEWLINE> edges [ b0 - 1 ] . append ( a0 - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> p0 , x0 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> num [ p0 - 1 ] += x0 <NEWLINE> <NL> <DEDENT> dfs ( 0 , - 1 , edges , num ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( num [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> points = [ k ] * ( n + 1 ) <NEWLINE> plus = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> plus [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> points [ i ] = points [ i ] - q + plus [ i ] <NEWLINE> if points [ i ] >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> w = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> w [ A ] . append ( B ) <NEWLINE> w [ B ] . append ( A ) <NEWLINE> <NL> <DEDENT> cnt = [ 0 ] * ( N + 1 ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> P , X = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ P ] += X <NEWLINE> <NL> <DEDENT> flag = [ False ] * ( N + 1 ) <NEWLINE> <NL> q = [ 1 ] <NEWLINE> while q : <NEWLINE> <INDENT> n = q . pop ( ) <NEWLINE> flag [ n ] = True <NEWLINE> for i in w [ n ] : <NEWLINE> <INDENT> if flag [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> flag [ i ] = True <NEWLINE> cnt [ i ] += cnt [ n ] <NEWLINE> q . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( c ) for c in cnt [ 1 : ] ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a_ = int ( input ( ) ) <NEWLINE> a . append ( a_ ) <NEWLINE> <DEDENT> a1 = sorted ( a ) <NEWLINE> ans1 = a1 [ - 1 ] <NEWLINE> ans2 = a1 [ - 2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == ans1 : <NEWLINE> <INDENT> print ( ans2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans1 ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b = [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> b . append ( i + 1 ) <NEWLINE> b . append ( i ) <NEWLINE> b . append ( i - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> c = Counter ( b ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( c . most_common ( ) [ 0 ] [ 1 ] ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> dp = { i } <NEWLINE> xs = [ ] <NEWLINE> ys = [ ] <NEWLINE> now = 0 <NEWLINE> xy = <STRING> <NEWLINE> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> if j < n and s [ j ] == <STRING> : <NEWLINE> <INDENT> now += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if xy == <STRING> : <NEWLINE> <INDENT> if now > 0 : <NEWLINE> <INDENT> xs . append ( now ) <NEWLINE> <DEDENT> xy = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if now > 0 : <NEWLINE> <INDENT> ys . append ( now ) <NEWLINE> <DEDENT> xy = <STRING> <NEWLINE> <DEDENT> now = 0 <NEWLINE> <NL> <DEDENT> for i in xs : <NEWLINE> <INDENT> newdp = set ( ) <NEWLINE> for j in dp : <NEWLINE> <INDENT> newdp . add ( j + i ) <NEWLINE> newdp . add ( j - i ) <NEWLINE> <DEDENT> dp = newdp <NEWLINE> <DEDENT> if x not in dp : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> dp = { 0 } <NEWLINE> for i in ys : <NEWLINE> <INDENT> newdp = set ( ) <NEWLINE> for j in dp : <NEWLINE> <INDENT> newdp . add ( j + i ) <NEWLINE> newdp . add ( j - i ) <NEWLINE> <DEDENT> dp = newdp <NEWLINE> <DEDENT> if y in dp : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if len ( S ) != 26 : <NEWLINE> <INDENT> L = [ 0 ] * 26 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> L [ ord ( S [ i ] ) - 97 ] = 1 <NEWLINE> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> if L [ i ] == 0 : <NEWLINE> <INDENT> print ( S + chr ( 97 + i ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> B = [ ] <NEWLINE> for i in reversed ( range ( 26 ) ) : <NEWLINE> <INDENT> if ord ( S [ i ] ) > ord ( S [ i - 1 ] ) : <NEWLINE> <INDENT> U = i <NEWLINE> M = i - 1 <NEWLINE> B += [ ord ( S [ i ] ) ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += [ ord ( S [ i ] ) ] <NEWLINE> <DEDENT> <DEDENT> B . sort ( ) <NEWLINE> for i in B : <NEWLINE> <INDENT> if chr ( i ) > S [ M ] : <NEWLINE> <INDENT> print ( S [ : M ] + chr ( i ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> L = [ 0 ] * len ( s ) <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> L [ i ] = L [ i - 1 ] <NEWLINE> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> L [ i ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( L [ r - 1 ] - L [ l - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> h , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> n = h * w <NEWLINE> a = [ 0 ] * n <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> a [ w * i + j ] = t [ j ] - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def dist ( i , j ) : <NEWLINE> <INDENT> dh = abs ( i // w - j // w ) <NEWLINE> dw = abs ( i % w - j % w ) <NEWLINE> return dh + dw <NEWLINE> <NL> <DEDENT> idx_list = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> idx_list [ a [ i ] ] = i <NEWLINE> <NL> <DEDENT> dist_list = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i < d : <NEWLINE> <INDENT> dist_list [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dist_list [ i ] = dist_list [ i - d ] + dist ( idx_list [ i - d ] , idx_list [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> l -= 1 ; r -= 1 <NEWLINE> print ( dist_list [ r ] - dist_list [ l ] ) <NEWLINE> <NL> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> res = 0 <NEWLINE> <NL> q = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> q . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> for s in range ( 2 ** n ) : <NEWLINE> <INDENT> judge = True <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( 1 , len ( q [ i ] ) ) : <NEWLINE> <INDENT> w = q [ i ] [ j ] <NEWLINE> if s >> ( w - 1 ) & 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt % 2 != p [ i ] : <NEWLINE> <INDENT> judge = False <NEWLINE> <DEDENT> <DEDENT> if judge : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> numbers = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> numbers = sorted ( numbers ) <NEWLINE> counter = 0 <NEWLINE> <NL> for a in range ( N ) : <NEWLINE> <INDENT> for b in range ( a + 1 , N ) : <NEWLINE> <INDENT> c = bisect . bisect_left ( numbers , numbers [ a ] + numbers [ b ] ) <NEWLINE> if c > b : <NEWLINE> <INDENT> counter += c - b - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> D = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> d_dict = collections . Counter ( D ) <NEWLINE> <NL> cnt = 0 <NEWLINE> if D [ 0 ] != 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> for i in D [ 1 : ] : <NEWLINE> <INDENT> cnt *= d_dict [ i - 1 ] <NEWLINE> cnt %= 998244353 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( cnt % 998244353 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
k , s = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> count = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - ( x + y ) <= k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> m = np . zeros ( ( n , 2 ) ) <NEWLINE> sum1 = 0 <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> sum1 = sum1 + ( ( m [ j ] [ 0 ] - m [ k ] [ 0 ] ) ** 2 + ( m [ j ] [ 1 ] - m [ k ] [ 1 ] ) ** 2 ) ** ( 1 / 2 ) <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> mul = 1 <NEWLINE> for l in range ( n ) : <NEWLINE> <INDENT> mul *= n - l <NEWLINE> <DEDENT> po = 0 <NEWLINE> if n == 2 : <NEWLINE> <INDENT> po = 1 <NEWLINE> <DEDENT> elif n == 3 : <NEWLINE> <INDENT> po = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for m in range ( n ) : <NEWLINE> <INDENT> po += m <NEWLINE> <NL> <DEDENT> <DEDENT> ans = sum1 * ( n - 1 ) / count <NEWLINE> print ( ans ) <NEWLINE>
from heapq import * <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> heapify ( A ) <NEWLINE> <NL> for m in range ( M ) : <NEWLINE> <INDENT> heappush ( A , int ( heappop ( A ) / 2 ) ) <NEWLINE> <NL> <DEDENT> print ( - sum ( A ) ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import math <NEWLINE> if N == 1 : <NEWLINE> <INDENT> if l [ 0 ] == K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> A = math . gcd ( l [ 0 ] , l [ 1 ] ) <NEWLINE> if K <= max ( l ) : <NEWLINE> <INDENT> for i in range ( max ( 0 , N - 2 ) ) : <NEWLINE> <INDENT> A = math . gcd ( A , l [ i + 2 ] ) <NEWLINE> <DEDENT> if K % A == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def dfs ( v ) : <NEWLINE> <INDENT> visited [ v ] = True <NEWLINE> for i in range ( len ( AL [ v ] [ CHILDREN ] ) ) : <NEWLINE> <INDENT> u = AL [ v ] [ CHILDREN ] [ i ] <NEWLINE> if visited [ u ] : <NEWLINE> <INDENT> AL [ v ] [ CHILDREN ] [ i ] = None <NEWLINE> continue <NEWLINE> <DEDENT> AL [ v ] [ SIZE ] += dfs ( u ) <NEWLINE> <DEDENT> return AL [ v ] [ SIZE ] <NEWLINE> <NL> <NL> <DEDENT> def anaaki ( v ) : <NEWLINE> <INDENT> ret = powp - 1 <NEWLINE> for ch in AL [ v ] [ CHILDREN ] : <NEWLINE> <INDENT> if ch is None : continue <NEWLINE> ret -= pow ( 2 , AL [ ch ] [ SIZE ] , p ) - 1 <NEWLINE> ret %= p <NEWLINE> <DEDENT> ret -= pow ( 2 , n - AL [ v ] [ SIZE ] , p ) - 1 <NEWLINE> ret %= p <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> SIZE = 0 <NEWLINE> CHILDREN = 1 <NEWLINE> AL = [ [ 1 , [ ] ] for _ in range ( n ) ] <NEWLINE> visited = [ False ] * n <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> powp = pow ( 2 , n - 1 , p ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> AL [ a ] [ CHILDREN ] . append ( b ) <NEWLINE> AL [ b ] [ CHILDREN ] . append ( a ) <NEWLINE> <NL> <DEDENT> dfs ( 0 ) <NEWLINE> numer = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> numer += anaaki ( i ) <NEWLINE> numer %= p <NEWLINE> <NL> <DEDENT> denom = pow ( 2 , n , p ) <NEWLINE> print ( numer * pow ( denom , p - 2 , p ) % p ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> from heapq import heappop , heappush <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> TD = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> TD . sort ( key = lambda z : - z [ 1 ] ) <NEWLINE> TD_new = [ [ ] for _ in range ( n ) ] <NEWLINE> for t , d in TD : <NEWLINE> <INDENT> TD_new [ t - 1 ] . append ( [ d , 0 ] if len ( TD_new [ t - 1 ] ) else [ d , 1 ] ) <NEWLINE> <NL> <DEDENT> ALL = [ ] <NEWLINE> for td in TD_new : <NEWLINE> <INDENT> ALL . extend ( td ) <NEWLINE> <DEDENT> ALL . sort ( reverse = True ) <NEWLINE> que = deque ( ALL ) <NEWLINE> <NL> x = y = 0 <NEWLINE> zero = [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> d , ex = que . popleft ( ) <NEWLINE> x += d <NEWLINE> y += ex <NEWLINE> if ex == 0 : <NEWLINE> <INDENT> heappush ( zero , d ) <NEWLINE> <NL> <DEDENT> <DEDENT> res = x + y ** 2 <NEWLINE> while que : <NEWLINE> <INDENT> d , ex = que . popleft ( ) <NEWLINE> if ex : <NEWLINE> <INDENT> if zero : <NEWLINE> <INDENT> x += d - heappop ( zero ) <NEWLINE> y += 1 <NEWLINE> res = max ( res , x + y ** 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> N = len ( s ) <NEWLINE> <NL> nox = [ ] <NEWLINE> idxs = [ ] <NEWLINE> ans = 0 <NEWLINE> for i , c in enumerate ( s ) : <NEWLINE> <INDENT> if c != <STRING> : <NEWLINE> <INDENT> nox . append ( c ) <NEWLINE> idxs . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if nox != nox [ : : - 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if len ( nox ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if len ( nox ) % 2 == 0 : <NEWLINE> <INDENT> left = len ( nox ) // 2 - 1 <NEWLINE> right = len ( nox ) // 2 <NEWLINE> <NL> left_idx = idxs [ left ] <NEWLINE> right_idx = idxs [ right ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> center = len ( nox ) // 2 <NEWLINE> left_idx = idxs [ center ] <NEWLINE> right_idx = idxs [ center ] <NEWLINE> <NL> <DEDENT> while not ( left_idx == 0 and right_idx == N - 1 ) : <NEWLINE> <INDENT> if s [ left_idx ] == s [ right_idx ] : <NEWLINE> <INDENT> if left_idx > 0 and right_idx < N - 1 : <NEWLINE> <INDENT> left_idx -= 1 <NEWLINE> right_idx += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if left_idx <= idxs [ 0 ] and right_idx >= idxs [ - 1 ] and ( left_idx > 0 or right_idx < N - 1 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> if left_idx > 0 : <NEWLINE> <INDENT> left_idx -= 1 <NEWLINE> <DEDENT> if right_idx < N - 1 : <NEWLINE> <INDENT> right_idx += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif s [ left_idx ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if left_idx > 0 : <NEWLINE> <INDENT> left_idx -= 1 <NEWLINE> <DEDENT> <DEDENT> elif s [ right_idx ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if right_idx < N - 1 : <NEWLINE> <INDENT> right_idx += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> in_n = lambda : int ( readline ( ) ) <NEWLINE> in_nn = lambda : map ( int , readline ( ) . split ( ) ) <NEWLINE> in_nl = lambda : list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> in_na = lambda : map ( int , read ( ) . split ( ) ) <NEWLINE> in_s = lambda : readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> H , W = in_nn ( ) <NEWLINE> a = np . array ( read ( ) . split ( ) , np . int32 ) . reshape ( ( H , W ) ) <NEWLINE> <NL> odd_count = np . count_nonzero ( a % 2 == 1 ) <NEWLINE> if odd_count % 2 == 1 : <NEWLINE> <INDENT> odd_count -= 1 <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> x , y = 0 , 0 <NEWLINE> px , py = - 1 , - 1 <NEWLINE> odd_f = False <NEWLINE> <NL> ans = [ ] <NEWLINE> while True : <NEWLINE> <NL> <INDENT> if odd_f : <NEWLINE> <INDENT> ans . append ( ( py + 1 , px + 1 , y + 1 , x + 1 ) ) <NEWLINE> if a [ y ] [ x ] % 2 == 1 : <NEWLINE> <INDENT> odd_f = False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a [ y ] [ x ] % 2 == 1 : <NEWLINE> <INDENT> odd_f = True <NEWLINE> <NL> <DEDENT> <DEDENT> px , py = x , y <NEWLINE> if a [ y ] [ x ] % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count >= odd_count : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if y % 2 == 0 : <NEWLINE> <INDENT> if x == W - 1 : <NEWLINE> <INDENT> y += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> y += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if y >= H : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE> for a in ans : <NEWLINE> <INDENT> print ( * a ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> t = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( S [ i : i + 2 ] == <STRING> ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT>
from bisect import bisect <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N == 2 : <NEWLINE> <INDENT> res = [ ( max ( A ) , min ( A ) ) ] <NEWLINE> s = max ( A ) - min ( A ) <NEWLINE> return s , res <NEWLINE> <NL> <DEDENT> if A [ 0 ] >= 0 : <NEWLINE> <INDENT> res = [ ] <NEWLINE> x = A [ 0 ] <NEWLINE> for a in A [ 1 : - 1 ] : <NEWLINE> <INDENT> res . append ( ( x , a ) ) <NEWLINE> x -= a <NEWLINE> <DEDENT> res . append ( ( A [ - 1 ] , x ) ) <NEWLINE> x = A [ - 1 ] - x <NEWLINE> return ( x , res ) <NEWLINE> <DEDENT> if A [ - 1 ] <= 0 : <NEWLINE> <INDENT> res = [ ] <NEWLINE> x = A [ - 1 ] <NEWLINE> for a in A [ : - 1 ] : <NEWLINE> <INDENT> res . append ( ( x , a ) ) <NEWLINE> x -= a <NEWLINE> <DEDENT> return ( x , res ) <NEWLINE> <NL> <DEDENT> res = [ ] <NEWLINE> p = bisect ( A , 0 ) - 1 <NEWLINE> x = A [ p ] <NEWLINE> for a in A [ p + 1 : N - 1 ] : <NEWLINE> <INDENT> res . append ( ( x , a ) ) <NEWLINE> x -= a <NEWLINE> <DEDENT> res . append ( ( A [ - 1 ] , x ) ) <NEWLINE> x = A [ - 1 ] - x <NEWLINE> for a in A [ : p ] : <NEWLINE> <INDENT> res . append ( ( x , a ) ) <NEWLINE> x -= a <NEWLINE> <DEDENT> return ( x , res ) <NEWLINE> <NL> <NL> <NL> <DEDENT> s , res = solve ( ) <NEWLINE> print ( s ) <NEWLINE> print ( <STRING> . join ( <STRING> for a , b in res ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import copy <NEWLINE> import random <NEWLINE> import bisect <COMMENT> <NEWLINE> import fractions <COMMENT> <NEWLINE> import math <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> from decimal import Decimal <COMMENT> <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( mod ) <COMMENT> <NEWLINE> <NL> d = collections . deque ( ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> weights = { } <NEWLINE> <NL> roots = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = LI ( ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> roots [ a ] . append ( b ) <NEWLINE> roots [ b ] . append ( a ) <NEWLINE> weights [ ( a , b ) ] = c <NEWLINE> weights [ ( b , a ) ] = c <NEWLINE> <NL> <DEDENT> Q , K = LI ( ) <NEWLINE> K -= 1 <NEWLINE> xy = [ 0 for i in range ( Q ) ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> x , y = LI ( ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> xy [ i ] = [ x , y ] <NEWLINE> <DEDENT> <STRING> <NEWLINE> <NL> visited = [ - 1 for i in range ( N ) ] <NEWLINE> queue = collections . deque ( ) <NEWLINE> queue . append ( K ) <NEWLINE> visited [ K ] = 0 <NEWLINE> <NL> while len ( queue ) > 0 : <NEWLINE> <INDENT> node = queue . popleft ( ) <NEWLINE> cnt = visited [ node ] <NEWLINE> for n_node in roots [ node ] : <NEWLINE> <INDENT> if visited [ n_node ] == - 1 : <NEWLINE> <INDENT> visited [ n_node ] = cnt + weights [ ( node , n_node ) ] <NEWLINE> queue . append ( n_node ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for x , y in xy : <NEWLINE> <INDENT> print ( visited [ x ] + visited [ y ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( list ( int ( input ( ) ) for i in range ( m ) ) ) <NEWLINE> <NL> p = 10 ** 9 + 7 <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % p <NEWLINE> if i in a : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE> <NL>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ - 1 ] * N <NEWLINE> <NL> <COMMENT> <NL> def rec ( i ) : <NEWLINE> <INDENT> if dp [ i ] >= 0 : <NEWLINE> <INDENT> return dp [ i ] <NEWLINE> <NL> <DEDENT> res = - 1 <NEWLINE> if i == N - 1 : <NEWLINE> <INDENT> res = 0 <NEWLINE> <DEDENT> elif i == N - 2 : <NEWLINE> <INDENT> res = rec ( i + 1 ) + abs ( h [ i + 1 ] - h [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = min ( rec ( i + 1 ) + abs ( h [ i + 1 ] - h [ i ] ) , rec ( i + 2 ) + abs ( h [ i + 2 ] - h [ i ] ) ) <NEWLINE> <NL> <DEDENT> dp [ i ] = res <NEWLINE> return dp [ i ] <NEWLINE> <NL> <DEDENT> print ( rec ( 0 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lis = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lis [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> import collections <NEWLINE> <NL> ans = 0 <NEWLINE> lis = collections . Counter ( lis ) <NEWLINE> <NL> for i in lis . values ( ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = [ int ( str ( i ) * 3 ) for i in range ( 10 ) ] <NEWLINE> import bisect <NEWLINE> x = bisect . bisect_left ( li , n ) <NEWLINE> print ( li [ x ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> an = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> <NL> dp = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> dp [ 0 ] = 1 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> if m == 0 : <NEWLINE> <INDENT> dp [ 0 ] = 1 <NEWLINE> dp [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % mod <NEWLINE> <DEDENT> print ( dp [ n ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if an [ 0 ] == 1 : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> a = 1 <NEWLINE> if len ( an ) == 1 : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> a = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i == an [ a ] : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> a += 1 <NEWLINE> if a == len ( an ) : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> l_ans = set ( ) <NEWLINE> <NL> count = 1 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if count <= k : <NEWLINE> <INDENT> l_ans . add ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> <NL> <DEDENT> count = 1 <NEWLINE> for i in range ( b , a - 1 , - 1 ) : <NEWLINE> <INDENT> if count <= k : <NEWLINE> <INDENT> l_ans . add ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> <NL> <DEDENT> for num in sorted ( l_ans ) : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT>
import collections <NEWLINE> s = input ( ) <NEWLINE> <NL> <NL> cnt = collections . Counter ( s ) <NEWLINE> used = set ( cnt . keys ( ) ) <NEWLINE> c = - 1 <NEWLINE> if len ( used ) < 26 : <NEWLINE> <INDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> if not chr ( i + ord ( <STRING> ) ) in used : <NEWLINE> <INDENT> c = chr ( i + ord ( <STRING> ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if c != - 1 : <NEWLINE> <INDENT> print ( s + c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> i = 25 <NEWLINE> while i > 1 and s [ i - 1 ] > s [ i ] : <NEWLINE> <INDENT> i -= 1 <NEWLINE> <DEDENT> lused = sorted ( s [ i - 1 : ] ) <NEWLINE> print ( s [ : i - 1 ] + lused [ lused . index ( s [ i - 1 ] ) + 1 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> N , P = map ( int , input ( ) . split ( ) ) <NEWLINE> x = math . floor ( math . pow ( P , 1 / N ) ) <NEWLINE> if x == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> x += 1 <NEWLINE> for i in range ( x , 0 , - 1 ) : <NEWLINE> <INDENT> if P % pow ( i , N ) == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> INF = 10 ** 9 <NEWLINE> d = [ [ INF ] * 3 for i in range ( n ) ] <NEWLINE> to = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> u , v = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> to [ u ] . append ( v ) <NEWLINE> <DEDENT> s , t = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> d [ s ] [ 0 ] = 0 <NEWLINE> cnt = 0 <NEWLINE> q = deque ( [ ( s , cnt ) ] ) <NEWLINE> while q : <NEWLINE> <INDENT> u , c = q . popleft ( ) <NEWLINE> for v in to [ u ] : <NEWLINE> <INDENT> nc = ( c + 1 ) % 3 <NEWLINE> if d [ v ] [ nc ] != INF : continue ; <NEWLINE> d [ v ] [ nc ] = d [ u ] [ c ] + 1 <NEWLINE> q . append ( ( v , nc ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = d [ t ] [ 0 ] <NEWLINE> print ( ans // 3 if ans != INF else - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import collections <NEWLINE> <NL> <COMMENT> <NL> n , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> b = [ None ] * m <NEWLINE> c = [ None ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> _b , _c = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> b [ i ] = _b <NEWLINE> c [ i ] = _c <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> cnt = collections . Counter ( a ) <NEWLINE> <NL> <COMMENT> <NL> for j in range ( m ) : <NEWLINE> <INDENT> cnt . update ( { c [ j ] : b [ j ] } ) <NEWLINE> <NL> <DEDENT> a_tup = cnt . items ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> res = 0 <NEWLINE> num_cnt = 0 <NEWLINE> for _ in sorted ( a_tup , reverse = True ) : <NEWLINE> <INDENT> res += _ [ 0 ] * _ [ 1 ] <NEWLINE> num_cnt += _ [ 1 ] <NEWLINE> <NL> if num_cnt >= n : <NEWLINE> <INDENT> res -= _ [ 0 ] * ( num_cnt - n ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 0 <NEWLINE> flagWhile = True <NEWLINE> flagManip = True <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> while List [ i ] % 2 == 0 : <NEWLINE> <INDENT> List [ i ] = List [ i ] // 2 <NEWLINE> res += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> a = bisect . bisect_left ( A , b ) <NEWLINE> c = bisect . bisect_right ( C , b ) <NEWLINE> ans += a * ( N - c ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans = i * ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> a = make_divisors ( i ) <NEWLINE> <COMMENT> <NL> d_count = len ( a ) <NEWLINE> <COMMENT> <NL> if d_count == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> t = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( 1 if s [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> print ( t [ lr [ i ] [ 1 ] - 1 ] - t [ lr [ i ] [ 0 ] - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) ; MOD = pow ( 10 , 9 ) + 7 <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> G [ a ] . append ( b ) ; G [ b ] . append ( a ) <NEWLINE> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> def dfs ( v , p ) : <COMMENT> <NEWLINE> <INDENT> global ans <COMMENT> <NEWLINE> res = 1 <COMMENT> <NEWLINE> ts = [ ] <COMMENT> <NEWLINE> for u in G [ v ] : <NEWLINE> <INDENT> if u == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> t = dfs ( u , v ) <COMMENT> <NEWLINE> res += t <NEWLINE> ts . append ( t ) <NEWLINE> <DEDENT> if p != - 1 : <COMMENT> <NEWLINE> <INDENT> ts . append ( N - res ) <NEWLINE> <DEDENT> now = pow ( 2 , N - 1 , MOD ) - 1 <COMMENT> <NEWLINE> for x in ts : <NEWLINE> <INDENT> now -= pow ( 2 , x , MOD ) - 1 <COMMENT> <NEWLINE> <DEDENT> ans = ( ans + now ) % MOD <NEWLINE> return res <COMMENT> <NEWLINE> <NL> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> ALL = pow ( 2 , N , MOD ) <NEWLINE> <COMMENT> <NL> ans = ans * pow ( ALL , MOD - 2 , MOD ) % MOD <COMMENT> <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( s ) - 1 for s in input ( ) . split ( ) ] <NEWLINE> <NL> result = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] != ( i - result ) : <NEWLINE> <INDENT> result += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if result == N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = sorted ( [ a - i for i , a in enumerate ( l , start = 1 ) ] ) <NEWLINE> b1 , b2 = m [ n // 2 ] , m [ n // 2 - 1 ] <NEWLINE> print ( min ( sum ( [ abs ( a - b1 ) for a in m ] ) , sum ( [ abs ( a - b2 ) for a in m ] ) ) ) <NEWLINE>
import math <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> <NL> prm_dict = { i : True for i in range ( 2 , 100004 ) } <NEWLINE> for n in range ( 2 , 100004 ) : <NEWLINE> <INDENT> if prm_dict [ n ] : <NEWLINE> <INDENT> if n >= x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for nk in range ( n * 2 , 100004 , n ) : <NEWLINE> <INDENT> prm_dict [ nk ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
N , * D = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> S = sorted ( D , reverse = True ) <NEWLINE> if S [ 1 ] == S [ 0 ] : <NEWLINE> <INDENT> [ print ( S [ 0 ] ) for i in range ( N ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> import numpy as np <NEWLINE> max_i = np . arange ( N ) [ np . array ( D ) == S [ 0 ] ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i == max_i : <NEWLINE> <INDENT> print ( S [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from collections import Counter as C <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = C ( [ input ( ) for _ in range ( n ) ] ) <NEWLINE> <NL> print ( sum ( [ 1 for v in a . values ( ) if v % 2 ] ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> memo = [ - 1 for i in range ( n ) ] <NEWLINE> <NL> def dp ( i ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif i >= 2 : <NEWLINE> <INDENT> if memo [ i ] != - 1 : <NEWLINE> <INDENT> return memo [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memo [ i ] = min ( dp ( i - 2 ) + abs ( h [ i ] - h [ i - 2 ] ) , dp ( i - 1 ) + abs ( h [ i ] - h [ i - 1 ] ) ) <NEWLINE> return memo [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp ( n - 1 ) ) <NEWLINE>
def eratosthenes ( n ) : <NEWLINE> <INDENT> is_prime = [ True for i in range ( n + 1 ) ] <NEWLINE> is_prime [ 0 ] , is_prime [ 1 ] = False , False <NEWLINE> prime = [ ] <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if is_prime [ i ] : <NEWLINE> <INDENT> prime . append ( i ) <NEWLINE> for j in range ( 2 * i , n + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return prime <NEWLINE> <NL> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> N = 10 ** 5 <NEWLINE> <NL> prime = eratosthenes ( N ) <NEWLINE> prime_num = [ 0 for i in range ( N + 1 ) ] <NEWLINE> for p in prime : <NEWLINE> <INDENT> prime_num [ p ] = 1 <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> ans = [ 0 for i in range ( N + 1 ) ] <NEWLINE> for i in range ( 1 , N + 1 , 2 ) : <NEWLINE> <INDENT> if prime_num [ i ] == 1 and prime_num [ ( i + 1 ) // 2 ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> ans [ i ] = count <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ans [ r ] - ans [ l - 2 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> <NL> def digit ( N ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> while N >= 1 : <NEWLINE> <INDENT> N /= 10 <NEWLINE> d += 1 <NEWLINE> <DEDENT> return d <NEWLINE> <NL> <NL> <DEDENT> f = [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= N : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> d1 = digit ( i ) <NEWLINE> d2 = digit ( int ( N / i ) ) <NEWLINE> f . append ( max ( d1 , d2 ) ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( min ( f ) ) <NEWLINE>
import os , sys , re , math <NEWLINE> <NL> <NL> ( H , W ) = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> def set_moves ( x , y , moves ) : <NEWLINE> <INDENT> if S [ y + 1 ] [ x + 1 ] != <STRING> : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if 0 <= grid [ y ] [ x ] < moves : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> grid [ y ] [ x ] = moves <NEWLINE> set_moves ( x , y - 1 , moves + 1 ) <NEWLINE> set_moves ( x , y + 1 , moves + 1 ) <NEWLINE> set_moves ( x - 1 , y , moves + 1 ) <NEWLINE> set_moves ( x + 1 , y , moves + 1 ) <NEWLINE> <NL> <NL> <DEDENT> S = [ ] <NEWLINE> S . append ( <STRING> * ( W + 2 ) ) <NEWLINE> has_wall = False <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> has_wall |= <STRING> in s <NEWLINE> S . append ( <STRING> + s + <STRING> ) <NEWLINE> <DEDENT> S . append ( <STRING> * ( W + 2 ) ) <NEWLINE> <NL> if not has_wall : <NEWLINE> <INDENT> result = W + H - 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = 0 <NEWLINE> for gy in range ( H ) : <NEWLINE> <INDENT> for gx in range ( W ) : <NEWLINE> <INDENT> if S [ gy + 1 ] [ gx + 1 ] != <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> grid = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> grid . append ( [ - 1 ] * W ) <NEWLINE> <DEDENT> set_moves ( gx , gy , 0 ) <NEWLINE> <NL> result = max ( result , max ( [ max ( row ) for row in grid ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = 1 <NEWLINE> <NL> c = collections . Counter ( a ) <NEWLINE> <NL> for x in range ( max ( a ) + 2 ) : <NEWLINE> <INDENT> d = c [ x ] + c [ x - 1 ] + c [ x + 1 ] <NEWLINE> if d >= M : <NEWLINE> <INDENT> M = d <NEWLINE> <NL> <DEDENT> <DEDENT> print ( M ) <NEWLINE>
y = [ int ( z ) for z in input ( ) . split ( ) ] <NEWLINE> l = [ int ( z ) for z in input ( ) . split ( ) ] <NEWLINE> d = [ 0 ] * ( y [ 0 ] + 1 ) <NEWLINE> c = 1 <NEWLINE> for i in range ( 1 , y [ 0 ] + 1 ) : <NEWLINE> <INDENT> d [ i ] = d [ i - 1 ] + l [ i - 1 ] <NEWLINE> if ( d [ i ] <= y [ 1 ] ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> min_p = n + 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] < min_p : <NEWLINE> <INDENT> ans += 1 <NEWLINE> min_p = p [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tmp = 0 <NEWLINE> for i in range ( N // 2 ) : <NEWLINE> <INDENT> tmp += A [ 2 * i + 1 ] <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> if sum ( A ) > 2 * tmp : <NEWLINE> <INDENT> ans . append ( sum ( A ) - 2 * tmp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans . append ( 2 * A [ i ] - ans [ - 1 ] ) <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mini = p [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] <= mini : <NEWLINE> <INDENT> ans += 1 <NEWLINE> mini = min ( p [ i ] , mini ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from math import floor , ceil , sqrt , factorial , log , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from collections import Counter , defaultdict <NEWLINE> from heapq import heappop , heappush , heappushpop , heapify <NEWLINE> import copy <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def lcm ( a , b ) : return a * b / gcd ( a , b ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = LI ( ) <NEWLINE> a = sorted ( list ( LI ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> bc = LIR ( m ) <NEWLINE> bc . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> d = [ ] <NEWLINE> i = 0 <NEWLINE> while len ( d ) < n and i < len ( bc ) : <NEWLINE> <INDENT> if bc [ i ] [ 0 ] + len ( d ) < n : <NEWLINE> <INDENT> d . extend ( [ bc [ i ] [ 1 ] ] * bc [ i ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . extend ( [ bc [ i ] [ 1 ] ] * ( n - len ( d ) ) ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> for i in range ( len ( d ) ) : <NEWLINE> <INDENT> if d [ i ] < a [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a [ i ] = d [ i ] <NEWLINE> <DEDENT> print ( sum ( a ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_lst = input ( ) . split ( ) <NEWLINE> odd = [ a for i , a in enumerate ( a_lst ) if i % 2 != 0 ] <NEWLINE> even = [ a for i , a in enumerate ( a_lst ) if i % 2 == 0 ] <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> b = list ( reversed ( odd ) ) + even <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = list ( reversed ( even ) ) + odd <NEWLINE> <DEDENT> print ( <STRING> . join ( b ) ) <NEWLINE>
from bisect import bisect_left <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = [ [ ] for _ in range ( n ) ] <NEWLINE> city = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p , y = map ( int , input ( ) . split ( ) ) <NEWLINE> city . append ( [ p , y ] ) <NEWLINE> l [ p - 1 ] . append ( y ) <NEWLINE> <NL> <DEDENT> for i in l : i . sort ( ) <NEWLINE> for i in city : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> ans += <STRING> * ( 6 - len ( str ( i [ 0 ] ) ) ) + str ( i [ 0 ] ) <NEWLINE> t = str ( bisect_left ( l [ i [ 0 ] - 1 ] , i [ 1 ] ) + 1 ) <NEWLINE> ans += <STRING> * ( 6 - len ( t ) ) + t <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if n * a < b : <NEWLINE> <INDENT> print ( n * a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max_cnt = 0 <NEWLINE> <NL> c = collections . Counter ( a_list ) <NEWLINE> <NL> for i in range ( max ( c . keys ( ) ) + 1 ) : <NEWLINE> <INDENT> cnt = c [ i ] + c [ i + 1 ] + c [ i + 2 ] <NEWLINE> <NL> if max_cnt < cnt : <NEWLINE> <INDENT> max_cnt = cnt <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_cnt ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> from collections import defaultdict <NEWLINE> def main ( ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> k -= 1 <NEWLINE> <NL> d1 = defaultdict ( list ) <NEWLINE> for i , c in enumerate ( s ) : <NEWLINE> <INDENT> d1 [ c ] . append ( i ) <NEWLINE> <DEDENT> d2 = sorted ( d1 . items ( ) ) <NEWLINE> <NL> lens = len ( s ) <NEWLINE> for d2e in d2 : <NEWLINE> <INDENT> subs = set ( ) <NEWLINE> subs . add ( d2e [ 0 ] ) <NEWLINE> for d2ee in d2e [ 1 ] : <NEWLINE> <INDENT> end = min ( lens + 1 , d2ee + k + 2 ) <NEWLINE> for i1 in range ( d2ee + 1 , end ) : <NEWLINE> <INDENT> subs . add ( <STRING> . join ( s [ d2ee : i1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> if len ( subs ) > k : <NEWLINE> <INDENT> subsl = list ( subs ) <NEWLINE> subsl . sort ( ) <NEWLINE> print ( subsl [ k ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= len ( subs ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
sx , sy , tx , ty = map ( int , input ( ) . split ( ) ) <NEWLINE> dy = ty - sy <NEWLINE> dx = tx - sx <NEWLINE> ans = dy * <STRING> + dx * <STRING> + dy * <STRING> + dx * <STRING> <NEWLINE> ans += <STRING> + ( dy + 1 ) * <STRING> + ( dx + 1 ) * <STRING> + <STRING> <NEWLINE> ans += <STRING> + ( dy + 1 ) * <STRING> + ( dx + 1 ) * <STRING> + <STRING> <NEWLINE> print ( ans ) <NEWLINE>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( p ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif p == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif n > 60 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> l = [ ] <COMMENT> <NEWLINE> for i in range ( 1 , int ( p ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if p % i == 0 : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> s = [ ] <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> if l [ i ] ** n <= p and p % ( l [ i ] ** n ) == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> s . append ( l [ i ] ) <NEWLINE> <DEDENT> if l [ i ] ** n > p : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( s [ - 1 ] ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> c = Counter ( [ <STRING> . join ( sorted ( input ( ) ) ) for i in range ( n ) ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> for k , cnt in c . items ( ) : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ False ] * n <NEWLINE> t = [ False ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> s [ b - 1 ] = True <NEWLINE> <DEDENT> if b == n : <NEWLINE> <INDENT> t [ a - 1 ] = True <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == True and t [ i ] == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys , math <NEWLINE> from functools import lru_cache <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <DEDENT> def mi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def ii ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def i2 ( n ) : <NEWLINE> <INDENT> tmp = [ list ( mi ( ) ) for i in range ( n ) ] <NEWLINE> return [ list ( i ) for i in zip ( * tmp ) ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = ii ( ) <NEWLINE> D = list ( mi ( ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if D [ 0 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> dic = defaultdict ( int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> dic [ D [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans *= dic [ D [ i ] - 1 ] <NEWLINE> ans %= 998244353 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = X * Y // math . gcd ( X , Y ) - X <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> c = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> b = list ( input ( ) ) <NEWLINE> a += b <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b = list ( input ( ) ) <NEWLINE> c += b <NEWLINE> <COMMENT> <NL> <DEDENT> f = False <NEWLINE> for i in range ( N * N ) : <NEWLINE> <INDENT> if f == True : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if N * N - i < M * M : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if M > 1 and i // N == N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count = 0 <NEWLINE> flag = True <NEWLINE> <COMMENT> <NL> if c [ 0 ] == a [ i ] : <NEWLINE> <INDENT> if N - ( ( i ) % N ) < M : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> num = i <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> for k in range ( M ) : <NEWLINE> <COMMENT> <NL> <INDENT> if c [ count ] == a [ num ] : <NEWLINE> <NL> <INDENT> num += 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> elif c [ count ] != a [ num ] : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> num += N - M <NEWLINE> if flag == False : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <DEDENT> if j == M - 1 : <NEWLINE> <INDENT> f = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if f == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> a = set ( [ ] ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> a . add ( s [ i : i + j ] ) <NEWLINE> <DEDENT> <DEDENT> a = sorted ( a ) <NEWLINE> print ( a [ k - 1 ] ) <NEWLINE>
import copy <NEWLINE> S_dash = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> len_S = len ( S_dash ) <NEWLINE> len_T = len ( T ) <NEWLINE> <NL> candidate0 = list ( S_dash ) <NEWLINE> <NL> <NL> ans = <STRING> * 51 <NEWLINE> <NL> if len_S >= len_T : <NEWLINE> <INDENT> for s in range ( len_S ) : <NEWLINE> <INDENT> cha_S = S_dash [ s ] <NEWLINE> if cha_S != <STRING> and cha_S in list ( T ) : <NEWLINE> <INDENT> for t in range ( len_T ) : <NEWLINE> <INDENT> cha_T = T [ t ] <NEWLINE> if cha_S == cha_T and 0 <= s - t < len_S and 0 < s - t + len_T <= len_S : <NEWLINE> <INDENT> S_cut = S_dash [ s - t : s - t + len_T ] <NEWLINE> candidate1 = copy . deepcopy ( candidate0 ) <NEWLINE> for x in range ( len_T ) : <NEWLINE> <INDENT> if S_cut [ x ] == <STRING> : <NEWLINE> <INDENT> candidate1 [ s - t + x ] = T [ x ] <NEWLINE> <DEDENT> elif S_cut [ x ] != T [ x ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if <STRING> . join ( candidate1 [ s - t : s - t + len_T ] ) == T : <NEWLINE> <INDENT> if ans > <STRING> . join ( candidate1 ) . replace ( <STRING> , <STRING> ) : <NEWLINE> <INDENT> ans = <STRING> . join ( candidate1 ) . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for u in range ( len_S - len_T + 1 ) : <NEWLINE> <INDENT> cut_S = S_dash [ u : u + len_T ] <NEWLINE> if cut_S . count ( <STRING> ) == len_T : <NEWLINE> <INDENT> candidate1 = copy . deepcopy ( candidate0 ) <NEWLINE> for t in range ( len_T ) : <NEWLINE> <INDENT> candidate1 [ u + t ] = T [ t ] <NEWLINE> <DEDENT> if ans > <STRING> . join ( candidate1 ) . replace ( <STRING> , <STRING> ) : <NEWLINE> <INDENT> ans = <STRING> . join ( candidate1 ) . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ans == <STRING> * 51 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> taka = a <NEWLINE> aoki = b <NEWLINE> recur = k <NEWLINE> if taka >= k : <NEWLINE> <INDENT> print ( <STRING> . format ( taka - k , aoki ) ) <NEWLINE> <DEDENT> elif k >= taka and ( aoki + taka ) >= k : <NEWLINE> <INDENT> print ( <STRING> . format ( 0 , aoki - ( k - taka ) ) ) <NEWLINE> <DEDENT> elif ( aoki + taka ) <= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> result = 2018 <NEWLINE> if R - L >= 2019 : <NEWLINE> <INDENT> result = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( L , R ) : <NEWLINE> <INDENT> for j in range ( L + 1 , R + 1 ) : <NEWLINE> <INDENT> result = min ( result , i * j % 2019 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n , k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if s < 10 ** 9 : <NEWLINE> <NL> <INDENT> if k > 0 : <NEWLINE> <INDENT> aa = [ s ] * k + [ s + 1 ] * ( n - k ) <NEWLINE> <DEDENT> elif k == 0 : <NEWLINE> <INDENT> aa = [ s + 1 ] * n <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> aa = [ s ] * k + [ 1 ] * ( n - k ) <NEWLINE> <NL> <DEDENT> print ( * aa ) <NEWLINE>
from math import fabs <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= 0 and 0 <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( fabs ( b - a ) + 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from bisect import bisect_left as BL <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> def isok ( border ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> res += N - BL ( A , border - A [ i ] ) <NEWLINE> <DEDENT> return res >= M <NEWLINE> <NL> <NL> <DEDENT> ok = 0 <NEWLINE> ng = A [ - 1 ] * 2 + 1 <NEWLINE> mid = ( ok + ng ) // 2 <NEWLINE> <NL> <COMMENT> <NL> while abs ( ok - ng ) > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if isok ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <DEDENT> <DEDENT> B = reversed ( A ) <NEWLINE> SB = [ 0 ] <NEWLINE> for b in B : <NEWLINE> <INDENT> SB . append ( b + SB [ - 1 ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> shake_c = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> goodshake = N - BL ( A , ok - A [ i ] ) <NEWLINE> shake_c += goodshake <NEWLINE> ans += A [ i ] * goodshake <NEWLINE> ans += SB [ goodshake ] <NEWLINE> <DEDENT> ans -= ( shake_c - M ) * ok <NEWLINE> print ( ans ) <NEWLINE>
T , A , K = map ( int , input ( ) . split ( ) ) <NEWLINE> sta = T + A - K <NEWLINE> if sta <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif sta >= A : <NEWLINE> <INDENT> print ( str ( T - K ) + <STRING> + str ( A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + str ( sta ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( * A [ : : - 2 ] , * A [ N % 2 : : 2 ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <COMMENT> <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> multip_K = [ i for i in range ( K , N + 1 , K ) ] <NEWLINE> <NL> <COMMENT> <NL> le = len ( multip_K ) <NEWLINE> ans_mod_0 = le ** 3 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> ans_mod_haf = 0 <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> multip_haf = [ i for i in range ( 1 , N + 1 ) if i % K == K // 2 ] <NEWLINE> le_haf = len ( multip_haf ) <NEWLINE> ans_mod_haf = le_haf ** 3 <NEWLINE> <NL> <DEDENT> ans = ans_mod_0 + ans_mod_haf <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K , Q , * A = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> B = [ 0 ] * N <NEWLINE> for a in A : <NEWLINE> <INDENT> B [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * N <NEWLINE> for i , b in enumerate ( B ) : <NEWLINE> <INDENT> if Q >= K + b : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> AB = sorted ( AB ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> K -= AB [ i ] [ 1 ] <NEWLINE> if K <= 0 : <NEWLINE> <INDENT> print ( AB [ i ] [ 0 ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab [ a - 1 ] . append ( b - 1 ) <NEWLINE> ab [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> add = [ 0 ] * n <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> pp , xx = map ( int , input ( ) . split ( ) ) <NEWLINE> add [ pp - 1 ] += xx <NEWLINE> <NL> <NL> <DEDENT> def dfs ( v , p , value ) : <NEWLINE> <INDENT> value += add [ v ] <NEWLINE> ans [ v ] = value <NEWLINE> for c in ab [ v ] : <NEWLINE> <INDENT> if c == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( c , v , value ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = [ 0 ] * n <NEWLINE> dfs ( 0 , - 1 , 0 ) <NEWLINE> print ( * ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> l , r = N // 2 - 1 , N // 2 <NEWLINE> sort_x = sorted ( X ) <NEWLINE> lx , rx = sort_x [ l ] , sort_x [ r ] <NEWLINE> <NL> if lx == rx : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( lx ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for ind in range ( N ) : <NEWLINE> <INDENT> target = X [ ind ] <NEWLINE> if target <= lx : <NEWLINE> <INDENT> print ( rx ) <NEWLINE> <DEDENT> if target >= rx : <NEWLINE> <INDENT> print ( lx ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> MOD = 1_000_000_007 <NEWLINE> def dot_MOD ( x1 , x2 , MOD ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = np . zeros ( ( x1 . shape [ 1 ] , x2 . shape [ 0 ] ) , dtype = <STRING> ) <NEWLINE> for i in range ( x1 . shape [ 0 ] ) : <NEWLINE> <INDENT> for j in range ( x2 . shape [ 1 ] ) : <NEWLINE> <INDENT> ret [ i ] [ j ] = np . mod ( x1 [ i , : ] * ( x2 [ : , j ] [ np . newaxis : ] ) , MOD , dtype = <STRING> ) . sum ( ) <NEWLINE> <DEDENT> <DEDENT> ret %= MOD <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> def x2_MOD ( x , MOD ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = np . empty ( x . shape , dtype = <STRING> ) <NEWLINE> for i in range ( x . shape [ 0 ] ) : <NEWLINE> <INDENT> for j in range ( x . shape [ 0 ] ) : <NEWLINE> <INDENT> ret [ i ] [ j ] = np . mod ( x [ i , : ] * ( x [ : , j ] [ np . newaxis : ] ) , MOD , dtype = <STRING> ) . sum ( ) <NEWLINE> <DEDENT> <DEDENT> ret %= MOD <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( list ( map ( int , read ( ) . split ( ) ) ) , dtype = <STRING> ) . reshape ( ( N , N ) ) <NEWLINE> ans = np . eye ( N , dtype = <STRING> ) <NEWLINE> while K : <NEWLINE> <INDENT> if K & 1 : <NEWLINE> <INDENT> ans = dot_MOD ( ans , A , MOD ) <NEWLINE> <DEDENT> A = x2_MOD ( A , MOD ) <NEWLINE> K >>= 1 <NEWLINE> <DEDENT> print ( np . mod ( ans . sum ( ) , MOD , dtype = <STRING> ) ) <NEWLINE>
<COMMENT> <NL> N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ K - Q ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> A [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> if a < 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for X in range ( K + 1 ) : <NEWLINE> <INDENT> for Y in range ( K + 1 ) : <NEWLINE> <INDENT> Z = S - X - Y <NEWLINE> if 0 <= Z <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> power = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> power *= i <NEWLINE> power %= mod <NEWLINE> <DEDENT> print ( power ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = 0 <NEWLINE> im = 0 <NEWLINE> for i , ai in enumerate ( a ) : <NEWLINE> <INDENT> if abs ( ai ) >= abs ( m ) : <NEWLINE> <INDENT> m = ai <NEWLINE> im = i <NEWLINE> <DEDENT> <DEDENT> print ( 2 * n - 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( im + 1 , i + 1 ) <NEWLINE> <NL> <DEDENT> if m > 0 : <NEWLINE> <INDENT> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> print ( i + 1 , i + 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in reversed ( range ( 1 , n ) ) : <NEWLINE> <INDENT> print ( i + 1 , i ) <NEWLINE> <NL> <DEDENT> <DEDENT>
from sys import setrecursionlimit <NEWLINE> <NL> setrecursionlimit ( 1000000 ) <NEWLINE> <NL> H = int ( input ( ) ) <NEWLINE> <NL> <NL> def f ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 + f ( n // 2 ) * 2 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( f ( H ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> minus_cnt = 0 <NEWLINE> abs_sum = 0 <NEWLINE> min_abs_val = 1000000000 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> abs_val = abs ( A [ i ] ) <NEWLINE> abs_sum = abs_sum + abs_val <NEWLINE> if abs_val < min_abs_val : <NEWLINE> <INDENT> min_abs_val = abs_val <NEWLINE> <DEDENT> if A [ i ] < 0 : <NEWLINE> <INDENT> minus_cnt = minus_cnt + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> B_max_sum = 0 <NEWLINE> if ( minus_cnt % 2 == 0 ) or ( min_abs_val == 0 ) : <NEWLINE> <INDENT> B_max_sum = abs_sum <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B_max_sum = abs_sum - min_abs_val * 2 <NEWLINE> <NL> <DEDENT> print ( B_max_sum ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if m == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> X . sort ( ) <NEWLINE> D = [ ] <NEWLINE> for i in range ( 1 , m ) : <NEWLINE> <INDENT> D . append ( X [ i ] - X [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> D . sort ( reverse = True ) <NEWLINE> d = 0 <NEWLINE> if i > 1 : <NEWLINE> <INDENT> for i in range ( min ( n - 1 , m - 1 ) ) : <NEWLINE> <INDENT> d += D [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = sum ( D ) - d <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> power = math . factorial ( n ) <NEWLINE> print ( power % ( 10 ** 9 + 7 ) ) <NEWLINE>
import sys <NEWLINE> from functools import lru_cache <NEWLINE> <NL> <NL> sys . setrecursionlimit ( 500000 ) <NEWLINE> <NL> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def rec ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> res = n <NEWLINE> i = 1 <NEWLINE> while i <= n : <NEWLINE> <INDENT> res = min ( res , rec ( n - i ) + 1 ) <NEWLINE> i *= 6 <NEWLINE> <DEDENT> i = 9 <NEWLINE> while i <= n : <NEWLINE> <INDENT> res = min ( res , rec ( n - i ) + 1 ) <NEWLINE> i *= 9 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> print ( rec ( N ) ) <NEWLINE> <NL> <NL>
r , g , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 0 , n + 1 , r ) : <NEWLINE> <INDENT> for j in range ( 0 , n + 1 - i , g ) : <NEWLINE> <INDENT> if ( n - i - j ) % b == 0 and ( n - i - j ) % b >= 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - ( i + j ) <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( int ( input ( ) ) for _ in range ( N ) ) <NEWLINE> <NL> S = [ A [ 0 ] ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if A [ i ] <= S [ 0 ] : <NEWLINE> <INDENT> S . insert ( 0 , A [ i ] ) <NEWLINE> continue <NEWLINE> <DEDENT> ok = 0 <NEWLINE> ng = len ( S ) <NEWLINE> tmp = ( ok + ng ) <NEWLINE> while ok + 1 < ng : <NEWLINE> <INDENT> tmp = ( ok + ng ) // 2 <NEWLINE> if A [ i ] > S [ tmp ] : <NEWLINE> <INDENT> ok = tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = tmp <NEWLINE> <DEDENT> <DEDENT> S [ ok ] = A [ i ] <NEWLINE> <DEDENT> print ( len ( S ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for N in range ( 1000 ) : <NEWLINE> <INDENT> tgt = str ( N ) . zfill ( 3 ) <NEWLINE> if tgt [ 0 ] in s : <NEWLINE> <INDENT> i = s . index ( tgt [ 0 ] ) <NEWLINE> if tgt [ 1 ] in s [ i + 1 : ] : <NEWLINE> <INDENT> j = s [ i + 1 : ] . index ( tgt [ 1 ] ) + i <NEWLINE> if tgt [ 2 ] in s [ j + 2 : ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> AB = [ ] <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> AB . append ( ( a , b ) ) <NEWLINE> <NL> <DEDENT> root = 1 <NEWLINE> parent = [ 0 ] * ( N + 1 ) <NEWLINE> order = [ ] <NEWLINE> stack = [ root ] <NEWLINE> <NL> while stack : <NEWLINE> <INDENT> x = stack . pop ( ) <NEWLINE> order . append ( x ) <NEWLINE> for y in graph [ x ] : <NEWLINE> <INDENT> if y == parent [ x ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> parent [ y ] = x <NEWLINE> stack . append ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> color = [ - 1 ] * ( N + 1 ) <NEWLINE> K = - 1 <NEWLINE> for x in order : <NEWLINE> <INDENT> ng = color [ x ] <NEWLINE> c = 1 <NEWLINE> for y in graph [ x ] : <NEWLINE> <INDENT> if y == parent [ x ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if c == ng : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> K = max ( c , K ) <NEWLINE> color [ y ] = c <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> <NL> for a , b in AB : <NEWLINE> <INDENT> if parent [ a ] == b : <NEWLINE> <INDENT> ans . append ( color [ a ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( color [ b ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( K ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def main0 ( n , g , xyuv ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> depth = [ 0 ] * n <NEWLINE> tour = [ ] <NEWLINE> hatsu = [ 0 ] * n <NEWLINE> dist = [ 0 ] * n <NEWLINE> tmp = 0 <NEWLINE> def et ( p , v , tour , tmp , pc , pd ) : <NEWLINE> <INDENT> hatsu [ v ] = len ( tour ) - 1 <NEWLINE> for nv , c , d in g [ v ] : <NEWLINE> <INDENT> if nv == p : continue <NEWLINE> depth [ nv ] = depth [ v ] + 1 <NEWLINE> tmp += d <NEWLINE> dist [ nv ] = tmp <NEWLINE> tour . append ( ( nv , c , d ) ) <NEWLINE> tour = et ( v , nv , tour , tmp , c , d ) <NEWLINE> tmp -= d <NEWLINE> tour . append ( ( v , c , - d ) ) <NEWLINE> <DEDENT> return tour <NEWLINE> <DEDENT> tour . append ( ( 0 , 0 , 0 ) ) <NEWLINE> tour = et ( - 1 , 0 , tour , 0 , 0 , 0 ) <NEWLINE> class SegmentTree ( ) : <NEWLINE> <INDENT> def __init__ ( self , size , f = lambda x , y : x + y , default = 0 ) : <NEWLINE> <INDENT> self . size = pow ( 2 , ( size - 1 ) . bit_length ( ) ) <NEWLINE> self . f = f <NEWLINE> self . default = default <NEWLINE> self . data = [ default ] * ( self . size * 2 ) <NEWLINE> <DEDENT> def update ( self , i , x ) : <NEWLINE> <INDENT> i += self . size <NEWLINE> self . data [ i ] = x <NEWLINE> while i : <NEWLINE> <INDENT> i >>= 1 <NEWLINE> self . data [ i ] = self . f ( self . data [ i * 2 ] , self . data [ i * 2 + 1 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> def query ( self , l , r ) : <NEWLINE> <INDENT> l , r = l + self . size , r + self . size <NEWLINE> lret , rret = self . default , self . default <NEWLINE> while l < r : <NEWLINE> <INDENT> if l & 1 : <NEWLINE> <INDENT> lret = self . f ( self . data [ l ] , lret ) <NEWLINE> l += 1 <NEWLINE> <DEDENT> if r & 1 : <NEWLINE> <INDENT> r -= 1 <NEWLINE> rret = self . f ( self . data [ r ] , rret ) <NEWLINE> <DEDENT> l >>= 1 <NEWLINE> r >>= 1 <NEWLINE> <DEDENT> return self . f ( lret , rret ) <NEWLINE> <NL> <DEDENT> <DEDENT> def func ( x , y ) : <NEWLINE> <INDENT> if x [ 0 ] < y [ 0 ] : return x <NEWLINE> return y <NEWLINE> <DEDENT> st = SegmentTree ( len ( tour ) , func , ( n + 1 , 0 ) ) <NEWLINE> for i , x in enumerate ( tour ) : <NEWLINE> <INDENT> v = x [ 0 ] <NEWLINE> st . update ( i , ( depth [ v ] , v ) ) <NEWLINE> <DEDENT> def lca ( u , v ) : <NEWLINE> <INDENT> x , y = hatsu [ u ] , hatsu [ v ] <NEWLINE> if x < y : <NEWLINE> <INDENT> y += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> y += 1 <NEWLINE> <DEDENT> return st . query ( x , y ) [ 1 ] <NEWLINE> <DEDENT> dc = { } <NEWLINE> dcary = { } <NEWLINE> for i , ( v , c , d ) in enumerate ( tour ) : <NEWLINE> <INDENT> if c in dc : <NEWLINE> <INDENT> ci = 1 if d > 0 else - 1 <NEWLINE> dc [ c ] . append ( ( dc [ c ] [ - 1 ] [ 0 ] + ci , dc [ c ] [ - 1 ] [ 1 ] + d ) ) <NEWLINE> dcary [ c ] . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dc [ c ] = [ ( 0 , 0 ) , ( 1 , d ) ] <NEWLINE> dcary [ c ] = [ 0 , i ] <NEWLINE> <DEDENT> <DEDENT> ret = [ ] <NEWLINE> from bisect import bisect_right as bl <NEWLINE> for x , y , u , v in xyuv : <NEWLINE> <INDENT> u , v = u - 1 , v - 1 <NEWLINE> w = lca ( u , v ) <NEWLINE> uvlen = dist [ u ] + dist [ v ] - dist [ w ] * 2 <NEWLINE> if x not in dc : <NEWLINE> <INDENT> ret . append ( uvlen ) <NEWLINE> continue <NEWLINE> <DEDENT> widx = bl ( dcary [ x ] , hatsu [ w ] ) - 1 <NEWLINE> wnum , wsum = dc [ x ] [ widx ] <NEWLINE> uidx = bl ( dcary [ x ] , hatsu [ u ] ) - 1 <NEWLINE> vidx = bl ( dcary [ x ] , hatsu [ v ] ) - 1 <NEWLINE> unum , usum = dc [ x ] [ uidx ] <NEWLINE> vnum , vsum = dc [ x ] [ vidx ] <NEWLINE> uvsum = usum + vsum - wsum * 2 <NEWLINE> uvnum = unum + vnum - wnum * 2 <NEWLINE> <COMMENT> <NL> ret . append ( uvlen - uvsum + uvnum * y ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> xyuv = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for a , b , c , d in abcd : <NEWLINE> <INDENT> a , b = a - 1 , b - 1 <NEWLINE> g [ a ] . append ( ( b , c , d ) ) <NEWLINE> g [ b ] . append ( ( a , c , d ) ) <NEWLINE> <DEDENT> ary0 = main0 ( n , g , xyuv ) <NEWLINE> print ( * ary0 , sep = <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> x_sort = sorted ( x ) <NEWLINE> a = x_sort [ 1 : n ] <NEWLINE> a_med = a [ n // 2 - 1 ] <NEWLINE> b = x_sort [ 0 : n - 1 ] <NEWLINE> b_med = b [ n // 2 - 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] < a_med : <NEWLINE> <INDENT> ans [ i ] = a_med <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = b_med <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> HW = [ 0 ] * H <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> HW [ i ] = str ( input ( ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> visited = [ [ 0 ] * W for i in range ( H ) ] <NEWLINE> def bfs ( x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> if visited [ x ] [ y ] == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> visited [ x ] [ y ] = 1 <NEWLINE> <NL> if HW [ x ] [ y ] == <STRING> : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> queue = [ [ 0 , 1 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ - 1 , 0 ] ] <NEWLINE> tt = 0 <NEWLINE> for i , j in queue : <NEWLINE> <INDENT> if ( 0 <= x + i < H ) and ( 0 <= y + j < W ) : <NEWLINE> <INDENT> if HW [ x + i ] [ y + j ] == <STRING> : <NEWLINE> <INDENT> tt = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if tt == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <COMMENT> <NL> <INDENT> st = bfs ( i , j ) <NEWLINE> <COMMENT> <NL> if st == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL>
<COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( 5 ) ] <NEWLINE> ans = math . ceil ( n / min ( a ) ) + 4 <NEWLINE> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def bfs ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> ls = deque ( [ ] ) <NEWLINE> D = [ [ True ] * ( W + 2 ) ] <NEWLINE> D += ( [ [ True ] + [ False ] * W + [ True ] for i in range ( H ) ] ) <NEWLINE> D . append ( [ True ] * ( W + 2 ) ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> if line [ j ] == <STRING> : <NEWLINE> <INDENT> ls . append ( [ i + 1 , j + 1 , 0 ] ) <NEWLINE> D [ i + 1 ] [ j + 1 ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while len ( ls ) > 0 : <NEWLINE> <INDENT> h , w , depth = ls . popleft ( ) <NEWLINE> if not D [ h + 1 ] [ w ] : <NEWLINE> <INDENT> ls . append ( [ h + 1 , w , depth + 1 ] ) <NEWLINE> D [ h + 1 ] [ w ] = True <NEWLINE> <DEDENT> if not D [ h - 1 ] [ w ] : <NEWLINE> <INDENT> ls . append ( [ h - 1 , w , depth + 1 ] ) <NEWLINE> D [ h - 1 ] [ w ] = True <NEWLINE> <DEDENT> if not D [ h ] [ w + 1 ] : <NEWLINE> <INDENT> ls . append ( [ h , w + 1 , depth + 1 ] ) <NEWLINE> D [ h ] [ w + 1 ] = True <NEWLINE> <DEDENT> if not D [ h ] [ w - 1 ] : <NEWLINE> <INDENT> ls . append ( [ h , w - 1 , depth + 1 ] ) <NEWLINE> D [ h ] [ w - 1 ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> return depth <NEWLINE> <NL> <DEDENT> print ( bfs ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H = [ h ] <NEWLINE> ans = 0 <NEWLINE> while len ( H ) > 0 : <NEWLINE> <INDENT> for e in H : <NEWLINE> <INDENT> if len ( e ) == 0 : <NEWLINE> <INDENT> H . remove ( e ) <NEWLINE> <DEDENT> elif 0 in e : <NEWLINE> <INDENT> a = e [ : e . index ( 0 ) ] <NEWLINE> b = e [ e . index ( 0 ) + 1 : ] <NEWLINE> H . append ( a ) <NEWLINE> H . append ( b ) <NEWLINE> H . remove ( e ) <NEWLINE> if [ ] in H : <NEWLINE> <INDENT> H . remove ( [ ] ) <NEWLINE> if len ( H ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += min ( e ) <NEWLINE> c = [ e [ j ] - min ( e ) for j in range ( len ( e ) ) ] <NEWLINE> a = c [ : c . index ( 0 ) ] <NEWLINE> b = c [ c . index ( 0 ) + 1 : ] <NEWLINE> H . append ( a ) <NEWLINE> H . append ( b ) <NEWLINE> H . remove ( e ) <NEWLINE> if [ ] in H : <NEWLINE> <INDENT> H . remove ( [ ] ) <NEWLINE> if len ( H ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if [ ] in H : <NEWLINE> <INDENT> H . remove ( [ ] ) <NEWLINE> if len ( H ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> EPS = 1e-8 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def run ( ) : <NEWLINE> <INDENT> N , * A = map ( int , read ( ) . split ( ) ) <NEWLINE> dic = defaultdict ( lambda : 0 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> dic [ a ] += 1 <NEWLINE> <DEDENT> G = { } <NEWLINE> <NL> for key in sorted ( list ( dic . keys ( ) ) ) : <NEWLINE> <INDENT> G [ N ] = key <NEWLINE> N -= dic [ key ] <NEWLINE> <NL> <DEDENT> criteria = 0 <NEWLINE> for key in G . keys ( ) : <NEWLINE> <INDENT> if G [ key ] % 2 : <NEWLINE> <INDENT> criteria ^= key <NEWLINE> <NL> <DEDENT> <DEDENT> if not criteria : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> M = 0 <NEWLINE> L = deque ( [ 0 ] ) <NEWLINE> R = deque ( [ 0 ] ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> L . append ( math . gcd ( L [ - 1 ] , A [ i - 1 ] ) ) <NEWLINE> R . appendleft ( math . gcd ( R [ 0 ] , A [ N - i ] ) ) <NEWLINE> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> m = math . gcd ( L [ j ] , R [ j + 1 ] ) <NEWLINE> M = max ( M , m ) <NEWLINE> <DEDENT> print ( M ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> j = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> while j < N and S [ i : j ] in S [ j : ] : <NEWLINE> <INDENT> ans = max ( ans , j - i ) <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> if N % 2 == 0 : <NEWLINE> <INDENT> k = N // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = ( N + 1 ) // 2 <NEWLINE> <NL> <DEDENT> cmb = [ ] <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> cmb . append ( [ i , N - i ] ) <NEWLINE> <NL> <DEDENT> def digitSum ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> s = str ( n ) <NEWLINE> <COMMENT> <NL> array = list ( map ( int , s ) ) <NEWLINE> <COMMENT> <NL> return sum ( array ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> X = digitSum ( cmb [ i ] [ 0 ] ) <NEWLINE> Y = digitSum ( cmb [ i ] [ 1 ] ) <NEWLINE> ans . append ( X + Y ) <NEWLINE> <NL> <NL> <DEDENT> if ans == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT>
def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return divisors <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> divisors = make_divisors ( N ) <NEWLINE> ans = 0 <NEWLINE> divisors . sort ( reverse = True ) <NEWLINE> for x in divisors : <NEWLINE> <INDENT> if x > 1 : <NEWLINE> <INDENT> temp = x - 1 <NEWLINE> d , m = divmod ( N , temp ) <NEWLINE> if d != m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += temp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> num = 0 <NEWLINE> num_f = 0 <NEWLINE> qual = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if num < a + b : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> num += 1 <NEWLINE> qual . append ( <STRING> ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> and num_f < b : <NEWLINE> <INDENT> num += 1 <NEWLINE> num_f += 1 <NEWLINE> qual . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> qual . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> qual . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( qual [ i ] ) <NEWLINE> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> S . append ( [ <STRING> for _ in range ( W + 2 ) ] ) <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> s = <STRING> + s + <STRING> <NEWLINE> S . append ( [ ] ) <NEWLINE> for k in range ( W + 2 ) : <NEWLINE> <INDENT> S [ - 1 ] . append ( s [ k ] ) <NEWLINE> <DEDENT> <DEDENT> S . append ( [ <STRING> for _ in range ( W + 2 ) ] ) <NEWLINE> b = 0 <NEWLINE> start = [ ] <NEWLINE> for h in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for w in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if S [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> c = 0 <NEWLINE> b += 1 <NEWLINE> if S [ h + 1 ] [ w ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if S [ h - 1 ] [ w ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if S [ h ] [ w + 1 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if S [ h ] [ w - 1 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if c == 1 : <NEWLINE> <INDENT> start . append ( [ h , w ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if len ( start ) == 0 : <NEWLINE> <INDENT> for h in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for w in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if S [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> c = 0 <NEWLINE> if S [ h + 1 ] [ w ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if S [ h - 1 ] [ w ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if S [ h ] [ w + 1 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if S [ h ] [ w - 1 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if c == 2 : <NEWLINE> <INDENT> start . append ( [ h , w ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <STRING> <NEWLINE> <COMMENT> <NL> def solve ( now , point ) : <NEWLINE> <INDENT> nextlist = [ ] <NEWLINE> for n in now : <NEWLINE> <INDENT> if counter [ n [ 0 ] + 1 ] [ n [ 1 ] ] > point + 1 : <NEWLINE> <INDENT> counter [ n [ 0 ] + 1 ] [ n [ 1 ] ] = point + 1 <NEWLINE> nextlist . append ( [ n [ 0 ] + 1 , n [ 1 ] ] ) <NEWLINE> <DEDENT> if counter [ n [ 0 ] ] [ n [ 1 ] + 1 ] > point + 1 : <NEWLINE> <INDENT> nextlist . append ( [ n [ 0 ] , n [ 1 ] + 1 ] ) <NEWLINE> counter [ n [ 0 ] ] [ n [ 1 ] + 1 ] = point + 1 <NEWLINE> <DEDENT> if counter [ n [ 0 ] - 1 ] [ n [ 1 ] ] > point + 1 : <NEWLINE> <INDENT> nextlist . append ( [ n [ 0 ] - 1 , n [ 1 ] ] ) <NEWLINE> counter [ n [ 0 ] - 1 ] [ n [ 1 ] ] = point + 1 <NEWLINE> <DEDENT> if counter [ n [ 0 ] ] [ n [ 1 ] - 1 ] > point + 1 : <NEWLINE> <INDENT> nextlist . append ( [ n [ 0 ] , n [ 1 ] - 1 ] ) <NEWLINE> counter [ n [ 0 ] ] [ n [ 1 ] - 1 ] = point + 1 <NEWLINE> <DEDENT> <DEDENT> if len ( nextlist ) == 0 : <NEWLINE> <INDENT> anskouho . append ( point ) <NEWLINE> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> solve ( nextlist , point + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> anskouho = [ ] <NEWLINE> for item in start : <NEWLINE> <INDENT> original_counter = [ [ b for _ in range ( W + 2 ) ] for _ in range ( H + 2 ) ] <NEWLINE> for k in range ( H + 2 ) : <NEWLINE> <INDENT> for j in range ( W + 2 ) : <NEWLINE> <INDENT> if S [ k ] [ j ] == <STRING> : <NEWLINE> <INDENT> original_counter [ k ] [ j ] = - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> counter = original_counter <NEWLINE> counter [ item [ 0 ] ] [ item [ 1 ] ] = 0 <NEWLINE> solve ( [ item ] , 0 ) <NEWLINE> <DEDENT> print ( max ( anskouho ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ [ ] for _ in range ( n ) ] <NEWLINE> px = [ 0 for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab [ a - 1 ] . append ( b - 1 ) <NEWLINE> ab [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> px [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> ans = px <NEWLINE> queue = deque ( [ ( 0 , 0 ) ] ) <NEWLINE> while len ( queue ) > 0 : <NEWLINE> <INDENT> prev , a = queue . pop ( ) <NEWLINE> for c in ab [ a ] : <NEWLINE> <INDENT> if c != prev : <NEWLINE> <INDENT> ans [ c ] += ans [ a ] <NEWLINE> queue . append ( ( a , c ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from collections import Counter <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> cumsum = A . cumsum ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> def f ( n ) : <NEWLINE> <INDENT> return n * ( n - 1 ) // 2 <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for key , value in Counter ( cumsum ) . items ( ) : <NEWLINE> <INDENT> if key == 0 : <NEWLINE> <INDENT> ans += value <NEWLINE> <DEDENT> if value >= 2 : <NEWLINE> <INDENT> ans += f ( value ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> while i % 2 == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> i //= 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from collections import defaultdict <NEWLINE> from heapq import heappop , heappush <NEWLINE> N = int ( input ( ) ) <NEWLINE> edge = defaultdict ( list ) <NEWLINE> length = defaultdict ( lambda : defaultdict ( lambda : 10 ** 20 ) ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> edge [ a ] . append ( b ) <NEWLINE> edge [ b ] . append ( a ) <NEWLINE> if b < a : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> length [ a ] [ b ] = c <NEWLINE> <DEDENT> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> K -= 1 <NEWLINE> cost = [ 0 ] * N <NEWLINE> length [ K ] [ K ] = 0 <NEWLINE> targets = [ ( 0 , K ) ] <NEWLINE> cost = [ 10 ** 18 ] * N <NEWLINE> cost [ K ] = 0 <NEWLINE> visited = [ False ] * N <NEWLINE> while targets : <NEWLINE> <INDENT> c , t = heappop ( targets ) <NEWLINE> if visited [ t ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cost [ t ] = c <NEWLINE> visited [ t ] = True <NEWLINE> for v in edge [ t ] : <NEWLINE> <INDENT> if cost [ v ] > cost [ t ] + length [ min ( t , v ) ] [ max ( t , v ) ] : <NEWLINE> <INDENT> heappush ( targets , ( cost [ t ] + length [ min ( t , v ) ] [ max ( t , v ) ] , v ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> out = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> x , y = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> out . append ( cost [ x ] + cost [ y ] ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , out ) ) ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> class Graph ( ) : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . adjacency_dict = { } <NEWLINE> self . weight = [ ] <NEWLINE> <NL> <DEDENT> def add_vertex ( self , v ) : <NEWLINE> <INDENT> self . adjacency_dict [ v ] = [ ] <NEWLINE> self . weight . append ( [ ] ) <NEWLINE> <NL> <DEDENT> def add_edge ( self , v1 , v2 , w ) : <NEWLINE> <INDENT> self . adjacency_dict [ v1 ] . append ( v2 ) <NEWLINE> self . adjacency_dict [ v2 ] . append ( v1 ) <NEWLINE> self . weight [ v1 ] . append ( w ) <NEWLINE> self . weight [ v2 ] . append ( w ) <NEWLINE> <NL> <DEDENT> def get_vertexes ( self ) : <NEWLINE> <INDENT> return self . adjacency_dict . keys ( ) <NEWLINE> <NL> <DEDENT> def get_edges ( self , v ) : <NEWLINE> <INDENT> return self . adjacency_dict [ v ] , self . weight [ v ] <NEWLINE> <NL> <DEDENT> def print_graph ( self ) : <NEWLINE> <INDENT> print ( self . adjacency_dict ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> res = [ ] <NEWLINE> g = Graph ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> res . append ( - 1 ) <NEWLINE> g . add_vertex ( i ) <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> g . add_edge ( u - 1 , v - 1 , w % 2 ) <NEWLINE> <NL> <DEDENT> q = [ ] <NEWLINE> res [ 0 ] = 0 <NEWLINE> q . append ( 0 ) <NEWLINE> while ( len ( q ) > 0 ) : <NEWLINE> <INDENT> v = q . pop ( ) <NEWLINE> u_l , w_l = g . get_edges ( v ) <NEWLINE> for u , w in zip ( u_l , w_l ) : <NEWLINE> <INDENT> if res [ u ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> res [ u ] = ( res [ v ] + w ) % 2 <NEWLINE> q . append ( u ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( res [ i ] ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> S_len = len ( S ) <NEWLINE> ans = set ( ) <NEWLINE> for i in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , S_len ) : <NEWLINE> <INDENT> if j + i <= S_len : <NEWLINE> <INDENT> t = S [ j : j + i ] <NEWLINE> if t != <STRING> : <NEWLINE> <INDENT> ans . add ( t ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = list ( ans ) <NEWLINE> ans . sort ( ) <NEWLINE> print ( ans [ K - 1 ] ) <NEWLINE>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans [ i + 1 ] = ans [ i ] <NEWLINE> if S [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> ans [ i + 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> start , end = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = ans [ end - 1 ] - ans [ start - 1 ] <NEWLINE> print ( cnt ) <NEWLINE> <DEDENT>
b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * ( b + w ) <NEWLINE> dp [ 0 ] = 1 / 2 <NEWLINE> mod = pow ( 10 , 9 ) + 7 <NEWLINE> <NL> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <DEDENT> g1 = [ 1 , 1 ] <COMMENT> <NEWLINE> g2 = [ 1 , 1 ] <COMMENT> <NEWLINE> inverse = [ 0 , 1 ] <NEWLINE> for i in range ( 2 , b + w + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <DEDENT> t1 , t2 = 0 , 0 <NEWLINE> for i in range ( 1 , 1 + b + w ) : <NEWLINE> <INDENT> t = pow ( 2 , mod - 2 , mod ) <NEWLINE> if i - b > 0 : <NEWLINE> <INDENT> t1 *= 2 <NEWLINE> t1 %= mod <NEWLINE> t1 += cmb ( i - 2 , b - 1 , mod ) <NEWLINE> t1 %= mod <NEWLINE> tmp = t1 * pow ( 2 , mod - 1 - i , mod ) <NEWLINE> tmp %= mod <NEWLINE> t -= tmp <NEWLINE> t %= mod <NEWLINE> <DEDENT> if i - w > 0 : <NEWLINE> <INDENT> t2 *= 2 <NEWLINE> t2 %= mod <NEWLINE> t2 += cmb ( i - 2 , w - 1 , mod ) <NEWLINE> t2 %= mod <NEWLINE> tmp = t2 * pow ( 2 , mod - 1 - i , mod ) <NEWLINE> tmp %= mod <NEWLINE> t += tmp <NEWLINE> t %= mod <NEWLINE> <DEDENT> print ( t ) <NEWLINE> <NL> <DEDENT>
import networkx as nx <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> UVW = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N - 1 ) ] <NEWLINE> <NL> G = nx . Graph ( ) <NEWLINE> <NL> color = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> for u , v , w in UVW : <NEWLINE> <INDENT> G . add_edge ( u - 1 , v - 1 , weight = w ) <NEWLINE> <NL> <DEDENT> color [ 0 ] = - 1 <NEWLINE> <NL> pred , dist = nx . dijkstra_predecessor_and_distance ( G , 0 ) <NEWLINE> <NL> c = [ dist [ i ] for i in range ( N ) ] <NEWLINE> ans = [ 1 if i % 2 == 0 else 0 for i in c ] <NEWLINE> print ( * ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> B = sorted ( A ) <NEWLINE> mx = B [ - 1 ] <NEWLINE> second = B [ - 2 ] <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == mx : <NEWLINE> <INDENT> print ( second ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mx ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
import collections <NEWLINE> import copy <NEWLINE> INF = 10000 <NEWLINE> <NL> <COMMENT> <NL> N , Ma , Mb = map ( int , input ( ) . split ( ) ) <NEWLINE> medichine = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> dp = { } <NEWLINE> <COMMENT> <NL> dp = collections . defaultdict ( lambda : INF ) <NEWLINE> dp [ 0 , 0 ] = 0 <NEWLINE> <NL> for a , b , c in medichine : <NEWLINE> <INDENT> dp_ = copy . copy ( dp ) <NEWLINE> for ca , cb in dp . keys ( ) : <NEWLINE> <INDENT> dp_ [ ca + a , cb + b ] = min ( dp_ [ ca + a , cb + b ] , dp [ ca , cb ] + c ) <NEWLINE> <DEDENT> dp = dp_ <NEWLINE> <NL> <DEDENT> ans = INF <NEWLINE> for ca , cb in dp . keys ( ) : <NEWLINE> <INDENT> if ca == cb == 0 : continue <NEWLINE> if ca * Mb == cb * Ma : <NEWLINE> <INDENT> ans = min ( ans , dp [ ca , cb ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 if ans == INF else ans ) <NEWLINE>
from collections import deque <NEWLINE> h , w , * s = open ( 0 ) . read ( ) . split ( ) <NEWLINE> h = int ( h ) <NEWLINE> w = int ( w ) <NEWLINE> <NL> q = deque ( ) <NEWLINE> used = [ False ] * ( h * w ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if not used [ i * w + j ] : <NEWLINE> <INDENT> bcnt = 0 <NEWLINE> cnt = 0 <NEWLINE> <NL> q . append ( ( i , j ) ) <NEWLINE> used [ i * w + j ] = True <NEWLINE> cnt += 1 <NEWLINE> bcnt += s [ i ] [ j ] == <STRING> <NEWLINE> <NL> while len ( q ) : <NEWLINE> <INDENT> y , x = q . popleft ( ) <NEWLINE> for dy , dx in [ ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( - 1 , 0 ) ] : <NEWLINE> <INDENT> ny = y + dy <NEWLINE> nx = x + dx <NEWLINE> if 0 <= nx < w and 0 <= ny < h and s [ y ] [ x ] != s [ ny ] [ nx ] and not used [ ny * w + nx ] : <NEWLINE> <INDENT> q . append ( ( ny , nx ) ) <NEWLINE> used [ ny * w + nx ] = True <NEWLINE> cnt += 1 <NEWLINE> bcnt += s [ ny ] [ nx ] == <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans += bcnt * ( cnt - bcnt ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def dfs ( num ) : <NEWLINE> <INDENT> if dp [ num ] != - 1 : <NEWLINE> <INDENT> return dp [ num ] <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for obj in G [ num ] : <NEWLINE> <INDENT> res = max ( res , dfs ( obj ) + 1 ) <NEWLINE> <NL> <DEDENT> dp [ num ] = res <NEWLINE> return res <NEWLINE> <NL> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dp = [ - 1 ] * N <NEWLINE> G = { i : [ ] for i in range ( N ) } <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ x - 1 ] . append ( y - 1 ) <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> res = max ( res , dfs ( i ) ) <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
import math <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> ARR = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def calculate ( n , arr ) : <NEWLINE> <INDENT> result = [ math . inf for i in range ( n ) ] <NEWLINE> <NL> result [ 0 ] = 0 <NEWLINE> result [ 1 ] = abs ( arr [ 1 ] - arr [ 0 ] ) <NEWLINE> <NL> <NL> for i in range ( 2 , n ) : <NEWLINE> <INDENT> a1 = abs ( arr [ i ] - arr [ i - 2 ] ) + result [ i - 2 ] <NEWLINE> a2 = abs ( arr [ i ] - arr [ i - 1 ] ) + result [ i - 1 ] <NEWLINE> <NL> result [ i ] = min ( a1 , a2 ) <NEWLINE> <NL> <NL> <DEDENT> print ( result [ - 1 ] ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> calculate ( N , ARR ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> x = [ int ( xn ) for xn in input ( ) . split ( ) ] <NEWLINE> x_sorted = sorted ( x ) <NEWLINE> idx_median = n // 2 <NEWLINE> median_low = x_sorted [ idx_median - 1 ] <NEWLINE> median_high = x_sorted [ idx_median ] <NEWLINE> for xn in x : <NEWLINE> <INDENT> print ( median_high if xn <= median_low else median_low ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
p = input ( ) . split ( ) <NEWLINE> <NL> k = int ( p [ 0 ] ) <NEWLINE> s = int ( p [ 1 ] ) <NEWLINE> <NL> x = - 1 <NEWLINE> y = - 1 <NEWLINE> z = 0 <NEWLINE> answer = 0 <NEWLINE> <NL> for num in range ( k + 1 ) : <NEWLINE> <INDENT> x += 1 <NEWLINE> y = - 1 <NEWLINE> for n in range ( k + 1 ) : <NEWLINE> <INDENT> y += 1 <NEWLINE> z = s - x - y <NEWLINE> if 0 <= z and z <= k : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from itertools import accumulate <NEWLINE> <NL> def merge ( x , y ) : <NEWLINE> <INDENT> a , b = dp [ x ] <NEWLINE> c , d = dp [ y ] <NEWLINE> if a >= c : <NEWLINE> <INDENT> return ( a , max ( c , b ) ) <NEWLINE> <DEDENT> return ( c , max ( a , d ) ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ ( a , 0 ) for a in A ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> for i in range ( 1 << n ) : <NEWLINE> <INDENT> if i & ( 1 << j ) : <NEWLINE> <INDENT> dp [ i ] = merge ( i , i & ~ ( 1 << j ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> L = tuple ( accumulate ( ( sum ( d ) for d in dp ) , max ) ) <NEWLINE> print ( * L [ 1 : ] , sep = <STRING> ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if 0 < a <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a <= b < 0 : <NEWLINE> <INDENT> if ( b - a + 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> import collections <NEWLINE> import fractions <NEWLINE> import itertools <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = collections . Counter ( t ) <NEWLINE> d = collections . Counter ( d ) <NEWLINE> for i in t : <NEWLINE> <INDENT> if t [ i ] > d [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = int ( b // x ) - int ( a // x ) <NEWLINE> if a % x == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> dp = [ 0 ] * ( 100000 + 1 ) <NEWLINE> a = 1 <NEWLINE> b = 6 <NEWLINE> c = 9 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i >= b * 6 : <NEWLINE> <INDENT> b *= 6 <NEWLINE> <DEDENT> if i >= c * 9 : <NEWLINE> <INDENT> c *= 9 <NEWLINE> <DEDENT> if i < 6 : <NEWLINE> <INDENT> dp [ i ] = i <NEWLINE> <DEDENT> elif i < 9 : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + 1 , dp [ i - b ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = min ( [ dp [ i - a ] + 1 , dp [ i - b ] + 1 , dp [ i - c ] + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ N ] ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> n = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> n . append ( t ) <NEWLINE> <DEDENT> n = np . array ( n ) <NEWLINE> dl = [ 0 ] <NEWLINE> s = np . ceil ( n / 10 ) * 10 <NEWLINE> <NL> if max ( n % 10 ) == 0 : <NEWLINE> <INDENT> print ( int ( np . sum ( s ) ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> m = [ e for e in n % 10 if e not in dl ] <NEWLINE> print ( int ( np . sum ( s ) - ( 10 - min ( m ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if a [ 0 ] < a [ 1 ] : flag = 1 <NEWLINE> elif a [ 0 ] > a [ 1 ] : flag = - 1 <NEWLINE> else : flag = 0 <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if flag == 1 and a [ i ] > a [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> flag = 0 <NEWLINE> <DEDENT> elif flag == - 1 and a [ i ] < a [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> flag = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a [ i ] > a [ i + 1 ] : flag = - 1 <NEWLINE> elif a [ i ] < a [ i + 1 ] : flag = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import heapq as hq <NEWLINE> x , y , z , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> for b in B : <NEWLINE> <INDENT> hq . heappush ( ab , - a - b ) <NEWLINE> <DEDENT> <DEDENT> abc = [ ] <NEWLINE> cnt = 0 <NEWLINE> while cnt < k and ab : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> a = hq . heappop ( ab ) <NEWLINE> for b in C : <NEWLINE> <INDENT> hq . heappush ( abc , a - b ) <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> while cnt < k : <NEWLINE> <INDENT> print ( - hq . heappop ( abc ) ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> route = [ ] <NEWLINE> n_black = 0 <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> tmp_ls = input ( ) <NEWLINE> n_black += tmp_ls . count ( <STRING> ) <NEWLINE> route . append ( tmp_ls ) <NEWLINE> <DEDENT> visited = [ [ False ] * W for _ in range ( H ) ] <NEWLINE> dist = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> dist [ 0 ] [ 0 ] = 0 <NEWLINE> tmp = [ 0 , 0 ] <NEWLINE> goal = [ H - 1 , W - 1 ] <NEWLINE> kouho = deque ( ) <NEWLINE> def rinsetsu ( ls ) : <NEWLINE> <INDENT> x , y = ls [ 0 ] , ls [ 1 ] <NEWLINE> ans = [ ] <NEWLINE> if x - 1 >= 0 : <NEWLINE> <INDENT> ans . append ( [ x - 1 , y ] ) <NEWLINE> <DEDENT> if x + 1 <= H - 1 : <NEWLINE> <INDENT> ans . append ( [ x + 1 , y ] ) <NEWLINE> <DEDENT> if y - 1 >= 0 : <NEWLINE> <INDENT> ans . append ( [ x , y - 1 ] ) <NEWLINE> <DEDENT> if y + 1 <= W - 1 : <NEWLINE> <INDENT> ans . append ( [ x , y + 1 ] ) <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> for ls in rinsetsu ( [ 0 , 0 ] ) : <NEWLINE> <INDENT> if route [ ls [ 0 ] ] [ ls [ 1 ] ] == <STRING> : <NEWLINE> <INDENT> kouho . append ( [ ls [ 0 ] , ls [ 1 ] , 0 , 0 ] ) <NEWLINE> <DEDENT> <DEDENT> def bfs ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if len ( kouho ) == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> tmp = kouho . popleft ( ) <NEWLINE> if not visited [ tmp [ 0 ] ] [ tmp [ 1 ] ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> x , y = tmp [ 0 ] , tmp [ 1 ] <NEWLINE> visited [ x ] [ y ] = True <NEWLINE> dist [ x ] [ y ] = dist [ tmp [ 2 ] ] [ tmp [ 3 ] ] + 1 <NEWLINE> if [ x , y ] == goal : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for ls in rinsetsu ( [ x , y ] ) : <NEWLINE> <INDENT> if not visited [ ls [ 0 ] ] [ ls [ 1 ] ] and route [ ls [ 0 ] ] [ ls [ 1 ] ] == <STRING> : <NEWLINE> <INDENT> kouho . append ( ls + [ x , y ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> bfs ( ) <NEWLINE> if dist [ H - 1 ] [ W - 1 ] == - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> white = dist [ H - 1 ] [ W - 1 ] + 1 <NEWLINE> print ( H * W - white - n_black ) <NEWLINE> <NL> <DEDENT>
from collections import deque <NEWLINE> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> B = [ ( i , j ) for i , a in enumerate ( A ) for j , b in enumerate ( a ) if b == <STRING> ] <NEWLINE> dxy = [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ] <NEWLINE> stack = deque ( B ) <NEWLINE> colored = len ( B ) <NEWLINE> tot = h * w <NEWLINE> count = 0 <NEWLINE> while colored < tot : <NEWLINE> <INDENT> next = deque ( [ ] ) <NEWLINE> while stack : <NEWLINE> <INDENT> y , x = stack . popleft ( ) <NEWLINE> for dx , dy in dxy : <NEWLINE> <INDENT> X = x + dx <NEWLINE> Y = y + dy <NEWLINE> if X < 0 or X >= w or Y < 0 or Y >= h : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if A [ Y ] [ X ] == <STRING> : <NEWLINE> <INDENT> next . append ( ( Y , X ) ) <NEWLINE> A [ Y ] [ X ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> stack = next <NEWLINE> count += 1 <NEWLINE> colored += len ( next ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
MOD = 10 ** 9 + 7 <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( M ) ] <NEWLINE> L = [ - 1 for _ in range ( N ) ] <NEWLINE> p = 0 <NEWLINE> if A == [ ] : <NEWLINE> <INDENT> A = [ 0 ] <NEWLINE> <DEDENT> if 1 == A [ p ] : <NEWLINE> <INDENT> L [ 0 ] = 0 <NEWLINE> if p < M - 1 : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> L [ 0 ] = 1 <NEWLINE> <DEDENT> if N > 1 : <NEWLINE> <INDENT> if 2 == A [ p ] : <NEWLINE> <INDENT> L [ 1 ] = 0 <NEWLINE> if p < M - 1 : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> L [ 1 ] = L [ 0 ] + 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 2 , N ) : <NEWLINE> <INDENT> if i + 1 == A [ p ] : <NEWLINE> <INDENT> L [ i ] = 0 <NEWLINE> if p < M - 1 : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> L [ i ] = L [ i - 1 ] + L [ i - 2 ] <NEWLINE> <DEDENT> <DEDENT> print ( L [ - 1 ] % MOD ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 2020202020 <NEWLINE> a = 0 <NEWLINE> b = sum ( s ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a += s [ i ] <NEWLINE> b -= s [ i ] <NEWLINE> ans = min ( ans , abs ( a - b ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> def seive ( ) : <NEWLINE> <INDENT> l [ 0 ] = 0 <NEWLINE> l [ 1 ] = 0 <NEWLINE> for i in range ( 2 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if l [ i ] == 1 : <NEWLINE> <INDENT> k . append ( i ) <NEWLINE> for j in range ( i * i , 10 ** 6 + 1 , i ) : <NEWLINE> <INDENT> l [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> l = [ 1 ] * ( 10 ** 6 + 1 ) <NEWLINE> k = [ ] <NEWLINE> seive ( ) <NEWLINE> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> d = bisect . bisect_left ( k , n ) <NEWLINE> print ( k [ d ] ) <NEWLINE> <NL>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> print ( math . factorial ( n ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> from math import floor , ceil , sqrt , factorial , log , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from collections import Counter , defaultdict <NEWLINE> from heapq import heappop , heappush , heappushpop , heapify <NEWLINE> import copy <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> from functools import lru_cache <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def lcm ( a , b ) : return a * b / gcd ( a , b ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> <NL> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def dp ( i , j ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> return 0 if j == 0 else - INF <NEWLINE> <DEDENT> if j == 0 : <NEWLINE> <INDENT> return max ( dp ( i - 1 , 0 ) + a [ i - 1 ] , dp ( i - 1 , 1 ) - a [ i - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return max ( dp ( i - 1 , 0 ) - a [ i - 1 ] , dp ( i - 1 , 1 ) + a [ i - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = I ( ) <NEWLINE> a = LI ( ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> print ( dp ( n , 0 ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def examA ( ) : <NEWLINE> <INDENT> N = SI ( ) <NEWLINE> n = len ( N ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( N ) <NEWLINE> return <NEWLINE> <DEDENT> ans = ( n - 1 ) * 9 + int ( N [ 0 ] ) - 1 <NEWLINE> if int ( N [ 1 : ] ) == int ( <STRING> * ( n - 1 ) ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def examB ( ) : <NEWLINE> <INDENT> def norm2 ( vec ) : <NEWLINE> <INDENT> return math . sqrt ( vec [ 0 ] ** 2 + vec [ 1 ] ** 2 ) <NEWLINE> <COMMENT> <NL> <DEDENT> def ConvexHull ( point_list ) : <NEWLINE> <INDENT> pos2idx = { point_list [ i ] : i for i in range ( len ( point_list ) ) } <NEWLINE> y_val = defaultdict ( list ) <NEWLINE> x_list = sorted ( list ( set ( [ p [ 0 ] for p in point_list ] ) ) ) <NEWLINE> for x , y in point_list : <NEWLINE> <INDENT> y_val [ x ] . append ( y ) <NEWLINE> <NL> <DEDENT> upper = [ ( x_list [ 0 ] , max ( y_val [ x_list [ 0 ] ] ) ) ] <NEWLINE> lower = [ ( x_list [ 0 ] , min ( y_val [ x_list [ 0 ] ] ) ) ] <NEWLINE> prev = float ( <STRING> ) <NEWLINE> for xi in x_list [ 1 : ] : <NEWLINE> <INDENT> x0 , y0 = upper [ - 1 ] <NEWLINE> x1 , y1 = xi , max ( y_val [ xi ] ) <NEWLINE> if ( y1 - y0 ) / ( x1 - x0 ) < prev : <NEWLINE> <INDENT> upper . append ( ( x1 , y1 ) ) <NEWLINE> prev = ( y1 - y0 ) / ( x1 - x0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> x0 , y0 = upper [ - 1 ] <NEWLINE> if len ( upper ) == 1 : <NEWLINE> <INDENT> upper . append ( ( x1 , y1 ) ) <NEWLINE> break <NEWLINE> <DEDENT> x00 , y00 = upper [ - 2 ] <NEWLINE> if ( y1 - y0 ) / ( x1 - x0 ) > ( y1 - y00 ) / ( x1 - x00 ) : <NEWLINE> <INDENT> upper . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prev = ( y1 - y0 ) / ( x1 - x0 ) <NEWLINE> upper . append ( ( x1 , y1 ) ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> prev = - float ( <STRING> ) <NEWLINE> for xi in x_list [ 1 : ] : <NEWLINE> <INDENT> x0 , y0 = lower [ - 1 ] <NEWLINE> x1 , y1 = xi , min ( y_val [ xi ] ) <NEWLINE> if ( y1 - y0 ) / ( x1 - x0 ) > prev : <NEWLINE> <INDENT> lower . append ( ( x1 , y1 ) ) <NEWLINE> prev = ( y1 - y0 ) / ( x1 - x0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> x0 , y0 = lower [ - 1 ] <NEWLINE> if len ( lower ) == 1 : <NEWLINE> <INDENT> lower . append ( ( x1 , y1 ) ) <NEWLINE> break <NEWLINE> <DEDENT> x00 , y00 = lower [ - 2 ] <NEWLINE> if ( y1 - y0 ) / ( x1 - x0 ) < ( y1 - y00 ) / ( x1 - x00 ) : <NEWLINE> <INDENT> lower . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prev = ( y1 - y0 ) / ( x1 - x0 ) <NEWLINE> lower . append ( ( x1 , y1 ) ) <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> upper_idx , lower_idx = [ pos2idx [ xy ] for xy in upper ] , [ pos2idx [ xy ] for xy in lower ] <NEWLINE> if upper_idx [ - 1 ] == lower_idx [ - 1 ] : <NEWLINE> <INDENT> upper_idx . pop ( ) <NEWLINE> <DEDENT> CH_idx = upper_idx <NEWLINE> CH_idx . extend ( reversed ( lower_idx ) ) <NEWLINE> if CH_idx [ 0 ] == CH_idx [ - 1 ] and len ( CH_idx ) > 1 : <NEWLINE> <INDENT> CH_idx . pop ( ) <NEWLINE> <DEDENT> return CH_idx <NEWLINE> <NL> <DEDENT> N = I ( ) <NEWLINE> P = [ [ ] for _ in range ( N ) ] <NEWLINE> D = defaultdict ( int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = LI ( ) <NEWLINE> P [ i ] = ( x , y ) <NEWLINE> D [ ( x , y ) ] = i <NEWLINE> <DEDENT> C = ConvexHull ( P ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> if len ( C ) == 2 : <NEWLINE> <INDENT> for c in C : <NEWLINE> <INDENT> ans [ c ] = 0.5 <NEWLINE> <DEDENT> for v in ans : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT> return <NEWLINE> <COMMENT> <NL> <DEDENT> for i , c in enumerate ( C ) : <NEWLINE> <INDENT> s , t , u = C [ i - 1 ] , C [ i ] , C [ ( i + 1 ) % len ( C ) ] <NEWLINE> x0 , y0 = P [ s ] <NEWLINE> x1 , y1 = P [ t ] <NEWLINE> x2 , y2 = P [ u ] <NEWLINE> vec0 = ( y0 - y1 , x1 - x0 ) <NEWLINE> vec1 = ( y1 - y2 , x2 - x1 ) <NEWLINE> ans [ t ] = math . acos ( ( vec0 [ 0 ] * vec1 [ 0 ] + vec0 [ 1 ] * vec1 [ 1 ] ) / ( norm2 ( vec0 ) * norm2 ( vec1 ) ) ) / ( 2 * math . pi ) <NEWLINE> <DEDENT> for v in ans : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> def examC ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> def examD ( ) : <NEWLINE> <INDENT> S = SI ( ) <NEWLINE> N = len ( S ) <NEWLINE> K = I ( ) <NEWLINE> if K > 150 : <NEWLINE> <INDENT> K = 150 <NEWLINE> <DEDENT> dp = [ [ [ 0 ] * ( K + 1 ) for _ in range ( N ) ] for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> dp [ i ] [ i ] [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> for k in range ( K + 1 ) : <NEWLINE> <INDENT> for l , r in enumerate ( range ( i - 1 , N ) ) : <NEWLINE> <INDENT> if S [ l ] == S [ r ] : <NEWLINE> <INDENT> dp [ l ] [ r ] [ k ] = dp [ l + 1 ] [ r - 1 ] [ k ] + 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k > 0 : <NEWLINE> <INDENT> dp [ l ] [ r ] [ k ] = max ( dp [ l + 1 ] [ r ] [ k ] , dp [ l ] [ r - 1 ] [ k ] , dp [ l + 1 ] [ r - 1 ] [ k - 1 ] + 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ l ] [ r ] [ k ] = max ( dp [ l + 1 ] [ r ] [ k ] , dp [ l ] [ r - 1 ] [ k ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = max ( dp [ 0 ] [ - 1 ] ) <NEWLINE> <COMMENT> <NL> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> def examE ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> def examF ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> from decimal import Decimal as dec <NEWLINE> import sys , bisect , itertools , heapq , math , random <NEWLINE> from copy import deepcopy <NEWLINE> from heapq import heappop , heappush , heapify <NEWLINE> from collections import Counter , defaultdict , deque <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def DI ( ) : return dec ( input ( ) ) <NEWLINE> def LDI ( ) : return list ( map ( dec , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def LSI ( ) : return list ( map ( str , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def SI ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> global mod , mod2 , inf , alphabet , _ep <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> mod2 = 998244353 <NEWLINE> inf = 10 ** 18 <NEWLINE> _ep = 10 ** ( - 12 ) <NEWLINE> alphabet = [ chr ( ord ( <STRING> ) + i ) for i in range ( 26 ) ] <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> examA ( ) <NEWLINE> <NL> <DEDENT> <STRING> <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def i ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N , M = I ( ) <NEWLINE> X = l ( ) <NEWLINE> X . sort ( ) <NEWLINE> kyori = [ ] <NEWLINE> <NL> if N >= M : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if M == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in range ( len ( X ) - 1 ) : <NEWLINE> <INDENT> s = X [ i + 1 ] - X [ i ] <NEWLINE> kyori . append ( s ) <NEWLINE> <NL> <DEDENT> kyori . sort ( ) <NEWLINE> kyori . reverse ( ) <NEWLINE> <NL> for j in range ( N - 1 ) : <NEWLINE> <INDENT> kyori . pop ( 0 ) <NEWLINE> <NL> <DEDENT> print ( sum ( kyori ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> vc = [ ] <NEWLINE> for i , j in zip ( v , c ) : <NEWLINE> <INDENT> vc . append ( i - j ) <NEWLINE> <DEDENT> vc = sorted ( vc , reverse = True ) <NEWLINE> ans = 0 <NEWLINE> for i in vc : <NEWLINE> <INDENT> if i <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list = [ ] <NEWLINE> a = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if H [ i ] >= H [ i + 1 ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list . append ( a ) <NEWLINE> a = 0 <NEWLINE> <DEDENT> <DEDENT> list . append ( a ) <NEWLINE> list = sorted ( list ) <NEWLINE> print ( list [ - 1 ] ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> S += <STRING> <NEWLINE> d = [ 0 ] * ( N + 1 ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( S ) - 1 ) : <NEWLINE> <INDENT> if S [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> d [ i + 1 ] = count <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = d [ r - 1 ] - d [ l - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> p_e = list ( ) <NEWLINE> exp = 0 <NEWLINE> for p in P : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> exp += ( 1 + p ) / 2 <NEWLINE> p_e . append ( exp ) <NEWLINE> <DEDENT> if n == k : <NEWLINE> <INDENT> print ( p_e [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> maxv = p_e [ k - 1 ] - p_e [ 0 ] <NEWLINE> for i in range ( 1 , n - k ) : <NEWLINE> <COMMENT> <NL> <INDENT> p_sum = p_e [ k + i ] - p_e [ i ] <NEWLINE> maxv = max ( maxv , p_sum ) <NEWLINE> <DEDENT> print ( maxv ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> d = Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> for t in T : <NEWLINE> <INDENT> if t in d and d [ t ] > 0 : <NEWLINE> <INDENT> d [ t ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> aa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> list1 = [ 0 ] * n <NEWLINE> cnt = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if aa [ i + 1 ] > aa [ i ] : <NEWLINE> <INDENT> list1 [ i + 1 ] = 1 <NEWLINE> <DEDENT> elif aa [ i + 1 ] < aa [ i ] : <NEWLINE> <INDENT> list1 [ i + 1 ] = - 1 <NEWLINE> <DEDENT> elif aa [ i + 1 ] == aa [ i ] : <NEWLINE> <INDENT> list1 [ i + 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> while 1 in list1 and - 1 in list1 : <NEWLINE> <INDENT> del list1 [ : max ( list1 . index ( 1 ) , list1 . index ( - 1 ) ) ] <NEWLINE> list1 [ 0 ] = 0 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
a , b , c , x = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( a + 1 ) : <NEWLINE> <INDENT> for j in range ( b + 1 ) : <NEWLINE> <INDENT> for k in range ( c + 1 ) : <NEWLINE> <INDENT> if 500 * i + 100 * j + 50 * k == x : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ [ 0 ] * 3 for xxx in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> ans [ 0 ] [ 0 ] = a <NEWLINE> ans [ 0 ] [ 1 ] = b <NEWLINE> ans [ 0 ] [ 2 ] = c <NEWLINE> continue <NEWLINE> <DEDENT> ans [ i ] [ 0 ] += max ( ans [ i - 1 ] [ 1 ] , ans [ i - 1 ] [ 2 ] ) + a <NEWLINE> ans [ i ] [ 1 ] += max ( ans [ i - 1 ] [ 2 ] , ans [ i - 1 ] [ 0 ] ) + b <NEWLINE> ans [ i ] [ 2 ] += max ( ans [ i - 1 ] [ 0 ] , ans [ i - 1 ] [ 1 ] ) + c <NEWLINE> <DEDENT> ans = ans [ - 1 ] <NEWLINE> print ( max ( ans ) ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = abs ( abs ( y ) - abs ( x ) ) <NEWLINE> <NL> if ( x > 0 and y <= 0 ) or ( x >= 0 and y < 0 ) or ( x < 0 and y > 0 ) : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> elif x > y : <NEWLINE> <INDENT> d += 2 <NEWLINE> <NL> <DEDENT> print ( d ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> i = 0 <NEWLINE> ans = 0 <NEWLINE> while True : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while A [ i + cnt ] == A [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if i + cnt == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if cnt % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> i += cnt <NEWLINE> if i == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys , math , collections , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> P = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> Q = [ 0 ] * ( N ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Q [ P [ i ] - 1 ] = i <NEWLINE> <NL> <DEDENT> cnt = 1 <NEWLINE> ans = 1 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if Q [ i + 1 ] > Q [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , cnt ) <NEWLINE> cnt = 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> print ( N - ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ True ] * N <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A [ a - 1 ] = False <COMMENT> <NEWLINE> <NL> <DEDENT> waru = 10 ** 9 + 7 <NEWLINE> dp = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> dp [ 0 ] , dp [ 1 ] = 1 , 1 <COMMENT> <NEWLINE> if not A [ 0 ] : <COMMENT> <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if not A [ i - 1 ] : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % waru <NEWLINE> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
S = input ( ) <NEWLINE> stack = [ ] <NEWLINE> for s in S : <NEWLINE> <INDENT> if not stack : <NEWLINE> <INDENT> stack . append ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s == stack [ - 1 ] : <NEWLINE> <INDENT> stack . append ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . pop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( S ) - len ( stack ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s1 = [ ] <NEWLINE> s2 = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if a % 10 != 0 : <NEWLINE> <INDENT> s1 . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s2 . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( s1 ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if sum ( s1 ) % 10 == 0 : <NEWLINE> <INDENT> print ( sum ( s1 ) - min ( s1 ) + sum ( s2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( s1 ) + sum ( s2 ) ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> l , r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ l - 1 ] . append ( ( r - 1 , d ) ) <NEWLINE> graph [ r - 1 ] . append ( ( l - 1 , - d ) ) <NEWLINE> <DEDENT> seen = [ False ] * n <NEWLINE> dist = [ None ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if seen [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q = deque ( [ i ] ) <NEWLINE> dist [ i ] = 0 <NEWLINE> while q : <NEWLINE> <INDENT> node = q . popleft ( ) <NEWLINE> if seen [ node ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> seen [ node ] = True <NEWLINE> for c_node , d in graph [ node ] : <NEWLINE> <INDENT> if dist [ c_node ] is None : <NEWLINE> <INDENT> dist [ c_node ] = dist [ node ] + d <NEWLINE> <DEDENT> elif dist [ c_node ] != dist [ node ] + d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> if not seen [ c_node ] : <NEWLINE> <INDENT> q . append ( c_node ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from collections import defaultdict <NEWLINE> N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> d = defaultdict ( int ) <COMMENT> <NEWLINE> for a in A : <NEWLINE> <INDENT> d [ a ] ^= 1 <COMMENT> <NEWLINE> <DEDENT> print ( sum ( d . values ( ) ) ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( h ) ] <NEWLINE> <NL> def bfs ( x , y ) : <NEWLINE> <INDENT> q = [ ] <NEWLINE> dp = { } <NEWLINE> def qpush ( x , y , t ) : <NEWLINE> <INDENT> if 0 <= x < w and 0 <= y < h and s [ y ] [ x ] != <STRING> and ( x , y ) not in dp : <NEWLINE> <INDENT> q . append ( ( x , y ) ) <NEWLINE> dp [ ( x , y ) ] = t <NEWLINE> <NL> <DEDENT> <DEDENT> qpush ( x , y , 0 ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> ( x , y ) = q . pop ( 0 ) <NEWLINE> qpush ( x + 1 , y , dp [ ( x , y ) ] + 1 ) <NEWLINE> qpush ( x , y - 1 , dp [ ( x , y ) ] + 1 ) <NEWLINE> qpush ( x - 1 , y , dp [ ( x , y ) ] + 1 ) <NEWLINE> qpush ( x , y + 1 , dp [ ( x , y ) ] + 1 ) <NEWLINE> <DEDENT> return dp . get ( ( x , y ) , 0 ) <NEWLINE> <NL> <DEDENT> t = 0 <NEWLINE> for y in range ( h ) : <NEWLINE> <INDENT> for x in range ( w ) : <NEWLINE> <INDENT> t = max ( t , bfs ( x , y ) ) <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> max_num = max ( l ) <NEWLINE> max_index = l . index ( max ( l ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i != max_index : <NEWLINE> <INDENT> print ( max_num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . remove ( max_num ) <NEWLINE> print ( max ( l ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ps = [ 0 ] + list ( filter ( lambda x : x >= 0 , X ) ) <NEWLINE> ns = [ 0 ] + list ( sorted ( filter ( lambda x : x < 0 , X ) , reverse = True ) ) <NEWLINE> <NL> ans = INF <NEWLINE> for i in range ( len ( ns ) ) : <NEWLINE> <INDENT> val = abs ( ns [ i ] ) * 2 <NEWLINE> if K - i >= 0 and K - i < len ( ps ) : <NEWLINE> <INDENT> val += abs ( ps [ K - i ] ) <NEWLINE> ans = min ( ans , val ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( ps ) ) : <NEWLINE> <INDENT> val = abs ( ps [ i ] ) * 2 <NEWLINE> if K - i >= 0 and K - i < len ( ns ) : <NEWLINE> <INDENT> val += abs ( ns [ K - i ] ) <NEWLINE> ans = min ( ans , val ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def solve ( h , w , a ) : <NEWLINE> <INDENT> used = [ [ True ] * ( w + 2 ) for _ in range ( h + 2 ) ] <NEWLINE> que = deque ( ) <NEWLINE> for r in range ( h ) : <NEWLINE> <INDENT> used [ r + 1 ] [ 1 : - 1 ] = map ( lambda _ : _ == <STRING> , a [ r ] ) <NEWLINE> for c in range ( w ) : <NEWLINE> <INDENT> if a [ r ] [ c ] == <STRING> : <NEWLINE> <INDENT> que . append ( ( r + 1 , c + 1 , 0 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> neighbors = [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> while que : <NEWLINE> <INDENT> r , c , k = que . popleft ( ) <NEWLINE> for dr , dc in neighbors : <NEWLINE> <INDENT> nr , nc = r + dr , c + dc <NEWLINE> if not used [ nr ] [ nc ] : <NEWLINE> <INDENT> que . append ( ( nr , nc , k + 1 ) ) <NEWLINE> used [ nr ] [ nc ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return k <NEWLINE> <NL> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ input ( ) for _ in range ( h ) ] <NEWLINE> print ( solve ( h , w , a ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ret = 0 <NEWLINE> for x in range ( 10 ) : <NEWLINE> <INDENT> for y in range ( 10 ) : <NEWLINE> <INDENT> for z in range ( 10 ) : <NEWLINE> <INDENT> a = S . find ( str ( x ) ) <NEWLINE> if a != - 1 : <NEWLINE> <INDENT> b = S . find ( str ( y ) , a + 1 ) <NEWLINE> if b != - 1 : <NEWLINE> <INDENT> c = S . find ( str ( z ) , b + 1 ) <NEWLINE> if c != - 1 : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> if a == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> if a <= x : <NEWLINE> <INDENT> ai = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ai = ( a // x ) * x <NEWLINE> if ai < a : <NEWLINE> <INDENT> ai += x <NEWLINE> <DEDENT> <DEDENT> if ai <= b : <NEWLINE> <INDENT> count += 1 <NEWLINE> count += ( b - ai ) // x <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = [ 0 for i in range ( 10 ** 7 ) ] <NEWLINE> for a in A : <NEWLINE> <INDENT> D [ a - 1 ] += 1 <NEWLINE> D [ a ] += 1 <NEWLINE> D [ a + 1 ] += 1 <NEWLINE> <DEDENT> print ( max ( D ) ) <NEWLINE>
from collections import deque <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> count = 0 <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> A = list ( input ( ) ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> S . append ( A ) <NEWLINE> <NL> <DEDENT> mas = deque ( [ ( 0 , 0 , 0 ) ] ) <NEWLINE> while mas : <NEWLINE> <INDENT> y , x , n = mas . popleft ( ) <NEWLINE> if 0 <= y <= H - 1 and 0 <= x <= W - 1 : <NEWLINE> <INDENT> if S [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> S [ y ] [ x ] = n <NEWLINE> mas . append ( ( y + 1 , x , n + 1 ) ) <NEWLINE> mas . append ( ( y , x + 1 , n + 1 ) ) <NEWLINE> mas . append ( ( y - 1 , x , n + 1 ) ) <NEWLINE> mas . append ( ( y , x - 1 , n + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> short = S [ H - 1 ] [ W - 1 ] <NEWLINE> if short == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( count - ( short + 1 ) ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( a > 0 and b < 0 ) or ( a < 0 and b > 0 ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif a == 0 or b == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif a > 0 and b > 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif a < 0 and b < 0 : <NEWLINE> <INDENT> if ( a % 2 == 0 and b % 2 == 0 ) or ( a % 2 != 0 and b % 2 != 0 ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> sento = 0 <NEWLINE> ketu = 0 <NEWLINE> tmp = <STRING> <NEWLINE> zeroichi = [ ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if tmp == s [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> zeroichi . append ( cnt ) <NEWLINE> cnt = 1 <NEWLINE> tmp = s [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> zeroichi . append ( cnt ) <NEWLINE> <NL> if len ( zeroichi ) % 2 == 0 : <NEWLINE> <INDENT> zeroichi . append ( 0 ) <NEWLINE> <NL> <DEDENT> if len ( zeroichi ) == 1 : <NEWLINE> <INDENT> zeroichi . append ( 0 ) <NEWLINE> zeroichi . append ( 0 ) <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> ans = 0 <NEWLINE> ans_list = [ ] <NEWLINE> j = 0 <NEWLINE> right = min ( 1 + k * 2 , len ( zeroichi ) ) <NEWLINE> left = 0 <NEWLINE> <NL> while i != right : <NEWLINE> <INDENT> ans += zeroichi [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> ans_list . append ( ans ) <NEWLINE> <NL> while right != len ( zeroichi ) : <NEWLINE> <INDENT> ans -= zeroichi [ left ] <NEWLINE> ans -= zeroichi [ left + 1 ] <NEWLINE> ans += zeroichi [ right ] <NEWLINE> ans += zeroichi [ right + 1 ] <NEWLINE> ans_list . append ( ans ) <NEWLINE> left += 2 <NEWLINE> right += 2 <NEWLINE> <NL> <DEDENT> print ( max ( ans_list ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v . sort ( ) <NEWLINE> ans = v [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = ( ans + v [ i ] ) / 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> b = [ A [ 0 ] ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> b . append ( b [ - 1 ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> cnt = Counter ( b ) <NEWLINE> cnt [ 0 ] += 1 <NEWLINE> <NL> for v in cnt . values ( ) : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import sys <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <DEDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> point = [ 0 ] * N <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a = a - 1 <NEWLINE> point [ a ] += b <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def dfs ( now , prev = - 1 ) : <NEWLINE> <INDENT> for next in graph [ now ] : <NEWLINE> <COMMENT> <NL> <INDENT> if next == prev : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> point [ next ] += point [ now ] <NEWLINE> <COMMENT> <NL> dfs ( next , now ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * point ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> count = 0 <NEWLINE> <NL> from bisect import bisect_left as bi <NEWLINE> <NL> for j in range ( N ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N - 1 ) : <NEWLINE> <INDENT> right = L [ j ] + L [ k ] <NEWLINE> ite_right = bi ( L , right ) <NEWLINE> count = count + ( ite_right - k - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , min ( k + i + 1 , len ( s ) + 1 ) ) : <NEWLINE> <INDENT> ans . append ( s [ i : j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = list ( set ( ans ) ) <NEWLINE> ans . sort ( ) <NEWLINE> print ( ans [ k - 1 ] ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> n = len ( S ) <NEWLINE> l_res = [ 0 ] <NEWLINE> r_res = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> l_res . append ( l_res [ i ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l_res . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> inv_S = S [ : : - 1 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if inv_S [ i ] == <STRING> : <NEWLINE> <INDENT> r_res . append ( r_res [ i ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r_res . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> res = 0 <NEWLINE> for l_cnt , r_cnt in zip ( l_res , r_res [ : : - 1 ] ) : <NEWLINE> <INDENT> res += max ( l_cnt , r_cnt ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> ACGT = <STRING> <NEWLINE> <NL> count = [ ] <NEWLINE> tmp_num = 0 <NEWLINE> for i in S : <NEWLINE> <INDENT> if i in ACGT : <NEWLINE> <INDENT> tmp_num += 1 <NEWLINE> <DEDENT> elif i not in ACGT : <NEWLINE> <INDENT> count . append ( tmp_num ) <NEWLINE> tmp_num = 0 <NEWLINE> <DEDENT> <DEDENT> count . append ( tmp_num ) <NEWLINE> <NL> print ( max ( count ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i , tgt in enumerate ( a , 1 ) : <NEWLINE> <INDENT> if a [ tgt - 1 ] == i : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt // 2 ) <NEWLINE>
class UnionFind : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <COMMENT> <NL> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <COMMENT> <NL> <INDENT> x , y = y , x <NEWLINE> <COMMENT> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> <COMMENT> <NL> self . parents [ y ] = x <NEWLINE> <DEDENT> def size ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <COMMENT> <NL> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <COMMENT> <NL> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <COMMENT> <NL> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> union = UnionFind ( n ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> union . union ( x - 1 , y - 1 ) <NEWLINE> <NL> <DEDENT> for cnt , j in enumerate ( p ) : <NEWLINE> <INDENT> if union . same ( cnt , j - 1 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N , X , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if not D : <NEWLINE> <INDENT> if not X : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> num_dict = dict ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> left_num = int ( i * X / D ) + int ( i * ( i - 1 ) / 2 ) <NEWLINE> right_num = int ( i * X / D ) + int ( i * ( 2 * N - 1 - i ) / 2 ) <NEWLINE> judge_num = i * X % D <NEWLINE> if not judge_num in num_dict : <NEWLINE> <INDENT> num_dict [ judge_num ] = [ ( left_num , right_num ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num_dict [ judge_num ] . append ( ( left_num , right_num ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for j , k in num_dict . items ( ) : <NEWLINE> <INDENT> new_k = sorted ( k ) <NEWLINE> L = new_k [ 0 ] [ 0 ] <NEWLINE> R = new_k [ 0 ] [ 1 ] <NEWLINE> for l in new_k : <NEWLINE> <INDENT> if l [ 0 ] <= R <= l [ 1 ] : <NEWLINE> <INDENT> R = l [ 1 ] <NEWLINE> <DEDENT> elif R < l [ 0 ] and R < l [ 1 ] : <NEWLINE> <INDENT> ans += R - L + 1 <NEWLINE> L , R = l [ 0 ] , l [ 1 ] <NEWLINE> <DEDENT> <DEDENT> ans += R - L + 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( A , min ( A + K , B + 1 ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> for i in range ( max ( A + K , B - K + 1 ) , B + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import numpy as np <NEWLINE> <NL> def main2 ( ) : <NEWLINE> <INDENT> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if A + K - 1 >= B - K + 1 : <NEWLINE> <INDENT> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( A , A + K ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( B - K + 1 , B + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> numbers = [ ] <NEWLINE> a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> numbers = np . arange ( a , b + 1 ) <NEWLINE> A = set ( numbers [ : k ] ) <NEWLINE> B = set ( numbers [ - k : ] ) <NEWLINE> answers = A | B <NEWLINE> <NL> for i in sorted ( answers ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main2 ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * ( n ) <NEWLINE> if k + 1 <= n : <NEWLINE> <INDENT> max = k + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max = n <NEWLINE> <NL> <DEDENT> for i in range ( 1 , max ) : <NEWLINE> <INDENT> dp [ i ] = abs ( h [ 0 ] - h [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( k , n ) : <NEWLINE> <INDENT> li = [ abs ( h [ i ] - h [ ik ] ) + dp [ ik ] for ik in range ( i - 1 , i - k - 1 , - 1 ) ] <NEWLINE> dp [ i ] = min ( li ) <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
import queue <NEWLINE> <NL> def bfs ( maze , h , w , sy , sx ) : <NEWLINE> <INDENT> dist = [ [ - 1 for _ in range ( w ) ] for _ in range ( h ) ] <NEWLINE> q = queue . deque ( [ [ sy , sx ] ] ) <NEWLINE> dist [ sy ] [ sx ] = 0 <NEWLINE> while q : <NEWLINE> <INDENT> y , x = q . popleft ( ) <NEWLINE> for dy , dx in d : <NEWLINE> <INDENT> ny , nx = y + dy , x + dx <NEWLINE> if 0 <= ny < h and 0 <= nx < w and dist [ ny ] [ nx ] == - 1 and maze [ ny ] [ nx ] != <STRING> : <NEWLINE> <INDENT> dist [ ny ] [ nx ] = dist [ y ] [ x ] + 1 <NEWLINE> q . append ( [ ny , nx ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return max ( [ max ( i ) for i in dist ] ) <NEWLINE> <NL> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ input ( ) for _ in range ( h ) ] <NEWLINE> d = [ [ 1 , 0 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] <NEWLINE> ans = 0 <NEWLINE> for sy in range ( h ) : <NEWLINE> <INDENT> for sx in range ( w ) : <NEWLINE> <INDENT> if a [ sy ] [ sx ] != <STRING> : <NEWLINE> <INDENT> ans = max ( ans , bfs ( a , h , w , sy , sx ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . append ( 0 ) <NEWLINE> s = sum ( p [ : k ] ) <NEWLINE> t = 0 <NEWLINE> for i in range ( k - 1 , n ) : <NEWLINE> <INDENT> t = max ( t , ( k + s ) / 2 ) <NEWLINE> s -= p [ i - k + 1 ] <NEWLINE> s += p [ i + 1 ] <NEWLINE> <DEDENT> print ( t ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> l = [ [ ] for i in range ( n ) ] <COMMENT> <NEWLINE> m = [ [ ] for i in range ( n - k + 1 ) ] <COMMENT> <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> l [ i ] = ( 1 + p [ i ] ) / 2 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> m [ 0 ] = sum ( l [ 0 : k ] ) <NEWLINE> ans = m [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> m [ i ] = m [ i - 1 ] - l [ i - 1 ] + l [ i + k - 1 ] <NEWLINE> if m [ i ] > ans : <NEWLINE> <INDENT> ans = m [ i ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> S = defaultdict ( int ) <NEWLINE> for i in input ( ) : <NEWLINE> <INDENT> S [ i ] += 1 <NEWLINE> <NL> <DEDENT> if len ( S . values ( ) ) == 2 : <NEWLINE> <INDENT> a , b = S . values ( ) <NEWLINE> if a == b == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> allcount = 0 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> vans = i <NEWLINE> while True : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif i % 2 == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> i //= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if count > allcount : <NEWLINE> <INDENT> allcount = count <NEWLINE> ans = vans <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> alp = <STRING> <NEWLINE> <NL> if s == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> d = { } <NEWLINE> e = { } <NEWLINE> for i in range ( len ( alp ) ) : <NEWLINE> <INDENT> d [ alp [ i ] ] = i <NEWLINE> e [ i ] = alp [ i ] <NEWLINE> <NL> <DEDENT> n = len ( s ) <NEWLINE> if n != 26 : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( d [ s [ i ] ] ) <NEWLINE> <NL> <DEDENT> for j in range ( 26 ) : <NEWLINE> <INDENT> if j not in ans : <NEWLINE> <INDENT> ans . append ( j ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> st = <STRING> <NEWLINE> for k in ans : <NEWLINE> <INDENT> st += e [ k ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> <NL> dp = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dp . append ( d [ s [ i ] ] ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> v = dp . pop ( ) <NEWLINE> <NL> tmp = [ j for j in arr if j > v ] <NEWLINE> if len ( tmp ) != 0 : <NEWLINE> <INDENT> dp . append ( min ( tmp ) ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> arr . append ( v ) <NEWLINE> <NL> <DEDENT> st = <STRING> <NEWLINE> for k in dp : <NEWLINE> <INDENT> st += e [ k ] <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( st ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a_s = set ( a ) <NEWLINE> cnt = 0 <NEWLINE> order = 1 <NEWLINE> if not 1 in a_s : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] != order : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if a [ i ] == order : <NEWLINE> <INDENT> order += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( A ) <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> CB = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> CB . append ( ( c , b ) ) <NEWLINE> <DEDENT> CB . sort ( reverse = True ) <NEWLINE> for c , b in CB : <NEWLINE> <INDENT> for j in range ( b ) : <NEWLINE> <INDENT> tmp = heapq . heappop ( A ) <NEWLINE> if tmp >= c : <NEWLINE> <INDENT> heapq . heappush ( A , tmp ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> heapq . heappush ( A , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> LR = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> LR . append ( [ l , r ] ) <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> p = 0 <NEWLINE> C = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> p = 1 <NEWLINE> <DEDENT> elif p == 1 and s [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> p = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = 0 <NEWLINE> <DEDENT> C . append ( c ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l = LR [ i ] [ 0 ] <NEWLINE> r = LR [ i ] [ 1 ] <NEWLINE> ans = C [ r - 1 ] - C [ l - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> from collections import deque <NEWLINE> b = deque ( [ ] ) <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> b . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . appendleft ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> print ( * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( * reversed ( b ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> x = input ( ) <NEWLINE> while <STRING> in x : <NEWLINE> <INDENT> x = x . replace ( <STRING> , <STRING> ) <NEWLINE> <COMMENT> <NL> n = len ( x ) // 2 <NEWLINE> if ( <STRING> not in x [ : n ] ) and ( <STRING> not in x [ n : ] ) : <NEWLINE> <INDENT> x = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( len ( x ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> num_lists = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num_counts = dict ( ) <NEWLINE> length = len ( set ( num_lists ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if length > k : <NEWLINE> <INDENT> d = Counter ( ) <NEWLINE> d . update ( num_lists ) <NEWLINE> count_sorted = list ( d . values ( ) ) <NEWLINE> count_sorted . sort ( ) <NEWLINE> for i in range ( length - k ) : <NEWLINE> <INDENT> ans += count_sorted [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> k = { } <NEWLINE> def y ( p ) : <NEWLINE> <INDENT> if p in k . keys ( ) : <NEWLINE> <INDENT> return k [ p ] <NEWLINE> <DEDENT> if p == 0 : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> elif p == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k [ p ] = y ( p - 2 ) + y ( p - 1 ) <NEWLINE> return k [ p ] <NEWLINE> <DEDENT> <DEDENT> print ( y ( N ) ) <NEWLINE>
def dfs ( i , sum , count , rest ) : <NEWLINE> <INDENT> global ans <NEWLINE> if i == d : <NEWLINE> <INDENT> if sum < g : <NEWLINE> <INDENT> rest_max = max ( rest ) <NEWLINE> n = min ( l [ rest_max - 1 ] [ 0 ] , - ( - ( g - sum ) // ( rest_max * 100 ) ) ) <NEWLINE> count += n <NEWLINE> sum += n * rest_max * 100 <NEWLINE> <DEDENT> if sum >= g : <NEWLINE> <INDENT> ans = min ( ans , count ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dfs ( i + 1 , sum , count , rest ) <COMMENT> <NEWLINE> dfs ( i + 1 , sum + l [ i ] [ 0 ] * ( i + 1 ) * 100 + l [ i ] [ 1 ] , count + l [ i ] [ 0 ] , rest - { i + 1 } ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> d , g = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( ( map ( int , input ( ) . split ( ) ) ) ) for _ in range ( d ) ] <NEWLINE> ans = float ( <STRING> ) <NEWLINE> dfs ( 0 , 0 , 0 , set ( range ( 1 , d + 1 ) ) ) <NEWLINE> print ( ans ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> Tree = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> Counter = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> AB = ( tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ) <NEWLINE> PX = ( tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ) <NEWLINE> <NL> for a , b in AB : <NEWLINE> <INDENT> Tree [ a ] . append ( b ) <NEWLINE> Tree [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for p , x in PX : <NEWLINE> <INDENT> Counter [ p ] += x <NEWLINE> <NL> <DEDENT> P = [ - 1 ] * ( n + 1 ) <NEWLINE> <NL> nodes = [ 1 ] <NEWLINE> while nodes : <NEWLINE> <INDENT> parent = nodes . pop ( ) <NEWLINE> for node_i in Tree [ parent ] : <NEWLINE> <INDENT> if P [ parent ] == node_i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> P [ node_i ] = parent <NEWLINE> nodes . append ( node_i ) <NEWLINE> Counter [ node_i ] += Counter [ parent ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * Counter [ 1 : ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> score = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = int ( input ( ) ) <NEWLINE> score . append ( s ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> non10 = [ ] <NEWLINE> flg10 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if score [ i ] % 10 != 0 : <NEWLINE> <INDENT> non10 . append ( score [ i ] ) <NEWLINE> flg10 = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flg10 == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if sum ( score ) % 10 == 0 : <NEWLINE> <INDENT> ans = sum ( score ) - min ( non10 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = sum ( score ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> ans = [ ] <NEWLINE> n = 1 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if <STRING> in S [ i ] : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if S [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> for _ in range ( j + 1 - len ( ans ) ) : <NEWLINE> <INDENT> ans . append ( str ( n ) ) <NEWLINE> <DEDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> if len ( ans ) < w : <NEWLINE> <INDENT> x = ans [ - 1 ] <NEWLINE> for _ in range ( w - len ( ans ) ) : <NEWLINE> <INDENT> ans . append ( x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> for _ in range ( i + 1 - cnt ) : <NEWLINE> <INDENT> print ( <STRING> . join ( ans ) ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
with open ( 0 ) as f : <NEWLINE> <INDENT> N , * xy = map ( int , f . read ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> from collections import namedtuple <NEWLINE> v = namedtuple ( <STRING> , [ <STRING> , <STRING> ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> X = sorted ( [ v ( x , i ) for x , i in zip ( xy [ : : 2 ] , range ( N ) ) ] ) <NEWLINE> Y = sorted ( [ v ( y , i ) for y , i in zip ( xy [ 1 : : 2 ] , range ( N ) ) ] ) <NEWLINE> <NL> diffiter = lambda X : zip ( X [ : len ( X ) - 1 ] , X [ 1 : ] ) <COMMENT> <NEWLINE> cost = lambda u , v : abs ( u . coordinate - v . coordinate ) <NEWLINE> from itertools import chain <NEWLINE> Edge = sorted ( [ ( cost ( u , v ) , u . num , v . num ) for u , v in chain ( diffiter ( X ) , diffiter ( Y ) ) ] ) <NEWLINE> <NL> root = namedtuple ( <STRING> , [ <STRING> , <STRING> ] ) <COMMENT> <NEWLINE> Root = [ root ( i , 0 ) for i in range ( N ) ] <NEWLINE> <NL> def fr ( i ) : <COMMENT> <NEWLINE> <INDENT> if i == Root [ i ] . num : <NEWLINE> <INDENT> return Root [ i ] <NEWLINE> <DEDENT> Root [ i ] = fr ( Root [ i ] . num ) <NEWLINE> return Root [ i ] <NEWLINE> <NL> <NL> <DEDENT> def unionT ( i , j ) : <COMMENT> <NEWLINE> <INDENT> p , q = fr ( i ) , fr ( j ) <NEWLINE> if p . rank < q . rank : <NEWLINE> <INDENT> Root [ p . num ] = q <NEWLINE> <DEDENT> elif p . rank > q . rank : <NEWLINE> <INDENT> Root [ q . num ] = p <NEWLINE> <DEDENT> elif p . rank == q . rank : <NEWLINE> <INDENT> r , s = min ( p , q ) , max ( p , q ) <NEWLINE> Root [ r . num ] = Root [ s . num ] = root ( r . num , r . rank + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for w , i , j in Edge : <NEWLINE> <INDENT> if fr ( i ) . num == fr ( j ) . num : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> unionT ( i , j ) <NEWLINE> ans += w <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> i = 0 <NEWLINE> hidari = str ( ) <NEWLINE> migi = str ( ) <NEWLINE> a = 0 <NEWLINE> while i < N : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> hidari += <STRING> <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> while i < N : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if a < 0 : <NEWLINE> <INDENT> hidari += abs ( a ) * <STRING> <NEWLINE> <DEDENT> elif a > 0 : <NEWLINE> <INDENT> migi += a * <STRING> <NEWLINE> <DEDENT> s = hidari + S + migi <NEWLINE> <NL> <NL> i = 0 <NEWLINE> hidari = str ( ) <NEWLINE> migi = str ( ) <NEWLINE> a = 0 <NEWLINE> while i < N : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> hidari += <STRING> <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> while i < N : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> a += 1 <NEWLINE> mina = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= 1 <NEWLINE> if a < 0 : <NEWLINE> <INDENT> if mina > a : <NEWLINE> <INDENT> hidari += <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> if a > 0 : <NEWLINE> <INDENT> migi += a * <STRING> <NEWLINE> <DEDENT> t = hidari + S + migi <NEWLINE> if len ( s ) == len ( t ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> elif len ( s ) > len ( t ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ input ( ) for _ in range ( h ) ] <NEWLINE> visited = [ [ 0 ] * w for _ in range ( h ) ] <NEWLINE> moves = ( ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if not visited [ i ] [ j ] : <NEWLINE> <INDENT> bcnt , wcnt = 0 , 0 <NEWLINE> q = deque ( [ ( i , j ) ] ) <NEWLINE> while q : <NEWLINE> <INDENT> cx , cy = q . popleft ( ) <NEWLINE> if visited [ cx ] [ cy ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if grid [ cx ] [ cy ] == <STRING> : <NEWLINE> <INDENT> bcnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wcnt += 1 <NEWLINE> <DEDENT> visited [ cx ] [ cy ] = 1 <NEWLINE> for ( dx , dy ) in moves : <NEWLINE> <INDENT> if 0 <= cx + dx < h and 0 <= cy + dy < w and not visited [ cx + dx ] [ cy + dy ] and grid [ cx + dx ] [ cy + dy ] != grid [ cx ] [ cy ] : <NEWLINE> <INDENT> q . append ( ( cx + dx , cy + dy ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans += bcnt * wcnt <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cut = 0 <NEWLINE> throw = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cut = max ( cut , a ) <NEWLINE> throw . append ( b ) <NEWLINE> <NL> <DEDENT> throw . sort ( reverse = True ) <NEWLINE> throw_cam = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if cut > throw [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i == 0 : <NEWLINE> <INDENT> throw_cam . append ( throw [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> throw_cam . append ( throw [ i ] + throw_cam [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if throw_cam [ len ( throw_cam ) - 1 ] < h : <NEWLINE> <INDENT> rh = h - throw_cam [ len ( throw_cam ) - 1 ] <NEWLINE> if rh % cut == 0 : <NEWLINE> <INDENT> print ( len ( throw_cam ) + rh // cut ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( throw_cam ) + rh // cut + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( throw_cam ) ) : <NEWLINE> <INDENT> d = throw_cam [ i ] <NEWLINE> if d >= h : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> from collections import deque <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( len ( s [ 0 ] ) ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> pre = 0 <NEWLINE> p = np . full ( ( h , w ) , - 1 ) <NEWLINE> p [ i ] [ j ] = 0 <NEWLINE> check = deque ( [ ( ( i , j ) , 0 ) ] ) <COMMENT> <NEWLINE> while check : <NEWLINE> <INDENT> now , d = check . popleft ( ) <NEWLINE> pre = max ( pre , d ) <NEWLINE> for k , l in [ ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ] : <NEWLINE> <INDENT> b = now [ 0 ] + k <NEWLINE> c = now [ 1 ] + l <NEWLINE> if b < 0 or c < 0 or b >= h or c >= w : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif p [ b ] [ c ] == - 1 and s [ b ] [ c ] != <STRING> : <NEWLINE> <INDENT> check . append ( ( ( b , c ) , d + 1 ) ) <NEWLINE> p [ b ] [ c ] = d + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = max ( ans , pre ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> score = [ 0 ] * n <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> score [ a - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> s = k + score [ i ] - q <NEWLINE> if s > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
import numpy as np <NEWLINE> <NL> class SieveOfEratosthenes : <NEWLINE> <INDENT> def __init__ ( self , V ) : <NEWLINE> <INDENT> self . is_prime = np . ones ( V + 1 , dtype = bool ) <NEWLINE> self . is_prime [ 2 : : 2 ] = False <NEWLINE> self . is_prime [ 3 : : 3 ] = False <NEWLINE> self . is_prime [ 5 : : 5 ] = False <NEWLINE> self . primes = [ 2 , 3 , 5 ] <NEWLINE> for i in range ( 7 , V + 1 , 2 ) : <NEWLINE> <INDENT> if self . is_prime [ i ] : <NEWLINE> <INDENT> self . primes . append ( i ) <NEWLINE> if i * i < V + 1 : <NEWLINE> <INDENT> self . is_prime [ i * i : : i ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def factorize ( self , x , return_dict = False ) : <NEWLINE> <INDENT> if x == 1 : <NEWLINE> <INDENT> return { 1 : 1 } if return_dict else [ ( 1 , 1 ) ] <NEWLINE> <DEDENT> result = [ ] <NEWLINE> for p in self . primes : <NEWLINE> <INDENT> exp = 0 <NEWLINE> while x % p == 0 : <NEWLINE> <INDENT> exp += 1 <NEWLINE> x = x // p <NEWLINE> <DEDENT> if exp > 0 : <NEWLINE> <INDENT> result . append ( ( p , exp ) ) <NEWLINE> <DEDENT> if p * p > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if x > 1 : <NEWLINE> <INDENT> result . append ( ( x , 1 ) ) <NEWLINE> <DEDENT> if return_dict : <NEWLINE> <INDENT> result = { p : e for p , e in result } <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> M = 10 ** 9 + 7 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sieve = SieveOfEratosthenes ( 10 ** 3 ) <NEWLINE> F = [ sieve . factorize ( a , return_dict = True ) for a in A ] <NEWLINE> <NL> lcm = F [ 0 ] <NEWLINE> for i in range ( 1 , len ( F ) ) : <NEWLINE> <INDENT> for p , e in F [ i ] . items ( ) : <NEWLINE> <INDENT> if p in lcm : <NEWLINE> <INDENT> lcm [ p ] = max ( lcm [ p ] , e ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lcm [ p ] = e <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> val = 1 <NEWLINE> for p , e in lcm . items ( ) : <NEWLINE> <INDENT> val = val * pow ( p , e , M ) % M <NEWLINE> <NL> <DEDENT> B = [ val * pow ( a , M - 2 , M ) % M for a in A ] <NEWLINE> print ( sum ( B ) % M ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> N , Q = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> connection = { i : set ( ) for i in range ( 1 , N + 1 ) } <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> connection [ a ] . add ( b ) <NEWLINE> connection [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> point = { i : 0 for i in range ( 1 , N + 1 ) } <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> point [ p ] += x <NEWLINE> <NL> <DEDENT> def DFS ( now , prev = - 1 ) : <NEWLINE> <INDENT> for next in connection [ now ] : <NEWLINE> <COMMENT> <NL> <INDENT> if next == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> point [ next ] += point [ now ] <NEWLINE> DFS ( next , now ) <NEWLINE> <NL> <DEDENT> <DEDENT> DFS ( 1 ) <NEWLINE> print ( * point . values ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> ans = sorted ( a ) <NEWLINE> max1 = ans [ - 1 ] <NEWLINE> max2 = ans [ - 2 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == max1 : <NEWLINE> <INDENT> print ( max2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max1 ) <NEWLINE> <DEDENT> <DEDENT>
N , M , X = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> r_count = 0 <NEWLINE> l_count = 0 <NEWLINE> <NL> tmp_1 = X <NEWLINE> tmp_2 = X <NEWLINE> <NL> <NL> while tmp_1 != N : <NEWLINE> <INDENT> tmp_1 += 1 <NEWLINE> if tmp_1 in A : <NEWLINE> <INDENT> r_count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> while tmp_2 != 0 : <NEWLINE> <INDENT> tmp_2 -= 1 <NEWLINE> if tmp_2 in A : <NEWLINE> <INDENT> l_count += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> res = min ( l_count , r_count ) <NEWLINE> print ( res ) <NEWLINE>
import heapq <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = - A [ i ] <NEWLINE> <DEDENT> heapq . heapify ( A ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> trgt = - heapq . heappop ( A ) // 2 <NEWLINE> heapq . heappush ( A , - trgt ) <NEWLINE> <DEDENT> print ( - sum ( A ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> dic = defaultdict ( bool ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> dic [ a ] = not dic [ a ] <NEWLINE> <NL> <DEDENT> print ( sum ( dic . values ( ) ) ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - ( x + y ) <NEWLINE> if 0 <= z and z <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> a_list = [ ] <NEWLINE> <NL> b_list = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list . append ( a ) <NEWLINE> b_list . append ( b ) <NEWLINE> <NL> <DEDENT> a_list = a_list [ : : - 1 ] <NEWLINE> b_list = b_list [ : : - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> st = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a_list [ i ] += st <NEWLINE> if a_list [ i ] % b_list [ i ] : <NEWLINE> <INDENT> if a_list [ i ] < b_list [ i ] : <NEWLINE> <INDENT> st += b_list [ i ] - a_list [ i ] <NEWLINE> <DEDENT> elif a_list [ i ] > b_list [ i ] : <NEWLINE> <INDENT> st += b_list [ i ] * ( ( a_list [ i ] // b_list [ i ] ) + 1 ) - a_list [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( st ) <NEWLINE>
D , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N != 100 : <NEWLINE> <INDENT> if D == 0 : <NEWLINE> <INDENT> print ( N ) <NEWLINE> <DEDENT> elif D == 1 : <NEWLINE> <INDENT> x = [ 100 * i for i in range ( 1 , 101 ) ] <NEWLINE> print ( x [ N - 1 ] ) <NEWLINE> <DEDENT> elif D == 2 : <NEWLINE> <INDENT> x = [ 10000 * i for i in range ( 1 , 101 ) ] <NEWLINE> print ( x [ N - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if D == 0 : <NEWLINE> <INDENT> print ( 101 ) <NEWLINE> <DEDENT> elif D == 1 : <NEWLINE> <INDENT> x = [ 100 * i for i in range ( 1 , 101 ) ] <NEWLINE> print ( x [ N - 1 ] + 100 ) <NEWLINE> <DEDENT> elif D == 2 : <NEWLINE> <INDENT> x = [ 10000 * i for i in range ( 1 , 101 ) ] <NEWLINE> print ( x [ N - 1 ] + 10000 ) <NEWLINE> <DEDENT> <DEDENT>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> count += bisect . bisect_left ( l , l [ i ] + l [ j ] ) - j - 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> participants = sorted ( [ int ( v ) for v in input ( ) . split ( <STRING> ) ] , reverse = True ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> sum = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> sum += participants [ 2 * i + 1 ] <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( int ( input ( ) ) for _ in range ( q ) ) <NEWLINE> p = [ k - q ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( 1 , q + 1 ) : <NEWLINE> <INDENT> p [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if p [ j ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> Y //= 1000 <NEWLINE> for nog in range ( N + 1 ) : <NEWLINE> <INDENT> for hig in range ( N + 1 - nog ) : <NEWLINE> <INDENT> yuk = N - nog - hig <NEWLINE> if nog + hig * 5 + yuk * 10 == Y : <NEWLINE> <INDENT> print ( yuk , hig , nog ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a == b == c : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> a_ = b + c <NEWLINE> b_ = a + c <NEWLINE> c_ = a + b <NEWLINE> <NL> if k == 0 : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif k % 2 == 0 : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a_ - b_ ) <NEWLINE> <DEDENT>
import sys <NEWLINE> stdin = sys . stdin <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( ns ( ) ) <NEWLINE> def na ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = ni ( ) <NEWLINE> a = na ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 61 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for ai in a : <NEWLINE> <INDENT> if ( ai >> i ) & 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ans += ( ( cnt * ( n - cnt ) ) * 2 ** i ) % mod <NEWLINE> <DEDENT> ans %= mod <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from collections import deque <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> INF = 10 ** 18 <NEWLINE> arr = deque ( [ ] ) <NEWLINE> for a in A : <NEWLINE> <INDENT> l , r = - 1 , len ( arr ) <NEWLINE> while ( r - l ) > 1 : <NEWLINE> <INDENT> mid = ( r + l ) // 2 <NEWLINE> if arr [ mid ] < a : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> <DEDENT> if l == - 1 : <NEWLINE> <INDENT> arr . appendleft ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr [ l ] = a <NEWLINE> <DEDENT> <DEDENT> print ( len ( arr ) ) <NEWLINE>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> A [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] > Q - K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> d = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cd = collections . Counter ( d ) <NEWLINE> ct = collections . Counter ( t ) <NEWLINE> <NL> flg = True <NEWLINE> for k in ct . items ( ) : <NEWLINE> <INDENT> if k [ 1 ] > cd [ k [ 0 ] ] : <NEWLINE> <INDENT> flg = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> if flg else <STRING> ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , numpy , string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> P = LI ( ) <NEWLINE> ans = 0 <NEWLINE> min_num = P [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if min_num >= P [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> min_num = P [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <NL>
import sys <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> import itertools <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = 10 ** 20 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> ni = lambda : int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> ns = lambda : map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> na = lambda : list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> na1 = lambda : list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> k = ni ( ) <NEWLINE> l = 50 <NEWLINE> ans = [ l - 1 for _ in range ( l ) ] <NEWLINE> <NL> for i in range ( l ) : <NEWLINE> <INDENT> ans [ i ] += k // l <NEWLINE> <NL> <DEDENT> for i in range ( l ) : <NEWLINE> <INDENT> tgt = k % l <NEWLINE> if i < tgt : <NEWLINE> <INDENT> ans [ i ] += l <NEWLINE> ans [ i ] -= tgt - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] -= tgt <NEWLINE> <NL> <DEDENT> <DEDENT> print ( l ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> xyh = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y , h = map ( int , input ( ) . split ( ) ) <NEWLINE> xyh [ i ] . append ( x ) <NEWLINE> xyh [ i ] . append ( y ) <NEWLINE> xyh [ i ] . append ( h ) <NEWLINE> <DEDENT> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> f = 0 <NEWLINE> dis = [ [ i ] for i in range ( 205 ) ] <NEWLINE> for q in range ( n ) : <NEWLINE> <INDENT> x = xyh [ q ] [ 0 ] <NEWLINE> y = xyh [ q ] [ 1 ] <NEWLINE> h = xyh [ q ] [ 2 ] <NEWLINE> d = abs ( x - i ) + abs ( y - j ) <NEWLINE> <NL> if len ( dis [ d ] ) == 1 : <NEWLINE> <INDENT> dis [ d ] . append ( h ) <NEWLINE> <DEDENT> elif len ( dis [ d ] ) != 1 and dis [ d ] [ 1 ] != h : <NEWLINE> <INDENT> f = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> dis = [ dis [ e ] for e in range ( 205 ) if len ( dis [ e ] ) != 1 ] <NEWLINE> m = len ( dis ) <NEWLINE> if m == 1 and f == 0 : <NEWLINE> <INDENT> print ( i , j , dis [ 0 ] [ 0 ] + dis [ 0 ] [ 1 ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if all ( dis [ e ] [ 0 ] + dis [ e ] [ 1 ] == dis [ e + 1 ] [ 0 ] + dis [ e + 1 ] [ 1 ] for e in range ( m - 1 ) if dis [ e + 1 ] [ 1 ] != 0 ) and f == 0 : <NEWLINE> <INDENT> print ( i , j , dis [ 0 ] [ 0 ] + dis [ 0 ] [ 1 ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<NL> url = <STRING> <NEWLINE> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = 10000000000000000 <NEWLINE> ns = make_divisors ( n ) <NEWLINE> for i in range ( 0 , ( len ( ns ) // 2 ) + 1 ) : <NEWLINE> <INDENT> tmp = max ( len ( str ( ns [ i ] ) ) , len ( str ( ns [ len ( ns ) - i - 1 ] ) ) ) <NEWLINE> ans = tmp if tmp < ans else ans <NEWLINE> <DEDENT> if len ( ns ) % 2 != 0 : <NEWLINE> <INDENT> tmp = len ( str ( ns [ len ( ns ) // 2 ] ) ) <NEWLINE> ans = tmp if tmp < ans else ans <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> print ( ans [ j ] , end = <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> week = input ( ) <NEWLINE> if week == <STRING> : <NEWLINE> <INDENT> result = 1 <NEWLINE> <DEDENT> elif week == <STRING> : <NEWLINE> <INDENT> result = 2 <NEWLINE> <DEDENT> elif week == <STRING> : <NEWLINE> <INDENT> result = 3 <NEWLINE> <DEDENT> elif week == <STRING> : <NEWLINE> <INDENT> result = 4 <NEWLINE> <DEDENT> elif week == <STRING> : <NEWLINE> <INDENT> result = 5 <NEWLINE> <DEDENT> elif week == <STRING> : <NEWLINE> <INDENT> result = 6 <NEWLINE> <DEDENT> elif week == <STRING> : <NEWLINE> <INDENT> result = 7 <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def RD ( ) : return input ( ) . rstrip ( ) . decode ( ) <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> def FI ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MF ( ) : return map ( float , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LF ( ) : return list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> def TI ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = II ( ) <NEWLINE> A = [ II ( ) for _ in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> now = 0 <NEWLINE> cnt = 1 <NEWLINE> ans = - 1 <NEWLINE> for i in range ( n + 5 ) : <NEWLINE> <INDENT> now = A [ now ] - 1 <NEWLINE> if now == 1 : <NEWLINE> <INDENT> ans = cnt <NEWLINE> break <NEWLINE> <DEDENT> elif now == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> L [ i + 1 ] += L [ i ] <NEWLINE> if X [ i ] > L [ i ] * 2 : <NEWLINE> <INDENT> L [ i + 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> L [ i ] = i - L [ i ] <NEWLINE> <NL> <DEDENT> d = Counter ( L ) <NEWLINE> ans = 1 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( 10 ** 5 ) : <NEWLINE> <INDENT> tmp += d [ i ] <NEWLINE> if tmp == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans *= tmp <NEWLINE> ans %= mod <NEWLINE> tmp -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ 0 for n in range ( N ) ] <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> L [ A - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> if K - ( Q - L [ j ] ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> for i in a [ - 1 : : - 2 ] : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> for i in a [ ( n % 2 == 1 ) : : 2 ] : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> print ( * b ) <NEWLINE>
from collections import deque <NEWLINE> A = deque ( map ( str , input ( ) ) ) <NEWLINE> B = deque ( map ( str , input ( ) ) ) <NEWLINE> C = deque ( map ( str , input ( ) ) ) <NEWLINE> x = A . popleft ( ) <NEWLINE> for _ in range ( 10000000 ) : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> if A : <NEWLINE> <INDENT> x = A . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> if B : <NEWLINE> <INDENT> x = B . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if C : <NEWLINE> <INDENT> x = C . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 2018 <NEWLINE> <NL> if r - l > 2018 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , ( i * j ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> j = 1 <NEWLINE> <NL> for i in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ( - 1 , n - j + 1 ) [ j != 1 ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ [ ] for _ in range ( m + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = [ int ( inp ) for inp in input ( ) . split ( ) ] <NEWLINE> if t [ 0 ] <= m : <NEWLINE> <INDENT> ab [ t [ 0 ] ] . append ( - t [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> import heapq <NEWLINE> h = ab [ 1 ] <NEWLINE> heapq . heapify ( h ) <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> if len ( h ) > 0 : <NEWLINE> <INDENT> ans += heapq . heappop ( h ) <NEWLINE> <DEDENT> if i != m : <NEWLINE> <INDENT> for t in ab [ i + 1 ] : <NEWLINE> <INDENT> heapq . heappush ( h , t ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( - ans ) <NEWLINE>
from collections import Counter <NEWLINE> import numpy as np <NEWLINE> n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a_ = int ( input ( ) ) <NEWLINE> a . append ( a_ ) <NEWLINE> <NL> <NL> <DEDENT> listn_ = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> listn_ . append ( k ) <NEWLINE> <DEDENT> listn = np . array ( listn_ ) <NEWLINE> listn = listn - q <NEWLINE> s = Counter ( a ) <NEWLINE> for i in s . keys ( ) : <NEWLINE> <INDENT> listn [ i - 1 ] += s [ i ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in listn : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> seat = [ 0 ] * 100000 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , list ( input ( ) . split ( ) ) ) <NEWLINE> for j in range ( a , b + 1 ) : <NEWLINE> <INDENT> seat [ j - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( seat ) ) <NEWLINE>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> price = X * A + Y * B <NEWLINE> for a in [ 0 , abs ( X - Y ) , X ] : <NEWLINE> <INDENT> for b in [ 0 , abs ( X - Y ) , Y ] : <NEWLINE> <INDENT> c = max ( X - a , Y - b ) * 2 <NEWLINE> price = min ( price , a * A + b * B + c * C ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( price ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> for i in range ( len ( s ) - len ( t ) + 1 ) [ : : - 1 ] : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> q = 0 <NEWLINE> for j in range ( len ( t ) ) [ : : - 1 ] : <NEWLINE> <INDENT> if s [ i + j ] == <STRING> : <NEWLINE> <INDENT> q += 1 <NEWLINE> <DEDENT> elif s [ i + j ] == t [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt == len ( t ) - q : <NEWLINE> <INDENT> idx = i <NEWLINE> s = s [ : idx ] + t + s [ idx + len ( t ) : ] <NEWLINE> for k in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ k ] == <STRING> : <NEWLINE> <INDENT> s = s [ : k ] + <STRING> + s [ k + 1 : ] <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> res = n * m // gcd ( n , m ) <NEWLINE> a = m // gcd ( n , m ) <NEWLINE> b = n // gcd ( n , m ) <NEWLINE> if n >= m : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> if ( i * b ) % a == 0 : <NEWLINE> <INDENT> if s [ ( i * b ) // a ] != t [ i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( i * a ) % b == 0 : <NEWLINE> <INDENT> if s [ i ] != t [ ( i * a ) // b ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> def isinsums ( x , lst ) : <NEWLINE> <INDENT> s = sum ( lst ) <NEWLINE> t = ( s + x ) // 2 <NEWLINE> if s == 0 and x == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if ( s - x ) % 2 or t < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> t = ( s + x ) // 2 <NEWLINE> m1 = ( 1 << ( t + 1 ) ) - 1 <NEWLINE> m2 = 1 << t <NEWLINE> sums = 0 <NEWLINE> for e in lst : <NEWLINE> <INDENT> sums = ( sums | ( 1 + sums ) << e ) & m1 <NEWLINE> <DEDENT> sums |= 1 <NEWLINE> if ( sums ) & m2 > 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> s = readline ( ) . strip ( ) <NEWLINE> x , y = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> bs = s . split ( ) <NEWLINE> if bs [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> x -= len ( bs [ 0 ] ) <NEWLINE> del bs [ 0 ] <NEWLINE> <NL> <DEDENT> xy = [ [ ] , [ ] ] <NEWLINE> f = 0 <NEWLINE> for i , e in enumerate ( bs ) : <NEWLINE> <INDENT> if not i % 2 : <NEWLINE> <INDENT> l = len ( e ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f ^= l % 2 <NEWLINE> xy [ f ] . append ( len ( e ) ) <NEWLINE> <DEDENT> <DEDENT> if isinsums ( x , xy [ 0 ] ) and isinsums ( y , xy [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> @ njit ( cache = True ) <NEWLINE> def main ( N , s ) : <NEWLINE> <INDENT> dpt = np . zeros ( ( N + 1 , N + 1 ) , dtype = np . int16 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N + 1 ) : <NEWLINE> <INDENT> if s [ j - 1 ] == s [ i - 1 ] : <NEWLINE> <INDENT> if j - dpt [ i - 1 ] [ j - 1 ] > i : <NEWLINE> <INDENT> dpt [ i ] [ j ] = dpt [ i - 1 ] [ j - 1 ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return np . amax ( dpt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> s = np . array ( [ ord ( c ) for c in input ( ) ] ) <NEWLINE> <NL> print ( main ( N , s ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> R = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> R [ a - 1 ] . append ( ( b - 1 , c ) ) <NEWLINE> <NL> <DEDENT> INF = 10 ** 40 <NEWLINE> S = [ - INF ] * N <NEWLINE> S [ 0 ] = 0 <NEWLINE> <NL> def score ( fst , s , C ) : <NEWLINE> <INDENT> for nx , p in R [ fst ] : <NEWLINE> <INDENT> if S [ nx ] >= s + p or S [ nx ] >= INF : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> S [ nx ] = s + p <NEWLINE> if nx in C : <NEWLINE> <INDENT> S [ nx ] = INF <NEWLINE> <DEDENT> C [ nx ] = C . get ( nx , 0 ) + 1 <NEWLINE> score ( nx , S [ nx ] , C ) <NEWLINE> C [ nx ] -= 1 <NEWLINE> if C [ nx ] == 0 : <NEWLINE> <INDENT> del C [ nx ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> score ( 0 , 0 , { 0 : 1 } ) <NEWLINE> <NL> if S [ - 1 ] < INF : <NEWLINE> <INDENT> ans = S [ - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> np_ab = np . array ( ab ) <NEWLINE> <NL> max_a = max ( np_ab [ : , 0 ] ) <NEWLINE> dp = [ 0 ] * ( h + max_a ) <NEWLINE> <NL> for i in range ( 1 , h + max_a ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + b for a , b in ab ) <NEWLINE> <NL> <DEDENT> print ( dp [ h ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = max ( L ) <NEWLINE> b = a <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if b >= abs ( L [ i ] - a / 2 ) and L [ i ] != a : <NEWLINE> <INDENT> b = abs ( L [ i ] - a / 2 ) <NEWLINE> c = L [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( a , c ) <NEWLINE>
ans = 0 <NEWLINE> K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - x - y and S - x - y <= K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a [ 0 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = sorted ( a ) <NEWLINE> d = { } <NEWLINE> for av in a : <NEWLINE> <INDENT> if av not in d : <NEWLINE> <INDENT> d [ av ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ av ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if a [ 0 ] != 0 or d [ 0 ] != 1 or len ( set ( d . keys ( ) ) ) != a [ - 1 ] + 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> MOD = 998244353 <NEWLINE> ans = 1 <NEWLINE> for i in range ( 2 , a [ - 1 ] + 1 ) : <NEWLINE> <INDENT> ans *= pow ( d [ i - 1 ] , d [ i ] , MOD ) <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE>
from functools import reduce <NEWLINE> MOD = 1_000_000_007 <NEWLINE> print ( reduce ( lambda a , b : a * b % MOD , range ( 1 , int ( input ( ) ) + 1 ) , 1 ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , M = ( int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ) <NEWLINE> As = [ int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ] <NEWLINE> d = { } <NEWLINE> for x in As : <NEWLINE> <INDENT> if x in d : <NEWLINE> <INDENT> d [ x ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ x ] = 1 <NEWLINE> <DEDENT> <DEDENT> for _ in range ( M ) : <NEWLINE> <INDENT> B , C = ( int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ) <NEWLINE> if C in d : <NEWLINE> <INDENT> d [ C ] += B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ C ] = B <NEWLINE> <DEDENT> <DEDENT> res = 0 <NEWLINE> rest = N <NEWLINE> d2 = sorted ( [ x for x in d . keys ( ) ] , reverse = True ) <NEWLINE> for m in d2 : <NEWLINE> <INDENT> x = d [ m ] <NEWLINE> if rest < x : <NEWLINE> <INDENT> res += rest * m <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += x * m <NEWLINE> rest -= x <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> if S [ : K ] . count ( <STRING> ) == K : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> A = S . lstrip ( <STRING> ) <NEWLINE> print ( A [ 0 ] ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> min , max = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 1 , M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> if L > max or R < min : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif min < L <= max : <NEWLINE> <INDENT> min = L <NEWLINE> <DEDENT> elif min <= R < max : <NEWLINE> <INDENT> max = R <NEWLINE> <DEDENT> <DEDENT> print ( max - min + 1 ) <NEWLINE>
import sys <NEWLINE> import cProfile <NEWLINE> input = sys . stdin . readline <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> l = [ 1 ] <NEWLINE> i = 0 <NEWLINE> aa = 1 <NEWLINE> while True : <NEWLINE> <INDENT> aa = a [ aa - 1 ] <NEWLINE> if aa == 2 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if i > n : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def solve ( h , w , a ) : <NEWLINE> <INDENT> used = [ [ True ] * ( w + 2 ) for _ in range ( h + 2 ) ] <NEWLINE> que = deque ( ) <NEWLINE> for r in range ( h ) : <NEWLINE> <INDENT> used [ r + 1 ] [ 1 : - 1 ] = map ( lambda _ : _ == <STRING> , a [ r ] ) <NEWLINE> for c in range ( w ) : <NEWLINE> <INDENT> if a [ r ] [ c ] == <STRING> : <NEWLINE> <INDENT> que . append ( ( r + 1 , c + 1 , 0 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> neighbors = [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> while que : <NEWLINE> <INDENT> r , c , k = que . popleft ( ) <NEWLINE> for dr , dc in neighbors : <NEWLINE> <INDENT> nr , nc = r + dr , c + dc <NEWLINE> if not used [ nr ] [ nc ] : <NEWLINE> <INDENT> que . append ( ( nr , nc , k + 1 ) ) <NEWLINE> used [ nr ] [ nc ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return k <NEWLINE> <NL> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ input ( ) for _ in range ( h ) ] <NEWLINE> print ( solve ( h , w , a ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> s = sorted ( A , reverse = True ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] != s [ 0 ] : <NEWLINE> <INDENT> print ( s [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 ; <NEWLINE> h = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> h . sort ( reverse = True ) <NEWLINE> h = h [ k : ] <NEWLINE> <NL> if len ( h ) > 0 : <NEWLINE> <INDENT> ans += sum ( h ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a1 = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> from collections import Counter <NEWLINE> a = Counter ( a1 ) . most_common ( ) <NEWLINE> num = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] [ 1 ] % 2 == 1 : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> from bisect import bisect_left <NEWLINE> ans = 0 <NEWLINE> for i1 in range ( N - 2 ) : <NEWLINE> <INDENT> for i2 in range ( i1 + 1 , N - 1 ) : <NEWLINE> <INDENT> l1 , l2 = L [ i1 ] , L [ i2 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> th = bisect_left ( L , l1 + l2 ) <NEWLINE> ans += max ( th - i2 - 1 , 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> import sys <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> import functools <NEWLINE> import itertools <NEWLINE> from collections import deque , Counter <NEWLINE> from operator import mul <NEWLINE> import copy <NEWLINE> <NL> n , k , l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> road = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> rail = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> p , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> road [ p ] . append ( q ) <NEWLINE> road [ q ] . append ( p ) <NEWLINE> <NL> <DEDENT> for i in range ( l ) : <NEWLINE> <INDENT> r , s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> rail [ r ] . append ( s ) <NEWLINE> rail [ s ] . append ( r ) <NEWLINE> <NL> <DEDENT> seen = [ 0 for i in range ( n + 1 ) ] <NEWLINE> <NL> def dfs_stack ( u , al , al_c , d ) : <NEWLINE> <INDENT> stack = deque ( [ u ] ) <NEWLINE> seen [ u ] = 1 <NEWLINE> <NL> while len ( stack ) > 0 : <NEWLINE> <INDENT> v = stack . pop ( ) <NEWLINE> <COMMENT> <NL> al_c [ v ] = d <NEWLINE> <COMMENT> <NL> <NL> for w in al [ v ] : <NEWLINE> <INDENT> if seen [ w ] == 0 : <NEWLINE> <INDENT> stack . append ( w ) <NEWLINE> seen [ w ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if stack == [ ] : break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> road_c = [ - 1 for i in range ( n + 1 ) ] <NEWLINE> rail_c = [ - 1 for i in range ( n + 1 ) ] <NEWLINE> <NL> d = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if seen [ i ] == 0 : <NEWLINE> <INDENT> dfs_stack ( i , road , road_c , d ) <NEWLINE> d += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> seen = [ 0 for i in range ( n + 1 ) ] <NEWLINE> <NL> d = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if seen [ i ] == 0 : <NEWLINE> <INDENT> dfs_stack ( i , rail , rail_c , d ) <NEWLINE> d += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> dict = { } <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ( road_c [ i ] , rail_c [ i ] ) not in dict : <NEWLINE> <INDENT> dict [ ( road_c [ i ] , rail_c [ i ] ) ] = [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict [ ( road_c [ i ] , rail_c [ i ] ) ] . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ 0 for i in range ( n + 1 ) ] <NEWLINE> <NL> for dd in dict . items ( ) : <NEWLINE> <INDENT> for j in dd [ 1 ] : <NEWLINE> <INDENT> ans [ j ] = str ( len ( dd [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( ans [ 1 : ] ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> cd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> for a , b in ab : <NEWLINE> <INDENT> distance = [ abs ( a - c ) + abs ( b - d ) for c , d in cd ] <NEWLINE> print ( distance . index ( min ( distance ) ) + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> V = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> C = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> profit = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if V [ i ] - C [ i ] >= 0 : <NEWLINE> <INDENT> profit += V [ i ] - C [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( profit ) <NEWLINE>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> StringList = [ ] <NEWLINE> for TSt in range ( 0 , N ) : <NEWLINE> <INDENT> for TEd in range ( TSt + 1 , TSt + K + 1 ) : <NEWLINE> <INDENT> StringList . append ( S [ TSt : TEd ] ) <NEWLINE> <DEDENT> <DEDENT> SetString = sorted ( set ( StringList ) ) <NEWLINE> print ( SetString [ K - 1 ] ) <NEWLINE>
h , w = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> list_a = [ input ( ) for s in range ( 0 , h ) ] <NEWLINE> list_tmp = [ ] <NEWLINE> for i in range ( 0 , h ) : <NEWLINE> <INDENT> for j in range ( 0 , w ) : <NEWLINE> <INDENT> if list_a [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> list_tmp . append ( list ( list_a [ i ] ) ) <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> list_tmp_t = [ list ( x ) for x in zip ( * list_tmp ) ] <NEWLINE> list_tmp2 = [ ] <NEWLINE> for i in range ( 0 , len ( list_tmp_t ) ) : <NEWLINE> <INDENT> for j in range ( 0 , len ( list_tmp_t [ i ] ) ) : <NEWLINE> <INDENT> if list_tmp_t [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> list_tmp2 . append ( list ( list_tmp_t [ i ] ) ) <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> list_ans = [ list ( x ) for x in zip ( * list_tmp2 ) ] <NEWLINE> for i in range ( 0 , len ( list_ans ) ) : <NEWLINE> <INDENT> print ( <STRING> . join ( list_ans [ i ] ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> import os <NEWLINE> from operator import mul <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def _S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( _S ( ) ) <NEWLINE> def LS ( ) : return list ( _S ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , LS ( ) ) ) <NEWLINE> <NL> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> inputFile = basename_without_ext = os . path . splitext ( os . path . basename ( __file__ ) ) [ 0 ] + <STRING> <NEWLINE> sys . stdin = open ( inputFile , <STRING> ) <NEWLINE> <DEDENT> INF = float ( <STRING> ) <NEWLINE> IINF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> H , W = LI ( ) <NEWLINE> S = [ list ( _S ( ) ) for _ in range ( H ) ] <NEWLINE> <NL> def check ( x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> res = False <NEWLINE> <COMMENT> <NL> dxs = [ - 1 , 1 ] <NEWLINE> dys = [ - 1 , 1 ] <NEWLINE> for dx in dxs : <NEWLINE> <INDENT> nx = x + dx <NEWLINE> ny = y <NEWLINE> if 0 <= nx and nx < H and S [ nx ] [ ny ] == <STRING> : <NEWLINE> <INDENT> res = True <NEWLINE> <DEDENT> <DEDENT> for dy in dys : <NEWLINE> <INDENT> nx = x <NEWLINE> ny = y + dy <NEWLINE> if 0 <= ny and ny < W and S [ nx ] [ ny ] == <STRING> : <NEWLINE> <INDENT> res = True <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if S [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> if not check ( i , j ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> import bisect <NEWLINE> <NL> def bin_search ( arr , ls , c ) : <NEWLINE> <INDENT> l = ls - 1 <NEWLINE> r = len ( arr ) <NEWLINE> while ( r - l ) > 1 : <NEWLINE> <INDENT> m = l + ( r - l ) // 2 <NEWLINE> if arr [ m ] >= c : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = m <NEWLINE> <DEDENT> <DEDENT> return l - ls + 1 <NEWLINE> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> readline = sys . stdin . readline <NEWLINE> n = int ( readline ( ) ) <NEWLINE> arr = list ( map ( int , readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> arr . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> c = arr [ i ] + arr [ j ] <NEWLINE> ans += ( bisect . bisect_left ( arr , c , j + 1 ) - j - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if <STRING> not in globals ( ) : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> xy = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> x , y , _ = map ( int , input ( ) . split ( ) ) <NEWLINE> xy . append ( ( x - 1 , y - 1 ) ) <NEWLINE> <NL> <DEDENT> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . li = list ( range ( n ) ) <NEWLINE> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . li [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> self . li [ x ] = self . root ( self . li [ x ] ) <NEWLINE> return self . li [ x ] <NEWLINE> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> rx = self . root ( x ) <NEWLINE> ry = self . root ( y ) <NEWLINE> if rx == ry : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> self . li [ ry ] = rx <NEWLINE> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . root ( x ) == self . root ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> uf = UnionFind ( n ) <NEWLINE> for x , y in xy : <NEWLINE> <INDENT> uf . unite ( x , y ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> uf . root ( i ) <NEWLINE> <DEDENT> print ( len ( set ( uf . li ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> . join ( ( a [ 0 : : 2 ] [ : : - 1 ] + a [ 1 : : 2 ] ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( ( a [ 1 : : 2 ] [ : : - 1 ] + a [ 0 : : 2 ] ) ) ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> * H , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> D = [ float ( <STRING> ) ] * N <NEWLINE> D [ 0 ] = 0 <NEWLINE> D [ 1 ] = abs ( H [ 1 ] - H [ 0 ] ) <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> D [ i ] = min ( abs ( H [ i ] - H [ k ] ) + D [ k ] for k in range ( max ( 0 , i - K ) , i ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( D [ - 1 ] ) <NEWLINE>
from sys import stdin <NEWLINE> nii = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> lnii = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> h , w , d = nii ( ) <NEWLINE> <NL> a_dict = { } <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> a = lnii ( ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> a_dict [ a [ j ] ] = ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> b_dict = { } <NEWLINE> for i in range ( 1 , h * w + 1 ) : <NEWLINE> <INDENT> if i - d <= 0 : <NEWLINE> <INDENT> b_dict [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> oy , ox = a_dict [ i - d ] <NEWLINE> ny , nx = a_dict [ i ] <NEWLINE> b_dict [ i ] = b_dict [ i - d ] + abs ( ny - oy ) + abs ( nx - ox ) <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> l , r = nii ( ) <NEWLINE> ans = b_dict [ r ] - b_dict [ l ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numpy . fft import rfft , irfft <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def ii ( ) : return int ( input ( ) ) <NEWLINE> def isp ( ) : return input ( ) . split ( ) <NEWLINE> def deb ( text ) : print ( <STRING> . format ( text ) ) <NEWLINE> <NL> INF = 10 ** 20 <NEWLINE> class Polynomial : <NEWLINE> <INDENT> def __init__ ( self , dim = 0 , const = 1 ) : <NEWLINE> <INDENT> self . values = [ ( dim , const ) ] <NEWLINE> <DEDENT> def __add__ ( self , other ) : <NEWLINE> <INDENT> return self . values + other . values <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class PolySolver : <NEWLINE> <INDENT> def __init__ ( self , size , init_val = 1 ) : <NEWLINE> <INDENT> self . size = size <NEWLINE> self . f = np . zeros ( size , np . int64 ) <NEWLINE> self . f [ 0 ] = init_val <NEWLINE> <NL> <NL> <DEDENT> def multiple ( self , polynomial , MOD ) : <COMMENT> <NEWLINE> <INDENT> new_F = np . zeros ( self . size , np . int64 ) <NEWLINE> for dim , const in polynomial : <NEWLINE> <INDENT> if dim != 0 : <NEWLINE> <INDENT> g = np . zeros ( self . size , np . int64 ) <NEWLINE> g [ dim : ] += self . f [ : - dim ] <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = const * self . f . copy ( ) <NEWLINE> <NL> <DEDENT> new_F += g <NEWLINE> <NL> <DEDENT> self . f = new_F <NEWLINE> <NL> <NL> <DEDENT> def add ( self , polynomial ) : <COMMENT> <NEWLINE> <INDENT> for dim , const in polynomial : <NEWLINE> <INDENT> self . f [ dim ] += const <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def get_coefficient ( self , dim ) : <NEWLINE> <INDENT> return self . f [ dim ] <NEWLINE> <NL> <DEDENT> def fft ( self , A , B , fft_len = 1 << 18 ) : <NEWLINE> <INDENT> x = irfft ( rfft ( A , fft_len ) * rfft ( B , fft_len ) ) <NEWLINE> return np . rint ( x ) . astype ( np . int64 ) <NEWLINE> <NL> <DEDENT> def convolve ( self , g ) : <NEWLINE> <INDENT> h = self . fft ( self . f , g ) [ : len ( self . f ) + len ( g ) - 1 ] <NEWLINE> self . f = h <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = mi ( ) <NEWLINE> A = list ( mi ( ) ) <NEWLINE> <NL> mx = 2 * 10 ** 5 + 10 <NEWLINE> F = PolySolver ( mx , init_val = 0 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> F . add ( Polynomial ( dim = a ) . values ) <NEWLINE> <NL> <DEDENT> g = F . f <NEWLINE> F . convolve ( g ) <NEWLINE> <NL> ans = 0 <NEWLINE> handshake = M <NEWLINE> for x in range ( mx - 1 , 1 , - 1 ) : <NEWLINE> <INDENT> count = F . get_coefficient ( x ) <NEWLINE> if count <= 0 : continue <NEWLINE> <NL> if count > handshake : <NEWLINE> <INDENT> ans += handshake * x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += count * x <NEWLINE> <NL> <DEDENT> handshake = max ( handshake - count , 0 ) <NEWLINE> if handshake == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> def gcd ( * numbers ) : reduce ( math . gcd , numbers ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> N = k ( ) <NEWLINE> D = l ( ) <NEWLINE> M = k ( ) <NEWLINE> T = l ( ) <NEWLINE> <NL> d = Counter ( D ) <NEWLINE> t = Counter ( T ) <NEWLINE> <NL> for i in t : <NEWLINE> <INDENT> if t [ i ] > d [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l_max = 1 <NEWLINE> r_min = 10 ** 5 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> l_max = max ( l , l_max ) <NEWLINE> r_min = min ( r , r_min ) <NEWLINE> <NL> <DEDENT> print ( max ( 0 , r_min - l_max + 1 ) ) <NEWLINE> <NL> <NL> <NL>
import sys <NEWLINE> from operator import itemgetter <NEWLINE> import math <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> XY = [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( N ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> tmp = [ 0 , 0 ] <NEWLINE> for x , y in XY : <NEWLINE> <INDENT> if x > 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <DEDENT> elif x == 0 and y > 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , math . sqrt ( tmp [ 0 ] ** 2 + tmp [ 1 ] ** 2 ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> tmp = [ 0 , 0 ] <NEWLINE> for x , y in XY : <NEWLINE> <INDENT> if x > 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <DEDENT> elif x == 0 and y < 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , math . sqrt ( tmp [ 0 ] ** 2 + tmp [ 1 ] ** 2 ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> tmp = [ 0 , 0 ] <NEWLINE> for x , y in XY : <NEWLINE> <INDENT> if x < 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <DEDENT> elif x == 0 and y > 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , math . sqrt ( tmp [ 0 ] ** 2 + tmp [ 1 ] ** 2 ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> tmp = [ 0 , 0 ] <NEWLINE> for x , y in XY : <NEWLINE> <INDENT> if x < 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <DEDENT> elif x == 0 and y < 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , math . sqrt ( tmp [ 0 ] ** 2 + tmp [ 1 ] ** 2 ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> tmp = [ 0 , 0 ] <NEWLINE> for x , y in XY : <NEWLINE> <INDENT> if y > 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <DEDENT> elif y == 0 and x > 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , math . sqrt ( tmp [ 0 ] ** 2 + tmp [ 1 ] ** 2 ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> tmp = [ 0 , 0 ] <NEWLINE> for x , y in XY : <NEWLINE> <INDENT> if y < 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <DEDENT> elif y == 0 and x > 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , math . sqrt ( tmp [ 0 ] ** 2 + tmp [ 1 ] ** 2 ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> tmp = [ 0 , 0 ] <NEWLINE> for x , y in XY : <NEWLINE> <INDENT> if y > 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <DEDENT> elif y == 0 and x < 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , math . sqrt ( tmp [ 0 ] ** 2 + tmp [ 1 ] ** 2 ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> tmp = [ 0 , 0 ] <NEWLINE> for x , y in XY : <NEWLINE> <INDENT> if y < 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <DEDENT> elif y == 0 and x < 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , math . sqrt ( tmp [ 0 ] ** 2 + tmp [ 1 ] ** 2 ) ) <NEWLINE> <NL> for i , ( x , y ) in enumerate ( XY ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> katamuki = 0 <NEWLINE> katamuki2 = float ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> katamuki = y / x <NEWLINE> if y == 0 : <NEWLINE> <INDENT> katamuki2 = float ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> katamuki2 = - ( x / y ) <NEWLINE> <DEDENT> <DEDENT> plus = [ 0 , 0 ] <NEWLINE> minus = [ 0 , 0 ] <NEWLINE> plus2 = [ 0 , 0 ] <NEWLINE> minus2 = [ 0 , 0 ] <NEWLINE> for j , ( xx , yy ) in enumerate ( XY ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if yy > katamuki * xx : <NEWLINE> <INDENT> plus [ 0 ] += xx <NEWLINE> plus [ 1 ] += yy <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus [ 0 ] += xx <NEWLINE> minus [ 1 ] += yy <NEWLINE> <NL> <DEDENT> if katamuki2 == float ( <STRING> ) : <NEWLINE> <INDENT> if xx > 0 : <NEWLINE> <INDENT> plus2 [ 0 ] += xx <NEWLINE> plus2 [ 1 ] += yy <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus2 [ 0 ] += xx <NEWLINE> minus2 [ 1 ] += yy <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if yy > katamuki2 * xx : <NEWLINE> <INDENT> plus2 [ 0 ] += xx <NEWLINE> plus2 [ 1 ] += yy <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus2 [ 0 ] += xx <NEWLINE> minus2 [ 1 ] += yy <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = max ( ans , math . sqrt ( plus [ 0 ] ** 2 + plus [ 1 ] ** 2 ) ) <NEWLINE> ans = max ( ans , math . sqrt ( minus [ 0 ] ** 2 + minus [ 1 ] ** 2 ) ) <NEWLINE> ans = max ( ans , math . sqrt ( plus2 [ 0 ] ** 2 + plus2 [ 1 ] ** 2 ) ) <NEWLINE> ans = max ( ans , math . sqrt ( minus2 [ 0 ] ** 2 + minus2 [ 1 ] ** 2 ) ) <NEWLINE> ans = max ( ans , math . sqrt ( ( plus [ 0 ] + x ) ** 2 + ( plus [ 1 ] + y ) ** 2 ) ) <NEWLINE> ans = max ( ans , math . sqrt ( ( minus [ 0 ] + x ) ** 2 + ( minus [ 1 ] + y ) ** 2 ) ) <NEWLINE> ans = max ( ans , math . sqrt ( ( plus2 [ 0 ] + x ) ** 2 + ( plus2 [ 1 ] + y ) ** 2 ) ) <NEWLINE> ans = max ( ans , math . sqrt ( ( minus2 [ 0 ] + x ) ** 2 + ( minus2 [ 1 ] + y ) ** 2 ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , product <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( str , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N = INT ( ) <NEWLINE> S = [ _ for _ in input ( ) ] <NEWLINE> <NL> left , right = 0 , S [ 1 : ] . count ( <STRING> ) <NEWLINE> ans = left + right <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> left += 1 <NEWLINE> <DEDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> right -= 1 <NEWLINE> <NL> <DEDENT> ans = min ( ans , left + right ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> import numpy as np <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> def bfs ( sx , sy ) : <NEWLINE> <COMMENT> <NL> <INDENT> d = [ [ float ( <STRING> ) ] * m for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> dx = [ 1 , 0 , - 1 , 0 ] <NEWLINE> dy = [ 0 , 1 , 0 , - 1 ] <NEWLINE> <NL> <COMMENT> <NL> que = deque ( [ ] ) <NEWLINE> que . append ( ( sx , sy ) ) <NEWLINE> d [ sx ] [ sy ] = 0 <NEWLINE> <NL> <COMMENT> <NL> while que : <NEWLINE> <COMMENT> <NL> <INDENT> p = que . popleft ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( 4 ) : <NEWLINE> <COMMENT> <NL> <INDENT> nx = p [ 0 ] + dx [ i ] <NEWLINE> ny = p [ 1 ] + dy [ i ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> if 0 <= nx < n and 0 <= ny < m and maze [ nx ] [ ny ] != <STRING> and d [ nx ] [ ny ] == float ( <STRING> ) : <NEWLINE> <COMMENT> <NL> <INDENT> que . append ( ( nx , ny ) ) <NEWLINE> d [ nx ] [ ny ] = d [ p [ 0 ] ] [ p [ 1 ] ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> a = np . max ( d ) <NEWLINE> return a <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> maze = [ list ( input ( ) ) for i in range ( n ) ] <NEWLINE> ans = 1 <NEWLINE> <NL> for x in range ( n ) : <NEWLINE> <INDENT> for y in range ( m ) : <NEWLINE> <INDENT> sx = x <NEWLINE> sy = y <NEWLINE> if maze [ sx ] [ sy ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> A = bfs ( sx , sy ) <NEWLINE> ans = max ( A , ans ) <NEWLINE> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a <= 0 and b >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif a < 0 and b < 0 : <NEWLINE> <INDENT> if ( abs ( a ) - abs ( b + 1 ) ) % 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools as it <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def I2 ( ) : return map ( int , sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ) <NEWLINE> def S ( ) : return str ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def L ( ) : return list ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def Intl ( ) : return [ int ( k ) for k in sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ] <NEWLINE> def Lx ( k ) : return list ( map ( lambda x : int ( x ) * - k , sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ) ) <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> s = S ( ) <NEWLINE> cnt = 0 <NEWLINE> tgt = <STRING> <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> if s [ : i ] + s [ len ( s ) - 7 + i : ] == tgt : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> delta = 0 <NEWLINE> if N > 1 : <NEWLINE> <INDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if ( i - 1 ) * i < 2 * N < i * ( i + 1 ) : <NEWLINE> <INDENT> delta = i * ( i + 1 ) // 2 - N <NEWLINE> res_list = list ( range ( 1 , i + 1 ) ) <NEWLINE> break <NEWLINE> <DEDENT> elif 2 * N == i * ( i + 1 ) : <NEWLINE> <INDENT> res_list = range ( 1 , i + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res_list = [ 1 ] <NEWLINE> <NL> <DEDENT> if delta > 0 : <NEWLINE> <INDENT> while delta > res_list [ - 1 ] : <NEWLINE> <INDENT> delta -= res_list [ - 1 ] <NEWLINE> del res_list [ - 1 ] <NEWLINE> <NL> <DEDENT> res_list . remove ( delta ) <NEWLINE> <NL> <NL> <DEDENT> for item in res_list : <NEWLINE> <INDENT> print ( item ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
