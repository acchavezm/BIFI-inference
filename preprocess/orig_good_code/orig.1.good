import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> res = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( res , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x = [ str ( input ( ) ) for i in range ( 2 ) ] <NEWLINE> if x [ 0 ] [ 0 ] == x [ 1 ] [ 2 ] and x [ 0 ] [ 1 ] == x [ 1 ] [ 1 ] and x [ 0 ] [ 2 ] == x [ 1 ] [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n != 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lists = [ ] <NEWLINE> for i in range ( 0 , 102 ) : <NEWLINE> <INDENT> if i in p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> lists . append ( i ) <NEWLINE> <NL> <DEDENT> ans = lists [ 0 ] <NEWLINE> mins = abs ( lists [ 0 ] - x ) <NEWLINE> for i in range ( 1 , len ( lists ) ) : <NEWLINE> <INDENT> dist = abs ( lists [ i ] - x ) <NEWLINE> if mins > dist : <NEWLINE> <INDENT> ans = lists [ i ] <NEWLINE> mins = dist <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a % 2 != 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if p == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if p == 0 : <NEWLINE> <INDENT> print ( 2 ** n ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 2 ** ( n - 1 ) <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( math . sqrt ( pow ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bound = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans = ans * a <NEWLINE> if ans > bound : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> kashi = [ 0 ] * n <NEWLINE> cnt = 0 <NEWLINE> M = 0 <NEWLINE> for s in range ( k ) : <NEWLINE> <INDENT> i = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if i > 0 : <NEWLINE> <INDENT> for m in li : <NEWLINE> <INDENT> kashi [ m - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in kashi : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> <NL> def prime ( x ) : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif x % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 3 <NEWLINE> while i <= math . sqrt ( x ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 2 <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> p = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if prime ( int ( input ( ) ) ) == True : <NEWLINE> <INDENT> p += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst . sort ( ) <NEWLINE> if len ( lst ) == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> A = X <NEWLINE> while A in lst : <NEWLINE> <INDENT> A -= 1 <NEWLINE> <DEDENT> B = X <NEWLINE> while B in lst : <NEWLINE> <INDENT> B += 1 <NEWLINE> <DEDENT> if X - A > B - X : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT>
n , m , p = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( [ ( int ( input ( ) ) - p ) % n for _ in range ( m ) ] ) <NEWLINE> print ( min ( a [ - 1 ] , n - a [ 0 ] , min ( [ a [ i ] + n - a [ i + 1 ] + min ( a [ i ] , n - a [ i + 1 ] ) for i in range ( m - 1 ) ] ) ) * 100 if m > 1 else min ( a [ 0 ] , n - a [ 0 ] ) * 100 ) <NEWLINE>
import math <NEWLINE> from functools import lru_cache <NEWLINE> def Frog1 ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> @ lru_cache ( None ) <NEWLINE> def Solve ( i ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if i == n - 2 : <NEWLINE> <INDENT> return abs ( h [ i ] - h [ i + 1 ] ) <NEWLINE> <DEDENT> return min ( Solve ( i + 1 ) + abs ( h [ i ] - h [ i + 1 ] ) , Solve ( i + 2 ) + abs ( h [ i ] - h [ i + 2 ] ) ) <NEWLINE> <DEDENT> dp = [ 0 ] * n <NEWLINE> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> elif i == n - 2 : <NEWLINE> <INDENT> dp [ i ] = abs ( h [ i ] - h [ i + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i + 1 ] + abs ( h [ i ] - h [ i + 1 ] ) , dp [ i + 2 ] + abs ( h [ i ] - h [ i + 2 ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ 0 ] ) <NEWLINE> <DEDENT> Frog1 ( ) <NEWLINE> <NL> <NL>
from sys import stdin <NEWLINE> import numpy as np <NEWLINE> <NL> def bit_search ( a , n , m , x ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> price = 0 <NEWLINE> skill = np . zeros ( ( n , m ) ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> price += a [ j ] [ 0 ] <NEWLINE> skill [ j ] = a [ j ] [ 1 : ] <NEWLINE> <DEDENT> <DEDENT> skill_sum = np . sum ( skill , axis = 0 ) if skill . shape [ 0 ] > 1 else skill <NEWLINE> if ( skill_sum >= x ) . all ( ) : res . append ( price ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> readline = stdin . readline <NEWLINE> n , m , x = map ( int , readline ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , readline ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> res = bit_search ( a , n , m , x ) <NEWLINE> print ( <STRING> if not res else min ( res ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> if len ( S ) > K : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> print ( S [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT>
import math <NEWLINE> import copy <NEWLINE> import sys <NEWLINE> import fractions <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> import decimal <NEWLINE> import heapq <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 100001 ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> def getInputIntList ( ) : <NEWLINE> <INDENT> outputDataList = [ ] <NEWLINE> inputData = input ( ) . split ( ) <NEWLINE> outputDataList = [ int ( n ) for n in inputData ] <NEWLINE> <NL> return outputDataList <NEWLINE> <NL> <NL> <DEDENT> def getSomeInputInt ( n ) : <NEWLINE> <INDENT> outputDataList = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inputData = int ( input ( ) ) <NEWLINE> outputDataList . append ( inputData ) <NEWLINE> <NL> <DEDENT> return outputDataList <NEWLINE> <NL> <NL> <DEDENT> def getSomeInputListInt ( n ) : <NEWLINE> <INDENT> inputDataList = [ ] <NEWLINE> outputDataList = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inputData = input ( ) . split ( ) <NEWLINE> inputDataList = [ int ( n ) for n in inputData ] <NEWLINE> outputDataList . append ( inputDataList ) <NEWLINE> <NL> <DEDENT> return outputDataList <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> n += 1 <NEWLINE> <NL> sum_mat = [ 0 ] <NEWLINE> for i in range ( 1 , 2 * ( 10 ** 5 ) + 3 ) : <NEWLINE> <INDENT> sum_mat . append ( sum_mat [ i - 1 ] + i ) <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( k , n + 1 ) : <NEWLINE> <INDENT> top = sum_mat [ i ] <NEWLINE> bottom = sum_mat [ i - 1 ] - 1 <NEWLINE> ans += ( i * n - top - bottom ) % MOD <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> def main ( i , A ) : <NEWLINE> <INDENT> global N <NEWLINE> global ans <NEWLINE> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> if i == N - 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> return ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return main ( i + 1 , A ) <NEWLINE> <DEDENT> <DEDENT> elif A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> while i < N - 1 : <NEWLINE> <INDENT> if A [ i ] <= A [ i + 1 ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if i == N - 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> return ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return main ( i + 1 , A ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> return ans <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> while i < N - 1 : <NEWLINE> <INDENT> if A [ i ] >= A [ i + 1 ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if i == N - 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> return ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return main ( i + 1 , A ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( main ( 0 , A ) ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = collections . Counter ( A ) <NEWLINE> <NL> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = 1 <NEWLINE> if any ( i == 0 for i in data ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in data : <NEWLINE> <INDENT> num *= i <NEWLINE> if 10 ** 18 < num : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
import math <NEWLINE> <NL> def f ( A , B , X ) : <NEWLINE> <INDENT> return math . floor ( ( A * X ) / B ) - A * math . floor ( X / B ) <NEWLINE> <NL> <DEDENT> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N < B : <NEWLINE> <INDENT> print ( f ( A , B , N ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( f ( A , B , B - 1 ) ) <NEWLINE> <DEDENT>
class BinarySearchTree : <NEWLINE> <INDENT> root = None <NEWLINE> def insert ( self , k ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = self . root <NEWLINE> z = Node ( k ) <NEWLINE> while x : <NEWLINE> <INDENT> y = x <NEWLINE> if z . k < x . k : <NEWLINE> <INDENT> x = x . l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . r <NEWLINE> <DEDENT> <DEDENT> z . p = y <NEWLINE> <NL> if y == None : <NEWLINE> <INDENT> self . root = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if z . k < y . k : <NEWLINE> <INDENT> y . l = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . r = z <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def find ( self , x , k ) : <NEWLINE> <INDENT> while x != None and k != x . k : <NEWLINE> <INDENT> if k < x . k : <NEWLINE> <INDENT> x = x . l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . r <NEWLINE> <DEDENT> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def deleteNode ( self , z ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = None <NEWLINE> if z . l == None or z . r == None : <NEWLINE> <INDENT> y = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = self . getSuccessor ( z ) <NEWLINE> <NL> <DEDENT> if y . l != None : <NEWLINE> <INDENT> x = y . l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = y . r <NEWLINE> <NL> <DEDENT> if x != None : <NEWLINE> <INDENT> x . p = y . p <NEWLINE> <NL> <DEDENT> if y . p == None : <NEWLINE> <INDENT> self . root = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if y == y . p . l : <NEWLINE> <INDENT> y . p . l = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . p . r = x <NEWLINE> <NL> <DEDENT> <DEDENT> if y != z : <NEWLINE> <INDENT> z . k = y . k <NEWLINE> <NL> <DEDENT> <DEDENT> def getSuccessor ( self , x ) : <NEWLINE> <INDENT> if x . r != None : <NEWLINE> <INDENT> return self . getMinimum ( x . r ) <NEWLINE> <DEDENT> y = x . p <NEWLINE> while y != None and x == y . r : <NEWLINE> <INDENT> x = y <NEWLINE> y = y . p <NEWLINE> <DEDENT> return y <NEWLINE> <NL> <DEDENT> def getMinimum ( self , x ) : <NEWLINE> <INDENT> while x . l != None : <NEWLINE> <INDENT> x = x . l <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def preParse ( self , u ) : <NEWLINE> <INDENT> if u == None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> print ( <STRING> , str ( u . k ) , end = <STRING> ) <NEWLINE> self . preParse ( u . l ) <NEWLINE> self . preParse ( u . r ) <NEWLINE> <NL> <DEDENT> def inParse ( self , u ) : <NEWLINE> <INDENT> if u == None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> self . inParse ( u . l ) <NEWLINE> print ( <STRING> , str ( u . k ) , end = <STRING> ) <NEWLINE> self . inParse ( u . r ) <NEWLINE> <NL> <DEDENT> <DEDENT> class Node : <NEWLINE> <INDENT> def __init__ ( self , k ) : <NEWLINE> <INDENT> self . k = k <NEWLINE> self . p = None <NEWLINE> self . l = None <NEWLINE> self . r = None <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) . rstrip ( ) ) <NEWLINE> x = BinarySearchTree ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> com = input ( ) . rstrip ( ) <NEWLINE> if com . startswith ( <STRING> ) : <NEWLINE> <INDENT> k = int ( com . split ( <STRING> ) [ 1 ] ) <NEWLINE> x . insert ( k ) <NEWLINE> <DEDENT> elif com . startswith ( <STRING> ) : <NEWLINE> <INDENT> k = int ( com . split ( <STRING> ) [ 1 ] ) <NEWLINE> if x . find ( x . root , k ) != None : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif com . startswith ( <STRING> ) : <NEWLINE> <INDENT> k = int ( com . split ( <STRING> ) [ 1 ] ) <NEWLINE> x . deleteNode ( x . find ( x . root , k ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x . inParse ( x . root ) <NEWLINE> print ( ) <NEWLINE> x . preParse ( x . root ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if p == [ ] : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> t = [ 0 ] * ( max ( p ) + 2 ) <NEWLINE> for i in p : <NEWLINE> <INDENT> t [ i ] = 1 <NEWLINE> <NL> <DEDENT> mi = t [ : x + 1 ] <NEWLINE> ma = t [ x : ] <NEWLINE> mi . reverse ( ) <NEWLINE> mii = mi . index ( 0 ) <NEWLINE> maa = ma . index ( 0 ) <NEWLINE> <NL> if mii < maa : <NEWLINE> <INDENT> print ( x - mii ) <NEWLINE> <DEDENT> elif mii > maa : <NEWLINE> <INDENT> print ( x + maa ) <NEWLINE> <DEDENT> elif mii == maa : <NEWLINE> <INDENT> print ( x - mii ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ary = [ 0 ] * n <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> ary [ x - 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , ary ) ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 1 and M == 1 : <NEWLINE> <INDENT> result = 0 <NEWLINE> <DEDENT> if 0 <= N and N <= 1 and 2 <= M : <NEWLINE> <INDENT> result = M * ( M - 1 ) // 2 <NEWLINE> <DEDENT> if 2 <= N and 0 <= M and M <= 1 : <NEWLINE> <INDENT> result = N * ( N - 1 ) // 2 <NEWLINE> <DEDENT> if 2 <= N and 2 <= M : <NEWLINE> <INDENT> result = ( N * ( N - 1 ) + M * ( M - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
import sys <NEWLINE> n , k = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> ans += ( n - i + 1 ) * i + 1 <NEWLINE> <DEDENT> ans %= mod <NEWLINE> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( A ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import namedtuple <NEWLINE> <NL> <NL> Node = namedtuple ( <STRING> , [ <STRING> , <STRING> , <STRING> , <STRING> ] ) <NEWLINE> <NL> <NL> class Treap : <NEWLINE> <INDENT> MAX_KEY = 2000000000 <NEWLINE> MAX_PRIORITY = 2000000000 <NEWLINE> <NL> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def insert ( self , key , priority ) : <NEWLINE> <INDENT> def _insert ( node ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return Node ( key , priority , None , None ) <NEWLINE> <DEDENT> k , p , left , right = node <NEWLINE> if key < k : <NEWLINE> <INDENT> node = Node ( k , p , _insert ( left ) , right ) <NEWLINE> if p < node . left . priority : <NEWLINE> <INDENT> node = self . _rotate_right ( node ) <NEWLINE> <DEDENT> <DEDENT> elif key > k : <NEWLINE> <INDENT> node = Node ( k , p , left , _insert ( right ) ) <NEWLINE> if p < node . right . priority : <NEWLINE> <INDENT> node = self . _rotate_left ( node ) <NEWLINE> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> pass <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> return node <NEWLINE> <NL> <DEDENT> self . root = _insert ( self . root ) <NEWLINE> <NL> <DEDENT> def delete ( self , key ) : <NEWLINE> <INDENT> def _delete ( node ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> k , p , left , right = node <NEWLINE> if key < k : <NEWLINE> <INDENT> node = node . _replace ( left = _delete ( left ) ) <NEWLINE> <DEDENT> elif key > k : <NEWLINE> <INDENT> node = node . _replace ( right = _delete ( right ) ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> if left is None : <NEWLINE> <INDENT> node = right <NEWLINE> <DEDENT> elif right is None : <NEWLINE> <INDENT> node = left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if left . priority > right . priority : <NEWLINE> <INDENT> node = _delete ( self . _rotate_right ( node ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node = _delete ( self . _rotate_left ( node ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> return node <NEWLINE> <NL> <DEDENT> self . root = _delete ( self . root ) <NEWLINE> <NL> <DEDENT> def find ( self , key ) : <NEWLINE> <INDENT> def _find ( node ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if key < node . key : <NEWLINE> <INDENT> return _find ( node . left ) <NEWLINE> <DEDENT> elif key > node . key : <NEWLINE> <INDENT> return _find ( node . right ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> return _find ( self . root ) <NEWLINE> <NL> <DEDENT> def inorder ( self ) : <NEWLINE> <INDENT> def _inorder ( node ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> yield from _inorder ( node . left ) <NEWLINE> yield node <NEWLINE> yield from _inorder ( node . right ) <NEWLINE> <DEDENT> <DEDENT> return _inorder ( self . root ) <NEWLINE> <NL> <DEDENT> def preorder ( self ) : <NEWLINE> <INDENT> def _preorder ( node ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> yield node <NEWLINE> yield from _preorder ( node . left ) <NEWLINE> yield from _preorder ( node . right ) <NEWLINE> <DEDENT> <DEDENT> return _preorder ( self . root ) <NEWLINE> <NL> <DEDENT> def postorder ( self ) : <NEWLINE> <INDENT> def _postorder ( node ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> yield from _postorder ( node . left ) <NEWLINE> yield from _postorder ( node . right ) <NEWLINE> yield node <NEWLINE> <DEDENT> <DEDENT> return _postorder ( self . root ) <NEWLINE> <NL> <DEDENT> def _rotate_left ( self , node ) : <NEWLINE> <COMMENT> <NL> <INDENT> top = node . right <NEWLINE> node = node . _replace ( right = top . left ) <NEWLINE> top = top . _replace ( left = node ) <NEWLINE> return top <NEWLINE> <NL> <DEDENT> def _rotate_right ( self , node ) : <NEWLINE> <COMMENT> <NL> <INDENT> top = node . left <NEWLINE> node = node . _replace ( left = top . right ) <NEWLINE> top = top . _replace ( right = node ) <NEWLINE> return top <NEWLINE> <NL> <DEDENT> def _heap_invariant ( self , node ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> key , priority , left , right = node <NEWLINE> return ( ( left is None or priority > left . priority ) <NEWLINE> <INDENT> and ( right is None or priority > right . priority ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def _bst_invariant ( self , node ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> key , priority , left , right = node <NEWLINE> return ( ( left is None or key > left . key ) <NEWLINE> <INDENT> and ( right is None or key < right . key ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> def _str ( node ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k , p , l , r = node <NEWLINE> return <STRING> . format ( _str ( l ) , k , p , _str ( r ) ) <NEWLINE> <DEDENT> <DEDENT> return _str ( self . root ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> input ( ) <NEWLINE> tree = Treap ( ) <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> if line . startswith ( <STRING> ) : <NEWLINE> <INDENT> key , priority = [ int ( i ) for i in line [ 7 : ] . split ( ) ] <NEWLINE> tree . insert ( key , priority ) <NEWLINE> <DEDENT> elif line . startswith ( <STRING> ) : <NEWLINE> <INDENT> if tree . find ( int ( line [ 5 : ] ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif line . startswith ( <STRING> ) : <NEWLINE> <INDENT> tree . delete ( int ( line [ 7 : ] ) ) <NEWLINE> <DEDENT> elif line . startswith ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> , <STRING> . join ( [ str ( n . key ) for n in tree . inorder ( ) ] ) ) <NEWLINE> print ( <STRING> , <STRING> . join ( [ str ( n . key ) for n in tree . preorder ( ) ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> def mn ( li ) : <NEWLINE> <INDENT> if li [ 0 ] == <STRING> : <NEWLINE> <INDENT> c [ 0 ] = 0 <NEWLINE> <DEDENT> elif li [ 0 ] == <STRING> : <NEWLINE> <INDENT> li [ 0 ] = 1 <NEWLINE> <DEDENT> elif li [ 0 ] == <STRING> : <NEWLINE> <INDENT> li [ 0 ] = 2 <NEWLINE> <DEDENT> elif li [ 0 ] == <STRING> : <NEWLINE> <INDENT> li [ 0 ] = 3 <NEWLINE> <DEDENT> li [ 1 ] = int ( li [ 1 ] ) <NEWLINE> return li <NEWLINE> <DEDENT> def nm ( nu ) : <NEWLINE> <INDENT> if nu == 0 : <NEWLINE> <INDENT> co = <STRING> <NEWLINE> <DEDENT> elif nu == 1 : <NEWLINE> <INDENT> co = <STRING> <NEWLINE> <DEDENT> elif nu == 2 : <NEWLINE> <INDENT> co = <STRING> <NEWLINE> <DEDENT> elif nu == 3 : <NEWLINE> <INDENT> co = <STRING> <NEWLINE> <COMMENT> <NL> <DEDENT> return co <NEWLINE> <DEDENT> T = [ ] <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> T . append ( [ ] ) <NEWLINE> for j in range ( 14 ) : <NEWLINE> <INDENT> T [ i ] . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c = [ j for j in input ( ) . split ( ) ] <NEWLINE> c = mn ( c ) <NEWLINE> <COMMENT> <NL> T [ c [ 0 ] ] [ c [ 1 ] ] = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 1 , 14 ) : <NEWLINE> <INDENT> if T [ i ] [ j ] == 0 : <NEWLINE> <INDENT> print ( nm ( i ) + <STRING> + str ( j ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> def goes_to_zero ( n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while ( n > 0 ) : <NEWLINE> <INDENT> n %= bin ( n ) . count ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> XC = X . count ( <STRING> ) <NEWLINE> XI = int ( X , 2 ) <NEWLINE> XCP = XC + 1 <NEWLINE> XCM = XC - 1 <NEWLINE> XTP = XI % XCP <NEWLINE> XTM = XI % XCM if XCM != 0 else 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> print ( goes_to_zero ( ( XTP + pow ( 2 , N - 1 - i , XCP ) ) % XCP ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if XCM == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( goes_to_zero ( ( XTM - pow ( 2 , N - 1 - i , XCM ) ) % XCM ) + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> count = 0 <NEWLINE> for n in range ( K , N + 2 ) : <NEWLINE> <INDENT> maxSum = ( n * ( N + N - n + 1 ) ) // 2 <NEWLINE> minSum = ( n * ( n - 1 ) ) // 2 <NEWLINE> count += maxSum - minSum + 1 <NEWLINE> count %= mod <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> <NL> num = s . count ( <STRING> ) <NEWLINE> <NL> before = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <NL> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> before += i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> after = 0 <NEWLINE> for j in range ( num ) : <NEWLINE> <INDENT> after += j <NEWLINE> <NL> <DEDENT> print ( before - after ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> ng = 0 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> vertices = { i : [ ] for i in range ( n ) } <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> l , r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> vertices [ l - 1 ] . append ( ( r - 1 , d ) ) <NEWLINE> vertices [ r - 1 ] . append ( ( l - 1 , - d ) ) <NEWLINE> <NL> <NL> <DEDENT> def answer ( ) : <NEWLINE> <INDENT> x = [ None ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] is not None : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x [ i ] = 0 <NEWLINE> queue = [ i ] <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> i0 = queue . pop ( ) <NEWLINE> for i1 , d in vertices [ i0 ] : <NEWLINE> <COMMENT> <NL> <INDENT> if x [ i1 ] is None : <NEWLINE> <INDENT> x [ i1 ] = x [ i0 ] + d <NEWLINE> queue . append ( i1 ) <NEWLINE> <DEDENT> elif x [ i1 ] != x [ i0 ] + d : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> if answer ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> Amax = A [ - 1 ] + 1 <NEWLINE> dp = [ True ] * Amax <NEWLINE> ans = 0 <NEWLINE> a_temp = set ( ) <NEWLINE> a_tempcheck = set ( ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if dp [ a ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> a_temp . add ( a ) <NEWLINE> for i in range ( a , Amax , a ) : <NEWLINE> <INDENT> dp [ i ] = False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a not in a_tempcheck : <NEWLINE> <INDENT> if a in a_temp : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> a_tempcheck . add ( a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( each ) for each in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> rep = [ tuple ( int ( each ) for each in input ( ) . split ( ) ) for i in range ( q ) ] <NEWLINE> <NL> s = [ sum ( a ) ] <NEWLINE> <NL> c = collections . Counter ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> diff = ( rep [ i ] [ 1 ] - rep [ i ] [ 0 ] ) <NEWLINE> num = c . get ( rep [ i ] [ 0 ] ) <NEWLINE> if not num : <NEWLINE> <INDENT> num = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> s . append ( s [ - 1 ] + num * diff ) <NEWLINE> <NL> <COMMENT> <NL> if c . get ( rep [ i ] [ 0 ] ) : <NEWLINE> <INDENT> c [ rep [ i ] [ 1 ] ] += c . pop ( rep [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( each ) for each in s [ 1 : ] ] ) ) <NEWLINE>
N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ <STRING> ] * ( N + 1 ) <NEWLINE> for a in range ( N ) : <NEWLINE> <INDENT> S [ a ] = input ( ) <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> L_ans = [ <STRING> ] * ( N + 1 ) <NEWLINE> i = 0 <NEWLINE> while i < N : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if A > B : <NEWLINE> <INDENT> B += 1 <NEWLINE> A -= 1 <NEWLINE> L_ans [ i ] = <STRING> <NEWLINE> <DEDENT> elif A < B : <NEWLINE> <INDENT> A += 1 <NEWLINE> B -= 1 <NEWLINE> L_ans [ i ] = <STRING> <NEWLINE> <DEDENT> elif A == B and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> B += 1 <NEWLINE> A -= 1 <NEWLINE> L_ans [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A += 1 <NEWLINE> B -= 1 <NEWLINE> L_ans [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> if A > C : <NEWLINE> <INDENT> C += 1 <NEWLINE> A -= 1 <NEWLINE> L_ans [ i ] = <STRING> <NEWLINE> <DEDENT> elif A < C : <NEWLINE> <INDENT> A += 1 <NEWLINE> C -= 1 <NEWLINE> L_ans [ i ] = <STRING> <NEWLINE> <DEDENT> elif A == C and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> C += 1 <NEWLINE> A -= 1 <NEWLINE> L_ans [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A += 1 <NEWLINE> C -= 1 <NEWLINE> L_ans [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> if C > B : <NEWLINE> <INDENT> B += 1 <NEWLINE> C -= 1 <NEWLINE> L_ans [ i ] = <STRING> <NEWLINE> <DEDENT> elif C < B : <NEWLINE> <INDENT> C += 1 <NEWLINE> B -= 1 <NEWLINE> L_ans [ i ] = <STRING> <NEWLINE> <DEDENT> elif B == C and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> B += 1 <NEWLINE> C -= 1 <NEWLINE> L_ans [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C += 1 <NEWLINE> B -= 1 <NEWLINE> L_ans [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> if any ( [ A < 0 , B < 0 , C < 0 ] ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> if ans == <STRING> : <NEWLINE> <INDENT> j = 0 <NEWLINE> while j < N : <NEWLINE> <INDENT> print ( L_ans [ j ] ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT>
r = float ( input ( ) ) <NEWLINE> pi = 3.141592653589 <NEWLINE> S = r * r * pi <NEWLINE> L = 2 * r * pi <NEWLINE> print ( str ( S ) + <STRING> + str ( L ) ) <NEWLINE>
a = input ( ) <NEWLINE> num = len ( a ) <NEWLINE> mod_map = { 0 : 1 } <NEWLINE> moji_int = 0 <NEWLINE> Sn = [ 0 ] * ( num + 1 ) <NEWLINE> tens = [ 1 ] * ( num + 1 ) <NEWLINE> for i in range ( - 1 , - num - 1 , - 1 ) : <NEWLINE> <INDENT> tens [ - i ] = tens [ - i - 1 ] * 10 % 2019 <NEWLINE> tmp = int ( a [ i ] ) * ( tens [ - i - 1 ] ) % 2019 <NEWLINE> Sn [ - i ] = ( Sn [ - i - 1 ] + tmp % 2019 ) % 2019 <NEWLINE> mod = Sn [ - i ] <NEWLINE> if mod not in mod_map : <NEWLINE> <INDENT> mod_map [ mod ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mod_map [ mod ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> res = 0 <NEWLINE> for i in mod_map . values ( ) : <NEWLINE> <INDENT> res += int ( i * ( i - 1 ) / 2 ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> from collections import * <NEWLINE> C = Counter ( S ) <NEWLINE> <NL> ans = 1 <NEWLINE> for c in C . values ( ) : <NEWLINE> <INDENT> ans *= ( c + 1 ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> ans = ( ans - 1 ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> p = [ 0 , 1 ] <NEWLINE> i = 2 <NEWLINE> while p [ - 1 ] <= x * x : <NEWLINE> <INDENT> p . append ( pow ( i , 5 ) ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> p_ = set ( p ) <NEWLINE> for z in p : <NEWLINE> <INDENT> if z - x in p_ : <NEWLINE> <INDENT> print ( int ( pow ( z , 1 / 5 ) ) , int ( pow ( z - x , 1 / 5 ) ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if x - z in p_ : <NEWLINE> <INDENT> print ( int ( pow ( abs ( x - z ) , 1 / 5 ) ) , int ( - pow ( z , 1 / 5 ) ) ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def TUPLE ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> N , D , A = MAP ( ) <NEWLINE> XH = [ LIST ( ) for _ in range ( N ) ] <NEWLINE> <NL> XH . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <NL> X , H = zip ( * XH ) <NEWLINE> right = [ 0 ] * N <NEWLINE> for i , x in enumerate ( X ) : <NEWLINE> <INDENT> right [ i ] = bisect ( X , x + 2 * D ) <NEWLINE> <NL> <DEDENT> damage = [ 0 ] * ( N + 1 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i , ( X , H ) in enumerate ( XH ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> damage [ i ] += damage [ i - 1 ] <NEWLINE> <DEDENT> H -= damage [ i ] <NEWLINE> if 0 < H : <NEWLINE> <INDENT> n = - ( - H // A ) <NEWLINE> ans += n <NEWLINE> d = A * n <NEWLINE> damage [ i ] += d <NEWLINE> damage [ right [ i ] ] -= d <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> xy = [ map ( int , input ( ) . split ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> <NL> def get_output ( ) : <NEWLINE> <INDENT> dist = [ 0 for _ in range ( N ) ] <NEWLINE> X , Y = [ ] , [ ] <NEWLINE> <NL> for i , ( x , y ) in enumerate ( xy ) : <NEWLINE> <INDENT> x , y = x - y , x + y <NEWLINE> X . append ( x ) <NEWLINE> Y . append ( y ) <NEWLINE> <NL> <DEDENT> a = max ( X ) - min ( X ) <NEWLINE> b = max ( Y ) - min ( Y ) <NEWLINE> return max ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> print ( get_output ( ) ) <NEWLINE>
from sys import stdin <NEWLINE> import bisect <NEWLINE> <NL> sysin = stdin . readline <NEWLINE> <NL> N , M , K = [ int ( x ) for x in sysin ( ) . rstrip ( ) . split ( ) ] <NEWLINE> a = [ int ( x ) for x in sysin ( ) . rstrip ( ) . split ( ) ] <NEWLINE> b = [ int ( x ) for x in sysin ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> <NL> accum_a = [ 0 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> _a = accum_a [ - 1 ] + i <NEWLINE> if _a > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> accum_a . append ( _a ) <NEWLINE> <DEDENT> <DEDENT> accum_a . append ( K ) <NEWLINE> <NL> accum_b = [ 0 ] <NEWLINE> for i in b : <NEWLINE> <INDENT> accum_b . append ( accum_b [ - 1 ] + i ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for j in range ( len ( accum_a ) - 1 ) : <NEWLINE> <INDENT> Kb = K - accum_a [ j ] <NEWLINE> bookB = bisect . bisect_right ( accum_b , Kb ) - 1 <NEWLINE> if j + bookB > ans : <NEWLINE> <INDENT> ans = j + bookB <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> res = np . zeros ( N + 1 ) <NEWLINE> <NL> th = int ( np . sqrt ( N ) ) + 1 <NEWLINE> for x in range ( 1 , th ) : <NEWLINE> <INDENT> for y in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , y + 1 ) : <NEWLINE> <INDENT> n = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if n > N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if x == y and y == z : <NEWLINE> <INDENT> res [ n ] += 1 <NEWLINE> <DEDENT> elif x == y or y == z or z == x : <NEWLINE> <INDENT> res [ n ] += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res [ n ] += 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( int ( res [ i ] ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> log_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> maxx = 10 ** 9 <NEWLINE> minx = 0 <NEWLINE> <NL> while ( maxx - minx != 1 ) : <NEWLINE> <INDENT> midx = ( maxx + minx ) // 2 <NEWLINE> cut_n = sum ( [ math . ceil ( length / midx ) - 1 for length in log_list ] ) <NEWLINE> if cut_n > K : <NEWLINE> <INDENT> minx = midx <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> maxx = midx <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( maxx ) <NEWLINE>
from math import gcd <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> g = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> g = gcd ( g , a ) <NEWLINE> <DEDENT> if g > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> MAXN = 10 ** 6 + 10 <NEWLINE> sieve = [ i for i in range ( MAXN + 1 ) ] <NEWLINE> p = 2 <NEWLINE> while p * p <= MAXN : <NEWLINE> <INDENT> if sieve [ p ] == p : <NEWLINE> <INDENT> for q in range ( 2 * p , MAXN + 1 , p ) : <NEWLINE> <INDENT> if sieve [ q ] == q : <NEWLINE> <INDENT> sieve [ q ] = p <NEWLINE> <DEDENT> <DEDENT> <DEDENT> p += 1 <NEWLINE> <NL> <DEDENT> st = set ( ) <NEWLINE> for a in A : <NEWLINE> <INDENT> tmp = set ( ) <NEWLINE> while a > 1 : <NEWLINE> <INDENT> tmp . add ( sieve [ a ] ) <NEWLINE> a //= sieve [ a ] <NEWLINE> <DEDENT> for p in tmp : <NEWLINE> <INDENT> if p in st : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> st . add ( p ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for m in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( i , gcd ( j , m ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import copy <NEWLINE> import random <NEWLINE> import bisect <COMMENT> <NEWLINE> import fractions <COMMENT> <NEWLINE> import math <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> from decimal import Decimal <COMMENT> <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( mod ) <COMMENT> <NEWLINE> <NL> d = collections . deque ( ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> xyh = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y , h = LI ( ) <NEWLINE> xyh . append ( [ x , y , h ] ) <NEWLINE> <NL> <NL> <DEDENT> <STRING> <NEWLINE> xyh = sorted ( xyh , key = lambda xyh : xyh [ 2 ] , reverse = True ) <NEWLINE> <NL> <COMMENT> <NL> ans = ( 0 , 0 , 0 ) <NEWLINE> for c_x in range ( 101 ) : <NEWLINE> <INDENT> for c_y in range ( 101 ) : <NEWLINE> <INDENT> H = 0 <NEWLINE> flag = True <NEWLINE> for i , ( x , y , h ) in enumerate ( xyh ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> H = h + abs ( x - c_x ) + abs ( y - c_y ) <NEWLINE> <DEDENT> if h != max ( H - abs ( x - c_x ) - abs ( y - c_y ) , 0 ) : <NEWLINE> <COMMENT> <NL> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> ans = ( c_x , c_y , H ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> X , Y , H = ans <NEWLINE> print ( X , Y , H ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = 10 ** 6 + 1 <NEWLINE> cnt = [ 0 ] * M <NEWLINE> for a in A : <NEWLINE> <INDENT> if cnt [ a ] != 0 : <NEWLINE> <INDENT> cnt [ a ] += 1 <NEWLINE> continue <NEWLINE> <DEDENT> for b in range ( a , M , a ) : <NEWLINE> <INDENT> cnt [ b ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if cnt [ a ] == 1 : ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> def solve ( N , A ) : <NEWLINE> <INDENT> A . sort ( ) <COMMENT> <NEWLINE> Amax = A [ - 1 ] <NEWLINE> dp = [ 1 ] * ( Amax + 1 ) <COMMENT> <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> p = A [ i ] <NEWLINE> if dp [ p ] == 1 : <COMMENT> <NEWLINE> <INDENT> for q in range ( Amax // p + 1 ) : <NEWLINE> <INDENT> dp [ p * q ] = 0 <COMMENT> <NEWLINE> <DEDENT> if A [ i ] != A [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if dp [ Amax ] == 1 : <COMMENT> <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> def solve_old ( N , A ) : <NEWLINE> <INDENT> A = sorted ( A ) <NEWLINE> dp = [ True for i in range ( N ) ] <COMMENT> <NEWLINE> <NL> idx = 0 <NEWLINE> while True : <NEWLINE> <INDENT> a = A [ idx ] <NEWLINE> for j , target in enumerate ( A [ i + 1 : ] ) : <NEWLINE> <INDENT> if target % a == 0 : <NEWLINE> <INDENT> dp [ idx + j + 1 ] = False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if dp [ i ] == False : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> elif A . count ( a ) > 1 : <COMMENT> <NEWLINE> <INDENT> dp [ i ] = False <NEWLINE> continue <NEWLINE> <NL> <DEDENT> for j , target in enumerate ( A [ i + 1 : ] ) : <COMMENT> <NEWLINE> <INDENT> if target % a == 0 : <NEWLINE> <INDENT> dp [ i + j + 1 ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if dp [ i ] == True : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> def solve_old ( N , A ) : <NEWLINE> <INDENT> A = sorted ( A ) <NEWLINE> dp = [ True for i in range ( N ) ] <COMMENT> <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if dp [ i ] == False : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> elif A . count ( a ) > 1 : <COMMENT> <NEWLINE> <INDENT> dp [ i ] = False <NEWLINE> continue <NEWLINE> <NL> <DEDENT> for j , target in enumerate ( A [ i + 1 : ] ) : <COMMENT> <NEWLINE> <INDENT> if target % a == 0 : <NEWLINE> <INDENT> dp [ i + j + 1 ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if dp [ i ] == True : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> A = [ int ( next ( tokens ) ) for _ in range ( N ) ] <COMMENT> <NEWLINE> solve ( N , A ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> const = 1000000007 <NEWLINE> ans = 0 <NEWLINE> total = sum ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> total -= A [ i ] <NEWLINE> ans += A [ i ] * total <NEWLINE> <DEDENT> print ( ans % const ) <NEWLINE>
import sys <NEWLINE> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , ( input ( ) . split ( ) ) ) ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> over = False <NEWLINE> <NL> for A in As : <NEWLINE> <INDENT> if A == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for A in As : <NEWLINE> <INDENT> ans *= A <NEWLINE> if ans > INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> <NL> for i in range ( n - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> b [ a [ i ] - 1 ] += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> print ( b [ j ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> m = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a = i <NEWLINE> if a % 3 == 0 : <NEWLINE> <INDENT> m . append ( i ) <NEWLINE> continue <NEWLINE> <DEDENT> while a > 0 : <NEWLINE> <INDENT> if a % 10 == 3 : <NEWLINE> <INDENT> m . append ( i ) <NEWLINE> break <NEWLINE> <DEDENT> a //= 10 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * m ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> for i in range ( n - ( k - 1 ) ) : <NEWLINE> <INDENT> if i >= 1 : <NEWLINE> <INDENT> if a [ i - 1 ] < a [ k + i - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> X = abs ( X ) <NEWLINE> <NL> <COMMENT> <NL> r = X % D <NEWLINE> <COMMENT> <NL> q = X // D <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> if K <= q : <NEWLINE> <INDENT> print ( X - D * K ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> rem = K - q <NEWLINE> <NL> <COMMENT> <NL> if rem % 2 == 0 : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( D - r ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) ) <NEWLINE> e = int ( ) <NEWLINE> e = 0 <NEWLINE> flag = True <NEWLINE> while flag : <NEWLINE> <INDENT> flag = False <NEWLINE> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if s [ i ] < s [ i - 1 ] : <NEWLINE> <INDENT> s [ i - 1 ] , s [ i ] = s [ i ] , s [ i - 1 ] <NEWLINE> e = e + 1 <NEWLINE> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 0 , len ( s ) ) : <NEWLINE> <INDENT> if i != len ( s ) - 1 : <NEWLINE> <INDENT> print ( s [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( e ) <NEWLINE> <NL>
def resolve ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <COMMENT> <NEWLINE> to_index = lambda x : int ( x ) - 1 <COMMENT> <NEWLINE> print_list_in_2D = lambda x : print ( * x , sep = <STRING> ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> def input_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def map_int_input ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) ) <NEWLINE> <NL> <DEDENT> MII = map_int_input <NEWLINE> <NL> def MII_split ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def MII_to_index ( ) : <NEWLINE> <INDENT> return map ( to_index , input ( ) ) <NEWLINE> <NL> <DEDENT> def MII_split_to_index ( ) : <NEWLINE> <INDENT> return map ( to_index , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def list_int_inputs ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) ) ) <NEWLINE> <NL> <DEDENT> LII = list_int_inputs <NEWLINE> <NL> def LII_split ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def LII_2D ( rows_number ) : <NEWLINE> <INDENT> return [ LII ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> <DEDENT> def LII_split_2D ( rows_number ) : <NEWLINE> <INDENT> return [ LII_split ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> <DEDENT> N = input_int ( ) <NEWLINE> A = LII_split ( ) <NEWLINE> <NL> s = 0 <NEWLINE> right_sum = 0 <NEWLINE> for i in reversed ( range ( N - 1 ) ) : <NEWLINE> <INDENT> right_sum += A [ i + 1 ] <NEWLINE> s += A [ i ] * right_sum <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if s > 10 ** 9 + 7 : <NEWLINE> <INDENT> s %= 10 ** 9 + 7 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> x = ri ( ) <NEWLINE> for a in range ( 150 ) : <NEWLINE> <INDENT> for b in range ( - 150 , a ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
import random <NEWLINE> random . seed ( 42 ) <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> C = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> S = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( D ) ] <NEWLINE> <NL> def score_calc ( T ) : <NEWLINE> <INDENT> total = 0 <NEWLINE> last = [ 0 ] * 26 <NEWLINE> for i in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> t = T [ i - 1 ] <NEWLINE> total += S [ i - 1 ] [ t - 1 ] <NEWLINE> last [ t - 1 ] = i <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> total -= C [ j ] * ( i - last [ j ] ) <NEWLINE> <DEDENT> <DEDENT> return total <NEWLINE> <NL> <DEDENT> N = 1000 <NEWLINE> T_ls = [ [ random . randint ( 1 , 26 ) for i in range ( D ) ] for j in range ( N ) ] <NEWLINE> best_score = 0 <NEWLINE> ans = [ 1 ] * D <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if score_calc ( T_ls [ i ] ) > best_score : <NEWLINE> <INDENT> best_score = score_calc ( T_ls [ i ] ) <NEWLINE> ans = T_ls [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
cost = input ( ) <NEWLINE> amari = int ( cost [ - 3 : ] ) <NEWLINE> if amari == 0 : <NEWLINE> <INDENT> amari = 1000 <NEWLINE> <DEDENT> print ( 1000 - amari ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K + 1 , N + 1 ) : <NEWLINE> <INDENT> a_latest , a_last = A [ i ] , A [ i - K ] <NEWLINE> if a_latest > a_last : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
H , W , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> masme = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> masme . append ( list ( input ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> h_p = [ ] <NEWLINE> for h in range ( pow ( 2 , H ) ) : <NEWLINE> <INDENT> h_p . append ( str ( bin ( h ) ) [ 2 : ] . zfill ( H ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> w_p = [ ] <NEWLINE> for w in range ( pow ( 2 , W ) ) : <NEWLINE> <INDENT> w_p . append ( str ( bin ( w ) ) [ 2 : ] . zfill ( W ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> def count ( mas ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in mas : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> if ( j == <STRING> ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def delete_row ( mas , i ) : <NEWLINE> <INDENT> ilist = list ( i ) <NEWLINE> <COMMENT> <NL> ans = [ ] <NEWLINE> for n in range ( H ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ilist [ n ] == <STRING> : <NEWLINE> <INDENT> ans . append ( mas [ n ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def delete_column ( mas , i ) : <NEWLINE> <INDENT> ilist = list ( i ) <NEWLINE> ans = [ ] <NEWLINE> for row in mas : <NEWLINE> <COMMENT> <NL> <INDENT> tmp_row = [ ] <NEWLINE> for n in range ( W ) : <NEWLINE> <INDENT> if ( ilist [ n ] == <STRING> ) : <NEWLINE> <INDENT> tmp_row . append ( row [ n ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans . append ( tmp_row ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> ans_cnt = 0 <NEWLINE> for h in h_p : <NEWLINE> <INDENT> for w in w_p : <NEWLINE> <INDENT> tmp = delete_row ( masme , h ) <NEWLINE> tmp2 = delete_column ( tmp , w ) <NEWLINE> cnt = count ( tmp2 ) <NEWLINE> if ( cnt == K ) : <NEWLINE> <INDENT> ans_cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans_cnt ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if not N == 0 : <NEWLINE> <INDENT> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> index = 0 <NEWLINE> value = abs ( A [ 0 ] - X ) <NEWLINE> up_list = [ 0 ] * ( N + 1 ) <NEWLINE> down_list = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if abs ( A [ i ] - X ) < N + 1 : <NEWLINE> <INDENT> if A [ i ] - X >= 0 : <NEWLINE> <INDENT> up_list [ A [ i ] - X ] = 1 <NEWLINE> <DEDENT> if A [ i ] - X <= 0 : <NEWLINE> <INDENT> down_list [ abs ( A [ i ] - X ) ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> j = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if down_list [ j ] == 0 : <NEWLINE> <INDENT> print ( X - j ) <NEWLINE> break <NEWLINE> <DEDENT> if up_list [ j ] == 0 : <NEWLINE> <INDENT> print ( X + j ) <NEWLINE> break <NEWLINE> <DEDENT> if j > N + 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> class Rect ( ) : <NEWLINE> <INDENT> def __init__ ( self , w , h ) : <NEWLINE> <INDENT> self . w = w <NEWLINE> self . h = h <NEWLINE> <NL> <DEDENT> def draw ( self ) : <NEWLINE> <INDENT> for i in range ( self . w ) : <NEWLINE> <INDENT> for j in range ( self . h ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> data = [ ] <NEWLINE> while 1 : <NEWLINE> <INDENT> n = input ( ) . split ( ) <NEWLINE> w = int ( n [ 0 ] ) <NEWLINE> h = int ( n [ 1 ] ) <NEWLINE> <NL> if w == 0 and h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> data . append ( Rect ( w , h ) ) <NEWLINE> <NL> <DEDENT> for num in data : <NEWLINE> <INDENT> num . draw ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( a = r * r * math . pi , b = r * 2 * math . pi ) ) <NEWLINE> <NL>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ab = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> total += math . gcd ( ab , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = x * i <NEWLINE> x = x % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
from collections import defaultdict <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a = list ( map ( lambda i : int ( i ) - 1 , input ( ) . split ( <STRING> ) ) ) <NEWLINE> s = [ 0 ] <NEWLINE> d = defaultdict ( lambda : 0 ) <NEWLINE> x = a [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( x ) <NEWLINE> x = a [ x ] <NEWLINE> <NL> <DEDENT> bb = None <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d [ s [ i ] ] += 1 <NEWLINE> if d [ s [ i ] ] == 2 : <NEWLINE> <INDENT> bb = s [ i ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> cc = s . index ( bb ) <NEWLINE> s [ cc ] = - 1 <NEWLINE> dd = s . index ( bb ) <NEWLINE> loop_len = dd - cc <NEWLINE> s [ cc ] = s [ dd ] <NEWLINE> <NL> if bb == None or k < cc : <NEWLINE> <INDENT> print ( s [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = ( k - cc ) % loop_len <NEWLINE> print ( s [ y + cc ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> A = np . zeros ( 11 , dtype = int ) <NEWLINE> for i in range ( 11 ) : <NEWLINE> <INDENT> A [ i ] = ( 26 ** ( i + 1 ) ) <NEWLINE> <DEDENT> B = np . cumsum ( A ) <NEWLINE> for i in range ( 11 ) : <NEWLINE> <INDENT> if N <= B [ i ] : <NEWLINE> <INDENT> name = [ <STRING> ] * ( i + 1 ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> N = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N -= B [ i - 1 ] <NEWLINE> <DEDENT> for j in reversed ( range ( i + 1 ) ) : <NEWLINE> <INDENT> if j >= 1 : <NEWLINE> <INDENT> if N == 0 : <NEWLINE> <INDENT> name [ i - j ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> name [ i - j ] = a [ ( N - 1 ) // A [ j - 1 ] ] <NEWLINE> <DEDENT> N -= N // A [ j - 1 ] * A [ j - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if N == 0 : <NEWLINE> <INDENT> name [ i - j ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> name [ i - j ] = a [ N - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( name ) ) <NEWLINE>
s = input ( ) <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> i , j = map ( int , a [ 1 : 3 ] ) <NEWLINE> if a [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( s [ i : j + 1 ] ) <NEWLINE> <DEDENT> elif a [ 0 ] == <STRING> : <NEWLINE> <INDENT> t1 = s [ 0 : i ] <NEWLINE> t2 = list ( s [ i : j + 1 ] ) <NEWLINE> t2 . reverse ( ) <NEWLINE> t3 = s [ j + 1 : ] <NEWLINE> s = t1 + <STRING> . join ( t2 ) + t3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s [ 0 : i ] + a [ 3 ] + s [ j + 1 : ] <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . reverse ( ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> S = [ 0 ] <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> S . append ( S [ i ] + a [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for j in range ( len ( a ) ) : <NEWLINE> <INDENT> ans += ( a [ j ] * S [ j ] ) <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> result = 0 <NEWLINE> x = min ( N , B - 1 ) <NEWLINE> a = ( A * x ) // B <NEWLINE> b = A * ( x // B ) <NEWLINE> result = max ( result , a - b ) <NEWLINE> print ( result ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = 1 <NEWLINE> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> b = b * i <NEWLINE> if b > 1000000007 : <NEWLINE> <INDENT> b = b % 1000000007 <NEWLINE> <DEDENT> <DEDENT> if b < 1000000000 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b % 1000000007 ) <NEWLINE> <DEDENT>
N , M , X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> CA = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> set_list = [ ] <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> select = [ ] <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> select . append ( j ) <NEWLINE> <DEDENT> <DEDENT> if len ( select ) != 0 : <NEWLINE> <INDENT> set_list . append ( select ) <NEWLINE> <NL> <DEDENT> <DEDENT> cost = [ ] <NEWLINE> for i in range ( 2 ** N - 1 ) : <NEWLINE> <INDENT> cost . append ( sum ( [ CA [ set_list [ i ] [ j ] ] [ 0 ] for j in range ( len ( set_list [ i ] ) ) ] ) ) <NEWLINE> <NL> <DEDENT> skill = [ ] <NEWLINE> for i in range ( 2 ** N - 1 ) : <NEWLINE> <INDENT> tmp = [ 0 ] * M <NEWLINE> for j in set_list [ i ] : <NEWLINE> <INDENT> for k in range ( M ) : <NEWLINE> <INDENT> tmp [ k ] += CA [ j ] [ k + 1 ] <NEWLINE> <DEDENT> <DEDENT> skill . append ( tmp ) <NEWLINE> <NL> <DEDENT> pool = [ ] <NEWLINE> for i in range ( 2 ** N - 1 ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for j in skill [ i ] : <NEWLINE> <INDENT> if j < X : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> pool . append ( cost [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if len ( pool ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( pool ) ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S [ 2 ] == S [ 3 ] and S [ 4 ] == S [ 5 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> dormitory = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> data = [ int ( j ) for j in list ( input ( ) . split ( ) ) ] <NEWLINE> tower = data [ 0 ] - 1 <NEWLINE> rank = data [ 1 ] - 1 <NEWLINE> room = data [ 2 ] - 1 <NEWLINE> dormitory [ tower ] [ rank ] [ room ] += data [ 3 ] <NEWLINE> <NL> <DEDENT> for i in range ( 0 , 4 ) : <NEWLINE> <INDENT> for j in range ( 0 , 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , dormitory [ i ] [ j ] ) ) ) <NEWLINE> <DEDENT> if i == 3 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += gcd ( c , gcd ( a , b ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = input ( ) <NEWLINE> N = int ( N ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> s [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> d = { i : set ( ) for i in range ( 1 , n + 1 ) } <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d [ a ] . add ( b ) <NEWLINE> d [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> vis = set ( ) <NEWLINE> res = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i not in vis : <NEWLINE> <INDENT> stack = [ i ] <NEWLINE> ans = 1 <NEWLINE> vis . add ( i ) <NEWLINE> while stack : <NEWLINE> <INDENT> cur = stack . pop ( ) <NEWLINE> for j in d [ cur ] : <NEWLINE> <INDENT> if j not in vis : <NEWLINE> <INDENT> vis . add ( j ) <NEWLINE> ans += 1 <NEWLINE> stack . append ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> res = max ( res , ans ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL>
class fibNum ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . arr = [ 1 , 1 ] <NEWLINE> <DEDENT> def fib ( self , n ) : <NEWLINE> <INDENT> return_num = 1 <NEWLINE> if n > 1 : <NEWLINE> <INDENT> if len ( self . arr ) <= n : <NEWLINE> <INDENT> self . arr . append ( self . fib ( n - 1 ) + self . fib ( n - 2 ) ) <NEWLINE> <DEDENT> return_num = self . arr [ n ] <NEWLINE> <DEDENT> return return_num <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> fn = fibNum ( ) <NEWLINE> print ( fn . fib ( n ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> cos = 0 <NEWLINE> mi = m / 60 * 360 <COMMENT> <NEWLINE> hour = ( 60 * h + m ) / 720 * 360 <COMMENT> <NEWLINE> <NL> cos = math . cos ( math . radians ( hour - mi ) ) <NEWLINE> ans = a * a + b * b - 2 * a * b * cos <NEWLINE> <COMMENT> <NL> ans = ans ** ( 1 / 2 ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = int ( 1e9 + 7 ) <NEWLINE> rem = ( 10 * 100 ) % MOD <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> if i == k : <NEWLINE> <INDENT> minimum = np . arange ( i ) . sum ( ) <NEWLINE> maximum = np . arange ( n , n - i , - 1 ) . sum ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minimum += i - 1 <NEWLINE> maximum += n - i + 1 <NEWLINE> <DEDENT> ans += ( maximum - minimum + 1 ) % MOD <NEWLINE> <NL> <DEDENT> print ( ans % MOD ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> initial = ( 1 , 1 , 1 ) <NEWLINE> queue = [ ] <NEWLINE> queue . append ( initial ) <NEWLINE> pointer = 0 <NEWLINE> answers = [ 0 ] * ( N + 1 ) <NEWLINE> memo = { } <NEWLINE> while pointer < len ( queue ) : <NEWLINE> <INDENT> x , y , z = queue [ pointer ] <NEWLINE> <COMMENT> <NL> q = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if q < N + 1 : <NEWLINE> <INDENT> add = 1 <NEWLINE> if x == y and y == z : <NEWLINE> <INDENT> add = 1 <NEWLINE> <DEDENT> elif x == y or y == z or z == x : <NEWLINE> <INDENT> add = 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> add = 6 <NEWLINE> <DEDENT> answers [ q ] += add <NEWLINE> <NL> if x + 1 >= y and y >= z and ( x + 1 , y , z ) not in memo : <NEWLINE> <INDENT> memo [ ( x + 1 , y , z ) ] = 0 <NEWLINE> queue . append ( ( x + 1 , y , z ) ) <NEWLINE> <DEDENT> if x >= y + 1 and y + 1 >= z and ( x , y + 1 , z ) not in memo : <NEWLINE> <INDENT> memo [ ( x , y + 1 , z ) ] = 0 <NEWLINE> queue . append ( ( x , y + 1 , z ) ) <NEWLINE> <DEDENT> if x >= y and y >= z + 1 and ( x , y , z + 1 ) not in memo : <NEWLINE> <INDENT> memo [ ( x , y , z + 1 ) ] = 0 <NEWLINE> queue . append ( ( x , y , z + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> pointer += 1 <NEWLINE> <NL> <NL> <DEDENT> for a in answers [ 1 : N + 1 ] : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> row = [ 0 ] * ( h + 1 ) <NEWLINE> rn = [ [ ] for _ in range ( h + 1 ) ] <NEWLINE> col = [ 0 ] * ( w + 1 ) <NEWLINE> cn = [ [ ] for _ in range ( w + 1 ) ] <NEWLINE> data = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> hd , wd = map ( int , input ( ) . split ( ) ) <NEWLINE> row [ hd ] += 1 <NEWLINE> rn [ hd ] . append ( wd ) <NEWLINE> col [ wd ] += 1 <NEWLINE> cn [ wd ] . append ( hd ) <NEWLINE> <NL> <DEDENT> cm = max ( col ) <NEWLINE> rm = max ( row ) <NEWLINE> ri = [ x for x , y in enumerate ( row ) if y == rm ] <NEWLINE> ci = [ x for x , y in enumerate ( col ) if y == cm ] <NEWLINE> for r in ri : <NEWLINE> <INDENT> rs = set ( rn [ r ] ) <NEWLINE> for c in ci : <NEWLINE> <INDENT> if c not in rs : <NEWLINE> <INDENT> ans = cm + rm <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = cm + rm - 1 <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> a = [ 0 ] * ( 10 ** 5 ) <NEWLINE> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> for j in range ( 1 , 100 ) : <NEWLINE> <INDENT> for k in range ( 1 , 100 ) : <NEWLINE> <INDENT> a [ ( i + j + k ) ** 2 - ( i * j + j * k + i * k ) ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( a [ i + 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> a , b , c = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> <NL> l = [ a , b , c ] <NEWLINE> l . sort ( ) <NEWLINE> <NL> for i , j in enumerate ( l ) : <NEWLINE> <INDENT> print ( j , end = <STRING> if i != len ( l ) - 1 else <STRING> ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> lrL = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> li = [ 0 ] * n <NEWLINE> mx = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> mx += 1 <NEWLINE> <DEDENT> li [ i + 1 ] = mx <NEWLINE> <NL> <DEDENT> for l , r in lrL : <NEWLINE> <INDENT> print ( li [ r - 1 ] - li [ l - 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> biggest = 0 <NEWLINE> humidai = 0 <NEWLINE> <NL> result = 0 <NEWLINE> <NL> tmp_list = [ ] <NEWLINE> <NL> tmp = sum ( A ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> tmp -= A [ i ] <NEWLINE> <NL> result += A [ i ] * tmp <NEWLINE> <NL> if result > 10 ** 9 + 7 : <NEWLINE> <INDENT> result = result % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> <DEDENT> result = result % ( 10 ** 9 + 7 ) <NEWLINE> <NL> print ( result ) <NEWLINE>
import math <NEWLINE> <STRING> <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <STRING> <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ab = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( ab , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N = input ( ) . split ( ) <NEWLINE> X = int ( math . fabs ( int ( N [ 0 ] ) ) ) <NEWLINE> K = int ( N [ 1 ] ) <NEWLINE> D = int ( N [ 2 ] ) <NEWLINE> if X - K * D >= 0 : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> syou = X // D <NEWLINE> x = X - syou * D <NEWLINE> y = X - ( syou + 1 ) * D <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> if syou % 2 == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( math . fabs ( y ) ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if syou % 2 == 0 : <NEWLINE> <INDENT> print ( int ( math . fabs ( y ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> cnt += ( n - 1 ) // a <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
MAXN = 300010 <NEWLINE> sieve = [ 1 ] * MAXN <NEWLINE> primes = [ ] <NEWLINE> for n in range ( 7 , MAXN , 7 ) : <NEWLINE> <INDENT> for m in [ n - 1 , n + 1 ] : <NEWLINE> <INDENT> if sieve [ m ] == 0 : continue <NEWLINE> primes . append ( m ) <NEWLINE> for l in range ( 2 * m , MAXN , m ) : <NEWLINE> <INDENT> sieve [ l ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def solve ( n ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> for p in primes : <NEWLINE> <INDENT> if p > n : break <NEWLINE> if n % p == 0 : <NEWLINE> <INDENT> ret . append ( p ) <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if N == 1 : break <NEWLINE> ans = <STRING> . join ( list ( map ( str , solve ( N ) ) ) ) <NEWLINE> print ( <STRING> . format ( N , ans ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> r = range ( - 1000 , 1000 ) <NEWLINE> for a in r : <NEWLINE> <INDENT> for b in r : <NEWLINE> <INDENT> if a * a * a * a * a - b * b * b * b * b == x : <NEWLINE> <INDENT> ans = ( a , b ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans [ 0 ] , ans [ 1 ] ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> A = list ( sorted ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> counter = defaultdict ( int ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> counter [ C ] += B <NEWLINE> <DEDENT> c_list = list ( sorted ( counter . keys ( ) , reverse = True ) ) <NEWLINE> <NL> <COMMENT> <NL> moves = [ ] <NEWLINE> n = 0 <NEWLINE> for c in c_list : <NEWLINE> <INDENT> b = counter [ c ] <NEWLINE> if n + b < N : <NEWLINE> <INDENT> p = b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = N - n <NEWLINE> <DEDENT> for i in range ( p ) : <NEWLINE> <INDENT> moves . append ( c ) <NEWLINE> <DEDENT> if len ( moves ) >= N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> siz = min ( N , len ( moves ) ) <NEWLINE> for i in range ( siz ) : <NEWLINE> <COMMENT> <NL> <INDENT> A [ i ] = max ( A [ i ] , moves [ i ] ) <NEWLINE> <NL> <DEDENT> print ( sum ( A ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( B - 1 , N ) <NEWLINE> print ( A * x // B - A * ( x // B ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = ( S - ( h * 3600 ) ) // 60 <NEWLINE> s = ( S - ( h * 3600 ) ) % 60 <NEWLINE> print ( h , m , s , sep = <STRING> ) <NEWLINE>
def multiply2 ( A ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> for item in A : <NEWLINE> <INDENT> res *= item <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( multiply2 ( A ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import numpy as np <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> from scipy . sparse . csgraph import breadth_first_order <NEWLINE> <NL> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> row = [ ] <NEWLINE> col = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> r , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> row . append ( c - 1 ) <NEWLINE> col . append ( r - 1 ) <NEWLINE> <NL> <DEDENT> data = [ 1 ] * ( M ) <NEWLINE> <NL> csr = csr_matrix ( ( data , ( row , col ) ) , shape = ( N , N ) ) <NEWLINE> _ , proc = breadth_first_order ( csr , 0 , directed = False ) <NEWLINE> <NL> if - 9999 in proc [ 1 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( ( proc [ 1 : ] + 1 ) . astype ( <STRING> ) ) ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> s = deque ( input ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> now : bool = True <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> q = list ( input ( ) . split ( ) ) <NEWLINE> if q [ 0 ] == <STRING> : <NEWLINE> <INDENT> now = not now <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( q [ 1 ] == <STRING> and now == True ) or ( q [ 1 ] == <STRING> and now == False ) : <NEWLINE> <INDENT> s . appendleft ( q [ 2 ] ) <NEWLINE> <DEDENT> elif ( q [ 1 ] == <STRING> and now == False ) or ( q [ 1 ] == <STRING> and now == True ) : <NEWLINE> <INDENT> s . append ( q [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if now == True : <NEWLINE> <INDENT> print ( <STRING> . join ( s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( reversed ( s ) ) ) <NEWLINE> <DEDENT>
from bisect import bisect_right <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> b [ i + 1 ] += b [ i ] <NEWLINE> <NL> <NL> <DEDENT> def f ( time , r ) : <NEWLINE> <INDENT> ret = bisect_right ( r , time ) - 1 <NEWLINE> return ret <NEWLINE> <NL> <NL> <DEDENT> def fa ( time ) : <NEWLINE> <INDENT> return f ( time , a ) <NEWLINE> <NL> <NL> <DEDENT> def fb ( time ) : <NEWLINE> <INDENT> return f ( time , b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i , ai in enumerate ( a ) : <NEWLINE> <INDENT> k -= ai <NEWLINE> if k < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = max ( ans , i + fb ( k ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> root = [ - 1 ] * n <NEWLINE> <NL> <NL> def r ( x ) : <NEWLINE> <INDENT> if root [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root [ x ] = r ( root [ x ] ) <NEWLINE> return root [ x ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = r ( x ) <NEWLINE> y = r ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> root [ x ] += root [ y ] <NEWLINE> root [ y ] = x <NEWLINE> <NL> <NL> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> return - 1 * root [ r ( x ) ] <NEWLINE> <NL> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> unite ( a , b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> while len ( arr ) > 1 : <NEWLINE> <INDENT> m = len ( arr ) <NEWLINE> if m & 1 : <NEWLINE> <INDENT> arr . append ( 1 ) <NEWLINE> m += 1 <NEWLINE> <NL> <DEDENT> left , right = arr [ : m // 2 ] , arr [ m // 2 : ] <NEWLINE> arr = [ x * y for x , y in zip ( left , right ) ] <NEWLINE> <NL> <DEDENT> x = arr [ 0 ] <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> sum = 1 <NEWLINE> keta = 0 <NEWLINE> <NL> numbers = input ( ) . split ( ) <NEWLINE> if not ( <STRING> in numbers ) : <NEWLINE> <INDENT> for num in numbers : <NEWLINE> <INDENT> keta += len ( num ) - 1 <NEWLINE> if keta > 19 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> sum *= int ( num ) <NEWLINE> if len ( str ( sum ) ) > 19 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( str ( sum ) ) == 19 : <NEWLINE> <INDENT> if str ( sum ) . count ( <STRING> ) == 1 and str ( sum ) . count ( <STRING> ) == 18 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a == b != c ) or ( a != b == c ) or ( a == c != b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> mod = 10 ** 9 + 7 <NEWLINE> def multarray ( x ) : <NEWLINE> <INDENT> ret = 1 <NEWLINE> for i in x : <NEWLINE> <INDENT> ret *= i <NEWLINE> ret %= mod <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n == k : <NEWLINE> <INDENT> print ( multarray ( a ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ap , am = [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] >= 0 : <NEWLINE> <INDENT> ap . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> am . append ( a [ i ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ap . sort ( reverse = True ) <NEWLINE> am . sort ( ) <NEWLINE> <NL> if len ( am ) == 0 : <NEWLINE> <INDENT> print ( multarray ( ap [ : k ] ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if len ( ap ) == 0 : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> print ( multarray ( am [ : k ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( multarray ( am [ : : - 1 ] [ : k ] ) ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> apm2 = [ ] <NEWLINE> for i in range ( len ( am ) // 2 ) : <NEWLINE> <INDENT> apm2 . append ( ( am [ 2 * i ] * am [ 2 * i + 1 ] , 0 ) ) <NEWLINE> <DEDENT> for i in range ( len ( ap ) // 2 ) : <NEWLINE> <INDENT> apm2 . append ( ( ap [ 2 * i ] * ap [ 2 * i + 1 ] , 1 ) ) <NEWLINE> <DEDENT> apm2 . sort ( reverse = True ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> p = 0 <NEWLINE> ans = [ ] <NEWLINE> for i in range ( k // 2 ) : <NEWLINE> <INDENT> p += ( 2 * apm2 [ i ] [ 1 ] ) <NEWLINE> ans . append ( apm2 [ i ] [ 0 ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if k % 2 == 0 : <NEWLINE> <INDENT> print ( multarray ( ans ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if p == len ( ap ) : <NEWLINE> <COMMENT> <NL> <INDENT> check_i = ans . index ( ap [ p - 1 ] * ap [ p - 2 ] ) <NEWLINE> ans [ check_i ] = ap [ p - 2 ] <NEWLINE> ans . append ( apm2 [ k // 2 ] [ 0 ] ) <NEWLINE> print ( multarray ( ans ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans_cand = [ ] <NEWLINE> <COMMENT> <NL> ans_cand . append ( multarray ( ans ) * ap [ p ] % mod ) <NEWLINE> if p >= 2 : <NEWLINE> <COMMENT> <NL> <INDENT> check_i = ans . index ( ap [ p - 1 ] * ap [ p - 2 ] ) <NEWLINE> <COMMENT> <NL> ans [ check_i ] = ap [ p - 2 ] <NEWLINE> ans . append ( apm2 [ k // 2 ] [ 0 ] ) <NEWLINE> ans_cand . append ( multarray ( ans ) ) <NEWLINE> <DEDENT> print ( max ( ans_cand ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> import collections <NEWLINE> <NL> def solve ( S : int ) : <NEWLINE> <INDENT> S = list ( map ( int , list ( str ( S ) ) ) ) <NEWLINE> count = collections . defaultdict ( int ) <NEWLINE> <NL> count [ 0 ] = 1 <NEWLINE> tmp = <STRING> <NEWLINE> prev_modulo = 0 <NEWLINE> for idx , s in enumerate ( S [ : : - 1 ] ) : <NEWLINE> <INDENT> prev_modulo = ( s * pow ( 10 , idx , 2019 ) + prev_modulo ) % 2019 <NEWLINE> count [ prev_modulo ] += 1 <NEWLINE> <NL> <DEDENT> result = 0 <NEWLINE> for k , v in count . items ( ) : <NEWLINE> <INDENT> result += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> print ( result ) <NEWLINE> return <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> S = int ( next ( tokens ) ) <COMMENT> <NEWLINE> solve ( S ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> ansa = 0 <NEWLINE> sa = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sa += A [ i ] <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> if sa >= 0 : <NEWLINE> <INDENT> ansa += abs ( sa ) + 1 <NEWLINE> sa = - 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if sa <= 0 : <NEWLINE> <INDENT> ansa += abs ( sa ) + 1 <NEWLINE> sa = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> ansb = 0 <NEWLINE> sb = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sb += A [ i ] <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> if sb <= 0 : <NEWLINE> <INDENT> ansb += abs ( sb ) + 1 <NEWLINE> sb = + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if sb >= 0 : <NEWLINE> <INDENT> ansb += abs ( sb ) + 1 <NEWLINE> sb = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( min ( ansa , ansb ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
def binary_search ( key , a ) : <NEWLINE> <INDENT> l = 0 <NEWLINE> r = len ( a ) <NEWLINE> ix = ( r - l ) // 2 <NEWLINE> <NL> while r - l > 0 : <NEWLINE> <INDENT> if key == a [ ix ] : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> if key < a [ ix ] : <NEWLINE> <INDENT> r = ix <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = ix + 1 <NEWLINE> <DEDENT> ix = l + ( r - l ) // 2 <NEWLINE> <NL> <DEDENT> return False <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> s = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> q = input ( ) <NEWLINE> t = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for e in t : <NEWLINE> <INDENT> ans += 1 if binary_search ( e , s ) else 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
ans = 1 <NEWLINE> ok1 = True <NEWLINE> _n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ok2 = False <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ok2 = True <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> ok1 = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ok2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif ok1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> r , g , b = S . count ( <STRING> ) , S . count ( <STRING> ) , S . count ( <STRING> ) <NEWLINE> ans = r * g * b <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for d in range ( 1 , N // 2 + 1 ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= N : break <NEWLINE> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = input ( ) <NEWLINE> for j in input ( ) . split ( ) : <NEWLINE> <INDENT> if j not in S : <NEWLINE> <INDENT> S . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( N - len ( S ) ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> <NL> from collections import deque <NEWLINE> import math <NEWLINE> <NL> <NL> def bfs ( h , w , sy , sx , S ) : <NEWLINE> <INDENT> maze = [ [ 10 ** 9 ] * ( W ) for _ in range ( H ) ] <NEWLINE> <NL> maze [ sy - 1 ] [ sx - 1 ] = 0 <NEWLINE> que = deque ( [ [ sy - 1 , sx - 1 ] ] ) <NEWLINE> count = 0 <NEWLINE> while que : <NEWLINE> <INDENT> y , x = que . popleft ( ) <NEWLINE> for i , j in [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] : <NEWLINE> <INDENT> nexty , nextx = y + i , x + j <NEWLINE> if 0 <= nexty < h and 0 <= nextx < w : <NEWLINE> <INDENT> dist1 = S [ nexty ] [ nextx ] <NEWLINE> dist2 = maze [ nexty ] [ nextx ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if dist1 != <STRING> : <NEWLINE> <INDENT> if dist2 > maze [ y ] [ x ] + 1 : <NEWLINE> <INDENT> maze [ nexty ] [ nextx ] = maze [ y ] [ x ] + 1 <NEWLINE> count = max ( count , maze [ nexty ] [ nextx ] ) <NEWLINE> que . append ( [ nexty , nextx ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for sy in range ( H ) : <NEWLINE> <INDENT> for sx in range ( W ) : <NEWLINE> <INDENT> if S [ sy ] [ sx ] == <STRING> : <NEWLINE> <INDENT> now = bfs ( H , W , sy + 1 , sx + 1 , S ) <NEWLINE> ans = max ( ans , now ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> from sys import stdin <NEWLINE> from collections import deque , defaultdict <NEWLINE> input = stdin . readline <NEWLINE> <NL> <NL> def solve ( field ) : <NEWLINE> <INDENT> BLANK , OBSTACLE , JUMP = 0 , 1 , 2 <NEWLINE> ans = 0 <COMMENT> <NEWLINE> <NL> dy = [ 1 , 1 , 1 ] <COMMENT> <NEWLINE> dx = [ 0 , - 1 , 1 ] <NEWLINE> x_limit = len ( field [ 0 ] ) <NEWLINE> y_limit = len ( field ) <NEWLINE> <NL> path = defaultdict ( int ) <COMMENT> <NEWLINE> Q = deque ( ) <NEWLINE> for x , m in enumerate ( field [ 0 ] ) : <NEWLINE> <INDENT> if m == BLANK : <COMMENT> <NEWLINE> <INDENT> t = <STRING> . format ( x , 0 ) <NEWLINE> Q . append ( ( x , 0 ) ) <NEWLINE> path [ t ] = 1 <NEWLINE> <DEDENT> <DEDENT> if y_limit < 2 : <NEWLINE> <INDENT> return len ( Q ) <NEWLINE> <NL> <NL> <DEDENT> while Q : <NEWLINE> <INDENT> cx , cy = Q . popleft ( ) <COMMENT> <NEWLINE> t = <STRING> . format ( cx , cy ) <NEWLINE> num = path . pop ( t ) <NEWLINE> <NL> if field [ cy ] [ cx ] == OBSTACLE : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif field [ cy ] [ cx ] == JUMP : <COMMENT> <NEWLINE> <INDENT> if cy + 2 > y_limit - 1 : <NEWLINE> <INDENT> ans += num <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = <STRING> . format ( cx , cy + 2 ) <NEWLINE> if not path [ t ] : <NEWLINE> <INDENT> Q . append ( ( cx , cy + 2 ) ) <NEWLINE> <DEDENT> path [ t ] += num <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> elif cy == y_limit - 1 : <NEWLINE> <INDENT> ans += num <NEWLINE> continue <NEWLINE> <NL> <DEDENT> for i in range ( len ( dx ) ) : <NEWLINE> <INDENT> nx = cx + dx [ i ] <COMMENT> <NEWLINE> ny = cy + dy [ i ] <NEWLINE> <NL> if 0 <= nx < x_limit : <NEWLINE> <INDENT> if ( ny >= y_limit - 1 ) and field [ ny ] [ nx ] == BLANK : <NEWLINE> <INDENT> ans += num <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if field [ ny ] [ nx ] == JUMP and dx [ i ] == 0 : <COMMENT> <NEWLINE> <INDENT> if ny + 2 > y_limit - 1 : <NEWLINE> <INDENT> ans += num <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = <STRING> . format ( nx , ny + 2 ) <NEWLINE> if not path [ t ] : <NEWLINE> <INDENT> Q . append ( ( nx , ny + 2 ) ) <NEWLINE> <DEDENT> path [ t ] += num <NEWLINE> <DEDENT> <DEDENT> elif field [ ny ] [ nx ] == BLANK : <NEWLINE> <INDENT> t = <STRING> . format ( nx , ny ) <NEWLINE> if not path [ t ] : <NEWLINE> <INDENT> Q . append ( ( nx , ny ) ) <NEWLINE> <DEDENT> path [ t ] += num <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( args ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> X , Y = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> if X == 0 and Y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> field = [ ] <NEWLINE> for _ in range ( Y ) : <NEWLINE> <INDENT> temp = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> field . append ( temp ) <NEWLINE> <DEDENT> result = solve ( field ) <NEWLINE> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> items = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> items . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> dp = [ [ 0 for i in range ( 10001 ) ] for j in range ( 110 ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for w in range ( W + 1 ) : <NEWLINE> <INDENT> if w >= items [ i ] [ 1 ] : <NEWLINE> <INDENT> dp [ i + 1 ] [ w ] = max ( dp [ i ] [ w - items [ i ] [ 1 ] ] + items [ i ] [ 0 ] , dp [ i ] [ w ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] [ w ] = dp [ i ] [ w ] <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ N ] [ W ] ) <NEWLINE>
<COMMENT> <NL> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> self . rank = [ 0 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> elif self . rank [ x ] > self . rank [ y ] : <NEWLINE> <INDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ y ] += self . parents [ x ] <NEWLINE> self . parents [ x ] = y <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ y ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> n , m = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> x = m <NEWLINE> abList = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( x ) ] ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> uf = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> uf . union ( abList [ i ] [ 0 ] - 1 , abList [ i ] [ 1 ] - 1 ) <NEWLINE> <NL> <DEDENT> out = max ( uf . size ( r ) for r in uf . roots ( ) ) <NEWLINE> <COMMENT> <NL> print ( <STRING> . format ( out ) ) <NEWLINE> <NL> <DEDENT>
from sys import stdin <NEWLINE> from collections import defaultdict <NEWLINE> readline = stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> v , e = map ( int , readline ( ) . split ( ) ) <NEWLINE> g = defaultdict ( set ) <NEWLINE> residual = [ [ 0 ] * v for _ in range ( v ) ] <NEWLINE> source , sink = 0 , v - 1 <NEWLINE> <NL> for _ in range ( e ) : <NEWLINE> <INDENT> s , t , c = map ( int , readline ( ) . split ( ) ) <NEWLINE> if 0 < c and s != sink and t != source : <NEWLINE> <INDENT> g [ s ] |= { t } <NEWLINE> g [ t ] |= { s } <NEWLINE> residual [ s ] [ t ] = c <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> route , flow = search ( g , residual , source , sink ) <NEWLINE> if not route : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for s , t in zip ( route , route [ 1 : ] ) : <NEWLINE> <INDENT> residual [ s ] [ t ] -= flow <NEWLINE> residual [ t ] [ s ] += flow <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( residual [ sink ] [ i ] for i in g [ sink ] ) ) <NEWLINE> <NL> <NL> <DEDENT> def search ( g , residual , source , sink ) : <NEWLINE> <INDENT> dfs_stack = [ ( source , None , float ( <STRING> ) ) ] <NEWLINE> route = [ None ] <NEWLINE> visited = set ( ) <NEWLINE> while dfs_stack : <NEWLINE> <INDENT> u , prev , flow = dfs_stack . pop ( ) <NEWLINE> while route [ - 1 ] != prev : <NEWLINE> <INDENT> route . pop ( ) <NEWLINE> <DEDENT> route . append ( u ) <NEWLINE> visited |= { u } <NEWLINE> if u == sink : <NEWLINE> <INDENT> return route [ 1 : ] , flow <NEWLINE> <DEDENT> for v in g [ u ] : <NEWLINE> <INDENT> if v not in visited and 0 < residual [ u ] [ v ] : <NEWLINE> <INDENT> dfs_stack . append ( ( v , u , min ( residual [ u ] [ v ] , flow ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return [ ] , 0 <NEWLINE> <DEDENT> main ( ) <NEWLINE>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> all_a = [ ] <NEWLINE> def make_a ( ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> todo = [ [ ] ] <NEWLINE> while todo : <NEWLINE> <INDENT> i = todo . pop ( ) <NEWLINE> if len ( i ) == n : <NEWLINE> <INDENT> ret . append ( i ) <NEWLINE> continue <NEWLINE> <DEDENT> l = i [ - 1 ] if len ( i ) > 0 else 1 <NEWLINE> for j in range ( l , m + 1 ) : <NEWLINE> <INDENT> todo . append ( i + [ j ] ) <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> all_a = make_a ( ) <NEWLINE> ans = 0 <NEWLINE> for an in all_a : <NEWLINE> <INDENT> ansi = 0 <NEWLINE> for a , b , c , d in abcd : <NEWLINE> <INDENT> if an [ b - 1 ] - an [ a - 1 ] == c : <NEWLINE> <INDENT> ansi += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , ansi ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> class Graph : <NEWLINE> <INDENT> def __init__ ( self , n , side ) : <NEWLINE> <INDENT> self . side = side <NEWLINE> self . neighbor = [ set ( ) for i in range ( n + 1 ) ] <NEWLINE> self . visited = [ False ] * ( n + 1 ) <NEWLINE> self . group = [ 0 ] * n <NEWLINE> self . product ( ) <NEWLINE> <DEDENT> def product ( self ) : <NEWLINE> <INDENT> for a , b in self . side : <NEWLINE> <INDENT> self . neighbor [ a ] . add ( b ) <NEWLINE> self . neighbor [ b ] . add ( a ) <NEWLINE> <DEDENT> <DEDENT> def dfs ( self , x , a ) : <NEWLINE> <INDENT> self . group [ a ] += 1 <NEWLINE> self . visited [ x ] = True <NEWLINE> for i in self . neighbor [ x ] : <NEWLINE> <INDENT> if self . visited [ i ] : continue <NEWLINE> self . dfs ( i , a ) <NEWLINE> <DEDENT> <DEDENT> def all_dfs ( self ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if not self . visited [ i ] : <NEWLINE> <INDENT> self . dfs ( i , a ) <NEWLINE> a += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> side = list ( tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ) <NEWLINE> graph1 = Graph ( n , side ) <NEWLINE> graph1 . all_dfs ( ) <NEWLINE> print ( max ( graph1 . group ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> while i % 2 == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> i //= 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> l = input ( ) . split ( ) <NEWLINE> l . reverse ( ) <NEWLINE> <NL> for i , j in enumerate ( l ) : <NEWLINE> <INDENT> print ( j , end = <STRING> if i != n - 1 else <STRING> ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> t = [ ] <NEWLINE> for i in range ( 677 ) : <NEWLINE> <INDENT> t . append ( [ ] ) <NEWLINE> <DEDENT> x = n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if ( len ( a ) < 4 ) : <NEWLINE> <INDENT> if ( a in t [ 0 ] ) : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ 0 ] . append ( a ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> p = ord ( a [ 0 ] ) * 26 + ord ( a [ 1 ] ) - 2618 <NEWLINE> if ( a [ 2 : ] in t [ p ] ) : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ p ] . append ( a [ 2 : ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> l = len ( T ) <NEWLINE> <NL> if l == len ( S ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for i in range ( len ( S ) - l ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for n in range ( l ) : <NEWLINE> <INDENT> if S [ i + n ] != T [ n ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ans . append ( cnt ) <NEWLINE> <NL> <DEDENT> print ( min ( ans ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> list_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> counts = np . zeros ( 100000 , dtype = int ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( len ( list_a ) ) : <NEWLINE> <INDENT> counts [ list_a [ i ] - 1 ] += 1 <NEWLINE> ans += list_a [ i ] <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans += counts [ b - 1 ] * ( c - b ) <NEWLINE> <NL> counts [ c - 1 ] += counts [ b - 1 ] <NEWLINE> counts [ b - 1 ] = 0 <NEWLINE> <NL> print ( ans ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> result = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> result *= a <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> r , g , b = 0 , 0 , 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans += r * g * b <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if 2 * j - i < N : <NEWLINE> <INDENT> if ( S [ i ] != S [ j ] ) and ( S [ j ] != S [ 2 * j - i ] ) and ( S [ i ] != S [ 2 * j - i ] ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for i in range ( n ) ] <NEWLINE> counter = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a - 1 ] . append ( b - 1 ) <NEWLINE> edges [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> counter [ p - 1 ] += x <NEWLINE> <DEDENT> def dfs ( now , prev ) : <NEWLINE> <INDENT> for next in edges [ now ] : <NEWLINE> <INDENT> if next == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> counter [ next ] += counter [ now ] <NEWLINE> dfs ( next , now ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> print ( * counter ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> l -= 1 <NEWLINE> r -= 1 <NEWLINE> graph [ r ] . append ( ( l , r , - d ) ) <NEWLINE> graph [ l ] . append ( ( r , l , d ) ) <NEWLINE> <NL> <DEDENT> max_int = 10 ** 10 <NEWLINE> point = [ None for _ in range ( n ) ] <NEWLINE> <NL> for v in range ( n ) : <NEWLINE> <INDENT> Q = deque ( ) <NEWLINE> if point [ v ] is not None : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> Q . extend ( graph [ v ] ) <NEWLINE> while Q : <NEWLINE> <INDENT> next_v , v , d = Q . popleft ( ) <NEWLINE> if point [ v ] is None : <NEWLINE> <INDENT> point [ v ] = 0 <NEWLINE> <DEDENT> if point [ next_v ] is not None : <NEWLINE> <INDENT> if point [ next_v ] != point [ v ] + d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> point [ next_v ] = point [ v ] + d <NEWLINE> Q . extend ( graph [ next_v ] ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def fn ( n , k , a ) : <NEWLINE> <INDENT> for _ in range ( k ) : <NEWLINE> <INDENT> b = np . zeros ( n , dtype = np . int64 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lb = max ( i - a [ i ] , 0 ) <NEWLINE> ub = min ( i + a [ i ] , n - 1 ) <NEWLINE> <NL> b [ lb ] += 1 <NEWLINE> if ub + 1 < n : <NEWLINE> <INDENT> b [ ub + 1 ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> a = b . cumsum ( ) <NEWLINE> if np . all ( a == n ) : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> <DEDENT> return a <NEWLINE> <NL> <DEDENT> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = np . array ( a , dtype = np . int64 ) <NEWLINE> <NL> b = fn ( n , k , a ) <NEWLINE> print ( <STRING> . join ( b . astype ( str ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> num = int ( input ( ) . strip ( ) ) <NEWLINE> istr = sys . stdin . read ( ) <NEWLINE> cmds = list ( istr . splitlines ( ) ) <NEWLINE> <NL> D = { } <NEWLINE> for i in cmds : <NEWLINE> <INDENT> if i [ 0 ] == <STRING> : <NEWLINE> <INDENT> D [ i [ 7 : ] ] = 1 <NEWLINE> <DEDENT> elif i [ 0 ] == <STRING> : <NEWLINE> <INDENT> if i [ 5 : ] in D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import queue <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> dist = [ - 1 for _ in range ( n + 1 ) ] <NEWLINE> guide = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> que = queue . Queue ( ) <NEWLINE> dist [ 1 ] = 0 <NEWLINE> que . put ( 1 ) <NEWLINE> <NL> while not que . empty ( ) : <NEWLINE> <INDENT> v = que . get ( ) <NEWLINE> for nv in graph [ v ] : <NEWLINE> <INDENT> if dist [ nv ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ nv ] = dist [ v ] + 1 <NEWLINE> guide [ nv ] = v <NEWLINE> que . put ( nv ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * guide [ 2 : ] , sep = <STRING> ) <NEWLINE>
import string <NEWLINE> <NL> a_to_z = string . ascii_uppercase <NEWLINE> <NL> input_string = input ( ) <NEWLINE> <NL> for s in input_string : <NEWLINE> <INDENT> print ( chr ( ( ( ord ( s ) - ord ( <STRING> ) - 3 ) % 26 + ord ( <STRING> ) ) ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> mod = 2019 <NEWLINE> cnt = [ 0 ] * mod <NEWLINE> cnt [ 0 ] = 1 <NEWLINE> digit = 1 <NEWLINE> now = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> now += int ( s [ - i ] ) * digit <NEWLINE> digit *= 10 <NEWLINE> digit %= mod <NEWLINE> now %= mod <NEWLINE> cnt [ now ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in cnt : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def processA ( target_list , correct_list , i ) : <NEWLINE> <NL> <INDENT> cost = 0 <NEWLINE> while not correct_list [ i ] == target_list [ i ] : <NEWLINE> <INDENT> min_i = target_list . index ( correct_list [ i ] ) <NEWLINE> change_i = target_list . index ( correct_list [ min_i ] ) <NEWLINE> cost += ( target_list [ min_i ] + target_list [ change_i ] ) <NEWLINE> target_list [ min_i ] , target_list [ change_i ] = target_list [ change_i ] , target_list [ min_i ] <NEWLINE> <COMMENT> <NL> <DEDENT> return cost <NEWLINE> <NL> <DEDENT> def processB ( target_list , correct_list , i ) : <NEWLINE> <INDENT> minv = correct_list [ 0 ] <NEWLINE> target = correct_list [ i ] <NEWLINE> <NL> if minv == target : <NEWLINE> <INDENT> return 10 ** 9 <NEWLINE> <DEDENT> cost = ( minv + target ) <NEWLINE> <COMMENT> <NL> mmi = target_list . index ( minv ) <NEWLINE> smi = target_list . index ( target ) <NEWLINE> target_list [ mmi ] , target_list [ smi ] = target_list [ smi ] , target_list [ mmi ] <NEWLINE> <NL> while not correct_list [ i ] == target_list [ i ] : <NEWLINE> <INDENT> min_i = target_list . index ( minv ) <NEWLINE> change_i = target_list . index ( correct_list [ min_i ] ) <NEWLINE> cost += ( target_list [ min_i ] + target_list [ change_i ] ) <NEWLINE> target_list [ min_i ] , target_list [ change_i ] = target_list [ change_i ] , target_list [ min_i ] <NEWLINE> <COMMENT> <NL> <DEDENT> return cost <NEWLINE> <NL> <DEDENT> def minimum_cost_sort ( target_list ) : <NEWLINE> <INDENT> correct_list = sorted ( [ a for a in target_list ] ) <NEWLINE> cost = 0 <NEWLINE> i = 0 <NEWLINE> while not correct_list == target_list : <NEWLINE> <INDENT> cost_b = processB ( [ a for a in target_list ] , correct_list , i ) <NEWLINE> cost_a = processA ( target_list , correct_list , i ) <NEWLINE> cost += min ( cost_a , cost_b ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> i += 1 <NEWLINE> <DEDENT> return cost <NEWLINE> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n_list = input ( ) <NEWLINE> target_list = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> print ( minimum_cost_sort ( target_list ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) . split ( ) <NEWLINE> <NL> A = int ( s [ 0 ] ) <NEWLINE> B = int ( s [ 1 ] ) <NEWLINE> N = int ( s [ 2 ] ) <NEWLINE> <NL> result = 0 <NEWLINE> <NL> n = ( N // B ) * B - 1 <NEWLINE> if ( n < 0 ) : <NEWLINE> <INDENT> n = 0 <NEWLINE> <NL> <DEDENT> a = ( A * N ) // B - A * ( N // B ) <NEWLINE> b = ( A * n ) // B - A * ( n // B ) <NEWLINE> <STRING> <NEWLINE> <NL> if ( a > b ) : <NEWLINE> <INDENT> result = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = b <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
import collections <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if m == 1 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> boss = list ( range ( n ) ) <NEWLINE> <NL> def look_boss ( target ) : <NEWLINE> <INDENT> num = target <NEWLINE> while num != boss [ num ] : <NEWLINE> <INDENT> num = boss [ num ] <NEWLINE> <DEDENT> boss [ target ] = num <NEWLINE> return num <NEWLINE> <NL> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> boss_a = look_boss ( a - 1 ) <NEWLINE> boss_b = look_boss ( b - 1 ) <NEWLINE> if boss_a != boss_b : <NEWLINE> <INDENT> boss [ boss_b ] = boss_a <NEWLINE> <NL> <DEDENT> <DEDENT> count = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> count [ look_boss ( i ) ] += 1 <NEWLINE> <DEDENT> print ( max ( count ) ) <NEWLINE>
def parse ( S ) : <NEWLINE> <INDENT> poly = [ ] <NEWLINE> t = [ ] <NEWLINE> for x in S . split ( <STRING> ) : <NEWLINE> <INDENT> if <STRING> in x : <NEWLINE> <INDENT> t = t + [ <STRING> + a if i != 0 else a for i , a in enumerate ( x . split ( <STRING> ) ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> for x in t : <NEWLINE> <INDENT> if <STRING> in x : <NEWLINE> <INDENT> t = x . split ( <STRING> ) <NEWLINE> if len ( t [ 0 ] ) == 0 : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( t [ 0 ] ) <NEWLINE> <DEDENT> b = int ( t [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if <STRING> in x : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> a = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( x [ : - 1 ] ) <NEWLINE> <DEDENT> b = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( x ) <NEWLINE> b = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> poly . append ( ( a , b ) ) <NEWLINE> <NL> <DEDENT> return poly <NEWLINE> <NL> <DEDENT> def calc_yaku ( n ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if i != 0 and n % i == 0 : <NEWLINE> <INDENT> ret . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> return reversed ( sorted ( ret + [ - x for x in ret ] ) ) <NEWLINE> <NL> <DEDENT> def calc ( poly , x ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for p in poly : <NEWLINE> <INDENT> ret += p [ 0 ] * x ** p [ 1 ] <NEWLINE> <NL> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def solve ( S ) : <NEWLINE> <INDENT> poly = parse ( S ) <NEWLINE> n = abs ( poly [ - 1 ] [ 0 ] ) <NEWLINE> yaku = calc_yaku ( n ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for x in yaku : <NEWLINE> <INDENT> if calc ( poly , x ) == 0 : <NEWLINE> <INDENT> ans . append ( - x ) <NEWLINE> <NL> <DEDENT> <DEDENT> for x in ans : <NEWLINE> <INDENT> if x > 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( x ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( x ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> S = input ( ) <NEWLINE> solve ( S ) <NEWLINE>
from collections import namedtuple <NEWLINE> Node = namedtuple ( <STRING> , [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> <NL> def insert ( T , z ) : <NEWLINE> <INDENT> p = None <NEWLINE> x = T [ <STRING> ] <NEWLINE> while x != None : <NEWLINE> <INDENT> p = x <NEWLINE> if z < x : x = T [ x ] . left <NEWLINE> else : x = T [ x ] . right <NEWLINE> <NL> <DEDENT> T [ z ] = Node ( p , None , None ) <NEWLINE> <NL> if p == None : <NEWLINE> <INDENT> T [ <STRING> ] = z <NEWLINE> <DEDENT> elif z < p : T [ p ] = Node ( T [ p ] . p , z , T [ p ] . right ) <NEWLINE> else : T [ p ] = Node ( T [ p ] . p , T [ p ] . left , z ) <NEWLINE> <NL> <NL> <DEDENT> def getInorderList ( T , i ) : <NEWLINE> <INDENT> l = T [ i ] . left <NEWLINE> r = T [ i ] . right <NEWLINE> if l : yield from getInorderList ( T , l ) <NEWLINE> yield i <NEWLINE> if r : yield from getInorderList ( T , r ) <NEWLINE> <NL> <NL> <DEDENT> def getPreorderList ( T , i ) : <NEWLINE> <INDENT> l = T [ i ] . left <NEWLINE> r = T [ i ] . right <NEWLINE> yield i <NEWLINE> if l : yield from getPreorderList ( T , l ) <NEWLINE> if r : yield from getPreorderList ( T , r ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> m = int ( input ( ) ) <NEWLINE> <NL> T = { } <NEWLINE> T [ <STRING> ] = None <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> op = input ( ) . split ( ) <NEWLINE> if op [ 0 ] == <STRING> : insert ( T , int ( op [ 1 ] ) ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> , * getInorderList ( T , T [ <STRING> ] ) ) <NEWLINE> print ( <STRING> , * getPreorderList ( T , T [ <STRING> ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> A_max = A [ - 1 ] + 1 <NEWLINE> dp = [ 0 ] * A_max <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> dp [ i ] += 1 <NEWLINE> if dp [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( i * 2 , A_max , i ) : <NEWLINE> <INDENT> dp [ j ] = 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp . count ( 1 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class PrimeChecker : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . primes = [ 2 , 3 ] <NEWLINE> <NL> <DEDENT> def isPrime ( self , n ) : <NEWLINE> <INDENT> if n in self . primes : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in self . primes : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> i = 5 <NEWLINE> w = 2 <NEWLINE> <NL> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> i += w <NEWLINE> w = 6 - w <NEWLINE> <NL> <DEDENT> self . primes . append ( n ) <NEWLINE> <NL> return True <NEWLINE> <NL> <DEDENT> <DEDENT> primeChecker = PrimeChecker ( ) <NEWLINE> count = 0 <NEWLINE> N = int ( input ( ) ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> if primeChecker . isPrime ( ( int ( input ( ) ) ) ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ 0 ] * a <NEWLINE> for i in b : <NEWLINE> <INDENT> c [ i - 1 ] += 1 <NEWLINE> <DEDENT> for j in c : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> data = [ ] <NEWLINE> [ data . append ( int ( input ( ) ) ) for i in range ( n ) ] <NEWLINE> <NL> ans = data [ 1 ] - data [ 0 ] <NEWLINE> x = data [ 0 ] <NEWLINE> <NL> for d in data [ 1 : ] : <NEWLINE> <INDENT> ans = max ( ans , d - x ) <NEWLINE> x = min ( d , x ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> prev = sum ( A [ 0 : K ] ) <NEWLINE> for i in range ( K + 1 , N + 1 ) : <NEWLINE> <INDENT> curr = prev - A [ i - K - 1 ] + A [ i - 1 ] <NEWLINE> if prev < curr : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> prev = curr <NEWLINE> <DEDENT>
from math import sqrt <NEWLINE> from math import floor <NEWLINE> n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ p ] <NEWLINE> for i in range ( 2 , floor ( sqrt ( p ) ) + 1 ) : <NEWLINE> <INDENT> if p % i == 0 : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> l . append ( p // i ) <NEWLINE> <DEDENT> <DEDENT> l . sort ( ) <NEWLINE> s = [ 1 ] <NEWLINE> i = 0 <NEWLINE> while p > 1 : <NEWLINE> <INDENT> if p % l [ i ] == 0 : <NEWLINE> <INDENT> s . append ( l [ i ] ) <NEWLINE> p = p // l [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 1 <NEWLINE> x = s [ 0 ] <NEWLINE> y = 1 <NEWLINE> for i in s [ 1 : ] : <NEWLINE> <INDENT> if x == i : <NEWLINE> <INDENT> y += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while y >= n : <NEWLINE> <INDENT> ans *= x <NEWLINE> y -= n <NEWLINE> <DEDENT> x = i <NEWLINE> y = 1 <NEWLINE> <DEDENT> <DEDENT> while y >= n : <NEWLINE> <INDENT> ans *= x <NEWLINE> y -= n <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> maxv = - 10e10 <NEWLINE> minv = a [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> maxv = a [ i ] - minv if maxv < a [ i ] - minv else maxv <NEWLINE> minv = a [ i ] if minv > a [ i ] else minv <NEWLINE> <NL> <DEDENT> print ( maxv ) <NEWLINE>
<NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = range ( n + 1 ) <NEWLINE> <NL> c = 0 <NEWLINE> <NL> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> mn = ( i - 1 ) * i // 2 <NEWLINE> mx = ( 2 * n + 1 - i ) * i // 2 <NEWLINE> c = c + mx - mn + 1 <NEWLINE> <NL> <DEDENT> print ( c % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL>
from collections import deque <NEWLINE> import numpy as np <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> def bfs ( sx , sy ) : <NEWLINE> <COMMENT> <NL> <INDENT> d = [ [ float ( <STRING> ) ] * m for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> dx = [ 1 , 0 , - 1 , 0 ] <NEWLINE> dy = [ 0 , 1 , 0 , - 1 ] <NEWLINE> <NL> <COMMENT> <NL> que = deque ( [ ] ) <NEWLINE> que . append ( ( sx , sy ) ) <NEWLINE> d [ sx ] [ sy ] = 0 <NEWLINE> <NL> <COMMENT> <NL> while que : <NEWLINE> <COMMENT> <NL> <INDENT> p = que . popleft ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( 4 ) : <NEWLINE> <COMMENT> <NL> <INDENT> nx = p [ 0 ] + dx [ i ] <NEWLINE> ny = p [ 1 ] + dy [ i ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> if 0 <= nx < n and 0 <= ny < m and maze [ nx ] [ ny ] != <STRING> and d [ nx ] [ ny ] == float ( <STRING> ) : <NEWLINE> <COMMENT> <NL> <INDENT> que . append ( ( nx , ny ) ) <NEWLINE> d [ nx ] [ ny ] = d [ p [ 0 ] ] [ p [ 1 ] ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> a = np . max ( d ) <NEWLINE> return a <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> maze = [ list ( input ( ) ) for i in range ( n ) ] <NEWLINE> ans = 1 <NEWLINE> <NL> for x in range ( n ) : <NEWLINE> <INDENT> for y in range ( m ) : <NEWLINE> <INDENT> sx = x <NEWLINE> sy = y <NEWLINE> if maze [ sx ] [ sy ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> A = bfs ( sx , sy ) <NEWLINE> ans = max ( A , ans ) <NEWLINE> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = collections . Counter ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( l [ i + 1 ] ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> if a [ i ] % 2 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> a . sort ( ) <NEWLINE> ma = a [ 0 ] * a [ 1 ] <NEWLINE> print ( ma * ( a [ 2 ] // 2 + 1 ) - ma * ( a [ 2 ] // 2 ) ) <NEWLINE>
H , W , s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ list ( input ( ) ) for i in range ( H ) ] <NEWLINE> l_h = [ 0 ] * H <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> if <STRING> in set ( l [ i ] ) : <NEWLINE> <INDENT> l_h [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> bor = sum ( l_h ) - 1 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> if cnt == bor : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if l_h [ i ] == 1 : <NEWLINE> <INDENT> l_h [ i ] = - 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> cnt = 1 <NEWLINE> import numpy as np <NEWLINE> tmp = [ ] <NEWLINE> st = 0 <NEWLINE> ans = np . zeros ( ( H , W ) ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> tmp . append ( l [ i ] ) <NEWLINE> if l_h [ i ] == - 1 : <NEWLINE> <INDENT> n_tmp = np . array ( tmp ) <NEWLINE> s_count = np . count_nonzero ( n_tmp == <STRING> ) - 1 <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> ans [ st : i + 1 , j ] = cnt <NEWLINE> if <STRING> in n_tmp [ : , j ] and s_count > 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> s_count -= 1 <NEWLINE> <DEDENT> <DEDENT> st = i + 1 <NEWLINE> cnt += 1 <NEWLINE> tmp = [ ] <NEWLINE> <DEDENT> <DEDENT> n_tmp = np . array ( tmp ) <NEWLINE> s_count = np . count_nonzero ( n_tmp == <STRING> ) - 1 <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> ans [ st : i + 1 , j ] = cnt <NEWLINE> if <STRING> in n_tmp [ : , j ] and s_count > 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> s_count -= 1 <NEWLINE> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( * list ( map ( int , i ) ) ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> anses = [ ] <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for c , d in zip ( s [ i : i + len ( t ) ] , t ) : <NEWLINE> <INDENT> if c != d : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> anses . append ( cnt ) <NEWLINE> <NL> <DEDENT> print ( min ( anses ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> num = { } <NEWLINE> for v in a : <NEWLINE> <INDENT> if v in num : <NEWLINE> <INDENT> num [ v ] = num [ v ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num [ v ] = 1 <NEWLINE> <DEDENT> <DEDENT> m = int ( input ( ) ) <NEWLINE> t = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ok = True <NEWLINE> for v in t : <NEWLINE> <INDENT> if v not in num : <NEWLINE> <INDENT> ok = False <NEWLINE> <DEDENT> elif num [ v ] <= 0 : <NEWLINE> <INDENT> ok = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num [ v ] = num [ v ] - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> ans = <STRING> <NEWLINE> def dfs ( a , b , c , t ) : <NEWLINE> <INDENT> global ans <NEWLINE> if a < 0 or b < 0 or c < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if t == N : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if s [ t ] == <STRING> : <NEWLINE> <INDENT> if dfs ( a - 1 , b + 1 , c , t + 1 ) : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> return True <NEWLINE> <DEDENT> elif dfs ( a + 1 , b - 1 , c , t + 1 ) : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> if s [ t ] == <STRING> : <NEWLINE> <INDENT> if dfs ( a , b - 1 , c + 1 , t + 1 ) : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> return True <NEWLINE> <DEDENT> elif dfs ( a , b + 1 , c - 1 , t + 1 ) : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> if s [ t ] == <STRING> : <NEWLINE> <INDENT> if dfs ( a + 1 , b , c - 1 , t + 1 ) : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> return True <NEWLINE> <DEDENT> if dfs ( a - 1 , b , c + 1 , t + 1 ) : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> if dfs ( A , B , C , 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * ans [ : : - 1 ] , sep = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ax = collections . Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ax [ i ] ) <NEWLINE> <DEDENT>
can = [ 0 ] <NEWLINE> for i in range ( 1 , 151 ) : <NEWLINE> <INDENT> can . append ( pow ( i , 5 ) ) <NEWLINE> can . append ( - pow ( i , 5 ) ) <NEWLINE> <DEDENT> can . sort ( ) <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> <NL> end = False <NEWLINE> for i in range ( len ( can ) ) : <NEWLINE> <INDENT> for q in range ( len ( can ) ) : <NEWLINE> <INDENT> if can [ i ] - can [ q ] == x : <NEWLINE> <NL> <INDENT> print ( i - 150 , q - 150 ) <NEWLINE> end = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if end : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import collections <NEWLINE> <NL> <NL> member_cnt = int ( input ( ) ) <NEWLINE> bosses = input ( ) . split ( <STRING> ) <NEWLINE> boss_dict = collections . Counter ( bosses ) <NEWLINE> <NL> for i in range ( 1 , member_cnt + 1 ) : <NEWLINE> <INDENT> print ( boss_dict . get ( str ( i ) , 0 ) ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( min ( k , a ) - max ( k - a - b , 0 ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> def gcd_ ( a , b ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> while not a % b == 0 : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return b <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> p = gcd_ ( i , j ) <NEWLINE> if p == 1 : <NEWLINE> <INDENT> s += k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for h in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> s += gcd_ ( p , h ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> <NL> nw1 = s . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> print ( nw1 ) <NEWLINE>
X , N = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> def main ( X , N ) : <NEWLINE> <INDENT> if N == 0 : <NEWLINE> <INDENT> return X <NEWLINE> <DEDENT> arrp = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> minus = X <NEWLINE> plus = X <NEWLINE> while True : <NEWLINE> <INDENT> if minus not in arrp : <NEWLINE> <INDENT> print ( minus ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if plus not in arrp : <NEWLINE> <INDENT> print ( plus ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> minus -= 1 <NEWLINE> plus += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( main ( X , N ) ) <NEWLINE>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ X ] <NEWLINE> A_dict = { X } <NEWLINE> a = X <NEWLINE> s = X <NEWLINE> r = 0 <NEWLINE> r0 = 0 <NEWLINE> l = 0 <NEWLINE> amari = 0 <NEWLINE> <NL> for i in range ( M + 1 ) : <NEWLINE> <INDENT> a = a ** 2 % M <NEWLINE> if a in A_dict : <NEWLINE> <INDENT> r0 = A . index ( a ) <NEWLINE> l = len ( A [ r0 : ] ) <NEWLINE> r = ( N - i - 1 ) // l <NEWLINE> amari = ( N - i - 1 ) % l <NEWLINE> s = s + sum ( A [ r0 : ] ) * r + sum ( A [ r0 : r0 + amari ] ) <NEWLINE> break <NEWLINE> <DEDENT> A . append ( a ) <NEWLINE> A_dict . add ( a ) <NEWLINE> s += A [ - 1 ] <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) ) . astype ( int ) <NEWLINE> <NL> <COMMENT> <NL> res = np . zeros ( N ) . astype ( int ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> res [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( res [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def solve ( dates ) : <NEWLINE> <INDENT> counter = 0 ; <NEWLINE> start_month = dates [ 1 ] <NEWLINE> start_day , end_day = dates [ 2 ] , 0 <NEWLINE> <NL> for year in range ( dates [ 0 ] , 1000 ) : <NEWLINE> <INDENT> for month in range ( start_month , 11 ) : <NEWLINE> <INDENT> if year % 3 == 0 or month % 2 == 1 : <NEWLINE> <INDENT> end_day = 21 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> end_day = 20 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> counter += ( end_day - start_day ) <NEWLINE> <NL> start_day = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start_month = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return counter <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> dates = [ 0 for i in range ( 3 ) ] <NEWLINE> tmp_dates = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp_dates = input ( ) . split ( ) <NEWLINE> for j in range ( len ( tmp_dates ) ) : <NEWLINE> <INDENT> dates [ j ] = int ( tmp_dates [ j ] ) <NEWLINE> <NL> <DEDENT> date_count = solve ( dates ) <NEWLINE> print ( date_count ) <NEWLINE> <DEDENT> <DEDENT>
from queue import Queue <NEWLINE> w , h = 0 , 0 <NEWLINE> <NL> def bfs ( x , y , data ) : <NEWLINE> <INDENT> que = Queue ( ) <NEWLINE> que . put ( ( x , y ) ) <NEWLINE> <NL> while not que . empty ( ) : <NEWLINE> <INDENT> x , y = que . get ( ) <NEWLINE> if data [ x ] [ y ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> data [ x ] [ y ] = 0 <NEWLINE> for dx in range ( - 1 , 2 ) : <NEWLINE> <INDENT> for dy in range ( - 1 , 2 ) : <NEWLINE> <INDENT> sx , sy = x + dx , y + dy <NEWLINE> if sx < 0 or sx >= h or sy < 0 or sy >= w : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> que . put ( ( sx , sy ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return data <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if w == h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> data = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> data . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for x in range ( h ) : <NEWLINE> <INDENT> for y in range ( w ) : <NEWLINE> <INDENT> if data [ x ] [ y ] > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> data = bfs ( x , y , data ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from decimal import Decimal <NEWLINE> import math <NEWLINE> a , b , n = map ( str , input ( ) . split ( ) ) <NEWLINE> <NL> a = Decimal ( a ) <NEWLINE> b = Decimal ( b ) <NEWLINE> n = int ( n ) <NEWLINE> ans = 0 <NEWLINE> kouho = [ min ( b - 1 , n ) ] <NEWLINE> for x in kouho : <NEWLINE> <INDENT> tmp = math . floor ( ( a * x ) / b ) - a * math . floor ( x / b ) <NEWLINE> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> n = int ( input ( ) ) <NEWLINE> sum1 = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> gcd1 = gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> gcd2 = gcd ( gcd1 , k ) <NEWLINE> sum1 += gcd2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum1 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> d = 1 <NEWLINE> D = 0 <NEWLINE> for I in range ( a ) : <NEWLINE> <INDENT> if d % 3 == 0 : <NEWLINE> <INDENT> d += 1 <NEWLINE> <NL> <DEDENT> elif d % 5 == 0 : <NEWLINE> <INDENT> d += 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> D = D + d <NEWLINE> d += 1 <NEWLINE> <DEDENT> <DEDENT> print ( D ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <DEDENT> m = max ( max ( A ) , max ( B ) , max ( C ) ) + 1 <NEWLINE> res = np . arange ( m , dtype = int ) <NEWLINE> newA = np . zeros ( ( m ) , dtype = int ) <NEWLINE> <NL> <NL> for a in A : <NEWLINE> <INDENT> newA [ a ] += 1 <NEWLINE> <NL> <DEDENT> sum_r = np . dot ( res , newA ) <NEWLINE> <NL> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> b = B [ i ] <NEWLINE> c = C [ i ] <NEWLINE> sum_r = sum_r - b * newA [ b ] + c * newA [ b ] <NEWLINE> print ( sum_r ) <NEWLINE> newA [ c ] += newA [ b ] <NEWLINE> newA [ b ] = 0 <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from collections import Counter <NEWLINE> s = input ( ) [ : : - 1 ] <NEWLINE> partial = 0 <NEWLINE> remainders = list ( ) <NEWLINE> num = ( int ( character ) for character in s ) <NEWLINE> for i , int_char in enumerate ( num ) : <NEWLINE> <INDENT> partial = ( partial + ( int_char * pow ( 10 , i , 2019 ) ) % 2019 ) % 2019 <NEWLINE> remainders . append ( partial ) <NEWLINE> <DEDENT> histo = Counter ( remainders ) <NEWLINE> non_single_count = int ( sum ( count * ( count - 1 ) / 2 for value , count in histo . items ( ) if value != 0 ) ) <NEWLINE> single_count = int ( sum ( count + count * ( count - 1 ) / 2 for value , count in histo . items ( ) if value == 0 ) ) <NEWLINE> print ( non_single_count + single_count ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> IS = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> II = lambda : int ( IS ( ) ) <NEWLINE> MII = lambda : list ( map ( int , IS ( ) . split ( ) ) ) <NEWLINE> MIIZ = lambda : list ( map ( lambda x : x - 1 , MII ( ) ) ) <NEWLINE> <COMMENT> <NL> INIT_VAL = 0 <NEWLINE> MD2 = lambda d1 , d2 : [ [ INIT_VAL ] * d2 for _ in range ( d1 ) ] <NEWLINE> MD3 = lambda d1 , d2 , d3 : [ MD2 ( d2 , d3 ) for _ in range ( d1 ) ] <NEWLINE> <COMMENT> <NL> DIVC = lambda x , y : - ( - x // y ) <NEWLINE> DIVF = lambda x , y : x // y <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> s = list ( map ( int , IS ( ) ) ) <NEWLINE> n = len ( s ) <NEWLINE> p = 2019 <NEWLINE> cnt = 0 <NEWLINE> d = [ 0 ] * p <NEWLINE> d [ 0 ] = 1 <COMMENT> <NEWLINE> ss = 0 <NEWLINE> x = 1 <NEWLINE> for si in s [ : : - 1 ] : <NEWLINE> <INDENT> ss += x * si <NEWLINE> ss %= p <NEWLINE> d [ ss ] += 1 <NEWLINE> x = ( 10 * x ) % p <COMMENT> <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for di in d : <NEWLINE> <INDENT> cnt += di * ( di - 1 ) // 2 <COMMENT> <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> l = len ( s ) <NEWLINE> ans = 0 <NEWLINE> p = 0 <NEWLINE> a = { } <NEWLINE> b = - 1 <NEWLINE> c = - 1 <NEWLINE> d = - 1 <NEWLINE> e = - 1 <NEWLINE> q = 1 <NEWLINE> for j in range ( l ) [ : : - 1 ] : <NEWLINE> <INDENT> p = ( p + int ( s [ j ] ) * q ) % 2019 <NEWLINE> q *= 10 <NEWLINE> q %= 2019 <NEWLINE> if p == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> if a . get ( p ) != None : <NEWLINE> <INDENT> ans += a [ p ] <NEWLINE> <DEDENT> if a . get ( p ) != None : <NEWLINE> <INDENT> a [ p ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ p ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in itertools . product ( range ( K + 1 ) , repeat = 2 ) : <NEWLINE> <INDENT> if 0 <= ( S - sum ( i ) ) <= K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for _ in range ( M ) ] ) <NEWLINE> INF = 1000000007 <NEWLINE> <NL> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if 1 not in a : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> dp [ i ] %= INF <NEWLINE> <NL> <DEDENT> print ( dp [ N ] ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> def bfs ( x1 , y1 , d ) : <NEWLINE> <INDENT> q = deque ( [ ] ) <NEWLINE> q . append ( ( d , x1 , y1 ) ) <NEWLINE> M [ x1 ] [ y1 ] = d <NEWLINE> <NL> while q : <NEWLINE> <INDENT> d , x1 , y1 = q . popleft ( ) <NEWLINE> <NL> if [ x1 , y1 ] == [ xg , yg ] : <NEWLINE> <INDENT> print ( d ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for dx , dy in ( ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( - 1 , 0 ) ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> x2 = x1 + dx * k <NEWLINE> y2 = y1 + dy * k <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if ( 0 <= x2 < H ) and ( 0 <= y2 < W ) : <NEWLINE> <INDENT> if m [ x2 ] [ y2 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif M [ x2 ] [ y2 ] == - 1 : <NEWLINE> <INDENT> M [ x2 ] [ y2 ] = d + 1 <NEWLINE> q . append ( ( d + 1 , x2 , y2 ) ) <NEWLINE> <DEDENT> elif M [ x2 ] [ y2 ] <= d : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif M [ x2 ] [ y2 ] == d + 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> H , W , K = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> xs , ys , xg , yg = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> xg -= 1 <NEWLINE> yg -= 1 <NEWLINE> <NL> m = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> m . append ( list ( map ( str , sys . stdin . readline ( ) . strip ( ) ) ) ) <NEWLINE> <NL> <DEDENT> M = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> <NL> bfs ( xs - 1 , ys - 1 , 0 ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if r - l >= 2019 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 2020 <NEWLINE> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> ans = min ( ( i * j ) % 2019 , ans ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import functools <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def euclid ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return euclid ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> def gcd ( nums ) : <NEWLINE> <INDENT> return functools . reduce ( euclid , nums ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> t = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> t . append ( ( a , b ) ) <NEWLINE> <DEDENT> z = 0 <NEWLINE> y = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if t [ i ] [ 0 ] == 0 and t [ i ] [ 1 ] == 0 : <NEWLINE> <INDENT> z += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = abs ( gcd ( [ t [ i ] [ 0 ] , t [ i ] [ 1 ] ] ) ) <NEWLINE> if t [ i ] [ 1 ] == 0 : <NEWLINE> <INDENT> a = ( 1 , 0 ) <NEWLINE> <DEDENT> elif t [ i ] [ 1 ] > 0 : <NEWLINE> <INDENT> a = ( t [ i ] [ 0 ] // g , t [ i ] [ 1 ] // g ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = ( - t [ i ] [ 0 ] // g , - t [ i ] [ 1 ] // g ) <NEWLINE> <DEDENT> if a not in y : <NEWLINE> <INDENT> y [ a ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y [ a ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> x = 1 <NEWLINE> for i in y : <NEWLINE> <INDENT> if ( - i [ 1 ] , i [ 0 ] ) in y : <NEWLINE> <INDENT> x *= pow ( 2 , y [ ( - i [ 1 ] , i [ 0 ] ) ] , MOD ) + pow ( 2 , y [ ( i [ 0 ] , i [ 1 ] ) ] , MOD ) - 1 <NEWLINE> cnt += y [ ( - i [ 1 ] , i [ 0 ] ) ] + y [ ( i [ 0 ] , i [ 1 ] ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = pow ( 2 , n - z - cnt , MOD ) * x - 1 <NEWLINE> print ( ( ans + z ) % MOD ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> B = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> B *= i <NEWLINE> if ( B > 10 ** 18 ) : <NEWLINE> <INDENT> B = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( B ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> md = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s [ 0 ] in md : <NEWLINE> <INDENT> md [ s [ 0 ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> vs = [ ] <NEWLINE> for v in md . values ( ) : <NEWLINE> <INDENT> vs . append ( v ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , 5 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , 5 ) : <NEWLINE> <INDENT> ans += vs [ i ] * vs [ j ] * vs [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> R = S . count ( <STRING> ) <NEWLINE> G = S . count ( <STRING> ) <NEWLINE> B = S . count ( <STRING> ) <NEWLINE> <NL> impossible = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> delta = j - i <NEWLINE> k = j + delta <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> pairs = { S [ i ] , S [ j ] , S [ k ] } <NEWLINE> if len ( pairs ) == 3 : <NEWLINE> <INDENT> impossible += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = R * G * B - impossible <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> mod = 1000000007 <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> B = [ <STRING> ] * ( n + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> B [ a ] = <STRING> <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( n + 1 ) <NEWLINE> if B [ 1 ] == <STRING> and B [ 2 ] == <STRING> : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> dp [ 2 ] = 2 <NEWLINE> <DEDENT> elif B [ 1 ] == <STRING> and B [ 2 ] == <STRING> : <NEWLINE> <INDENT> dp [ 2 ] = 1 <NEWLINE> <DEDENT> elif B [ 1 ] == <STRING> and B [ 2 ] == <STRING> : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if B [ i ] == <STRING> : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 2 ] + dp [ i - 1 ] ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
def fib ( n ) : <NEWLINE> <INDENT> if n == 0 or n == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> l = [ 0 ] * ( n + 1 ) <NEWLINE> l [ 0 ] = 1 <NEWLINE> l [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> l [ i ] = l [ i - 2 ] + l [ i - 1 ] <NEWLINE> <DEDENT> return l [ i ] <NEWLINE> <NL> <DEDENT> print ( fib ( int ( input ( ) ) ) ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> l = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> s = 1 <NEWLINE> if n == k : <NEWLINE> <INDENT> for i in l : <NEWLINE> <INDENT> s *= i <NEWLINE> s %= 1000000007 <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pos = [ ] <NEWLINE> neg = [ ] <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> if i >= 0 : <NEWLINE> <INDENT> pos . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> neg . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> pos . sort ( ) <NEWLINE> neg . sort ( reverse = True ) <NEWLINE> answer = [ ] <NEWLINE> <NL> if k % 2 == 1 and not pos : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> s *= neg [ i ] <NEWLINE> s %= 1000000007 <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if k % 2 == 1 : <NEWLINE> <INDENT> s = pos . pop ( ) <NEWLINE> <DEDENT> for i in range ( k // 2 ) : <NEWLINE> <INDENT> if len ( pos ) >= 2 : <NEWLINE> <INDENT> answer . append ( pos . pop ( ) * pos . pop ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( k // 2 ) : <NEWLINE> <INDENT> if len ( neg ) >= 2 : <NEWLINE> <INDENT> answer . append ( neg . pop ( ) * neg . pop ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> answer . sort ( reverse = True ) <NEWLINE> for i in range ( k // 2 ) : <NEWLINE> <INDENT> s *= answer [ i ] <NEWLINE> s %= 1000000007 <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) ) <NEWLINE> values = [ [ int ( val ) for val in num [ : - 1 ] . split ( ) ] for num in sys . stdin . readlines ( ) ] <NEWLINE> <NL> nyukyo = [ [ [ 0 for _ in range ( 10 ) ] for _ in range ( 3 ) ] for _ in range ( 4 ) ] <NEWLINE> <NL> for value in values : <NEWLINE> <INDENT> nyukyo [ value [ 0 ] - 1 ] [ value [ 1 ] - 1 ] [ value [ 2 ] - 1 ] += value [ 3 ] <NEWLINE> if nyukyo [ value [ 0 ] - 1 ] [ value [ 1 ] - 1 ] [ value [ 2 ] - 1 ] < 0 : <NEWLINE> <INDENT> nyukyo [ value [ 0 ] - 1 ] [ value [ 1 ] - 1 ] [ value [ 2 ] - 1 ] = 0 <NEWLINE> <DEDENT> elif nyukyo [ value [ 0 ] - 1 ] [ value [ 1 ] - 1 ] [ value [ 2 ] - 1 ] > 9 : <NEWLINE> <INDENT> nyukyo [ value [ 0 ] - 1 ] [ value [ 1 ] - 1 ] [ value [ 2 ] - 1 ] = 9 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> for n in range ( 3 ) : <NEWLINE> <INDENT> for m in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> + str ( nyukyo [ j ] [ n ] [ m ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if j < 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> b = np . sqrt ( a ) <NEWLINE> <NL> lim = 10 ** 9 <NEWLINE> lim_1 = 10 ** 18 <NEWLINE> ans_1 = np . prod ( b ) <NEWLINE> ans = np . prod ( a ) <NEWLINE> <NL> if ans_1 > lim : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> elif ans_1 < 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> if ans > lim_1 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> elif ans < 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( N + 1 ) <NEWLINE> RANGE = 333 <NEWLINE> for i in range ( 1 , RANGE ) : <NEWLINE> <INDENT> if i ** 2 <= N + 1 : <NEWLINE> <INDENT> for j in range ( 1 , RANGE ) : <NEWLINE> <INDENT> if i ** 2 + j ** 2 + i * j <= N + 1 : <NEWLINE> <INDENT> for k in range ( 1 , RANGE ) : <NEWLINE> <INDENT> wd = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> if wd < N + 1 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans [ wd ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> X = 1 <NEWLINE> c = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> X = X * A [ i ] <NEWLINE> if X <= 10 ** 18 : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if c == N : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( L ) <NEWLINE> A = list ( c . keys ( ) ) <NEWLINE> B = list ( c . values ( ) ) <NEWLINE> R = list ( ) <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if B [ i ] >= 2 : <NEWLINE> <INDENT> R . append ( [ A [ i ] , B [ i ] ] ) <NEWLINE> <DEDENT> <DEDENT> R = sorted ( R , reverse = True ) <NEWLINE> if len ( R ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if R [ 0 ] [ 1 ] >= 4 : <NEWLINE> <INDENT> print ( R [ 0 ] [ 0 ] ** 2 ) <NEWLINE> <DEDENT> elif len ( R ) < 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( R [ 0 ] [ 0 ] * R [ 1 ] [ 0 ] ) <NEWLINE> <DEDENT>
import math as np <NEWLINE> K = int ( input ( ) ) <NEWLINE> P = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> l = np . gcd ( i , j ) <NEWLINE> <NL> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> m = np . gcd ( l , k ) <NEWLINE> P = m + P <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( P ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = ( input ( ) . split ( ) ) <NEWLINE> out = <STRING> <NEWLINE> for i in reversed ( l ) : out += i + <STRING> <NEWLINE> print ( out . strip ( ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> from_one = [ ] <NEWLINE> to_n = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> from_one += [ b ] <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> from_one += [ a ] <NEWLINE> <DEDENT> elif a == N - 1 : <NEWLINE> <INDENT> to_n += [ b ] <NEWLINE> <DEDENT> elif b == N - 1 : <NEWLINE> <INDENT> to_n += [ a ] <NEWLINE> <NL> <DEDENT> <DEDENT> from_one = set ( from_one ) <NEWLINE> to_n = set ( to_n ) <NEWLINE> if len ( from_one & to_n ) >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a . count ( 0 ) > 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > ( 10 ** 18 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if not ans > ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> num = 0 <NEWLINE> <NL> for a in range ( 1 , n ) : <NEWLINE> <INDENT> for b in range ( n // a ) : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> if n % a == 0 : <NEWLINE> <INDENT> num -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
import math <NEWLINE> from math import gcd , pi , sqrt <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import itertools <NEWLINE> from collections import Counter , deque <NEWLINE> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = i_input ( ) <NEWLINE> l = [ i_list ( ) for i in range ( n ) ] <NEWLINE> <NL> L = [ ] <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> if i [ 2 ] != 0 : <NEWLINE> <INDENT> L . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if len ( L ) == 1 : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , L [ 0 ] ) ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for x in range ( 101 ) : <NEWLINE> <INDENT> for y in range ( 101 ) : <NEWLINE> <INDENT> H = L [ 0 ] [ 2 ] + abs ( x - L [ 0 ] [ 0 ] ) + abs ( y - L [ 0 ] [ 1 ] ) <NEWLINE> flg = True <NEWLINE> for x1 , y1 , h1 in L [ 1 : ] : <NEWLINE> <INDENT> if h1 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> if H != h1 + abs ( x - x1 ) + abs ( y - y1 ) : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg == True : <NEWLINE> <INDENT> ans = [ x , y ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> H = L [ 0 ] [ 2 ] + abs ( ans [ 0 ] - L [ 0 ] [ 0 ] ) + abs ( ans [ 1 ] - L [ 0 ] [ 1 ] ) <NEWLINE> print ( <STRING> . join ( map ( str , ans ) ) + <STRING> + str ( H ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 2019 <NEWLINE> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , i * j % 2019 ) <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> ans = 0 <NEWLINE> a . sort ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if sum ( a ) % 10 == 0 : <NEWLINE> <INDENT> if a [ i ] % 10 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( a ) ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE>
import sys <NEWLINE> from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> Sc = Counter ( S ) <NEWLINE> R = Sc [ <STRING> ] <NEWLINE> G = Sc [ <STRING> ] <NEWLINE> B = Sc [ <STRING> ] <NEWLINE> if R == 0 or G == 0 or B == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = R * G * B <NEWLINE> <DEDENT> for i in range ( 1 , N // 2 + 2 ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if j + i + i >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ j ] == S [ j + i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ j ] == S [ j + i + i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ j + i ] == S [ j + i + i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def floor ( a ) : <NEWLINE> <INDENT> return int ( a ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> abn = input ( ) <NEWLINE> abn = abn . split ( ) <NEWLINE> a = int ( abn [ 0 ] ) <NEWLINE> b = int ( abn [ 1 ] ) <NEWLINE> n = int ( abn [ 2 ] ) <NEWLINE> <NL> x = min ( b - 1 , n ) <NEWLINE> ans = floor ( a * x / b ) - a * floor ( x / b ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> student = list ( range ( 0 , N ) ) <NEWLINE> <NL> student . sort ( key = lambda x : A [ x ] ) <NEWLINE> <NL> for s in student : <NEWLINE> <INDENT> print ( s + 1 , end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in an : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> <DEDENT> if ans != 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * an [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , n = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> x = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> if n < b : <NEWLINE> <INDENT> x = n <NEWLINE> <DEDENT> elif n > b : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b > 1 : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> 1 <NEWLINE> <DEDENT> <DEDENT> ans = ( a * x ) // b <NEWLINE> <NL> if b == 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit , i8 , void <NEWLINE> <NL> @ njit ( i8 ( i8 , i8 ) , cache = True ) <NEWLINE> def gcd ( x , y ) : <NEWLINE> <INDENT> while y : <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> @ njit ( i8 ( i8 [ : ] ) , cache = True ) <NEWLINE> def get_gcd ( a ) : <NEWLINE> <INDENT> gcd_all = a [ 0 ] <NEWLINE> for i in range ( 1 , a . size ) : <NEWLINE> <INDENT> gcd_all = gcd ( gcd_all , a [ i ] ) <NEWLINE> <DEDENT> return gcd_all <NEWLINE> <NL> <DEDENT> @ njit ( i8 ( i8 [ : ] ) , cache = True ) <NEWLINE> def judge_setwise ( a ) : <NEWLINE> <INDENT> amax = a . max ( ) <NEWLINE> aflag = np . zeros ( amax , np . int64 ) <NEWLINE> aflag [ a - 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , amax + 1 ) : <NEWLINE> <INDENT> index = ( np . arange ( amax // i ) + 1 ) * i - 1 <NEWLINE> count = aflag [ index ] . sum ( ) <NEWLINE> if count >= 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , np . int64 ) <NEWLINE> <NL> <NL> if get_gcd ( a ) > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> judge_setwise ( a ) <NEWLINE> <DEDENT>
mod = 10 ** 9 + 7 <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> pi = 1 <NEWLINE> ni = 0 <NEWLINE> ans = 1 <NEWLINE> i = 0 <NEWLINE> while i < K - 1 : <NEWLINE> <INDENT> if A [ ni ] * A [ ni + 1 ] > A [ - pi ] * A [ - pi - 1 ] : <NEWLINE> <INDENT> ans = ans * A [ ni ] * A [ ni + 1 ] % mod <NEWLINE> ni += 2 <NEWLINE> i += 2 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * A [ - pi ] % mod <NEWLINE> pi += 1 <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if i == K - 1 : <NEWLINE> <INDENT> ans = ans * A [ - pi ] % mod <NEWLINE> <NL> <DEDENT> if A [ - 1 ] < 0 and K % 2 == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in A [ N - K : ] : <NEWLINE> <INDENT> ans = ans * i % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> import decimal <NEWLINE> input = sys . stdin . readline <NEWLINE> n , m , d = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> if d == 0 : <NEWLINE> <INDENT> print ( ( m - 1 ) / n ) <NEWLINE> return True <NEWLINE> <DEDENT> print ( ( ( n - d ) * 2 * ( m - 1 ) / pow ( n , 2 ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from bisect import bisect_right <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = map ( int , input ( ) . split ( ) ) <NEWLINE> B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> sum_as = [ 0 ] * ( N + 1 ) <NEWLINE> sum_bs = [ 0 ] * ( M + 1 ) <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> sum_as [ i + 1 ] = sum_as [ i ] + a <NEWLINE> <NL> <DEDENT> for i , b in enumerate ( B ) : <NEWLINE> <INDENT> sum_bs [ i + 1 ] = sum_bs [ i ] + b <NEWLINE> <DEDENT> sum_bs = sum_bs [ 1 : ] <NEWLINE> <NL> answer = 0 <NEWLINE> for i , sa in enumerate ( sum_as ) : <NEWLINE> <INDENT> remain = K - sa <NEWLINE> if remain < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> idx = bisect_right ( sum_bs , remain ) <NEWLINE> answer = max ( answer , i + idx ) <NEWLINE> <NL> <DEDENT> return answer <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> print ( solve ( ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> a = int ( input ( ) ) <NEWLINE> h = int ( a / 3600 ) <NEWLINE> m = int ( ( a % 3600 ) / 60 ) <NEWLINE> s = int ( ( a % 3600 ) % 60 ) <NEWLINE> <NL> print ( <STRING> . format ( h , <STRING> , m , <STRING> , s ) ) <NEWLINE>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( format ( r * r * pi , <STRING> ) , format ( r * 2 * pi , <STRING> ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ None for _ in range ( k ) ] <NEWLINE> a = [ None for _ in range ( k ) ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d [ i ] = int ( input ( ) ) <NEWLINE> a [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> tricked = [ True for _ in range ( n ) ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> for j in range ( d [ i ] ) : <NEWLINE> <INDENT> tricked [ a [ i ] [ j ] - 1 ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if tricked [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
c = 0 <NEWLINE> input ( ) <NEWLINE> s = set ( input ( ) . split ( ) ) <NEWLINE> input ( ) <NEWLINE> t = set ( input ( ) . split ( ) ) <NEWLINE> print ( len ( s & t ) ) <NEWLINE>
import abc <NEWLINE> <NL> <NL> class AdjacentGraph : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , size ) : <NEWLINE> <INDENT> self . size = size <NEWLINE> self . _nodes = [ [ 0 ] * ( size + 1 ) for _ in range ( size + 1 ) ] <NEWLINE> <NL> <DEDENT> def set_adj_node ( self , id_ , adj_id ) : <NEWLINE> <INDENT> self . _nodes [ id_ ] [ adj_id ] = 1 <NEWLINE> <NL> <DEDENT> def __iter__ ( self ) : <NEWLINE> <INDENT> self . _id = 0 <NEWLINE> return self <NEWLINE> <NL> <DEDENT> def __next__ ( self ) : <NEWLINE> <INDENT> if self . _id < self . size : <NEWLINE> <INDENT> self . _id += 1 <NEWLINE> return ( self . _id , self . _nodes [ self . _id ] [ 1 : ] ) <NEWLINE> <NL> <DEDENT> raise StopIteration ( ) <NEWLINE> <NL> <DEDENT> def dfs ( self , handler = None ) : <NEWLINE> <INDENT> def find_first ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return visited . index ( 0 ) + 1 <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> return None <NEWLINE> <NL> <DEDENT> <DEDENT> visited = [ 0 ] * self . size <NEWLINE> first = 1 <NEWLINE> while first is not None : <NEWLINE> <INDENT> stack = [ ( first , 0 , 0 ) ] <NEWLINE> while len ( stack ) > 0 : <NEWLINE> <INDENT> i , depth , j = stack . pop ( ) <NEWLINE> if j == 0 : <NEWLINE> <INDENT> if handler : <NEWLINE> <INDENT> handler . visit ( i , depth ) <NEWLINE> <DEDENT> visited [ i - 1 ] = 1 <NEWLINE> yield i <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> j = self . _nodes [ i ] . index ( 1 , j + 1 ) <NEWLINE> stack . append ( ( i , depth , j ) ) <NEWLINE> if visited [ j - 1 ] == 0 : <NEWLINE> <INDENT> stack . append ( ( j , depth + 1 , 0 ) ) <NEWLINE> <DEDENT> <DEDENT> except ValueError : <NEWLINE> <INDENT> if handler : <NEWLINE> <INDENT> handler . leave ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> first = find_first ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def bfs ( self , handler = None ) : <NEWLINE> <INDENT> def find_first ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return visited . index ( 0 ) + 1 <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> return None <NEWLINE> <NL> <DEDENT> <DEDENT> visited = [ 0 ] * self . size <NEWLINE> first = 1 <NEWLINE> while first is not None : <NEWLINE> <INDENT> queue = [ ( first , 0 ) ] <NEWLINE> while len ( queue ) > 0 : <NEWLINE> <INDENT> ( i , depth ) , * queue = queue <NEWLINE> if visited [ i - 1 ] == 0 : <NEWLINE> <INDENT> if handler : <NEWLINE> <INDENT> handler . visit ( i , depth ) <NEWLINE> <DEDENT> visited [ i - 1 ] = 1 <NEWLINE> yield i <NEWLINE> try : <NEWLINE> <INDENT> j = 0 <NEWLINE> while j < self . size : <NEWLINE> <INDENT> j = self . _nodes [ i ] . index ( 1 , j + 1 ) <NEWLINE> if visited [ j - 1 ] == 0 : <NEWLINE> <INDENT> queue . append ( ( j , depth + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> if handler : <NEWLINE> <INDENT> handler . leave ( i ) <NEWLINE> <DEDENT> <DEDENT> first = find_first ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class EventHandler ( abc . ABC ) : <NEWLINE> <INDENT> @ abc . abstractmethod <NEWLINE> def visit ( self , i , depth ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> @ abc . abstractmethod <NEWLINE> def leave ( self , i ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Logger ( EventHandler ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . log = [ ( 0 , 0 ) ] * n <NEWLINE> self . step = 0 <NEWLINE> <NL> <DEDENT> def visit ( self , i , depth ) : <NEWLINE> <INDENT> self . step += 1 <NEWLINE> self . log [ i - 1 ] = ( self . step , depth , 0 ) <NEWLINE> <NL> <DEDENT> def leave ( self , i ) : <NEWLINE> <INDENT> self . step += 1 <NEWLINE> self . log [ i - 1 ] = ( self . log [ i - 1 ] [ 0 ] , self . log [ i - 1 ] [ 1 ] , self . step ) <NEWLINE> <NL> <DEDENT> def by_node ( self ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> for discover , depth , finish in self . log : <NEWLINE> <INDENT> yield ( i , discover , depth , finish ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> g = AdjacentGraph ( n ) <NEWLINE> log = Logger ( n ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> id_ , c , * links = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> for n in links : <NEWLINE> <INDENT> g . set_adj_node ( id_ , n ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in g . bfs ( log ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> reachable = None <NEWLINE> for node in log . by_node ( ) : <NEWLINE> <INDENT> id_ , find , dep , exit = node <NEWLINE> if id_ > 1 and dep == 0 : <NEWLINE> <INDENT> reachable = find - 1 <NEWLINE> <NL> <DEDENT> if reachable is not None and find > reachable : <NEWLINE> <INDENT> dep = - 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( id_ , dep ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
h1 , m1 , h2 , m2 , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> H = h2 - h1 <NEWLINE> M = m2 - m1 <NEWLINE> <NL> if ( M < 0 ) : <NEWLINE> <INDENT> M += 60 <NEWLINE> H -= 1 <NEWLINE> <DEDENT> if ( H < 0 ) : <NEWLINE> <INDENT> H += 24 <NEWLINE> <NL> <DEDENT> M += H * 60 <NEWLINE> <NL> ans = M - K <NEWLINE> print ( ans ) <NEWLINE>
def check ( a , b ) : <NEWLINE> <INDENT> return pow ( a , 5 ) - pow ( b , 5 ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( 0 , 120 ) : <NEWLINE> <INDENT> for j in range ( - 119 , i ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> if n == check ( i , j ) : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> a = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> N = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> S = [ x for x in input ( ) ] <NEWLINE> <NL> C = Counter ( S ) <NEWLINE> <NL> W = C [ <STRING> ] <NEWLINE> R = C [ <STRING> ] <NEWLINE> <NL> SS = S [ : R ] <NEWLINE> CC = Counter ( SS ) <NEWLINE> RR = CC [ <STRING> ] <NEWLINE> <NL> print ( RR ) <NEWLINE>
A , B = map ( str , input ( ) . split ( ) ) <NEWLINE> A = int ( A ) <NEWLINE> B1 , B2 , B3 = int ( B [ 0 ] ) , int ( B [ 2 ] ) , int ( B [ 3 ] ) <NEWLINE> ans = A * B1 * 100 + A * B2 * 10 + A * B3 <NEWLINE> ans = str ( ans ) <NEWLINE> if len ( ans ) > 2 : <NEWLINE> <INDENT> print ( int ( ans [ : - 2 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . reverse ( ) <NEWLINE> str = <STRING> <NEWLINE> for d in a : <NEWLINE> <INDENT> str += <STRING> % ( d ) <NEWLINE> <NL> <DEDENT> print ( str [ : - 1 ] ) <NEWLINE>
import math <NEWLINE> import itertools <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pf = [ 0 ] * ( n + 1 ) <NEWLINE> pb = [ 0 ] * ( n + 1 ) <NEWLINE> p = a [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p = math . gcd ( p , a [ i ] ) <NEWLINE> pf [ i + 1 ] = p <NEWLINE> <DEDENT> p = a [ - 1 ] <NEWLINE> for i in range ( - 1 , - n - 1 , - 1 ) : <NEWLINE> <INDENT> p = math . gcd ( p , a [ i ] ) <NEWLINE> pb [ i - 1 ] = p <NEWLINE> <DEDENT> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ i ] = math . gcd ( pf [ i ] , pb [ i + 1 ] ) <NEWLINE> <DEDENT> print ( max ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> <NL> for x in range ( 1 , int ( n ** 0.5 ) ) : <NEWLINE> <INDENT> for y in range ( 1 , int ( n ** 0.5 ) ) : <NEWLINE> <INDENT> for z in range ( 1 , int ( n ** 0.5 ) ) : <NEWLINE> <INDENT> a = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if a <= n : <NEWLINE> <INDENT> ans [ a - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> [ print ( x ) for x in ans ] <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> score = 1 <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = 1 <NEWLINE> s = 26 <NEWLINE> while True : <NEWLINE> <INDENT> if n <= s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c += 1 <NEWLINE> s += 26 ** c <NEWLINE> <DEDENT> a = <STRING> <NEWLINE> al = <STRING> <NEWLINE> for i in range ( 1 , c + 1 ) : <NEWLINE> <INDENT> a += al [ ( n - 1 ) % 26 ] <NEWLINE> n = ( n - 1 ) // 26 <NEWLINE> <DEDENT> print ( a [ : : - 1 ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> <NL> L = A [ left : mid ] + [ 1e9 ] <NEWLINE> R = A [ mid : right ] + [ 1e9 ] <NEWLINE> <NL> i , j = 0 , 0 <NEWLINE> <NL> for k in range ( left , right ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def merge_sort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( A , left , mid ) <NEWLINE> merge_sort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> array_length = int ( _input [ 0 ] ) <NEWLINE> array = list ( map ( int , _input [ 1 ] . split ( ) ) ) <NEWLINE> assert array_length == len ( array ) <NEWLINE> count = 0 <NEWLINE> merge_sort ( A = array , left = 0 , right = array_length ) <NEWLINE> print ( * array ) <NEWLINE> print ( count ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cumsum_a = [ 0 ] * ( N + 1 ) <NEWLINE> cumsum_b = [ 0 ] * ( M + 1 ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> cumsum_a [ i ] = cumsum_a [ i - 1 ] + A [ i - 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> cumsum_b [ i ] = cumsum_b [ i - 1 ] + B [ i - 1 ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> bi = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for j in range ( bi , - 1 , - 1 ) : <NEWLINE> <INDENT> t = cumsum_a [ i ] + cumsum_b [ j ] <NEWLINE> if t <= K : <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> bi = j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> p = 2019 <NEWLINE> sur1 = [ int ( s [ 0 ] ) % p ] <NEWLINE> sur2 = [ int ( s [ - 1 ] ) % p ] <NEWLINE> sur10 = [ 1 % p ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> sur1 += [ ( sur1 [ i ] * 10 + int ( s [ i + 1 ] ) ) % p ] <NEWLINE> sur10 += [ ( sur10 [ i ] * 10 ) % p ] <NEWLINE> sur2 += [ ( sur2 [ i ] + sur10 [ i + 1 ] * int ( s [ - i - 2 ] ) ) % p ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> d = defaultdict ( int ) <NEWLINE> for x in sur2 : <NEWLINE> <INDENT> d [ x ] += 1 <NEWLINE> <NL> <DEDENT> for k , v in d . items ( ) : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> ans += v * ( v + 1 ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> from __future__ import ( division , absolute_import , print_function , <NEWLINE> <INDENT> unicode_literals ) <NEWLINE> <DEDENT> from sys import stdin <NEWLINE> <NL> def solve ( li , n , s , total , cnt ) : <NEWLINE> <INDENT> for i in li : <NEWLINE> <INDENT> value = i * n + total <NEWLINE> if value > s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n - 1 : <NEWLINE> <INDENT> subli = li [ : ] <NEWLINE> subli . remove ( i ) <NEWLINE> r = range ( n - 1 , 0 , - 1 ) <NEWLINE> minimum = value + sum ( i * j for i , j in zip ( r , subli ) ) <NEWLINE> maximum = value + sum ( i * j for i , j in zip ( r , subli [ : : - 1 ] ) ) <NEWLINE> if minimum <= s <= maximum : <NEWLINE> <INDENT> solve ( subli , n - 1 , s , value , cnt ) <NEWLINE> <DEDENT> <DEDENT> elif value == s : <NEWLINE> <INDENT> cnt [ 0 ] += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> cnt = [ 0 ] <NEWLINE> for line in stdin : <NEWLINE> <INDENT> n , s = ( int ( s ) for s in line . split ( ) ) <NEWLINE> cnt [ 0 ] = 0 <NEWLINE> <NL> solve ( list ( range ( 10 ) ) , n , s , 0 , cnt ) <NEWLINE> print ( cnt [ 0 ] ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> c = list ( itertools . permutations ( [ <STRING> , <STRING> , <STRING> ] , 3 ) ) <NEWLINE> for j in range ( 1 , N ) : <NEWLINE> <INDENT> for i in range ( N - j * 2 ) : <NEWLINE> <INDENT> if ( S [ i ] , S [ i + j ] , S [ i + j * 2 ] ) in c : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
MOD = 998244353 <NEWLINE> <COMMENT> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> frac = [ 1 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> frac . append ( frac [ i ] * ( i + 1 ) % MOD ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def comb ( n , k , mod ) : <NEWLINE> <INDENT> a = frac [ n ] <NEWLINE> b = frac [ k ] <NEWLINE> c = frac [ n - k ] <NEWLINE> return ( a * pow ( b , mod - 2 , mod ) * pow ( c , mod - 2 , mod ) ) % mod <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> ans = [ 0 ] * ( K + 1 ) <NEWLINE> temp = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> temp *= M <NEWLINE> temp %= MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp *= ( M - 1 ) <NEWLINE> temp %= MOD <NEWLINE> <DEDENT> if i + 1 >= N - K : <NEWLINE> <INDENT> ans [ i + 1 - N + K ] = temp <NEWLINE> <DEDENT> <DEDENT> t_ans = 0 <NEWLINE> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> key = comb ( N - 1 , i , MOD ) <NEWLINE> t_ans += ( ans [ - 1 - i ] * key ) <NEWLINE> t_ans %= MOD <NEWLINE> <DEDENT> print ( t_ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> readline = stdin . readline <NEWLINE> D = int ( readline ( ) ) <NEWLINE> c = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> s = [ list ( map ( int , readline ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> <NL> kaisai = [ 0 ] * 26 <NEWLINE> kaisai_all = [ [ 0 ] * 26 for _ in range ( D ) ] <NEWLINE> manzokudo = 0 <NEWLINE> t = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> res = - float ( <STRING> ) <NEWLINE> res_i = - 1 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> henka = s [ i ] [ j ] <NEWLINE> kaisai_kari = kaisai [ : ] <NEWLINE> kaisai_kari [ j ] = i + 1 <NEWLINE> for k in range ( 26 ) : <NEWLINE> <INDENT> henka -= c [ k ] * ( i + 1 - kaisai_kari [ k ] ) <NEWLINE> <DEDENT> if res < henka : <NEWLINE> <INDENT> res = henka <NEWLINE> res_i = j <NEWLINE> <DEDENT> <DEDENT> manzokudo += res <NEWLINE> if i != 0 : <NEWLINE> <INDENT> kaisai_all [ i ] = kaisai_all [ i - 1 ] [ : ] <NEWLINE> <DEDENT> kaisai [ res_i ] = i + 1 <NEWLINE> kaisai_all [ i ] [ res_i ] = i + 1 <NEWLINE> t . append ( res_i ) <NEWLINE> <NL> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> print ( t [ i ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> m = len ( n ) <NEWLINE> li = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> li . append ( n [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( li ) ) : <NEWLINE> <INDENT> if li [ i ] == <STRING> : <NEWLINE> <INDENT> li [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( li ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s . append ( s [ i ] + A [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += A [ i ] * ( s [ N ] - s [ i + 1 ] ) <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> num = 0 <NEWLINE> <NL> for a in range ( K ) : <NEWLINE> <INDENT> for b in range ( K ) : <NEWLINE> <INDENT> ab = math . gcd ( a + 1 , b + 1 ) <NEWLINE> for c in range ( K ) : <NEWLINE> <INDENT> num += math . gcd ( ab , c + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = 0 <NEWLINE> s = 1 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if i >= K : <NEWLINE> <INDENT> B = A [ i - K ] <NEWLINE> s = a <NEWLINE> if B != 0 and B < s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif B != 0 and B >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> INF = 10 ** 9 <NEWLINE> sys . setrecursionlimit ( INF ) <NEWLINE> import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> x , = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> for i in range ( - 1000 , 1000 + 1 ) : <NEWLINE> <INDENT> for j in range ( - i + 1 , i ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> a = i <NEWLINE> b = j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> print ( ans ) <NEWLINE> return ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ el for el in map ( int , input ( ) . split ( ) ) ] <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> res = 1 <NEWLINE> for el in A : <NEWLINE> <INDENT> res *= el <NEWLINE> if res - 10 ** 18 > 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import sys <NEWLINE> import socket <NEWLINE> <NL> hostname = socket . gethostname ( ) <NEWLINE> <NL> if hostname == <STRING> : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def read_int_list ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def read_str_list ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <NL> <DEDENT> def read_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def read_str ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> N , M = read_int_list ( ) <NEWLINE> A = [ 0 ] * M <NEWLINE> B = [ 0 ] * M <NEWLINE> v = [ set ( ) for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = read_int_list ( ) <NEWLINE> v [ A [ i ] - 1 ] . add ( B [ i ] ) <NEWLINE> v [ B [ i ] - 1 ] . add ( A [ i ] ) <NEWLINE> <NL> <DEDENT> res = [ 0 ] * ( N - 1 ) <NEWLINE> done = set ( ) <NEWLINE> l = set ( [ 1 ] ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l2 = set ( ) <NEWLINE> for t in l : <NEWLINE> <INDENT> for r in v [ t - 1 ] : <NEWLINE> <INDENT> if r not in l and r not in done : <NEWLINE> <INDENT> l2 . add ( r ) <NEWLINE> res [ r - 2 ] = t <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> done . update ( l ) <NEWLINE> l = l2 <NEWLINE> <NL> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def solve0 ( ) : <NEWLINE> <INDENT> N , M = read_int_list ( ) <NEWLINE> A = [ 0 ] * M <NEWLINE> B = [ 0 ] * M <NEWLINE> v = [ set ( ) ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = read_int_list ( ) <NEWLINE> v [ A [ i ] - 1 ] . add ( B [ i ] ) <NEWLINE> v [ A [ i ] - 1 ] . add ( B [ i ] ) <NEWLINE> <NL> <DEDENT> res = [ 0 ] * ( N - 1 ) <NEWLINE> done = set ( ) <NEWLINE> l = set ( [ 1 ] ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l2 = set ( ) <NEWLINE> for k in range ( M ) : <NEWLINE> <INDENT> for t in l : <NEWLINE> <INDENT> if t == A [ k ] : <NEWLINE> <INDENT> if B [ k ] not in l and B [ k ] not in done : <NEWLINE> <INDENT> l2 . add ( B [ k ] ) <NEWLINE> res [ B [ k ] - 2 ] = A [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> if t == B [ k ] : <NEWLINE> <INDENT> if A [ k ] not in l and A [ k ] not in done : <NEWLINE> <INDENT> l2 . add ( A [ k ] ) <NEWLINE> res [ A [ k ] - 2 ] = B [ k ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> done . update ( l ) <NEWLINE> l = l2 <NEWLINE> <NL> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> res = solve ( ) <NEWLINE> print ( <STRING> , * res , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( 1 , int ( n ** ( 0.5 ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> a . append ( i ) <NEWLINE> <DEDENT> <DEDENT> m = max ( a ) <NEWLINE> c = int ( n / m ) <NEWLINE> keta = len ( str ( c ) ) <NEWLINE> print ( keta ) <NEWLINE>
import math <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if B == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if B > N : <NEWLINE> <INDENT> print ( math . floor ( A * N / B ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( math . floor ( A * ( B - 1 ) / B ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import defaultdict , deque <NEWLINE> <NL> n , m = tuple ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> L = tuple ( tuple ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) for _ in range ( m ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> X = [ n + 1 ] * ( n + 1 ) <NEWLINE> Y = [ 0 ] * ( n + 1 ) <NEWLINE> d = defaultdict ( set ) <NEWLINE> for a , b in L : <NEWLINE> <INDENT> d [ a ] . add ( b ) <NEWLINE> d [ b ] . add ( a ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> X0 = X [ 0 ] <NEWLINE> X [ 1 ] = 0 <NEWLINE> qu = deque ( [ 1 ] ) <NEWLINE> while qu : <NEWLINE> <INDENT> i = qu . popleft ( ) <NEWLINE> cost = X [ i ] <NEWLINE> for b in d [ i ] : <NEWLINE> <INDENT> if X [ b ] == X0 : <NEWLINE> <INDENT> X [ b ] = cost + 1 <NEWLINE> qu . append ( b ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> s = X [ 0 ] <NEWLINE> try : <NEWLINE> <INDENT> X . index ( X [ 0 ] , 1 ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> c = X [ i ] <NEWLINE> for v in d [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> if c - 1 == X [ v ] : <NEWLINE> <INDENT> Y [ i ] = v <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for v in Y [ 2 : ] : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> d = range ( l , r + 1 ) <NEWLINE> print ( 0 if r - l > 671 else min ( i * j % 2019 for i in d for j in d if i < j ) ) <NEWLINE>
from networkx import * <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == 0 : print ( 1 ) ; exit ( ) <NEWLINE> G = Graph ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G . add_edges_from ( [ ( a , b ) ] ) <NEWLINE> <NL> <DEDENT> print ( len ( max ( connected_components ( G ) , key = len ) ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from collections import Counter <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = readInts ( ) <NEWLINE> u = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = readInts ( ) <NEWLINE> u . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> print ( u . group_count ( ) - 1 ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> dp = [ 0 for _ in range ( X + 110 ) ] <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( X + 1 ) : <NEWLINE> <INDENT> if dp [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i + 100 ] = 1 <NEWLINE> dp [ i + 101 ] = 1 <NEWLINE> dp [ i + 102 ] = 1 <NEWLINE> dp [ i + 103 ] = 1 <NEWLINE> dp [ i + 104 ] = 1 <NEWLINE> dp [ i + 105 ] = 1 <NEWLINE> <DEDENT> print ( dp [ X ] ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( n == 0 ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = [ ] <NEWLINE> l1 = [ ] <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if x - i not in li : <NEWLINE> <INDENT> l . append ( x - i ) <NEWLINE> <DEDENT> if x + i not in li : <NEWLINE> <INDENT> l1 . append ( x + i ) <NEWLINE> <DEDENT> <DEDENT> a = max ( l ) <NEWLINE> b = min ( l1 ) <NEWLINE> if ( abs ( a - x ) > abs ( b - x ) ) : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N == K : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> B = [ ] <NEWLINE> n_plus = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a >= 0 : <NEWLINE> <INDENT> B . append ( ( a , True ) ) <NEWLINE> n_plus += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( ( - a , False ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if n_plus == 0 : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> A . sort ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A . sort ( reverse = True ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> B . sort ( key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> cnt = 0 <NEWLINE> prev_minus = None <NEWLINE> prev_plus = None <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> b , flag = B [ i ] <NEWLINE> <NL> if flag : <NEWLINE> <INDENT> prev_plus = b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> prev_minus = b <NEWLINE> <NL> <DEDENT> <DEDENT> if prev_plus == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if cnt % 2 == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> b , flag = B [ i ] <NEWLINE> ans *= b <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> next_minus = None <NEWLINE> next_plus = None <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> b , flag = B [ i ] <NEWLINE> if flag : <NEWLINE> <INDENT> if next_plus is None : <NEWLINE> <INDENT> next_plus = b <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if next_minus is None : <NEWLINE> <INDENT> next_minus = b <NEWLINE> <NL> <DEDENT> <DEDENT> if b == 0 : <NEWLINE> <INDENT> if next_minus is None : <NEWLINE> <INDENT> next_minus = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if next_plus is not None and prev_minus is not None : <NEWLINE> <INDENT> ans1 = 1 <NEWLINE> ignored = False <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> b , flag = B [ i ] <NEWLINE> <NL> if ignored or prev_minus != b : <NEWLINE> <INDENT> ans1 *= b <NEWLINE> ans1 %= MOD <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if prev_minus == b : <NEWLINE> <INDENT> ignored = True <NEWLINE> <NL> <DEDENT> <DEDENT> ans1 *= next_plus <NEWLINE> ans1 %= MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans1 = - INF <NEWLINE> <NL> <DEDENT> if next_minus is not None and prev_plus is not None : <NEWLINE> <INDENT> ans2 = 1 <NEWLINE> ignored = False <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> b , flag = B [ i ] <NEWLINE> <NL> if ignored or prev_plus != b : <NEWLINE> <INDENT> ans2 *= b <NEWLINE> ans2 %= MOD <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if prev_plus == b : <NEWLINE> <INDENT> ignored = True <NEWLINE> <NL> <DEDENT> <DEDENT> ans2 *= next_minus <NEWLINE> ans2 %= MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans2 = - INF <NEWLINE> <NL> <DEDENT> if ans1 == - INF : <NEWLINE> <INDENT> print ( ans2 ) <NEWLINE> <DEDENT> elif ans2 == - INF : <NEWLINE> <INDENT> print ( ans1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if prev_minus * next_minus > prev_plus * next_plus : <NEWLINE> <INDENT> print ( ans2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( <STRING> ) <NEWLINE> result = 1 <NEWLINE> if <STRING> in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> result *= int ( A [ i ] ) <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if abs ( x ) // d <= k and k > 1000 : <NEWLINE> <INDENT> z = k - ( abs ( x ) // d ) <NEWLINE> x = abs ( x ) % d <NEWLINE> if z % 2 == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if abs ( x ) + d <= abs ( abs ( x ) - d ) : <NEWLINE> <INDENT> print ( abs ( x ) + d ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( abs ( x ) - d ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif abs ( x ) // d > k and k > 1000 : <NEWLINE> <INDENT> x = abs ( x ) - k * d <NEWLINE> print ( abs ( x ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if abs ( x ) >= abs ( abs ( x ) - d ) : <NEWLINE> <INDENT> x = abs ( x ) - d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( k - i - 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( x ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if abs ( x ) + d <= abs ( abs ( x ) - d ) : <NEWLINE> <INDENT> print ( abs ( x ) + d ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( abs ( x ) - d ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( abs ( x ) ) <NEWLINE>
<COMMENT> <NL> from collections import Counter <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> T = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> T [ i ] = ( T [ i + 1 ] + int ( S [ i ] ) * pow ( 10 , N - i , 2019 ) ) % 2019 <NEWLINE> <DEDENT> l = Counter ( T ) <NEWLINE> ans = 0 <NEWLINE> for v in l . values ( ) : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> class UnionFind ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) <NEWLINE> <INDENT> for r in self . roots ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if len ( b ) <= a [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a [ 1 ] == 0 : <NEWLINE> <INDENT> print ( sum ( b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . sort ( reverse = True ) <NEWLINE> print ( sum ( b [ a [ 1 ] : ] ) ) <NEWLINE> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> flag = 0 <NEWLINE> ky = abs ( a - b ) <NEWLINE> if b == a : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> elif w >= v : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif abs ( ( b - a ) / ( v - w ) ) <= t : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = modpow ( m , n , mod ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <DEDENT> def modpow ( x , y , mod ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> <NL> while y : <NEWLINE> <INDENT> if y & 1 : <NEWLINE> <INDENT> res = ( res * x ) % mod <NEWLINE> <NL> <DEDENT> x = ( x * x ) % mod <NEWLINE> y >>= 1 <NEWLINE> <NL> <DEDENT> return res <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> if n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if ( n % 9 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from functools import reduce <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import heapq <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ceil = lambda x , y : ( x + y - 1 ) // y <NEWLINE> input_list = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> def bfs ( s , n , node ) : <NEWLINE> <INDENT> check = [ False for _ in range ( n ) ] <NEWLINE> check [ s ] = True <NEWLINE> queue = [ n for _ in range ( n ) ] <NEWLINE> now = 0 <NEWLINE> queue [ now ] = s <NEWLINE> ans = [ - 1 for _ in range ( n ) ] <NEWLINE> ans [ 0 ] = [ 0 ] <NEWLINE> last_ind = 1 <NEWLINE> while last_ind < n : <NEWLINE> <NL> <NL> <INDENT> if now >= n or queue [ now ] == n : <NEWLINE> <INDENT> return [ ] <NEWLINE> <NL> <DEDENT> for i in node [ queue [ now ] ] : <NEWLINE> <INDENT> edge = i [ 0 ] <NEWLINE> <NL> ind = i [ 1 ] <NEWLINE> if check [ edge ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> queue [ last_ind ] = edge <NEWLINE> last_ind += 1 <NEWLINE> <COMMENT> <NL> <NL> ans [ edge ] = queue [ now ] <NEWLINE> check [ edge ] = True <NEWLINE> <DEDENT> now += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <NL> <DEDENT> n , m = input_list ( ) <NEWLINE> node = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> u , v = input_list ( ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> node [ u ] . append ( [ v , i ] ) <NEWLINE> node [ v ] . append ( [ u , i ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = bfs ( 0 , n , node ) <NEWLINE> if len ( ans ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for each in ans [ 1 : ] : <NEWLINE> <INDENT> print ( each + 1 ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> a = 0 <NEWLINE> ans = False <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> a = 10 * a + 7 <NEWLINE> cnt += 1 <NEWLINE> if a % K == 0 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> ans = True <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = a % K <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == False : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = input ( ) <NEWLINE> a = list ( a ) <NEWLINE> a . reverse ( ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> c = 1 <NEWLINE> <NL> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] != a [ i + 1 ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE>
<COMMENT> <NL> <NL> first = 0 <NEWLINE> second = 0 <NEWLINE> third = 0 <NEWLINE> i = 0 <NEWLINE> <NL> for i in range ( 0 , 10 ) : <NEWLINE> <INDENT> line = int ( input ( ) ) <NEWLINE> <NL> if first < int ( line ) : <NEWLINE> <INDENT> third = second <NEWLINE> second = first <NEWLINE> first = int ( line ) <NEWLINE> <DEDENT> elif second < int ( line ) : <NEWLINE> <INDENT> third = second <NEWLINE> second = int ( line ) <NEWLINE> <DEDENT> elif third < int ( line ) : <NEWLINE> <INDENT> third = int ( line ) <NEWLINE> <DEDENT> <DEDENT> print ( first ) <NEWLINE> print ( second ) <NEWLINE> print ( third ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * ( 20000 ) <NEWLINE> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> for j in range ( 1 , 101 ) : <NEWLINE> <INDENT> for k in range ( 1 , 101 ) : <NEWLINE> <INDENT> if i ** 2 + j ** 2 + k ** 2 >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a [ i ** 2 + j ** 2 + k ** 2 + i * j + j * k + i * k ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from collections import deque <NEWLINE> from math import gcd <NEWLINE> a_left = deque ( ) <NEWLINE> <NL> a_left . append ( a [ 0 ] ) <NEWLINE> <NL> <NL> a_right = deque ( ) <NEWLINE> <NL> a_right . append ( a [ - 1 ] ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a_left . append ( gcd ( a_left [ - 1 ] , a [ i + 1 ] ) ) <NEWLINE> a_right . appendleft ( gcd ( a_right [ 0 ] , a [ n - i - 2 ] ) ) <NEWLINE> <NL> <NL> <DEDENT> a_right = list ( a_right ) <NEWLINE> a_left = list ( a_left ) <NEWLINE> <NL> count = max ( a_left [ - 2 ] , a_right [ 1 ] ) <NEWLINE> <NL> for j in range ( n - 2 ) : <NEWLINE> <INDENT> count = max ( gcd ( a_left [ j ] , a_right [ j + 2 ] ) , count ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
n = str ( input ( ) ) <NEWLINE> if n [ 0 ] == n [ 1 ] == n [ 2 ] or n [ 1 ] == n [ 2 ] == n [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> print ( len ( set ( s ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , * H = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> c = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if H [ i ] >= H [ i + 1 ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( c ) <NEWLINE> c = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ans . append ( c ) <NEWLINE> <NL> print ( max ( ans ) ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if 0 <= z <= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import numpy as np <NEWLINE> from numpy import array <NEWLINE> <NL> <NL> n , m , x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> a = array ( a ) <NEWLINE> <NL> c_min = 0 <NEWLINE> flag = False <NEWLINE> <NL> for i in range ( 1 , 2 ** n ) : <NEWLINE> <INDENT> b = np . zeros ( m + 1 ) <NEWLINE> <NL> for k in range ( n ) : <NEWLINE> <INDENT> if ( ( i >> k ) & 1 ) : <NEWLINE> <INDENT> b += a [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> if np . all ( b [ 1 : ] >= x ) : <NEWLINE> <INDENT> if flag == False : <NEWLINE> <INDENT> c_min = b [ 0 ] <NEWLINE> flag = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c_min = min ( c_min , b [ 0 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> c_min = int ( c_min ) <NEWLINE> <NL> if flag == False : <NEWLINE> <INDENT> c_min = - 1 <NEWLINE> <NL> <DEDENT> print ( c_min ) <NEWLINE> <NL>
def modpow ( val , n , mod ) : <NEWLINE> <INDENT> ret = 1 <NEWLINE> while n : <NEWLINE> <INDENT> if n & 1 : <NEWLINE> <INDENT> ret = ( ret * val ) % mod <NEWLINE> <DEDENT> val = ( val * val ) % mod <NEWLINE> n = n >> 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def calc ( val , my_dict , cnt ) : <NEWLINE> <INDENT> num_one = bin ( val ) . count ( <STRING> ) <NEWLINE> if val in my_dict : <NEWLINE> <INDENT> return cnt + my_dict [ val ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if num_one == 0 : <NEWLINE> <INDENT> return cnt <NEWLINE> <DEDENT> nex = val % num_one <NEWLINE> ret = calc ( nex , my_dict , cnt + 1 ) <NEWLINE> my_dict [ val ] = ret - cnt <NEWLINE> return ret <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> tmp = list ( x ) <NEWLINE> my_dict = dict ( ) <NEWLINE> <NL> num_one = tmp . count ( <STRING> ) <NEWLINE> num_one_plus = num_one + 1 <NEWLINE> num_one_minus = num_one - 1 <NEWLINE> <NL> modsum_plus = 0 <NEWLINE> modsum_minus = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if tmp [ - i ] == <STRING> : <NEWLINE> <INDENT> modsum_plus += modpow ( 2 , i - 1 , num_one_plus ) % num_one_plus <NEWLINE> if num_one_minus != 0 : <NEWLINE> <INDENT> modsum_minus += modpow ( 2 , i - 1 , num_one_minus ) % num_one_minus <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if num_one == 1 and tmp [ i ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> if tmp [ i ] == <STRING> : <NEWLINE> <INDENT> val = ( modsum_plus + modpow ( 2 , n - i - 1 , num_one_plus ) ) % num_one_plus <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if num_one_minus != 0 : <NEWLINE> <INDENT> val = ( modsum_minus - modpow ( 2 , n - i - 1 , num_one_minus ) ) % num_one_minus <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> val = 0 <NEWLINE> <DEDENT> <DEDENT> if val != 0 : <NEWLINE> <INDENT> print ( calc ( val , my_dict , 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . readline <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> x_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n >= m : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> sabun_list = [ ] <NEWLINE> x_list . sort ( ) <NEWLINE> for i , x in enumerate ( x_list ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> sabun_list . append ( x - x_list [ i - 1 ] ) <NEWLINE> <DEDENT> result = 0 <NEWLINE> sum_max_sabun = 0 <NEWLINE> sabun_list . sort ( reverse = True ) <NEWLINE> sum_max_sabun = sum ( sabun_list [ : n - 1 ] ) <NEWLINE> <NL> result = ( x_list [ - 1 ] - x_list [ 0 ] ) - sum_max_sabun <NEWLINE> <NL> print ( result ) <NEWLINE> <NL> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = 0 <NEWLINE> if N < B : <NEWLINE> <INDENT> x = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> <NL> <DEDENT> print ( math . floor ( A * x / B ) - A * math . floor ( x / B ) ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> best = 0 <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for j in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ j ] + B [ j ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> <NL> def make_grid ( h , w , num ) : return [ [ int ( num ) ] * w for _ in range ( h ) ] <NEWLINE> <NL> <COMMENT> <NL> def combinations_mod ( n , r , mod = 1000000007 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> r = min ( r , n - r ) <NEWLINE> combs = 1 <NEWLINE> for i , j in zip ( range ( n - r + 1 , n + 1 ) , range ( 1 , r + 1 ) ) : <NEWLINE> <INDENT> combs *= ( i % mod ) * pow ( j , mod - 2 , mod ) <NEWLINE> combs %= mod <NEWLINE> <DEDENT> return combs <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = NMI ( ) <NEWLINE> A = NLI ( ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 0 <NEWLINE> fac = [ 1 ] * ( N + 1 ) <NEWLINE> inv = [ 1 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i % MOD <NEWLINE> inv [ i ] = inv [ i - 1 ] * pow ( i , - 1 , MOD ) % MOD <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> max_num = 0 <NEWLINE> min_num = 0 <NEWLINE> if i >= K - 1 : <NEWLINE> <INDENT> max_num = fac [ i ] * inv [ K - 1 ] * inv [ i - K + 1 ] <NEWLINE> <DEDENT> if N - 1 - i >= K - 1 : <NEWLINE> <INDENT> min_num = fac [ N - 1 - i ] * inv [ K - 1 ] * inv [ N - K - i ] <NEWLINE> <DEDENT> ans += ( max_num - min_num ) * A [ i ] % MOD <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> aa = sum ( lst ) % ( 10 ** 9 + 7 ) <NEWLINE> <COMMENT> <NL> new_lst = [ ] <NEWLINE> temp_1 = aa <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> temp_1 -= lst [ i ] <NEWLINE> new_lst . append ( temp_1 ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> tem = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> tem += ( lst [ i ] ) * new_lst [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> print ( tem % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> if k * d <= x : <NEWLINE> <INDENT> print ( x - d * k ) <NEWLINE> <DEDENT> elif ( k - x // d ) % 2 == 0 : <NEWLINE> <INDENT> print ( x % d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d - x % d ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> B = sorted ( A ) <NEWLINE> C = max ( A ) <NEWLINE> for i in A : <NEWLINE> <INDENT> if C == i : <NEWLINE> <INDENT> print ( B [ - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( C ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <DEDENT> import collections <NEWLINE> d = collections . Counter ( s ) <NEWLINE> largest = max ( list ( d . values ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> for key in d . keys ( ) : <NEWLINE> <INDENT> if d [ key ] == largest : <NEWLINE> <INDENT> ans . append ( key ) <NEWLINE> <DEDENT> <DEDENT> ans . sort ( reverse = True ) <NEWLINE> while len ( ans ) > 0 : <NEWLINE> <INDENT> print ( ans . pop ( - 1 ) ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s in dic : <NEWLINE> <INDENT> dic [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ s ] = 1 <NEWLINE> <DEDENT> <DEDENT> mv = max ( dic . values ( ) ) <NEWLINE> for s , v in sorted ( dic . items ( ) ) : <NEWLINE> <INDENT> if v == mv : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> N = I ( ) <NEWLINE> s = [ <STRING> . join ( sorted ( S ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> from collections import Counter <NEWLINE> <NL> c = Counter ( s ) <NEWLINE> ans = 0 <NEWLINE> for i in c . keys ( ) : <NEWLINE> <INDENT> ans += c [ i ] * ( c [ i ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b : print ( 2 * a ) <NEWLINE> else : print ( max ( a , b ) + max ( a - 1 , b - 1 ) ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> f_i = sys . stdin <NEWLINE> <NL> n = int ( f_i . readline ( ) ) <NEWLINE> <NL> edges = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for l_i in f_i : <NEWLINE> <INDENT> s , t , w = map ( int , l_i . split ( ) ) <NEWLINE> edges [ s ] . append ( ( t , w ) ) <NEWLINE> edges [ t ] . append ( ( s , w ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> import collections <NEWLINE> <NL> def tree_walk ( start , switch = 0 ) : <NEWLINE> <INDENT> path = collections . deque ( ) <NEWLINE> path . append ( start ) <NEWLINE> <NL> weight = collections . deque ( ) <NEWLINE> weight . append ( 0 ) <NEWLINE> <NL> unvisited = [ True ] * n <NEWLINE> unvisited [ start ] = False <NEWLINE> <NL> rest = n - 1 <NEWLINE> end_point = start <NEWLINE> diameter = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> u = path [ - 1 ] <NEWLINE> for v , w in edges [ u ] : <NEWLINE> <INDENT> if unvisited [ v ] : <NEWLINE> <INDENT> path . append ( v ) <NEWLINE> unvisited [ v ] = False <NEWLINE> rest -= 1 <NEWLINE> weight . append ( w ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if u == path [ - 1 ] : <NEWLINE> <INDENT> distance = sum ( weight ) <NEWLINE> if diameter < distance : <NEWLINE> <INDENT> diameter = distance <NEWLINE> end_point = u <NEWLINE> <DEDENT> if rest == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> path . pop ( ) <NEWLINE> weight . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if switch : <NEWLINE> <INDENT> print ( diameter ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return end_point <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> tree_walk ( tree_walk ( 0 ) , 1 ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> from bisect import bisect_right <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A , B = [ 0 ] , [ 0 ] <NEWLINE> x , y = 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x += a [ i ] <NEWLINE> A . append ( x ) <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> y += b [ j ] <NEWLINE> B . append ( y ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if A [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> bi = bisect_right ( B , k - A [ i ] ) - 1 <NEWLINE> ans = max ( ans , i + bi ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
from operator import mul <NEWLINE> from functools import reduce <NEWLINE> N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> while len ( A ) > 1 : <NEWLINE> <INDENT> n = len ( A ) <NEWLINE> if n & 1 : <NEWLINE> <INDENT> A . append ( 1 ) <NEWLINE> n += 1 <NEWLINE> <DEDENT> L , R = A [ : n // 2 ] , A [ n // 2 : ] <NEWLINE> A = [ x * y for x , y in zip ( L , R ) ] <NEWLINE> <DEDENT> x = A [ 0 ] <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> x = - 1 <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> mylist = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> flag_list = [ float ( <STRING> ) for n in range ( N + 1 ) ] <NEWLINE> <COMMENT> <NL> myseries = [ ] <NEWLINE> <NL> myflag = 0 <NEWLINE> mypos = 1 <NEWLINE> mycnt = 0 <NEWLINE> while myflag == 0 : <NEWLINE> <INDENT> if flag_list [ mypos ] == float ( <STRING> ) : <NEWLINE> <INDENT> flag_list [ mypos ] = mycnt <NEWLINE> <COMMENT> <NL> myseries . append ( mypos ) <NEWLINE> mypos = mylist [ mypos ] <NEWLINE> mycnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> myflag = 1 <NEWLINE> mystart = flag_list [ mypos ] <NEWLINE> mylen = mycnt - mystart <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if K < mystart : <NEWLINE> <INDENT> print ( myseries [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( myseries [ ( K - mystart ) % mylen + mystart ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * ( ( 10 ** 6 ) + 1000 ) <NEWLINE> for i in L : <NEWLINE> <INDENT> dp [ i ] += 1 <NEWLINE> <NL> <DEDENT> one = [ ] <NEWLINE> for i in range ( 10 ** 6 + 1000 ) : <NEWLINE> <INDENT> if dp [ i ] == 1 : <NEWLINE> <INDENT> one . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> dp = [ 0 ] * ( ( 10 ** 6 ) + 1000 ) <NEWLINE> a = list ( set ( L ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> for j in range ( 2 * i , 10 ** 6 + 1000 , i ) : <NEWLINE> <INDENT> dp [ j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in one : <NEWLINE> <INDENT> if dp [ i ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> limit = 10 ** 9 + 7 <NEWLINE> S = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = A [ i ] % limit <NEWLINE> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> S . append ( ( S [ i - 1 ] + A [ - i ] ) % limit ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * S [ - 1 - i ] <NEWLINE> ans = ans % limit <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( 0 , len ( a ) , 2 ) : <NEWLINE> <INDENT> if a [ i ] % 2 == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> <NL> def Grouping ( F ) : <NEWLINE> <INDENT> n = len ( F ) <NEWLINE> G = [ None for i in range ( n ) ] <NEWLINE> for u in range ( n ) : <NEWLINE> <INDENT> if G [ u ] is None : <NEWLINE> <INDENT> G [ u ] = u <NEWLINE> S = [ u ] <NEWLINE> while ( len ( S ) > 0 ) : <NEWLINE> <INDENT> u1 = S . pop ( ) <NEWLINE> for u2 in F [ u1 ] : <NEWLINE> <INDENT> if G [ u2 ] is None : <NEWLINE> <INDENT> G [ u2 ] = u <NEWLINE> S . append ( u2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return G <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> istr = sys . stdin . read ( ) <NEWLINE> ilist = istr . splitlines ( ) <NEWLINE> unum , fnum = list ( map ( int , ilist [ 0 ] . split ( ) ) ) <NEWLINE> <NL> F = [ [ ] for i in range ( unum ) ] <NEWLINE> fnum += 1 <NEWLINE> for n in range ( 1 , fnum ) : <NEWLINE> <INDENT> uid , fid = map ( int , ilist [ n ] . split ( ) ) <NEWLINE> F [ uid ] . append ( fid ) <NEWLINE> F [ fid ] . append ( uid ) <NEWLINE> <NL> <DEDENT> G = Grouping ( F ) <NEWLINE> <NL> qnum = int ( ilist [ fnum ] ) <NEWLINE> fnum += 1 <NEWLINE> for q in range ( fnum , ( fnum + qnum ) ) : <NEWLINE> <INDENT> id1 , id2 = map ( int , ilist [ q ] . split ( ) ) <NEWLINE> if G [ id1 ] == G [ id2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> S = readline ( ) . strip ( ) <NEWLINE> sums = 0 <NEWLINE> mins = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> sums += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sums -= 1 <NEWLINE> mins = min ( mins , sums ) <NEWLINE> <DEDENT> <DEDENT> if sums >= 0 : <NEWLINE> <INDENT> L . append ( ( sums , mins ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R . append ( ( - sums , mins - sums ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> L . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> R . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> l_now = 0 <NEWLINE> for d , min_d in L : <NEWLINE> <INDENT> if l_now + min_d < 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l_now += d <NEWLINE> <NL> <DEDENT> <DEDENT> r_now = 0 <NEWLINE> for d , min_d in R : <NEWLINE> <INDENT> if r_now + min_d < 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r_now += d <NEWLINE> <NL> <DEDENT> <DEDENT> if l_now != r_now : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( a ) - 1 for a in input ( ) . split ( ) ] <NEWLINE> <NL> if K <= N : <NEWLINE> <INDENT> p = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> p = A [ p ] <NEWLINE> <DEDENT> print ( p + 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> p = 0 <NEWLINE> t = [ - 1 ] * N <NEWLINE> t [ 0 ] = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> p = A [ p ] <NEWLINE> if t [ p ] != - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t [ p ] = i <NEWLINE> <NL> <DEDENT> d = i - t [ p ] <NEWLINE> K -= i <NEWLINE> K %= d <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> p = A [ p ] <NEWLINE> <DEDENT> print ( p + 1 ) <NEWLINE>
S , T = [ input ( ) for i in range ( 2 ) ] <NEWLINE> U = list ( S ) <NEWLINE> W = list ( T ) <NEWLINE> if S in T and len ( S ) + 1 == len ( T ) and U [ 0 ] == W [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> X = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( K ) ] <NEWLINE> <NL> <COMMENT> <NL> dp = [ 0 ] * N <NEWLINE> acc = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] , acc [ 1 ] = 1 , 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> mod = 998244353 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> r = i - X [ j ] [ 0 ] <NEWLINE> l = i - X [ j ] [ 1 ] <NEWLINE> if r < 0 : continue <NEWLINE> l = max ( l , 0 ) <NEWLINE> <NL> dp [ i ] += acc [ r + 1 ] - acc [ l ] <COMMENT> <NEWLINE> dp [ i ] %= mod <NEWLINE> <DEDENT> acc [ i + 1 ] = acc [ i ] + dp [ i ] <COMMENT> <NEWLINE> <NL> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , h , * ab = map ( int , read ( ) . split ( ) ) <NEWLINE> tops = max ( ab [ 0 : : 2 ] ) <NEWLINE> tlst = [ b for b in ab [ 1 : : 2 ] if b > tops ] <NEWLINE> tlst . sort ( reverse = True ) <NEWLINE> i = - 1 <NEWLINE> t = 0 <NEWLINE> for i , t in enumerate ( tlst ) : <NEWLINE> <INDENT> h -= t <NEWLINE> if h <= 0 : <NEWLINE> <INDENT> h = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( h // tops + ( h % tops > 0 ) + i + 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = list ( input ( ) ) <NEWLINE> b = list ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> next = a . pop ( 0 ) <NEWLINE> while True : <NEWLINE> <INDENT> if next == <STRING> : <NEWLINE> <INDENT> if a == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> next = a . pop ( 0 ) <NEWLINE> <DEDENT> <DEDENT> elif next == <STRING> : <NEWLINE> <INDENT> if b == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> next = b . pop ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if c == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> next = c . pop ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> max_A = A [ - 1 ] + 1 <NEWLINE> ans = [ 0 ] * max_A <NEWLINE> for i in A : <NEWLINE> <INDENT> ans [ i ] += 1 <NEWLINE> if ans [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( i * 2 , max_A , i ) : <NEWLINE> <INDENT> ans [ j ] = 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans . count ( 1 ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def solve ( X : int , N : int , p : <STRING> ) : <NEWLINE> <INDENT> ii = [ i for i in range ( - 10 , 110 ) ] <NEWLINE> iii = sorted ( list ( set ( ii ) - set ( p ) ) ) <NEWLINE> idx = np . abs ( np . asarray ( iii ) - X ) . argmin ( ) <NEWLINE> print ( iii [ idx ] ) <NEWLINE> return <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> X = int ( next ( tokens ) ) <COMMENT> <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> p = [ int ( next ( tokens ) ) for _ in range ( N ) ] <COMMENT> <NEWLINE> solve ( X , N , p ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = 0 <NEWLINE> r_l = [ ] <NEWLINE> g = 0 <NEWLINE> g_l = [ ] <NEWLINE> b = 0 <NEWLINE> b_l = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> r_l . append ( i ) <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> g_l . append ( i ) <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> b_l . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = r * g * b <NEWLINE> <NL> for i in r_l : <NEWLINE> <INDENT> for j in g_l : <NEWLINE> <INDENT> tmp = abs ( i - j ) <NEWLINE> if 0 <= i - tmp and s [ i - tmp ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if 0 <= j - tmp and s [ j - tmp ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if i + tmp < n and s [ i + tmp ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if j + tmp < n and s [ j + tmp ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> if ( tmp / 2 ) . is_integer ( ) : <NEWLINE> <INDENT> if s [ max ( i , j ) - ( tmp // 2 ) ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if max ( i , j ) - ( tmp // 2 ) != min ( i , j ) + ( tmp // 2 ) and s [ min ( i , j ) + ( tmp // 2 ) ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> <NL> a = ( 2 * x - y ) / 3 <NEWLINE> b = ( 2 * y - x ) / 3 <NEWLINE> if not ( a . is_integer ( ) and b . is_integer ( ) ) or 2 * x < y or 2 * y < x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> from functools import reduce <NEWLINE> def mycmb ( n , r , p ) : <NEWLINE> <INDENT> r = min ( r , n - r ) <NEWLINE> if r == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> over = reduce ( lambda x , y : x * y % p , range ( n , n - r , - 1 ) ) <NEWLINE> under = reduce ( lambda x , y : x * y % p , range ( 1 , r + 1 ) ) <NEWLINE> return ( over * pow ( under , p - 2 , p ) ) % p <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> print ( mycmb ( a + b , a , mod ) ) <NEWLINE>
from math import gcd <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n == 2 : <NEWLINE> <INDENT> print ( max ( A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> r = max ( gcd ( A [ 0 ] , A [ 1 ] ) , gcd ( A [ 1 ] , A [ 2 ] ) , gcd ( A [ 2 ] , A [ 0 ] ) ) <NEWLINE> <COMMENT> <NL> a = gcd ( A [ 0 ] , gcd ( A [ 1 ] , A [ 2 ] ) ) <NEWLINE> <NL> for i in range ( 3 , n ) : <NEWLINE> <INDENT> r = max ( gcd ( A [ i ] , r ) , a ) <NEWLINE> a = gcd ( A [ i ] , a ) <NEWLINE> <NL> <DEDENT> print ( r ) <NEWLINE> <DEDENT>
import copy <NEWLINE> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> hw = [ ] <NEWLINE> mas = [ ] <NEWLINE> mas_su = 0 <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> hwi = input ( ) <NEWLINE> masi = [ ] <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if hwi [ j ] == <STRING> : <NEWLINE> <INDENT> masi . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> masi . append ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> mas_su += sum ( masi ) <NEWLINE> mas . append ( masi ) <NEWLINE> <NL> <DEDENT> l = 2 ** ( h + w ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( l ) : <NEWLINE> <INDENT> test = copy . deepcopy ( mas ) <NEWLINE> num = 0 <NEWLINE> for j in range ( h + w ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> if j < h : <NEWLINE> <INDENT> for p in range ( w ) : <NEWLINE> <INDENT> if test [ j ] [ p ] == 1 : <NEWLINE> <INDENT> test [ j ] [ p ] = 0 <NEWLINE> num += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for p in range ( h ) : <NEWLINE> <INDENT> if test [ p ] [ j - h ] == 1 : <NEWLINE> <INDENT> test [ p ] [ j - h ] = 0 <NEWLINE> num += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if mas_su - num == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> s = input ( ) <NEWLINE> <NL> maxs = 0 <NEWLINE> ans = [ ] <NEWLINE> for a in s : <NEWLINE> <INDENT> if a == <STRING> : <NEWLINE> <INDENT> maxs += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( maxs ) <NEWLINE> maxs = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans . append ( maxs ) <NEWLINE> print ( max ( ans ) ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> s = s [ : : - 1 ] <NEWLINE> mod = 2019 <NEWLINE> li = [ 0 ] * ( len ( s ) + 1 ) <NEWLINE> cnt = 1 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> li [ i + 1 ] = li [ i ] + int ( s [ i ] ) * cnt <NEWLINE> li [ i + 1 ] %= mod <NEWLINE> cnt *= 10 <NEWLINE> cnt %= mod <NEWLINE> <DEDENT> import collections <NEWLINE> A = collections . Counter ( li [ 1 : ] ) ; ans = 0 <NEWLINE> for u , v in A . items ( ) : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> if u == 0 : <NEWLINE> <INDENT> ans += v <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> arr = [ int ( i ) for i in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> arr = sorted ( arr ) <NEWLINE> arr = arr [ : : - 1 ] <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( 1 , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += arr [ i // 2 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> S . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> s = sum ( S ) <NEWLINE> if s % 10 != 0 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . sort ( ) <NEWLINE> for i in S : <NEWLINE> <INDENT> if i % 10 != 0 : <NEWLINE> <INDENT> s -= i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if s % 10 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> B = sorted ( A ) [ : N - 1 ] <NEWLINE> m = max ( A ) <NEWLINE> n = A . index ( max ( A ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i != n : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( B ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> R = S . count ( <STRING> ) <NEWLINE> G = S . count ( <STRING> ) <NEWLINE> ans = R * G * ( N - R - G ) <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i , N - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < N : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( a ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( min ( a ) , max ( a ) + 1 ) : <NEWLINE> <INDENT> res = c [ x ] + c [ x + 1 ] + c [ x - 1 ] <NEWLINE> ans = max ( ans , res ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> for i in range ( 1 , min ( s ) + 1 ) : <NEWLINE> <INDENT> if ( sum ( map ( lambda x : x % i , s ) ) == 0 ) : print ( i ) <NEWLINE> <DEDENT> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> B = [ 0 ] * M <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ ] <NEWLINE> b . append ( 0 ) <NEWLINE> tmp = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( tmp + B [ i ] ) <NEWLINE> tmp = tmp + B [ i ] <COMMENT> <NEWLINE> <DEDENT> a = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <COMMENT> <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <COMMENT> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> C = A % B <NEWLINE> ans = 0 <NEWLINE> b = min ( B - 1 , N ) <NEWLINE> ans = ( A * b - C * b % B ) // B <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> ans = r * g * b <NEWLINE> for i in range ( 1 , 1 + n // 2 ) : <NEWLINE> <INDENT> for j in range ( 1 , n - i * 2 + 1 ) : <NEWLINE> <INDENT> if s [ j - 1 ] != s [ j + i - 1 ] and s [ j - 1 ] != s [ j + i * 2 - 1 ] and s [ j + i - 1 ] != s [ j + i * 2 - 1 ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> <NL> maxval = a [ 0 ] <NEWLINE> cc = { maxval : 1 } <NEWLINE> <NL> ans = 0 <NEWLINE> idx = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if a [ i ] in cc : <NEWLINE> <INDENT> cc [ a [ i ] ] += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cc [ a [ i ] ] = 2 <NEWLINE> <DEDENT> cc [ maxval ] -= 1 <NEWLINE> ans += maxval <NEWLINE> if cc [ maxval ] == 0 : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> idx += 1 <NEWLINE> if maxval > a [ idx ] : <NEWLINE> <INDENT> maxval = a [ idx ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> CNTR = 0 <NEWLINE> CNTG = 0 <NEWLINE> CNTB = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> CNTR += 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> CNTG += 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> CNTB += 1 <NEWLINE> <DEDENT> <DEDENT> CONB = CNTR * CNTG * CNTB <NEWLINE> CNT = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i , N ) : <NEWLINE> <INDENT> if S [ j ] != S [ i ] : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k > N - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ k ] != S [ i ] and S [ k ] != S [ j ] : <NEWLINE> <INDENT> CNT += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( CONB - CNT ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> sum = 0 <NEWLINE> print ( sum ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if sum == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sum = sum * a [ i ] <NEWLINE> if sum > 10 ** 18 : <NEWLINE> <INDENT> sum = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ [ ] for i in range ( n ) ] <NEWLINE> e = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> b -= 1 <NEWLINE> c -= 1 <NEWLINE> a [ b ] . append ( c ) <NEWLINE> e . append ( c ) <NEWLINE> <DEDENT> col = [ 0 for i in range ( n ) ] <NEWLINE> v = deque ( [ 0 ] ) <NEWLINE> <NL> while v : <NEWLINE> <INDENT> d = v . popleft ( ) <NEWLINE> k = 1 <NEWLINE> for i in a [ d ] : <NEWLINE> <INDENT> if col [ d ] == k : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> col [ i ] = k <NEWLINE> v . append ( i ) <NEWLINE> k += 1 <NEWLINE> <DEDENT> <DEDENT> print ( max ( col ) ) <NEWLINE> for i in e : <NEWLINE> <INDENT> print ( col [ i ] ) <NEWLINE> <DEDENT>
from numba import njit <NEWLINE> import numpy as np <NEWLINE> <NL> d = int ( input ( ) ) <NEWLINE> cs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cs = np . array ( cs , dtype = np . int64 ) <NEWLINE> sm = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( d ) ] <NEWLINE> sm = np . array ( sm , dtype = np . int64 ) <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def total_satisfaction ( ts , d ) : <NEWLINE> <INDENT> ls = np . zeros ( 26 , dtype = np . int64 ) <NEWLINE> s = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> t = ts [ i ] <NEWLINE> t -= 1 <NEWLINE> s += sm [ i ] [ t ] <NEWLINE> ls [ t ] = i + 1 <NEWLINE> <NL> dv = cs * ( ( i + 1 ) - ls ) <NEWLINE> s -= dv . sum ( ) <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def differential ( s , ts , t , d , ls ) : <NEWLINE> <INDENT> i = len ( ts ) <NEWLINE> <NL> t -= 1 <NEWLINE> bk = ls [ t ] <NEWLINE> s += sm [ i ] [ t ] <NEWLINE> ls [ t ] = i + 1 <NEWLINE> <NL> dv = cs * ( ( i + 1 ) - ls ) <NEWLINE> s -= dv . sum ( ) <NEWLINE> <NL> ls [ t ] = bk <NEWLINE> return s <NEWLINE> <NL> <DEDENT> ts = [ ] <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> sc = 0 <NEWLINE> if len ( ts ) > 0 : <NEWLINE> <INDENT> tt = np . array ( ts , dtype = np . int64 ) <NEWLINE> sc = total_satisfaction ( tt , i ) <NEWLINE> <NL> <DEDENT> ls = np . zeros ( 26 , np . int64 ) <NEWLINE> for i , t in enumerate ( ts , 1 ) : <NEWLINE> <INDENT> ls [ t - 1 ] = i <NEWLINE> <NL> <DEDENT> lst = [ ] <NEWLINE> for t in range ( 1 , 26 + 1 ) : <NEWLINE> <INDENT> df = differential ( sc , ts , t , i + 1 , ls ) <NEWLINE> s = sc + df <NEWLINE> lst . append ( ( s , t ) ) <NEWLINE> <DEDENT> lst . sort ( reverse = True ) <NEWLINE> mxt = lst [ 0 ] [ 1 ] <NEWLINE> ts . append ( mxt ) <NEWLINE> print ( mxt ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> z = 101 <NEWLINE> p_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pp_list = [ i for i in range ( 102 ) ] <NEWLINE> <NL> for j in p_list : <NEWLINE> <INDENT> pp_list . remove ( j ) <NEWLINE> <NL> <DEDENT> for k in pp_list : <NEWLINE> <INDENT> zettaiti = abs ( x - k ) <NEWLINE> <NL> if z > zettaiti : <NEWLINE> <INDENT> z = zettaiti <NEWLINE> ans = k <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> import functools <NEWLINE> <NL> <COMMENT> <NL> <NL> def primes ( n ) : <NEWLINE> <INDENT> is_prime = [ 1 ] * ( n + 1 ) <NEWLINE> is_prime [ 0 ] = 0 <NEWLINE> is_prime [ 1 ] = 0 <NEWLINE> D_prime = [ i for i in range ( n + 1 ) ] <NEWLINE> D_prime [ 0 ] = 0 <NEWLINE> D_prime [ 1 ] = 1 <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if not is_prime [ i ] : <NEWLINE> <INDENT> D_prime [ i ] = i <NEWLINE> continue <NEWLINE> <DEDENT> for j in range ( i * 2 , n + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = 0 <NEWLINE> D_prime [ j ] = i <NEWLINE> <DEDENT> <DEDENT> return D_prime <NEWLINE> <NL> <NL> <NL> <DEDENT> Fnum_list2 = [ ] <NEWLINE> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> A . sort ( ) <NEWLINE> Amax = A [ - 1 ] <NEWLINE> Fnum_list2 = primes ( Amax ) <NEWLINE> j = A [ 0 ] <NEWLINE> ans = 1 <NEWLINE> <COMMENT> <NL> Ai_primes = set ( ) <NEWLINE> Ai_primes_add = [ ] <NEWLINE> gcd_num = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> p = A [ i ] <NEWLINE> while p != 1 : <NEWLINE> <INDENT> j = p <NEWLINE> p = int ( p / Fnum_list2 [ j ] ) <NEWLINE> if Fnum_list2 [ j ] in Ai_primes : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Ai_primes_add . append ( Fnum_list2 [ j ] ) <NEWLINE> <DEDENT> <DEDENT> if Fnum_list2 [ j ] in Ai_primes : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Ai_primes |= set ( Ai_primes_add ) <NEWLINE> Ai_primes_add . clear ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> gcd_num = functools . reduce ( math . gcd , A ) <NEWLINE> <NL> if ans == 0 : <NEWLINE> <INDENT> if gcd_num == 1 : <NEWLINE> <INDENT> ans = 2 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if ans == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ans == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lst = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if ( lst . count ( 0 ) > 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in lst : <NEWLINE> <INDENT> ans *= i <COMMENT> <NEWLINE> if ( ans > 1.0e+18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> uf = UnionFind ( N ) <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> uf . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE>
n = str ( input ( ) ) <NEWLINE> a = int ( 0 ) <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> a = a + int ( n [ i ] ) <NEWLINE> <DEDENT> if a % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> K , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A [ N + 1 : ] = [ A [ 0 ] + K ] <COMMENT> <NEWLINE> <NL> distance_list = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> distance = abs ( A [ i ] - A [ i + 1 ] ) <NEWLINE> distance_list . append ( distance ) <NEWLINE> <DEDENT> distance_list . remove ( max ( distance_list ) ) <NEWLINE> print ( sum ( distance_list ) ) <NEWLINE>
S = input ( ) [ : : - 1 ] <NEWLINE> P = [ 0 ] * ( len ( S ) + 1 ) <NEWLINE> a = 0 <NEWLINE> for i , j in enumerate ( ( S ) ) : <NEWLINE> <INDENT> a = ( a + int ( j ) * pow ( 10 , i , 2019 ) ) % 2019 <NEWLINE> P [ i ] = a <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * 2019 <NEWLINE> for i in P : <NEWLINE> <INDENT> dp [ i % 2019 ] += 1 <NEWLINE> <DEDENT> print ( sum ( [ i * ( i - 1 ) // 2 for i in dp ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> string = input ( ) <NEWLINE> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> for c in string : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> ans = r * g * b <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if 2 * j - i >= n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if string [ i ] != string [ j ] and string [ i ] != string [ 2 * j - i ] and string [ j ] != string [ 2 * j - i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> L = len ( A ) <NEWLINE> <COMMENT> <NL> Ans = 0 <NEWLINE> count += Ans <NEWLINE> for j in range ( L - count ) : <NEWLINE> <INDENT> if A [ count + j ] == i + 1 : <NEWLINE> <INDENT> Ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( Ans ) <NEWLINE> count += Ans <NEWLINE> <NL> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> p . append ( 4 ) <NEWLINE> <NL> <DEDENT> for a in range ( x ) : <NEWLINE> <INDENT> if sum ( p ) == y : <NEWLINE> <INDENT> ans = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . remove ( 4 ) <NEWLINE> p . append ( 2 ) <NEWLINE> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> if sum ( p ) == y : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( y == 2 ) & ( x == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if ( y == 4 ) & ( x == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> items = list ( input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if ( int ( items [ i ] ) > int ( items [ i - k ] ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x , n = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> flag = [ 0 for i in range ( 105 ) ] <NEWLINE> if ( n != 0 ) : <NEWLINE> <INDENT> p = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> for i in p : <NEWLINE> <INDENT> flag [ i ] = 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> for i in range ( 100 ) : <NEWLINE> <INDENT> if x - i >= 0 : <NEWLINE> <INDENT> if flag [ x - i ] == 0 : <NEWLINE> <INDENT> ans = x - i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> if flag [ x + i ] == 0 : <NEWLINE> <INDENT> ans = x + i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import sys <NEWLINE> import math <NEWLINE> import itertools as it <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def I2 ( ) : return map ( int , sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ) <NEWLINE> def S ( ) : return str ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def L ( ) : return list ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def Intl ( ) : return [ int ( k ) for k in sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ] <NEWLINE> def Lx ( k ) : return list ( map ( lambda x : int ( x ) * - k , sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ) ) <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> s = S ( ) <NEWLINE> cnt = 0 <NEWLINE> tgt = <STRING> <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> if s [ : i ] + s [ len ( s ) - 7 + i : ] == tgt : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> R = defaultdict ( int ) <NEWLINE> <COMMENT> <NL> <NL> for i , Ai in enumerate ( A , 1 ) : <NEWLINE> <INDENT> R [ i + Ai ] += 1 <NEWLINE> <NL> <DEDENT> L = defaultdict ( int ) <NEWLINE> for j , Aj in enumerate ( A , 1 ) : <NEWLINE> <INDENT> L [ j - Aj ] += 1 <NEWLINE> <NL> <DEDENT> for i in R : <NEWLINE> <INDENT> ans += R . get ( i , 0 ) * L . get ( i , 0 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> s = str ( input ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> stat = 0 <NEWLINE> l = [ ] <NEWLINE> a = deque ( ) <NEWLINE> b = deque ( ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> l = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> t = int ( l [ 0 ] ) <NEWLINE> if t == 1 : <NEWLINE> <INDENT> stat += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = int ( l [ 1 ] ) <NEWLINE> c = l [ 2 ] <NEWLINE> if stat % 2 == 0 : <NEWLINE> <INDENT> if f == 1 : <NEWLINE> <INDENT> a . appendleft ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( c ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if f == 1 : <NEWLINE> <INDENT> b . append ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . appendleft ( c ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = <STRING> . join ( a ) + s + <STRING> . join ( b ) <NEWLINE> if stat % 2 == 1 : <NEWLINE> <INDENT> ans = ans [ : : - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
m = int ( input ( ) ) <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , key , left , right ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class BinaryTree ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def getRoot ( self ) : <NEWLINE> <INDENT> return self . root <NEWLINE> <DEDENT> def setRoot ( self , v ) : <NEWLINE> <INDENT> self . root = v <NEWLINE> <NL> <DEDENT> def inorder ( self , v = None ) : <NEWLINE> <INDENT> if v is None : <NEWLINE> <INDENT> v = self . root <NEWLINE> <DEDENT> if v . left is not None : <NEWLINE> <INDENT> self . inorder ( v . left ) <NEWLINE> <DEDENT> print ( <STRING> + str ( v . key ) , end = <STRING> ) <NEWLINE> if v . right is not None : <NEWLINE> <INDENT> self . inorder ( v . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def preorder ( self , v = None ) : <NEWLINE> <INDENT> if v is None : <NEWLINE> <INDENT> v = self . root <NEWLINE> <DEDENT> print ( <STRING> + str ( v . key ) , end = <STRING> ) <NEWLINE> if v . left is not None : <NEWLINE> <INDENT> self . preorder ( v . left ) <NEWLINE> <DEDENT> if v . right is not None : <NEWLINE> <INDENT> self . preorder ( v . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def insert ( T , z ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = T . getRoot ( ) <NEWLINE> while x is not None : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . p = y <NEWLINE> <NL> if y is None : <NEWLINE> <INDENT> T . setRoot ( z ) <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( T , k ) : <NEWLINE> <INDENT> x = T . getRoot ( ) <NEWLINE> while x is not None : <NEWLINE> <INDENT> if x . key == k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> elif x . key < k : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> T = BinaryTree ( ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> inp = input ( ) . split ( ) <NEWLINE> if inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> T . inorder ( ) <NEWLINE> print ( ) <NEWLINE> T . preorder ( ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> elif inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> find ( T , int ( inp [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v = Node ( int ( inp [ 1 ] ) , None , None ) <NEWLINE> insert ( T , v ) <NEWLINE> <DEDENT> <DEDENT>
S = list ( str ( input ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> sofar = 0 <NEWLINE> j = 1 <NEWLINE> nax = 0 <NEWLINE> for i in range ( len ( S ) - 1 ) : <NEWLINE> <INDENT> if S [ i ] == S [ i + 1 ] : <NEWLINE> <INDENT> ans += j <NEWLINE> j += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += j <NEWLINE> nax = j <NEWLINE> j = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += j <NEWLINE> if nax != 0 : <NEWLINE> <INDENT> ans -= j <NEWLINE> <DEDENT> j = 1 <NEWLINE> nax = 0 <NEWLINE> <DEDENT> if j > nax : <NEWLINE> <INDENT> ans -= nax <NEWLINE> nax = 0 <NEWLINE> <DEDENT> <DEDENT> if j > nax : <NEWLINE> <INDENT> ans += j <NEWLINE> ans -= nax <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> t = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> cnt += math . gcd ( k , t ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def floor ( t ) : <NEWLINE> <INDENT> return int ( t ) <NEWLINE> <NL> <DEDENT> Ans = floor ( A * min ( N , B - 1 ) / B ) <NEWLINE> <NL> print ( Ans ) <NEWLINE>
N , D , A = map ( int , input ( ) . split ( ) ) <NEWLINE> monster = [ ] <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> monster . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> monster . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> monster [ k ] [ 1 ] = int ( ( monster [ k ] [ 1 ] - 0.1 ) // A + 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> <NL> final = monster [ - 1 ] [ 0 ] <NEWLINE> ruiseki = 0 <NEWLINE> minuslist = [ ] <NEWLINE> j = 0 <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> while ( j < len ( minuslist ) ) : <NEWLINE> <INDENT> if monster [ k ] [ 0 ] >= minuslist [ j ] [ 0 ] : <NEWLINE> <INDENT> ruiseki -= minuslist [ j ] [ 1 ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ruiseki < monster [ k ] [ 1 ] : <NEWLINE> <INDENT> ans += monster [ k ] [ 1 ] - ruiseki <NEWLINE> if monster [ k ] [ 0 ] + 2 * D + 1 <= final : <NEWLINE> <INDENT> minuslist . append ( [ monster [ k ] [ 0 ] + 2 * D + 1 , monster [ k ] [ 1 ] - ruiseki ] ) <NEWLINE> <DEDENT> ruiseki = monster [ k ] [ 1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import zip_longest , count , accumulate <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> <NL> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( accumulate ( LIST ( ) ) ) <NEWLINE> b = list ( accumulate ( LIST ( ) ) ) <NEWLINE> <NL> num = 0 <NEWLINE> <NL> for i , a in enumerate ( a ) : <NEWLINE> <INDENT> time_rest = k - a <NEWLINE> <NL> if time_rest < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> num = max ( num , i + bisect ( b , time_rest ) ) <NEWLINE> <NL> <DEDENT> print ( num ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K - 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , K ) : <NEWLINE> <INDENT> for c in range ( b + 1 , K + 1 ) : <NEWLINE> <INDENT> r = math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> r *= 6 <NEWLINE> ans += r <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for a in range ( 1 , K ) : <NEWLINE> <INDENT> for b in range ( a + 1 , K + 1 ) : <NEWLINE> <INDENT> r = math . gcd ( a , b ) <NEWLINE> r *= 6 <NEWLINE> ans += r <NEWLINE> <DEDENT> <DEDENT> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if len ( str ( i ) ) % 2 == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> def insert ( k , node ) : <NEWLINE> <INDENT> if k < node : <NEWLINE> <INDENT> if tree [ node ] [ <STRING> ] == None : <NEWLINE> <INDENT> tree [ node ] [ <STRING> ] = k <NEWLINE> tree [ k ] = { <STRING> : node , <STRING> : None , <STRING> : None } <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> insert ( k , tree [ node ] [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if tree [ node ] [ <STRING> ] == None : <NEWLINE> <INDENT> tree [ node ] [ <STRING> ] = k <NEWLINE> tree [ k ] = { <STRING> : node , <STRING> : None , <STRING> : None } <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> insert ( k , tree [ node ] [ <STRING> ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def pre_order ( n ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> if n == None : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> result . append ( str ( n ) ) <NEWLINE> result . extend ( pre_order ( tree [ n ] [ <STRING> ] ) ) <NEWLINE> result . extend ( pre_order ( tree [ n ] [ <STRING> ] ) ) <NEWLINE> <NL> return result <NEWLINE> <NL> <NL> <DEDENT> def in_order ( n ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> <NL> if n == None : <NEWLINE> <INDENT> return [ ] <NEWLINE> <NL> <DEDENT> result . extend ( in_order ( tree [ n ] [ <STRING> ] ) ) <NEWLINE> result . append ( str ( n ) ) <NEWLINE> result . extend ( in_order ( tree [ n ] [ <STRING> ] ) ) <NEWLINE> <NL> return result <NEWLINE> <NL> <NL> <DEDENT> M = int ( input ( ) ) <NEWLINE> root = <STRING> <NEWLINE> while root == <STRING> : <NEWLINE> <INDENT> inp = [ n for n in input ( ) . split ( ) ] <NEWLINE> if inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root = int ( inp [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> tree = { root : { <STRING> : None , <STRING> : None , <STRING> : None } } <NEWLINE> <NL> for i , _ in enumerate ( range ( M - 1 ) ) : <NEWLINE> <INDENT> inp = [ n for n in input ( ) . split ( ) ] <NEWLINE> if inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> in_text = <STRING> <NEWLINE> pre_text = <STRING> <NEWLINE> print ( <STRING> + <STRING> . join ( in_order ( root ) ) ) <NEWLINE> print ( <STRING> + <STRING> . join ( pre_order ( root ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> insert ( int ( inp [ 1 ] ) , root ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> s = int ( S ) <NEWLINE> mod = 2019 <NEWLINE> c = [ 0 ] * ( len ( S ) + 1 ) <NEWLINE> d = [ 0 ] * 2019 <NEWLINE> <NL> <NL> c [ 0 ] = 0 <NEWLINE> d [ 0 ] = 1 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> c [ i + 1 ] = ( c [ i ] + int ( S [ - i - 1 ] ) * pow ( 10 , i , mod ) ) % mod <NEWLINE> d [ c [ i + 1 ] ] += 1 <NEWLINE> <NL> <DEDENT> m = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> m += d [ i ] * ( d [ i ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( m ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> print ( ( ( sum ( A ) ** 2 - sum ( [ i ** 2 for i in A ] ) ) // 2 ) % mod ) <NEWLINE>
import math <NEWLINE> def gcd_arg3 ( a , b , c ) : <NEWLINE> <INDENT> return math . gcd ( a , math . gcd ( b , c ) ) <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gcd_a_b = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( gcd_a_b , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = defaultdict ( list ) <NEWLINE> s = set ( list ( range ( 1 , n + 1 ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> while s : <NEWLINE> <INDENT> root = s . pop ( ) <NEWLINE> q = deque ( ) <NEWLINE> q . append ( root ) <NEWLINE> done = set ( ) <NEWLINE> done . add ( root ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> node = q . popleft ( ) <NEWLINE> <NL> for adj in g [ node ] : <NEWLINE> <INDENT> if adj not in done : <NEWLINE> <INDENT> done . add ( adj ) <NEWLINE> q . append ( adj ) <NEWLINE> s . remove ( adj ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans - 1 ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> result = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> thing = input ( ) <NEWLINE> result += [ thing ] <NEWLINE> <DEDENT> print ( len ( collections . Counter ( result ) ) ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def sign ( x ) : <NEWLINE> <INDENT> return 1 if x >= 0 else - 1 <NEWLINE> <NL> <NL> <DEDENT> ans = abs ( X ) - K * D <NEWLINE> <NL> if abs ( X ) - K * D < 0 : <NEWLINE> <INDENT> divs = abs ( X ) // D <NEWLINE> mods = abs ( X ) % D <NEWLINE> nums = K - divs <NEWLINE> <NL> ans = abs ( mods - ( nums % 2 ) * D ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
<NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> return gcd ( b % a , a ) <NEWLINE> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) / gcd ( a , b ) <NEWLINE> <NL> <DEDENT> a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> print ( int ( lcm ( a , b ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> cnt = [ 0 for y in range ( N ) ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> cnt [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans , sign = 1 , 1 <NEWLINE> <NL> l , r = 0 , n - 1 <NEWLINE> <NL> if k % 2 : <NEWLINE> <INDENT> ans = A [ r ] <NEWLINE> r -= 1 <NEWLINE> k -= 1 <NEWLINE> if ans < 0 : <NEWLINE> <INDENT> sign = - 1 <NEWLINE> <DEDENT> <DEDENT> while k : <NEWLINE> <INDENT> x = A [ l ] * A [ l + 1 ] <NEWLINE> y = A [ r ] * A [ r - 1 ] <NEWLINE> <NL> if x * sign > y * sign : <NEWLINE> <INDENT> ans = x % mod * ans % mod <NEWLINE> l += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = y % mod * ans % mod <NEWLINE> r -= 2 <NEWLINE> <DEDENT> k -= 2 <NEWLINE> <DEDENT> print ( ( ans + mod ) % mod ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import math , sys <NEWLINE> for e in sys . stdin : print ( int ( float ( e ) ** 2 / 98 + 2 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> R = S . count ( <STRING> ) <NEWLINE> G = S . count ( <STRING> ) <NEWLINE> B = S . count ( <STRING> ) <NEWLINE> <NL> def f ( S ) : <NEWLINE> <INDENT> N = len ( S ) <NEWLINE> ret = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> ans = R * B * G - f ( S ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> con = 1 <NEWLINE> mod = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> why = 0 <NEWLINE> while con == 1 : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> i += 1 <NEWLINE> if ans > mod and i != n : <NEWLINE> <INDENT> ans = 1 <NEWLINE> why = 1 <NEWLINE> <DEDENT> elif ans > mod and i == n : <NEWLINE> <INDENT> con = 0 <NEWLINE> ans = 1 <NEWLINE> why = 1 <NEWLINE> <DEDENT> elif i == n : <NEWLINE> <INDENT> con = 0 <NEWLINE> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif why == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = Counter ( a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> ans = sum ( a ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += ( c - b ) * count [ b ] <NEWLINE> count [ c ] += count [ b ] <NEWLINE> count [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import collections <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> N , P = map ( int , readline ( ) . split ( ) ) <NEWLINE> S = list ( map ( int , readline ( ) . rstrip ( ) . decode ( ) ) ) <NEWLINE> <NL> def solve_2 ( S ) : <NEWLINE> <INDENT> cnt = sum ( i for i , x in enumerate ( S , 1 ) if x % 2 == 0 ) <NEWLINE> return cnt <NEWLINE> <DEDENT> def solve_5 ( S ) : <NEWLINE> <INDENT> cnt = sum ( i for i , x in enumerate ( S , 1 ) if x % 5 == 0 ) <NEWLINE> return cnt <NEWLINE> <DEDENT> def solve ( S ) : <NEWLINE> <INDENT> if P == 2 : <NEWLINE> <INDENT> return solve_2 ( S ) <NEWLINE> <DEDENT> if P == 5 : <NEWLINE> <INDENT> return solve_5 ( S ) <NEWLINE> <DEDENT> mod_cnt = [ 0 ] * ( len ( S ) ) <NEWLINE> power = 1 <NEWLINE> S = S [ : : - 1 ] <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> power *= 10 <NEWLINE> power %= P <NEWLINE> mod_cnt [ i ] = ( mod_cnt [ i - 1 ] + S [ i ] * power ) % P <NEWLINE> <DEDENT> c = collections . Counter ( mod_cnt ) <NEWLINE> cnt = sum ( n * ( n - 1 ) // 2 for n in c . values ( ) ) + c [ 0 ] <NEWLINE> return cnt <NEWLINE> <NL> <DEDENT> print ( solve ( S ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> a_dic = { } <NEWLINE> <NL> for elem in a : <NEWLINE> <INDENT> if elem not in a_dic : <NEWLINE> <INDENT> a_dic [ elem ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_dic [ elem ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> a_sum = sum ( a ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b in a_dic : <NEWLINE> <INDENT> diff = c - b <NEWLINE> a_sum += diff * a_dic [ b ] <NEWLINE> print ( a_sum ) <NEWLINE> if c in a_dic : <NEWLINE> <INDENT> a_dic [ c ] += a_dic [ b ] <NEWLINE> del a_dic [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_dic [ c ] = a_dic [ b ] <NEWLINE> del a_dic [ b ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( a_sum ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> sum = sum ( A ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> sum -= A [ i ] <NEWLINE> ans += A [ i ] * sum <NEWLINE> <NL> <DEDENT> ans = ans % 1000000007 <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . root = [ - 1 ] * ( n + 1 ) <NEWLINE> self . rank = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <COMMENT> <NEWLINE> <INDENT> if self . root [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . root [ x ] = self . find ( self . root [ x ] ) <COMMENT> <NEWLINE> return self . root [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> elif self . rank [ x ] > self . rank [ y ] : <COMMENT> <NEWLINE> <INDENT> self . root [ x ] += self . root [ y ] <NEWLINE> self . root [ y ] = x <COMMENT> <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> self . root [ y ] += self . root [ x ] <NEWLINE> self . root [ x ] = y <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ y ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def issame ( self , x , y ) : <COMMENT> <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <NL> <DEDENT> def count ( self , x ) : <COMMENT> <NEWLINE> <INDENT> return ( - 1 ) * self . root [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . unite ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = set ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans . add ( uf . find ( i ) ) <NEWLINE> <NL> <DEDENT> print ( len ( ans ) - 1 ) <NEWLINE>
import sys <NEWLINE> import bisect as bi <NEWLINE> import math <NEWLINE> from collections import defaultdict as dd <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> def cin ( ) : <NEWLINE> <INDENT> return map ( int , sin ( ) . split ( ) ) <NEWLINE> <DEDENT> def ain ( ) : <NEWLINE> <INDENT> return list ( map ( int , sin ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def sin ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def inin ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> for _ in range ( 1 ) : <NEWLINE> <INDENT> s = input ( ) . strip ( ) <NEWLINE> n = len ( s ) <NEWLINE> ans = 0 <NEWLINE> if ( <STRING> in s ) : <NEWLINE> <INDENT> p = s . index ( <STRING> ) ; <NEWLINE> c = 1 <NEWLINE> for i in range ( p + 1 , n ) : <NEWLINE> <INDENT> if ( s [ i ] == <STRING> ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , c ) <NEWLINE> c = 0 <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , c ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> s = 0 <NEWLINE> if b <= n : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> s = ( a * x ) // b - a * ( x // b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = n <NEWLINE> s = ( a * x ) // b - a * ( x // b ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> num = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for a in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> temp = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> count += math . gcd ( temp , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from sys import stdin <NEWLINE> from random import randint <NEWLINE> from time import time <NEWLINE> input = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> start = time ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b . reverse ( ) <NEWLINE> ok = 0 <NEWLINE> t = time ( ) - start <NEWLINE> while t < 1.8 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == b [ i ] : <NEWLINE> <INDENT> rng = randint ( 0 , n - 1 ) <NEWLINE> b [ i ] , b [ rng ] = b [ rng ] , b [ i ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt == 0 : <NEWLINE> <INDENT> ok = 1 <NEWLINE> break <NEWLINE> <DEDENT> t = time ( ) - start <NEWLINE> <DEDENT> if ok == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num = int ( input ( ) ) <NEWLINE> numList = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max = 1000000000000000000 <NEWLINE> flg = True <NEWLINE> result = 1 <NEWLINE> <NL> if 0 in numList : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( num ) : <NEWLINE> <INDENT> result *= numList [ i ] <NEWLINE> if result > max : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> L = [ ] <NEWLINE> for l in sys . stdin : <NEWLINE> <INDENT> L . append ( l ) <NEWLINE> <DEDENT> A = list ( map ( int , L [ 1 ] . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> answer = answer * a <NEWLINE> if answer > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if answer <= 1000000000000000000 : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < n : <NEWLINE> <INDENT> if s [ k ] != s [ i ] and s [ k ] != s [ j ] and s [ i ] != s [ j ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> crane = ( 4 * X - Y ) / 2 <NEWLINE> turtle = ( Y - 2 * X ) / 2 <NEWLINE> <NL> <NL> def is_integer_num ( n ) : <NEWLINE> <INDENT> if isinstance ( n , int ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if isinstance ( n , float ) : <NEWLINE> <INDENT> return n . is_integer ( ) <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> if is_integer_num ( crane ) and crane >= 0 and is_integer_num ( turtle ) and turtle >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> if 0 <= n <= 10000 : <NEWLINE> <INDENT> for i in range ( 1 , ( n + 1 ) ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> l . append ( str ( i ) ) <NEWLINE> <DEDENT> elif i % 10 == 3 : <NEWLINE> <INDENT> l . append ( str ( i ) ) <NEWLINE> <DEDENT> elif <STRING> in str ( i ) : <NEWLINE> <INDENT> l . append ( str ( i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> + <STRING> . join ( l ) ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> nums = [ 0 ] * len ( s ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : nums [ i ] = nums [ i - 1 ] + 1 <NEWLINE> else : nums [ i ] = nums [ i - 1 ] <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> print ( nums [ r ] - nums [ l ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> part_of_sum = [ ] <NEWLINE> s = 0 <NEWLINE> mini_sum = sum ( li [ 1 : ] ) <NEWLINE> for j in range ( n - 1 ) : <NEWLINE> <INDENT> s += li [ j ] * mini_sum <NEWLINE> mini_sum -= li [ j + 1 ] <NEWLINE> <NL> <DEDENT> print ( s % ( 10 ** 9 + 7 ) ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <DEDENT> l = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> c = collections . Counter ( A ) <NEWLINE> <COMMENT> <NL> for key in c : <NEWLINE> <INDENT> l [ key ] = c [ key ] <NEWLINE> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for item in c : <NEWLINE> <INDENT> ans += item * c [ item ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> if B [ i ] in c : <NEWLINE> <COMMENT> <NL> <INDENT> ans = ans - B [ i ] * c [ B [ i ] ] + C [ i ] * c [ B [ i ] ] <NEWLINE> c [ C [ i ] ] += c [ B [ i ] ] <NEWLINE> c . pop ( B [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if As [ i - k ] < As [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , A = map ( int , input ( ) . split ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Y = [ x - A for x in X ] <NEWLINE> dp = { 0 : 1 } <NEWLINE> <NL> for y in Y : <NEWLINE> <INDENT> tmp = list ( dp . items ( ) ) <NEWLINE> for k , v in tmp : <NEWLINE> <INDENT> dp [ k + y ] = dp . get ( k + y , 0 ) + v <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ 0 ] - 1 ) <NEWLINE>
from itertools import accumulate <NEWLINE> from bisect import bisect_left <NEWLINE> <NL> ri = lambda S : [ int ( v ) for v in S . split ( ) ] <NEWLINE> <NL> <NL> def rii ( ) : <NEWLINE> <INDENT> return ri ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> N , M , K = rii ( ) <NEWLINE> A = rii ( ) <NEWLINE> B = rii ( ) <NEWLINE> <NL> i = j = 0 <NEWLINE> <NL> pA = [ 0 ] + list ( accumulate ( A ) ) <NEWLINE> pB = [ 0 ] + list ( accumulate ( B ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i , a in enumerate ( pA ) : <NEWLINE> <INDENT> br = 0 <NEWLINE> if K >= a : <NEWLINE> <INDENT> r = K - a <NEWLINE> br = i <NEWLINE> <NL> <DEDENT> if r : <NEWLINE> <INDENT> j = bisect_left ( pB , r ) <NEWLINE> if j != len ( pB ) : <NEWLINE> <INDENT> if pB [ j ] > r : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> br += j <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , br ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> res = 0 <NEWLINE> if s * 2 <= c : <NEWLINE> <INDENT> res = s <NEWLINE> c -= s * 2 <NEWLINE> s = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += c // 2 <NEWLINE> c = 0 <NEWLINE> <NL> <DEDENT> if c : <NEWLINE> <INDENT> res += c // 4 <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> t = [ 0 ] * n <NEWLINE> r = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> t [ i ] = r <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> def sum_k ( n ) : <NEWLINE> <INDENT> return n * ( n + 1 ) // 2 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += i * sum_k ( n // i ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> ret = 0 <NEWLINE> ans = 0 <NEWLINE> if B == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if B > N : <NEWLINE> <INDENT> base = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> base = B - 1 <NEWLINE> <DEDENT> ret = math . floor ( A * base / B ) - A * math . floor ( base / B ) <NEWLINE> print ( ret ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> SA = list ( range ( A , min ( B , A + K ) ) ) <NEWLINE> SB = list ( range ( max ( A , B - K + 1 ) , B + 1 ) ) <NEWLINE> <NL> ans = sorted ( set ( SA + SB ) ) <NEWLINE> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> _list = list ( range ( 1 , n + 1 ) ) <NEWLINE> for x in _list : <NEWLINE> <INDENT> if x % 3 == 0 or any ( list ( map ( lambda x : x == 3 , list ( map ( int , list ( str ( x ) ) ) ) ) ) ) : <NEWLINE> <INDENT> print ( <STRING> % x , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = [ ] <NEWLINE> SA = sum ( A ) <NEWLINE> SB = sum ( B ) <NEWLINE> S = SA - SB <NEWLINE> cnt = 0 <NEWLINE> ns = 0 <NEWLINE> if SB > SA : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for a , b in zip ( A , B ) : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> C . append ( a - b ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> ns += b - a <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> C . sort ( reverse = True ) <NEWLINE> for i in range ( len ( C ) ) : <NEWLINE> <INDENT> if ns > 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> ns -= C [ i ] <NEWLINE> <DEDENT> else : break <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( <STRING> ) <NEWLINE> s = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if int ( A [ i ] ) == 0 : <NEWLINE> <INDENT> s = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if s == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = s * int ( A [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> ls = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> flag = 1 <NEWLINE> for e in ls : <NEWLINE> <INDENT> ans *= e <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> zeroflag = 1 <NEWLINE> for e in ls : <NEWLINE> <INDENT> if e == 0 : <NEWLINE> <INDENT> zeroflag = 0 <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 * zeroflag ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( N , B - 1 ) <NEWLINE> p = A * x // B <NEWLINE> q = x // B * A <NEWLINE> ans = p - q <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> <NL> S = [ A [ 0 ] ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> S [ i ] = S [ i - 1 ] + A [ i ] <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> sum += ( A [ i ] * ( S [ N - 1 ] - S [ i ] ) ) % p <NEWLINE> <DEDENT> print ( sum % p ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> product = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> product = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> product *= i <NEWLINE> if product > 10 ** 18 : <NEWLINE> <INDENT> product = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( product ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = ( a ) // 2 + 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , b , 1 ) : <NEWLINE> <INDENT> x = a // i <NEWLINE> ans += ( ( x ** 2 + x ) // 2 ) * i <NEWLINE> <DEDENT> ans += ( a ** 2 + a + b - b ** 2 ) // 2 <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> l [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> N = N % K <NEWLINE> print ( min ( N , K - N ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> i = ( N // B ) * B <NEWLINE> <NL> i = i - 1 <NEWLINE> if i < 0 : <NEWLINE> <INDENT> ans = ( A * N ) // B - A * ( N // B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( A * i ) // B - A * ( i // B ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> n_data = Counter ( A ) <NEWLINE> ans = sum ( A ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += ( c - b ) * n_data [ b ] <NEWLINE> n_data [ c ] += n_data [ b ] <NEWLINE> n_data [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> l [ a [ i ] - 1 ] = l [ a [ i ] - 1 ] + 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( A [ 1 : ] ) <NEWLINE> B = [ 0 ] * ( N + 1 ) <NEWLINE> B [ 0 ] = 1 - A [ 0 ] <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> s -= A [ i + 1 ] <NEWLINE> if 2 * B [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> B [ i + 1 ] = min ( 2 * B [ i ] - A [ i + 1 ] , s ) <NEWLINE> <DEDENT> if B [ - 1 ] != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( A ) + sum ( B ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum_a = 0 <NEWLINE> result = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum_a += a [ i ] <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> sum_a -= a [ j ] <NEWLINE> result += sum_a * a [ j ] <NEWLINE> <DEDENT> print ( result % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for l in range ( q ) ] <NEWLINE> cnt = [ 0 ] * 100001 <NEWLINE> Sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cnt [ a [ i ] ] += 1 <NEWLINE> Sum += a [ i ] <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> Sum += ( bc [ i ] [ 1 ] - bc [ i ] [ 0 ] ) * cnt [ bc [ i ] [ 0 ] ] <NEWLINE> cnt [ bc [ i ] [ 1 ] ] += cnt [ bc [ i ] [ 0 ] ] <NEWLINE> cnt [ bc [ i ] [ 0 ] ] = 0 <NEWLINE> print ( Sum ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> M = 10 ** 9 + 7 <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p_list = [ ] <NEWLINE> n_list = [ ] <NEWLINE> z_count = 0 <NEWLINE> <NL> for A in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> if A < 0 : <NEWLINE> <INDENT> n_list . append ( A ) <NEWLINE> <DEDENT> elif A > 0 : <NEWLINE> <INDENT> p_list . append ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z_count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> p_list . sort ( ) <NEWLINE> n_list . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if len ( p_list ) + len ( n_list ) < K : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> values = [ ] <NEWLINE> <NL> if len ( p_list ) + len ( n_list ) == K : <NEWLINE> <INDENT> values = p_list + n_list <NEWLINE> n_count = 0 <NEWLINE> for v in values : <NEWLINE> <INDENT> if v < 0 : <NEWLINE> <INDENT> n_count += 1 <NEWLINE> <DEDENT> <DEDENT> if n_count % 2 == 1 and z_count > 0 : <NEWLINE> <INDENT> values = [ 0 ] <NEWLINE> <DEDENT> <DEDENT> elif len ( p_list ) == 0 and K % 2 == 1 : <NEWLINE> <INDENT> if z_count > 0 : <NEWLINE> <INDENT> values = [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( min ( len ( n_list ) , K ) ) : <NEWLINE> <INDENT> values . append ( n_list . pop ( ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> n_list . reverse ( ) <NEWLINE> values_pair = [ ] <NEWLINE> values_left = None <NEWLINE> values_left_count = 0 <NEWLINE> if len ( p_list ) >= K : <NEWLINE> <INDENT> if K % 2 == 1 : <NEWLINE> <INDENT> values_left = p_list . pop ( ) <NEWLINE> values_left_count = 1 <NEWLINE> p_count = K - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p_count = K <NEWLINE> <NL> <DEDENT> while len ( values_pair ) * 2 + values_left_count < K : <NEWLINE> <INDENT> v1 = p_list . pop ( ) <NEWLINE> v2 = p_list . pop ( ) <NEWLINE> values_pair . append ( ( v1 * v2 , v1 , v2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( K - len ( p_list ) ) % 2 == 1 and len ( p_list ) > 0 : <NEWLINE> <INDENT> p_count = len ( p_list ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p_count = len ( p_list ) <NEWLINE> <NL> <DEDENT> if p_count % 2 == 1 : <NEWLINE> <INDENT> values_left = p_list . pop ( ) <NEWLINE> values_left_count = 1 <NEWLINE> p_count -= 1 <NEWLINE> <NL> <DEDENT> for i in range ( 0 , p_count - 1 , 2 ) : <NEWLINE> <INDENT> v1 = p_list . pop ( ) <NEWLINE> v2 = p_list . pop ( ) <NEWLINE> values_pair . append ( ( v1 * v2 , v1 , v2 ) ) <NEWLINE> <NL> <DEDENT> while len ( values_pair ) * 2 + values_left_count < K : <NEWLINE> <INDENT> v1 = n_list . pop ( ) <NEWLINE> v2 = n_list . pop ( ) <NEWLINE> values_pair . append ( ( v1 * v2 , v1 , v2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> values_pair . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> i = 0 <NEWLINE> for i in range ( len ( values_pair ) ) : <NEWLINE> <INDENT> if len ( n_list ) < 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif values_pair [ i ] [ 0 ] < n_list [ - 1 ] * n_list [ - 2 ] : <NEWLINE> <INDENT> v1 = n_list . pop ( ) <NEWLINE> v2 = n_list . pop ( ) <NEWLINE> values_pair [ i ] = ( v1 * v2 , v1 , v2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if values_left != None : <NEWLINE> <INDENT> values . append ( values_left ) <NEWLINE> <NL> <DEDENT> for prod , v1 , v2 in values_pair : <NEWLINE> <INDENT> values . append ( v1 ) <NEWLINE> values . append ( v2 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> total = 1 <NEWLINE> for v in values : <NEWLINE> <INDENT> total = ( total * v ) % M <NEWLINE> <COMMENT> <NL> <DEDENT> print ( total ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def Cost ( a , Sum ) : <NEWLINE> <INDENT> if Sum > 0 : <NEWLINE> <INDENT> if Sum + a < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return abs ( Sum + a ) + 1 <NEWLINE> <DEDENT> <DEDENT> if Sum < 0 : <NEWLINE> <INDENT> if Sum + a > 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return abs ( Sum + a ) + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> Sum = lambda a , preSum : preSum + a if Cost ( a , preSum ) == 0 else ( - 1 ) ** int ( preSum > 0 ) <NEWLINE> <NL> pCost , pSum = ( lambda : ( 0 , A [ 0 ] ) if A [ 0 ] > 0 else ( abs ( A [ 0 ] ) + 1 , 1 ) ) ( ) <NEWLINE> nCost , nSum = ( lambda : ( 0 , A [ 0 ] ) if A [ 0 ] < 0 else ( abs ( A [ 0 ] ) + 1 , - 1 ) ) ( ) <NEWLINE> for a in A [ 1 : ] : <NEWLINE> <INDENT> pCost += Cost ( a , pSum ) <NEWLINE> pSum = Sum ( a , pSum ) <NEWLINE> nCost += Cost ( a , nSum ) <NEWLINE> nSum = Sum ( a , nSum ) <NEWLINE> <DEDENT> print ( min ( pCost , nCost ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> node = i + 1 <NEWLINE> key = H [ i ] <NEWLINE> parent = H [ int ( node / 2 ) - 1 ] if node != 1 else None <NEWLINE> left = H [ node * 2 - 1 ] if node * 2 <= n else None <NEWLINE> right = H [ node * 2 ] if node * 2 + 1 <= n else None <NEWLINE> print ( <STRING> % ( node , key ) , end = <STRING> ) <NEWLINE> if parent != None : print ( <STRING> % parent , end = <STRING> ) <NEWLINE> if left != None : print ( <STRING> % left , end = <STRING> ) <NEWLINE> if right != None : print ( <STRING> % right , end = <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> if int ( N ) < 10 : <NEWLINE> <INDENT> if int ( N ) == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif int ( N ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif int ( N ) >= 10 : <NEWLINE> <INDENT> l = [ int ( n ) for n in list ( N ) ] <NEWLINE> a = sum ( l ) <NEWLINE> if a % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from math import floor , ceil , sqrt , factorial , log , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from collections import Counter , defaultdict <NEWLINE> from heapq import heappop , heappush , heappushpop <NEWLINE> import copy <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def lcm ( a , b ) : return a * b / gcd ( a , b ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , x , y = LI ( ) <NEWLINE> d = [ 0 ] * n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> d [ min ( j - i , abs ( x - i ) + 1 + abs ( j - y ) , <NEWLINE> <INDENT> abs ( y - i ) + 1 + abs ( j - x ) ) - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for k in range ( n - 1 ) : <NEWLINE> <INDENT> print ( d [ k ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> asum = [ 0 ] <NEWLINE> bsum = [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> asum . append ( asum [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> bsum . append ( bsum [ i ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> best = m <NEWLINE> answer = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> j = best <NEWLINE> while 1 : <NEWLINE> <INDENT> if bsum [ j ] <= ( k - asum [ i ] ) : <NEWLINE> <INDENT> best = j <NEWLINE> if answer < i + j : <NEWLINE> <INDENT> answer = i + j <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> j -= 1 <NEWLINE> if j < 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bits = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> bits |= bits << a <NEWLINE> <DEDENT> for m in M : <NEWLINE> <INDENT> print ( <STRING> if ( bits >> m ) & 1 else <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> import collections <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> c = collections . Counter ( S ) <NEWLINE> c = c [ <STRING> ] * c [ <STRING> ] * c [ <STRING> ] <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < N : <NEWLINE> <INDENT> if ( S [ i ] != S [ j ] ) and ( S [ j ] != S [ k ] ) and ( S [ i ] != S [ k ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( c - count ) <NEWLINE> <NL> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> num = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( <STRING> ) ) ) ; <NEWLINE> <NL> maxi = 1000000000000000000 <NEWLINE> <NL> val = 1 ; <NEWLINE> arr . sort ( ) <NEWLINE> <NL> if arr [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in arr : <NEWLINE> <INDENT> val = val * i ; <NEWLINE> if val > maxi : <NEWLINE> <INDENT> val = - 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( val ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
from collections import Counter <NEWLINE> <NL> while True : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 and M == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> H = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> W = [ int ( input ( ) ) for _ in range ( M ) ] <NEWLINE> <NL> all_H = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( i , N ) : <NEWLINE> <INDENT> s += H [ j ] <NEWLINE> all_H . append ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> all_W = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( i , M ) : <NEWLINE> <INDENT> s += W [ j ] <NEWLINE> all_W . append ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> all_H = Counter ( all_H ) <NEWLINE> all_W = Counter ( all_W ) <NEWLINE> ans = 0 <NEWLINE> for k , v in all_H . items ( ) : <NEWLINE> <INDENT> if k in all_H : <NEWLINE> <INDENT> ans += v * all_W [ k ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ret = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ret -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> for i in range ( int ( N ** 0.5 + 1 ) , - 1 , - 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> print ( len ( str ( N // i ) ) ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> c = i <NEWLINE> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if c % k != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> p = 0 <NEWLINE> u = 0 <NEWLINE> l = <STRING> <NEWLINE> r = <STRING> <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> q = list ( input ( ) . split ( ) ) <NEWLINE> if q [ 0 ] == <STRING> : <NEWLINE> <INDENT> u += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if q [ 1 ] == <STRING> and u % 2 == 0 or q [ 1 ] == <STRING> and u % 2 == 1 : <NEWLINE> <INDENT> l = l + q [ 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = r + q [ 2 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if u % 2 == 0 : <NEWLINE> <INDENT> l = l [ : : - 1 ] <NEWLINE> S = l + S + r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = S [ : : - 1 ] <NEWLINE> r = r [ : : - 1 ] <NEWLINE> S = r + S + l <NEWLINE> <DEDENT> print ( S ) <NEWLINE>
d = set ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d . add ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( d ) ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sm = sum ( A ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> sm -= a <NEWLINE> ans += sm * a <NEWLINE> ans %= ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> goods = { } <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> good = input ( ) <NEWLINE> goods [ good ] = 1 <NEWLINE> <NL> <NL> <DEDENT> print ( len ( goods ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> <NL> A . append ( 0 ) <NEWLINE> <NL> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> ans [ A [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT> print ( 0 ) <NEWLINE>
import bisect <NEWLINE> <NL> <NL> def memoize ( f ) : <NEWLINE> <INDENT> cache = { } <NEWLINE> <NL> def func ( x ) : <NEWLINE> <INDENT> if x not in cache : <NEWLINE> <INDENT> cache [ x ] = f ( x ) <NEWLINE> <DEDENT> return cache [ x ] <NEWLINE> <NL> <DEDENT> return func <NEWLINE> <NL> <NL> <DEDENT> @ memoize <NEWLINE> def get_bisect ( y ) : <NEWLINE> <INDENT> return bisect . bisect ( vy , ( y , ) ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> vx , vy = [ ] , [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> if x1 == x2 : <NEWLINE> <INDENT> if y1 > y2 : <NEWLINE> <INDENT> y1 , y2 = y2 , y1 <NEWLINE> <DEDENT> vx . append ( ( x1 , y1 , y2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x1 > x2 : <NEWLINE> <INDENT> x1 , x2 = x2 , x1 <NEWLINE> <DEDENT> vy . append ( ( y1 , x1 , x2 ) ) <NEWLINE> <DEDENT> <DEDENT> vy . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for x , y1 , y2 in vx : <NEWLINE> <INDENT> it1 , it2 = get_bisect ( y1 ) , get_bisect ( y2 + 1 ) <NEWLINE> ans += sum ( 1 for y , x1 , x2 in vy [ it1 : it2 ] if x1 <= x <= x2 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = [ ] <NEWLINE> g = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> <DEDENT> ans = len ( r ) * len ( g ) * len ( b ) <NEWLINE> for i in b : <NEWLINE> <INDENT> for j in g : <NEWLINE> <INDENT> a = max ( i , j ) <NEWLINE> u = min ( i , j ) <NEWLINE> if a * 2 - u >= 0 and a * 2 - u < n : <NEWLINE> <INDENT> if s [ a * 2 - u ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> if 2 * u - a >= 0 and 2 * u - a < n : <NEWLINE> <INDENT> if s [ 2 * u - a ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> if ( a - u ) % 2 == 0 and u + ( a - u ) / 2 >= 0 and u + ( a - u ) / 2 < n : <NEWLINE> <INDENT> if s [ u + ( a - u ) // 2 ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> def wa ( N , K ) : <NEWLINE> <INDENT> return K * ( N + 1 - K ) + 1 <NEWLINE> <DEDENT> d = 0 <NEWLINE> for i in range ( K , N + 2 ) : <NEWLINE> <INDENT> d = d + wa ( N , i ) <NEWLINE> <DEDENT> print ( ( d ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 1000000007 <NEWLINE> ans = 0 <NEWLINE> cs = [ 0 ] * N <NEWLINE> cs [ 0 ] = A [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> cs [ i ] = cs [ i - 1 ] + A [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> n = A [ i ] * ( cs [ - 1 ] - cs [ i ] ) % mod <NEWLINE> ans += n <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h_array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = [ ] <NEWLINE> sum = 0 <NEWLINE> answer = [ True for i in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> ab . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( ab ) ) : <NEWLINE> <INDENT> if h_array [ ab [ i ] [ 0 ] - 1 ] >= h_array [ ab [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> answer [ ab [ i ] [ 1 ] - 1 ] = False <NEWLINE> <DEDENT> if h_array [ ab [ i ] [ 1 ] - 1 ] >= h_array [ ab [ i ] [ 0 ] - 1 ] : <NEWLINE> <INDENT> answer [ ab [ i ] [ 0 ] - 1 ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer . count ( True ) ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> array = [ input ( ) for a in range ( N ) ] <NEWLINE> base = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> for I in base : <NEWLINE> <INDENT> print ( I + <STRING> + str ( array . count ( I ) ) ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = deque ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> cmd = input ( ) . split ( <STRING> ) <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> l . appendleft ( cmd [ 1 ] ) <NEWLINE> <DEDENT> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> try : l . remove ( cmd [ 1 ] ) <NEWLINE> except : pass <NEWLINE> <DEDENT> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> l . popleft ( ) <NEWLINE> <DEDENT> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> l . pop ( ) <NEWLINE> <DEDENT> <DEDENT> print ( * l ) <NEWLINE> <NL>
def gcd ( a , b ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> a_init = a <NEWLINE> a = b <NEWLINE> b = a_init <NEWLINE> <DEDENT> while b != 0 : <NEWLINE> <INDENT> r = a % b <NEWLINE> a = b <NEWLINE> b = r <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> temp = [ ] <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , a ) : <NEWLINE> <INDENT> temp . append ( gcd ( a , b ) ) <NEWLINE> <DEDENT> <DEDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( len ( temp ) ) : <NEWLINE> <INDENT> count += gcd ( c , temp [ j ] ) * 2 <NEWLINE> <DEDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> count += gcd ( c , k ) <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> if N >= 4 : <NEWLINE> <INDENT> C = [ 0 ] * N <NEWLINE> C [ 0 ] = 0 <NEWLINE> C [ 1 ] = 0 <NEWLINE> C [ 2 ] = 1 <NEWLINE> n = 2 <NEWLINE> <COMMENT> <NL> while True : <NEWLINE> <INDENT> n = n + 1 <NEWLINE> C [ n ] = C [ n - 1 ] + C [ n - 3 ] <NEWLINE> <COMMENT> <NL> if n == ( N - 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( C [ N - 1 ] % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT> if N == 3 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> if N <= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ 0 ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ L ] [ R ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> G [ i + 1 ] [ j + 1 ] += G [ i + 1 ] [ j ] + G [ i ] [ j + 1 ] - G [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = G [ q ] [ q ] - G [ p - 1 ] [ q ] - G [ q ] [ p - 1 ] + G [ p - 1 ] [ p - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> sums = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> a = i + 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> b = i + 1 <NEWLINE> d = math . gcd ( a , b ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> c = i + 1 <NEWLINE> <NL> sums = sums + math . gcd ( c , d ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sums ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> mul = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mul = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> mul = mul * A [ i ] <NEWLINE> if mul > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if mul > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mul ) <NEWLINE> <DEDENT>
from heapq import * <NEWLINE> a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s [ 2 ] == <STRING> : break <NEWLINE> elif s [ 0 ] == <STRING> : heappush ( a , - int ( s [ 7 : ] ) ) <NEWLINE> else : print ( - heappop ( a ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> height = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> height_x = height [ x - 1 ] <NEWLINE> height_y = height [ y - 1 ] <NEWLINE> if height_x > height_y : <NEWLINE> <INDENT> arr . append ( y ) <NEWLINE> <DEDENT> elif height_x < height_y : <NEWLINE> <INDENT> arr . append ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr . append ( x ) <NEWLINE> arr . append ( y ) <NEWLINE> <DEDENT> <DEDENT> arr = list ( set ( arr ) ) <NEWLINE> print ( n - len ( arr ) ) <NEWLINE> <NL>
S = list ( input ( ) ) <NEWLINE> T = list ( input ( ) ) <NEWLINE> pos = [ ] <NEWLINE> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> if S [ i ] == T [ 0 ] or S [ i ] == <STRING> : <NEWLINE> <INDENT> flag = 1 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if not T [ j ] == S [ i + j ] and not S [ i + j ] == <STRING> : <NEWLINE> <INDENT> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> pos . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if not pos : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> words = [ ] <NEWLINE> for p in pos : <NEWLINE> <INDENT> word = S [ 0 : p ] + T + S [ p + len ( T ) : ] <NEWLINE> for i in range ( len ( word ) ) : <NEWLINE> <INDENT> if word [ i ] == <STRING> : <NEWLINE> <INDENT> word [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> words . append ( word ) <NEWLINE> <DEDENT> words . sort ( ) <NEWLINE> print ( <STRING> . join ( words [ 0 ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> a0 = sum ( a [ 1 : ] ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += ( a0 * a [ i ] ) % mod <NEWLINE> ans %= mod <NEWLINE> a0 -= a [ i + 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> mul = 1 <NEWLINE> limit = 1000000000000000000 <NEWLINE> x = input ( ) . split ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p = int ( x [ i ] ) <NEWLINE> if ( p == 0 ) : <NEWLINE> <INDENT> mul = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( mul == 0 ) : <NEWLINE> <INDENT> print ( mul ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> p = int ( x [ i ] ) <NEWLINE> mul *= p <NEWLINE> if ( mul > limit ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ( mul > limit ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mul ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> k = int ( ( 10 ** 9 + 8 ) / 2 ) <NEWLINE> sum = 0 <NEWLINE> sum_1 = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> sum += A [ i ] <NEWLINE> <DEDENT> sum = ( sum ** 2 ) % mod <NEWLINE> <NL> for j in range ( N ) : <NEWLINE> <INDENT> sum_1 += A [ j ] ** 2 <NEWLINE> <DEDENT> sum_1 = ( sum_1 ) % mod <NEWLINE> <NL> ans = sum - sum_1 <NEWLINE> ans = ( ans * k ) % mod <NEWLINE> <NL> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> P = stdin . readline ( ) . rstrip ( ) . split ( ) <NEWLINE> if <STRING> in P : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <COMMENT> <NL> <DEDENT> ans = 1 <NEWLINE> for a in P : <NEWLINE> <INDENT> ans *= int ( a ) <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> an = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if ( k < n ) and ( s [ i ] != s [ j ] ) and ( s [ j ] != s [ k ] ) and ( s [ i ] != s [ k ] ) : <NEWLINE> <INDENT> an -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( an ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> NUM = [ i for i in range ( 1 , N + 1 ) ] <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L_NUM = [ x + y for ( x , y ) in zip ( NUM , H ) ] <NEWLINE> R_NUM = [ x - y for ( x , y ) in zip ( NUM , H ) ] <NEWLINE> <NL> L_dict = collections . Counter ( L_NUM ) <NEWLINE> R_dict = collections . Counter ( R_NUM ) <NEWLINE> <NL> ANS = 0 <NEWLINE> for i in L_dict . keys ( ) : <NEWLINE> <INDENT> cnt = L_dict [ i ] * R_dict [ i ] <NEWLINE> ANS += cnt <NEWLINE> <DEDENT> print ( ANS ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ i + 1 ] = b [ i ] + a [ i ] <NEWLINE> <DEDENT> x = [ [ 0 , 0 ] for _ in range ( n - 3 ) ] <NEWLINE> j = 1 <NEWLINE> for i in range ( 2 , n - 1 ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if i == j + 1 : <NEWLINE> <INDENT> x [ i - 2 ] [ 0 ] = b [ j ] <NEWLINE> break <NEWLINE> <DEDENT> if abs ( b [ i ] - 2 * b [ j ] ) > abs ( b [ i ] - 2 * b [ j + 1 ] ) : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x [ i - 2 ] [ 0 ] = b [ j ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> j = n - 1 <NEWLINE> for i in range ( n - 2 , 1 , - 1 ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if i == j - 1 : <NEWLINE> <INDENT> x [ i - 2 ] [ 1 ] = b [ j ] <NEWLINE> break <NEWLINE> <DEDENT> if abs ( b [ n ] + b [ i ] - 2 * b [ j ] ) > abs ( b [ n ] + b [ i ] - 2 * b [ j - 1 ] ) : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x [ i - 2 ] [ 1 ] = b [ j ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 1145141919810 <NEWLINE> for i in range ( n - 3 ) : <NEWLINE> <INDENT> s = [ x [ i ] [ 0 ] , b [ i + 2 ] - x [ i ] [ 0 ] , x [ i ] [ 1 ] - b [ i + 2 ] , b [ n ] - x [ i ] [ 1 ] ] <NEWLINE> ans = min ( ans , max ( s ) - min ( s ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> dp = [ True ] * ( A [ - 1 ] + 1 ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if dp [ A [ i ] ] : <NEWLINE> <INDENT> if ( i == len ( A ) - 1 ) or ( A [ i ] != A [ i + 1 ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> k = 1 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> dp [ k * A [ i ] ] = False <NEWLINE> k += 1 <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if i == j == k : <NEWLINE> <INDENT> ans = ans + gcd ( i , j , k ) <NEWLINE> <DEDENT> elif i == j or j == k or i == k : <NEWLINE> <INDENT> ans = ans + gcd ( i , j , k ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + gcd ( i , j , k ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_lst = [ int ( elem ) for elem in input ( ) . split ( ) ] <NEWLINE> <NL> dic = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not i - a_lst [ i ] in dic : <NEWLINE> <INDENT> dic [ i - a_lst [ i ] ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ i - a_lst [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if j + a_lst [ j ] in dic : <NEWLINE> <INDENT> cnt += dic [ j + a_lst [ j ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <NL> <INDENT> sum = sum + A [ i - 1 ] <NEWLINE> ans = ( ans + sum * A [ i ] ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> A [ i ] . append ( H [ i - 1 ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ a ] . append ( H [ b - 1 ] ) <NEWLINE> A [ b ] . append ( H [ a - 1 ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if max ( A [ i ] ) == A [ i ] [ 0 ] and A [ i ] . count ( A [ i ] [ 0 ] ) < 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from functools import reduce <NEWLINE> from operator import xor <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> n = int ( readline ( ) ) <NEWLINE> a = tuple ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> s = reduce ( xor , a [ 1 : ] , a [ 0 ] ) <NEWLINE> <COMMENT> <NL> b = tuple ( str ( s ^ v ) for v in a ) <NEWLINE> print ( <STRING> . join ( b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v = [ ] <NEWLINE> before = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i != before : v . append ( i ) <NEWLINE> before = i <NEWLINE> <DEDENT> money = 1000 <NEWLINE> stack = 0 <NEWLINE> if len ( v ) != 1 : <NEWLINE> <INDENT> if v [ 0 ] < v [ 1 ] : <NEWLINE> <INDENT> buy_point = [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> buy_point = [ 0 ] <NEWLINE> <DEDENT> for i in range ( 1 , len ( v ) - 1 ) : <NEWLINE> <INDENT> if v [ i - 1 ] < v [ i ] < v [ i + 1 ] : <NEWLINE> <INDENT> buy_point . append ( 2 ) <NEWLINE> <DEDENT> elif v [ i - 1 ] > v [ i ] > v [ i + 1 ] : <NEWLINE> <INDENT> buy_point . append ( 0 ) <NEWLINE> <DEDENT> elif v [ i - 1 ] < v [ i ] and v [ i ] > v [ i + 1 ] : <NEWLINE> <INDENT> buy_point . append ( - 1 ) <NEWLINE> <DEDENT> elif v [ i - 1 ] > v [ i ] and v [ i ] < v [ i + 1 ] : <NEWLINE> <INDENT> buy_point . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if v [ - 2 ] < v [ - 1 ] : <NEWLINE> <INDENT> buy_point . append ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> buy_point . append ( 0 ) <NEWLINE> <NL> <DEDENT> for ( i , j ) in zip ( v , buy_point ) : <NEWLINE> <INDENT> if j == 1 : <NEWLINE> <INDENT> stack += money // i <NEWLINE> money = money % i <NEWLINE> <DEDENT> elif j == - 1 : <NEWLINE> <INDENT> money += stack * i <NEWLINE> stack = 0 <NEWLINE> <DEDENT> elif j == 2 : <NEWLINE> <INDENT> stack += money // i <NEWLINE> money = money % i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( money ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> R = i + a [ i ] <NEWLINE> if not R in x : <NEWLINE> <INDENT> x [ R ] = 1 <NEWLINE> <DEDENT> else : x [ R ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> L = i - a [ i ] <NEWLINE> if L in x : <NEWLINE> <INDENT> ans += x [ L ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b , w = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> a , b = a - v * t , b - w * t <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if a <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a , b = a + v * t , b + w * t <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if a >= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> from collections import * <NEWLINE> D = deque ( S ) <NEWLINE> count = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> * Q , = input ( ) . split ( ) <NEWLINE> if len ( Q ) == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( count + int ( Q [ 1 ] ) ) % 2 : <NEWLINE> <INDENT> D . appendleft ( Q [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D . append ( Q [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = <STRING> . join ( D ) <NEWLINE> print ( ans [ : : - 1 ] if count % 2 else ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> N = 1 <NEWLINE> <NL> if 0 in lis : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> N *= lis [ i ] <NEWLINE> if N > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( N ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> c = { i for i in a } <NEWLINE> <NL> if len ( a ) == len ( c ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . gcd ( a , b ) , a * b // math . gcd ( a , b ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
class Forest : <NEWLINE> <INDENT> def __init__ ( self , g , id ) : <NEWLINE> <INDENT> self . forest = set ( [ id ] ) <NEWLINE> self . graph = g <NEWLINE> self . next_wait = self . graph [ id ] <NEWLINE> self . wait = 0 <NEWLINE> <DEDENT> def add_tree ( self , id ) : <NEWLINE> <INDENT> self . wait += self . next_wait [ id ] <NEWLINE> self . forest . update ( [ id ] ) <NEWLINE> <NL> self . marge_next_wait ( id ) <NEWLINE> <DEDENT> def next_tree ( self ) : <NEWLINE> <INDENT> min_id = min_wait = None <NEWLINE> for id , wait in self . next_wait . items ( ) : <NEWLINE> <INDENT> if id not in self . forest : <NEWLINE> <INDENT> if min_wait == None or min_wait > wait : <NEWLINE> <INDENT> min_wait = wait <NEWLINE> min_id = id <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return min_id <NEWLINE> <DEDENT> def marge_next_wait ( self , merge_id ) : <NEWLINE> <INDENT> for id , wait in self . graph [ merge_id ] . items ( ) : <NEWLINE> <INDENT> if id not in self . next_wait or self . next_wait [ id ] > wait : <NEWLINE> <INDENT> self . next_wait [ id ] = wait <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> g = [ { e : i for e , i in enumerate ( map ( int , input ( ) . split ( ) ) ) if i != - 1 } for _ in range ( n ) ] <NEWLINE> forest = Forest ( g , 0 ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> id = forest . next_tree ( ) <NEWLINE> forest . add_tree ( id ) <NEWLINE> <DEDENT> print ( forest . wait ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n == 1 or n == 2 or n == 3 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> while n > 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 2 , 10 ) : <NEWLINE> <INDENT> if n == i ** j : <NEWLINE> <INDENT> print ( n ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> n -= 1 <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> table = [ 0 for i in range ( 2019 ) ] <NEWLINE> table [ 0 ] = 1 <NEWLINE> num = 0 <NEWLINE> d = 1 <NEWLINE> for c in s [ : : - 1 ] : <NEWLINE> <INDENT> num += ( int ( c ) * d ) <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> table [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in table : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from itertools import combinations <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> items = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] , dtype = np . int32 ) <NEWLINE> all_book = [ i for i in range ( N ) ] <NEWLINE> out = 10 ** 18 <NEWLINE> <COMMENT> <NL> for num in range ( 1 , N + 1 ) : <COMMENT> <NEWLINE> <INDENT> for t in combinations ( all_book , num ) : <COMMENT> <NEWLINE> <INDENT> book_buy = np . array ( t , dtype = int ) <NEWLINE> understand_now = items [ book_buy ] <NEWLINE> tmp = np . sum ( understand_now , axis = 0 ) <NEWLINE> if np . all ( tmp [ 1 : ] >= X ) : <NEWLINE> <INDENT> out = min ( out , tmp [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if out == 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( out ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ K + i ] > A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> <NL> ans = None <NEWLINE> a_max = None <NEWLINE> <NL> for _x in range ( 1 ) : <NEWLINE> <INDENT> x = min ( ( B - 1 ) , N ) * ( _x + 1 ) <NEWLINE> if x > N : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> a = x / B - int ( x / B ) <NEWLINE> <COMMENT> <NL> sa = int ( a * A ) <NEWLINE> <COMMENT> <NL> if a_max == None : <NEWLINE> <INDENT> a_max = sa <NEWLINE> <DEDENT> elif sa > a_max : <NEWLINE> <INDENT> a_max = sa <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a_max ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> FizzBuzz_sum_list = [ 0 , 1 , 3 , 3 , 7 , 7 , 7 , 14 , 22 , 22 , 22 , 33 , 33 , 46 , 60 ] <NEWLINE> FizzBuzz_num_list = [ 0 , 1 , 2 , 2 , 3 , 3 , 3 , 4 , 5 , 5 , 5 , 6 , 6 , 7 , 8 ] <NEWLINE> <NL> answer = 60 * pow ( N // 15 , 2 ) + FizzBuzz_sum_list [ N % 15 ] + 15 * ( N // 15 ) * FizzBuzz_num_list [ N % 15 ] <NEWLINE> <NL> print ( answer ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = [ 0 ] <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A += B <NEWLINE> <COMMENT> <NL> <NL> sig = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> sig [ A [ i + 1 ] - 1 ] += 1 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> for i in sig : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = 0 <NEWLINE> if a >= k : <NEWLINE> <INDENT> s = k <NEWLINE> <DEDENT> elif a + b >= k : <NEWLINE> <INDENT> s = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = a - ( k - a - b ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
import bisect <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> A [ i ] += A [ i - 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , M ) : <NEWLINE> <INDENT> B [ i ] += B [ i - 1 ] <NEWLINE> <NL> <DEDENT> V = 0 <NEWLINE> ACount = bisect . bisect_right ( A , K ) <NEWLINE> if ACount != 0 : <NEWLINE> <INDENT> V = K - A [ ACount - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> V = K <NEWLINE> <NL> <DEDENT> AInitial = ACount <NEWLINE> <NL> BCount = bisect . bisect_right ( B , V ) <NEWLINE> final = ACount + BCount <NEWLINE> <NL> for i in range ( 1 , AInitial ) : <NEWLINE> <INDENT> V = K - A [ AInitial - 1 - i ] <NEWLINE> BCount = bisect . bisect_right ( B , V ) <NEWLINE> final = max ( final , AInitial - i + BCount ) <NEWLINE> <NL> <DEDENT> final = max ( final , bisect . bisect_right ( B , K ) ) <NEWLINE> print ( final ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> RGB = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if ( k >= N ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( S [ i ] != S [ j ] ) & ( S [ j ] != S [ k ] ) & ( S [ i ] != S [ k ] ) : <NEWLINE> <INDENT> RGB -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( RGB ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for data in sys . stdin : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 = map ( float , data . split ( ) ) <NEWLINE> a1 = x2 - x1 <NEWLINE> b1 = y2 - y1 <NEWLINE> a2 = x3 - x1 <NEWLINE> b2 = y3 - y1 <NEWLINE> px = ( b2 * ( a1 * a1 + b1 * b1 ) - b1 * ( a2 * a2 + b2 * b2 ) ) / ( 2 * ( a1 * b2 - a2 * b1 ) ) <NEWLINE> py = ( a1 * ( a2 * a2 + b2 * b2 ) - a2 * ( a1 * a1 + b1 * b1 ) ) / ( 2 * ( a1 * b2 - a2 * b1 ) ) <NEWLINE> r = math . sqrt ( px * px + py * py ) <NEWLINE> px += x1 <NEWLINE> py += y1 <NEWLINE> print ( <STRING> . format ( px , py , r ) ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A + ( A + B - K ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def update ( index , n ) : <NEWLINE> <INDENT> targ [ index ] = n <NEWLINE> index = ( index - 1 ) // 2 <NEWLINE> while True : <NEWLINE> <INDENT> targ [ index ] = min ( targ [ index * 2 + 1 ] , targ [ index * 2 + 2 ] ) <NEWLINE> if index <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> index = ( index - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( i , e , node , inode , enode ) : <NEWLINE> <COMMENT> <NL> <INDENT> if inode > e or enode < i : <NEWLINE> <INDENT> return float ( <STRING> ) <NEWLINE> <DEDENT> elif ( i <= inode and enode <= e ) or inode == enode : <NEWLINE> <INDENT> return targ [ node ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> irange = find ( i , e , 2 * node + 1 , inode , ( inode + enode ) // 2 ) <NEWLINE> erange = find ( i , e , 2 * node + 2 , ( inode + enode ) // 2 + 1 , enode ) <NEWLINE> return min ( irange , erange ) <NEWLINE> <NL> <DEDENT> <DEDENT> num , query = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> initial = 2147483647 <NEWLINE> ln = 2 ** math . ceil ( math . log2 ( num ) ) - 1 <NEWLINE> if num == 1 : <NEWLINE> <INDENT> tail = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tail = 2 ** math . ceil ( math . log2 ( num ) ) - num <NEWLINE> <DEDENT> global targ <NEWLINE> targ = [ initial ] * ( ln + num + tail ) <NEWLINE> <NL> for q in range ( query ) : <NEWLINE> <COMMENT> <NL> <INDENT> temp = [ int ( n ) for n in input ( ) . split ( <STRING> ) ] <NEWLINE> if temp [ 0 ] == 0 : <NEWLINE> <INDENT> update ( temp [ 1 ] + ln , temp [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( find ( temp [ 1 ] , temp [ 2 ] , 0 , 0 , ln ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , sys . stdin . readline ( ) . rsplit ( ) ) ) for _ in range ( H ) ] <NEWLINE> <NL> res = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if A [ i ] [ j ] % 2 != 0 and j < W - 1 : <NEWLINE> <INDENT> A [ i ] [ j ] -= 1 <NEWLINE> A [ i ] [ j + 1 ] += 1 <NEWLINE> res . append ( [ i + 1 , j + 1 , i + 1 , j + 2 ] ) <NEWLINE> <DEDENT> elif A [ i ] [ j ] % 2 != 0 and i != H - 1 and j == W - 1 : <NEWLINE> <INDENT> A [ i ] [ j ] -= 1 <NEWLINE> A [ i + 1 ] [ j ] += 1 <NEWLINE> res . append ( [ i + 1 , j + 1 , i + 2 , j + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( res ) ) <NEWLINE> for i in range ( len ( res ) ) : <NEWLINE> <INDENT> print ( * res [ i ] ) <NEWLINE> <DEDENT>
r = <STRING> <NEWLINE> str = input ( ) <NEWLINE> for c in str : <NEWLINE> <INDENT> r = c + r <NEWLINE> <NL> <DEDENT> print ( r ) <NEWLINE>
<NL> <COMMENT> <NL> <COMMENT> <NL> <NL> from __future__ import division , print_function <NEWLINE> <NL> import os , sys <NEWLINE> from io import BytesIO , IOBase <NEWLINE> <NL> if sys . version_info [ 0 ] < 3 : <NEWLINE> <INDENT> from __builtin__ import xrange as range <NEWLINE> from future_builtins import ascii , filter , hex , map , oct , zip <NEWLINE> <NL> <NL> <DEDENT> def ii ( ) : return int ( input ( ) ) <NEWLINE> def si ( ) : return input ( ) <NEWLINE> def mi ( ) : return map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> def msi ( ) : return map ( str , input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> def li ( ) : return list ( mi ( ) ) <NEWLINE> <NL> def dmain ( ) : <NEWLINE> <INDENT> sys . setrecursionlimit ( 1000000 ) <NEWLINE> threading . stack_size ( 1024000 ) <NEWLINE> thread = threading . Thread ( target = main ) <NEWLINE> thread . start ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> abc = <STRING> <NEWLINE> abd = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 , <STRING> : 3 , <STRING> : 4 , <STRING> : 5 , <STRING> : 6 , <STRING> : 7 , <STRING> : 8 , <STRING> : 9 , <STRING> : 10 , <STRING> : 11 , <STRING> : 12 , <STRING> : 13 , <STRING> : 14 , <STRING> : 15 , <STRING> : 16 , <STRING> : 17 , <STRING> : 18 , <STRING> : 19 , <STRING> : 20 , <STRING> : 21 , <STRING> : 22 , <STRING> : 23 , <STRING> : 24 , <STRING> : 25 } <NEWLINE> mod = 1000000007 <NEWLINE> <COMMENT> <NL> inf = float ( <STRING> ) <NEWLINE> vow = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> dx , dy = [ - 1 , 1 , 0 , 0 ] , [ 0 , 0 , 1 , - 1 ] <NEWLINE> def getKey ( item ) : return item [ 1 ] <NEWLINE> def sort2 ( l ) : return sorted ( l , key = getKey , reverse = True ) <NEWLINE> def d2 ( n , m , num ) : return [ [ num for x in range ( m ) ] for y in range ( n ) ] <NEWLINE> def isPowerOfTwo ( x ) : return ( x and ( not ( x & ( x - 1 ) ) ) ) <NEWLINE> def decimalToBinary ( n ) : return bin ( n ) . replace ( <STRING> , <STRING> ) <NEWLINE> def ntl ( n ) : return [ int ( i ) for i in str ( n ) ] <NEWLINE> def ncr ( n , r ) : return factorial ( n ) // ( factorial ( r ) * factorial ( max ( n - r , 1 ) ) ) <NEWLINE> <NL> def ceil ( x , y ) : <NEWLINE> <INDENT> if x % y == 0 : <NEWLINE> <INDENT> return x // y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return x // y + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def powerMod ( x , y , p ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> x %= p <NEWLINE> while y > 0 : <NEWLINE> <INDENT> if y & 1 : <NEWLINE> <INDENT> res = ( res * x ) % p <NEWLINE> <DEDENT> y = y >> 1 <NEWLINE> x = ( x * x ) % p <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def gcd ( x , y ) : <NEWLINE> <INDENT> while y : <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def isPrime ( n ) : <COMMENT> <NEWLINE> <INDENT> if ( n <= 1 ) : return False <NEWLINE> if ( n <= 3 ) : return True <NEWLINE> if ( n % 2 == 0 or n % 3 == 0 ) : return False <NEWLINE> i = 5 <NEWLINE> while ( i * i <= n ) : <NEWLINE> <INDENT> if ( n % i == 0 or n % ( i + 2 ) == 0 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i = i + 6 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <NL> <NL> <DEDENT> def read ( ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdout = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <INDENT> n = ii ( ) <NEWLINE> <NL> r = n % 1000 <NEWLINE> <NL> r = ( 1000 - r ) % 1000 <NEWLINE> <NL> <NL> print ( r ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> BUFSIZE = 8192 <NEWLINE> <NL> <NL> class FastIO ( IOBase ) : <NEWLINE> <INDENT> newlines = 0 <NEWLINE> <NL> def __init__ ( self , file ) : <NEWLINE> <INDENT> self . _fd = file . fileno ( ) <NEWLINE> self . buffer = BytesIO ( ) <NEWLINE> self . writable = <STRING> in file . mode or <STRING> not in file . mode <NEWLINE> self . write = self . buffer . write if self . writable else None <NEWLINE> <NL> <DEDENT> def read ( self ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) <NEWLINE> if not b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ptr = self . buffer . tell ( ) <NEWLINE> self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) <NEWLINE> <DEDENT> self . newlines = 0 <NEWLINE> return self . buffer . read ( ) <NEWLINE> <NL> <DEDENT> def readline ( self ) : <NEWLINE> <INDENT> while self . newlines == 0 : <NEWLINE> <INDENT> b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) <NEWLINE> self . newlines = b . count ( <STRING> ) + ( not b ) <NEWLINE> ptr = self . buffer . tell ( ) <NEWLINE> self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) <NEWLINE> <DEDENT> self . newlines -= 1 <NEWLINE> return self . buffer . readline ( ) <NEWLINE> <NL> <DEDENT> def flush ( self ) : <NEWLINE> <INDENT> if self . writable : <NEWLINE> <INDENT> os . write ( self . _fd , self . buffer . getvalue ( ) ) <NEWLINE> self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class IOWrapper ( IOBase ) : <NEWLINE> <INDENT> def __init__ ( self , file ) : <NEWLINE> <INDENT> self . buffer = FastIO ( file ) <NEWLINE> self . flush = self . buffer . flush <NEWLINE> self . writable = self . buffer . writable <NEWLINE> self . write = lambda s : self . buffer . write ( s . encode ( <STRING> ) ) <NEWLINE> self . read = lambda : self . buffer . read ( ) . decode ( <STRING> ) <NEWLINE> self . readline = lambda : self . buffer . readline ( ) . decode ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def print ( * args , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> sep , file = kwargs . pop ( <STRING> , <STRING> ) , kwargs . pop ( <STRING> , sys . stdout ) <NEWLINE> at_start = True <NEWLINE> for x in args : <NEWLINE> <INDENT> if not at_start : <NEWLINE> <INDENT> file . write ( sep ) <NEWLINE> <DEDENT> file . write ( str ( x ) ) <NEWLINE> at_start = False <NEWLINE> <DEDENT> file . write ( kwargs . pop ( <STRING> , <STRING> ) ) <NEWLINE> if kwargs . pop ( <STRING> , False ) : <NEWLINE> <INDENT> file . flush ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if sys . version_info [ 0 ] < 3 : <NEWLINE> <INDENT> sys . stdin , sys . stdout = FastIO ( sys . stdin ) , FastIO ( sys . stdout ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) <NEWLINE> <NL> <DEDENT> input = lambda : sys . stdin . readline ( ) . rstrip ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> main ( ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for N in range ( 1000 ) : <NEWLINE> <INDENT> tgt = str ( N ) . zfill ( 3 ) <NEWLINE> if tgt [ 0 ] in s : <NEWLINE> <INDENT> i = s . index ( tgt [ 0 ] ) <NEWLINE> if tgt [ 1 ] in s [ i + 1 : ] : <NEWLINE> <INDENT> j = s [ i + 1 : ] . index ( tgt [ 1 ] ) + i <NEWLINE> if tgt [ 2 ] in s [ j + 2 : ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> from bisect import bisect_left <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( N - 2 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , N - 1 ) : <NEWLINE> <INDENT> x = bisect_left ( L , L [ a ] + L [ b ] , lo = b ) <NEWLINE> ans += ( x - 1 - b ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> import sys <NEWLINE> <NL> H , W , M , * hw = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> h = hw [ : : 2 ] <NEWLINE> w = hw [ 1 : : 2 ] <NEWLINE> <NL> hw_set = set ( ( hi , wi ) for hi , wi in zip ( h , w ) ) <NEWLINE> <NL> <NL> raw_count = Counter ( h ) . most_common ( ) <NEWLINE> col_count = Counter ( w ) . most_common ( ) <NEWLINE> <NL> <NL> raw_max = raw_count [ 0 ] [ 1 ] <NEWLINE> col_max = col_count [ 0 ] [ 1 ] <NEWLINE> <NL> ans = 0 <NEWLINE> for hi , rcount in raw_count : <NEWLINE> <INDENT> if rcount < raw_max : break <NEWLINE> for wi , ccount in col_count : <NEWLINE> <INDENT> if ccount < col_max : break <NEWLINE> <NL> if ( hi , wi ) in hw_set : <NEWLINE> <INDENT> ans = raw_max + col_max - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( raw_max + col_max ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> s3 = [ ] <NEWLINE> <NL> s = list ( input ( ) ) <NEWLINE> <NL> s1 = s <NEWLINE> <NL> <NL> s2 = s1 [ K - 1 ] <NEWLINE> <NL> s3 = s2 . lower ( ) <NEWLINE> <NL> s1 [ K - 1 ] = s3 <NEWLINE> <NL> print ( <STRING> . join ( s1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( str ( input ( ) ) ) <NEWLINE> <NL> <NL> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < n and s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> R = 0 <NEWLINE> G = 0 <NEWLINE> B = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> R = R + 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> G = G + 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> B = B + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( R * G * B - c ) <NEWLINE> <NL>
def resolve ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> query = int ( input ( ) ) <NEWLINE> r = 0 <NEWLINE> left = <STRING> <NEWLINE> for i in range ( query ) : <NEWLINE> <INDENT> q = input ( ) <NEWLINE> if q [ 0 ] == <STRING> : <NEWLINE> <INDENT> _ , f , c = q . split ( ) <NEWLINE> if ( int ( f ) + r ) % 2 == 0 : <NEWLINE> <INDENT> s += c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left += c <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> r = ( r + 1 ) % 2 <NEWLINE> <DEDENT> <DEDENT> print ( left [ : : - 1 ] + s if r == 0 else s [ : : - 1 ] + left ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> lists = [ ] <NEWLINE> x = abs ( x ) <NEWLINE> <NL> step = int ( x / d ) <NEWLINE> <NL> if step >= k : <NEWLINE> <INDENT> answer = x - k * d <NEWLINE> <DEDENT> elif step < k : <NEWLINE> <INDENT> k_left = k - int ( step ) <NEWLINE> if k_left % 2 == 0 : <NEWLINE> <INDENT> answer = x % d <NEWLINE> <DEDENT> if k_left % 2 == 1 : <NEWLINE> <INDENT> answer = abs ( x - step * d - d ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp += A [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> tmp -= A [ i ] <NEWLINE> ans += A [ i ] * tmp % ( 10 ** 9 + 7 ) <NEWLINE> ans %= ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> nvertices , nedges , s = map ( int , input ( ) . split ( ) ) <NEWLINE> Adj = [ [ ] for i in range ( nvertices ) ] <NEWLINE> for i in range ( nedges ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> Adj [ u ] . append ( ( v , w ) ) <NEWLINE> <NL> <DEDENT> Q = [ ( 0 , s ) ] <NEWLINE> d = [ float ( <STRING> ) ] * nvertices <NEWLINE> d [ s ] = 0 <NEWLINE> while Q : <NEWLINE> <INDENT> w , u = heapq . heappop ( Q ) <NEWLINE> if d [ u ] < w : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for v , cost in Adj [ u ] : <NEWLINE> <INDENT> if d [ u ] + cost < d [ v ] : <NEWLINE> <INDENT> d [ v ] = d [ u ] + cost <NEWLINE> heapq . heappush ( Q , ( d [ v ] , v ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for cost in d : <NEWLINE> <INDENT> if math . isinf ( cost ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cost ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if k <= a : <NEWLINE> <INDENT> ans = k <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a + ( - 1 ) * ( k - a - b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> print ( sum ( math . gcd ( math . gcd ( a , b ) , c ) for a in range ( 1 , K + 1 ) for b in range ( 1 , K + 1 ) for c in ( range ( 1 , K + 1 ) ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> N , M , K = [ int ( s ) for s in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> n = 0 <NEWLINE> A = [ 0 ] <NEWLINE> for s in sys . stdin . readline ( ) . split ( ) : <NEWLINE> <INDENT> n = n + int ( s ) <NEWLINE> A . append ( n ) <NEWLINE> <NL> <DEDENT> n = 0 <NEWLINE> B = [ 0 ] <NEWLINE> for s in sys . stdin . readline ( ) . split ( ) : <NEWLINE> <INDENT> n = n + int ( s ) <NEWLINE> B . append ( n ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if A [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( M , - 1 , - 1 ) : <NEWLINE> <INDENT> if A [ i ] + B [ j ] <= K : <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> M = j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> if A [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if l [ i + 1 ] < l [ i ] : <NEWLINE> <INDENT> ans += l [ i ] - l [ i + 1 ] <NEWLINE> l [ i + 1 ] = l [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def ip ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> [ n , k ] = ip ( ) <NEWLINE> arr = ip ( ) <NEWLINE> s = 0 <NEWLINE> e = k <NEWLINE> u = n - k <NEWLINE> while u : <NEWLINE> <INDENT> if arr [ s ] < arr [ e ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> s += 1 <NEWLINE> u -= 1 <NEWLINE> e += 1 <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> A . append ( a ) <NEWLINE> <NL> <DEDENT> B = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> b = input ( ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> idx = [ 0 , 0 ] <NEWLINE> while True : <NEWLINE> <INDENT> if idx [ 0 ] == N - 1 and idx [ 1 ] == N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if A [ idx [ 0 ] ] [ idx [ 1 ] ] == B [ 0 ] [ 0 ] : <NEWLINE> <INDENT> check = False <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> if 0 <= idx [ 0 ] + i < N and 0 <= idx [ 1 ] + j < N : <NEWLINE> <INDENT> if A [ idx [ 0 ] + i ] [ idx [ 1 ] + j ] != B [ i ] [ j ] : <NEWLINE> <INDENT> check = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> check = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if check : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if not check : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if idx [ 1 ] < N - 1 : <NEWLINE> <INDENT> idx [ 1 ] += 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx [ 0 ] += 1 <NEWLINE> idx [ 1 ] = 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT> if A [ - 1 ] [ - 1 ] == B [ 0 ] [ 0 ] and M == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> THP = A <NEWLINE> AHP = C <NEWLINE> while ( True ) : <NEWLINE> <COMMENT> <NL> <INDENT> AHP -= B <NEWLINE> if ( AHP <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> THP -= D <NEWLINE> if ( THP <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
L , R , d = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> temp = num <NEWLINE> ans = 1 <NEWLINE> while temp > 10 : <NEWLINE> <INDENT> temp %= 10 <NEWLINE> <COMMENT> <NL> <DEDENT> if temp in [ 1 , 3 , 7 , 9 ] : <NEWLINE> <INDENT> sa = 7 <NEWLINE> while True : <NEWLINE> <INDENT> if sa % num == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sa *= 10 <NEWLINE> sa += 7 <NEWLINE> sa %= num <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = input ( ) . split ( ) <NEWLINE> ans = 1 <NEWLINE> d = 1 ; <NEWLINE> e = 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> e = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * int ( s [ i ] ) <NEWLINE> if ans > np . power ( 10 , 18 ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> break ; <NEWLINE> <NL> <DEDENT> <DEDENT> if d == 0 and e == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif e == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
from itertools import chain , combinations <NEWLINE> <NL> def power_set ( x ) : <NEWLINE> <INDENT> return chain . from_iterable ( combinations ( x , r ) for r in range ( len ( x ) + 1 ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = input ( ) <NEWLINE> <COMMENT> <NL> A = list ( map ( int , A . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> m = input ( ) <NEWLINE> ms = list ( map ( int , m . split ( ) ) ) <NEWLINE> powerset = power_set ( A ) <NEWLINE> sum_set = [ sum ( s ) for s in powerset if len ( s ) != 0 ] <NEWLINE> <NL> for m in ms : <NEWLINE> <INDENT> if m in sum_set : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A , B = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if A [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while B [ j ] > k - A [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> if n < b : <NEWLINE> <INDENT> m = math . floor ( a * n / b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e = b - 1 <NEWLINE> m = math . floor ( a * e / b ) <NEWLINE> <DEDENT> print ( m ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> for i in range ( K + 1 , N + 1 ) : <NEWLINE> <INDENT> print ( <STRING> if A [ i ] > A [ i - K ] else <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> for i in s : <NEWLINE> <NL> <INDENT> if i != s [ k - 1 ] : <NEWLINE> <INDENT> a . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * [ i for i in a ] , sep = <STRING> ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : break <NEWLINE> while b [ j ] > K - a [ i ] : j -= 1 <NEWLINE> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> input1 = input ( ) <NEWLINE> N = int ( input1 ) <NEWLINE> S = [ 0 ] * N <NEWLINE> result = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> input2 = input ( ) <NEWLINE> S [ i ] = str ( input2 ) <NEWLINE> <NL> <DEDENT> set_S = [ ] <NEWLINE> set_S = set ( S ) <NEWLINE> result = len ( set_S ) <NEWLINE> <NL> print ( result ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> print ( <STRING> . format ( a * b , 2 * a + 2 * b ) ) <NEWLINE>
n , * l = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> from heapq import * ; heapify ( l ) <NEWLINE> while len ( l ) > 1 : heappush ( l , heappop ( l ) * heappop ( l ) ) <NEWLINE> print ( [ l [ 0 ] , - 1 ] [ l [ 0 ] > 10 ** 18 ] ) <NEWLINE>
d , t , s = map ( int , input ( ) . split ( ) ) <NEWLINE> time = d / s <NEWLINE> if time <= t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> li [ a - 1 ] . append ( b ) <NEWLINE> li [ b - 1 ] . append ( a ) <NEWLINE> <DEDENT> ans = [ 0 ] * n <NEWLINE> a = [ [ ] for _ in range ( n ) ] <NEWLINE> d = deque ( [ 1 ] ) <NEWLINE> while len ( d ) > 0 : <NEWLINE> <INDENT> x = d . popleft ( ) <NEWLINE> if ans [ x - 1 ] == 0 : <NEWLINE> <INDENT> ans [ x - 1 ] += 1 <NEWLINE> for v in li [ x - 1 ] : <NEWLINE> <INDENT> if ans [ v - 1 ] == 0 : <NEWLINE> <INDENT> d . append ( v ) <NEWLINE> a [ v - 1 ] . append ( x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if sum ( ans ) == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( a [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = float ( input ( ) ) <NEWLINE> <NL> area = ( n * n ) * math . pi <NEWLINE> measure = ( n * 2 ) * math . pi <NEWLINE> <NL> print ( <STRING> . format ( area , measure ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> <NL> for i in range ( - 500 , 500 ) : <NEWLINE> <INDENT> for j in range ( - 500 , 500 ) : <NEWLINE> <INDENT> if x == i ** 5 - j ** 5 : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> import sys <NEWLINE> a = 0 <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> if len ( s ) == len ( t ) : <NEWLINE> <INDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in range ( len ( s ) - len ( t ) ) : <NEWLINE> <INDENT> b . append ( s [ i : len ( t ) + i ] ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> for j in range ( len ( b [ i ] ) ) : <NEWLINE> <INDENT> if b [ i ] [ j ] != t [ j ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> c . append ( a ) <NEWLINE> a = 0 <NEWLINE> <NL> <DEDENT> print ( min ( c ) ) <NEWLINE> <NL> <NL> <NL>
X = int ( input ( ) ) <NEWLINE> C = [ i ** 5 for i in range ( 120 ) ] <NEWLINE> <NL> a = 0 <NEWLINE> b = 0 <NEWLINE> <NL> for a in range ( len ( C ) ) : <NEWLINE> <INDENT> for b in range ( len ( C ) ) : <NEWLINE> <INDENT> if C [ a ] + C [ b ] == X : <NEWLINE> <INDENT> print ( a , - b ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> elif C [ a ] - C [ b ] == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> li_nq = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> li_px = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( ( q ) ) ] <NEWLINE> <NL> graph = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for i , j in li_nq : <NEWLINE> <INDENT> graph [ i ] . append ( j ) <NEWLINE> graph [ j ] . append ( i ) <NEWLINE> <NL> <DEDENT> ans = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> for i , j in li_px : <NEWLINE> <INDENT> ans [ i ] += j <NEWLINE> <NL> <DEDENT> check_list = [ None ] * ( n + 1 ) <NEWLINE> stack = [ 1 ] <NEWLINE> <NL> while stack : <NEWLINE> <INDENT> num = stack . pop ( ) <NEWLINE> for i in graph [ num ] : <NEWLINE> <INDENT> if check_list [ num ] == i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> stack . append ( i ) <NEWLINE> ans [ i ] += ans [ num ] <NEWLINE> check_list [ i ] = num <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * ans [ 1 : ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> right = A [ - 1 ] + 1 <NEWLINE> left = 0 <NEWLINE> flag = True <NEWLINE> mid = ( left + right ) // 2 <NEWLINE> minN = right <NEWLINE> result = mid <NEWLINE> while right - left > 1 and flag : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> count = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> count += ( i - 1 ) // mid <NEWLINE> <DEDENT> if count <= K : <NEWLINE> <INDENT> right = mid <NEWLINE> if minN > mid : <NEWLINE> <INDENT> minN = mid <NEWLINE> result = mid <NEWLINE> <DEDENT> <DEDENT> elif count > K : <NEWLINE> <INDENT> left = mid <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( h ) ] <NEWLINE> a = [ [ 0 ] * w for _ in range ( h ) ] <NEWLINE> cnt = 1 <NEWLINE> later = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if <STRING> not in s [ i ] : continue <NEWLINE> later . append ( i ) <NEWLINE> fst = True <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if not fst and s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if fst and s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> fst = False <NEWLINE> <DEDENT> a [ i ] [ j ] = cnt <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> for i in later : <NEWLINE> <INDENT> if i >= h - 1 : continue <NEWLINE> if a [ i + 1 ] [ 0 ] != 0 : continue <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> k = i <NEWLINE> while k < h - 1 : <NEWLINE> <INDENT> if a [ k + 1 ] [ j ] == 0 : <NEWLINE> <INDENT> a [ k + 1 ] [ j ] = a [ k ] [ j ] <NEWLINE> k += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if later [ 0 ] != 0 : <NEWLINE> <INDENT> for i in range ( later [ 0 ] , 0 , - 1 ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> a [ i - 1 ] [ j ] = a [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for ans in a : <NEWLINE> <INDENT> print ( * ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x == a ** 2 * b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> elif x >= a ** 2 * b / 2 : <NEWLINE> <INDENT> print ( 90 - math . degrees ( math . atan ( a ** 3 / ( 2 * a ** 2 * b - 2 * x ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> print ( ( 90 - math . degrees ( math . atan ( 2 * x / ( a * b ** 2 ) ) ) ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> matrix = [ [ ] for _ in range ( n ) ] <NEWLINE> col_sum = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> matrix [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> matrix [ i ] . append ( sum ( matrix [ i ] ) ) <NEWLINE> for j in range ( n + 1 ) : <NEWLINE> <INDENT> col_sum [ j ] += matrix [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> matrix . append ( col_sum ) <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( n + 1 ) : <NEWLINE> <INDENT> print ( <STRING> % matrix [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s_list = list ( str ( input ( ) ) ) <NEWLINE> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s_list [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif s_list [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = r * g * b <NEWLINE> <NL> for d in range ( 1 , n ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i + 2 * d >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s_list [ i ] != s_list [ i + d ] and s_list [ i ] != s_list [ i + 2 * d ] and s_list [ i + d ] != s_list [ i + 2 * d ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> allxor = 0 <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> allxor = allxor ^ a [ i ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans [ i ] = allxor ^ a [ i ] <NEWLINE> <DEDENT> ansstr = <STRING> . join ( map ( str , ans ) ) <NEWLINE> print ( ansstr ) <NEWLINE>
<NL> import random <NEWLINE> import copy <NEWLINE> import time <NEWLINE> def evaluateSatisfaction ( d , c , s , ans ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> last = [ - 1 for i in range ( 26 ) ] <NEWLINE> <NL> for i in range ( d ) : <NEWLINE> <NL> <INDENT> score += s [ i ] [ ans [ i ] ] <NEWLINE> last [ ans [ i ] ] = i <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> if j != ans [ i ] or True : <NEWLINE> <INDENT> score -= c [ j ] * ( i - last [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return score <NEWLINE> <NL> <DEDENT> def valuationFunction ( d , c , s , contestType , day , last ) : <NEWLINE> <NL> <INDENT> gain = s [ day ] [ contestType ] <NEWLINE> <COMMENT> <NL> lost = c [ contestType ] * ( 78 ) <NEWLINE> return gain - lost <NEWLINE> <NL> <DEDENT> def Input ( ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( d ) ] <NEWLINE> <COMMENT> <NL> return d , c , s <NEWLINE> <NL> <DEDENT> def evolution ( d , c , s , ans ) : <NEWLINE> <INDENT> score_before = evaluateSatisfaction ( d , c , s , ans ) <NEWLINE> ans_after = copy . copy ( ans ) <NEWLINE> <NL> idx1 = random . randint ( 0 , d - 1 ) <NEWLINE> idx2 = random . randint ( 0 , d - 1 ) <NEWLINE> <NL> tmp = ans_after [ idx1 ] <NEWLINE> ans_after [ idx1 ] = ans_after [ idx2 ] <NEWLINE> ans_after [ idx2 ] = tmp <NEWLINE> <NL> score_after = evaluateSatisfaction ( d , c , s , ans_after ) <NEWLINE> <NL> if score_after > score_before : <NEWLINE> <INDENT> return ans_after <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ans <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> d , c , s = Input ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> t1 = time . time ( ) <NEWLINE> ans = [ 0 for i in range ( d ) ] <NEWLINE> last = [ - 1 for i in range ( 26 ) ] <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> evalValueList = [ 0 for j in range ( 26 ) ] <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> evalValueList [ j ] = valuationFunction ( d , c , s , j , i , last ) <NEWLINE> <NL> <DEDENT> max_idx = 0 <NEWLINE> max = evalValueList [ 0 ] <NEWLINE> <NL> for j in range ( 26 ) : <NEWLINE> <INDENT> if ( max < evalValueList [ j ] ) : <NEWLINE> <INDENT> max_idx = j <NEWLINE> max = evalValueList [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans [ i ] = max_idx <NEWLINE> last [ ans [ i ] ] = i <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> t2 = time . time ( ) <NEWLINE> while ( float ( t2 - t1 ) < 1.0 ) : <NEWLINE> <INDENT> ans = evolution ( d , c , s , ans ) <NEWLINE> <COMMENT> <NL> t2 = time . time ( ) <NEWLINE> <DEDENT> for x in ans : <NEWLINE> <INDENT> print ( x + 1 ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> l = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> s = 0 <NEWLINE> m = 0 <NEWLINE> for li in l : <NEWLINE> <INDENT> s = max ( 0 , s + li ) <NEWLINE> m = max ( m , s ) <NEWLINE> <DEDENT> print ( m if m else max ( l ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> for a in range ( - 120 , 120 ) : <NEWLINE> <INDENT> for b in range ( - 120 , a ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( <STRING> . format ( a , b ) ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tmp = 1 <NEWLINE> A . sort ( ) <NEWLINE> <COMMENT> <NL> if A [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> tmp *= A [ i ] <NEWLINE> if tmp > 10 ** 18 : <NEWLINE> <INDENT> tmp = - 1 <NEWLINE> print ( tmp ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( tmp ) <NEWLINE>
from sys import stdin <NEWLINE> import math <NEWLINE> <NL> def GCD ( a , b ) : <NEWLINE> <INDENT> if ( a % b == 0 ) : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = a % b <NEWLINE> return GCD ( b , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> def LCM ( a , b ) : <NEWLINE> <INDENT> gcd = GCD ( a , b ) <NEWLINE> return int ( a * b / gcd ) <NEWLINE> <NL> <DEDENT> for line in stdin : <NEWLINE> <INDENT> a , b = line . split ( <STRING> ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> gcd = GCD ( a , b ) <NEWLINE> lcm = LCM ( a , b ) <NEWLINE> <NL> print ( str ( gcd ) + <STRING> + str ( lcm ) ) <NEWLINE> <NL> <NL> <DEDENT>
def input_one_number ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> D = input_one_number ( ) <NEWLINE> <NL> def input_multiple_number_as_list ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> c = input_multiple_number_as_list ( ) <NEWLINE> last = [ - 1 ] * 26 <NEWLINE> <NL> <NL> s = [ [ ] * 26 for _ in range ( D ) ] <NEWLINE> <NL> def dot ( day ) : <NEWLINE> <INDENT> k = [ 0 ] * 26 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> k [ i ] = c [ i ] * ( day + 1 - last [ i ] ) <NEWLINE> <DEDENT> return k <NEWLINE> <NL> <NL> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> s [ i ] = input_multiple_number_as_list ( ) <NEWLINE> <NL> <DEDENT> for day in range ( D ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> print ( day % 26 + 1 ) <NEWLINE> <NL> <DEDENT>
from math import factorial as fact <NEWLINE> import math <NEWLINE> import sys <NEWLINE> import itertools <NEWLINE> import numpy as np <NEWLINE> from collections import Counter <NEWLINE> import datetime <NEWLINE> <NL> <NL> <COMMENT> <NL> def input1 ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def input2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def input_array ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def keta ( N ) : <NEWLINE> <INDENT> return len ( str ( N ) ) <NEWLINE> <NL> <NL> <DEDENT> def input_daytime ( input_time ) : <NEWLINE> <INDENT> time , distance = input_time . split ( ) <NEWLINE> t = time . split ( <STRING> ) <NEWLINE> se = str ( t [ - 1 ] ) . split ( <STRING> ) <NEWLINE> dt1 = datetime . timedelta ( hours = int ( t [ 0 ] ) , minutes = int ( t [ 1 ] ) , seconds = int ( se [ 0 ] ) , milliseconds = int ( se [ 1 ] ) ) <NEWLINE> return dt1 <NEWLINE> <NL> <DEDENT> def combinations ( n , r ) : <NEWLINE> <INDENT> return list ( itertools . combinations ( range ( n ) , r ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> def all_sets ( num_list ) : <NEWLINE> <INDENT> subsets = [ ] <NEWLINE> for i in range ( 2 , len ( num_list ) + 1 ) : <NEWLINE> <INDENT> for c in combinations ( num_list , i ) : <NEWLINE> <INDENT> subsets . append ( c ) <NEWLINE> <DEDENT> <DEDENT> return subsets <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def ch ( x1 ) : <NEWLINE> <INDENT> cf = [ ] <NEWLINE> for i in range ( 2 , math . sqrt ( x1 ) + 1 ) : <NEWLINE> <INDENT> if x1 % i == 0 : <NEWLINE> <INDENT> cf . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return cf <NEWLINE> <NL> <DEDENT> def CountOneRoots ( x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> return fact ( x + y ) / fact ( x ) / fact ( y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> tmp = n <NEWLINE> count = 0 <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 2 ) : <NEWLINE> <INDENT> if tmp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while tmp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> tmp //= i <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if tmp != 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> return count <NEWLINE> <NL> <NL> <DEDENT> def fl ( a , b , x ) : <NEWLINE> <INDENT> b1 = x // b <NEWLINE> x = math . floor ( a * x / b ) <NEWLINE> y = math . floor ( b1 ) <NEWLINE> return x - y <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> a , b , n = input2 ( ) <NEWLINE> if b > n : <NEWLINE> <INDENT> b_ans = fl ( a , b , n ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> b_ans = fl ( a , b , b - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( 0 , n , b ) : <NEWLINE> <INDENT> ans = fl ( a , b , i ) <NEWLINE> <COMMENT> <NL> if ans > b_ans : <NEWLINE> <INDENT> b_ans = ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( b_ans ) <NEWLINE> <NL>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = [ <STRING> . join ( sorted ( list ( input ( ) ) ) ) for i in range ( N ) ] <NEWLINE> c = collections . Counter ( S ) <NEWLINE> print ( sum ( [ int ( x * ( x - 1 ) / 2 ) for x in c . values ( ) ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> min_num = p [ 0 ] <NEWLINE> for i in p : <NEWLINE> <INDENT> if i <= min_num : <NEWLINE> <INDENT> min_num = i <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> tmp = 0 <NEWLINE> length = [ ] <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> or s [ i ] == <STRING> or s [ i ] == <STRING> or s [ i ] == <STRING> : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> if i == len ( s ) - 1 : <NEWLINE> <INDENT> length . append ( tmp ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> length . append ( tmp ) <NEWLINE> tmp = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max ( length ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> for j in range ( 1 , 100 ) : <NEWLINE> <INDENT> for k in range ( 1 , 100 ) : <NEWLINE> <INDENT> b = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> if b <= n : <NEWLINE> <INDENT> a [ b - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> b = list ( set ( a ) ) <NEWLINE> m = len ( b ) <NEWLINE> <NL> p = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> for i in b : <NEWLINE> <INDENT> if p [ i ] == 0 : <NEWLINE> <INDENT> j = 2 <NEWLINE> while i * j <= 10 ** 6 : <NEWLINE> <INDENT> p [ i * j ] = 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> a . append ( - 1 ) <NEWLINE> a . insert ( 0 , - 1 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if a [ i ] != a [ i + 1 ] and a [ i ] != a [ i - 1 ] and p [ a [ i ] ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import ceil <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] , reverse = True ) <NEWLINE> left = 0 <NEWLINE> right = a [ 0 ] <NEWLINE> while right - left > 1 : <NEWLINE> <INDENT> ki = k <NEWLINE> mid = left + ( right - left ) // 2 <NEWLINE> for ai in a : <NEWLINE> <INDENT> if ki < 0 : <NEWLINE> <INDENT> left = mid <NEWLINE> break <NEWLINE> <DEDENT> if ai <= mid : <NEWLINE> <INDENT> right = mid <NEWLINE> break <NEWLINE> <DEDENT> ki -= ceil ( ai / mid ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ki < 0 : <NEWLINE> <INDENT> left = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( right ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A_list = list ( map ( lambda x : int ( x ) * ( - 1 ) , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( A_list ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> max_num = heapq . heappop ( A_list ) * ( - 1 ) <NEWLINE> heapq . heappush ( A_list , ( - 1 ) * ( max_num // 2 ) ) <NEWLINE> <DEDENT> print ( ( - 1 ) * sum ( A_list ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> <NL> def Prime_Factorize ( n ) : <NEWLINE> <INDENT> primes = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> n //= 2 <NEWLINE> primes . append ( 2 ) <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> n //= f <NEWLINE> primes . append ( f ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> primes . append ( n ) <NEWLINE> <DEDENT> return primes <NEWLINE> <NL> <DEDENT> Primes = Prime_Factorize ( N ) <NEWLINE> cnt = 0 <NEWLINE> for p in Primes : <NEWLINE> <INDENT> e = 1 <NEWLINE> z = p <NEWLINE> while ( N % z == 0 ) and ( N >= z ) : <NEWLINE> <INDENT> N //= z <NEWLINE> e += 1 <NEWLINE> z = p ** e <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> while N % p == 0 : <NEWLINE> <INDENT> N //= p <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if ( 0 in P ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P . sort ( ) <NEWLINE> <NL> mult = 1 <NEWLINE> for i in P : <NEWLINE> <INDENT> mult *= i <NEWLINE> if ( mult > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mult ) <NEWLINE> <DEDENT> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> B = sorted ( A ) <NEWLINE> mx = B [ - 1 ] <NEWLINE> second = B [ - 2 ] <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == mx : <NEWLINE> <INDENT> print ( second ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mx ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def solve ( N , K , As ) : <NEWLINE> <INDENT> ans = max ( As ) <NEWLINE> l , r = 1 , ans <NEWLINE> for _ in range ( 30 ) : <NEWLINE> <INDENT> m = ( l + r ) // 2 <NEWLINE> if m <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for A in As : <NEWLINE> <INDENT> cnt += math . ceil ( A / m ) - 1 <NEWLINE> <DEDENT> if cnt <= K : <NEWLINE> <INDENT> ans = min ( ans , m ) <NEWLINE> r = m - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = m + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> As = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> solve ( N , K , As ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for y in range ( x + 1 ) : <NEWLINE> <INDENT> for b in [ - 1 , 1 ] : <NEWLINE> <INDENT> c = x + y * b <NEWLINE> if a . count ( c ) == 0 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> now = 1 <NEWLINE> city = [ 1 ] <NEWLINE> city2 = { 1 } <NEWLINE> while count < K : <NEWLINE> <INDENT> count += 1 <NEWLINE> now = A [ now - 1 ] <NEWLINE> if now in city2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> city . append ( now ) <NEWLINE> city2 . add ( now ) <NEWLINE> <DEDENT> <DEDENT> if count == K : <NEWLINE> <INDENT> print ( now ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = city . index ( now ) <NEWLINE> K -= n <NEWLINE> count -= n <NEWLINE> K %= count <NEWLINE> print ( city [ n + K ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def cross ( c1 , c2 ) : <NEWLINE> <INDENT> return c1 . real * c2 . imag - c1 . imag * c2 . real <NEWLINE> <NL> <DEDENT> def cross_point ( p1 , p2 , p3 , p4 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> base = p4 - p3 <NEWLINE> hypo1 = p1 - p3 <NEWLINE> hypo2 = p2 - p3 <NEWLINE> d1 = cross ( base , hypo1 ) / abs ( base ) <NEWLINE> d2 = cross ( base , hypo2 ) / abs ( base ) <NEWLINE> cp = p1 + d1 / ( d1 - d2 ) * ( p2 - p1 ) <NEWLINE> return cp <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def _area_of_triangle ( c1 , c2 , c3 ) : <NEWLINE> <INDENT> v1 = c2 - c1 <NEWLINE> v2 = c3 - c1 <NEWLINE> return abs ( v1 . real * v2 . imag - v1 . imag * v2 . real ) / 2 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def convex_cut ( points , c1 , c2 ) : <NEWLINE> <INDENT> points . append ( points [ 0 ] ) <NEWLINE> ref_vec = c2 - c1 <NEWLINE> cross_point1 = None <NEWLINE> flag = 0 <NEWLINE> <COMMENT> <NL> for i , segment in enumerate ( zip ( points , points [ 1 : ] ) ) : <NEWLINE> <INDENT> p1 , p2 = segment <NEWLINE> cross1 = cross ( ref_vec , p1 - c1 ) <NEWLINE> cross2 = cross ( ref_vec , p2 - c1 ) <NEWLINE> flag += cross1 <NEWLINE> if cross1 <= 0 and cross2 > 0 : <NEWLINE> <INDENT> cross_point1 = cross_point ( c1 , c2 , p1 , p2 ) <NEWLINE> points = points [ i + 1 : ] <NEWLINE> break <NEWLINE> <DEDENT> elif cross1 > 0 and cross2 <= 0 : <NEWLINE> <INDENT> cross_point1 = cross_point ( c1 , c2 , p1 , p2 ) <NEWLINE> points = points [ i : : - 1 ] + points [ : i : - 1 ] <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if cross_point1 == None : <NEWLINE> <INDENT> if flag > 0 : <NEWLINE> <INDENT> cross_point1 = points [ 0 ] <NEWLINE> points = points [ 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> cut_area = 0 <NEWLINE> for p1 , p2 in zip ( points , points [ 1 : ] ) : <NEWLINE> <INDENT> if cross ( ref_vec , p1 - c1 ) * cross ( ref_vec , p2 - c1 ) <= 0 : <NEWLINE> <INDENT> cross_point2 = cross_point ( c1 , c2 , p1 , p2 ) <NEWLINE> cut_area += _area_of_triangle ( cross_point1 , cross_point2 , p1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cut_area += _area_of_triangle ( cross_point1 , p1 , p2 ) <NEWLINE> <DEDENT> <DEDENT> return cut_area <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> import sys <NEWLINE> <NL> file_input = sys . stdin <NEWLINE> <NL> n = int ( file_input . readline ( ) ) <NEWLINE> <NL> def string_to_complex ( s ) : <NEWLINE> <INDENT> x , y = map ( float , s . split ( ) ) <NEWLINE> return x + y * 1j <NEWLINE> <NL> <DEDENT> G = [ string_to_complex ( file_input . readline ( ) ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> q = int ( file_input . readline ( ) ) <NEWLINE> <NL> for line in file_input : <NEWLINE> <INDENT> p1x , p1y , p2x , p2y = map ( int , line . split ( ) ) <NEWLINE> p1 = p1x + p1y * 1j <NEWLINE> p2 = p2x + p2y * 1j <NEWLINE> ans = convex_cut ( G . copy ( ) , p1 , p2 ) <NEWLINE> print ( <STRING> . format ( ans ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N , i = map ( int , input ( ) . split ( ) ) <NEWLINE> if not ( 1 <= N <= 100 and 1 <= i <= N ) : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <NL> <DEDENT> print ( N - i + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> <NL> a_cnts = { } <NEWLINE> a_sum = 0 <NEWLINE> for an in a : <NEWLINE> <INDENT> if an in a_cnts . keys ( ) : <NEWLINE> <INDENT> a_cnts [ an ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_cnts [ an ] = 1 <NEWLINE> <DEDENT> a_sum += int ( an ) <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> ( b , c ) = input ( ) . split ( ) <NEWLINE> <NL> if b in a_cnts . keys ( ) : <NEWLINE> <INDENT> hit_cnt = a_cnts [ b ] <NEWLINE> del a_cnts [ b ] <NEWLINE> if c in a_cnts . keys ( ) : <NEWLINE> <INDENT> a_cnts [ c ] += hit_cnt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_cnts [ c ] = hit_cnt <NEWLINE> <DEDENT> a_sum += ( int ( c ) - int ( b ) ) * hit_cnt <NEWLINE> <NL> <DEDENT> print ( a_sum ) <NEWLINE> <DEDENT>
def gcd ( x , y ) : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> if y == 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> return gcd ( y , x % y ) <NEWLINE> <NL> <DEDENT> x , y = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( gcd ( x , y ) ) <NEWLINE>
A , B , C = input ( ) . split ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> first = <STRING> <NEWLINE> second = <STRING> <NEWLINE> f = 1 <NEWLINE> s = 1 <NEWLINE> nokori = K <NEWLINE> for i in range ( 1 , K ) : <NEWLINE> <INDENT> if int ( A ) < int ( B ) * f : <NEWLINE> <INDENT> first = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f *= 2 <NEWLINE> nokori -= 1 <NEWLINE> <DEDENT> <DEDENT> if int ( A ) < int ( B ) * f : <NEWLINE> <INDENT> first = <STRING> <NEWLINE> <DEDENT> if first == <STRING> : <NEWLINE> <INDENT> for o in range ( 1 , nokori + 1 ) : <NEWLINE> <INDENT> if int ( B ) * f < int ( C ) * s : <NEWLINE> <INDENT> second = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s *= 2 <NEWLINE> <DEDENT> <DEDENT> if int ( B ) * f < int ( C ) * s : <NEWLINE> <INDENT> second = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if first == <STRING> and second == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> int1 = lambda x : int ( x ) - 1 <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> T = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int1 , input ( ) . split ( ) ) <NEWLINE> T [ a ] . append ( b ) <NEWLINE> T [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> lst = [ 0 ] * N <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> lst [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> d = deque ( [ 0 ] ) <NEWLINE> visited = set ( ) <NEWLINE> while d : <NEWLINE> <INDENT> v = d . pop ( ) <NEWLINE> visited . add ( v ) <NEWLINE> for x in T [ v ] : <NEWLINE> <INDENT> if x not in visited : <NEWLINE> <INDENT> lst [ x ] += lst [ v ] <NEWLINE> d . append ( x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * lst ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> sys . setrecursionlimit ( 20000000 ) <NEWLINE> <NL> def yn ( b ) : <NEWLINE> <INDENT> print ( <STRING> if b == 1 else <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> def count_ones_by_bin ( num ) : <NEWLINE> <INDENT> bin_num = bin ( num ) [ 2 : ] <NEWLINE> count = 0 <NEWLINE> for i in bin_num : <NEWLINE> <INDENT> count += int ( i ) <NEWLINE> <DEDENT> return count <NEWLINE> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> readline = sys . stdin . readline <NEWLINE> <NL> n = int ( readline ( ) ) <NEWLINE> x = readline ( ) . rstrip ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> amr1 = [ 0 ] * ( ( 10 ** 5 ) * 2 + 5 ) <NEWLINE> amr2 = [ 0 ] * ( ( 10 ** 5 ) * 2 + 5 ) <NEWLINE> bits = [ False ] * ( ( 10 ** 5 ) * 2 + 5 ) <NEWLINE> pc = [ - 1 ] * ( ( 10 ** 5 ) * 2 + 5 ) <NEWLINE> bcnt = 0 <NEWLINE> j = 0 <NEWLINE> for i in x : <NEWLINE> <INDENT> if int ( i ) == 1 : <NEWLINE> <INDENT> bcnt += 1 <NEWLINE> bits [ j ] = True <NEWLINE> <DEDENT> j += 1 <NEWLINE> <NL> <DEDENT> base1 = 0 <NEWLINE> base2 = 0 <NEWLINE> ni1 = 1 <NEWLINE> ni2 = 1 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> i = n - 1 - j <NEWLINE> jo = n - i - 1 <NEWLINE> if j > 0 : <NEWLINE> <INDENT> ni1 *= 2 <NEWLINE> ni2 *= 2 <NEWLINE> <COMMENT> <NL> <DEDENT> ni1 = ni1 % ( bcnt + 1 ) <NEWLINE> amr1 [ i ] = ni1 <NEWLINE> if ( bcnt - 1 ) == 0 : <NEWLINE> <INDENT> amr2 [ i ] = 0 <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ni2 = ni2 % ( bcnt - 1 ) <NEWLINE> amr2 [ i ] = ni2 <NEWLINE> <DEDENT> if bits [ i ] == True : <NEWLINE> <INDENT> base1 += amr1 [ i ] <NEWLINE> base2 += amr2 [ i ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> if bits [ i ] == True : <COMMENT> <NEWLINE> <INDENT> if ( bcnt - 1 ) == 0 : <NEWLINE> <INDENT> base = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> base = ( base2 - amr2 [ i ] ) % ( bcnt - 1 ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> base = ( base1 + amr1 [ i ] ) % ( bcnt + 1 ) <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> while base > 0 : <NEWLINE> <INDENT> if pc [ base ] == - 1 : <NEWLINE> <INDENT> pc [ base ] = count_ones_by_bin ( base ) <NEWLINE> <DEDENT> base = base % pc [ base ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> if <STRING> not in globals ( ) : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
import math <NEWLINE> A , B , N = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> def tgt ( A , B , d ) : <NEWLINE> <INDENT> return math . floor ( A * d / B ) <NEWLINE> <NL> <DEDENT> if N >= B - 1 : <NEWLINE> <INDENT> d_max = B - 1 <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> d_max = N <NEWLINE> <NL> <DEDENT> ret = tgt ( A , B , d_max ) <NEWLINE> <NL> print ( ret ) <NEWLINE> <NL> <NL> <NL>
n , k , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + a <NEWLINE> p = 1 <NEWLINE> while k : <NEWLINE> <INDENT> if k % 2 : <NEWLINE> <INDENT> p = a [ p ] <NEWLINE> <DEDENT> a = [ a [ b ] for b in a ] <NEWLINE> k //= 2 <NEWLINE> <DEDENT> print ( p ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> <NL> X , N = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> P = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> l = [ i for i in range ( - 1 , 102 ) if i not in P ] <NEWLINE> abslist = list ( map ( lambda a : abs ( a - X ) , l ) ) <NEWLINE> print ( l [ abslist . index ( min ( abslist ) ) ] ) <NEWLINE>
import queue <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ [ ] for i in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab [ a - 1 ] . append ( b - 1 ) <NEWLINE> ab [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> q = queue . Queue ( ) <NEWLINE> q . put ( 0 ) <NEWLINE> ans = [ - 1 ] * n <NEWLINE> ans [ 0 ] = 0 <NEWLINE> while q : <NEWLINE> <INDENT> now = q . get ( ) <NEWLINE> for i , next in enumerate ( ab [ now ] ) : <NEWLINE> <INDENT> if ans [ next ] == - 1 : <NEWLINE> <INDENT> ans [ next ] = now + 1 <NEWLINE> q . put ( next ) <NEWLINE> <DEDENT> <DEDENT> if q . empty ( ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 10001 ) ] <NEWLINE> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> for j in range ( 1 , 100 ) : <NEWLINE> <INDENT> for k in range ( 1 , 100 ) : <NEWLINE> <INDENT> summ = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> if summ < 10001 : <NEWLINE> <INDENT> ans [ summ ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <COMMENT> <NL> <DEDENT>
<COMMENT> <NL> <NL> import itertools <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> X = [ i for i in range ( 1 , M + 1 ) ] <NEWLINE> <NL> for i in itertools . combinations_with_replacement ( X , r = N ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> j = list ( i ) <NEWLINE> for k in lis : <NEWLINE> <INDENT> if j [ k [ 1 ] - 1 ] - j [ k [ 0 ] - 1 ] == k [ 2 ] : <NEWLINE> <INDENT> cnt += k [ 3 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<STRING> <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> import math ; from collections import * <NEWLINE> import sys ; from functools import reduce <NEWLINE> import time ; from itertools import groupby <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> def get_ints ( ) : return map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> def get_list ( ) : return list ( get_ints ( ) ) <NEWLINE> def get_string ( ) : return list ( input ( ) . strip ( ) . split ( ) ) <NEWLINE> def printxsp ( * args ) : return print ( * args , end = <STRING> ) <NEWLINE> def printsp ( * args ) : return print ( * args , end = <STRING> ) <NEWLINE> <NL> <NL> DIRECTIONS = [ ( + 0 , + 1 ) , ( + 0 , - 1 ) , ( + 1 , + 0 ) , ( + 1 , - 1 ) ] <NEWLINE> NEIGHBOURS = [ ( - 1 , - 1 ) , ( - 1 , + 0 ) , ( - 1 , + 1 ) , ( + 0 , - 1 ) , ( + 1 , + 1 ) , ( + 1 , + 0 ) , ( + 1 , - 1 ) , ( + 0 , + 1 ) ] <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> n , x , m = get_ints ( ) <NEWLINE> prefix_sum = [ 0 ] <NEWLINE> found = set ( ) <NEWLINE> d = dict ( ) <NEWLINE> ind = 0 ; doneInd = 1 ; <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( x % m ) not in found : <NEWLINE> <INDENT> found . add ( x % m ) <NEWLINE> d [ x % m ] = i <NEWLINE> prefix_sum . append ( prefix_sum [ - 1 ] + ( x % m ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ind = d [ x % m ] <NEWLINE> doneInd = i <NEWLINE> break <NEWLINE> <DEDENT> x **= 2 <NEWLINE> x %= m <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> try : <NEWLINE> <INDENT> lastset = prefix_sum [ - 1 ] - prefix_sum [ ind ] ; <NEWLINE> offset = prefix_sum [ ind ] <NEWLINE> <NL> sz = len ( prefix_sum ) - ind - 1 <NEWLINE> <NL> rem = n - ind <NEWLINE> ans = offset <NEWLINE> ans += lastset * ( rem // sz ) <NEWLINE> ans += prefix_sum [ ind + ( rem % sz ) ] - offset <NEWLINE> <COMMENT> <NL> <DEDENT> except : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL>
import copy <NEWLINE> <NL> n , m , = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b , = map ( int , input ( ) . split ( ) ) <NEWLINE> p . append ( [ a - 1 , b - 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> height = copy . copy ( h ) <NEWLINE> for i in p : <NEWLINE> <INDENT> index0 = i [ 0 ] <NEWLINE> index1 = i [ 1 ] <NEWLINE> if h [ index0 ] < h [ index1 ] : <NEWLINE> <INDENT> height [ index0 ] = - 1 <NEWLINE> <DEDENT> elif h [ index0 ] > h [ index1 ] : <NEWLINE> <INDENT> height [ index1 ] = - 1 <NEWLINE> <DEDENT> elif h [ index0 ] == h [ index1 ] : <NEWLINE> <INDENT> height [ index0 ] = - 1 <NEWLINE> height [ index1 ] = - 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> ret = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if height [ i ] == h [ i ] : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( ret ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = input ( ) . split ( ) <NEWLINE> result = 1 <NEWLINE> <NL> A . sort ( ) <NEWLINE> fl = True <NEWLINE> <NL> if int ( A [ 0 ] ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> result *= int ( i ) <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> fl = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if fl : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import bisect <NEWLINE> import time <NEWLINE> <NL> start = time . time ( ) <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> c = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ 0 ] + [ [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> sch , held = [ 0 ] , [ [ 0 ] for _ in range ( 27 ) ] <NEWLINE> <NL> for d in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> SLvar = [ s [ d ] [ i ] + c [ i ] * ( d - held [ i ] [ - 1 ] ) for i in range ( 1 , 27 ) ] <NEWLINE> t = SLvar . index ( max ( SLvar ) ) + 1 <NEWLINE> sch . append ( t ) <NEWLINE> held [ t ] . append ( d ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 27 ) : <NEWLINE> <INDENT> held [ i ] . append ( D + 1 ) <NEWLINE> <NL> <DEDENT> s_sort = [ 0 ] + [ [ 0 ] + sorted ( [ [ s [ d ] [ i ] , i ] for i in range ( 1 , 27 ) ] , key = lambda x : x [ 0 ] , reverse = True ) for d in range ( 1 , D + 1 ) ] <NEWLINE> <NL> i , j = 1 , 1 <NEWLINE> while time . time ( ) - start < 1.8 and i <= D and j < 27 : <NEWLINE> <INDENT> d , q = i , s_sort [ i ] [ j ] [ 1 ] <NEWLINE> <NL> if sch [ d ] != q : <NEWLINE> <INDENT> SLvar = s [ d ] [ q ] - s [ d ] [ sch [ d ] ] <NEWLINE> <NL> ind_p = bisect . bisect_left ( held [ sch [ d ] ] , d ) <NEWLINE> k = d - held [ sch [ d ] ] [ ind_p - 1 ] <NEWLINE> l = held [ sch [ d ] ] [ ind_p + 1 ] - d <NEWLINE> SLvar -= c [ sch [ d ] ] * k * l <NEWLINE> <NL> ind_n = bisect . bisect_left ( held [ q ] , d ) <NEWLINE> k = d - held [ q ] [ ind_n - 1 ] <NEWLINE> l = held [ q ] [ ind_n ] - d <NEWLINE> SLvar += c [ q ] * k * l <NEWLINE> <NL> if SLvar > 0 : <NEWLINE> <INDENT> del held [ sch [ d ] ] [ ind_p ] <NEWLINE> held [ q ] . insert ( ind_n , d ) <NEWLINE> sch [ d ] = q <NEWLINE> <NL> <DEDENT> <DEDENT> i += 1 <NEWLINE> if i > D : <NEWLINE> <INDENT> i = 1 <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> print ( sch [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> from decimal import Decimal , ROUND_HALF_UP , ROUND_HALF_EVEN <NEWLINE> from collections import deque <NEWLINE> from bisect import bisect_left <NEWLINE> from itertools import product <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def LI2 ( N ) : return [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> <COMMENT> <NL> def LSI ( ) : return list ( map ( int , list ( sys . stdin . readline ( ) . rstrip ( ) ) ) ) <NEWLINE> def LSI2 ( N ) : return [ list ( map ( int , list ( sys . stdin . readline ( ) . rstrip ( ) ) ) ) for i in range ( N ) ] <NEWLINE> <COMMENT> <NL> def ST ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def LST ( ) : return sys . stdin . readline ( ) . rstrip ( ) . split ( ) <NEWLINE> def LST2 ( N ) : return [ sys . stdin . readline ( ) . rstrip ( ) . split ( ) for i in range ( N ) ] <NEWLINE> def FILL ( i , h ) : return [ i for j in range ( h ) ] <NEWLINE> def FILL2 ( i , h , w ) : return [ FILL ( i , w ) for j in range ( h ) ] <NEWLINE> def FILL3 ( i , h , w , d ) : return [ FILL2 ( i , w , d ) for j in range ( h ) ] <NEWLINE> def FILL4 ( i , h , w , d , d2 ) : return [ FILL3 ( i , w , d , d2 ) for j in range ( h ) ] <NEWLINE> def sisha ( num , digit ) : return Decimal ( str ( num ) ) . quantize ( Decimal ( digit ) , rounding = ROUND_HALF_UP ) <NEWLINE> <COMMENT> <NL> MOD = 1000000007 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> sys . setrecursionlimit ( 10 ** 6 + 10 ) <NEWLINE> <NL> from fractions import Fraction <NEWLINE> <NL> N = I ( ) <NEWLINE> cnt = { } <NEWLINE> pair = { } <NEWLINE> bothzero = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A , B = MI ( ) <NEWLINE> if A == 0 and B == 0 : <NEWLINE> <INDENT> bothzero += 1 <NEWLINE> <DEDENT> elif B == 0 : <NEWLINE> <INDENT> pair [ 0 ] = pair . get ( 0 , 0 ) + 1 <NEWLINE> <DEDENT> elif A == 0 : <NEWLINE> <INDENT> cnt [ 0 ] = cnt . get ( 0 , 0 ) + 1 <NEWLINE> <DEDENT> elif A / B > 0 : <NEWLINE> <INDENT> frac = Fraction ( A , B ) . as_integer_ratio ( ) <NEWLINE> <NL> cnt [ frac ] = cnt . get ( frac , 0 ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> frac = Fraction ( - B , A ) . as_integer_ratio ( ) <NEWLINE> pair [ frac ] = pair . get ( frac , 0 ) + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> res = N - bothzero <NEWLINE> ans = 1 <NEWLINE> for v in cnt : <NEWLINE> <INDENT> if pair . get ( v , 0 ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> res -= ( cnt [ v ] + pair [ v ] ) <NEWLINE> ans = ans * ( ( pow ( 2 , cnt [ v ] , MOD ) + pow ( 2 , pair [ v ] , MOD ) - 1 ) % MOD ) <NEWLINE> ans = ans % MOD <NEWLINE> <DEDENT> ans = ( ans * pow ( 2 , res , MOD ) - 1 ) % MOD <NEWLINE> ans = ( ans + bothzero ) % MOD <NEWLINE> print ( ans ) <NEWLINE> <NL>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> n = abs ( x ) // d <NEWLINE> if k >= n : <NEWLINE> <INDENT> k = k - n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = k <NEWLINE> k = 0 <NEWLINE> <NL> <DEDENT> if k % 2 == 0 : <NEWLINE> <INDENT> x = abs ( x ) - d * n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = abs ( x ) - d * ( n + 1 ) <NEWLINE> <NL> <DEDENT> print ( abs ( x ) ) <NEWLINE>
import sys <NEWLINE> from collections import Counter <NEWLINE> from math import gcd <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def list2d ( a , b , c ) : return [ [ c ] * b for i in range ( a ) ] <NEWLINE> def list3d ( a , b , c , d ) : return [ [ [ d ] * c for j in range ( b ) ] for i in range ( a ) ] <NEWLINE> def list4d ( a , b , c , d , e ) : return [ [ [ [ e ] * d for j in range ( c ) ] for j in range ( b ) ] for i in range ( a ) ] <NEWLINE> def ceil ( x , y = 1 ) : return int ( - ( - x // y ) ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( N = None ) : return list ( MAP ( ) ) if N is None else [ INT ( ) for i in range ( N ) ] <NEWLINE> def Yes ( ) : print ( <STRING> ) <NEWLINE> def No ( ) : print ( <STRING> ) <NEWLINE> def YES ( ) : print ( <STRING> ) <NEWLINE> def NO ( ) : print ( <STRING> ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> N = INT ( ) <NEWLINE> C = Counter ( ) <NEWLINE> zero = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = MAP ( ) <NEWLINE> if a == b == 0 : <NEWLINE> <INDENT> zero += 1 <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> C [ ( 0 , 1 , 0 ) ] += 1 <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> C [ ( 1 , 0 , 1 ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = gcd ( a , b ) <NEWLINE> ga , gb = a // g , b // g <NEWLINE> C [ ( ( a < 0 ) ^ ( b < 0 ) , abs ( ga ) , abs ( gb ) ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for k , v in C . items ( ) : <NEWLINE> <INDENT> if v == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> op , a , b = k <NEWLINE> ans *= pow ( 2 , C [ ( op , a , b ) ] , MOD ) + pow ( 2 , C [ ( 1 - op , b , a ) ] , MOD ) - 1 <NEWLINE> ans %= MOD <NEWLINE> if ( 1 - op , b , a ) in C : <NEWLINE> <INDENT> C [ ( 1 - op , b , a ) ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ( zero + ans - 1 ) % MOD ) <NEWLINE>
import numpy as np <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> Cs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Ss = [ ] <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Ss . append ( s ) <NEWLINE> <NL> <DEDENT> Ss = np . array ( Ss ) <NEWLINE> <NL> solution = np . argmax ( Ss , axis = 1 ) <NEWLINE> <NL> days_till_next = np . ones_like ( Ss ) * ( D - 1 ) - np . arange ( D ) . reshape ( ( D , 1 ) ) <NEWLINE> <NL> <NL> def update_days_till_next ( d , erase = False ) : <NEWLINE> <INDENT> contest = solution [ d ] <NEWLINE> delta = days_till_next [ d + 1 , contest ] + 1 if d < D - 1 else 0 <NEWLINE> days_till_next [ d , contest ] = delta <NEWLINE> for _d in range ( d - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if solution [ _d ] == contest or _d == 0 : <NEWLINE> <INDENT> days_till_next [ _d : d , contest ] = ( d - _d ) - np . arange ( d - _d ) + ( delta if erase else 0 ) <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def update_days_till_next_old ( d ) : <NEWLINE> <INDENT> contest = solution [ d ] <NEWLINE> if d < D - 1 : <NEWLINE> <INDENT> days_till_next [ d , contest ] = days_till_next [ d + 1 , contest ] + 1 <NEWLINE> <DEDENT> for _d in range ( d - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if solution [ _d ] == contest or _d == 0 : <NEWLINE> <INDENT> days_till_next [ _d : d , contest ] = ( d - _d + 1 ) - np . arange ( d - _d ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for d in range ( D - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> update_days_till_next ( d ) <NEWLINE> <NL> <DEDENT> for _ in range ( 100 ) : <NEWLINE> <INDENT> n_contests = len ( Ss [ 0 ] ) <NEWLINE> days_since_last = np . zeros ( n_contests ) <NEWLINE> for d , i in enumerate ( solution ) : <NEWLINE> <INDENT> days_since_last += 1 <NEWLINE> new_scores = days_till_next [ d ] * days_since_last * Cs + Ss [ d ] <NEWLINE> new_i = new_scores . argmax ( ) <NEWLINE> days_since_last [ new_i ] = 0 <NEWLINE> if new_i != i : <NEWLINE> <INDENT> update_days_till_next ( d , erase = True ) <NEWLINE> solution [ d ] = new_i <NEWLINE> update_days_till_next ( d ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for s in solution : <NEWLINE> <INDENT> print ( s + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> s = input ( ) <NEWLINE> t = s . split ( <STRING> ) <NEWLINE> <COMMENT> <NL> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> ans [ int ( t [ i ] ) - 1 ] = ans [ int ( t [ i ] ) - 1 ] + 1 <NEWLINE> <NL> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> def primeFactors ( n ) : <NEWLINE> <INDENT> A = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> A . append ( 2 ) <NEWLINE> n = n // 2 <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : <NEWLINE> <NL> <NL> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> A . append ( i ) <NEWLINE> n = n // i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if n > 2 : <NEWLINE> <INDENT> A . append ( n ) <NEWLINE> <NL> <DEDENT> return A <NEWLINE> <NL> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> primes = set ( primeFactors ( N ) ) <NEWLINE> answer = 0 <NEWLINE> for p in primes : <NEWLINE> <INDENT> d = p <NEWLINE> while N % d == 0 : <NEWLINE> <INDENT> answer += 1 <NEWLINE> N //= d <NEWLINE> d *= p <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = [ abs ( a [ 0 ] ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> d . append ( abs ( a [ i + 1 ] - a [ i ] ) ) <NEWLINE> <NL> <DEDENT> d . append ( abs ( a [ - 1 ] ) ) <NEWLINE> <NL> s = sum ( d ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> t = s - d [ i ] - d [ i + 1 ] + abs ( a [ i + 1 ] ) <NEWLINE> <DEDENT> elif i == n - 1 : <NEWLINE> <INDENT> t = s - d [ i ] - d [ i + 1 ] + abs ( - a [ i - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = s - d [ i ] - d [ i + 1 ] + abs ( a [ i + 1 ] - a [ i - 1 ] ) <NEWLINE> <DEDENT> print ( t ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> passlist = [ 0 ] * N <NEWLINE> point = 1 <NEWLINE> depth = 0 <NEWLINE> waylist = [ ] <NEWLINE> while passlist [ point - 1 ] == 0 : <NEWLINE> <INDENT> waylist . append ( point ) <NEWLINE> passlist [ point - 1 ] = depth <NEWLINE> point = A [ point - 1 ] <NEWLINE> depth += 1 <NEWLINE> <DEDENT> roop = waylist [ waylist . index ( point ) : len ( waylist ) ] <NEWLINE> firstreach = passlist [ roop [ 0 ] - 1 ] <NEWLINE> if K < firstreach : <NEWLINE> <INDENT> print ( passlist . index ( K ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( roop [ ( K - firstreach ) % len ( roop ) ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> def prime_number ( num ) : <NEWLINE> <INDENT> if num == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> for i in range ( 2 , int ( math . sqrt ( num ) ) + 1 ) : <NEWLINE> <INDENT> if ( num % i ) == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> return 1 <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> count += int ( prime_number ( num ) ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
distance = ( <NEWLINE> <INDENT> ( ) , <NEWLINE> ( 0 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 2 , 3 , 4 , 5 , 3 , 4 , 5 , 6 ) , <NEWLINE> ( 1 , 0 , 1 , 2 , 2 , 1 , 2 , 3 , 3 , 2 , 3 , 4 , 4 , 3 , 4 , 5 ) , <NEWLINE> ( 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 4 , 3 , 2 , 3 , 5 , 4 , 3 , 4 ) , <NEWLINE> ( 3 , 2 , 1 , 0 , 4 , 3 , 2 , 1 , 5 , 4 , 3 , 2 , 6 , 5 , 4 , 3 ) , <NEWLINE> ( 1 , 2 , 3 , 4 , 0 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 2 , 3 , 4 , 5 ) , <NEWLINE> ( 2 , 1 , 2 , 3 , 1 , 0 , 1 , 2 , 2 , 1 , 2 , 3 , 3 , 2 , 3 , 4 ) , <NEWLINE> ( 3 , 2 , 1 , 2 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 4 , 3 , 2 , 3 ) , <NEWLINE> ( 4 , 3 , 2 , 1 , 3 , 2 , 1 , 0 , 4 , 3 , 2 , 1 , 5 , 4 , 3 , 2 ) , <NEWLINE> ( 2 , 3 , 4 , 5 , 1 , 2 , 3 , 4 , 0 , 1 , 2 , 3 , 1 , 2 , 3 , 4 ) , <NEWLINE> ( 3 , 2 , 3 , 4 , 2 , 1 , 2 , 3 , 1 , 0 , 1 , 2 , 2 , 1 , 2 , 3 ) , <NEWLINE> ( 4 , 3 , 2 , 3 , 3 , 2 , 1 , 2 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 ) , <NEWLINE> ( 5 , 4 , 3 , 2 , 4 , 3 , 2 , 1 , 3 , 2 , 1 , 0 , 4 , 3 , 2 , 1 ) , <NEWLINE> ( 3 , 4 , 5 , 6 , 2 , 3 , 4 , 5 , 1 , 2 , 3 , 4 , 0 , 1 , 2 , 3 ) , <NEWLINE> ( 4 , 3 , 4 , 5 , 3 , 2 , 3 , 4 , 2 , 1 , 2 , 3 , 1 , 0 , 1 , 2 ) , <NEWLINE> ( 5 , 4 , 3 , 4 , 4 , 3 , 2 , 3 , 3 , 2 , 1 , 2 , 2 , 1 , 0 , 1 ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> def get_distance ( board ) : <NEWLINE> <INDENT> sd = 0 <NEWLINE> for i in range ( 16 ) : <NEWLINE> <INDENT> p = board [ i ] <NEWLINE> if p == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> sd += distance [ p ] [ i ] <NEWLINE> <DEDENT> return sd <NEWLINE> <NL> <DEDENT> adjacent = ( <NEWLINE> <INDENT> ( 1 , 4 ) , <COMMENT> <NEWLINE> ( 0 , 2 , 5 ) , <COMMENT> <NEWLINE> ( 1 , 3 , 6 ) , <COMMENT> <NEWLINE> ( 2 , 7 ) , <COMMENT> <NEWLINE> ( 0 , 5 , 8 ) , <COMMENT> <NEWLINE> ( 1 , 4 , 6 , 9 ) , <COMMENT> <NEWLINE> ( 2 , 5 , 7 , 10 ) , <COMMENT> <NEWLINE> ( 3 , 6 , 11 ) , <COMMENT> <NEWLINE> ( 4 , 9 , 12 ) , <COMMENT> <NEWLINE> ( 5 , 8 , 10 , 13 ) , <COMMENT> <NEWLINE> ( 6 , 9 , 11 , 14 ) , <COMMENT> <NEWLINE> ( 7 , 10 , 15 ) , <COMMENT> <NEWLINE> ( 8 , 13 ) , <COMMENT> <NEWLINE> ( 9 , 12 , 14 ) , <COMMENT> <NEWLINE> ( 10 , 13 , 15 ) , <COMMENT> <NEWLINE> ( 11 , 14 ) <COMMENT> <NEWLINE> <DEDENT> ) <NEWLINE> <NL> GOAL = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 0 ] <NEWLINE> <NL> def df_lower_search ( limit , move , space , lower , pre_p ) : <NEWLINE> <INDENT> if move == limit : <NEWLINE> <INDENT> if board == GOAL : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in adjacent [ space ] : <NEWLINE> <INDENT> p = board [ i ] <NEWLINE> if p == pre_p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> board [ space ] = p <NEWLINE> board [ i ] = 0 <NEWLINE> new_lower = lower - distance [ p ] [ i ] + distance [ p ] [ space ] <NEWLINE> if new_lower + move <= limit : <NEWLINE> <INDENT> if df_lower_search ( limit , move + 1 , i , new_lower , p ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> board [ space ] = 0 <NEWLINE> board [ i ] = p <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> import sys <NEWLINE> <NL> board = list ( map ( int , sys . stdin . read ( ) . split ( ) ) ) <NEWLINE> n = get_distance ( board ) <NEWLINE> for l in range ( n , 46 ) : <NEWLINE> <INDENT> if df_lower_search ( l , 0 , board . index ( 0 ) , n , None ) : <NEWLINE> <INDENT> print ( l ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> def bipartite_graph_check ( n , edge ) : <NEWLINE> <INDENT> color = [ - 1 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if color [ i ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> stack = [ i ] <NEWLINE> color [ i ] = 0 <NEWLINE> for node in stack : <NEWLINE> <INDENT> for mode in edge [ node ] : <NEWLINE> <INDENT> if color [ mode ] == - 1 : <NEWLINE> <INDENT> stack . append ( mode ) <NEWLINE> color [ mode ] = color [ node ] ^ 1 <NEWLINE> <DEDENT> elif color [ mode ] == color [ node ] : <NEWLINE> <INDENT> return False <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return color <NEWLINE> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> edge [ a ] . append ( b ) <NEWLINE> edge [ b ] . append ( a ) <NEWLINE> <DEDENT> if bipartite_graph_check ( n , edge ) : <NEWLINE> <INDENT> color = bipartite_graph_check ( n , edge ) <NEWLINE> print ( color . count ( 0 ) * color . count ( 1 ) - m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n * ( n - 1 ) // 2 - m ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> c = 0 <NEWLINE> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if j <= i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if k <= j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i != j and i != k and j != k and i + j + k == x : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if n != 0 : <NEWLINE> <INDENT> p = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> aa = [ ] <NEWLINE> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> if not i in p : <NEWLINE> <INDENT> aa . append ( i ) <NEWLINE> <DEDENT> <DEDENT> bb = [ ] <NEWLINE> if len ( aa ) == 0 : <NEWLINE> <INDENT> if abs ( x - ( 0 ) ) <= abs ( x - 101 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 101 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for A in aa : <NEWLINE> <INDENT> eee = abs ( x - A ) <NEWLINE> bb . append ( eee ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = bb . index ( min ( bb ) ) <NEWLINE> if abs ( x - ( 0 ) ) <= min ( bb ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif abs ( x - 101 ) < min ( bb ) : <NEWLINE> <INDENT> print ( 101 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( aa [ ans ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 1000000007 <NEWLINE> q = sum ( l ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> q -= l [ i ] <NEWLINE> ans += l [ i ] * q % mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
import math <NEWLINE> <NL> N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Df = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( float , input ( ) . split ( ) ) <NEWLINE> if math . sqrt ( x * x + y * y ) <= D : <NEWLINE> <INDENT> Df [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( Df . count ( 1 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> S = sum ( A ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> S -= A [ i ] <NEWLINE> ans = ( ans + S * A [ i ] ) % MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> cnt [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> maxcount = 0 <NEWLINE> for i in range ( 2 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> maxcount = max ( maxcount , sum ( cnt [ i : : i ] ) ) <NEWLINE> <NL> <DEDENT> if np . gcd . reduce ( A ) != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif maxcount <= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> if sum ( b [ i : : i + 1 ] ) % 2 != a [ i ] : <NEWLINE> <INDENT> b [ i ] += 1 <NEWLINE> ans . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( b ) ) <NEWLINE> print ( * sorted ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> bc . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> a_sum = sum ( a ) <NEWLINE> <NL> dic = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if str ( a [ i ] ) not in dic : <NEWLINE> <INDENT> dic [ str ( a [ i ] ) ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ str ( a [ i ] ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> if str ( bc [ i ] [ 0 ] ) in dic . keys ( ) : <NEWLINE> <INDENT> buf = dic [ str ( bc [ i ] [ 0 ] ) ] <NEWLINE> if str ( bc [ i ] [ 1 ] ) in dic . keys ( ) : <NEWLINE> <INDENT> dic [ str ( bc [ i ] [ 1 ] ) ] += buf <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ str ( bc [ i ] [ 1 ] ) ] = buf <NEWLINE> <NL> <DEDENT> a_sum += buf * ( - bc [ i ] [ 0 ] + bc [ i ] [ 1 ] ) <NEWLINE> dic [ str ( bc [ i ] [ 0 ] ) ] = 0 <NEWLINE> <NL> <NL> <DEDENT> print ( a_sum ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> aa = [ ] <NEWLINE> i = 0 <NEWLINE> score = 0 <NEWLINE> <NL> while score < n : <NEWLINE> <INDENT> i += 1 <NEWLINE> score += i <NEWLINE> aa . append ( i ) <NEWLINE> <NL> <DEDENT> if score == n : <NEWLINE> <INDENT> for k in range ( len ( aa ) ) : <NEWLINE> <INDENT> print ( aa [ k ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> aa . remove ( score - n ) <NEWLINE> for k in range ( len ( aa ) ) : <NEWLINE> <INDENT> print ( aa [ k ] ) <NEWLINE> <DEDENT> <DEDENT>
from math import ceil <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ng = 0 <NEWLINE> ok = 10 ** 9 + 7 <NEWLINE> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cnt += ( a [ i ] - 1 ) // mid <NEWLINE> <DEDENT> if cnt <= k : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> print ( ceil ( ok ) if k > 0 else a [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> num = 0 <NEWLINE> <NL> for i in range ( 0 , K ) : <NEWLINE> <INDENT> num = num * 10 + 7 <NEWLINE> if num % K == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> num %= K <NEWLINE> <NL> <DEDENT> print ( - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P_min = [ ] <NEWLINE> a = 200000 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if a >= P [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> a = P [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> import heapq <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> c = [ [ <STRING> ] * ( w + 2 ) ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> i = list ( <STRING> + input ( ) + <STRING> ) <NEWLINE> c . append ( i ) <NEWLINE> <DEDENT> c . append ( [ <STRING> ] * ( w + 2 ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> seen = [ [ - 1 ] * ( w + 2 ) for _ in range ( h + 2 ) ] <NEWLINE> <NL> <COMMENT> <NL> todo = [ ( 0 , x1 , y1 , 0 ) ] <NEWLINE> heapq . heapify ( todo ) <NEWLINE> <NL> <COMMENT> <NL> dx = [ - 1 , 0 , 1 , 0 ] <NEWLINE> dy = [ 0 , 1 , 0 , - 1 ] <NEWLINE> <NL> while len ( todo ) > 0 : <NEWLINE> <INDENT> cost , xi , yi , direction = heapq . heappop ( todo ) <NEWLINE> <NL> <COMMENT> <NL> if seen [ xi ] [ yi ] != - 1 : <NEWLINE> <INDENT> if ( seen [ xi ] [ yi ] + k - 1 ) // k * k >= cost : <NEWLINE> <INDENT> xj , yj = xi + dx [ direction ] , yi + dy [ direction ] <NEWLINE> if c [ xj ] [ yj ] == <STRING> : <NEWLINE> <INDENT> heapq . heappush ( todo , ( cost + 1 , xj , yj , direction ) ) <NEWLINE> <DEDENT> <DEDENT> continue <NEWLINE> <DEDENT> seen [ xi ] [ yi ] = cost <NEWLINE> <NL> <COMMENT> <NL> if xi == x2 and yi == y2 : <NEWLINE> <INDENT> print ( ( cost + k - 1 ) // k ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> xj , yj = xi + dx [ j ] , yi + dy [ j ] <NEWLINE> if c [ xj ] [ yj ] == <STRING> : <NEWLINE> <INDENT> if j == direction : <NEWLINE> <INDENT> if seen [ xj ] [ yj ] == - 1 or ( seen [ xj ] [ yj ] + k - 1 ) // k * k > cost : <NEWLINE> <INDENT> heapq . heappush ( todo , ( cost + 1 , xj , yj , j ) ) <NEWLINE> <DEDENT> <DEDENT> elif seen [ xj ] [ yj ] == - 1 : <NEWLINE> <INDENT> heapq . heappush ( todo , ( ( cost + k - 1 ) // k * k + 1 , xj , yj , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> <NL> def furui ( n ) : <NEWLINE> <INDENT> l = [ 1 for i in range ( n + 1 ) ] <NEWLINE> l [ 0 ] = 0 <NEWLINE> l [ 1 ] = 0 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if l [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( 2 , n // i + 1 ) : <NEWLINE> <INDENT> l [ i * j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> l2 = [ ] <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> if l [ i ] == 1 : <NEWLINE> <INDENT> l2 . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return l2 <NEWLINE> <NL> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> n = int ( line ) <NEWLINE> l = furui ( n ) <NEWLINE> if max ( l ) == n : <NEWLINE> <INDENT> i1 = l [ len ( l ) - 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i1 = max ( l ) <NEWLINE> <DEDENT> i2 = n <NEWLINE> while True : <NEWLINE> <INDENT> i2 += 1 <NEWLINE> flag = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> if i2 % i == 0 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( str ( i1 ) + <STRING> + str ( i2 ) ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> bomb_count = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( 3 ) : <NEWLINE> <INDENT> for l in range ( 3 ) : <NEWLINE> <INDENT> a = i - 1 + k <NEWLINE> b = j - 1 + l <NEWLINE> if a < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif a > h - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if b < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif b > w - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ a ] [ b ] == <STRING> : <NEWLINE> <INDENT> bomb_count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> s [ i ] [ j ] = str ( bomb_count ) <NEWLINE> bomb_count = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> . join ( s [ i ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> c = collections . Counter ( l ) <NEWLINE> L = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> M = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> <NL> for x , y in c . items ( ) : <NEWLINE> <INDENT> L [ x ] += y <NEWLINE> <NL> <DEDENT> M [ 0 ] = L [ 0 ] <NEWLINE> M [ 10 ** 5 ] = L [ 10 ** 5 ] <NEWLINE> for i in range ( 1 , 10 ** 5 ) : <NEWLINE> <INDENT> M [ i ] = L [ i - 1 ] + L [ i ] + L [ i + 1 ] <NEWLINE> <DEDENT> print ( max ( M ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> r_min = int ( input ( ) ) <NEWLINE> r_t = int ( input ( ) ) <NEWLINE> g_max = r_t - r_min <NEWLINE> r_min = min ( r_t , r_min ) <NEWLINE> <NL> for _ in range ( n - 2 ) : <NEWLINE> <INDENT> r_t = int ( input ( ) ) <NEWLINE> g_max = max ( g_max , r_t - r_min ) <NEWLINE> r_min = min ( r_t , r_min ) <NEWLINE> <NL> <DEDENT> print ( g_max ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> count = 0 <NEWLINE> <NL> min_a = N + 1 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a == min ( min_a , a ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> min_a = a <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> <NL> bc = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( M ) ] <NEWLINE> bc . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> <NL> <NL> ai = N - 1 <NEWLINE> mi = M - 1 <NEWLINE> pos = 0 <NEWLINE> ans = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> if ( A [ ai ] > bc [ mi ] [ 1 ] ) | ( mi < 0 ) : <NEWLINE> <INDENT> pos += 1 <NEWLINE> ans += A [ ai ] <NEWLINE> ai -= 1 <NEWLINE> <DEDENT> elif pos + bc [ mi ] [ 0 ] >= N : <NEWLINE> <INDENT> ans += bc [ mi ] [ 1 ] * ( N - pos ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += bc [ mi ] [ 0 ] * bc [ mi ] [ 1 ] <NEWLINE> pos += bc [ mi ] [ 0 ] <NEWLINE> mi -= 1 <NEWLINE> <DEDENT> if pos >= N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class SegmentTree ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . dat = [ INF for _ in range ( n * 2 - 1 ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> self . n = n <NEWLINE> <NL> <DEDENT> def update ( self , node_index , value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> index = node_index + ( self . n - 1 ) <COMMENT> <NEWLINE> self . dat [ index ] = value <NEWLINE> <NL> <COMMENT> <NL> while index > 0 : <NEWLINE> <INDENT> index = ( index - 1 ) // 2 <COMMENT> <NEWLINE> self . dat [ index ] = min ( [ self . dat [ index * 2 + 1 ] , self . dat [ index * 2 + 2 ] ] ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> def querry ( self , left , right , nowNode , nowLeft , nowRight ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> <COMMENT> <NL> if nowRight < left or nowLeft > right : <NEWLINE> <INDENT> return INF <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if left <= nowLeft and nowRight <= right : <NEWLINE> <INDENT> return self . dat [ nowNode ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> value_left = self . querry ( left , right , 2 * nowNode + 1 , nowLeft , ( nowLeft + nowRight ) // 2 ) <NEWLINE> value_right = self . querry ( left , right , 2 * nowNode + 2 , ( nowLeft + nowRight ) // 2 + 1 , nowRight ) <NEWLINE> return min ( [ value_left , value_right ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def DEBUG_dat ( self ) : <NEWLINE> <INDENT> print ( self . dat ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> INF = 2147483647 <NEWLINE> n , q = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> result = [ ] <NEWLINE> <NL> for i in range ( 1 , 20 ) : <NEWLINE> <INDENT> if 2 ** i >= n : <NEWLINE> <INDENT> min_pow2 = 2 ** i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> tree = SegmentTree ( min_pow2 ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> com , x , y = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if com == 0 : <NEWLINE> <INDENT> tree . update ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( tree . querry ( x , y , 0 , 0 , min_pow2 - 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in result : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
def Multiplication_2 ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> An = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in An : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> over = 10 ** 18 <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in An : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > over : <NEWLINE> <INDENT> return - 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> print ( Multiplication_2 ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> tmp = 10000 - n <NEWLINE> s = tmp % 1000 <NEWLINE> <NL> print ( s ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> b = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if a [ b - 1 ] == - 1 : <NEWLINE> <INDENT> a [ b - 1 ] = i + 1 <NEWLINE> b = List [ b - 1 ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> c = i <NEWLINE> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> num = a [ b - 1 ] - 1 <NEWLINE> T = c - num <NEWLINE> <COMMENT> <NL> e = 1 <NEWLINE> if K < num : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> e = List [ e - 1 ] <NEWLINE> <DEDENT> print ( e ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> qw = ( K - num ) % T <NEWLINE> List_new = [ ] <NEWLINE> for i in range ( T ) : <NEWLINE> <INDENT> List_new . append ( b ) <NEWLINE> b = List [ b - 1 ] <NEWLINE> <DEDENT> print ( List_new [ qw ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> stdin = sys . stdin <NEWLINE> <NL> ns = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> ni = lambda : int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> nm = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n = ni ( ) <NEWLINE> color = nl ( ) <NEWLINE> g = [ list ( ) for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = nm ( ) <NEWLINE> g [ a - 1 ] . append ( b - 1 ) <NEWLINE> g [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> size = [ 1 ] * n <NEWLINE> par = [ - 1 ] * n <NEWLINE> h = [ list ( ) for _ in range ( n + 1 ) ] <NEWLINE> idx = [ 0 ] * n <NEWLINE> def dfs ( v , p ) : <NEWLINE> <INDENT> h [ color [ v ] ] . append ( v ) <NEWLINE> for x in g [ v ] : <NEWLINE> <INDENT> if x == p : continue <NEWLINE> par [ x ] = v <NEWLINE> size [ v ] += dfs ( x , v ) <NEWLINE> h [ color [ v ] ] . append ( v ) <NEWLINE> <DEDENT> h [ color [ v ] ] . append ( v ) <NEWLINE> return size [ v ] <NEWLINE> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> <COMMENT> <NL> for v in range ( n ) : <NEWLINE> <INDENT> if idx [ v ] < len ( g [ v ] ) and g [ v ] [ idx [ v ] ] == par [ v ] : <NEWLINE> <INDENT> idx [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> acc = [ 0 ] * ( n + 10 ) <NEWLINE> ans = [ n * ( n + 1 ) // 2 ] * ( n + 1 ) <NEWLINE> for col in range ( 1 , n + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> acc [ - 1 ] = 0 <NEWLINE> p = [ - 1 ] <NEWLINE> for v in h [ col ] : <NEWLINE> <INDENT> if p [ - 1 ] == v : <NEWLINE> <INDENT> p . pop ( ) <NEWLINE> if idx [ v ] >= len ( g [ v ] ) : <NEWLINE> <INDENT> acc [ p [ - 1 ] ] += size [ v ] <NEWLINE> continue <NEWLINE> <DEDENT> q = size [ g [ v ] [ idx [ v ] ] ] - acc [ v ] <NEWLINE> idx [ v ] += 1 <NEWLINE> if idx [ v ] < len ( g [ v ] ) and g [ v ] [ idx [ v ] ] == par [ v ] : <NEWLINE> <INDENT> idx [ v ] += 1 <NEWLINE> <DEDENT> ans [ col ] -= q * ( q + 1 ) // 2 <NEWLINE> acc [ v ] = 0 <NEWLINE> <COMMENT> <NL> p . append ( v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . append ( v ) <NEWLINE> <DEDENT> <DEDENT> q = n - acc [ - 1 ] <NEWLINE> <COMMENT> <NL> ans [ col ] -= q * ( q + 1 ) // 2 <NEWLINE> <DEDENT> print ( * ans [ 1 : ] , sep = <STRING> ) <NEWLINE>
<NL> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> import math <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( input ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> @ njit <NEWLINE> def solve ( n , k , a ) : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> new = np . zeros_like ( a ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> distance = j - a [ j ] <NEWLINE> if distance < 0 : <NEWLINE> <INDENT> distance = 0 <NEWLINE> <DEDENT> last = j + a [ j ] <NEWLINE> if last > n - 1 : <NEWLINE> <INDENT> last = n - 1 <NEWLINE> <DEDENT> new [ distance ] += 1 <NEWLINE> if last + 1 < n : <NEWLINE> <INDENT> new [ last + 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> a = np . cumsum ( new ) <NEWLINE> if np . all ( a == n ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return a <NEWLINE> <NL> <DEDENT> a = solve ( n , k , a ) <NEWLINE> print ( <STRING> . join ( a . astype ( str ) ) ) <NEWLINE>
from numba import jit <NEWLINE> <NL> @ jit <NEWLINE> def solve ( N , K , A ) : <NEWLINE> <INDENT> for k in range ( K ) : <NEWLINE> <INDENT> B = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l = max ( 0 , i - A [ i ] ) <NEWLINE> r = i + A [ i ] + 1 <NEWLINE> B [ l ] += 1 <NEWLINE> if r < N : <NEWLINE> <INDENT> B [ r ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( N - 1 ) : <NEWLINE> <INDENT> B [ j + 1 ] += B [ j ] <NEWLINE> <NL> <DEDENT> if A == B : <NEWLINE> <INDENT> return B <NEWLINE> <DEDENT> A = B <NEWLINE> <DEDENT> return B <NEWLINE> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = solve ( N , K , A ) <NEWLINE> for b in B : <NEWLINE> <INDENT> print ( b , end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = [ 0 ] * ( 1 + A [ - 1 ] ) <NEWLINE> for i in A : <NEWLINE> <INDENT> B [ i ] += 1 <NEWLINE> if B [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( 2 * i , A [ - 1 ] + 1 , i ) : <NEWLINE> <INDENT> B [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if B [ i ] == 1 : ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_list = sorted ( a_list ) <NEWLINE> flag = [ 0 ] * n <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> m = max ( a_list ) <NEWLINE> b_list = [ 0 ] * ( m + 1 ) <NEWLINE> for i in a_list : <NEWLINE> <INDENT> b_list [ i ] += 1 <NEWLINE> <DEDENT> for i in a_list : <NEWLINE> <INDENT> if b_list [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> for j in range ( i , m + 1 , i ) : <NEWLINE> <INDENT> b_list [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> idx = 1 <NEWLINE> idx_li = [ ] <NEWLINE> ord_ = [ - 1 ] * n <NEWLINE> flag = False <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> idx_li . append ( idx ) <NEWLINE> ord_ [ idx - 1 ] = 1 <NEWLINE> idx = a [ idx - 1 ] <NEWLINE> if ord_ [ idx - 1 ] == 1 : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <COMMENT> <NL> <INDENT> loop = idx_li [ idx_li . index ( idx ) : ] <NEWLINE> <NL> size = len ( loop ) <NEWLINE> print ( loop [ ( k - ( len ( idx_li ) - len ( loop ) ) ) % size ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( idx ) <NEWLINE> <DEDENT>
H , W , M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> sum_h = [ 0 ] * W <NEWLINE> sum_w = [ 0 ] * H <NEWLINE> bomb_list = set ( ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> h -= 1 <NEWLINE> w -= 1 <NEWLINE> bomb_list . add ( ( h , w ) ) <NEWLINE> sum_h [ w ] += 1 <NEWLINE> sum_w [ h ] += 1 <NEWLINE> <NL> <DEDENT> max_sum_h = max ( sum_h ) <NEWLINE> max_sum_w = max ( sum_w ) <NEWLINE> output = max_sum_h + max_sum_w - 1 <NEWLINE> <NL> max_bombs_h = [ h for h in range ( H ) if sum_w [ h ] == max_sum_w ] <NEWLINE> max_bombs_w = [ w for w in range ( W ) if sum_h [ w ] == max_sum_h ] <NEWLINE> <NL> for h in max_bombs_h : <NEWLINE> <INDENT> for w in max_bombs_w : <NEWLINE> <INDENT> if ( h , w ) not in bomb_list : <NEWLINE> <INDENT> output = max_sum_h + max_sum_w <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( output ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> sevens = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sevens = ( sevens * 10 + 7 ) % k <NEWLINE> if sevens == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , C , K = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> if K <= A : <NEWLINE> <INDENT> sum += K <NEWLINE> print ( sum ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += A <NEWLINE> K -= A <NEWLINE> if K <= B : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= B <NEWLINE> sum -= K <NEWLINE> print ( sum ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> d = { } <NEWLINE> par = [ [ ] for i in range ( n ) ] <NEWLINE> que = deque ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> par [ a - 1 ] . append ( b ) <NEWLINE> par [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> que . append ( 1 ) <NEWLINE> while ( len ( que ) > 0 ) : <NEWLINE> <INDENT> label = que . popleft ( ) <NEWLINE> for i in par [ label - 1 ] : <NEWLINE> <INDENT> if i not in d . keys ( ) : <NEWLINE> <INDENT> que . append ( i ) <NEWLINE> d [ i ] = label <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if len ( d ) < n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> found = False <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> <NL> for i in range ( - 200 , 201 ) : <NEWLINE> <INDENT> for j in range ( - 200 , 201 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> found = True <NEWLINE> a = i <NEWLINE> b = j <NEWLINE> <DEDENT> <DEDENT> if found : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> remain = [ [ 0 , 0 , 0 ] ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> r , g , b = remain [ - 1 ] <NEWLINE> if s [ - i - 1 ] == <STRING> : <NEWLINE> <INDENT> r = r + 1 <NEWLINE> <DEDENT> elif s [ - i - 1 ] == <STRING> : <NEWLINE> <INDENT> g = g + 1 <NEWLINE> <DEDENT> elif s [ - i - 1 ] == <STRING> : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <NL> <DEDENT> remain . append ( [ r , g , b ] ) <NEWLINE> <NL> <DEDENT> total = 0 <NEWLINE> <NL> rgb = <STRING> <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> first = s [ i ] <NEWLINE> search = [ ] <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> if j == rgb . find ( first ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> search . append ( j ) <NEWLINE> <DEDENT> <DEDENT> total = total + ( remain [ - i - 2 ] [ search [ 0 ] ] * remain [ - i - 2 ] [ search [ 1 ] ] ) <NEWLINE> try : <NEWLINE> <INDENT> for j in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i ] != s [ i + j ] and s [ i ] != s [ i + j + j ] and s [ i + j ] != s [ i + j + j ] : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import math <NEWLINE> <NL> str = input ( ) . split ( <STRING> ) <NEWLINE> x1 = float ( str [ 0 ] ) <NEWLINE> x2 = float ( str [ 1 ] ) <NEWLINE> y1 = float ( str [ 2 ] ) <NEWLINE> y2 = float ( str [ 3 ] ) <NEWLINE> <NL> result = ( x1 - y1 ) * ( x1 - y1 ) + ( x2 - y2 ) * ( x2 - y2 ) <NEWLINE> result = math . sqrt ( result ) if result != 0 else 0 <NEWLINE> <NL> print ( <STRING> % result ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i + j + k == x : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> if j != k : <NEWLINE> <INDENT> if i != k : <NEWLINE> <INDENT> a . append ( [ i , j , k ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> b = [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> b . append ( sorted ( i ) ) <NEWLINE> <NL> <DEDENT> c = [ ] <NEWLINE> c = sorted ( b ) <NEWLINE> <NL> if len ( c ) == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> t = c [ 0 ] <NEWLINE> for i in c : <NEWLINE> <INDENT> if t != i : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> t = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i >= K : <NEWLINE> <INDENT> prev = A [ i - K ] <NEWLINE> cur = A [ i ] <NEWLINE> if prev >= cur : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> a_list = [ ] <NEWLINE> <NL> b_list = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list . append ( a ) <NEWLINE> b_list . append ( b ) <NEWLINE> <NL> <DEDENT> a_list = a_list [ : : - 1 ] <NEWLINE> b_list = b_list [ : : - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> st = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a_list [ i ] += st <NEWLINE> if a_list [ i ] % b_list [ i ] : <NEWLINE> <INDENT> if a_list [ i ] < b_list [ i ] : <NEWLINE> <INDENT> st += b_list [ i ] - a_list [ i ] <NEWLINE> <DEDENT> elif a_list [ i ] > b_list [ i ] : <NEWLINE> <INDENT> st += b_list [ i ] * ( ( a_list [ i ] // b_list [ i ] ) + 1 ) - a_list [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( st ) <NEWLINE>
<NL> f = [ - 1 for i in range ( 45 ) ] <NEWLINE> f [ 0 ] = f [ 1 ] = 1 <NEWLINE> <NL> def fib ( n ) : <NEWLINE> <INDENT> global f <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> f [ i ] = f [ i - 1 ] + f [ i - 2 ] <NEWLINE> <COMMENT> <NL> <DEDENT> return f [ n ] <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> n = int ( n ) <NEWLINE> <COMMENT> <NL> print ( fib ( n ) ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> lines = [ s . rstrip ( <STRING> ) for s in sys . stdin . readlines ( ) ] <NEWLINE> input = lines . pop ( 0 ) <NEWLINE> acgt = tuple ( <STRING> ) <NEWLINE> max_num_list = [ ] <NEWLINE> max_num = 0 <NEWLINE> for c in input : <NEWLINE> <INDENT> if c in acgt : <NEWLINE> <INDENT> max_num += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_num_list . append ( max_num ) <NEWLINE> max_num = 0 <NEWLINE> <DEDENT> <DEDENT> max_num_list . append ( max_num ) <NEWLINE> print ( max ( max_num_list ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . readline <NEWLINE> read = sys . stdin . read <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> def run ( ) : <NEWLINE> <INDENT> N , K = map ( int , sysread ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , sysread ( ) . split ( ) ) ) <NEWLINE> <NL> seen = [ False ] * ( N + 1 ) <NEWLINE> arr = [ 1 ] <NEWLINE> seen [ 1 ] = True <NEWLINE> while True : <NEWLINE> <INDENT> next = A [ arr [ - 1 ] ] <NEWLINE> if seen [ next ] : <NEWLINE> <INDENT> arr . append ( next ) <NEWLINE> break <NEWLINE> <DEDENT> arr . append ( next ) <NEWLINE> seen [ next ] = True <NEWLINE> <DEDENT> arr = np . array ( arr ) <NEWLINE> x = int ( math . log2 ( K ) ) + 1 <NEWLINE> dub = np . array ( [ [ 0 ] * ( N + 1 ) for _ in range ( x ) ] ) <NEWLINE> dub [ 0 , arr [ : - 1 ] ] = np . array ( arr [ 1 : ] ) <NEWLINE> for d in range ( 1 , x ) : <NEWLINE> <INDENT> next1 = dub [ d - 1 , arr [ : - 1 ] ] <NEWLINE> next2 = dub [ d - 1 , next1 ] <NEWLINE> dub [ d , arr [ : - 1 ] ] = next2 <NEWLINE> <NL> <DEDENT> ret = 1 <NEWLINE> while K : <NEWLINE> <INDENT> d = int ( math . log2 ( K ) ) <NEWLINE> K -= 1 << d <NEWLINE> ret = dub [ d ] [ ret ] <NEWLINE> <DEDENT> print ( ret ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> for key in A : <NEWLINE> <INDENT> d [ key ] += 1 <NEWLINE> <DEDENT> d [ sum ] = sum ( A ) <NEWLINE> <NL> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> change_sum = d [ b ] * ( c - b ) <NEWLINE> d [ sum ] += change_sum <NEWLINE> d [ c ] += d [ b ] <NEWLINE> d [ b ] = 0 <NEWLINE> print ( d [ sum ] ) <NEWLINE> <DEDENT>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> <NL> <NL> class Matrix ( ) : <NEWLINE> <INDENT> def __init__ ( self , A ) : <NEWLINE> <INDENT> self . A = A <NEWLINE> self . row = len ( A ) <NEWLINE> self . col = len ( A [ 0 ] ) <NEWLINE> <NL> <DEDENT> def __iter__ ( self ) : <NEWLINE> <INDENT> return self . A . __iter__ ( ) <NEWLINE> <NL> <DEDENT> def __getitem__ ( self , i ) : <NEWLINE> <INDENT> return self . A . __getitem__ ( i ) <NEWLINE> <NL> <DEDENT> def __add__ ( self , B ) : <NEWLINE> <INDENT> aa = self . A <NEWLINE> bb = B . A <NEWLINE> return Matrix ( [ [ aa [ i ] [ j ] + bb [ i ] [ j ] for j in range ( self . col ) ] for i in range ( self . row ) ] ) <NEWLINE> <NL> <DEDENT> def __sub__ ( self , B ) : <NEWLINE> <INDENT> aa = self . A <NEWLINE> bb = B . A <NEWLINE> return Matrix ( [ [ aa [ i ] [ j ] - bb [ i ] [ j ] for j in range ( self . col ) ] for i in range ( self . row ) ] ) <NEWLINE> <NL> <DEDENT> def __mul__ ( self , B ) : <NEWLINE> <INDENT> aa = self . A <NEWLINE> bb = B . A <NEWLINE> a = [ ] <NEWLINE> for i in range ( self . row ) : <NEWLINE> <INDENT> ai = aa [ i ] <NEWLINE> r = [ ] <NEWLINE> for j in range ( B . col ) : <NEWLINE> <INDENT> r . append ( sum ( [ ai [ k ] * bb [ k ] [ j ] for k in range ( self . col ) ] ) ) <NEWLINE> <DEDENT> a . append ( r ) <NEWLINE> <DEDENT> return Matrix ( a ) <NEWLINE> <NL> <DEDENT> def __truediv__ ( self , x ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> def lu ( self ) : <NEWLINE> <INDENT> size = self . row <NEWLINE> T = copy . deepcopy ( self . A ) <NEWLINE> L = [ [ 0 ] * size for _ in range ( size ) ] <NEWLINE> U = [ [ 0 ] * size for _ in range ( size ) ] <NEWLINE> for i in range ( size ) : <NEWLINE> <INDENT> for j in range ( i , size ) : <NEWLINE> <INDENT> L [ j ] [ i ] = T [ j ] [ i ] <NEWLINE> <DEDENT> for j in range ( i , size ) : <NEWLINE> <INDENT> U [ i ] [ j ] = T [ i ] [ j ] / T [ i ] [ i ] <NEWLINE> <DEDENT> for j in range ( i + 1 , size ) : <NEWLINE> <INDENT> for k in range ( i + 1 , size ) : <NEWLINE> <INDENT> T [ j ] [ k ] -= L [ j ] [ i ] * U [ i ] [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return Matrix ( L ) , Matrix ( U ) <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return self . A . __str__ ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def solve_se ( A , b ) : <NEWLINE> <INDENT> n = A . row <NEWLINE> L , U = A . lu ( ) <NEWLINE> y = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = b [ i ] <NEWLINE> for k in range ( i ) : <NEWLINE> <INDENT> t -= L [ i ] [ k ] * y [ k ] <NEWLINE> <DEDENT> y . append ( t / L [ i ] [ i ] ) <NEWLINE> <NL> <DEDENT> x = [ 0 ] * n <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> t = y [ i ] <NEWLINE> for k in range ( i + 1 , n ) : <NEWLINE> <INDENT> t -= U [ i ] [ k ] * x [ k ] <NEWLINE> <DEDENT> x [ i ] = t <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> sa = [ s for s in sys . stdin . read ( ) . split ( <STRING> ) if s ] <NEWLINE> r = [ ] <NEWLINE> for s in sa : <NEWLINE> <INDENT> a , b , c , d , e , f = [ int ( c ) for c in s . split ( ) ] <NEWLINE> A = Matrix ( [ [ a , b ] , [ d , e ] ] ) <NEWLINE> B = [ c , f ] <NEWLINE> x = solve_se ( A , B ) <NEWLINE> r . append ( <STRING> . join ( map ( lambda t : <STRING> . format ( 1.0 * t ) , x ) ) ) <NEWLINE> <NL> <DEDENT> return <STRING> . join ( r ) <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> m = N // i - 1 <NEWLINE> q , r = divmod ( N , m ) <NEWLINE> if q == r : <NEWLINE> <INDENT> ans += m <NEWLINE> <DEDENT> if m < N ** .5 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from itertools import combinations_with_replacement <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> comb = list ( combinations_with_replacement ( range ( 1 , m + 1 ) , n ) ) <NEWLINE> ans = [ 0 ] * len ( comb ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( len ( comb ) ) : <NEWLINE> <INDENT> if comb [ i ] [ b - 1 ] - comb [ i ] [ a - 1 ] == c : <NEWLINE> <INDENT> ans [ i ] += d <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> adj_max = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if adj_max [ a - 1 ] < H [ b - 1 ] : <NEWLINE> <INDENT> adj_max [ a - 1 ] = H [ b - 1 ] <NEWLINE> <DEDENT> if adj_max [ b - 1 ] < H [ a - 1 ] : <NEWLINE> <INDENT> adj_max [ b - 1 ] = H [ a - 1 ] <NEWLINE> <DEDENT> <DEDENT> num = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if H [ i ] > adj_max [ i ] : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> ans = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += str ( b [ i ] ) + <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<NL> i = 0 <COMMENT> <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <COMMENT> <NEWLINE> print ( <STRING> . format ( i , n ) ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> N , K = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> P = [ int ( _ ) - 1 for _ in input ( ) . split ( ) ] <NEWLINE> C = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> class SegmentTree ( ) : <NEWLINE> <INDENT> def __init__ ( self , array , f , ti ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . f = f <NEWLINE> self . ti = ti <NEWLINE> self . n = n = 2 ** ( len ( array ) . bit_length ( ) ) <NEWLINE> self . dat = dat = [ ti ] * n + array + [ ti ] * ( n - len ( array ) ) <NEWLINE> for i in range ( n - 1 , 0 , - 1 ) : <COMMENT> <NEWLINE> <INDENT> dat [ i ] = f ( dat [ i << 1 ] , dat [ i << 1 | 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def update ( self , p , v ) : <COMMENT> <NEWLINE> <INDENT> f , n , dat = self . f , self . n , self . dat <NEWLINE> p += n <NEWLINE> dat [ p ] = v <NEWLINE> while p > 1 : <NEWLINE> <INDENT> p >>= 1 <NEWLINE> dat [ p ] = f ( dat [ p << 1 ] , dat [ p << 1 | 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def operate_right ( self , p , v ) : <COMMENT> <NEWLINE> <INDENT> f , n , dat = self . f , self . n , self . dat <NEWLINE> p += n <NEWLINE> dat [ p ] = f ( dat [ p ] , v ) <NEWLINE> while p > 1 : <NEWLINE> <INDENT> p >>= 1 <NEWLINE> dat [ p ] = f ( dat [ p << 1 ] , dat [ p << 1 | 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def operate_left ( self , p , v ) : <COMMENT> <NEWLINE> <INDENT> f , n , dat = self . f , self . n , self . dat <NEWLINE> p += n <NEWLINE> dat [ p ] = f ( v , dat [ p ] ) <NEWLINE> while p > 1 : <NEWLINE> <INDENT> p >>= 1 <NEWLINE> dat [ p ] = f ( dat [ p << 1 ] , dat [ p << 1 | 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def query ( self , l , r ) : <COMMENT> <NEWLINE> <INDENT> f , ti , n , dat = self . f , self . ti , self . n , self . dat <NEWLINE> vl = vr = ti <NEWLINE> l += n <NEWLINE> r += n <NEWLINE> while l < r : <NEWLINE> <INDENT> if l & 1 : <NEWLINE> <INDENT> vl = f ( vl , dat [ l ] ) <NEWLINE> l += 1 <NEWLINE> <DEDENT> if r & 1 : <NEWLINE> <INDENT> r -= 1 <NEWLINE> vr = f ( dat [ r ] , vr ) <NEWLINE> <DEDENT> l >>= 1 <NEWLINE> r >>= 1 <NEWLINE> <DEDENT> return f ( vl , vr ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = - 10 ** 20 <NEWLINE> se = set ( ) <NEWLINE> for start in range ( N ) : <NEWLINE> <INDENT> if start in se : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> now = start <NEWLINE> scores = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> if now in se : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> se . add ( now ) <NEWLINE> scores += [ C [ now ] ] <NEWLINE> now = P [ now ] <NEWLINE> <DEDENT> cyclelen = len ( scores ) <NEWLINE> cum = list ( itertools . accumulate ( scores * 2 ) ) <NEWLINE> st = SegmentTree ( cum , max , - 10 ** 20 ) <NEWLINE> cycle , residue = divmod ( K , cyclelen ) <NEWLINE> ans = max ( [ ans ] + [ <NEWLINE> <INDENT> st . query ( start2 + 1 , start2 + 1 + min ( cyclelen , K ) ) - cum [ start2 ] <NEWLINE> for start2 in range ( cyclelen ) <NEWLINE> <DEDENT> ] ) <NEWLINE> if cum [ - 1 ] > 0 and cycle > 0 : <NEWLINE> <INDENT> v1 = cum [ - 1 ] * ( cycle - 1 ) // 2 + max ( <NEWLINE> <INDENT> st . query ( start2 , start2 + cyclelen + 1 ) - cum [ start2 ] <NEWLINE> for start2 in range ( cyclelen ) ) <NEWLINE> <DEDENT> v2 = cum [ - 1 ] * cycle // 2 + max ( <NEWLINE> <INDENT> st . query ( start2 , start2 + residue + 1 ) - cum [ start2 ] <NEWLINE> for start2 in range ( cyclelen ) ) <NEWLINE> <DEDENT> ans = max ( [ ans , v1 , v2 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> N , M = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> adj = [ [ ] for n in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> inp = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> adj [ inp [ 0 ] ] . append ( inp [ 1 ] ) <NEWLINE> adj [ inp [ 1 ] ] . append ( inp [ 0 ] ) <NEWLINE> <NL> <DEDENT> unsearched = set ( range ( N ) ) <NEWLINE> colors = { n : - 1 for n in range ( N ) } <NEWLINE> color = - 1 <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> if colors [ n ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> color += 1 <NEWLINE> start = n <NEWLINE> <NL> que = deque ( [ start ] ) <NEWLINE> while len ( que ) : <NEWLINE> <INDENT> q = que . pop ( ) <NEWLINE> next_ = [ i for i in adj [ q ] if colors [ i ] == - 1 ] <NEWLINE> que . extendleft ( next_ ) <NEWLINE> colors [ q ] = color <NEWLINE> <NL> <DEDENT> <DEDENT> Q = int ( input ( ) ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> question = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if colors [ question [ 0 ] ] == colors [ question [ 1 ] ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if h == 0 or h == H - 1 or w == 0 or w == W - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cnt = max ( cnt , uf . size ( i ) ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 1 <NEWLINE> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in l : <NEWLINE> <INDENT> s *= i <NEWLINE> if ( s > ( 10 ** 18 ) ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> count = [ 0 ] * ( 10 ** 7 ) <NEWLINE> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> for j in range ( 1 , 101 ) : <NEWLINE> <INDENT> for k in range ( 1 , 101 ) : <NEWLINE> <INDENT> count [ i * i + j * j + k * k + i * j + j * k + k * i - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( count [ i ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <NL> <INDENT> k = int ( input ( ) ) <NEWLINE> a = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> a [ 0 ] = 7 % k <NEWLINE> if a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> a [ i ] = ( a [ i - 1 ] * 10 + 7 ) % k <NEWLINE> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import defaultdict , deque , Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> counter = Counter ( ) <NEWLINE> nodes = defaultdict ( list ) <NEWLINE> edges = [ ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> nodes [ u ] . append ( ( v , i ) ) <NEWLINE> nodes [ v ] . append ( ( u , i ) ) <NEWLINE> edges . append ( ( u , v ) ) <NEWLINE> <NL> <DEDENT> K = 0 <NEWLINE> for node in nodes . values ( ) : <NEWLINE> <INDENT> K = max ( K , len ( node ) ) <NEWLINE> <NL> <DEDENT> checked = set ( ) <NEWLINE> queue = deque ( [ ( 1 , 0 ) ] ) <NEWLINE> edge_colors = [ 0 ] * N <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> u , uc = queue . popleft ( ) <NEWLINE> checked . add ( u ) <NEWLINE> color = 1 <NEWLINE> for v , e in nodes [ u ] : <NEWLINE> <INDENT> if v in checked : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if color == uc : <NEWLINE> <INDENT> color += 1 <NEWLINE> <DEDENT> edge_colors [ e ] = color <NEWLINE> queue . append ( ( v , color ) ) <NEWLINE> color += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( K ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> print ( edge_colors [ i ] ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if y % 2 == 0 and y >= 2 * x and y <= 4 * x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( S ) ) ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if a + i <= b : <NEWLINE> <INDENT> print ( a + i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( k - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if b - i > a + k - 1 : <NEWLINE> <INDENT> print ( b - i ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = A [ 0 ] <NEWLINE> <NL> for n in range ( 1 , N ) : <NEWLINE> <INDENT> ans = ans * A [ n ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lmax = 0 <NEWLINE> rmin = 1000000 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> lmax = max ( l , lmax ) <NEWLINE> rmin = min ( r , rmin ) <NEWLINE> <NL> <DEDENT> if rmin - lmax >= 0 : <NEWLINE> <INDENT> print ( rmin - lmax + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> s = input ( ) <NEWLINE> mod = 2019 <NEWLINE> dct = defaultdict ( int ) <NEWLINE> dct [ 0 ] = 1 <NEWLINE> x = 0 <NEWLINE> d = 1 <NEWLINE> for c in s [ : : - 1 ] : <NEWLINE> <INDENT> x = ( x + int ( c ) * d ) % mod <NEWLINE> d = d * 10 % mod <NEWLINE> dct [ x ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for v in dct . values ( ) : ans += v * ( v - 1 ) // 2 <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = 1 <NEWLINE> <NL> A_list . sort ( ) <NEWLINE> if A_list [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in range ( len ( A_list ) ) : <NEWLINE> <INDENT> s = s * A_list [ i ] <NEWLINE> if s > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def solve ( N , As ) : <NEWLINE> <INDENT> import math <NEWLINE> x = 1 if max ( As ) == 0 else math . ceil ( math . log2 ( max ( As ) ) ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> cnt = sum ( ( A >> i ) % 2 for A in As ) <NEWLINE> ans += ( cnt * ( N - cnt ) ) * pow ( 2 , i , mod ) <NEWLINE> ans = ans % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> As = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> solve ( N , As ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> num = list ( map ( int , ( input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <NL> flag = 1 <NEWLINE> if 0 in num : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> flag = 0 <NEWLINE> <NL> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if flag == 1 : <NEWLINE> <INDENT> ans *= num [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = b = 0 <NEWLINE> <NL> <NL> if x * 4 < y or x * 2 > y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if ( y - 2 * x ) % 2 == 0 : <NEWLINE> <INDENT> n = ( y - 2 * x ) / 2 <NEWLINE> if x - b >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> M = P [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if M >= P [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> M = P [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> XY = [ ] <NEWLINE> <NL> XY . append ( a * c ) <NEWLINE> XY . append ( a * d ) <NEWLINE> XY . append ( b * c ) <NEWLINE> XY . append ( b * d ) <NEWLINE> <NL> print ( max ( XY ) ) <NEWLINE>
n = input ( ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> sum += int ( n [ i ] ) <NEWLINE> <NL> <DEDENT> if sum % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from heapq import heappush , heappop <NEWLINE> <NL> def dij ( s , g , E ) : <NEWLINE> <INDENT> h = [ ] <NEWLINE> U = [ ] <NEWLINE> heappush ( h , ( 0 , s ) ) <NEWLINE> while h : <NEWLINE> <INDENT> v = heappop ( h ) <NEWLINE> if v [ 1 ] == g : <NEWLINE> <INDENT> if v [ 0 ] >= INF : print ( - 1 ) <NEWLINE> else : print ( v [ 0 ] ) <NEWLINE> break <NEWLINE> <DEDENT> U . append ( v [ 1 ] ) <NEWLINE> for e in E [ v [ 1 ] ] : <NEWLINE> <INDENT> if not e [ 0 ] in U : <NEWLINE> <INDENT> heappush ( h , ( v [ 0 ] + e [ 1 ] , e [ 0 ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : print ( - 1 ) <NEWLINE> <DEDENT> INF = 100000000 <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and k == 0 : break <NEWLINE> E = [ [ ] for i in range ( n ) ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if lst [ 0 ] == 0 : <NEWLINE> <INDENT> dij ( lst [ 1 ] - 1 , lst [ 2 ] - 1 , E ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> E [ lst [ 1 ] - 1 ] . append ( [ lst [ 2 ] - 1 , lst [ 3 ] ] ) <NEWLINE> E [ lst [ 2 ] - 1 ] . append ( [ lst [ 1 ] - 1 , lst [ 3 ] ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> aa = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> e = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> e [ a ] . append ( b ) <NEWLINE> e [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> dp = [ 10 ** 9 ] * ( n + 10 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> ans1 = [ 0 ] * n <NEWLINE> ans2 = [ 0 ] * n <NEWLINE> <NL> <NL> def dfs ( i = 0 , r = - 1 ) : <NEWLINE> <INDENT> global dp , ans1 , ans2 <NEWLINE> mi = 0 <NEWLINE> ma = n <NEWLINE> while mi != ma : <NEWLINE> <INDENT> mm = ( mi + ma ) // 2 <NEWLINE> if dp [ mm ] >= aa [ i ] : <NEWLINE> <INDENT> ma = mm <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mi = mm + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> be = dp [ mi ] <NEWLINE> dp [ mi ] = min ( dp [ mi ] , aa [ i ] ) <NEWLINE> ans1 [ i ] = mi <NEWLINE> ans2 [ i ] = max ( ans1 [ i ] , ans2 [ r ] ) <NEWLINE> <NL> for j in e [ i ] : <NEWLINE> <INDENT> if j == r : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( j , i ) <NEWLINE> <NL> <DEDENT> dp [ mi ] = be <NEWLINE> <NL> <NL> <DEDENT> dfs ( ) <NEWLINE> print ( <STRING> . join ( map ( str , ans2 ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> s = 0 <NEWLINE> for num in n : <NEWLINE> <INDENT> s += num <NEWLINE> s %= 9 <NEWLINE> <NL> <DEDENT> print ( <STRING> if s == 0 else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> X = int ( input ( ) ) <NEWLINE> <NL> for x in range ( 100000 ) : <NEWLINE> <INDENT> if 2 * x ** 5 == X : <NEWLINE> <INDENT> print ( x , - x ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for y in range ( x ) : <NEWLINE> <INDENT> if ( x ** 5 - y ** 5 ) == X : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if ( - x ** 5 + y ** 5 ) == X : <NEWLINE> <INDENT> print ( - y , - x ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> tmp = 0 <NEWLINE> y = 0 <NEWLINE> while tmp < X : <NEWLINE> <INDENT> tmp = x ** 5 + y ** 5 <NEWLINE> if tmp == X : <NEWLINE> <INDENT> print ( x , - y ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> y += 1 <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> lucas = [ 2 , 1 ] <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> lucas . append ( lucas [ i - 1 ] + lucas [ i - 2 ] ) <NEWLINE> <NL> <DEDENT> print ( lucas [ N ] ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import time <NEWLINE> import unittest <NEWLINE> from io import StringIO <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> sum = r * g * b <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( S ) ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k < len ( S ) and S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> sum -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <NL> <DEDENT> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def checkTLE ( self , input ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> <NL> <DEDENT> def debugIO ( self , input ) : <NEWLINE> <INDENT> stdin = sys . stdin <NEWLINE> sys . stdin = StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdin = stdin <NEWLINE> <NL> <DEDENT> def setUp ( self ) : <NEWLINE> <INDENT> self . startTime = time . time ( ) <NEWLINE> <NL> <DEDENT> def tearDown ( self ) : <NEWLINE> <INDENT> t = time . time ( ) - self . startTime <NEWLINE> print ( <STRING> % ( self . id ( ) , t ) , flush = True ) <NEWLINE> <NL> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> if <STRING> in locals ( ) : <NEWLINE> <INDENT> suite = unittest . TestLoader ( ) . loadTestsFromTestCase ( TestClass ) <NEWLINE> unittest . TextTestRunner ( verbosity = 0 ) . run ( suite ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> b . append ( a ) <NEWLINE> <NL> <NL> <NL> <DEDENT> c = set ( b ) <NEWLINE> <NL> print ( len ( c ) ) <NEWLINE>
def judge ( array ) : <NEWLINE> <INDENT> count = [ [ 0 for i in range ( 8 ) ] for i in range ( 8 ) ] <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> for j in array [ i ] : <NEWLINE> <INDENT> if int ( j ) == 1 : <NEWLINE> <INDENT> count [ i ] [ x ] += 1 <NEWLINE> <DEDENT> x += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> a = 0 <NEWLINE> p = [ ] <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> for j in range ( 8 ) : <NEWLINE> <INDENT> if count [ i ] [ j ] != 0 : <NEWLINE> <INDENT> p . append ( a ) <NEWLINE> <DEDENT> a += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if p [ 0 ] + 1 != p [ 1 ] : <NEWLINE> <INDENT> if p [ 0 ] + 8 * 3 == p [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if p [ 0 ] + 8 * 2 + 1 == p [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if p [ 0 ] + 1 == p [ 1 ] and p [ 1 ] + 1 == p [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if p [ 0 ] + 8 == p [ 2 ] and p [ 1 ] + 8 == p [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if p [ 0 ] + 8 == p [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> array = [ ] <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> array . append ( input ( ) ) <NEWLINE> <DEDENT> judge ( array ) <NEWLINE> input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> import itertools <NEWLINE> from functools import reduce <NEWLINE> <NL> <COMMENT> <NL> K = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> result = 0 <NEWLINE> for a , b in itertools . product ( range ( 1 , K + 1 ) , repeat = 2 ) : <NEWLINE> <INDENT> d = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> result += math . gcd ( d , c ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> index = 0 <NEWLINE> count = 0 <NEWLINE> while index < n : <NEWLINE> <INDENT> number = int ( input ( ) ) <NEWLINE> stock = [ ] <NEWLINE> devideN = 1 <NEWLINE> while devideN <= number : <NEWLINE> <INDENT> if len ( stock ) > 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif devideN == 10000 : <NEWLINE> <INDENT> stock . append ( devideN ) <NEWLINE> break <NEWLINE> <DEDENT> elif number % devideN == 0 : <NEWLINE> <INDENT> if devideN != 1 and devideN != number : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stock . append ( devideN ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> devideN += 1 <NEWLINE> <DEDENT> if len ( stock ) == 2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> index += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> M = 10 ** 6 <NEWLINE> is_ans_flag = [ 0 ] * ( M + 1 ) <NEWLINE> n_appeared_in_A = [ 0 ] * ( M + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> n_appeared_in_A [ a ] += 1 <NEWLINE> is_ans_flag [ a ] = 1 <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> if n_appeared_in_A [ a ] == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if n_appeared_in_A [ a ] >= 2 : <NEWLINE> <INDENT> is_ans_flag [ a ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , M + 1 ) : <NEWLINE> <INDENT> if a * i > M : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> is_ans_flag [ a * i ] = 0 <NEWLINE> <NL> <DEDENT> n_appeared_in_A [ a ] = - 1 <NEWLINE> <NL> <DEDENT> return sum ( is_ans_flag ) <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
residence = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> lines = [ input ( ) for i in range ( n ) ] <NEWLINE> for l in lines : <NEWLINE> <INDENT> k = list ( map ( int , l . split ( ) ) ) <NEWLINE> residence [ k [ 0 ] - 1 ] [ k [ 1 ] - 1 ] [ k [ 2 ] - 1 ] += k [ 3 ] <NEWLINE> if residence [ k [ 0 ] - 1 ] [ k [ 1 ] - 1 ] [ k [ 2 ] - 1 ] > 9 : residence [ k [ 0 ] - 1 ] [ k [ 1 ] - 1 ] [ k [ 2 ] - 1 ] = 9 <NEWLINE> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , residence [ b ] [ f ] ) ) ) <NEWLINE> <DEDENT> if b != 3 : print ( <STRING> * 20 ) <NEWLINE> <DEDENT>
n , m = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> h = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> route = [ 1 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> <NL> if h [ b ] >= h [ a ] : <NEWLINE> <INDENT> route [ a ] = 0 <NEWLINE> <DEDENT> if h [ a ] >= h [ b ] : <NEWLINE> <INDENT> route [ b ] = 0 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( sum ( route ) ) <NEWLINE>
from collections import deque <NEWLINE> import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> tele = list ( input ( ) . split ( ) ) <NEWLINE> tele = np . array ( [ int ( tele [ i ] ) for i in range ( N ) ] ) <NEWLINE> seen = set ( [ ] ) <NEWLINE> roop_in = deque ( [ ] ) <NEWLINE> now = 1 <NEWLINE> w_num = 0 <NEWLINE> <NL> while now not in seen and w_num < K : <NEWLINE> <INDENT> seen . add ( now ) <NEWLINE> roop_in . append ( now ) <NEWLINE> now = tele [ now - 1 ] <NEWLINE> w_num += 1 <NEWLINE> <NL> <DEDENT> if w_num == K : <NEWLINE> <INDENT> print ( now ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> roop_in_index = roop_in . index ( now ) <NEWLINE> roop = list ( roop_in ) [ roop_in_index : ] <NEWLINE> roop_len = len ( roop ) <NEWLINE> last = ( K - ( w_num - 1 ) ) % roop_len <NEWLINE> print ( roop [ last - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = 26 <NEWLINE> b = 1 <NEWLINE> import math <NEWLINE> import string <NEWLINE> array = list ( string . ascii_lowercase ) <NEWLINE> while n > a : <NEWLINE> <INDENT> b += 1 <NEWLINE> a += 26 ** b <NEWLINE> <DEDENT> if b == 1 : <NEWLINE> <INDENT> print ( array [ n - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = b - 1 <NEWLINE> d = n - a <NEWLINE> brray = [ 0 ] <NEWLINE> crray = [ d ] <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> brray . append ( math . ceil ( crray [ i ] / ( 26 ** ( c - i ) ) ) ) <NEWLINE> crray . append ( crray [ i ] % ( 26 ** ( c - i ) ) ) <NEWLINE> <DEDENT> ans = array [ brray [ 1 ] - 1 ] <NEWLINE> if c > 1 : <NEWLINE> <INDENT> for j in range ( 2 , b ) : <NEWLINE> <INDENT> ans = ans + array [ brray [ j ] - 1 ] <NEWLINE> <DEDENT> <DEDENT> ans = ans + array [ crray [ c ] - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> print ( math . factorial ( n ) % ( ( 10 ** 9 ) + 7 ) ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> lst0 = [ 0 ] * N <NEWLINE> lst1 = [ 0 ] * N <NEWLINE> lst0 [ 0 ] = 1 <NEWLINE> lst1 [ 0 ] = 1 <NEWLINE> c = S . count ( <STRING> ) <NEWLINE> m0 = int ( S [ - 1 ] ) <NEWLINE> m1 = int ( S [ - 1 ] ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> lst0 [ i ] += ( lst0 [ i - 1 ] * 2 ) % ( c + 1 ) <NEWLINE> if c == 1 : lst1 [ i ] = 0 <NEWLINE> else : lst1 [ i ] += ( lst1 [ i - 1 ] * 2 ) % ( c - 1 ) <NEWLINE> m0 += lst0 [ i ] * int ( S [ N - 1 - i ] ) <NEWLINE> m0 %= c + 1 <NEWLINE> m1 += ( lst1 [ i ] * int ( S [ N - 1 - i ] ) ) <NEWLINE> if c == 1 : m1 = 0 <NEWLINE> else : m1 %= c - 1 <NEWLINE> <NL> <DEDENT> memo = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> def calc ( a ) : <NEWLINE> <INDENT> global ans , memo <NEWLINE> if a == 0 : return ans <NEWLINE> ans += 1 <NEWLINE> if memo [ a ] != 0 : <NEWLINE> <INDENT> b = memo [ a ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = bin ( a ) . count ( <STRING> ) <NEWLINE> memo [ a ] = b <NEWLINE> <DEDENT> return calc ( a % b ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> b = c - 1 <NEWLINE> if b == 0 : a = 0 <NEWLINE> else : a = max ( ( m1 - lst1 [ N - 1 - i ] ) % b , ( m1 - lst1 [ N - 1 - i ] + b ) % b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = c + 1 <NEWLINE> a = ( m0 + lst0 [ N - 1 - i ] ) % b <NEWLINE> <DEDENT> if b == 0 : print ( 0 ) <NEWLINE> elif a == 0 : print ( 1 ) <NEWLINE> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> print ( calc ( a ) ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += gcd ( tmp , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> M = 10 ** 9 + 7 <NEWLINE> As = sum ( A ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> As = As - A [ i ] <NEWLINE> s += ( A [ i ] * As ) % M <NEWLINE> <DEDENT> print ( s % M ) <NEWLINE>
d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = [ 0 ] * 26 <NEWLINE> ans = [ ] <NEWLINE> for i in range ( 1 , d + 1 ) : <NEWLINE> <INDENT> num1 = 1 <NEWLINE> num2 = - ( 10 ** 100 ) <NEWLINE> num3 = [ 0 ] * 26 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> num3 [ j ] = - 1 * ( ( i - num [ j ] ) * c [ j ] ) <NEWLINE> <DEDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> num5 = s [ j ] - num3 [ j ] <NEWLINE> if num5 > num2 : <NEWLINE> <INDENT> num1 = j + 1 <NEWLINE> num2 = num5 <NEWLINE> <DEDENT> <DEDENT> ans . append ( num1 ) <NEWLINE> num [ num1 - 1 ] = i <NEWLINE> <DEDENT> for i in range ( d ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for d in range ( 60 ) : <NEWLINE> <INDENT> mask = 1 << d <NEWLINE> num1 = len ( [ 1 for A in As if A & mask ] ) <NEWLINE> ans += num1 * ( N - num1 ) * mask <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> solve ( ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( M ) ] <NEWLINE> L = [ - 1 for _ in range ( N ) ] <NEWLINE> p = 0 <NEWLINE> if A == [ ] : <NEWLINE> <INDENT> A = [ 0 ] <NEWLINE> <DEDENT> if 1 == A [ p ] : <NEWLINE> <INDENT> L [ 0 ] = 0 <NEWLINE> if p < M - 1 : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> L [ 0 ] = 1 <NEWLINE> <DEDENT> if N > 1 : <NEWLINE> <INDENT> if 2 == A [ p ] : <NEWLINE> <INDENT> L [ 1 ] = 0 <NEWLINE> if p < M - 1 : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> L [ 1 ] = L [ 0 ] + 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 2 , N ) : <NEWLINE> <INDENT> if i + 1 == A [ p ] : <NEWLINE> <INDENT> L [ i ] = 0 <NEWLINE> if p < M - 1 : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> L [ i ] = L [ i - 1 ] + L [ i - 2 ] <NEWLINE> <DEDENT> <DEDENT> print ( L [ - 1 ] % MOD ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> l = [ - 1 ] <NEWLINE> i = 0 <NEWLINE> <NL> while i < len ( s ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> l . append ( l [ i ] + 1 ) <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while s [ i + cnt ] == <STRING> : <NEWLINE> <INDENT> if i + cnt == len ( s ) - 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> if l [ i ] < cnt : <NEWLINE> <INDENT> l . append ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( l [ i ] + 1 ) <NEWLINE> <DEDENT> i += cnt <NEWLINE> cnt -= 1 <NEWLINE> while cnt != - 1 : <NEWLINE> <INDENT> l . append ( cnt ) <NEWLINE> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> if s [ len ( s ) - 1 ] == <STRING> : <NEWLINE> <INDENT> l . append ( l [ i ] + 1 ) <NEWLINE> <DEDENT> del l [ 0 ] <NEWLINE> ans = sum ( l ) <NEWLINE> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> T = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> j = M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while a [ i ] + b [ j ] > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
def search ( x , y , m ) : <NEWLINE> <INDENT> if x < 0 or y < 0 or x >= len ( m [ 0 ] ) or y >= len ( m ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if m [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> m [ y ] [ x ] = <STRING> <NEWLINE> return 1 + search ( x + 1 , y , m ) + search ( x - 1 , y , m ) + search ( x , y + 1 , m ) + search ( x , y - 1 , m ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if w == 0 : break <NEWLINE> room = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> tmp = list ( input ( ) ) <NEWLINE> room . append ( tmp [ : w ] ) <NEWLINE> if <STRING> in tmp : <NEWLINE> <INDENT> y = i <NEWLINE> x = tmp . index ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( search ( x , y , room ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = { } <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if not i in A : <NEWLINE> <INDENT> A [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> s = 0 <NEWLINE> for k , v in A . items ( ) : <NEWLINE> <INDENT> s += k * v <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b in A : <NEWLINE> <INDENT> s = s - ( b - c ) * A [ b ] <NEWLINE> if not c in A : <NEWLINE> <INDENT> A [ c ] = A [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ c ] += A [ b ] <NEWLINE> <DEDENT> A [ b ] = 0 <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Si = input ( ) <NEWLINE> ans . add ( Si ) <NEWLINE> <DEDENT> print ( len ( ans ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> G = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ x ] += [ y ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> dp = [ - 1 ] * ( N + 1 ) <NEWLINE> <NL> <NL> def func ( n ) : <NEWLINE> <INDENT> if dp [ n ] != - 1 : <NEWLINE> <INDENT> return dp [ n ] <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for m in G [ n ] : <NEWLINE> <INDENT> cnt = max ( cnt , func ( m ) + 1 ) <NEWLINE> <DEDENT> dp [ n ] = cnt <NEWLINE> return cnt <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> func ( i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( max ( dp ) ) <NEWLINE>
import collections <NEWLINE> import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> m = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> c = [ ] <NEWLINE> d = [ ] <NEWLINE> frac = [ ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> m += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if a == 0 : <NEWLINE> <INDENT> frac . append ( <STRING> ) <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> frac . append ( ( <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gcd = abs ( math . gcd ( a , b ) ) <NEWLINE> sign = 1 if a * b > 0 else - 1 <NEWLINE> a = sign * abs ( a ) // gcd <NEWLINE> b = abs ( b ) // gcd <NEWLINE> frac . append ( <STRING> . format ( a , b ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> frac = collections . Counter ( frac ) <NEWLINE> <NL> def inverse ( key ) : <NEWLINE> <INDENT> if key == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif key == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif key [ 0 ] != <STRING> : <NEWLINE> <INDENT> a , b = key . split ( <STRING> ) <NEWLINE> return <STRING> . format ( b , a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a , b = key [ 1 : ] . split ( <STRING> ) <NEWLINE> return <STRING> . format ( b , a ) <NEWLINE> <NL> <DEDENT> <DEDENT> for key , value in frac . items ( ) : <NEWLINE> <INDENT> if key [ 0 ] == <STRING> or key [ 0 ] == <STRING> : continue <NEWLINE> if frac [ inverse ( key ) ] > 0 : <NEWLINE> <INDENT> c . append ( value ) <NEWLINE> d . append ( frac [ inverse ( key ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = pow ( 2 , n - sum ( c ) - sum ( d ) , mod ) <NEWLINE> for i , j in zip ( c , d ) : <NEWLINE> <INDENT> tmp = ( pow ( 2 , i , mod ) + pow ( 2 , j , mod ) - 1 ) % mod <NEWLINE> ans = ans * tmp % mod <NEWLINE> <DEDENT> ans = ( ans - 1 + m ) % mod <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> if N % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> def power_func ( a , b , p ) : <NEWLINE> <INDENT> if b == 0 : return 1 <NEWLINE> if b % 2 == 0 : <NEWLINE> <INDENT> d = power_func ( a , b // 2 , p ) <NEWLINE> return d * d % p <NEWLINE> <DEDENT> if b % 2 == 1 : <NEWLINE> <INDENT> return ( a * power_func ( a , b - 1 , p ) ) % p <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> <DEDENT> mod = 998244353 <NEWLINE> g1 = [ 1 , 1 ] <NEWLINE> g2 = [ 1 , 1 ] <NEWLINE> inverse = [ 0 , 1 ] <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> <NL> for x in range ( k + 1 ) : <NEWLINE> <INDENT> s += ( m * power_func ( m - 1 , n - 1 - x , 998244353 ) * cmb ( n - 1 , x , 998244353 ) ) % 998244353 <NEWLINE> s %= 998244353 <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> num = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> num += a [ i ] <NEWLINE> ans += a [ i + 1 ] * num <NEWLINE> <NL> <DEDENT> print ( ans % 1000000007 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> al = [ 0 for i in range ( n ) ] <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> al [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( al [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import bisect <NEWLINE> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for j in range ( n ) ] <NEWLINE> <NL> dp = [ a [ 0 ] ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if dp [ - 1 ] < a [ i ] : <NEWLINE> <INDENT> dp . append ( a [ i ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> dp [ bisect . bisect_left ( dp , a [ i ] ) ] = a [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( len ( dp ) ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a1 = [ ] <NEWLINE> a2 = [ ] <NEWLINE> for i , a in enumerate ( alist ) : <NEWLINE> <INDENT> a2 . append ( i - a ) <NEWLINE> a1 . append ( i + a ) <NEWLINE> <DEDENT> aa = Counter ( a2 ) <NEWLINE> count = 0 <NEWLINE> for k in a1 : <NEWLINE> <INDENT> count += aa . get ( k , 0 ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
ans = 0 <NEWLINE> S = input ( ) <NEWLINE> a = len ( S ) <NEWLINE> k = 0 <NEWLINE> c = dict ( ) <NEWLINE> mod = 2019 <NEWLINE> s = 1 <NEWLINE> c [ 0 ] = 1 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> k += ( s * int ( S [ a - i - 1 ] ) ) <NEWLINE> k %= mod <NEWLINE> s *= 10 <NEWLINE> s %= mod <NEWLINE> if k in c : <NEWLINE> <INDENT> c [ k ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ k ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in c : <NEWLINE> <INDENT> ans += c [ i ] * ( c [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
( n , m ) , * a = [ map ( int , t . split ( ) ) for t in open ( 0 ) ] <NEWLINE> p = [ - 1 ] * - ~ n <NEWLINE> for a in a : <NEWLINE> <INDENT> a , b = sorted ( map ( r : = lambda x : x * ( p [ x ] < 0 ) or r ( p [ x ] ) , a ) , key = p . __getitem__ ) <NEWLINE> if a - b : p [ a ] += p [ b ] ; p [ b ] = a <NEWLINE> <DEDENT> print ( sum ( i < 0 for i in p ) - 2 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ww = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def chk ( p ) : <NEWLINE> <INDENT> c = 1 <NEWLINE> s = 0 <NEWLINE> for w in ww : <NEWLINE> <INDENT> if w > p : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if s + w <= p : <NEWLINE> <INDENT> s += w <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> s = w <NEWLINE> <DEDENT> if c > k : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> def search ( l , r ) : <NEWLINE> <INDENT> if r - l < 10 : <NEWLINE> <INDENT> for i in range ( l , r ) : <NEWLINE> <INDENT> if chk ( i ) : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> m = ( l + r ) // 2 <NEWLINE> if chk ( m ) : <NEWLINE> <INDENT> return search ( l , m + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return search ( m , r ) <NEWLINE> <DEDENT> <DEDENT> print ( search ( 0 , 2 ** 30 ) ) <NEWLINE>
import numpy as np <NEWLINE> from itertools import combinations <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> memo = np . zeros ( ( k + 1 , k + 1 ) , int ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( i , k + 1 ) : <NEWLINE> <INDENT> tmp = np . gcd ( i , j ) <NEWLINE> memo [ i ] [ j ] = tmp <NEWLINE> memo [ j ] [ i ] = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> res += i <NEWLINE> <NL> <DEDENT> for c in combinations ( range ( 1 , k + 1 ) , 2 ) : <NEWLINE> <INDENT> ab = memo [ c [ 0 ] , c [ 1 ] ] <NEWLINE> res += ab * 6 <NEWLINE> <NL> <DEDENT> for c in combinations ( range ( 1 , k + 1 ) , 3 ) : <NEWLINE> <INDENT> ab = memo [ c [ 0 ] , c [ 1 ] ] <NEWLINE> abc = memo [ ab , c [ 2 ] ] <NEWLINE> res += abc * 6 <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
S = list ( input ( ) ) <NEWLINE> one = S . count ( <STRING> ) <NEWLINE> zero = S . count ( <STRING> ) <NEWLINE> <NL> print ( 2 * min ( one , zero ) ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> cnt_init = X . count ( <STRING> ) <NEWLINE> x = int ( X , 2 ) <NEWLINE> a = x % ( cnt_init + 1 ) <NEWLINE> if cnt_init - 1 != 0 : <NEWLINE> <INDENT> b = x % ( cnt_init - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> cnt = cnt_init + 1 <NEWLINE> y = ( a + pow ( 2 , n - i - 1 , cnt ) ) % cnt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = cnt_init - 1 <NEWLINE> if cnt == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> y = ( b - pow ( 2 , n - i - 1 , cnt ) ) % cnt <NEWLINE> <NL> <DEDENT> res = 1 <NEWLINE> while y : <NEWLINE> <INDENT> cnt = bin ( y ) . count ( <STRING> ) <NEWLINE> y %= cnt <NEWLINE> res += 1 <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( a / b ) , a % b , <STRING> % ( a / b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> dishes = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> points = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bonuses = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> score = 0 <NEWLINE> prev = 0 <NEWLINE> for i in dishes : <NEWLINE> <INDENT> score += points [ i - 1 ] <NEWLINE> if prev > 0 : <NEWLINE> <INDENT> if i == prev + 1 : score += bonuses [ i - 2 ] <NEWLINE> <DEDENT> prev = i <NEWLINE> <NL> <DEDENT> print ( score ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = [ 0 ] * n <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> res [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for num in res : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> As = set ( [ int ( input ( ) ) for _ in range ( m ) ] ) <NEWLINE> mod = 1000000007 <NEWLINE> <NL> Steps = [ 0 ] * ( n + 1 ) <NEWLINE> Steps [ 0 ] = 1 <NEWLINE> if 1 not in As : <NEWLINE> <INDENT> Steps [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i in As : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> Steps [ i ] = Steps [ i - 1 ] + Steps [ i - 2 ] <NEWLINE> <DEDENT> ans = Steps [ - 1 ] % mod <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def calc ( ) : <NEWLINE> <INDENT> _ = int ( sys . stdin . readline ( ) ) <NEWLINE> xs = [ int ( x ) for x in sys . stdin . readline ( ) . split ( <STRING> ) ] <NEWLINE> for x in xs : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> r = 1 <NEWLINE> m = 10 ** 18 <NEWLINE> for x in xs : <NEWLINE> <INDENT> r *= x <NEWLINE> if r > m : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return r <NEWLINE> <NL> <DEDENT> print ( calc ( ) ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> num = 0 <NEWLINE> <NL> x = n // ( a + b ) <NEWLINE> num += ( x * a ) <NEWLINE> <NL> y = n % ( a + b ) <NEWLINE> <NL> if y <= a : <NEWLINE> <INDENT> num += y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num += a <NEWLINE> <NL> <DEDENT> print ( num ) <NEWLINE>
lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i , data in enumerate ( sorted ( lst ) ) : <NEWLINE> <INDENT> if not i == len ( lst ) - 1 : <NEWLINE> <INDENT> print ( <STRING> . format ( data ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( data ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> dic1 = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> temp = input ( ) <NEWLINE> dic1 . setdefault ( temp , 0 ) <NEWLINE> dic1 [ temp ] += 1 <NEWLINE> <DEDENT> fmax = max ( dic1 . values ( ) ) <NEWLINE> mflst = [ ] <NEWLINE> ks = list ( dic1 . keys ( ) ) <NEWLINE> for i in dic1 : <NEWLINE> <INDENT> if dic1 [ i ] == fmax : <NEWLINE> <INDENT> mflst . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> mflst . sort ( ) <NEWLINE> for i in range ( len ( mflst ) ) : <NEWLINE> <INDENT> print ( mflst [ i ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> <COMMENT> <NL> N , M , X = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> CA = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> CA [ i ] = k [ : ] <NEWLINE> <DEDENT> CA = np . array ( CA ) <NEWLINE> <COMMENT> <NL> cnt = ( 10 ** 5 ) * N + 1 <NEWLINE> <NL> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> score = np . zeros ( M + 1 ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> score += CA [ j ] <NEWLINE> <DEDENT> <DEDENT> for k in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if score [ k ] < X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if score [ 0 ] < cnt : <NEWLINE> <INDENT> cnt = score [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if cnt != ( 10 ** 5 ) * N + 1 : <NEWLINE> <INDENT> print ( int ( cnt ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> x *= i <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if A . count ( 0 ) >= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = Counter ( A ) <NEWLINE> <NL> A = list ( set ( A ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> <NL> C = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if C [ a ] == 0 : <NEWLINE> <INDENT> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if a * i > 10 ** 6 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> C [ a * i ] = 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> if cnt [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x = input ( ) <NEWLINE> scount , tcount , c = 0 , 0 , 0 <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> if x [ c ] == <STRING> : <NEWLINE> <INDENT> scount += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if scount > 0 : <NEWLINE> <INDENT> scount -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tcount += 1 <NEWLINE> <DEDENT> <DEDENT> c += 1 <NEWLINE> <DEDENT> print ( tcount * 2 ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( a ) <NEWLINE> for _ in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( c [ _ ] ) <NEWLINE> <NL> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> kk = k - a <NEWLINE> for i in range ( 1 ) : <NEWLINE> <INDENT> if kk < 0 : <NEWLINE> <INDENT> ans = k <NEWLINE> k = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a <NEWLINE> k = k - a <NEWLINE> <DEDENT> kk = k - b <NEWLINE> if kk < 0 : <NEWLINE> <INDENT> k = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = k - b <NEWLINE> <NL> <DEDENT> kk = k - c <NEWLINE> <NL> if kk < 0 : <NEWLINE> <INDENT> ans = ans - k <NEWLINE> <DEDENT> elif kk >= 0 : <NEWLINE> <INDENT> ans = ans - c <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import bisect , collections , copy , heapq , itertools , math , numpy , string <NEWLINE> <COMMENT> <NL> import sys <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> N , M = LI ( ) <NEWLINE> AB = [ LI ( ) for _ in range ( M ) ] <NEWLINE> path = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> mp = [ ] <NEWLINE> ans = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for ab in AB : <NEWLINE> <INDENT> a = ab [ 0 ] <NEWLINE> b = ab [ 1 ] <NEWLINE> path [ a ] . append ( b ) <NEWLINE> path [ b ] . append ( a ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> def bfs ( tree , st , endlist , endnum ) : <NEWLINE> <INDENT> queue = collections . deque ( ) <NEWLINE> queue . append ( [ - 1 , st ] ) <NEWLINE> endlist [ st ] -= 1 <NEWLINE> now = [ - 1 , - 1 , - 1 ] <NEWLINE> pre = [ ] <NEWLINE> depth = 0 <NEWLINE> histind = - 1 <NEWLINE> node = - 1 <NEWLINE> hist = [ ] <NEWLINE> res = [ ] <NEWLINE> allres = [ ] <NEWLINE> while queue : <NEWLINE> <INDENT> pre = now [ : ] <NEWLINE> now = queue . popleft ( ) <NEWLINE> histind = now [ 0 ] <NEWLINE> node = now [ 1 ] <NEWLINE> hist . append ( [ histind , node ] ) <NEWLINE> <COMMENT> <NL> res = [ node , hist [ histind ] [ 1 ] ] <NEWLINE> allres . append ( res [ : : ] ) <NEWLINE> endnum -= 1 <NEWLINE> if endnum == 0 : <NEWLINE> <INDENT> return allres <NEWLINE> <DEDENT> for v in path [ node ] : <NEWLINE> <INDENT> if endlist [ v ] > 0 : <NEWLINE> <INDENT> queue . append ( [ len ( hist ) - 1 , v ] ) <NEWLINE> <COMMENT> <NL> endlist [ v ] -= 1 <NEWLINE> <DEDENT> <DEDENT> continue <NEWLINE> <DEDENT> return None <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> result = bfs ( path , 1 , [ 1 ] * ( N + 1 ) , N ) <NEWLINE> <COMMENT> <NL> if result is None : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> execnum = N <NEWLINE> maxlen = len ( result [ len ( result ) - 1 ] ) <NEWLINE> for i in result : <NEWLINE> <COMMENT> <NL> <INDENT> if ans [ i [ 0 ] ] == 0 : <NEWLINE> <INDENT> ans [ i [ 0 ] ] = i [ 1 ] <NEWLINE> execnum -= 1 <NEWLINE> if execnum == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in ans [ 2 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> H , W , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> bomb = [ tuple ( map ( lambda x : int ( x ) - 1 , s . split ( ) ) ) for s in readlines ( ) ] <NEWLINE> X = [ 0 ] * H <NEWLINE> Y = [ 0 ] * W <NEWLINE> for h , w in bomb : <NEWLINE> <INDENT> X [ h ] += 1 <NEWLINE> Y [ w ] += 1 <NEWLINE> <DEDENT> maxX = max ( X ) <NEWLINE> maxY = max ( Y ) <NEWLINE> <NL> R = [ h for h , x in enumerate ( X ) if x == maxX ] <NEWLINE> C = [ w for w , y in enumerate ( Y ) if y == maxY ] <NEWLINE> <NL> bomb = set ( bomb ) <NEWLINE> for r in R : <NEWLINE> <INDENT> for c in C : <NEWLINE> <INDENT> if ( r , c ) not in bomb : <NEWLINE> <INDENT> print ( maxX + maxY ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( maxX + maxY - 1 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> A = [ ( i + 1 , a ) for i , a in enumerate ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> A = sorted ( A , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> dp = [ [ - INF ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 0 <NEWLINE> <NL> for s in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for l in range ( s + 1 ) : <NEWLINE> <INDENT> r = s - l <NEWLINE> dp [ l ] [ r ] = max ( dp [ l - 1 ] [ r ] + A [ s - 1 ] [ 1 ] * abs ( A [ s - 1 ] [ 0 ] - l ) , dp [ l ] [ r - 1 ] + A [ s - 1 ] [ 1 ] * abs ( N - r + 1 - A [ s - 1 ] [ 0 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for m in range ( N ) : <NEWLINE> <INDENT> if ( dp [ m ] [ N - m ] > ans ) : <NEWLINE> <INDENT> ans = dp [ m ] [ N - m ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> chk1 = [ 0 ] * 10 <NEWLINE> chk2 = [ 0 ] * 100 <NEWLINE> l = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if chk1 [ int ( s [ i ] ) ] == 0 : <NEWLINE> <INDENT> chk1 [ int ( s [ i ] ) ] = 1 <NEWLINE> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> x = s [ i ] + s [ j ] <NEWLINE> if chk2 [ int ( x ) ] == 0 : <NEWLINE> <INDENT> chk2 [ int ( x ) ] = 1 <NEWLINE> if x in l : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( x ) <NEWLINE> ans += len ( set ( s [ j + 1 : ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> while x % y != 0 : <NEWLINE> <INDENT> tmp = y <NEWLINE> y = x % y <NEWLINE> x = tmp <NEWLINE> <DEDENT> print ( y ) <NEWLINE> <NL>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> upper = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> def counting ( x ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( 1 , math . ceil ( x / 2 ) ) : <NEWLINE> <INDENT> if s [ x - 1 ] != s [ x - 1 - i ] and s [ x - 1 - i ] != s [ x - 1 - 2 * i ] and s [ x - 1 - 2 * i ] != s [ x - 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 0 <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> if n >= 3 : <NEWLINE> <INDENT> minus = [ 0 ] * ( n + 1 ) <NEWLINE> if s [ 0 ] != s [ 1 ] and s [ 1 ] != s [ 2 ] and s [ 2 ] != s [ 0 ] : <NEWLINE> <INDENT> minus [ 3 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus [ 3 ] = 0 <NEWLINE> <DEDENT> for i in range ( 3 , n ) : <NEWLINE> <INDENT> minus [ i + 1 ] = minus [ i ] + counting ( i + 1 ) <NEWLINE> <DEDENT> print ( int ( upper - minus [ n ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( 0 ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( int ( input ( ) ) for _ in range ( N ) ) <NEWLINE> s = set ( ) <NEWLINE> for i in A : <NEWLINE> <INDENT> if i not in s : <NEWLINE> <INDENT> s . add ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . remove ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( s ) ) <NEWLINE>
import collections <NEWLINE> import sys <NEWLINE> from functools import lru_cache <NEWLINE> sys . setrecursionlimit ( int ( 10 ** 9 ) ) <NEWLINE> n , m = [ int ( i ) for i in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> edges = collections . defaultdict ( list ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s , d = [ int ( i ) for i in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> edges [ s - 1 ] . append ( d - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> maxPath = 0 <NEWLINE> @ lru_cache ( None ) <NEWLINE> def dfs ( node ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in edges [ node ] : <NEWLINE> <INDENT> ans = max ( ans , dfs ( i ) + 1 ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> maxPath = max ( dfs ( i ) , maxPath ) <NEWLINE> <DEDENT> print ( maxPath ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> for a in range ( 1 , 120 ) : <NEWLINE> <INDENT> for b in range ( - a , a ) : <NEWLINE> <INDENT> if pow ( a , 5 ) - pow ( b , 5 ) == x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if pow ( a , 5 ) - pow ( b , 5 ) == x : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> i = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i >= 0 : <NEWLINE> <INDENT> i = i * a [ j ] <NEWLINE> <DEDENT> if i > 10 ** 18 : <NEWLINE> <INDENT> i = - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( int ( i ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x1 , y1 , x2 , y2 = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> v1 = x1 * ( w + 1 ) + y1 <NEWLINE> v2 = x2 * ( w + 1 ) + y2 <NEWLINE> C = <STRING> . join ( input ( ) . rstrip ( ) + <STRING> for _ in range ( h ) ) <NEWLINE> dist = [ - 1 if c == <STRING> else 10 ** 10 for c in C ] <NEWLINE> ans = 0 <NEWLINE> que = deque ( ) <NEWLINE> que . append ( v1 ) <NEWLINE> dist [ v1 ] = 0 <NEWLINE> while que : <NEWLINE> <INDENT> v = que . popleft ( ) <NEWLINE> if v == v2 : <NEWLINE> <INDENT> print ( dist [ v2 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> d = dist [ v ] + 1 <NEWLINE> for dr in ( - ( w + 1 ) , - 1 , w + 1 , 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> nv = v + dr * i <NEWLINE> if 0 <= nv < h * ( w + 1 ) : <NEWLINE> <INDENT> if dist [ nv ] > d : <NEWLINE> <INDENT> dist [ nv ] = d <NEWLINE> que . append ( nv ) <NEWLINE> <DEDENT> elif dist [ nv ] == d : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for i in range ( - 120 , 120 ) : <NEWLINE> <INDENT> for j in range ( - 120 , 120 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ K + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import copy <NEWLINE> import random <NEWLINE> import bisect <COMMENT> <NEWLINE> import fractions <COMMENT> <NEWLINE> import math <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( mod ) <COMMENT> <NEWLINE> <NL> d = collections . deque ( ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = LI ( ) <NEWLINE> <NL> A_ii = copy . deepcopy ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A_ii [ i ] += i <NEWLINE> <DEDENT> dic_A_ii = collections . Counter ( A_ii ) <NEWLINE> <NL> A_jj = copy . deepcopy ( A ) <NEWLINE> <NL> for j in range ( N ) : <NEWLINE> <INDENT> A_jj [ j ] = - 1 * A_jj [ j ] + j <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> dic_A_jj = collections . Counter ( A_jj ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> for ii_key in dic_A_ii . keys ( ) : <NEWLINE> <INDENT> ans += dic_A_jj [ ii_key ] * dic_A_ii [ ii_key ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> if ans > ( 10 ** 18 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans > ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> pFlag = True <NEWLINE> mFlag = True <NEWLINE> for j in range ( len ( p ) ) : <NEWLINE> <INDENT> if p [ j ] == x + i : <NEWLINE> <INDENT> pFlag = False <NEWLINE> <DEDENT> if p [ j ] == x - i : <NEWLINE> <INDENT> mFlag = False <NEWLINE> <DEDENT> <DEDENT> if mFlag : <NEWLINE> <INDENT> a = ( - 1 ) * i <NEWLINE> break <NEWLINE> <DEDENT> if pFlag : <NEWLINE> <INDENT> a = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( x + a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for num in A : <NEWLINE> <INDENT> ans *= num <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in L : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for l in L : <NEWLINE> <INDENT> ans *= l <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> C = input ( ) <NEWLINE> <NL> l , r = 0 , N - 1 <NEWLINE> ans = 0 <NEWLINE> while l < r : <NEWLINE> <INDENT> if C [ l ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> elif C [ r ] == <STRING> : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> l += 1 <NEWLINE> r -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> l = 0 <NEWLINE> r = n <NEWLINE> t = T [ i ] <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> m = ( r + l ) // 2 <NEWLINE> if ( S [ m ] > t ) : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = m <NEWLINE> <DEDENT> <DEDENT> if ( S [ l ] == T [ i ] ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> code = list ( set ( list ( S ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in code : <NEWLINE> <INDENT> for j in code : <NEWLINE> <INDENT> for k in code : <NEWLINE> <INDENT> count = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if count == 0 : <NEWLINE> <INDENT> if s == i : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> elif count == 1 : <NEWLINE> <INDENT> if s == j : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> elif count == 2 : <NEWLINE> <INDENT> if s == k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count == 3 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = i + 1 <NEWLINE> xx = x * x <NEWLINE> if x * x >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> y = j + 1 <NEWLINE> yy = y * y <NEWLINE> if xx + yy + x * y >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for k in range ( n ) : <NEWLINE> <INDENT> z = k + 1 <NEWLINE> zz = z * z <NEWLINE> kotae = xx + yy + zz + x * y + y * z + z * x <NEWLINE> if kotae > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans [ kotae - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def solve ( N : int , S : str ) : <NEWLINE> <INDENT> rest_r = [ ] <NEWLINE> rest_g = [ ] <NEWLINE> rest_b = [ ] <NEWLINE> <NL> c_r = 0 <NEWLINE> c_g = 0 <NEWLINE> c_b = 0 <NEWLINE> <NL> i_r = [ ] <NEWLINE> i_g = [ ] <NEWLINE> i_b = [ ] <NEWLINE> <NL> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> c_r += 1 <NEWLINE> i_r . append ( i ) <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> c_g += 1 <NEWLINE> i_g . append ( i ) <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> c_b += 1 <NEWLINE> i_b . append ( i ) <NEWLINE> <DEDENT> rest_r . append ( c_r ) <NEWLINE> rest_g . append ( c_g ) <NEWLINE> rest_b . append ( c_b ) <NEWLINE> <NL> <DEDENT> rest_r . reverse ( ) <NEWLINE> rest_g . reverse ( ) <NEWLINE> rest_b . reverse ( ) <NEWLINE> <NL> i_r . reverse ( ) <NEWLINE> i_g . reverse ( ) <NEWLINE> i_b . reverse ( ) <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> <COMMENT> <NL> for r in i_r : <NEWLINE> <INDENT> for g in i_g : <NEWLINE> <INDENT> i_max = max ( r , g ) <NEWLINE> sum += rest_b [ i_max ] <NEWLINE> i = i_max + abs ( g - r ) <NEWLINE> if i < N and S [ i ] == <STRING> : <NEWLINE> <INDENT> sum -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for r in i_r : <NEWLINE> <INDENT> for g in i_b : <NEWLINE> <INDENT> i_max = max ( r , g ) <NEWLINE> sum += rest_g [ i_max ] <NEWLINE> i = i_max + abs ( g - r ) <NEWLINE> if i < N and S [ i ] == <STRING> : <NEWLINE> <INDENT> sum -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for r in i_g : <NEWLINE> <INDENT> for g in i_b : <NEWLINE> <INDENT> i_max = max ( r , g ) <NEWLINE> sum += rest_r [ i_max ] <NEWLINE> i = i_max + abs ( g - r ) <NEWLINE> if i < N and S [ i ] == <STRING> : <NEWLINE> <INDENT> sum -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> S = next ( tokens ) <COMMENT> <NEWLINE> solve ( N , S ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> * w ) <NEWLINE> for i in range ( h - 2 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( w - 2 ) + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * w ) <NEWLINE> print ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> z = 1 <NEWLINE> while not ( z * ( z + 1 ) <= 2 * x < ( z + 1 ) * ( z + 2 ) ) : <NEWLINE> <INDENT> z += 1 <NEWLINE> <DEDENT> return z <NEWLINE> <NL> <DEDENT> x = [ - 1 ] * ( 10 ** 6 + 1 ) <COMMENT> <NEWLINE> x [ 0 ] = 0 <NEWLINE> x [ 1 ] = 1 <NEWLINE> i = 2 <NEWLINE> prime = [ ] <NEWLINE> while i <= 10 ** 6 : <NEWLINE> <INDENT> if x [ i ] == - 1 : <NEWLINE> <INDENT> x [ i ] = i <NEWLINE> prime . append ( i ) <NEWLINE> <DEDENT> for j in prime : <NEWLINE> <INDENT> if i * j > 10 ** 6 or j > x [ i ] : break <NEWLINE> x [ j * i ] = j <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> a = [ ] <NEWLINE> q = 0 <NEWLINE> for i in range ( len ( prime ) ) : <NEWLINE> <INDENT> p = prime [ i ] <NEWLINE> while n % p == 0 : <NEWLINE> <INDENT> q += 1 <NEWLINE> n = n // p <NEWLINE> <DEDENT> if q > 0 : a . append ( q ) <NEWLINE> q = 0 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> ans += f ( a [ i ] ) <NEWLINE> <DEDENT> print ( ans if n == 1 else ans + 1 ) <NEWLINE>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = l [ 0 ] <NEWLINE> b = l [ 1 ] <NEWLINE> n = l [ 2 ] <NEWLINE> if b - 1 <= n : <NEWLINE> <INDENT> i = b - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = n <NEWLINE> <DEDENT> y = ( ( ( a * i ) / b ) // 1 ) - ( a * ( ( i / b ) // 1 ) ) <NEWLINE> print ( int ( y ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> j = 1 <NEWLINE> while i + 2 * j <= n - 1 : <NEWLINE> <INDENT> if s [ i ] != s [ i + j ] and s [ i + j ] != s [ i + 2 * j ] and s [ i + 2 * j ] != s [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r * g * b - cnt ) <NEWLINE>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> l_i = [ a [ i ] + i + 1 for i in range ( len ( a ) ) ] <NEWLINE> r_j = [ i - a [ i ] + 1 for i in range ( len ( a ) ) ] <NEWLINE> dl = defaultdict ( int ) <NEWLINE> dr = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dl [ l_i [ i ] ] += 1 <NEWLINE> dr [ r_j [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in dl . keys ( ) : <NEWLINE> <INDENT> ans += dl [ i ] * dr [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> inputs = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> h , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> inds = { } <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for D , j in enumerate ( input ( ) . split ( ) ) : <NEWLINE> <INDENT> inds [ int ( j ) - 1 ] = ( i , D ) <NEWLINE> <DEDENT> <DEDENT> nows = [ [ 0 ] for c in range ( d ) ] <NEWLINE> <NL> for k in range ( d , h * w ) : <NEWLINE> <INDENT> a , b = inds [ k ] <NEWLINE> x , y = inds [ k - d ] <NEWLINE> k %= d <NEWLINE> nows [ k ] . append ( nows [ k ] [ - 1 ] + abs ( a - x ) + abs ( b - y ) ) <NEWLINE> <DEDENT> q = input ( ) <NEWLINE> for i in inputs ( ) : <NEWLINE> <INDENT> l , r = map ( int , i . split ( ) ) <NEWLINE> l -= 1 ; r -= 1 <NEWLINE> l , b = divmod ( l , d ) <NEWLINE> r , b = divmod ( r , d ) <NEWLINE> print ( nows [ b ] [ r ] - nows [ b ] [ l ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from bisect import bisect_left <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def solve ( N , L ) : <NEWLINE> <INDENT> L . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( N - 2 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , N - 1 ) : <NEWLINE> <INDENT> c = bisect_left ( L , L [ a ] + L [ b ] ) - 1 <NEWLINE> ans += c - b <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = solve ( N , L ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , Ma , Mb = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> sum_a = 0 <NEWLINE> sum_b = 0 <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> sum_a += a <NEWLINE> sum_b += b <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <DEDENT> inf = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> dp = [ [ [ inf ] * ( sum_b + 1 ) for _ in range ( sum_a + 1 ) ] for _ in range ( N + 1 ) ] <NEWLINE> <NL> dp [ 0 ] [ 0 ] [ 0 ] = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for sa in range ( sum_a ) : <NEWLINE> <INDENT> for sb in range ( sum_b ) : <NEWLINE> <INDENT> if sa - A [ i ] >= 0 and sb - B [ i ] >= 0 : <NEWLINE> <INDENT> dp [ i + 1 ] [ sa ] [ sb ] = min ( dp [ i ] [ sa - A [ i ] ] <NEWLINE> <INDENT> [ sb - B [ i ] ] + C [ i ] , dp [ i ] [ sa ] [ sb ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] [ sa ] [ sb ] = min ( dp [ i ] [ sa ] [ sb ] , dp [ i + 1 ] [ sa ] [ sb ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = inf <NEWLINE> for i in range ( 1 , sum_a + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , sum_b + 1 ) : <NEWLINE> <INDENT> if Ma * j == Mb * i : <NEWLINE> <INDENT> ans = min ( ans , dp [ N ] [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans if ans != inf else - 1 ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> D = collections . Counter ( A ) <NEWLINE> s = 0 <NEWLINE> for i in D : <NEWLINE> <INDENT> s += D [ i ] * ( D [ i ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( s - ( D [ A [ i ] ] - 1 ) ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 0 , n - k ) : <NEWLINE> <INDENT> if a [ i ] < a [ k + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> c = <STRING> <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> c += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += <STRING> <NEWLINE> <DEDENT> <DEDENT> c += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( W ) : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> c += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += <STRING> <NEWLINE> <DEDENT> <DEDENT> c += <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> tmp = 1 <NEWLINE> before_score = 0 <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if i >= K - 1 : <NEWLINE> <INDENT> if i >= K : <NEWLINE> <INDENT> print ( <STRING> if A [ i - K ] < A [ i ] else <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> somme = sum ( A ) <NEWLINE> <NL> from collections import Counter <NEWLINE> D = Counter ( ) <NEWLINE> <NL> for l in A : <NEWLINE> <INDENT> D [ l ] += 1 <NEWLINE> <NL> <DEDENT> for step in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if b not in D : <NEWLINE> <INDENT> print ( somme ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> somme = somme + ( c - b ) * D [ b ] <NEWLINE> <NL> D [ c ] = D [ c ] + D [ b ] <NEWLINE> del D [ b ] <NEWLINE> print ( somme ) <NEWLINE> <DEDENT>
def gcd ( a , b ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> def unzip ( strlist , a , b ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> for word in strlist : <NEWLINE> <INDENT> tmp = <STRING> <NEWLINE> for i in range ( len ( word ) ) : <NEWLINE> <INDENT> tmp += chr ( ( ( ord ( word [ i ] ) - 97 ) * a + b ) % 26 + 97 ) <NEWLINE> <DEDENT> ret . append ( tmp ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> instr = input ( ) . split ( ) <NEWLINE> flag = False <NEWLINE> for a in range ( 1 , 26 ) : <NEWLINE> <INDENT> if gcd ( 1 , 26 ) != 1 : continue <NEWLINE> if flag : break <NEWLINE> for b in range ( 26 ) : <NEWLINE> <INDENT> if <STRING> in unzip ( instr , a , b ) : <NEWLINE> <INDENT> print ( <STRING> . join ( unzip ( instr , a , b ) ) ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> elif <STRING> in unzip ( instr , a , b ) : <NEWLINE> <INDENT> print ( <STRING> . join ( unzip ( instr , a , b ) ) ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> th = math . pi / 3 <NEWLINE> <NL> def koch ( p2 , n , points ) : <NEWLINE> <INDENT> p1 = points [ - 1 ] <NEWLINE> x , y = p2 [ 0 ] - p1 [ 0 ] , p2 [ 1 ] - p1 [ 1 ] <NEWLINE> s = [ p1 [ 0 ] + x / 3 , p1 [ 1 ] + y / 3 ] <NEWLINE> t = [ p1 [ 0 ] + x * 2 / 3 , p1 [ 1 ] + y * 2 / 3 ] <NEWLINE> s0t = [ t [ 0 ] - s [ 0 ] , t [ 1 ] - s [ 1 ] ] <NEWLINE> s0u = [ math . cos ( th ) * s0t [ 0 ] - math . sin ( th ) * s0t [ 1 ] , <NEWLINE> <INDENT> math . sin ( th ) * s0t [ 0 ] + math . cos ( th ) * s0t [ 1 ] ] <NEWLINE> <DEDENT> u = [ s [ 0 ] + s0u [ 0 ] , s [ 1 ] + s0u [ 1 ] ] <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> points . append ( p2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> koch ( s , n - 1 , points ) <NEWLINE> koch ( u , n - 1 , points ) <NEWLINE> koch ( t , n - 1 , points ) <NEWLINE> koch ( p2 , n - 1 , points ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> p1 = [ 0.0 , 0.0 ] <NEWLINE> p2 = [ 100.0 , 0.0 ] <NEWLINE> points = [ p1 ] <NEWLINE> koch ( p2 , n , points ) <NEWLINE> [ print ( * p ) for p in points ] <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> c = Counter ( a ) <NEWLINE> maxa = a [ - 1 ] + 1 <NEWLINE> dp = [ True ] * maxa <NEWLINE> s = list ( set ( a ) ) <NEWLINE> for x in s : <NEWLINE> <INDENT> for j in range ( x * 2 , maxa , x ) : <NEWLINE> <INDENT> dp [ j ] = False <NEWLINE> <DEDENT> <DEDENT> ret = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> if c [ x ] == 1 and dp [ x ] == True : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> cnt = s . count ( <STRING> ) <NEWLINE> a = [ i for i , x in enumerate ( s ) if x == <STRING> ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( cnt ) : <NEWLINE> <INDENT> ans += a [ i ] - i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( m - 1 ) : <NEWLINE> <NL> <INDENT> nl , nr = map ( int , input ( ) . split ( ) ) <NEWLINE> if l < nl : <NEWLINE> <INDENT> l = nl <NEWLINE> <DEDENT> if r > nr : <NEWLINE> <INDENT> r = nr <NEWLINE> <DEDENT> <DEDENT> print ( max ( r - l + 1 , 0 ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> N = min ( B - 1 , N ) <NEWLINE> ret = ( N * A ) // B - A * ( N // B ) <NEWLINE> print ( ret ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( b , c ) , a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> s = s [ : : - 1 ] <NEWLINE> n = len ( s ) <NEWLINE> <NL> count = [ 0 ] * 2019 <NEWLINE> count [ 0 ] = 1 <NEWLINE> num , d = 0 , 1 <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> num += int ( i ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> count [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in count : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
x1 , y1 , x2 , y2 = [ float ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> print ( ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ** ( 1 / 2 ) ) <NEWLINE>
class UnionFind : <NEWLINE> <INDENT> pairs = { } <NEWLINE> def __init__ ( self , n ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> self . pairs [ i ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> def set ( self , s , t ) : <NEWLINE> <INDENT> if s in self . pairs and self . pairs [ s ] == s : <NEWLINE> <INDENT> self . pairs [ s ] = self . root ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . pairs [ t ] = self . root ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . pairs [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> self . pairs [ x ] = self . root ( self . pairs [ x ] ) <NEWLINE> return self . pairs [ x ] <NEWLINE> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> rx = self . root ( x ) <NEWLINE> ry = self . root ( y ) <NEWLINE> if rx == ry : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> self . pairs [ rx ] = ry <NEWLINE> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> rx = self . root ( x ) <NEWLINE> ry = self . root ( y ) <NEWLINE> if rx == ry : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> uf = UnionFind ( n ) <NEWLINE> pairs = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> if uf . same ( s - 1 , t - 1 ) == False : <NEWLINE> <INDENT> uf . unite ( s - 1 , t - 1 ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> root = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> root . append ( uf . root ( i ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> single_root = set ( root ) <NEWLINE> <NL> print ( len ( single_root ) - 1 ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_sort = sorted ( A ) <NEWLINE> sum_num = A_sort . pop ( - 1 ) <NEWLINE> <NL> i = 2 <NEWLINE> while i + 2 <= N : <NEWLINE> <INDENT> sum_num += A_sort . pop ( - 1 ) * 2 <NEWLINE> i += 2 <NEWLINE> <NL> <DEDENT> if i + 1 <= N : <NEWLINE> <INDENT> sum_num += A_sort . pop ( - 1 ) <NEWLINE> <NL> <DEDENT> print ( sum_num ) <NEWLINE> <NL>
def split ( word ) : <NEWLINE> <INDENT> return [ char for char in word ] <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> Slist = split ( S ) <NEWLINE> Rcounter = 0 <NEWLINE> Bcounter = 0 <NEWLINE> Gcounter = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> if Slist [ i ] == <STRING> : <NEWLINE> <INDENT> Rcounter = Rcounter + 1 <NEWLINE> <DEDENT> if Slist [ i ] == <STRING> : <NEWLINE> <INDENT> Bcounter = Bcounter + 1 <NEWLINE> <DEDENT> if Slist [ i ] == <STRING> : <NEWLINE> <INDENT> Gcounter = Gcounter + 1 <NEWLINE> <DEDENT> <DEDENT> ans = Rcounter * Gcounter * Bcounter <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if 2 * j - i > N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( Slist [ i ] == Slist [ j ] ) or ( Slist [ i ] == Slist [ 2 * j - i ] ) or ( Slist [ j ] == Slist [ 2 * j - i ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans = ans - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def counting_sort ( a , b , k ) : <NEWLINE> <INDENT> c = [ 0 ] * ( k + 1 ) <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> c [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> c [ i ] = c [ i ] + c [ i - 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( len ( a ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> c [ a [ i ] ] -= 1 <NEWLINE> b [ c [ a [ i ] ] ] = a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> counting_sort ( a , b , max ( a ) ) <NEWLINE> print ( b [ 0 ] , end = <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( <STRING> + str ( b [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL>
class Dice : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . state = [ 1 , 2 , 3 , 4 , 5 , 6 ] <NEWLINE> <NL> <DEDENT> def setState ( self , li ) : <COMMENT> <NEWLINE> <INDENT> self . state = li <NEWLINE> <NL> <DEDENT> def move ( self , str_direction ) : <NEWLINE> <INDENT> if str_direction == <STRING> : <NEWLINE> <INDENT> self . state = [ self . state [ 1 ] , self . state [ 5 ] , self . state [ 2 ] , <NEWLINE> <INDENT> self . state [ 3 ] , self . state [ 0 ] , self . state [ 4 ] ] <NEWLINE> <DEDENT> <DEDENT> if str_direction == <STRING> : <NEWLINE> <INDENT> self . state = [ self . state [ 2 ] , self . state [ 1 ] , self . state [ 5 ] , <NEWLINE> <INDENT> self . state [ 0 ] , self . state [ 4 ] , self . state [ 3 ] ] <NEWLINE> <DEDENT> <DEDENT> if str_direction == <STRING> : <NEWLINE> <INDENT> self . state = [ self . state [ 3 ] , self . state [ 1 ] , self . state [ 0 ] , <NEWLINE> <INDENT> self . state [ 5 ] , self . state [ 4 ] , self . state [ 2 ] ] <NEWLINE> <DEDENT> <DEDENT> if str_direction == <STRING> : <NEWLINE> <INDENT> self . state = [ self . state [ 4 ] , self . state [ 0 ] , self . state [ 2 ] , <NEWLINE> <INDENT> self . state [ 3 ] , self . state [ 5 ] , self . state [ 1 ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def rotate ( self ) : <NEWLINE> <INDENT> self . state = [ self . state [ 0 ] , self . state [ 2 ] , self . state [ 4 ] , <NEWLINE> <INDENT> self . state [ 1 ] , self . state [ 3 ] , self . state [ 5 ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> def sameDice1 ( self , dice1 ) : <NEWLINE> <INDENT> set1 = list ( ) <NEWLINE> for _ in range ( 4 ) : <NEWLINE> <INDENT> for __ in range ( 4 ) : <NEWLINE> <INDENT> set1 . append ( self . state ) <NEWLINE> self . rotate ( ) <NEWLINE> <DEDENT> self . move ( <STRING> ) <NEWLINE> <DEDENT> self . move ( <STRING> ) <NEWLINE> for _ in range ( 4 ) : <NEWLINE> <INDENT> set1 . append ( self . state ) <NEWLINE> self . rotate ( ) <NEWLINE> <DEDENT> self . move ( <STRING> ) <NEWLINE> self . move ( <STRING> ) <NEWLINE> for _ in range ( 4 ) : <NEWLINE> <INDENT> set1 . append ( self . state ) <NEWLINE> self . rotate ( ) <NEWLINE> <DEDENT> if dice1 . state in set1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> myd1 , myd2 = Dice ( ) , Dice ( ) <NEWLINE> myd1 . setState ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> myd2 . setState ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( myd1 . sameDice1 ( myd2 ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> for i in range ( - 100 , 120 ) : <NEWLINE> <INDENT> if i not in p : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> l2 = [ ] <NEWLINE> if x not in p : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 1 , 101 ) : <NEWLINE> <INDENT> nump = x + j <NEWLINE> numm = x - j <NEWLINE> if numm in l : <NEWLINE> <INDENT> l2 . append ( numm ) <NEWLINE> <DEDENT> if nump in l : <NEWLINE> <INDENT> l2 . append ( nump ) <NEWLINE> <DEDENT> if len ( l2 ) > 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( l2 [ 0 ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> 2 <NEWLINE> 3 <NEWLINE> 4 <NEWLINE> 5 <NEWLINE> 6 <NEWLINE> 7 <NEWLINE> 8 <NEWLINE> 9 <NEWLINE> 10 <NEWLINE> 11 <NEWLINE> 12 <NEWLINE> 13 <NEWLINE> 14 <NEWLINE> 15 <NEWLINE> 16 <NEWLINE> 17 <NEWLINE> 18 <NEWLINE> 19 <NEWLINE> <NL> <NL> <NL> from collections import Counter <NEWLINE> import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = Counter ( A ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 0 <NEWLINE> MX = 10 ** 6 <NEWLINE> P = [ 0 ] * ( MX + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if P [ a ] == 0 : <NEWLINE> <INDENT> for i in range ( MX + 1 ) : <NEWLINE> <INDENT> x = a * i <NEWLINE> if x > MX : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> P [ x ] = 1 <NEWLINE> <DEDENT> if cnt [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Edge = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> Edge [ u - 1 ] . append ( v - 1 ) <NEWLINE> Edge [ v - 1 ] . append ( u - 1 ) <NEWLINE> <NL> <DEDENT> visited = [ False ] * N <NEWLINE> visited [ 0 ] = True <NEWLINE> answer = [ 1 ] * N <NEWLINE> <NL> def dfs ( v , dp ) : <NEWLINE> <INDENT> for nv in Edge [ v ] : <NEWLINE> <INDENT> if visited [ nv ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> visited [ nv ] = True <NEWLINE> if len ( dp ) == 0 or A [ nv ] > dp [ - 1 ] : <NEWLINE> <INDENT> dp . append ( A [ nv ] ) <NEWLINE> answer [ nv ] = len ( dp ) <NEWLINE> dfs ( nv , dp ) <NEWLINE> dp . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx = bisect . bisect_left ( dp , A [ nv ] ) <NEWLINE> temp = dp [ idx ] <NEWLINE> dp [ idx ] = A [ nv ] <NEWLINE> answer [ nv ] = len ( dp ) <NEWLINE> dfs ( nv , dp ) <NEWLINE> dp [ idx ] = temp <NEWLINE> <NL> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> dfs ( 0 , [ A [ 0 ] ] ) <NEWLINE> answer [ 0 ] = 1 <NEWLINE> for a in answer : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . reverse ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k <= a : <NEWLINE> <INDENT> sum = k <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> sum = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum = a - ( k - a - b ) <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> S = r * r * math . pi <NEWLINE> L = 2 * r * math . pi <NEWLINE> <NL> print ( <STRING> . format ( S ) , <STRING> . format ( L ) ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> count = Counter ( A ) <NEWLINE> <NL> max_len_A = 10 ** 6 + 1 <NEWLINE> data = [ 0 ] * max_len_A <NEWLINE> A = list ( set ( A ) ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if data [ a ] == 0 : <NEWLINE> <INDENT> for j in range ( a + a , max_len_A , a ) : <NEWLINE> <INDENT> data [ j ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> ans = len ( [ a for a in A if data [ a ] == 0 and count [ a ] == 1 ] ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 200000 ) <NEWLINE> <NL> <NL> def f_dfs ( i ) : <NEWLINE> <INDENT> global f_edges , counter <NEWLINE> visited [ i ] = True <NEWLINE> for edge in f_edges [ i ] : <NEWLINE> <INDENT> if visited [ edge ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> f_dfs ( edge ) <NEWLINE> <DEDENT> finish_order [ i ] = ( counter , i ) <NEWLINE> counter += 1 <NEWLINE> <NL> <NL> <DEDENT> def b_dfs ( i , group ) : <NEWLINE> <INDENT> global b_edges , groups <NEWLINE> visited [ i ] = True <NEWLINE> groups [ i ] = group <NEWLINE> for edge in b_edges [ i ] : <NEWLINE> <INDENT> if visited [ edge ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> b_dfs ( edge , group ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> f_edges = [ set ( ) for _ in range ( n ) ] <NEWLINE> b_edges = [ set ( ) for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> f_edges [ s ] . add ( t ) <NEWLINE> b_edges [ t ] . add ( s ) <NEWLINE> <NL> <DEDENT> visited = [ False ] * n <NEWLINE> finish_order = [ None ] * n <NEWLINE> counter = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if not visited [ i ] : <NEWLINE> <INDENT> f_dfs ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> visited = [ False ] * n <NEWLINE> groups = [ None ] * n <NEWLINE> group = 0 <NEWLINE> <NL> for d , i in sorted ( finish_order , reverse = True ) : <NEWLINE> <INDENT> if not visited [ i ] : <NEWLINE> <INDENT> b_dfs ( i , group ) <NEWLINE> group += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> q -= 1 <NEWLINE> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( groups [ u ] == groups [ v ] ) ) <NEWLINE> <DEDENT>
<NL> <NL> itemsList = { } <NEWLINE> num = int ( input ( ) ) <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> temp = input ( ) <NEWLINE> if not temp in itemsList : <NEWLINE> <INDENT> itemsList [ temp ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( len ( itemsList ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if b > n : <NEWLINE> <INDENT> print ( math . floor ( a * n / b ) - a * math . floor ( n / b ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( math . floor ( a * ( b - 1 ) / b ) - a * math . floor ( ( b - 1 ) / b ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from itertools import combinations_with_replacement <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> qx = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in combinations_with_replacement ( range ( 1 , m + 1 ) , n ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for a , b , c , d in qx : <NEWLINE> <INDENT> s += d if ( i [ b - 1 ] - i [ a - 1 ] == c ) else 0 <NEWLINE> <DEDENT> ans = max ( ans , s ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ ( A [ i ] , i ) for i in range ( N ) ] <NEWLINE> B . sort ( key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> <NL> DP = [ [ 0 ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> <NL> for i , b in enumerate ( B ) : <NEWLINE> <INDENT> a = b [ 0 ] <NEWLINE> tmp = b [ 1 ] <NEWLINE> for x in range ( i + 1 ) : <NEWLINE> <INDENT> DP [ x + 1 ] [ i - x ] = max ( DP [ x + 1 ] [ i - x ] , DP [ x ] [ i - x ] + a * abs ( tmp - x ) ) <NEWLINE> DP [ x ] [ i - x + 1 ] = max ( DP [ x ] [ i - x + 1 ] , DP [ x ] [ i - x ] + a * abs ( ( N - tmp - 1 ) - ( i - x ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , DP [ i ] [ N - i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> a = collections . deque ( ) <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> b = input ( ) <NEWLINE> if b [ 0 ] == <STRING> : a . appendleft ( b [ 7 : ] ) <NEWLINE> elif b [ 6 ] == <STRING> : <NEWLINE> <INDENT> try : a . remove ( b [ 7 : ] ) <NEWLINE> except : pass <NEWLINE> <DEDENT> elif len ( b ) > 10 : a . popleft ( ) <NEWLINE> elif len ( b ) > 6 : a . pop ( ) <NEWLINE> <DEDENT> print ( * a ) <NEWLINE>
x , n = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if n != 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = [ ] <NEWLINE> <DEDENT> lst = list ( range ( - 1 , x * 2 + 1 ) ) <NEWLINE> for i in p : <NEWLINE> <INDENT> if i in lst : <NEWLINE> <INDENT> lst . remove ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( x + 2 ) : <NEWLINE> <INDENT> if x - i in lst or x - i < 0 : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> break <NEWLINE> <DEDENT> elif x + i in lst : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) [ : : - 1 ] <COMMENT> <NEWLINE> <NL> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> <NL> num , d = 0 , 1 <NEWLINE> <NL> for char in s : <NEWLINE> <INDENT> num += int ( char ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> counts [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in counts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <COMMENT> <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> class Counter ( dict ) : <NEWLINE> <INDENT> def __missing__ ( self , i ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> class BoolDict ( dict ) : <NEWLINE> <INDENT> def __missing__ ( self , i ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> passed = 0 <NEWLINE> penalties = Counter ( ) <NEWLINE> <NL> ac = BoolDict ( ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> if not ac [ p ] : <NEWLINE> <INDENT> if s == <STRING> : penalties [ p ] += 1 <NEWLINE> elif s == <STRING> : <NEWLINE> <INDENT> passed += 1 <NEWLINE> ac [ p ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> x = 0 <NEWLINE> for i in penalties : <NEWLINE> <INDENT> if ac [ i ] : <NEWLINE> <INDENT> x += penalties [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( passed , x ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> N = 7 % K <NEWLINE> NotFound = True <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if N == 0 : <NEWLINE> <INDENT> NotFound = False <NEWLINE> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> N = ( N * 10 + 7 ) % K <NEWLINE> <NL> <DEDENT> if ( NotFound ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> t = 0 <NEWLINE> u = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if t < A + B : <NEWLINE> <INDENT> t = t + 1 <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> if t < A + B and B > u : <NEWLINE> <INDENT> t = t + 1 <NEWLINE> u = u + 1 <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT>
import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cumsum = list ( itertools . accumulate ( a ) ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += a [ i ] * cumsum [ i - 1 ] <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = z = 0 <NEWLINE> while z <= x and i < n : <NEWLINE> <INDENT> z += l [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> if z <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> print ( i ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nux = max ( A ) <NEWLINE> B = set ( A ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 0 <NEWLINE> table = [ True ] * ( nux + 1 ) <NEWLINE> for ii , s in enumerate ( A ) : <NEWLINE> <INDENT> if table [ s ] == False : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ii == n - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif A [ ii + 1 ] != s : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> i = 1 <NEWLINE> while i * s <= nux : <NEWLINE> <INDENT> table [ i * s ] = False <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> k *= a [ i ] <NEWLINE> if k > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( k ) <NEWLINE>
def abc162d_rgb_triplets ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r_cnt = 0 <NEWLINE> g_cnt = 0 <NEWLINE> b_cnt = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r_cnt += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g_cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b_cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> result = r_cnt * g_cnt * b_cnt <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if s [ i ] == s [ j ] or k >= n or s [ i ] == s [ k ] or s [ j ] == s [ k ] : continue <NEWLINE> result -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <NL> <DEDENT> abc162d_rgb_triplets ( ) <NEWLINE>
T = list ( input ( ) ) <NEWLINE> <NL> if len ( T ) == 1 : <NEWLINE> <INDENT> if T [ 0 ] == <STRING> : <NEWLINE> <INDENT> T [ 0 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <NL> <INDENT> if T [ 0 ] == <STRING> : <NEWLINE> <INDENT> if T [ 1 ] == <STRING> : <NEWLINE> <INDENT> T [ 0 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ 0 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , len ( T ) - 1 ) : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> if T [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if T [ - 1 ] == <STRING> : <NEWLINE> <INDENT> T [ - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( T ) ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> fac = 2 <NEWLINE> e = 1 <NEWLINE> while n % ( div : = pow ( fac , e ) ) == 0 : <NEWLINE> <INDENT> n //= div <NEWLINE> ans += 1 <NEWLINE> e += 1 <NEWLINE> <NL> <DEDENT> while n % fac == 0 : <NEWLINE> <INDENT> n //= fac <NEWLINE> <NL> <DEDENT> fac = 3 <NEWLINE> e = 1 <NEWLINE> while pow ( fac , 2 ) <= n : <NEWLINE> <INDENT> while n % ( div : = pow ( fac , e ) ) == 0 : <NEWLINE> <INDENT> n //= div <NEWLINE> ans += 1 <NEWLINE> e += 1 <NEWLINE> <NL> <DEDENT> while n % fac == 0 : <NEWLINE> <INDENT> n //= fac <NEWLINE> <DEDENT> e = 1 <NEWLINE> fac += 2 <NEWLINE> <NL> <DEDENT> if n != 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> B = sorted ( A ) [ : N - 1 ] <NEWLINE> m = max ( A ) <NEWLINE> n = A . index ( max ( A ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i != n : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( B ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> s = sum ( A [ 1 : ] ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * s <NEWLINE> s = s - A [ i + 1 ] <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> dict = { key : 0 for key in range ( M ) } <NEWLINE> <COMMENT> <NL> if N == 1 : <NEWLINE> <INDENT> return X <NEWLINE> <DEDENT> dict [ X ] += 1 <NEWLINE> cnt = 1 <NEWLINE> A = [ 0 ] * ( M + 1 ) <NEWLINE> A [ 1 ] = X <NEWLINE> ans = X <NEWLINE> tmp = X <NEWLINE> for i in range ( 1 , N , 1 ) : <NEWLINE> <INDENT> tmp = ( tmp ** 2 ) % M <NEWLINE> if dict [ tmp ] != 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += tmp <NEWLINE> A [ i + 1 ] = A [ i ] + tmp <NEWLINE> cnt += 1 <NEWLINE> dict [ tmp ] += cnt <NEWLINE> <NL> <DEDENT> num = N - cnt <COMMENT> <NEWLINE> roop_num = cnt - dict [ tmp ] + 1 <NEWLINE> syo = num // roop_num <NEWLINE> amari = num % roop_num <NEWLINE> ans += syo * ( A [ cnt ] - A [ dict [ tmp ] - 1 ] ) <NEWLINE> ans += ( A [ dict [ tmp ] + amari - 1 ] - A [ dict [ tmp ] - 1 ] ) <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def floor ( x ) : <NEWLINE> <INDENT> return ( A * x // B ) - A * ( x // B ) <NEWLINE> <NL> <DEDENT> print ( floor ( min ( B - 1 , N ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a1 = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> step = 1 <NEWLINE> start = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> start += 1 <NEWLINE> a1 [ step ] += 1 <NEWLINE> step = a [ step ] <NEWLINE> if a1 [ step ] == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> c = step <NEWLINE> gap = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> gap += 1 <NEWLINE> step = a [ step ] <NEWLINE> if step == c : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> result = 1 <NEWLINE> if k > start : <NEWLINE> <INDENT> k = ( k - start ) % gap <NEWLINE> result = c <NEWLINE> <DEDENT> for _ in range ( k ) : <NEWLINE> <INDENT> result = a [ result ] <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
def gcd ( x , y ) : <NEWLINE> <INDENT> if y == 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> return gcd ( y , x % y ) <NEWLINE> <NL> <DEDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( gcd ( x , y ) ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> def doubly_lined_list ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> Q = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> line = sys . stdin . readline ( ) <NEWLINE> command = line . split ( ) [ 0 ] <NEWLINE> <NL> if command == <STRING> : <NEWLINE> <INDENT> Q . appendleft ( line . split ( ) [ 1 ] ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> Q . remove ( line . split ( ) [ 1 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> Q . popleft ( ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> Q . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( Q ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> doubly_lined_list ( ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> s = input ( ) [ : : - 1 ] <COMMENT> <NEWLINE> <NL> counts = [ 0 ] * 2019 <COMMENT> <NEWLINE> counts [ 0 ] = 1 <COMMENT> <NEWLINE> <NL> num , d = 0 , 1 <NEWLINE> <NL> for char in s : <NEWLINE> <INDENT> num += int ( char ) * d <COMMENT> <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> counts [ num ] += 1 <COMMENT> <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in counts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( ans ) <COMMENT> <NEWLINE>
from math import gcd <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> K = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 1 <NEWLINE> <COMMENT> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> for i in a : <NEWLINE> <INDENT> if s < 10 ** 18 : <NEWLINE> <INDENT> s *= i <NEWLINE> <DEDENT> <DEDENT> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r , l = [ 0 ] * ( n ) , [ 0 ] * ( n ) <NEWLINE> l [ 0 ] = 0 <NEWLINE> r [ n - 1 ] = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> l [ i ] = math . gcd ( l [ i - 1 ] , a [ i - 1 ] ) <NEWLINE> r [ n - i - 1 ] = math . gcd ( r [ n - i ] , a [ n - i ] ) <NEWLINE> <DEDENT> m = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m [ i ] = math . gcd ( l [ i ] , r [ i ] ) <NEWLINE> <DEDENT> print ( max ( m ) ) <NEWLINE>
from math import gcd <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L , R = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> L += [ gcd ( L [ i ] , A [ i ] ) ] <NEWLINE> R += [ gcd ( R [ i ] , A [ - i - 1 ] ) ] <NEWLINE> <NL> <DEDENT> print ( max ( gcd ( L [ i ] , R [ - i - 1 ] ) for i in range ( N ) ) ) <NEWLINE> <NL>
import numpy as np <NEWLINE> <NL> <NL> def solve_greedy ( dd , c_arr , s_arr ) : <NEWLINE> <INDENT> missing_d = np . zeros ( 26 , dtype = np . int64 ) <NEWLINE> score = 0 <NEWLINE> res_list = [ ] <NEWLINE> for d in range ( dd ) : <NEWLINE> <NL> <INDENT> missing_d += 1 <NEWLINE> <NL> score_add = s_arr [ d , : ] <NEWLINE> score_miss = c_arr * missing_d <NEWLINE> <NL> t = np . argmax ( score_add + score_miss ) <NEWLINE> <NL> score += score_add [ t ] + score_miss [ t ] - score_miss . sum ( ) <NEWLINE> <NL> res_list . append ( t ) <NEWLINE> missing_d [ t ] = 0 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> return score , np . array ( res_list ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( dd , c_arr , s_arr ) : <NEWLINE> <NL> <INDENT> score , t_arr = solve_greedy ( dd , c_arr , s_arr ) <NEWLINE> <NL> score_d = np . zeros ( dd , dtype = np . int64 ) <NEWLINE> missing_d = np . zeros ( ( dd , 26 ) , dtype = np . int64 ) <NEWLINE> for d in range ( dd ) : <NEWLINE> <INDENT> score_d [ d ] = s_arr [ d , t_arr [ d ] ] <NEWLINE> if d == 0 : <NEWLINE> <INDENT> missing_d [ d , : ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> missing_d [ d , : ] = missing_d [ d - 1 , : ] + 1 <NEWLINE> <DEDENT> missing_d [ d , t_arr [ d ] ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 1000 ) : <NEWLINE> <INDENT> d0 = np . random . choice ( dd ) <NEWLINE> q0 = np . random . choice ( 26 ) <NEWLINE> p0 = t_arr [ d0 ] <NEWLINE> t_arr [ d0 ] = q0 <NEWLINE> <NL> score_new = score <NEWLINE> <NL> score_new += s_arr [ d0 , q0 ] <NEWLINE> score_new -= s_arr [ d0 , p0 ] <NEWLINE> score_new += ( c_arr [ q0 ] * missing_d [ : , q0 ] ) . sum ( ) <NEWLINE> score_new += ( c_arr [ p0 ] * missing_d [ : , p0 ] ) . sum ( ) <NEWLINE> for d in range ( dd ) : <NEWLINE> <INDENT> if d == 0 : <NEWLINE> <INDENT> missing_d [ d , p0 ] = 1 <NEWLINE> missing_d [ d , q0 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> missing_d [ d , p0 ] = missing_d [ d - 1 , p0 ] + 1 <NEWLINE> missing_d [ d , q0 ] = missing_d [ d - 1 , q0 ] + 1 <NEWLINE> <DEDENT> if t_arr [ d ] == p0 : <NEWLINE> <INDENT> missing_d [ d , p0 ] = 0 <NEWLINE> <DEDENT> elif t_arr [ d ] == q0 : <NEWLINE> <INDENT> missing_d [ d , q0 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> score_new -= ( c_arr [ q0 ] * missing_d [ : , q0 ] ) . sum ( ) <NEWLINE> score_new -= ( c_arr [ p0 ] * missing_d [ : , p0 ] ) . sum ( ) <NEWLINE> <NL> if score_new >= score : <NEWLINE> <INDENT> score = score_new <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t_arr [ d0 ] = p0 <NEWLINE> for d in range ( dd ) : <NEWLINE> <INDENT> if d == 0 : <NEWLINE> <INDENT> missing_d [ d , p0 ] = 1 <NEWLINE> missing_d [ d , q0 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> missing_d [ d , p0 ] = missing_d [ d - 1 , p0 ] + 1 <NEWLINE> missing_d [ d , q0 ] = missing_d [ d - 1 , q0 ] + 1 <NEWLINE> <DEDENT> if t_arr [ d ] == p0 : <NEWLINE> <INDENT> missing_d [ d , p0 ] = 0 <NEWLINE> <DEDENT> elif t_arr [ d ] == q0 : <NEWLINE> <INDENT> missing_d [ d , q0 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return [ t + 1 for t in t_arr ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> d = np . int64 ( input ( ) ) <NEWLINE> c_arr = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) . astype ( np . int64 ) <NEWLINE> s_arr = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( d ) ] ) . astype ( np . int64 ) <NEWLINE> res = solve ( d , c_arr , s_arr ) <NEWLINE> for r in res : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> to = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> to [ a - 1 ] . append ( b - 1 ) <NEWLINE> to [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> q = deque ( [ 0 ] ) <NEWLINE> r = [ None ] * N <NEWLINE> r [ 0 ] = 0 <NEWLINE> while q : <NEWLINE> <INDENT> x = q . popleft ( ) <NEWLINE> for i in to [ x ] : <NEWLINE> <INDENT> if r [ i ] is None : <NEWLINE> <INDENT> q . append ( i ) <NEWLINE> r [ i ] = x + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if r [ i ] != 0 : <NEWLINE> <INDENT> print ( r [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> S = int ( input ( ) ) <NEWLINE> z = 10 ** 9 + 7 <NEWLINE> if S >= 7 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> n = S // 3 <NEWLINE> b = S % 3 <NEWLINE> a = 3 + b <NEWLINE> <NL> c = n - 1 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> y = max ( [ a , c - 1 ] ) <NEWLINE> r = min ( [ a , c - 1 ] ) <NEWLINE> <COMMENT> <NL> s = 1 <NEWLINE> for k in range ( y + 1 , a + c ) : <NEWLINE> <INDENT> s *= k <NEWLINE> <COMMENT> <NL> <DEDENT> s //= math . factorial ( r ) <NEWLINE> s %= z <NEWLINE> ans += s <NEWLINE> a += 3 <NEWLINE> c -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if b == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> if b == 1 : <NEWLINE> <INDENT> ans += n <NEWLINE> <DEDENT> if b == 2 : <NEWLINE> <INDENT> ans += n * ( n - 1 ) // 2 + n <NEWLINE> <DEDENT> <DEDENT> elif S == 6 : <NEWLINE> <INDENT> ans = 2 <NEWLINE> <DEDENT> elif 3 <= S < 6 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans % z ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def bfs ( graph , start ) : <NEWLINE> <INDENT> visited = { start : None } <NEWLINE> unvisited = deque ( ) <NEWLINE> unvisited . append ( start ) <NEWLINE> while unvisited : <NEWLINE> <INDENT> now = unvisited . popleft ( ) <NEWLINE> for next in graph [ now ] : <NEWLINE> <INDENT> if not ( next in visited ) : <NEWLINE> <INDENT> unvisited . append ( next ) <NEWLINE> visited [ next ] = now <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return visited <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ set ( ) for i in range ( n ) ] <NEWLINE> group = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a ] . add ( b ) <NEWLINE> g [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( len ( group ) ) : <NEWLINE> <INDENT> if s in group [ j ] and t in group [ j ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif s in group [ j ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> group_tmp = set ( bfs ( g , s ) . keys ( ) ) <NEWLINE> if t in group_tmp : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> group . append ( group_tmp ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( arg ) for arg in input ( ) . split ( ) ] <NEWLINE> res = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> res *= i <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> a = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> a *= i <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> aMax = a [ - 1 ] <NEWLINE> ans = 0 <NEWLINE> dp = [ 1 ] * ( aMax + 1 ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> p = a [ i ] <NEWLINE> if dp [ p ] == 1 : <NEWLINE> <INDENT> for j in range ( aMax // p + 1 ) : <NEWLINE> <INDENT> dp [ p * j ] = 0 <NEWLINE> <DEDENT> if a [ i ] != a [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if dp [ aMax ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
p = 2019 <NEWLINE> D = input ( ) <NEWLINE> n = ( len ( D ) ) <NEWLINE> out = 0 <NEWLINE> <NL> <NL> if 10 % p == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if int ( D [ i ] ) % p == 0 : <NEWLINE> <INDENT> out += i + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> mod = 0 <NEWLINE> count = [ 0 ] * p <NEWLINE> ten = 1 <NEWLINE> count [ mod ] += 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> mod = ( mod + int ( D [ n - i - 1 ] ) * ten ) % p <NEWLINE> ten = ten * 10 % p <NEWLINE> count [ mod ] += 1 <NEWLINE> <DEDENT> for c in count : <NEWLINE> <INDENT> out += ( c * ( c - 1 ) ) // 2 <NEWLINE> <DEDENT> <DEDENT> print ( out ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N , _A , Q , * val = [ [ * map ( int , line . split ( ) ) ] for line in open ( 0 ) ] <NEWLINE> N = N [ 0 ] <NEWLINE> Q = Q [ 0 ] <NEWLINE> <NL> A = defaultdict ( int ) <NEWLINE> for _a in _A : <NEWLINE> <INDENT> A [ _a ] += 1 <NEWLINE> <NL> <DEDENT> ans = sum ( _A ) <NEWLINE> for v in val : <NEWLINE> <INDENT> if v [ 0 ] in A . keys ( ) : <NEWLINE> <INDENT> num = A [ v [ 0 ] ] <NEWLINE> A [ v [ 0 ] ] = 0 <NEWLINE> A [ v [ 1 ] ] += num <NEWLINE> ans += ( v [ 1 ] - v [ 0 ] ) * num <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A > K : <NEWLINE> <INDENT> a = K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = A <NEWLINE> <NL> <DEDENT> if ( A + B ) < K : <NEWLINE> <INDENT> a = a - K + A + B <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
def nibutan ( f_id , e_id , f_num , count ) : <NEWLINE> <NL> <NL> <INDENT> m_id = int ( ( f_id + e_id ) / 2 ) <NEWLINE> m_num = n_lis [ m_id ] <NEWLINE> <NL> <NL> if ( f_id > e_id ) : <NEWLINE> <INDENT> return count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> if m_num > f_num : <NEWLINE> <INDENT> return ( nibutan ( f_id , m_id - 1 , f_num , count ) ) <NEWLINE> <DEDENT> elif m_num < f_num : <NEWLINE> <INDENT> return ( nibutan ( m_id + 1 , e_id , f_num , count ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return count <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> global n_lis <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n_lis = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> n_lis . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> f_n = int ( input ( ) ) <NEWLINE> ans = nibutan ( 0 , n - 1 , f_n , 0 ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> C = [ input ( ) for i in range ( H ) ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> print ( C [ i ] ) <NEWLINE> print ( C [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> for i in A : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> K , S = LI ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x , y in itertools . product ( range ( K + 1 ) , repeat = 2 ) : <NEWLINE> <INDENT> if 0 <= S - ( x + y ) <= K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , sys . stdin . readline ( ) [ : - 1 ] . split ( ) ) ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> M = list ( map ( int , sys . stdin . readline ( ) [ : - 1 ] . split ( ) ) ) <NEWLINE> <NL> R = [ [ None ] * 2000 for i in range ( n + 1 ) ] <NEWLINE> def solve ( A , n , i , m ) : <NEWLINE> <INDENT> if R [ i ] [ m ] != None : <NEWLINE> <INDENT> return R [ i ] [ m ] <NEWLINE> <DEDENT> if m == 0 : <NEWLINE> <INDENT> R [ i ] [ m ] = True <NEWLINE> return True <NEWLINE> <DEDENT> if n <= i : <NEWLINE> <INDENT> R [ i ] [ m ] = False <NEWLINE> return False <NEWLINE> <DEDENT> a = A [ i ] <NEWLINE> R [ i ] [ m ] = ( solve ( A , n , i + 1 , m ) or solve ( A , n , i + 1 , m - a ) ) <NEWLINE> return R [ i ] [ m ] <NEWLINE> <NL> <DEDENT> for m in M : <NEWLINE> <INDENT> if solve ( A , n , 0 , m ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> list_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from collections import Counter <NEWLINE> under = Counter ( list_a ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( under [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = [ 0 ] * N <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> x = A [ i ] <NEWLINE> C [ x - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( C [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> result = [ 0 ] * n <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> result [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> print ( result [ j ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import collections <NEWLINE> c = collections . Counter ( A ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def f ( n ) : <NEWLINE> <INDENT> arr = list ( ) <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( tuple ( [ i , cnt ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> tup = tuple ( [ temp , 1 ] ) <NEWLINE> arr . append ( tup ) <NEWLINE> <NL> <DEDENT> if len ( arr ) == 0 : <NEWLINE> <INDENT> tup = tuple ( [ n , 1 ] ) <NEWLINE> arr . append ( tup ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> t = f ( N ) <NEWLINE> res = 0 <NEWLINE> <NL> for a in t : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> c = 0 <NEWLINE> while cnt <= a [ 1 ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> cnt += c <NEWLINE> <DEDENT> res += c - 1 <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd_list ( numbers ) : <NEWLINE> <INDENT> gcd = reduce ( math . gcd , numbers ) <NEWLINE> return gcd <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> numberslist = [ ] <NEWLINE> sumgcd = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if i == j == k : <NEWLINE> <INDENT> sumgcd += gcd_list ( [ i , j , k ] ) <NEWLINE> <DEDENT> elif i == j or j == k or k == i : <NEWLINE> <INDENT> sumgcd += gcd_list ( [ i , j , k ] ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sumgcd += gcd_list ( [ i , j , k ] ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sumgcd ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = float ( <STRING> ) <NEWLINE> S = sum ( A ) <NEWLINE> T = [ ] <NEWLINE> T . append ( A [ 0 ] ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> T . append ( T [ i - 1 ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> if N == 2 : <NEWLINE> <INDENT> ans = abs ( A [ 0 ] - A [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> ans = min ( ans , abs ( S - 2 * T [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
class Dice : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self ) : <COMMENT> <NEWLINE> <INDENT> self . eyeIndex = 1 <COMMENT> <NEWLINE> self . eyeIndex_E = 3 <COMMENT> <NEWLINE> self . eyeIndex_W = 4 <COMMENT> <NEWLINE> self . eyeIndex_N = 5 <COMMENT> <NEWLINE> self . eyeIndex_S = 2 <COMMENT> <NEWLINE> self . eye = 0 <NEWLINE> self . eye_S = 0 <NEWLINE> self . eye_E = 0 <NEWLINE> self . eyes = [ ] <NEWLINE> <NL> <DEDENT> def convEyesIndexToEyes ( self ) : <NEWLINE> <INDENT> self . eye = self . eyes [ self . eyeIndex ] <NEWLINE> self . eye_S = self . eyes [ self . eyeIndex_S ] <NEWLINE> self . eye_E = self . eyes [ self . eyeIndex_E ] <NEWLINE> <NL> <NL> <DEDENT> def shakeDice ( self , in_command ) : <NEWLINE> <INDENT> pre_eyeIndex = self . eyeIndex <NEWLINE> if in_command == <STRING> : <NEWLINE> <INDENT> self . eyeIndex = self . eyeIndex_W <NEWLINE> self . eyeIndex_E = pre_eyeIndex <NEWLINE> self . eyeIndex_W = 7 - self . eyeIndex_E <NEWLINE> <NL> <DEDENT> elif in_command == <STRING> : <NEWLINE> <INDENT> self . eyeIndex = self . eyeIndex_E <NEWLINE> self . eyeIndex_W = pre_eyeIndex <NEWLINE> self . eyeIndex_E = 7 - self . eyeIndex_W <NEWLINE> <NL> <DEDENT> elif in_command == <STRING> : <NEWLINE> <INDENT> self . eyeIndex = self . eyeIndex_S <NEWLINE> self . eyeIndex_N = pre_eyeIndex <NEWLINE> self . eyeIndex_S = 7 - self . eyeIndex_N <NEWLINE> <NL> <DEDENT> elif in_command == <STRING> : <NEWLINE> <INDENT> self . eyeIndex = self . eyeIndex_N <NEWLINE> self . eyeIndex_S = pre_eyeIndex <NEWLINE> self . eyeIndex_N = 7 - self . eyeIndex_S <NEWLINE> <NL> <DEDENT> self . convEyesIndexToEyes ( ) <NEWLINE> <NL> <NL> <DEDENT> def rotateDice ( self ) : <NEWLINE> <COMMENT> <NL> <INDENT> pre_E = self . eyeIndex_E <NEWLINE> pre_S = self . eyeIndex_S <NEWLINE> pre_W = self . eyeIndex_W <NEWLINE> pre_N = self . eyeIndex_N <NEWLINE> <NL> self . eyeIndex_E = pre_N <NEWLINE> self . eyeIndex_S = pre_E <NEWLINE> self . eyeIndex_W = pre_S <NEWLINE> self . eyeIndex_N = pre_W <NEWLINE> <NL> self . convEyesIndexToEyes ( ) <NEWLINE> <NL> <DEDENT> def getEye ( self ) : <NEWLINE> <INDENT> return self . eye <NEWLINE> <NL> <DEDENT> def getEye_S ( self ) : <NEWLINE> <INDENT> return self . eye_S <NEWLINE> <NL> <DEDENT> def getEye_E ( self ) : <NEWLINE> <INDENT> return self . eye_E <NEWLINE> <NL> <DEDENT> def setEyes ( self , eyes ) : <COMMENT> <NEWLINE> <INDENT> eyes = <STRING> + eyes <NEWLINE> self . eyes = list ( map ( int , eyes . split ( <STRING> ) ) ) <NEWLINE> self . convEyesIndexToEyes ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> dice_1 = Dice ( ) <NEWLINE> dice_1 . setEyes ( input ( ) . rstrip ( ) ) <NEWLINE> command_time = int ( input ( ) . rstrip ( ) ) <NEWLINE> <NL> for i in range ( command_time ) : <NEWLINE> <INDENT> in_eye , in_eye_S = map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) <NEWLINE> <NL> shake_direction = <STRING> <NEWLINE> def_eye = dice_1 . getEye ( ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> dice_1 . shakeDice ( shake_direction ) <NEWLINE> <NL> if dice_1 . getEye ( ) == in_eye : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if dice_1 . getEye ( ) == def_eye : <NEWLINE> <INDENT> shake_direction = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> if dice_1 . getEye_S ( ) == in_eye_S : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dice_1 . rotateDice ( ) <NEWLINE> <NL> <NL> <DEDENT> print ( dice_1 . getEye_E ( ) ) <NEWLINE> <DEDENT>
def solve2 ( ) : <NEWLINE> <INDENT> r , c = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> ans_matrix = [ [ 0 for _ in range ( c + 1 ) ] for _ in range ( r + 1 ) ] <NEWLINE> input_matrix = [ ] <NEWLINE> <NL> for _ in range ( r ) : <NEWLINE> <INDENT> input_matrix . append ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <NL> <DEDENT> largest_square = 0 <NEWLINE> <NL> for i in range ( len ( input_matrix ) ) : <NEWLINE> <INDENT> for j in range ( len ( input_matrix [ i ] ) ) : <NEWLINE> <INDENT> new_i , new_j = i + 1 , j + 1 <NEWLINE> if input_matrix [ i ] [ j ] == 0 : <NEWLINE> <INDENT> ans_matrix [ new_i ] [ new_j ] = min ( ans_matrix [ new_i - 1 ] [ new_j ] , ans_matrix [ new_i ] [ new_j - 1 ] , ans_matrix [ new_i - 1 ] [ new_j - 1 ] ) + 1 <NEWLINE> largest_square = ans_matrix [ new_i ] [ new_j ] if ans_matrix [ new_i ] [ new_j ] > largest_square else largest_square <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_matrix [ new_i ] [ new_j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( largest_square ** 2 ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> solve2 ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> al = sum ( l ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> al -= l [ i ] <NEWLINE> <DEDENT> print ( al ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> DEBUG = False <NEWLINE> if DEBUG : <NEWLINE> <INDENT> f = open ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = sys . stdin <NEWLINE> <DEDENT> mod = 1 <NEWLINE> ans = 0 <NEWLINE> N = int ( f . readline ( ) . strip ( ) ) <NEWLINE> if N % 2 == 0 or N % 5 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if N % 7 == 0 : <NEWLINE> <INDENT> A = N * 9 / 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = N * 9 <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> mod = ( 10 * mod ) % A <NEWLINE> if mod == 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> f . close ( ) <NEWLINE>
ii = lambda : int ( input ( ) ) <NEWLINE> mi = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ix = lambda x : list ( input ( ) for _ in range ( x ) ) <NEWLINE> mix = lambda x : list ( mi ( ) for _ in range ( x ) ) <NEWLINE> iix = lambda x : list ( int ( input ( ) ) for _ in range ( x ) ) <NEWLINE> <COMMENT> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n = ii ( ) <NEWLINE> a = mi ( ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> res = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> res = res * i <NEWLINE> if ( res > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> limit = pow ( 10 , 18 ) <NEWLINE> <NL> f = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] != 0 and f == 0 : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> <DEDENT> elif A [ i ] != 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if ans > limit : <NEWLINE> <INDENT> f = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if f == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import decimal <NEWLINE> <NL> data = input ( ) . split ( ) <NEWLINE> X = decimal . Decimal ( data [ 0 ] ) <NEWLINE> K = decimal . Decimal ( data [ 1 ] ) <NEWLINE> D = decimal . Decimal ( data [ 2 ] ) <NEWLINE> if X < 0 : <NEWLINE> <INDENT> X *= - 1 <NEWLINE> <DEDENT> if X / D - X // D > 0.5 : <NEWLINE> <INDENT> y = X // D + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = X // D <NEWLINE> <DEDENT> if y > K : <NEWLINE> <INDENT> y = K <NEWLINE> <DEDENT> X -= y * D <NEWLINE> <NL> if ( K - y ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( X ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if X > 0 : <NEWLINE> <INDENT> print ( D - X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X + D ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> S . sort ( ) <NEWLINE> ans = sum ( S ) <NEWLINE> <NL> if ans % 10 != 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] % 10 != 0 : <NEWLINE> <INDENT> print ( ans - S [ i ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = [ 0 ] * 101 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> inp = int ( input ( ) ) <NEWLINE> d [ inp ] += 1 <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in d : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> if ( K % 2 == 0 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if ( K % 5 == 0 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> tmp = 7 <NEWLINE> for i in range ( 1 * 10 ** 6 ) : <NEWLINE> <INDENT> if tmp % K == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> hoge = tmp % K <NEWLINE> ans += 1 <NEWLINE> tmp = hoge * 10 + 7 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> LIM = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> if A [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > LIM : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = list ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> ans += int ( n [ i ] ) <NEWLINE> <NL> <DEDENT> if ans % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> s = input ( ) <NEWLINE> x = 0 <NEWLINE> y = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> y -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> x = max ( x , y ) <NEWLINE> <NL> <DEDENT> print ( x * 2 ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> if ( <STRING> in s and <STRING> in s ) : <NEWLINE> <INDENT> if ( s . count ( <STRING> ) == 1 ) : <NEWLINE> <INDENT> if ( s . index ( <STRING> ) < s . index ( <STRING> ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( s . index ( <STRING> ) < s . index ( <STRING> , 1 ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> s = len ( S ) <NEWLINE> T = input ( ) <NEWLINE> t = len ( T ) <NEWLINE> <NL> key = 0 <NEWLINE> for i in range ( s - t , - 1 , - 1 ) : <NEWLINE> <INDENT> for j , k in enumerate ( S [ i : i + t ] ) : <NEWLINE> <INDENT> if k == T [ j ] or k == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> key = i <NEWLINE> break <NEWLINE> <DEDENT> key = 100 <NEWLINE> <DEDENT> if key == 100 or s < t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = S [ 0 : i ] + T + S [ i + t : ] <NEWLINE> ans = ans . replace ( <STRING> , <STRING> ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> c = X . count ( <STRING> ) <NEWLINE> if c == 0 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> quit ( ) <NEWLINE> <DEDENT> if c == 1 : <NEWLINE> <INDENT> if int ( X [ - 1 ] ) : <NEWLINE> <INDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if int ( X [ i ] ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( 2 ) <NEWLINE> <DEDENT> quit ( ) <NEWLINE> <NL> <DEDENT> memo = { 0 : 0 , 1 : 1 , 2 : 1 } <NEWLINE> def calc ( x ) : <NEWLINE> <INDENT> global memo <NEWLINE> if x in memo : <NEWLINE> <INDENT> return memo [ x ] <NEWLINE> <DEDENT> c = bin ( x ) . count ( <STRING> ) <NEWLINE> y = x % c <NEWLINE> res = calc ( y ) + 1 <NEWLINE> memo [ x ] = res <NEWLINE> <NL> <DEDENT> for i in range ( 3 , 2 * 10 ** 5 + 1 ) : <NEWLINE> <INDENT> calc ( i ) <NEWLINE> <NL> <DEDENT> Xmodp = Xmodm = 0 <NEWLINE> digit_p = digit_m = 1 <NEWLINE> digit = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if int ( X [ - i - 1 ] ) : <NEWLINE> <INDENT> Xmodp += digit_p <NEWLINE> Xmodp %= c + 1 <NEWLINE> Xmodm += digit_m <NEWLINE> Xmodm %= c - 1 <NEWLINE> <DEDENT> digit [ i ] = [ digit_p , digit_m ] <NEWLINE> digit_p = ( digit_p * 2 ) % ( c + 1 ) <NEWLINE> digit_m = ( digit_m * 2 ) % ( c - 1 ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = int ( X [ - i - 1 ] ) <NEWLINE> if x : <NEWLINE> <INDENT> ans . append ( memo [ ( Xmodm - digit [ i ] [ 1 ] ) % ( c - 1 ) ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( memo [ ( Xmodp + digit [ i ] [ 0 ] ) % ( c + 1 ) ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = ans [ : : - 1 ] <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 100000000 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> visited = [ False for _ in range ( n + 1 ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> def dfs ( node ) : <NEWLINE> <INDENT> visited [ node ] = True <NEWLINE> ret = 0 <NEWLINE> for child in graph [ node ] : <NEWLINE> <INDENT> if not visited [ child ] : <NEWLINE> <INDENT> ret += dfs ( child ) <NEWLINE> <DEDENT> <DEDENT> return ret + 1 <NEWLINE> <NL> <NL> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> rets = [ ] <NEWLINE> for node in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if not visited [ node ] : <NEWLINE> <INDENT> counts = dfs ( node ) <NEWLINE> rets . append ( counts ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( rets ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] = ans [ A [ i ] - 1 ] + 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a == b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_0 = a - b <NEWLINE> ans_1 = b - a <NEWLINE> if abs ( ans_0 ) >= 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif k % 2 != 0 : <NEWLINE> <INDENT> print ( ans_1 ) <NEWLINE> <DEDENT> elif k % 2 == 0 : <NEWLINE> <INDENT> print ( ans_0 ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> c1x , c1y , c1r = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> c2x , c2y , c2r = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> d = math . sqrt ( pow ( c1x - c2x , 2 ) + pow ( c1y - c2y , 2 ) ) <NEWLINE> <NL> s = c1r + c2r <NEWLINE> <NL> if d > s : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif d == s : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if c1r > c2r : <NEWLINE> <INDENT> if d + c2r > c1r : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif d + c2r == c1r : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if d + c1r > c2r : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif d + c1r == c2r : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> <NL> class DoubleLinkedList : <NEWLINE> <INDENT> class Node : <NEWLINE> <INDENT> def __init__ ( self , value = None , prev = None , _next = None ) : <NEWLINE> <INDENT> self . value = value <NEWLINE> self . prev = prev <NEWLINE> self . next = _next <NEWLINE> <NL> <DEDENT> <DEDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . head = self . Node ( ) <NEWLINE> self . tail = self . Node ( ) <NEWLINE> self . head . next = self . tail <NEWLINE> self . tail . prev = self . head <NEWLINE> <NL> <DEDENT> def insert ( self , v ) : <NEWLINE> <INDENT> head = self . head <NEWLINE> node = self . Node ( v , head , head . next ) <NEWLINE> head . next . prev = node <NEWLINE> head . next = node <NEWLINE> <NL> <DEDENT> def delete ( self , node ) : <NEWLINE> <INDENT> if node in ( self . head , self . tail ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . prev . next , node . next . prev = node . next , node . prev <NEWLINE> <NL> <DEDENT> <DEDENT> def delete_first ( self ) : <NEWLINE> <INDENT> self . delete ( self . head . next ) <NEWLINE> <NL> <DEDENT> def delete_last ( self ) : <NEWLINE> <INDENT> self . delete ( self . tail . prev ) <NEWLINE> <NL> <DEDENT> def delete_first_value ( self , v ) : <NEWLINE> <INDENT> node = self . find ( v , self . head ) <NEWLINE> if node is not None : <NEWLINE> <INDENT> self . delete ( node ) <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( self , v , cur = None ) : <NEWLINE> <INDENT> if cur is None : <NEWLINE> <INDENT> cur = self . head <NEWLINE> <NL> <DEDENT> while cur != self . tail : <NEWLINE> <INDENT> cur = cur . next <NEWLINE> if cur . value == v : <NEWLINE> <INDENT> return cur <NEWLINE> <NL> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> cur = self . head . next <NEWLINE> vs = <STRING> <NEWLINE> while cur != self . tail : <NEWLINE> <INDENT> vs += cur . value <NEWLINE> cur = cur . next <NEWLINE> if cur != self . tail : <NEWLINE> <INDENT> vs += <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> return vs <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> steps = int ( input ( ) ) <COMMENT> <NEWLINE> dl = DoubleLinkedList ( ) <NEWLINE> <NL> for command in sys . stdin : <NEWLINE> <INDENT> if command . startswith ( <STRING> ) : <NEWLINE> <INDENT> dl . insert ( command [ 7 : - 1 ] ) <NEWLINE> <DEDENT> elif command . startswith ( <STRING> ) : <NEWLINE> <INDENT> dl . delete_first ( ) <NEWLINE> <DEDENT> elif command . startswith ( <STRING> ) : <NEWLINE> <INDENT> dl . delete_last ( ) <NEWLINE> <DEDENT> elif command . startswith ( <STRING> ) : <NEWLINE> <INDENT> dl . delete_first_value ( command [ 7 : - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dl ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> from decimal import Decimal , ROUND_HALF_UP <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> a , b = tuple ( sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) ) , tuple ( sorted ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> c = 0 <NEWLINE> q = { ( ) : ( 0 , 0 ) } <NEWLINE> for i in range ( 9 ) : <NEWLINE> <INDENT> nq = { } <NEWLINE> for k in q : <NEWLINE> <INDENT> for j in b : <NEWLINE> <INDENT> if j not in k : <NEWLINE> <INDENT> x = q [ k ] [ 0 ] + ( a [ i ] + j ) * ( a [ i ] > j ) <NEWLINE> y = q [ k ] [ 1 ] + ( a [ i ] + j ) * ( a [ i ] < j ) <NEWLINE> if x > 85 : c += math . factorial ( 9 - i - 1 ) <NEWLINE> elif y < 86 : nq [ tuple ( list ( k ) + [ j ] ) ] = ( x , y ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> q = nq <NEWLINE> <DEDENT> c /= 362880 <NEWLINE> print ( <STRING> . format ( Decimal ( c ) . quantize ( Decimal ( <STRING> ) , rounding = ROUND_HALF_UP ) , Decimal ( 1 - c ) . quantize ( Decimal ( <STRING> ) , rounding = ROUND_HALF_UP ) ) ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k <= a : <NEWLINE> <INDENT> ans = k <NEWLINE> <DEDENT> elif k > a and k <= a + b : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a - ( k - ( a + b ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
class OfficialHouse : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . bill = [ [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> <INDENT> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] , <NEWLINE> [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] , <NEWLINE> [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] , <NEWLINE> [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def input_bfrv ( self , b , f , r , v ) : <NEWLINE> <INDENT> self . bill [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> def result ( self ) : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> , <STRING> . join ( map ( str , self . bill [ i ] [ j ] ) ) ) <NEWLINE> <DEDENT> if i != 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> oh = OfficialHouse ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> bfrv = input ( ) . split ( ) <NEWLINE> b = int ( bfrv [ 0 ] ) <NEWLINE> f = int ( bfrv [ 1 ] ) <NEWLINE> r = int ( bfrv [ 2 ] ) <NEWLINE> v = int ( bfrv [ 3 ] ) <NEWLINE> <NL> oh . input_bfrv ( b , f , r , v ) <NEWLINE> <NL> <DEDENT> oh . result ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> nums = [ ] <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nums = sorted ( nums , reverse = True ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> fir_num = nums [ 0 ] <NEWLINE> <NL> del nums [ 0 ] <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> fir_num += nums [ int ( i / 2 ) ] <NEWLINE> <NL> <NL> <DEDENT> print ( fir_num ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> import heapq <NEWLINE> <NL> a = list ( map ( lambda x : int ( x ) * ( - 1 ) , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> tmp_min = heapq . heappop ( a ) <NEWLINE> heapq . heappush ( a , ( - 1 ) * ( - tmp_min // 2 ) ) <NEWLINE> <DEDENT> print ( - sum ( a ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> now = 1 <NEWLINE> used = [ - 228 ] * ( n + 191 ) <NEWLINE> used [ 1 ] = - 1 <NEWLINE> cn = - 292 <NEWLINE> ahah = 1 <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> now = A [ now ] <NEWLINE> if used [ now ] != - 228 : <NEWLINE> <INDENT> cn = _ + 1 - used [ now ] - 1 <NEWLINE> break <NEWLINE> <DEDENT> used [ now ] = _ <NEWLINE> ahah += 1 <NEWLINE> <DEDENT> if cn == - 292 : <NEWLINE> <INDENT> print ( now ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> for i in range ( ( k - ahah ) % cn ) : <NEWLINE> <INDENT> now = A [ now ] <NEWLINE> <DEDENT> print ( now ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans , num = sum ( p [ 0 : K ] ) , sum ( p [ 0 : K ] ) <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> num = num + p [ i + K ] - p [ i ] <NEWLINE> ans = max ( ans , num ) <NEWLINE> <DEDENT> print ( ( ans + K ) / 2 ) <NEWLINE>
<COMMENT> <NL> S = input ( ) <NEWLINE> ans = [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> for i in S : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> ans . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( max ( max ( ans ) , cnt ) ) <NEWLINE>
class Node ( object ) : <NEWLINE> <INDENT> def __init__ ( self , num , prv = None , nxt = None ) : <NEWLINE> <INDENT> self . num = num <NEWLINE> self . prv = prv <NEWLINE> self . nxt = nxt <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class DoublyLinkedList ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . start = self . last = None <NEWLINE> <NL> <DEDENT> def insert ( self , num ) : <NEWLINE> <INDENT> new_elem = Node ( num ) <NEWLINE> <NL> if self . start is None : <NEWLINE> <INDENT> self . start = self . last = new_elem <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> new_elem . nxt = self . start <NEWLINE> self . start . prv = new_elem <NEWLINE> self . start = new_elem <NEWLINE> <NL> <DEDENT> <DEDENT> def delete_num ( self , target ) : <NEWLINE> <INDENT> it = self . start <NEWLINE> while it is not None : <NEWLINE> <INDENT> if it . num == target : <NEWLINE> <INDENT> if it . prv is None and it . nxt is None : <NEWLINE> <INDENT> self . start = self . last = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if it . prv is not None : <NEWLINE> <INDENT> it . prv . nxt = it . nxt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . start = self . start . nxt <NEWLINE> <NL> <DEDENT> if it . nxt is not None : <NEWLINE> <INDENT> it . nxt . prv = it . prv <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . last = self . last . prv <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> it = it . nxt <NEWLINE> <NL> <DEDENT> <DEDENT> def delete_start ( self ) : <NEWLINE> <INDENT> if self . start is self . last : <NEWLINE> <INDENT> self . start = self . last = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . start . nxt . prv = None <NEWLINE> self . start = self . start . nxt <NEWLINE> <NL> <DEDENT> <DEDENT> def delete_last ( self ) : <NEWLINE> <INDENT> if self . start is self . last : <NEWLINE> <INDENT> self . start = self . last = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . last . prv . nxt = None <NEWLINE> self . last = self . last . prv <NEWLINE> <NL> <DEDENT> <DEDENT> def get_content ( self ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> it = self . start <NEWLINE> <NL> while it is not None : <NEWLINE> <INDENT> ret . append ( it . num ) <NEWLINE> it = it . nxt <NEWLINE> <NL> <DEDENT> return <STRING> . join ( ret ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def _main ( ) : <NEWLINE> <INDENT> from sys import stdin <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> lst = DoublyLinkedList ( ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> cmd = stdin . readline ( ) . strip ( ) . split ( ) <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> lst . insert ( cmd [ 1 ] ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> lst . delete_num ( cmd [ 1 ] ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> lst . delete_start ( ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> lst . delete_last ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( lst . get_content ( ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> mul = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> mul *= a [ i ] <NEWLINE> if ( mul > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mul ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> list_n = [ n ] <NEWLINE> <NL> map_n = map ( int , input ( ) . split ( ) ) <NEWLINE> list_n = list ( map_n ) <NEWLINE> <NL> for value in reversed ( list_n ) : <NEWLINE> <INDENT> print ( value , end = <STRING> ) <NEWLINE> if value != list_n [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( m ) ] <NEWLINE> l = [ 1 ] * ( n + 1 ) <NEWLINE> for j in a : <NEWLINE> <INDENT> l [ j ] = 0 <NEWLINE> <DEDENT> x = 10 ** 9 + 7 <NEWLINE> if m > n // 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if 1 not in a : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if l [ i ] : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % x <NEWLINE> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( n ) ] <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> eq = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if eq < n + 1 : <NEWLINE> <INDENT> ans [ eq - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> wa = 0 <NEWLINE> a = 0 <NEWLINE> for l in range ( N - 1 ) : <NEWLINE> <INDENT> a += A [ N - l - 1 ] <NEWLINE> wa += a * A [ N - l - 2 ] <NEWLINE> <DEDENT> print ( wa % ( 10 ** 9 + 7 ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> UR = defaultdict ( list ) <NEWLINE> UD = defaultdict ( list ) <NEWLINE> UL = defaultdict ( list ) <NEWLINE> DR = defaultdict ( list ) <NEWLINE> DL = defaultdict ( list ) <NEWLINE> RL = defaultdict ( list ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x , y , u = input ( ) . split ( ) <NEWLINE> x , y = int ( x ) , int ( y ) <NEWLINE> if u == <STRING> : <NEWLINE> <INDENT> UD [ x ] . append ( ( y , 1 ) ) <NEWLINE> UR [ x + y ] . append ( ( x - y , 0 ) ) <NEWLINE> UL [ y - x ] . append ( ( x + y , 1 ) ) <NEWLINE> <DEDENT> elif u == <STRING> : <NEWLINE> <INDENT> UD [ x ] . append ( ( y , 0 ) ) <NEWLINE> DR [ y - x ] . append ( ( x + y , 0 ) ) <NEWLINE> DL [ x + y ] . append ( ( x - y , 1 ) ) <NEWLINE> <DEDENT> elif u == <STRING> : <NEWLINE> <INDENT> RL [ y ] . append ( ( x , 1 ) ) <NEWLINE> DR [ y - x ] . append ( ( x + y , 1 ) ) <NEWLINE> UR [ x + y ] . append ( ( x - y , 1 ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> RL [ y ] . append ( ( x , 0 ) ) <NEWLINE> UL [ y - x ] . append ( ( x + y , 0 ) ) <NEWLINE> DL [ x + y ] . append ( ( x - y , 0 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = float ( <STRING> ) <NEWLINE> <NL> for x in [ UD , UL , UR , DR , DL , RL ] : <NEWLINE> <INDENT> for v in x . values ( ) : <NEWLINE> <INDENT> V = sorted ( v ) <NEWLINE> <NL> for i in range ( len ( V ) - 1 ) : <NEWLINE> <INDENT> if V [ i ] [ 1 ] and not V [ i + 1 ] [ 1 ] : <NEWLINE> <INDENT> ans = min ( ans , V [ i + 1 ] [ 0 ] - V [ i ] [ 0 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ans == float ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans * 5 ) <NEWLINE> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , K = LI ( ) <NEWLINE> A = LI ( ) <NEWLINE> <NL> <COMMENT> <NL> def cut_num ( x ) : <NEWLINE> <INDENT> ret = sum ( [ math . ceil ( i / x ) - 1 for i in A ] ) <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> ng = 0 <NEWLINE> ok = max ( A ) <NEWLINE> while abs ( ok - ng ) > 10 ** ( - 6 ) : <NEWLINE> <INDENT> m = ( ng + ok ) / 2 <NEWLINE> if cut_num ( m ) <= K : <NEWLINE> <INDENT> ok = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = m <NEWLINE> <NL> <DEDENT> <DEDENT> print ( math . ceil ( ok ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> xy = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> xy . append ( [ x , y ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = xy [ i ] [ 0 ] <NEWLINE> y = xy [ i ] [ 1 ] <NEWLINE> if ( D * D >= ( x * x + y * y ) ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = 2 <NEWLINE> ARR = [ 157 , 193 ] <NEWLINE> <NL> N = 6 <NEWLINE> ARR = [ 200 , 180 , 160 , 140 , 120 , 100 ] <NEWLINE> <NL> N = 7 <NEWLINE> ARR = [ 100 , 130 , 130 , 130 , 115 , 115 , 150 ] <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> ARR = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def prepare ( n , arr ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> result . append ( arr [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if arr [ i ] != arr [ i - 1 ] : <NEWLINE> <INDENT> result . append ( arr [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> def calculate ( arr ) : <NEWLINE> <INDENT> n = len ( arr ) <NEWLINE> result = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> if arr [ i ] > arr [ i - 1 ] : <NEWLINE> <INDENT> result . append ( { <STRING> : 1 , <STRING> : arr [ i ] } ) <NEWLINE> <DEDENT> continue <NEWLINE> <NL> <DEDENT> if i == 0 : <NEWLINE> <INDENT> if arr [ 1 ] > arr [ 0 ] : <NEWLINE> <INDENT> result . append ( { <STRING> : 0 , <STRING> : arr [ i ] } ) <NEWLINE> <DEDENT> continue <NEWLINE> <NL> <DEDENT> if ( arr [ i + 1 ] > arr [ i ] ) and ( arr [ i ] < arr [ i - 1 ] ) : <NEWLINE> <INDENT> result . append ( { <STRING> : 0 , <STRING> : arr [ i ] } ) <NEWLINE> <NL> <DEDENT> if ( arr [ i + 1 ] < arr [ i ] ) and ( arr [ i ] > arr [ i - 1 ] ) : <NEWLINE> <INDENT> result . append ( { <STRING> : 1 , <STRING> : arr [ i ] } ) <NEWLINE> <NL> <DEDENT> <DEDENT> money = 1000 <NEWLINE> num = 0 <NEWLINE> for index , res in enumerate ( result ) : <NEWLINE> <INDENT> type = res . get ( <STRING> ) <NEWLINE> value = res . get ( <STRING> ) <NEWLINE> <NL> if index == ( len ( result ) - 1 ) : <NEWLINE> <INDENT> if value == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> if type == 0 : <NEWLINE> <INDENT> tmpNum = money // value <NEWLINE> num += tmpNum <NEWLINE> money -= value * tmpNum <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> money += num * value <NEWLINE> num = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( money ) <NEWLINE> <NL> <NL> <DEDENT> arr = prepare ( N , ARR ) <NEWLINE> calculate ( arr ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> from math import sqrt <NEWLINE> from collections import deque <NEWLINE> from collections import Counter <NEWLINE> from collections import defaultdict <NEWLINE> <COMMENT> <NL> from collections import OrderedDict <NEWLINE> <COMMENT> <NL> from math import ceil <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> sys . setrecursionlimit ( 11451419 ) <NEWLINE> from decimal import Decimal <COMMENT> <NEWLINE> from functools import lru_cache <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> k = int ( input ( ) ) <NEWLINE> print ( 50 ) ; n = 50 <NEWLINE> if k == 0 : <NEWLINE> <INDENT> print ( <STRING> . join ( [ <STRING> ] * 50 ) ) ; exit ( ) <NEWLINE> <NL> <DEDENT> a = k // n <NEWLINE> b = k % n <NEWLINE> A = [ a + i for i in range ( 50 ) ] <NEWLINE> for i in range ( b ) : <NEWLINE> <INDENT> A = [ A [ j ] - 1 if i != j else A [ j ] + n for j in range ( 50 ) ] <NEWLINE> <DEDENT> print ( * A ) <NEWLINE>
from math import gcd <NEWLINE> from functools import reduce <NEWLINE> def gcds ( * numbers ) : <NEWLINE> <INDENT> return reduce ( gcd , numbers ) <NEWLINE> <DEDENT> K = int ( input ( ) ) <NEWLINE> ans1 = 0 <NEWLINE> ans2 = 0 <NEWLINE> ans3 = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( a , K + 1 ) : <NEWLINE> <INDENT> for c in range ( b , K + 1 ) : <NEWLINE> <INDENT> if a == b and b == c : <NEWLINE> <INDENT> ans1 += gcds ( a , b , c ) <NEWLINE> <DEDENT> elif a == b or b == c or c == a : <NEWLINE> <INDENT> ans2 += gcds ( a , b , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans3 += gcds ( a , b , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans1 + 3 * ans2 + 6 * ans3 ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <COMMENT> <NL> def int1 ( x ) : return int ( x ) - 1 <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MI1 ( ) : return map ( int1 , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LI1 ( ) : return list ( map ( int1 , input ( ) . split ( ) ) ) <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def MS ( ) : return input ( ) . split ( ) <NEWLINE> def LS ( ) : return list ( input ( ) ) <NEWLINE> def LLS ( rows_number ) : return [ LS ( ) for _ in range ( rows_number ) ] <NEWLINE> def printlist ( lst , k = <STRING> ) : print ( k . join ( list ( map ( str , lst ) ) ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> N , M = MI ( ) <NEWLINE> <NL> uf = UnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = MI1 ( ) <NEWLINE> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> tmp = [ ] <NEWLINE> <COMMENT> <NL> for r in uf . roots ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> tmp . append ( uf . size ( r ) ) <NEWLINE> <DEDENT> s = sorted ( tmp , reverse = True ) <NEWLINE> <COMMENT> <NL> if len ( s ) == 1 : <NEWLINE> <INDENT> print ( s [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ 1 ] + s [ 0 ] - s [ 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> C = list ( input ( ) ) <NEWLINE> <NL> l = 0 <NEWLINE> r = N - 1 <NEWLINE> count = 0 <NEWLINE> while l < r : <NEWLINE> <INDENT> if C [ l ] == <STRING> and C [ r ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> r -= 1 <NEWLINE> <DEDENT> elif C [ l ] == <STRING> and C [ r ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> elif C [ r ] == <STRING> and C [ r ] == <STRING> : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> elif C [ l ] == <STRING> and C [ r ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> r -= 1 <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , H ) : <NEWLINE> <INDENT> for j in range ( 0 , W ) : <NEWLINE> <INDENT> if j == W - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import itertools as it <NEWLINE> import sys <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 or M == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> a = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( [ x , y ] ) <NEWLINE> a . append ( [ y , x ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for e in it . permutations ( range ( N ) ) : <NEWLINE> <INDENT> if e [ 0 ] != 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> count = 1 <NEWLINE> for j in range ( N - 1 ) : <NEWLINE> <INDENT> if [ e [ j ] + 1 , e [ j + 1 ] + 1 ] in a : <NEWLINE> <INDENT> count *= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count *= 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans += count <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> from bisect import bisect_right , bisect_left <NEWLINE> <NL> readline = sys . stdin . readline <NEWLINE> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = np . array ( readline ( ) . split ( ) , np . int64 ) <NEWLINE> num_array = np . zeros ( 10 ** 5 , np . int64 ) <NEWLINE> for n in A : <NEWLINE> <INDENT> num_array [ n - 1 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> A_sum = sum ( A ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = np . array ( [ np . array ( readline ( ) . split ( ) , np . int64 ) for n in range ( Q ) ] , np . int64 ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> for q in range ( Q ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> <STRING> <NEWLINE> <NL> <STRING> <NEWLINE> <NL> plus_num = BC [ q ] [ 1 ] - BC [ q ] [ 0 ] <NEWLINE> plus_multiple = num_array [ BC [ q ] [ 0 ] - 1 ] <NEWLINE> <COMMENT> <NL> num_array [ BC [ q ] [ 1 ] - 1 ] += num_array [ BC [ q ] [ 0 ] - 1 ] <NEWLINE> num_array [ BC [ q ] [ 0 ] - 1 ] = 0 <NEWLINE> <NL> A_sum = A_sum + plus_num * plus_multiple <NEWLINE> print ( A_sum ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> c = 1 <NEWLINE> l = 10 ** 18 <NEWLINE> for i in a : <NEWLINE> <INDENT> c *= i <NEWLINE> if c > l : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> num = Counter ( a ) <NEWLINE> s = sum ( a ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s += ( c - b ) * num [ b ] <NEWLINE> num [ c ] += num [ b ] <NEWLINE> num [ b ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> flag_zero = 0 <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> flag_zero = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += math . log10 ( a [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if flag_zero == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif sum > 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum *= a [ i ] <NEWLINE> <DEDENT> if sum > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> d = float ( input ( ) ) <NEWLINE> if d < 0 : break <NEWLINE> a = bin ( int ( d ) ) [ 2 : ] <NEWLINE> if len ( a ) > 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = a . zfill ( 8 ) + <STRING> <NEWLINE> b = d - int ( d ) <NEWLINE> for _ in range ( 4 ) : <NEWLINE> <INDENT> b *= 2 <NEWLINE> if int ( b ) >= 1 : <NEWLINE> <INDENT> a = a + <STRING> <NEWLINE> b -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = a + <STRING> <NEWLINE> <DEDENT> <DEDENT> a = a . ljust ( 13 , <STRING> ) <NEWLINE> print ( <STRING> if 1e-10 < b or len ( a ) > 13 else a ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import math <NEWLINE> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <DEDENT> if n >= 2 : <NEWLINE> <INDENT> ue = lcm ( a [ 0 ] , a [ 1 ] ) <NEWLINE> if n >= 3 : <NEWLINE> <INDENT> for i in range ( 2 , n ) : <NEWLINE> <INDENT> ue = lcm ( ue , a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ue = a [ 0 ] <NEWLINE> <NL> <DEDENT> shita = 0 <NEWLINE> if n >= 2 : <NEWLINE> <INDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> shita += ue // a [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> shita = n <NEWLINE> <NL> <DEDENT> ans = ue / shita <NEWLINE> print ( <STRING> ) <NEWLINE>
import math <NEWLINE> <NL> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( math . sqrt ( abs ( x2 - x1 ) ** 2 + abs ( y2 - y1 ) ** 2 ) ) <NEWLINE>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> aa = list ( sorted ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> bb = list ( sorted ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> cc = list ( sorted ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for b in bb : <NEWLINE> <INDENT> ax = bisect . bisect_left ( aa , b ) <NEWLINE> ci = bisect . bisect ( cc , b ) <NEWLINE> cx = len ( cc ) - ci <NEWLINE> ans += ax * cx <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for val in As : <NEWLINE> <INDENT> if val == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for val in As : <NEWLINE> <INDENT> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if val == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> ans = val * ans <NEWLINE> if 10 ** 18 < ans : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> from collections import Counter <NEWLINE> <NL> def II ( ) : return int ( input ( ) ) <NEWLINE> def MII ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LII ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = LII ( ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> ax = max ( A ) + 1 <NEWLINE> dp = [ 0 ] * ax <NEWLINE> for ai in A : <NEWLINE> <INDENT> da = dp [ ai ] <NEWLINE> if da > 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ ai ] += 1 <NEWLINE> if da == 0 : <NEWLINE> <INDENT> for aj in range ( 2 * ai , ax , ai ) : <NEWLINE> <INDENT> dp [ aj ] = 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( filter ( lambda x : x == 1 , dp ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) ; <NEWLINE> print ( a * b , 2 * a + 2 * b ) ; <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for j in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ j ] + B [ j ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while a [ i ] + b [ j ] > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ ] <NEWLINE> C = [ 0 ] * ( max ( A ) + 1 ) <NEWLINE> for a in A : C [ a ] += 1 <NEWLINE> i = 0 <NEWLINE> for k in C : B += [ str ( i ) ] * k ; i += 1 <NEWLINE> print ( <STRING> . join ( B ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 500 * 500 ) <NEWLINE> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> edges = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N - 1 ) ] <NEWLINE> tree = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> <NL> for edge in edges : <NEWLINE> <INDENT> tree [ edge [ 0 ] ] . append ( [ edge [ 1 ] , edge [ 2 ] ] ) <NEWLINE> tree [ edge [ 1 ] ] . append ( [ edge [ 0 ] , edge [ 2 ] ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> depth = [ - 1 ] * ( N + 1 ) <NEWLINE> depth [ 1 ] = 0 <NEWLINE> <NL> def dfs ( tree , s ) : <NEWLINE> <INDENT> for l in tree [ s ] : <NEWLINE> <INDENT> if depth [ l [ 0 ] ] == - 1 : <NEWLINE> <INDENT> depth [ l [ 0 ] ] = depth [ s ] + l [ 1 ] <NEWLINE> dfs ( tree , l [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( tree , 1 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> for l in depth [ 1 : ] : <NEWLINE> <INDENT> if l % 2 == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> s = input ( ) . split ( ) <NEWLINE> cir = 2 * ( int ( s [ 0 ] ) + int ( s [ 1 ] ) ) <NEWLINE> area = int ( s [ 0 ] ) * int ( s [ 1 ] ) <NEWLINE> print ( area , cir ) <NEWLINE>
import math <NEWLINE> <NL> def sign ( x ) : <NEWLINE> <INDENT> if x >= 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> while n != 0 : <NEWLINE> <INDENT> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> b = [ ] <NEWLINE> b . append ( a [ 0 ] ) <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> if b [ len ( b ) - 1 ] > 0 and a [ i ] > 0 : <NEWLINE> <INDENT> b [ len ( b ) - 1 ] = b [ len ( b ) - 1 ] + a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = b [ 0 ] <NEWLINE> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> S = 0 <NEWLINE> for j in range ( i , len ( b ) ) : <NEWLINE> <INDENT> S = S + b [ j ] <NEWLINE> ans = max ( S , ans ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> <DEDENT>
r , g , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> rgb = sorted ( [ r , g , b ] ) <NEWLINE> n_rgb = [ ] <NEWLINE> for e in rgb : <NEWLINE> <INDENT> n_rgb . append ( n // e ) <NEWLINE> <DEDENT> for i in range ( n_rgb [ 2 ] + 1 ) : <NEWLINE> <INDENT> N2 = n - i * rgb [ 2 ] <NEWLINE> for j in range ( n_rgb [ 1 ] + 1 ) : <NEWLINE> <INDENT> N = N2 - j * rgb [ 1 ] <NEWLINE> if N >= 0 and N % rgb [ 0 ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> D = [ 0 ] * ( K + 1 ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( K , 0 , - 1 ) : <NEWLINE> <INDENT> D [ i ] = ( pow ( K // i , N , mod ) - sum ( D [ i : : i ] ) ) % mod <NEWLINE> ans += ( D [ i ] * i ) % mod <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> def calc ( b , e ) : <NEWLINE> <INDENT> cnt = e // b <NEWLINE> return ( b + e ) * cnt // 2 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += calc ( i , n // i * i ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ans_list = [ 0 for i in range ( N ) ] <NEWLINE> <NL> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <NL> <INDENT> left_eq = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if ( left_eq <= N ) : <NEWLINE> <INDENT> ans_list [ left_eq - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans_list [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> <NL> prm_dict = { i : True for i in range ( 2 , 100004 ) } <NEWLINE> for n in range ( 2 , 100004 ) : <NEWLINE> <INDENT> if prm_dict [ n ] : <NEWLINE> <INDENT> if n >= x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for nk in range ( n * 2 , 100004 , n ) : <NEWLINE> <INDENT> prm_dict [ nk ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
t = input ( <STRING> ) <NEWLINE> <NL> tlist = list ( t ) <NEWLINE> for i in range ( len ( tlist ) ) : <NEWLINE> <INDENT> if tlist [ i ] == <STRING> : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> tlist [ i ] = <STRING> <NEWLINE> <DEDENT> elif i == len ( tlist ) - 1 : <NEWLINE> <INDENT> tlist [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if tlist [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> if tlist [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> tlist [ i ] = <STRING> <NEWLINE> <DEDENT> elif tlist [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> tlist [ i ] = <STRING> <NEWLINE> <DEDENT> elif tlist [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> tlist [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if tlist [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> tlist [ i ] = <STRING> <NEWLINE> <DEDENT> elif tlist [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> tlist [ i ] = <STRING> <NEWLINE> <DEDENT> elif tlist [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> tlist [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( tlist ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> total = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> total = total * A [ i ] <NEWLINE> if total > 10 ** 18 : <NEWLINE> <INDENT> total = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> value = [ 0 ] * n <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> value [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> seen = [ False ] * n <NEWLINE> def dfs ( v ) : <NEWLINE> <INDENT> seen [ v ] = True <NEWLINE> for nv in g [ v ] : <NEWLINE> <INDENT> if seen [ nv ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> value [ nv ] += value [ v ] <NEWLINE> dfs ( nv ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * value ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> A [ i ] += A [ i - 1 ] <NEWLINE> <DEDENT> A = Counter ( A ) <NEWLINE> k = 0 <NEWLINE> for j in A . values ( ) : <NEWLINE> <INDENT> k += j * ( j - 1 ) // 2 <NEWLINE> <DEDENT> k += A . get ( 0 , 0 ) <NEWLINE> print ( k ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maxI = 0 <NEWLINE> maxT = 0 <NEWLINE> t = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t += p [ i ] <NEWLINE> if k <= i : <NEWLINE> <INDENT> t -= p [ i - k ] <NEWLINE> <DEDENT> if maxT < t : <NEWLINE> <INDENT> maxT = t <NEWLINE> maxI = i <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> <NL> def calc ( n ) : <NEWLINE> <INDENT> return n * ( n + 1 ) / 2 / n <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += i / n <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> for i in range ( maxI - k + 1 , maxI + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += calc ( p [ i ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = lcm ( C , D ) <NEWLINE> <NL> temp = l - ( l // C + l // D - 1 ) <NEWLINE> <NL> a = ( A - 1 ) % l <NEWLINE> b = B % l <NEWLINE> <NL> aa = ( A - 1 ) // l <NEWLINE> bb = B // l <NEWLINE> <NL> tempA = a - ( a // C + a // D - 1 ) <NEWLINE> tempB = b - ( b // C + b // D - 1 ) <NEWLINE> <NL> <NL> ans = temp * bb + tempB - ( temp * aa + tempA ) <NEWLINE> <NL> <NL> print ( ans ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> dd = { i : [ ] for i in range ( N ) } <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> dd [ a - 1 ] . append ( b - 1 ) <NEWLINE> dd [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> ans = [ 0 for _ in range ( N ) ] <NEWLINE> visited = [ False for _ in range ( N ) ] <NEWLINE> queue = [ ] <NEWLINE> for i in range ( len ( dd [ 0 ] ) ) : <NEWLINE> <INDENT> queue . append ( [ 0 , dd [ 0 ] [ i ] ] ) <NEWLINE> <DEDENT> queue = deque ( queue ) <NEWLINE> while queue : <NEWLINE> <INDENT> q = queue . popleft ( ) <NEWLINE> if visited [ q [ 1 ] ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited [ q [ 1 ] ] = True <NEWLINE> ans [ q [ 1 ] ] = q [ 0 ] + 1 <NEWLINE> for v in dd [ q [ 1 ] ] : <NEWLINE> <INDENT> if not visited [ v ] : <NEWLINE> <INDENT> queue . append ( [ q [ 1 ] , v ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * ans [ 1 : ] , sep = <STRING> ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> U = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = np . uint64 ) <NEWLINE> V = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = np . uint64 ) <NEWLINE> <NL> ans = np . zeros ( ( N , N ) , dtype = np . uint64 ) <NEWLINE> <NL> for n in range ( 64 ) : <NEWLINE> <INDENT> u = ( U >> n ) & 1 <NEWLINE> v = ( V >> n ) & 1 <NEWLINE> su = [ int ( S [ i ] * 2 + u [ i ] ) for i in range ( N ) ] <NEWLINE> tv = [ int ( T [ i ] * 2 + v [ i ] ) for i in range ( N ) ] <NEWLINE> suzerozero = [ ] <NEWLINE> suoneone = [ ] <NEWLINE> tvzerozero = [ ] <NEWLINE> tvoneone = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if su [ i ] == 0 : <NEWLINE> <INDENT> suzerozero . append ( i ) <NEWLINE> <DEDENT> if su [ i ] == 3 : <NEWLINE> <INDENT> suoneone . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if tv [ i ] == 0 : <NEWLINE> <INDENT> tvzerozero . append ( i ) <NEWLINE> <DEDENT> if tv [ i ] == 3 : <NEWLINE> <INDENT> tvoneone . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> b = np . zeros ( ( N , N ) , dtype = np . uint64 ) <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if su [ i ] == 1 : <NEWLINE> <INDENT> b [ i ] = np . ones ( N , int ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if tv [ i ] == 1 : <NEWLINE> <INDENT> b [ : , i ] = np . ones ( N , int ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> b |= np . dot ( np . array ( [ u ] ) . T , np . ones ( ( 1 , N ) , dtype = np . uint64 ) ) & np . dot ( np . array ( [ v ] ) . T , np . ones ( ( 1 , N ) , dtype = np . uint64 ) ) . T <NEWLINE> <COMMENT> <NL> if 1 not in tv and 3 not in tv : <NEWLINE> <INDENT> m = len ( tvzerozero ) <NEWLINE> now = 0 <NEWLINE> for i in suoneone : <NEWLINE> <INDENT> b [ i ] [ tvzerozero [ now % m ] ] += 1 <NEWLINE> now += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if 1 not in su and 3 not in su : <NEWLINE> <INDENT> m = len ( suzerozero ) <NEWLINE> now = 0 <NEWLINE> for i in tvoneone : <NEWLINE> <INDENT> b [ suzerozero [ now % m ] ] [ i ] += 1 <NEWLINE> now += 1 <NEWLINE> <DEDENT> <DEDENT> ans += b << n <NEWLINE> <NL> <DEDENT> def end ( ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == 0 : <NEWLINE> <INDENT> now = ans [ i ] [ 0 ] <NEWLINE> for j in range ( 1 , N ) : <NEWLINE> <INDENT> now &= ans [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> if S [ i ] == 1 : <NEWLINE> <INDENT> now = ans [ i ] [ 0 ] <NEWLINE> for j in range ( 1 , N ) : <NEWLINE> <INDENT> now |= ans [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> if now != U [ i ] : <NEWLINE> <INDENT> end ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if T [ i ] == 0 : <NEWLINE> <INDENT> now = ans [ 0 ] [ i ] <NEWLINE> for j in range ( 1 , N ) : <NEWLINE> <INDENT> now &= ans [ j ] [ i ] <NEWLINE> <DEDENT> <DEDENT> if T [ i ] == 1 : <NEWLINE> <INDENT> now = ans [ 0 ] [ i ] <NEWLINE> for j in range ( 1 , N ) : <NEWLINE> <INDENT> now |= ans [ j ] [ i ] <NEWLINE> <DEDENT> <DEDENT> if now != V [ i ] : <NEWLINE> <INDENT> end ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for item in ans : <NEWLINE> <INDENT> print ( * list ( item ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = 1 <NEWLINE> a . sort ( ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> x *= a [ i ] <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from bisect import bisect_left <NEWLINE> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> def dist ( x , s , t ) : <NEWLINE> <INDENT> if s < x and t < x : <NEWLINE> <INDENT> return x - min ( s , t ) <NEWLINE> <DEDENT> elif s > x and t > x : <NEWLINE> <INDENT> return max ( s , t ) - x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( ds : = abs ( x - s ) ) <= ( dt : = abs ( x - t ) ) : <NEWLINE> <INDENT> return 2 * ds + dt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ds + 2 * dt <NEWLINE> <DEDENT> <DEDENT> <DEDENT> def near ( A , x ) : <NEWLINE> <INDENT> if ( i : = bisect_left ( A , x ) ) == 0 : <NEWLINE> <INDENT> return [ A [ 0 ] , ] <NEWLINE> <DEDENT> elif 0 < i < len ( A ) : <NEWLINE> <INDENT> return [ A [ i - 1 ] , A [ i ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ A [ - 1 ] , ] <NEWLINE> <DEDENT> <DEDENT> a , b , q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ int ( input ( ) ) for _ in range ( a ) ] <NEWLINE> T = [ int ( input ( ) ) for _ in range ( b ) ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> ans = 100000000000 <NEWLINE> for s in near ( S , x ) : <NEWLINE> <INDENT> for t in near ( T , x ) : <NEWLINE> <INDENT> ans = min ( ans , dist ( x , s , t ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> a = r ** 2 * math . pi <NEWLINE> c = r * 2 * math . pi <NEWLINE> <NL> print ( <STRING> % ( a ) , <STRING> % ( c ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> power = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> power *= i <NEWLINE> power %= mod <NEWLINE> <NL> <DEDENT> print ( power % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> arr = make_divisors ( n ) <NEWLINE> arr = [ x - 1 for x in arr if x >= 2 ] <NEWLINE> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for x in arr [ : : - 1 ] : <NEWLINE> <INDENT> if n // x != n % x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += x <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans = min ( ans , 10 ** 20 ) <NEWLINE> <DEDENT> print ( ans if ans <= 10 ** 18 else - 1 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for cal in a : <NEWLINE> <INDENT> ans *= cal <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> flag = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> flag = 2 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag != 2 : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif flag == 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> big = max ( 30 * h + ( m * 0.5 ) , 6 * m ) <NEWLINE> small = min ( 30 * h + ( m * 0.5 ) , 6 * m ) <NEWLINE> gap = min ( big - small , 360 - ( big - small ) ) <NEWLINE> <NL> print ( format ( math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( math . radians ( gap ) ) ) , <STRING> ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> S = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S *= A [ i ] <NEWLINE> if S > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( S ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if K <= A : <NEWLINE> <INDENT> ans = K <NEWLINE> <DEDENT> elif K <= A + B : <NEWLINE> <INDENT> ans = A <NEWLINE> <DEDENT> elif K <= A + B + C : <NEWLINE> <INDENT> ans = A - ( K - A - B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A - C <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
nums = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> if nums [ 0 ] < nums [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif nums [ 0 ] > nums [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import os <NEWLINE> <NL> def file_input ( ) : <NEWLINE> <INDENT> f = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdin = f <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = 1 <NEWLINE> keys = list ( range ( N ) ) <NEWLINE> li = { s : - 1 for s in keys } <NEWLINE> li [ 0 ] = 0 <NEWLINE> <NL> roop = 0 <NEWLINE> pre_d = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> pre_d = d <NEWLINE> d = A [ d - 1 ] <NEWLINE> <COMMENT> <NL> if li [ d - 1 ] != - 1 : <NEWLINE> <INDENT> roop = i - li [ d - 1 ] <NEWLINE> <COMMENT> <NL> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li [ d - 1 ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> if roop != 0 : <NEWLINE> <INDENT> k = 1 <NEWLINE> for j in range ( ( K - li [ d - 1 ] - 1 ) % roop + li [ d - 1 ] + 1 ) : <NEWLINE> <INDENT> k = A [ k - 1 ] <NEWLINE> <DEDENT> print ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> scores = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> right = k <NEWLINE> left = right - k + 1 <NEWLINE> <NL> while right < n : <NEWLINE> <INDENT> if scores [ right ] > scores [ left - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> right += 1 <NEWLINE> left += 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> file_input = sys . stdin <NEWLINE> <NL> v_num , e_num , r = map ( int , file_input . readline ( ) . split ( ) ) <NEWLINE> <NL> G = [ [ ] for i in range ( v_num ) ] <NEWLINE> <NL> import heapq <NEWLINE> <NL> for line in file_input : <NEWLINE> <INDENT> s , t , w = map ( int , line . split ( ) ) <NEWLINE> if t != r : <NEWLINE> <INDENT> heapq . heappush ( G [ t ] , [ w , s , t ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> def find_cycle ( incoming_edges , root ) : <NEWLINE> <INDENT> in_tree = [ False ] * v_num <NEWLINE> in_tree [ root ] = True <NEWLINE> for e in incoming_edges : <NEWLINE> <INDENT> if e : <NEWLINE> <INDENT> S = [ ] <NEWLINE> S . append ( e [ 2 ] ) <NEWLINE> while True : <NEWLINE> <INDENT> p = incoming_edges [ S [ - 1 ] ] [ 1 ] <NEWLINE> if in_tree [ p ] : <NEWLINE> <INDENT> while S : <NEWLINE> <INDENT> in_tree [ S . pop ( ) ] = True <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> elif p in S : <NEWLINE> <INDENT> return S [ S . index ( p ) : ] <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . append ( p ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <DEDENT> def contract_cycle ( digraph , cycle_node , root ) : <NEWLINE> <INDENT> super_node = cycle_node [ 0 ] <NEWLINE> for edges in digraph : <NEWLINE> <INDENT> if edges : <NEWLINE> <INDENT> min_weight = edges [ 0 ] [ 0 ] <NEWLINE> for e in edges : <NEWLINE> <INDENT> e [ 0 ] -= min_weight <NEWLINE> if e [ 1 ] in cycle_node : <NEWLINE> <INDENT> e [ 1 ] = super_node <NEWLINE> <DEDENT> if e [ 2 ] in cycle_node : <NEWLINE> <INDENT> e [ 2 ] = super_node <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> contracted_edges = [ ] <NEWLINE> for n in cycle_node : <NEWLINE> <INDENT> for e in digraph [ n ] : <NEWLINE> <INDENT> if e [ 1 ] != super_node : <NEWLINE> <INDENT> heapq . heappush ( contracted_edges , e ) <NEWLINE> <DEDENT> <DEDENT> digraph [ n ] . clear ( ) <NEWLINE> <DEDENT> digraph [ super_node ] = contracted_edges <NEWLINE> <NL> <DEDENT> def edmonds_branching ( digraph , root , weight ) : <NEWLINE> <INDENT> min_incoming_edges = [ None ] * v_num <NEWLINE> for edges in digraph : <NEWLINE> <INDENT> if edges : <NEWLINE> <INDENT> min_edge = edges [ 0 ] <NEWLINE> min_incoming_edges [ min_edge [ 2 ] ] = min_edge <NEWLINE> weight += min_edge [ 0 ] <NEWLINE> <DEDENT> <DEDENT> C = find_cycle ( min_incoming_edges , root ) <NEWLINE> if not C : <NEWLINE> <INDENT> return weight <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> contract_cycle ( digraph , C , r ) <NEWLINE> return edmonds_branching ( digraph , root , weight ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( edmonds_branching ( G , r , 0 ) ) <NEWLINE>
from functools import reduce <NEWLINE> <NL> n = input ( ) <NEWLINE> xs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MAX = 10 ** 18 <NEWLINE> <NL> if 0 in xs : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> result = 1 <NEWLINE> <NL> for x in xs : <NEWLINE> <INDENT> result *= x <NEWLINE> <NL> if result > MAX : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
x , n = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ps = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> best = 100000000 <NEWLINE> ret = x <NEWLINE> <NL> if n : <NEWLINE> <INDENT> mn = min ( ps ) <NEWLINE> mx = max ( ps ) <NEWLINE> s = set ( ps ) <NEWLINE> for i in range ( mn , mx + 1 ) : <NEWLINE> <INDENT> if i not in s : <NEWLINE> <INDENT> d = abs ( x - i ) <NEWLINE> if d < best : <NEWLINE> <INDENT> best = d <NEWLINE> ret = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ret == x : <NEWLINE> <INDENT> up = abs ( mx + 1 - x ) <NEWLINE> down = abs ( mn - 1 - x ) <NEWLINE> ret = mn - 1 if down <= up else mx + 1 <NEWLINE> <DEDENT> if x not in s : <NEWLINE> <INDENT> ret = x <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <NL>
def resolve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> ord = [ - 1 for i in range ( n + 1 ) ] <NEWLINE> rep = 1 <NEWLINE> pos = 1 <NEWLINE> while ord [ pos ] == - 1 : <NEWLINE> <INDENT> ord [ pos ] = len ( s ) <NEWLINE> s . append ( pos ) <NEWLINE> pos = A [ pos - 1 ] <NEWLINE> rep += 1 <NEWLINE> <NL> <DEDENT> rep = len ( s ) - ord [ pos ] <NEWLINE> <COMMENT> <NL> l = ord [ pos ] <NEWLINE> if k < l : <NEWLINE> <INDENT> print ( s [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> k -= l <NEWLINE> k %= rep <NEWLINE> print ( s [ l + k ] ) <NEWLINE> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
class Quicksort : <NEWLINE> <INDENT> def quicksort ( self , a , p , r ) : <NEWLINE> <INDENT> if p < r : <NEWLINE> <INDENT> q = self . partion ( a , p , r ) <NEWLINE> self . quicksort ( a , p , q - 1 ) <NEWLINE> self . quicksort ( a , q + 1 , r ) <NEWLINE> <DEDENT> return ( a ) <NEWLINE> <NL> <DEDENT> def partion ( self , a , p , r ) : <NEWLINE> <INDENT> x = a [ r ] [ 1 ] <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if a [ j ] [ 1 ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> a [ i ] , a [ j ] = a [ j ] , a [ i ] <NEWLINE> <DEDENT> <DEDENT> a [ i + 1 ] , a [ r ] = a [ r ] , a [ i + 1 ] <NEWLINE> return ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def bubbleSort ( a , n ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> while flag == 1 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for j in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if a [ j ] [ 1 ] < a [ j - 1 ] [ 1 ] : <NEWLINE> <INDENT> a [ j ] , a [ j - 1 ] = a [ j - 1 ] , a [ j ] <NEWLINE> flag = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ( a ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) . rstrip ( ) ) <NEWLINE> cards = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> tmp [ 1 ] = int ( tmp [ 1 ] ) <NEWLINE> cards . append ( tmp ) <NEWLINE> <DEDENT> a = cards [ : ] <NEWLINE> b = cards [ : ] <NEWLINE> x = Quicksort ( ) <NEWLINE> a = x . quicksort ( a , 0 , n - 1 ) <NEWLINE> b = sorted ( b , key = lambda i : i [ 1 ] ) <NEWLINE> <NL> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> i [ 1 ] = str ( i [ 1 ] ) <NEWLINE> print ( <STRING> . join ( i ) ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( N % K , - N % K ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( m ) ] <NEWLINE> a = set ( a ) <NEWLINE> d = [ 1 ] + [ 1 ] * n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> d [ i ] = 0 <NEWLINE> d [ i + 1 ] = d [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i + 1 ] = d [ i ] + d [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( d [ n ] % 1000000007 ) <NEWLINE>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> g = [ ] <NEWLINE> for i in range ( l [ 1 ] ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if li [ a - 1 ] == li [ b - 1 ] : <NEWLINE> <INDENT> g += [ a , b ] <NEWLINE> <DEDENT> if li [ a - 1 ] > li [ b - 1 ] : <NEWLINE> <INDENT> g += [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g += [ a ] <NEWLINE> <NL> <DEDENT> <DEDENT> g = set ( g ) <NEWLINE> r = l [ 0 ] - len ( g ) <NEWLINE> print ( r ) <NEWLINE>
def mips ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def msps ( ) : <NEWLINE> <INDENT> return map ( str , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> import itertools <NEWLINE> N , M , X = mips ( ) <NEWLINE> know = dict ( ) <NEWLINE> price = [ [ ] for _ in range ( N ) ] <NEWLINE> L = [ ] <NEWLINE> C = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> know [ i ] = 0 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> L . append ( [ i for i in mips ( ) ] ) <NEWLINE> C . append ( L [ i ] [ 0 ] ) <NEWLINE> L [ i ] . remove ( L [ i ] [ 0 ] ) <NEWLINE> <DEDENT> Money = [ ] <NEWLINE> paid = 0 <NEWLINE> K = [ ] <NEWLINE> No = 0 <NEWLINE> P = [ ] <NEWLINE> Q = [ i for i in range ( N ) ] <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> P . append ( list ( itertools . combinations ( Q , i ) ) ) <NEWLINE> <DEDENT> for k in range ( N + 1 ) : <NEWLINE> <INDENT> for el in P [ k ] : <NEWLINE> <INDENT> for book in el : <NEWLINE> <INDENT> K = L [ book ] <NEWLINE> paid += C [ book ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> know [ i ] += K [ i ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> if know [ i ] < X : <NEWLINE> <INDENT> No = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if No == 0 : <NEWLINE> <INDENT> Money . append ( paid ) <NEWLINE> <DEDENT> paid = 0 <NEWLINE> No = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> know [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if Money == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( Money ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = input ( ) . split ( ) <NEWLINE> ans = 1 <NEWLINE> T = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if l [ i ] == <STRING> : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans != 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> ans = ans * int ( l [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if False : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> import math <NEWLINE> minn = 100000000000000000000 <NEWLINE> for i in range ( 1 , int ( math . sqrt ( n ) ) + 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> j = n / i <NEWLINE> minn = min ( int ( i + j - 2 ) , minn ) <NEWLINE> <DEDENT> <DEDENT> print ( minn ) <NEWLINE>
<NL> def resolve ( ) : <NEWLINE> <INDENT> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> return <NEWLINE> <DEDENT> A = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = { } <NEWLINE> for i in range ( - 10 , 110 ) : <NEWLINE> <INDENT> if i not in A : <NEWLINE> <INDENT> dic [ i ] = abs ( X - i ) <NEWLINE> <NL> <DEDENT> <DEDENT> sorted_A = sorted ( dic . items ( ) , key = lambda x : ( x [ 1 ] , x [ 0 ] ) ) <NEWLINE> print ( sorted_A [ 0 ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
from bisect import bisect_left <NEWLINE> <NL> <NL> while True : <NEWLINE> <INDENT> N , Q = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> era = { } <COMMENT> <NEWLINE> <NL> years = [ ] <COMMENT> <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> name , j , w = input ( ) . split ( <STRING> ) <NEWLINE> j , w = int ( j ) , int ( w ) <NEWLINE> era [ w ] = ( name , j ) <NEWLINE> years . append ( w ) <NEWLINE> <DEDENT> years . sort ( ) <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> q = int ( input ( ) ) <NEWLINE> i = bisect_left ( years , q ) <NEWLINE> if i >= len ( years ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> y = years [ i ] <NEWLINE> name , length = era [ y ] <NEWLINE> if q - y + length <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( name + <STRING> + str ( q - y + length ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> def main ( ) : <NEWLINE> <INDENT> i = int ( input ( ) ) <NEWLINE> j = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 1 <NEWLINE> <NL> if 0 in j : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for jj in j : <NEWLINE> <INDENT> res *= jj <NEWLINE> if math . pow ( 10 , 18 ) < res : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> n_hoge = int ( N ** 0.5 ) <NEWLINE> print <NEWLINE> <NL> true_ans = 10 ** 12 <NEWLINE> for i in range ( 1 , n_hoge + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> ans = N // i <NEWLINE> true_ans = min ( ans + i - 2 , true_ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( true_ans ) <NEWLINE>
K , S = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for x in range ( max ( 0 , S - 2 * K ) , min ( K , S ) + 1 ) : <NEWLINE> <INDENT> ans += min ( K , S - x ) - max ( 0 , S - x - K ) + 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> score = [ ] <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if l [ i - K ] < l [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( ) <NEWLINE> B = list ( ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> B . sort ( reverse = True ) <NEWLINE> if N % 2 == 1 : <NEWLINE> <INDENT> print ( B [ ( N + 1 ) // 2 - 1 ] - A [ ( N + 1 ) // 2 - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( B [ ( N + 1 ) // 2 - 1 ] - A [ ( N + 1 ) // 2 - 1 ] ) + ( B [ ( N + 1 ) // 2 ] - A [ ( N + 1 ) // 2 ] ) + 1 ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> if S == T [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = ( int ) ( input ( ) ) <NEWLINE> a = sorted ( list ( input ( ) for i in range ( n ) ) ) <NEWLINE> lis = sorted ( list ( set ( a ) ) ) <NEWLINE> big = [ 0 for i in range ( len ( lis ) ) ] <NEWLINE> maxi = 0 <NEWLINE> counter = 1 <NEWLINE> check = 0 <NEWLINE> <COMMENT> <NL> for i in range ( len ( a ) - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> big [ check ] = counter <NEWLINE> counter = 1 <NEWLINE> check += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> big [ - 1 ] = counter <NEWLINE> <DEDENT> maxi = max ( big ) <NEWLINE> <COMMENT> <NL> for i in range ( len ( lis ) ) : <NEWLINE> <INDENT> if big [ i ] == maxi : <NEWLINE> <INDENT> print ( lis [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = l [ 0 ] , sum ( l [ 1 : ] ) <NEWLINE> m = abs ( a - b ) <NEWLINE> for v in l [ 1 : - 1 ] : <NEWLINE> <INDENT> a += v <NEWLINE> b -= v <NEWLINE> m = min ( m , abs ( a - b ) ) <NEWLINE> <DEDENT> print ( m ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> indexes = np . arange ( 0 , N ) <NEWLINE> <NL> dp = np . zeros ( shape = N + 1 , dtype = np . int64 ) <NEWLINE> <NL> for k in range ( K ) : <NEWLINE> <INDENT> np . add . at ( dp , np . maximum ( 0 , indexes - A ) , 1 ) <NEWLINE> np . add . at ( dp , np . minimum ( N , indexes + A + 1 ) , - 1 ) <NEWLINE> A = dp . cumsum ( ) [ : - 1 ] <NEWLINE> if np . all ( A == N ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp *= 0 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> lb = [ 0 ] * ( len ( B ) + 1 ) <NEWLINE> lsum = [ 0 ] * ( len ( B ) + 1 ) <NEWLINE> temp = 0 <NEWLINE> for i in range ( len ( B ) ) : <NEWLINE> <INDENT> lb [ i ] = bisect . bisect_left ( A , B [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( B ) ) : <NEWLINE> <INDENT> lsum [ i ] = lb [ i ] + lsum [ i - 1 ] <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( C ) ) : <NEWLINE> <INDENT> temp = bisect . bisect_left ( B , C [ i ] ) <NEWLINE> ans += lsum [ temp - 1 ] <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
T = input ( ) <NEWLINE> S = [ ] <NEWLINE> for n in range ( 0 , len ( T ) ) : <NEWLINE> <INDENT> if T [ n ] == <STRING> : <NEWLINE> <INDENT> S . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . append ( T [ n ] ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( S ) ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( A ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> w = S . count ( <STRING> ) <NEWLINE> b = 0 <NEWLINE> ans = min ( w , N - w ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> w -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> ans = min ( ans , w + b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL>
import numpy as np <NEWLINE> import math <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> i = B - 1 <NEWLINE> <NL> if i >= N : <NEWLINE> <INDENT> x = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> <NL> <DEDENT> print ( math . floor ( ( A * x ) / B ) - A * math . floor ( ( x / B ) ) ) <NEWLINE>
c = input ( ) <NEWLINE> al = <STRING> <NEWLINE> print ( al [ al . index ( c ) + 1 ] ) <NEWLINE>
<NL> def s0 ( ) : return input ( ) <NEWLINE> def s1 ( ) : return input ( ) . split ( ) <NEWLINE> def s2 ( n ) : return [ input ( ) for x in range ( n ) ] <NEWLINE> def s3 ( n ) : return [ input ( ) . split ( ) for _ in range ( n ) ] <NEWLINE> def s4 ( n ) : return [ [ x for x in s ] for s in s2 ( n ) ] <NEWLINE> def n0 ( ) : return int ( input ( ) ) <NEWLINE> def n1 ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def n2 ( n ) : return [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def n3 ( n ) : return [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( n ) ] <NEWLINE> def t3 ( n ) : return [ tuple ( int ( x ) for x in input ( ) . split ( ) ) for _ in range ( n ) ] <NEWLINE> def p0 ( b , yes = <STRING> , no = <STRING> ) : print ( yes if b else no ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> x , n = n1 ( ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = n1 ( ) <NEWLINE> if ( not x in P ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = [ ] <NEWLINE> d2 = [ ] <NEWLINE> for i in range ( 0 , 102 ) : <NEWLINE> <INDENT> if ( not i in P ) : <NEWLINE> <INDENT> d . append ( i ) <NEWLINE> d2 . append ( abs ( x - i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> a = min ( d2 ) <NEWLINE> if ( x - a ) in d : <NEWLINE> <INDENT> print ( x - a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x + a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> from collections import Counter <NEWLINE> s = input ( ) <NEWLINE> <NL> n = 2019 <NEWLINE> l = [ 0 ] <NEWLINE> t = 1 <NEWLINE> for i , x in enumerate ( s [ : : - 1 ] ) : <NEWLINE> <INDENT> t = t * 10 % n <NEWLINE> y = ( l [ - 1 ] + int ( x ) * t ) % n <NEWLINE> l . append ( y ) <NEWLINE> <NL> <DEDENT> c = Counter ( l ) <NEWLINE> ans = sum ( [ v * ( v - 1 ) // 2 for v in c . values ( ) ] ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> a = x ** 2 + y ** 2 + z ** 2 + x * z + y * z + x * y <NEWLINE> if a <= n : <NEWLINE> <INDENT> arr [ a ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( arr [ i ] ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> ans = { 0 : 1 } <NEWLINE> memo = [ 0 ] <NEWLINE> last = 1 <NEWLINE> for ind , s in enumerate ( S [ : : - 1 ] ) : <NEWLINE> <INDENT> memo . append ( ( int ( s ) * last + memo [ - 1 ] ) % 2019 ) <NEWLINE> last *= 10 <NEWLINE> last %= 2019 <NEWLINE> if ( memo [ - 1 ] in ans ) : <NEWLINE> <INDENT> ans [ memo [ - 1 ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ memo [ - 1 ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> res = 0 <NEWLINE> for key in ans . keys ( ) : <NEWLINE> <INDENT> res += ans [ key ] * ( ans [ key ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> import math <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in reversed ( range ( 1 , ( int ( math . sqrt ( N ) ) ) + 1 ) ) : <NEWLINE> <INDENT> if N % a == 0 : <NEWLINE> <INDENT> b = N / a <NEWLINE> ans = max ( len ( str ( int ( a ) ) ) , len ( str ( int ( b ) ) ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
k = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> def gcd ( x , y ) : <COMMENT> <NEWLINE> <INDENT> if y > x : <NEWLINE> <INDENT> y , x = x , y <NEWLINE> <DEDENT> while y > 0 : <NEWLINE> <INDENT> r = x % y <NEWLINE> x = y <NEWLINE> y = r <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> import math <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for m in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sub = gcd ( i , m ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += gcd ( sub , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> lis = [ ] <NEWLINE> def cnt ( n ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ret += i <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> lis . append ( sorted ( list ( input ( ) ) ) ) <NEWLINE> <DEDENT> co = 1 <NEWLINE> lis . sort ( ) <NEWLINE> bef = lis [ 0 ] <NEWLINE> <NL> for i in lis [ 1 : ] : <NEWLINE> <INDENT> if bef != i : <NEWLINE> <INDENT> ans += cnt ( co ) <NEWLINE> co = 1 <NEWLINE> bef = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> co += 1 <NEWLINE> <DEDENT> <DEDENT> ans += cnt ( co ) <NEWLINE> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ A [ i ] + i for i in range ( N ) ] <NEWLINE> R = [ i - A [ i ] for i in range ( N ) ] <NEWLINE> c = Counter ( R ) <NEWLINE> <NL> ans = 0 <NEWLINE> for l in L : <NEWLINE> <INDENT> ans += c [ l ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
f = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> n , m = f ( ) <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = f ( ) <NEWLINE> g [ a - 1 ] . append ( b - 1 ) <NEWLINE> g [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> p = [ 0 ] * n <NEWLINE> from collections import deque <NEWLINE> q = deque ( [ 0 ] ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for c in g [ v ] : <NEWLINE> <INDENT> if p [ c ] < 1 : p [ c ] = v + 1 ; q . append ( c ) <NEWLINE> <DEDENT> <DEDENT> if 0 in p : print ( <STRING> ) <NEWLINE> else : print ( <STRING> , * p [ 1 : ] , sep = <STRING> ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> if ( a - c ) >= 0 : <NEWLINE> <INDENT> AC = ( a - c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> AC = ( c - a ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if a < b < c : <NEWLINE> <INDENT> AB = ( b - a ) <NEWLINE> BC = ( c - b ) <NEWLINE> <DEDENT> if c < b < a : <NEWLINE> <INDENT> AB = ( a - b ) <NEWLINE> BC = ( b - c ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if AC <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif AB <= d and BC <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> if num == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> stars = sorted ( input ( ) . split ( ) ) <NEWLINE> if stars . count ( stars [ num // 2 ] ) > num / 2 : <NEWLINE> <INDENT> print ( stars [ num // 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = 1000001 <NEWLINE> a = [ 0 ] * N <NEWLINE> input ( ) <NEWLINE> for x in input ( ) . split ( ) : <NEWLINE> <INDENT> a [ int ( x ) ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( i + i , N , i ) : <NEWLINE> <INDENT> if a [ i ] : <NEWLINE> <INDENT> a [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a . count ( 1 ) ) <NEWLINE>
import sys <NEWLINE> from heapq import * <NEWLINE> import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit <NEWLINE> i8 = numba . int64 <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> @ njit ( ( i8 , i8 , i8 [ : , : ] , i8 [ : ] ) , cache = True ) <NEWLINE> def main ( N , S , G , CD ) : <NEWLINE> <INDENT> ind = np . searchsorted ( G [ : , 0 ] , np . arange ( N + 1 ) , <STRING> ) <NEWLINE> U = 2600 <NEWLINE> C , D = CD [ : : 2 ] , CD [ 1 : : 2 ] <NEWLINE> C = np . minimum ( C , U ) <NEWLINE> S = np . minimum ( S , U ) <NEWLINE> INF = 10 ** 18 <NEWLINE> dist = np . full ( ( N + 1 , U + 1 ) , INF , np . int64 ) <NEWLINE> dist [ 1 , S ] = 0 <NEWLINE> q = [ ( 0 , 1 , S ) ] <NEWLINE> while q : <NEWLINE> <INDENT> d , v , coin = heappop ( q ) <NEWLINE> if dist [ v , coin ] < d : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for i in range ( ind [ v - 1 ] , ind [ v ] ) : <NEWLINE> <INDENT> w , a , b = G [ i , 1 : ] <NEWLINE> if coin < a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if dist [ w , coin - a ] <= d + b : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ w , coin - a ] = d + b <NEWLINE> heappush ( q , ( d + b , w , coin - a ) ) <NEWLINE> <DEDENT> c = min ( U , coin + C [ v - 1 ] ) <NEWLINE> if dist [ v , c ] <= d + D [ v - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ v , c ] = d + D [ v - 1 ] <NEWLINE> heappush ( q , ( d + D [ v - 1 ] , v , c ) ) <NEWLINE> <DEDENT> return dist <NEWLINE> <NL> <DEDENT> N , M , S = map ( int , readline ( ) . split ( ) ) <NEWLINE> nums = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> UVAB = nums [ : 4 * M ] <NEWLINE> CD = nums [ 4 * M : ] <NEWLINE> <NL> U , V , A , B = UVAB . reshape ( - 1 , 4 ) . T <NEWLINE> <NL> G = np . empty ( ( M + M , 4 ) , np . int64 ) <NEWLINE> G [ : , 0 ] = np . concatenate ( ( U , V ) ) <NEWLINE> G [ : , 1 ] = np . concatenate ( ( V , U ) ) <NEWLINE> G [ : , 2 ] = np . concatenate ( ( A , A ) ) <NEWLINE> G [ : , 3 ] = np . concatenate ( ( B , B ) ) <NEWLINE> G = G [ G [ : , 0 ] . argsort ( ) ] <NEWLINE> <NL> ans = main ( N , S , G , CD ) [ 2 : ] . min ( axis = 1 ) <NEWLINE> print ( <STRING> . join ( map ( str , ans . tolist ( ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_j = { } <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if A_j . get ( i - a ) : <NEWLINE> <INDENT> A_j [ i - a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A_j [ i - a ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> r = 0 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> t = A_j . get ( a + i ) <NEWLINE> if t : <NEWLINE> <INDENT> r += t <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
from collections import deque <NEWLINE> from copy import deepcopy <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> t = ( ( 0 , 1 ) , ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ) <NEWLINE> m = 0 <NEWLINE> for sy in range ( h ) : <NEWLINE> <INDENT> for sx in range ( w ) : <NEWLINE> <INDENT> if s [ sy ] [ sx ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ss = deepcopy ( s ) <NEWLINE> ss [ sy ] [ sx ] = <STRING> <NEWLINE> q = deque ( [ ( 0 , sy , sx ) ] ) <NEWLINE> max_cost = 0 <NEWLINE> my , mx = 0 , 0 <NEWLINE> while ( q ) : <NEWLINE> <INDENT> cost , y , x = q . popleft ( ) <NEWLINE> max_cost = max ( max_cost , cost ) <NEWLINE> cost += 1 <NEWLINE> for i , j in t : <NEWLINE> <INDENT> ny = y + i <NEWLINE> nx = x + j <NEWLINE> if 0 <= ny < h and 0 <= nx < w : <NEWLINE> <INDENT> if ss [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> q . append ( ( cost , ny , nx ) ) <NEWLINE> ss [ ny ] [ nx ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> m = max ( m , max_cost ) <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> a = x . count ( <STRING> ) <NEWLINE> b = int ( x , 2 ) <NEWLINE> <COMMENT> <NL> <NL> ary = [ None for i in range ( 200010 ) ] <NEWLINE> ary [ 0 ] = 0 <NEWLINE> <NL> def f ( n ) : <NEWLINE> <INDENT> if ary [ n ] is not None : <NEWLINE> <INDENT> return ary [ n ] <NEWLINE> <DEDENT> b = bin ( n ) . count ( <STRING> ) <NEWLINE> r = 1 + f ( n % b ) <NEWLINE> ary [ n ] = r <NEWLINE> return ary [ n ] <NEWLINE> <NL> <NL> <DEDENT> a1 = a + 1 <NEWLINE> a0 = a - 1 <NEWLINE> for i in range ( 200010 ) : <NEWLINE> <INDENT> f ( i ) <NEWLINE> <NL> <NL> <DEDENT> one = [ 1 ] * 200010 <NEWLINE> zero = [ 1 ] * 200010 <NEWLINE> for i in range ( 1 , 200010 ) : <NEWLINE> <INDENT> if a0 != 0 : <NEWLINE> <INDENT> one [ i ] = one [ i - 1 ] * 2 % a0 <NEWLINE> <DEDENT> zero [ i ] = zero [ i - 1 ] * 2 % a1 <NEWLINE> <NL> <NL> <DEDENT> ans = [ 0 for i in range ( n ) ] <NEWLINE> c1 = b % a1 <NEWLINE> if a0 != 0 : <NEWLINE> <INDENT> c0 = b % a0 <NEWLINE> <DEDENT> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if x [ n - 1 - i ] == <STRING> : <NEWLINE> <INDENT> y = c1 + zero [ i ] <NEWLINE> <COMMENT> <NL> y %= a1 <NEWLINE> print ( ary [ y ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a0 != 0 : <NEWLINE> <INDENT> y = c0 - one [ i ] <NEWLINE> y %= a0 <NEWLINE> print ( ary [ y ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = [ ( 1 , 2 ) , ( 2 , 5 ) , ( 3 , 5 ) , ( 4 , 4 ) , ( 5 , 5 ) , ( 6 , 6 ) , ( 7 , 3 ) , ( 8 , 7 ) , ( 9 , 6 ) ] <NEWLINE> B = [ ] <NEWLINE> for num , cost in L : <NEWLINE> <INDENT> if num in A : <NEWLINE> <INDENT> B . append ( [ num , cost ] ) <NEWLINE> <DEDENT> <DEDENT> B . sort ( key = lambda x : - x [ 0 ] ) <NEWLINE> dp = [ - f_inf ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for _ , cost in B : <NEWLINE> <INDENT> if i - cost == 0 : <NEWLINE> <INDENT> dp [ i ] = max ( dp [ i ] , dp [ 0 ] + 1 ) <NEWLINE> <DEDENT> elif i - cost > 0 and dp [ i - cost ] != 0 : <NEWLINE> <INDENT> dp [ i ] = max ( dp [ i ] , dp [ i - cost ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> j = 0 <NEWLINE> k = n <NEWLINE> res = <STRING> <NEWLINE> while k > 0 and j < m : <NEWLINE> <INDENT> num , cost = B [ j ] <NEWLINE> if k - cost >= 0 and dp [ k ] - dp [ k - cost ] == 1 : <NEWLINE> <INDENT> res += str ( num ) <NEWLINE> k -= cost <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
from math import floor , ceil , sqrt , factorial , log <NEWLINE> from collections import Counter , deque <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> import itertools <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def MS ( ) : return map ( str , input ( ) . split ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def FLI ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> def LS ( ) : return list ( MS ( ) ) <NEWLINE> def LI ( ) : return list ( MI ( ) ) <NEWLINE> def LLS ( ) : return [ list ( map ( str , l . split ( ) ) ) for l in input ( ) ] <NEWLINE> def LLI ( ) : return [ list ( map ( int , l . split ( ) ) ) for l in input ( ) ] <NEWLINE> def LLSN ( n : int ) : return [ LS ( ) for _ in range ( n ) ] <NEWLINE> def LLIN ( n : int ) : return [ LI ( ) for _ in range ( n ) ] <NEWLINE> <NL> N , K = MI ( ) <NEWLINE> P = LI ( ) <NEWLINE> <NL> P = sorted ( P ) <NEWLINE> <NL> ans = sum ( P [ : K ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> x = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> x *= a <NEWLINE> if x > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> n = int ( readline ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ma = int ( 1e18 ) <NEWLINE> <NL> for p_ in p : <NEWLINE> <INDENT> if p_ == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for p_ in p : <NEWLINE> <INDENT> ans *= p_ <NEWLINE> if ans > ma : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> from collections import defaultdict <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> in_n = lambda : int ( readline ( ) ) <NEWLINE> in_nn = lambda : map ( int , readline ( ) . split ( ) ) <NEWLINE> in_nl = lambda : list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> in_na = lambda : map ( int , read ( ) . split ( ) ) <NEWLINE> in_s = lambda : readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = in_n ( ) <NEWLINE> xy = [ tuple ( in_nn ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> comb = itertools . combinations ( range ( N ) , 2 ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> <NL> for i , j in comb : <NEWLINE> <INDENT> x1 , y1 = xy [ i ] <NEWLINE> x2 , y2 = xy [ j ] <NEWLINE> xd = x2 - x1 <NEWLINE> yd = y2 - y1 <NEWLINE> d [ ( xd , yd ) ] += 1 <NEWLINE> d [ ( - xd , - yd ) ] += 1 <NEWLINE> <NL> <DEDENT> ans = N - max ( d . values ( ) ) <NEWLINE> <COMMENT> <NL> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> ans = 0 <NEWLINE> nCi = [ 1 ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> nCi . append ( nCi [ i - 1 ] * ( N - i ) * pow ( i , mod - 2 , mod ) % mod ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( K + 1 ) : <NEWLINE> <INDENT> ans += M * pow ( M - 1 , N - 1 - i , mod ) * nCi [ i ] <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def ans167 ( A , B , C , K ) : <NEWLINE> <INDENT> if A >= K : <NEWLINE> <INDENT> return ( K ) <NEWLINE> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> return ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( A - ( K - A - B ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans167 ( A , B , C , K ) ) <NEWLINE>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> ans = 3 <NEWLINE> <DEDENT> elif <STRING> in s : <NEWLINE> <INDENT> ans = 2 <NEWLINE> <DEDENT> elif <STRING> in s : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque , defaultdict <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> D = defaultdict ( list ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> D [ s ] . append ( t ) <NEWLINE> D [ t ] . append ( s ) <NEWLINE> <NL> <DEDENT> q = deque ( ) <NEWLINE> q . append ( 1 ) <NEWLINE> d = defaultdict ( lambda : float ( <STRING> ) ) <NEWLINE> d [ 1 ] = 0 <NEWLINE> <NL> while q : <NEWLINE> <INDENT> u = q . popleft ( ) <NEWLINE> <NL> for v in D [ u ] : <NEWLINE> <INDENT> if d [ v ] == float ( <STRING> ) : <NEWLINE> <INDENT> d [ v ] = u <NEWLINE> q . append ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if len ( d ) == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> w = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> c += math . gcd ( w , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
a , b , x = map ( float , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> if x <= a * a * b / 2 : <NEWLINE> <INDENT> print ( math . degrees ( math . atan ( a * b * b / 2 / x ) ) ) <NEWLINE> <DEDENT> elif ( - x / a + a * b ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . degrees ( math . atan ( 2 / a / a * ( a * b - x / a ) ) ) ) <NEWLINE> <DEDENT>
from functools import reduce <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = sorted ( A , reverse = True ) <NEWLINE> c = 1 <NEWLINE> if b [ - 1 ] == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if c > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c *= b [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if c > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> L = sorted ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( len ( L ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( L ) ) : <NEWLINE> <INDENT> a = L [ i ] <NEWLINE> b = L [ j ] <NEWLINE> ans += max ( 0 , bisect . bisect_right ( L , a + b - 1 ) - ( j + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 1 <NEWLINE> flag = 1 <NEWLINE> zero = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> zero = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if zero == 0 : <NEWLINE> <INDENT> for i in l : <NEWLINE> <INDENT> p *= i <NEWLINE> if p > 1000000000000000000 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , s = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> mod = 998244353 <NEWLINE> dp = np . zeros ( ( n + 1 , s + 1 ) , dtype = int ) <NEWLINE> dp [ 0 ] [ 0 ] = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ai = a [ i ] <NEWLINE> dp [ i + 1 ] = dp [ i ] * 2 % mod <NEWLINE> dp [ i + 1 , ai : ] = ( dp [ i + 1 , ai : ] + dp [ i , : - ai ] ) % mod <NEWLINE> <DEDENT> print ( dp [ n ] [ s ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def popcount ( x ) : <NEWLINE> <INDENT> return bin ( x ) . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> N , X = open ( 0 ) . read ( ) . split ( ) <NEWLINE> N = int ( N ) <NEWLINE> XS = list ( X ) <NEWLINE> X = int ( X , 2 ) <NEWLINE> <NL> p = popcount ( X ) <NEWLINE> xi = X % ( p + 1 ) <NEWLINE> if p == 1 : <NEWLINE> <INDENT> xd = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xd = X % ( p - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if XS [ i ] == <STRING> : <NEWLINE> <INDENT> if p == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = pow ( 2 , N - 1 - i , p - 1 ) <NEWLINE> x = ( xd - k ) % ( p - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> k = pow ( 2 , N - 1 - i , p + 1 ) <NEWLINE> x = ( xi + k ) % ( p + 1 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> while x != 0 : <NEWLINE> <INDENT> x %= popcount ( x ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> a = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> c = S . count ( <STRING> ) <NEWLINE> ans = a * b * c <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> if S [ i ] != S [ j ] : <NEWLINE> <INDENT> if ( 2 * j - i ) <= N - 1 and S [ i ] != S [ 2 * j - i ] != S [ j ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from bisect import bisect_left , bisect_right , insort_left <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> D = { } <NEWLINE> a = [ ] <NEWLINE> c = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> if a [ i ] [ 0 ] == 0 : <NEWLINE> <INDENT> if not a [ i ] [ 1 ] in D : <NEWLINE> <INDENT> insort_left ( S , a [ i ] [ 1 ] ) <NEWLINE> D [ a [ i ] [ 1 ] ] = 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not D [ a [ i ] [ 1 ] ] == 1 : <NEWLINE> <INDENT> D [ a [ i ] [ 1 ] ] = 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT> elif a [ i ] [ 0 ] == 1 : <NEWLINE> <INDENT> if a [ i ] [ 1 ] in D : <NEWLINE> <INDENT> if D [ a [ i ] [ 1 ] ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> elif a [ i ] [ 0 ] == 2 : <NEWLINE> <INDENT> if a [ i ] [ 1 ] in D : <NEWLINE> <INDENT> if D [ a [ i ] [ 1 ] ] == 1 : <NEWLINE> <INDENT> D [ a [ i ] [ 1 ] ] = 0 <NEWLINE> c -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> L = bisect_left ( S , a [ i ] [ 1 ] ) <NEWLINE> R = bisect_right ( S , a [ i ] [ 2 ] ) <NEWLINE> for j in range ( L , R ) : <NEWLINE> <INDENT> if D [ S [ j ] ] == 1 : <NEWLINE> <INDENT> print ( S [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> b = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> num = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> num [ i ] += 1 <NEWLINE> <DEDENT> sum_a = sum ( a ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> dif = b [ i ] [ 1 ] - b [ i ] [ 0 ] <NEWLINE> <COMMENT> <NL> sum_a += dif * num [ b [ i ] [ 0 ] ] <NEWLINE> num [ b [ i ] [ 1 ] ] += num [ b [ i ] [ 0 ] ] <NEWLINE> num [ b [ i ] [ 0 ] ] = 0 <NEWLINE> print ( sum_a ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> now = 1 <NEWLINE> cyc = 0 <NEWLINE> visited = [ 0 ] * n <NEWLINE> flg = False <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> now = a [ now - 1 ] <NEWLINE> visited [ now - 1 ] += 1 <NEWLINE> if visited [ now - 1 ] == 2 : <NEWLINE> <INDENT> cyc += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if visited [ now - 1 ] == 3 : <NEWLINE> <INDENT> flg = True <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> for i in range ( ( k - cnt + 2 * cyc ) % cyc ) : <NEWLINE> <INDENT> now = a [ now - 1 ] <NEWLINE> <DEDENT> print ( now ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( now ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def solve ( i ) : <NEWLINE> <INDENT> return A * i // B - A * ( i // B ) <NEWLINE> <NL> <DEDENT> print ( solve ( min ( B - 1 , N ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> x = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> x += ( n - 1 ) // a <NEWLINE> a += 1 <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import collections <NEWLINE> c = collections . Counter ( A ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
MOD = 998244353 <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( K ) ] <NEWLINE> <NL> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 1 ] = 1 <COMMENT> <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ i ] += dp [ i - 1 ] <COMMENT> <NEWLINE> dp [ i ] %= MOD <NEWLINE> for l , r in LR : <NEWLINE> <INDENT> ll = i + l <NEWLINE> rr = i + r <NEWLINE> if ll <= N : <NEWLINE> <INDENT> dp [ ll ] += dp [ i ] <COMMENT> <NEWLINE> dp [ ll ] %= MOD <NEWLINE> <DEDENT> if rr < N : <NEWLINE> <INDENT> dp [ rr + 1 ] -= dp [ i ] <COMMENT> <NEWLINE> dp [ rr + 1 ] %= MOD <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
k , s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - x - y <= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> k = sum ( a ) <NEWLINE> for i in a : <NEWLINE> <INDENT> k -= i <NEWLINE> ans += i * k <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A_str = input ( ) <NEWLINE> A_str_list = A_str . split ( ) <NEWLINE> A = np . array ( [ int ( A_str_list [ i ] ) for i in range ( N ) ] ) <NEWLINE> sum = 0 <NEWLINE> mod = 1000000007 <NEWLINE> res = np . cumsum ( A ) <NEWLINE> res = [ np . mod ( ( res [ - 1 ] - res [ i ] ) , mod ) for i in range ( N ) ] <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> sum += np . mod ( res [ i ] * A [ i ] , mod ) <NEWLINE> <DEDENT> print ( np . mod ( sum , mod ) ) <NEWLINE>
import queue <NEWLINE> import math <NEWLINE> q = queue . Queue ( ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> check = [ - 1 ] * N <NEWLINE> graph = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> flag = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> lines = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . append ( lines [ 0 ] ) <NEWLINE> B . append ( lines [ 1 ] ) <NEWLINE> graph [ lines [ 0 ] ] . append ( lines [ 1 ] ) <NEWLINE> graph [ lines [ 1 ] ] . append ( lines [ 0 ] ) <NEWLINE> <NL> <DEDENT> q . put ( 1 ) <NEWLINE> check [ 0 ] = 0 <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> p = q . get ( ) <NEWLINE> for np in graph [ p ] : <NEWLINE> <INDENT> if check [ np - 1 ] == - 1 : <NEWLINE> <INDENT> check [ np - 1 ] = check [ p - 1 ] + 1 <NEWLINE> q . put ( np ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> if check [ A [ i ] - 1 ] - check [ B [ i ] - 1 ] == 1 : <NEWLINE> <INDENT> flag [ A [ i ] - 1 ] = B [ i ] <NEWLINE> <DEDENT> if check [ B [ i ] - 1 ] - check [ A [ i ] - 1 ] == 1 : <NEWLINE> <INDENT> flag [ B [ i ] - 1 ] = A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( flag [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> h , w = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> dp = [ [ 0 ] * w for _ in range ( h ) ] <NEWLINE> G = [ [ int ( j ) for j in sys . stdin . readline ( ) . split ( ) ] for _ in range ( h ) ] <NEWLINE> for x in range ( h ) : <NEWLINE> <INDENT> dp [ x ] [ 0 ] = 1 if G [ x ] [ 0 ] == 0 else 0 <NEWLINE> <DEDENT> for y in range ( w ) : <NEWLINE> <INDENT> dp [ 0 ] [ y ] = 1 if G [ 0 ] [ y ] == 0 else 0 <NEWLINE> <DEDENT> for i in range ( 1 , h ) : <NEWLINE> <INDENT> for j in range ( 1 , w ) : <NEWLINE> <INDENT> if ( G [ i ] [ j ] == 0 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( itertools . chain ( * dp ) ) ** 2 ) <NEWLINE>
import sys <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> c = [ [ ] for _ in range ( 3 ) ] <COMMENT> <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> c [ 0 ] . append ( i ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> c [ 1 ] . append ( i ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> c [ 2 ] . append ( i ) <NEWLINE> <DEDENT> <DEDENT> total = len ( c [ 0 ] ) * len ( c [ 1 ] ) * len ( c [ 2 ] ) <NEWLINE> <NL> reigai = 0 <COMMENT> <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> reigai += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total - reigai ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
r , g , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n // r + 1 ) : <NEWLINE> <INDENT> for j in range ( ( n - r * i ) // g + 1 ) : <NEWLINE> <INDENT> if ( n - r * i - g * j ) % b == 0 and ( n - r * i - g * j ) // b >= 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from math import ceil as C , floor as F , sqrt <NEWLINE> from collections import defaultdict as D , Counter as CNT <NEWLINE> from functools import reduce as R <NEWLINE> <NL> ALP = <STRING> <NEWLINE> alp = <STRING> <NEWLINE> def _X ( ) : return sys . stdin . readline ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> def _S ( ss ) : return tuple ( ss ) if len ( ss ) > 1 else ss [ 0 ] <NEWLINE> def S ( ) : return _S ( _X ( ) ) <NEWLINE> def Ss ( ) : return list ( S ( ) ) <NEWLINE> def _I ( ss ) : return tuple ( [ int ( s ) for s in ss ] ) if isinstance ( ss , tuple ) else int ( ss ) <NEWLINE> def I ( ) : return _I ( S ( ) ) <NEWLINE> def _Is ( ss ) : return list ( ss ) if isinstance ( ss , tuple ) else [ ss ] <NEWLINE> def Is ( ) : return _Is ( I ( ) ) <NEWLINE> <NL> x = I ( ) <NEWLINE> <NL> A = [ ] <NEWLINE> As = [ ] <NEWLINE> B = [ ] <NEWLINE> Bs = [ ] <NEWLINE> <NL> for i in range ( 250 ) : <NEWLINE> <INDENT> n = i ** 5 <NEWLINE> A . append ( i ) <NEWLINE> As . append ( n ) <NEWLINE> B . append ( i ) <NEWLINE> Bs . append ( n ) <NEWLINE> B . append ( - i ) <NEWLINE> Bs . append ( - n ) <NEWLINE> <NL> <DEDENT> xs = [ a - x for a in As ] <NEWLINE> for i , x in enumerate ( xs ) : <NEWLINE> <INDENT> if x in Bs : <NEWLINE> <INDENT> print ( A [ i ] , B [ Bs . index ( x ) ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> A = sorted ( A , reverse = True ) <NEWLINE> mul = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> mul *= a <NEWLINE> <NL> if mul > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mul ) <NEWLINE>
for i in range ( 10000 ) : <NEWLINE> <INDENT> x = input ( ) . split ( ) <NEWLINE> h = int ( x [ 0 ] ) <NEWLINE> w = int ( x [ 1 ] ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> for i in range ( w ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> INF = 10 ** 9 <NEWLINE> d = [ [ INF ] * 3 for i in range ( n ) ] <NEWLINE> to = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> u , v = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> to [ u ] . append ( v ) <NEWLINE> <DEDENT> s , t = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> d [ s ] [ 0 ] = 0 <NEWLINE> cnt = 0 <NEWLINE> q = deque ( [ ( s , cnt ) ] ) <NEWLINE> while q : <NEWLINE> <INDENT> u , c = q . popleft ( ) <NEWLINE> for v in to [ u ] : <NEWLINE> <INDENT> nc = ( c + 1 ) % 3 <NEWLINE> if d [ v ] [ nc ] != INF : continue ; <NEWLINE> d [ v ] [ nc ] = d [ u ] [ c ] + 1 <NEWLINE> q . append ( ( v , nc ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = d [ t ] [ 0 ] <NEWLINE> print ( ans // 3 if ans != INF else - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> <COMMENT> <NL> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def f ( n ) : <NEWLINE> <INDENT> for i in range ( 1 , 20 ) : <NEWLINE> <INDENT> if n < ( i * ( i + 1 ) ) // 2 : <NEWLINE> <INDENT> return i - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> c = collections . Counter ( prime_factorize ( n ) ) <NEWLINE> ans = 0 <NEWLINE> for i in c . keys ( ) : <NEWLINE> <INDENT> ans += f ( c [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> from collections import deque <NEWLINE> <NL> def xins ( x ) : <NEWLINE> <INDENT> if not x in xlist : <NEWLINE> <INDENT> insp = bisect . bisect ( xlist , x ) <NEWLINE> xlist . insert ( insp , x ) <NEWLINE> for lst in zaatu : <NEWLINE> <INDENT> ins = 1 if insp == 0 else lst [ insp - 1 ] <NEWLINE> lst . insert ( insp , ins ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def yins ( y ) : <NEWLINE> <INDENT> if not y in ylist : <NEWLINE> <INDENT> insp = bisect . bisect ( ylist , y ) <NEWLINE> ylist . insert ( insp , y ) <NEWLINE> a = [ 1 ] * ( len ( xlist ) + 1 ) <NEWLINE> if insp > 0 : <NEWLINE> <INDENT> for i in range ( len ( xlist ) ) : <NEWLINE> <INDENT> a [ i ] = zaatu [ insp - 1 ] [ i ] <NEWLINE> <DEDENT> <DEDENT> zaatu . insert ( insp , a ) <NEWLINE> <NL> <DEDENT> <DEDENT> def addmask ( x1 , y1 , x2 , y2 ) : <NEWLINE> <INDENT> xins ( x1 ) <NEWLINE> yins ( y1 ) <NEWLINE> xins ( x2 ) <NEWLINE> yins ( y2 ) <NEWLINE> x1 = xlist . index ( x1 ) <NEWLINE> y1 = ylist . index ( y1 ) <NEWLINE> x2 = xlist . index ( x2 ) <NEWLINE> y2 = ylist . index ( y2 ) <NEWLINE> <NL> for i in range ( y1 , y2 ) : <NEWLINE> <INDENT> for j in range ( x1 , x2 ) : <NEWLINE> <INDENT> zaatu [ i ] [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def printcolor ( zaatu , no , x , y , xlen , ylen , stack ) : <NEWLINE> <INDENT> if zaatu [ y ] [ x ] == 1 : <NEWLINE> <INDENT> zaatu [ y ] [ x ] = no <NEWLINE> if x > 0 : <NEWLINE> <INDENT> stack . append ( [ x - 1 , y ] ) <NEWLINE> <DEDENT> if x < xlen - 1 : <NEWLINE> <INDENT> stack . append ( [ x + 1 , y ] ) <NEWLINE> <DEDENT> if y > 0 : <NEWLINE> <INDENT> stack . append ( [ x , y - 1 ] ) <NEWLINE> <DEDENT> if y < ylen - 1 : <NEWLINE> <INDENT> stack . append ( [ x , y + 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def doprint ( zaatu , no , xlen , ylen , stack ) : <NEWLINE> <INDENT> while len ( stack ) != 0 : <NEWLINE> <INDENT> x , y = stack . popleft ( ) <NEWLINE> printcolor ( zaatu , no , x , y , xlen , ylen , stack ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> xlist = [ ] <NEWLINE> ylist = [ ] <NEWLINE> zaatu = [ [ 1 ] ] <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 : break <NEWLINE> masn = int ( input ( ) ) <NEWLINE> for i in range ( masn ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> addmask ( a , b , c , d ) <NEWLINE> <NL> <DEDENT> if xlist [ 0 ] != 0 : xins ( 0 ) <NEWLINE> if ylist [ 0 ] != 0 : yins ( 0 ) <NEWLINE> if xlist [ - 1 ] == h : xlist . pop ( ) <NEWLINE> if ylist [ - 1 ] == w : ylist . pop ( ) <NEWLINE> zaatu . pop ( ) <NEWLINE> xlen = len ( xlist ) <NEWLINE> ylen = len ( ylist ) <NEWLINE> no = 2 <NEWLINE> <NL> for y in range ( ylen ) : <NEWLINE> <INDENT> for x in range ( xlen ) : <NEWLINE> <INDENT> if zaatu [ y ] [ x ] == 1 : <NEWLINE> <INDENT> d = deque ( [ [ x , y ] ] ) <NEWLINE> doprint ( zaatu , no , xlen , ylen , d ) <NEWLINE> <DEDENT> if zaatu [ y ] [ x ] == no : no += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> mx = 0 <NEWLINE> for lst in zaatu : <NEWLINE> <INDENT> mx = max ( mx , max ( lst ) ) <NEWLINE> <DEDENT> print ( mx - 1 ) <NEWLINE> <DEDENT>
import collections , itertools , copy <NEWLINE> <NL> <NL> class MaximumFlow : <NEWLINE> <INDENT> def ford_fulkerson ( self , G , s , t ) : <NEWLINE> <INDENT> G_residue = copy . deepcopy ( G ) <NEWLINE> <NL> def dfs ( start , used ) : <NEWLINE> <INDENT> if start == t : <NEWLINE> <INDENT> return [ start ] <NEWLINE> <DEDENT> for end , cap in G_residue [ start ] . items ( ) : <NEWLINE> <INDENT> if cap > 0 and end not in used : <NEWLINE> <INDENT> used . add ( end ) <NEWLINE> ret = dfs ( end , used ) <NEWLINE> if ret : <NEWLINE> <INDENT> return ret + [ start ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return [ ] <NEWLINE> <NL> <DEDENT> flow_value = 0 <NEWLINE> while True : <NEWLINE> <INDENT> root = dfs ( s , set ( [ s ] ) ) <NEWLINE> if root : <NEWLINE> <INDENT> root = root [ : : - 1 ] <NEWLINE> residue = min ( <NEWLINE> <INDENT> [ G_residue [ a ] [ b ] for a , b in zip ( root , root [ 1 : ] ) ] ) <NEWLINE> <DEDENT> flow_value += residue <NEWLINE> for a , b in zip ( root , root [ 1 : ] ) : <NEWLINE> <INDENT> G_residue [ a ] [ b ] -= residue <NEWLINE> G_residue [ b ] [ a ] += residue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return ( flow_value , G_residue ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> AB = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for _ in range ( N ) ] <NEWLINE> CD = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for _ in range ( N ) ] <NEWLINE> G = collections . defaultdict ( lambda : collections . defaultdict ( int ) ) <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> G [ - 1 ] [ 1000 * a + b ] = 1 <NEWLINE> <DEDENT> for c , d in CD : <NEWLINE> <INDENT> G [ 1000 * c + d ] [ - 2 ] = 1 <NEWLINE> <DEDENT> for ab , cd in itertools . product ( AB , CD ) : <NEWLINE> <INDENT> a , b = ab <NEWLINE> c , d = cd <NEWLINE> if a < c and b < d : <NEWLINE> <INDENT> G [ 1000 * a + b ] [ 1000 * c + d ] = 1 <NEWLINE> <DEDENT> <DEDENT> flow_value , flow_dict = MaximumFlow ( ) . ford_fulkerson ( G , - 1 , - 2 ) <NEWLINE> print ( flow_value ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li . sort ( ) <NEWLINE> if li [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in li : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> s = math . pi * r ** 2 <NEWLINE> l = 2 * math . pi * r <NEWLINE> <NL> print ( <STRING> . format ( s , l ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> li = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> s . sort ( ) <NEWLINE> li . append ( s ) <NEWLINE> <DEDENT> li . sort ( ) <NEWLINE> temp = 1 <NEWLINE> for j in range ( N - 1 ) : <NEWLINE> <INDENT> if li [ j ] == li [ j + 1 ] : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += temp * ( temp - 1 ) // 2 <NEWLINE> temp = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans += temp * ( temp - 1 ) // 2 <NEWLINE> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> A [ i ] += A [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , m ) : <NEWLINE> <INDENT> B [ i ] += B [ i - 1 ] <NEWLINE> <DEDENT> A . insert ( 0 , 0 ) <NEWLINE> B . insert ( 0 , 0 ) <NEWLINE> <NL> j = m <NEWLINE> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if A [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> while B [ j ] > k - A [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> p = True <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ( ans == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> p = False <NEWLINE> break <NEWLINE> <DEDENT> if ( ans > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> p = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if p : <NEWLINE> <INDENT> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if N % K == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif N > K : <NEWLINE> <INDENT> hako1 = N % K <NEWLINE> hako2 = abs ( hako1 - K ) <NEWLINE> if hako1 > hako2 : <NEWLINE> <INDENT> print ( hako2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( hako1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if N >= abs ( N - K ) : <NEWLINE> <INDENT> print ( abs ( N - K ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N ) <NEWLINE> <DEDENT> <DEDENT>
rooms = [ 0 ] * ( 4 * 3 * 10 ) <NEWLINE> count = int ( input ( ) ) <NEWLINE> for i in range ( count ) : <NEWLINE> <INDENT> b , f , r , v = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> rooms [ 30 * ( b - 1 ) + 10 * ( f - 1 ) + ( r - 1 ) ] += v <NEWLINE> <NL> <DEDENT> for i , room in enumerate ( rooms , start = 1 ) : <NEWLINE> <INDENT> print ( <STRING> , room , end = <STRING> ) <NEWLINE> if i % 10 == 0 : <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT> if i % 30 == 0 and i % 120 != 0 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> d = { } <NEWLINE> input ( ) <NEWLINE> for i in sys . stdin : <NEWLINE> <INDENT> if i [ 0 ] == <STRING> : <NEWLINE> <INDENT> d [ i [ 7 : ] ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i [ 5 : ] in d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> t = min ( k , a ) <NEWLINE> k -= min ( k , a ) <NEWLINE> if k : <NEWLINE> <INDENT> k -= b <NEWLINE> <DEDENT> if k > 0 : <NEWLINE> <INDENT> t -= k <NEWLINE> <DEDENT> print ( t ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> <NL> asum = sum ( a ) <COMMENT> <NEWLINE> d = { } <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i in d : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for b , c in bc : <NEWLINE> <INDENT> if b in d : <NEWLINE> <INDENT> asum += d [ b ] * ( c - b ) <NEWLINE> if c in d : <NEWLINE> <INDENT> d [ c ] += d [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ c ] = d [ b ] <NEWLINE> <DEDENT> d [ b ] = 0 <NEWLINE> <DEDENT> print ( asum ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> paths = { } <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> paths . setdefault ( u , { } ) <NEWLINE> paths [ u ] [ v ] = w <NEWLINE> paths . setdefault ( v , { } ) <NEWLINE> paths [ v ] [ u ] = w <NEWLINE> <NL> <DEDENT> node_colors = [ - 1 ] * ( N + 1 ) <NEWLINE> <NL> def route ( last , now , dist ) : <NEWLINE> <INDENT> for next_node , next_distance in zip ( paths [ now ] . keys ( ) , paths [ now ] . values ( ) ) : <NEWLINE> <INDENT> node_colors [ next_node ] = ( dist + next_distance ) % 2 <NEWLINE> if next_node != last : <NEWLINE> <INDENT> route ( now , next_node , dist + next_distance ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> node_colors [ 1 ] = 0 <NEWLINE> <NL> route ( 0 , 1 , 0 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( node_colors [ i + 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def is_contained ( a , area ) : <NEWLINE> <INDENT> rx1 , ry1 , rx2 , ry2 = a <NEWLINE> for r in area : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 = r <NEWLINE> if x1 <= rx1 <= x2 and x1 <= rx2 <= x2 and y1 <= ry1 <= y2 and y1 <= ry2 <= y2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def add_area ( a , area ) : <NEWLINE> <INDENT> if is_contained ( a , area ) : <NEWLINE> <INDENT> return area <NEWLINE> <DEDENT> xs , ys , xe , ye = a <NEWLINE> if xs >= xe or ys >= ye : <NEWLINE> <INDENT> return area <NEWLINE> <DEDENT> ret = area <NEWLINE> if area == [ ] : <NEWLINE> <INDENT> return [ a ] <NEWLINE> <DEDENT> rr = [ ] <NEWLINE> for r in area : <NEWLINE> <INDENT> rxs , rys , rxe , rye = r <NEWLINE> if xs < rxs < xe and ys < rys < ye and xe <= rxe and ye <= rye : <NEWLINE> <INDENT> rr = [ [ xs , ys , xe , rys ] , [ xs , rys , rxs , ye ] ] <NEWLINE> <DEDENT> elif xs < rxs < xe and ys < rye < ye and rys <= ys and xe <= rxe : <NEWLINE> <INDENT> rr = [ [ xs , ys , rxs , rye ] , [ xs , rye , xe , ye ] ] <NEWLINE> <DEDENT> elif xs < rxe < xe and ys < rys < ye and rxs <= xs and ye <= rye : <NEWLINE> <INDENT> rr = [ [ xs , ys , rxe , rys ] , [ rxe , ys , xe , ye ] ] <NEWLINE> <DEDENT> elif xs < rxe < xe and ys < rye < ye and rxs <= xs and rys <= ys : <NEWLINE> <INDENT> rr = [ [ xs , rye , rxe , ye ] , [ rxe , ys , xe , ye ] ] <NEWLINE> <DEDENT> elif xs < rxs and ys <= rys < ye and rxe < xe and ye <= rye : <NEWLINE> <INDENT> rr = [ [ xs , ys , xe , rys ] , [ xs , rys , rxs , ye ] , [ rxe , rys , xe , ye ] ] <NEWLINE> <DEDENT> elif xs < rxs and ys < rye <= ye and rxe < xe and rys <= ys : <NEWLINE> <INDENT> rr = [ [ xs , rye , xe , ye ] , [ xs , ys , rxs , rye ] , [ rxe , ys , xe , rye ] ] <NEWLINE> <DEDENT> elif xs <= rxs < xe and ys < rys and rye < ye and xe <= rxe : <NEWLINE> <INDENT> rr = [ [ xs , ys , rxs , ye ] , [ rxs , ys , xe , rys ] , [ rxs , rye , xe , ye ] ] <NEWLINE> <DEDENT> elif xs < rxe <= xe and ys < rys and rye < ye and rxs <= xs : <NEWLINE> <INDENT> rr = [ [ rxe , ys , xe , ye ] , [ xs , ys , rxe , rys ] , [ xs , rye , rxe , ye ] ] <NEWLINE> <DEDENT> elif rxs <= xs and xe <= rxe and ys < rys < ye and ye <= rye : <NEWLINE> <INDENT> rr = [ [ xs , ys , xe , rys ] ] <NEWLINE> <DEDENT> elif rys <= ys and ye <= rye and xs < rxs < xe and xe <= rxe : <NEWLINE> <INDENT> rr = [ [ xs , ys , rxs , ye ] ] <NEWLINE> <DEDENT> elif rxs <= xs and xe <= rxe and ys < rye < ye and rys <= ys : <NEWLINE> <INDENT> rr = [ [ xs , rye , xe , ye ] ] <NEWLINE> <DEDENT> elif rys <= ys and ye <= rye and xs < rxe < xe and rxs <= xs : <NEWLINE> <INDENT> rr = [ [ rxe , ys , xe , ye ] ] <NEWLINE> <DEDENT> elif xs < rxs < xe and xs < rxe < xe and ys < rys < ye and ys < rye < ye : <NEWLINE> <INDENT> rr = [ [ xs , ys , rxs , rye ] , [ xs , rye , rxe , ye ] , [ rxe , rys , xe , ye ] , [ rxs , ys , xe , rys ] ] <NEWLINE> <DEDENT> elif rxs <= xs and xe <= rxe and ys < rys and rye < ye : <NEWLINE> <INDENT> rr = [ [ xs , ys , xe , rys ] , [ xs , rye , xe , ye ] ] <NEWLINE> <DEDENT> elif rys <= ys and ye <= rye and xs < rxs and rxe < xe : <NEWLINE> <INDENT> rr = [ [ xs , ys , rxs , ye ] , [ rxe , ys , xe , ye ] ] <NEWLINE> <DEDENT> if rr != [ ] : <NEWLINE> <INDENT> for q in rr : <NEWLINE> <INDENT> ret = add_area ( q , ret ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> if rr == [ ] : <NEWLINE> <INDENT> ret . append ( a ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def calc_area ( area ) : <NEWLINE> <INDENT> s = 0.0 <NEWLINE> for r in area : <NEWLINE> <INDENT> s += ( r [ 2 ] - r [ 0 ] ) * ( r [ 3 ] - r [ 1 ] ) <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> n = 0 <NEWLINE> c = 0 <NEWLINE> area = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> n = int ( line ) <NEWLINE> c += 1 <NEWLINE> area = [ ] <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ant = list ( map ( float , line . strip ( ) . split ( ) ) ) <NEWLINE> r = [ ant [ 0 ] - ant [ 2 ] , ant [ 1 ] - ant [ 2 ] , ant [ 0 ] + ant [ 2 ] , ant [ 1 ] + ant [ 2 ] ] <NEWLINE> area = add_area ( r , area ) <NEWLINE> n -= 1 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( <STRING> % ( c , calc_area ( area ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> c = collections . Counter ( A ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> if i * j >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i == j : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <DEDENT> queue = deque ( [ 1 ] ) <NEWLINE> visited = [ False ] * ( n + 1 ) <NEWLINE> visited [ 0 ] = True <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> while queue : <NEWLINE> <INDENT> node = queue . popleft ( ) <NEWLINE> for xnode in graph [ node ] : <NEWLINE> <INDENT> if visited [ xnode ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ xnode ] = node <NEWLINE> visited [ xnode ] = True <NEWLINE> queue . append ( xnode ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for a in ans [ 2 : ] : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <DEDENT>
import networkx as nx <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> if N == M == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> print ( S [ 0 ] [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> index = lambda i , j : i * M + j <NEWLINE> <NL> G = nx . Graph ( ) <NEWLINE> dx , dy = ( 1 , 0 ) , ( 0 , 1 ) <NEWLINE> E = [ ] <NEWLINE> n1 , n2 = [ ] , [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> if S [ i ] [ j ] == <STRING> : continue <NEWLINE> if ( i + j ) % 2 : <NEWLINE> <INDENT> n1 . append ( index ( i , j ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n2 . append ( index ( i , j ) ) <NEWLINE> <DEDENT> for k in range ( 2 ) : <NEWLINE> <INDENT> v1 , v2 = index ( i , j ) , index ( i + dx [ k ] , j + dy [ k ] ) <NEWLINE> if not ( 0 <= i + dx [ k ] < N and 0 <= j + dy [ k ] < M ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ i + dx [ k ] ] [ j + dy [ k ] ] == <STRING> : continue <NEWLINE> if ( i + j ) % 2 : <NEWLINE> <INDENT> E . append ( ( v2 , v1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> E . append ( ( v1 , v2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> G . add_nodes_from ( n1 , bipartite = 0 ) <NEWLINE> G . add_nodes_from ( n2 , bipartite = 1 ) <NEWLINE> G . add_edges_from ( E ) <NEWLINE> u = [ n for n in G . nodes if G . nodes [ n ] [ <STRING> ] == 0 ] <NEWLINE> match = nx . bipartite . maximum_matching ( G , top_nodes = u ) <NEWLINE> match = { v : match [ v ] for v in match . keys ( ) if v < match [ v ] } <NEWLINE> <NL> for v in match . keys ( ) : <NEWLINE> <INDENT> i1 , j1 = divmod ( v , M ) <NEWLINE> i2 , j2 = divmod ( match [ v ] , M ) <NEWLINE> if i1 > i2 or j1 > j2 : <NEWLINE> <INDENT> ( i1 , j1 ) , ( i2 , j2 ) = ( i2 , j2 ) , ( i1 , j1 ) <NEWLINE> <DEDENT> if i1 < i2 : <NEWLINE> <INDENT> S [ i1 ] [ j1 ] = <STRING> <NEWLINE> S [ i2 ] [ j2 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ i1 ] [ j1 ] = <STRING> <NEWLINE> S [ i2 ] [ j2 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( match ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( <STRING> . join ( S [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> r , g , b , n = I ( ) <NEWLINE> a = [ ] <NEWLINE> a . append ( r ) <NEWLINE> a . append ( g ) <NEWLINE> a . append ( b ) <NEWLINE> a . sort ( ) <NEWLINE> a [ 0 ] , a [ 1 ] , a [ 2 ] = r , g , b <NEWLINE> <NL> mx_b = n // b <NEWLINE> amari = n % b <NEWLINE> for i in range ( n // r + 1 ) : <NEWLINE> <INDENT> for j in range ( ( n - r * i ) // g + 1 ) : <NEWLINE> <INDENT> if ( n - r * i - g * j ) % b == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> <NL> cR = c . count ( <STRING> ) <NEWLINE> cW = c . count ( <STRING> ) <NEWLINE> <NL> <NL> if all ( [ i == <STRING> for i in c [ : cR ] ] ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if all ( [ i == <STRING> for i in c [ cR : cR + cW ] ] ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = c [ : cR ] . count ( <STRING> ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
<COMMENT> <NL> X = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> a , b = 0 , 0 <NEWLINE> <NL> nl = [ ] <NEWLINE> i = 0 <NEWLINE> np = 0 <NEWLINE> n = i ** 5 <NEWLINE> while n - np <= 10 ** 9 : <NEWLINE> <INDENT> nl . append ( n ) <NEWLINE> i += 1 <NEWLINE> np = n <NEWLINE> n = i ** 5 <NEWLINE> <NL> <DEDENT> for i in range ( len ( nl ) ) : <NEWLINE> <INDENT> t = X - nl [ i ] <NEWLINE> if t in nl : <NEWLINE> <INDENT> a = i <NEWLINE> b = - ( nl . index ( t ) ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> if - t in nl : <NEWLINE> <INDENT> a = i <NEWLINE> b = nl . index ( - t ) <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( a , b ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = { } <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> d [ i ] = a [ i - 1 ] <NEWLINE> <NL> <DEDENT> did = set ( ) <NEWLINE> route = [ 1 ] <NEWLINE> <NL> now = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> now = d [ now ] <NEWLINE> route . append ( now ) <NEWLINE> if now in did : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> did . add ( now ) <NEWLINE> <NL> <DEDENT> if k < 10 ** 6 : <NEWLINE> <INDENT> now = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> now = d [ now ] <NEWLINE> <NL> <DEDENT> print ( now ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( route ) ) : <NEWLINE> <INDENT> if route [ i ] == route [ - 1 ] : <NEWLINE> <INDENT> roop = route [ i : - 1 ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( roop [ ( k - i ) % len ( roop ) ] ) <NEWLINE> <DEDENT>
def readinput ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> return n , l <NEWLINE> <NL> <DEDENT> def main ( n , a ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> hist = [ 0 ] * 61 <NEWLINE> bs = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> s = bin ( a [ i ] ) [ 2 : ] <NEWLINE> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> hist [ len ( s ) - j - 1 ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> sum = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> b = 1 <NEWLINE> for j in range ( 61 ) : <NEWLINE> <INDENT> sum = ( sum + ( hist [ j ] * ( n - hist [ j ] ) * b ) % MOD ) % MOD <NEWLINE> b *= 2 <NEWLINE> <NL> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , l = readinput ( ) <NEWLINE> ans = main ( n , l ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> A [ i ] [ 0 ] -= 1 <NEWLINE> A [ i ] [ 1 ] -= 1 <NEWLINE> <NL> <DEDENT> score = 0 <NEWLINE> max = 0 <NEWLINE> <NL> for iter in itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) : <NEWLINE> <NL> <INDENT> score = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> if iter [ A [ i ] [ 1 ] ] - iter [ A [ i ] [ 0 ] ] == A [ i ] [ 2 ] : <NEWLINE> <INDENT> score += A [ i ] [ 3 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if max < score : <NEWLINE> <INDENT> max = score <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , j + 1 ) : <NEWLINE> <INDENT> if i == j == k : <NEWLINE> <INDENT> ans += math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <DEDENT> elif i == j or j == k : <NEWLINE> <INDENT> ans += 3 * math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 6 * math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> T = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = Counter ( T ) <NEWLINE> d = dict ( ) <NEWLINE> sum = 0 <NEWLINE> for c in C . most_common ( ) : <NEWLINE> <INDENT> if c [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if d . get ( c [ 1 ] ) : <NEWLINE> <INDENT> sum += d [ c [ 1 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = ( c [ 1 ] * ( c [ 1 ] - 1 ) ) // 2 <NEWLINE> d [ c [ 1 ] ] = x <NEWLINE> sum += x <NEWLINE> <DEDENT> <DEDENT> for t in T : <NEWLINE> <INDENT> x = C [ t ] <NEWLINE> if x >= 2 : <NEWLINE> <INDENT> if d . get ( x ) : <NEWLINE> <INDENT> minus = d [ x ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus = ( x * ( x - 1 ) ) // 2 <NEWLINE> d [ x ] = minus <NEWLINE> <DEDENT> if d . get ( x - 1 ) : <NEWLINE> <INDENT> plus = d [ x - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> plus = ( ( x - 1 ) * ( x - 2 ) ) // 2 <NEWLINE> d [ x - 1 ] = plus <NEWLINE> <DEDENT> print ( sum - minus + plus ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT> <DEDENT>
<NL> data = [ [ [ 0 for r in range ( 10 ) ] for f in range ( 3 ) ] for b in range ( 4 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> ( b , f , r , v ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> data [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> for r in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> , data [ b ] [ f ] [ r ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> if b < 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tot = 0 <NEWLINE> num2 = [ 0 ] * ( N - 1 ) <NEWLINE> numtot = sum ( num ) <NEWLINE> <NL> for i in range ( len ( num ) - 1 ) : <NEWLINE> <INDENT> numtot -= num [ i ] <NEWLINE> num2 [ i ] = numtot % ( 10 ** 9 + 7 ) <NEWLINE> <NL> num1 = num [ i ] % ( 10 ** 9 + 7 ) <NEWLINE> <NL> tot += num1 * num2 [ i ] <NEWLINE> <NL> if tot >= ( 10 ** 9 + 7 ) : tot = tot % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( tot ) <NEWLINE>
L = [ 1 , 0 , 1 , 2 , 1 , 2 , 1 , 1 , 2 , 1 , 2 , 1 ] <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if L [ a - 1 ] == L [ b - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys , math <NEWLINE> from functools import lru_cache <NEWLINE> from collections import deque <NEWLINE> from bisect import bisect_left <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <DEDENT> def mi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def ii ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def i2 ( n ) : <NEWLINE> <INDENT> tmp = [ list ( mi ( ) ) for i in range ( n ) ] <NEWLINE> return [ list ( i ) for i in zip ( * tmp ) ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = mi ( ) <NEWLINE> <NL> d = [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= M : <NEWLINE> <INDENT> if M % i == 0 : <NEWLINE> <INDENT> d . append ( i ) <NEWLINE> d . append ( M // i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> d . sort ( ) <NEWLINE> <NL> for v in d : <NEWLINE> <INDENT> if v <= M // N : <NEWLINE> <INDENT> ans = v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> MOD_CONST = 10 ** 9 + 7 <NEWLINE> <NL> if N <= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> res = [ 1 ] * N <NEWLINE> res [ 0 ] = res [ 1 ] = 0 <NEWLINE> <NL> for i in range ( 5 , N ) : <NEWLINE> <INDENT> res [ i ] = res [ i - 4 ] + res [ i - 3 ] + res [ i - 2 ] <NEWLINE> <NL> <DEDENT> print ( res [ N - 1 ] % MOD_CONST ) <NEWLINE> <NL>
from bisect import bisect_left <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = sorted ( L ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> a = L [ i ] <NEWLINE> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> b = L [ j ] <NEWLINE> ans += bisect_left ( L , a + b ) - ( j + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d , e = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( [ d , e ] ) <NEWLINE> <NL> <NL> <DEDENT> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] [ 0 ] == a [ i ] [ 1 ] : <NEWLINE> <INDENT> b . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> c = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if b [ i ] == 1 and b [ i + 1 ] == 1 and b [ i + 2 ] == 1 : <NEWLINE> <INDENT> c = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if c == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> m = 0 <NEWLINE> count = 1 <NEWLINE> chk = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> m = ( m * 10 + 7 ) % K <NEWLINE> if m == 0 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> chk = 1 <NEWLINE> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> <NL> <DEDENT> if chk == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ruiA = [ 0 ] <NEWLINE> ruiB = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ruiA . append ( ruiA [ - 1 ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> ruiB . append ( ruiB [ - 1 ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> MAX = 0 <NEWLINE> j = M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if ruiA [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while ruiA [ i ] + ruiB [ j ] > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> MAX = max ( MAX , i + j ) <NEWLINE> <NL> <DEDENT> print ( MAX ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( str ( input ( ) ) ) <NEWLINE> from collections import Counter <NEWLINE> <NL> c = Counter ( S ) <NEWLINE> ans = c [ <STRING> ] * c [ <STRING> ] * c [ <STRING> ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i , N ) : <NEWLINE> <INDENT> if S [ i ] == S [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif i + ( j - i ) * 2 > N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = S [ i + ( j - i ) * 2 ] <NEWLINE> if s != S [ i ] and s != S [ j ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> counter = 0 <NEWLINE> for i in range ( a [ 0 ] , a [ n - 1 ] + 1 ) : <NEWLINE> <INDENT> sum = c [ i - 1 ] + c [ i ] + c [ i + 1 ] <NEWLINE> if sum > counter : <NEWLINE> <INDENT> counter = sum <NEWLINE> <NL> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p_list = [ 0 for i in range ( 100 ) ] <NEWLINE> n_abs = 1000 <NEWLINE> ans = 100000 <NEWLINE> <NL> for i in p : <NEWLINE> <INDENT> p_list [ i - 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 0 , 102 ) : <NEWLINE> <INDENT> if i == 0 or i == 101 : <NEWLINE> <INDENT> temp_abs = abs ( x - i ) <NEWLINE> if n_abs > temp_abs : <NEWLINE> <INDENT> n_abs = temp_abs <NEWLINE> ans = i <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> temp_abs = abs ( x - i ) <NEWLINE> if n_abs > temp_abs and p_list [ i - 1 ] != 1 : <NEWLINE> <INDENT> n_abs = temp_abs <NEWLINE> ans = i <NEWLINE> <DEDENT> elif n_abs == temp_abs and i < ans and p_lsit [ i - 1 ] != 1 : <NEWLINE> <INDENT> n_abs = temp_abs <NEWLINE> ans = i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> <NL> <NL> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> h_cnt = np . zeros ( h , dtype = int ) <NEWLINE> w_cnt = np . zeros ( w , dtype = int ) <NEWLINE> bom_cord = set ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> hi , wi = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> bom_cord . add ( ( hi , wi ) ) <NEWLINE> h_cnt [ hi ] += 1 <NEWLINE> w_cnt [ wi ] += 1 <NEWLINE> <NL> <DEDENT> w_max = w_cnt . max ( ) <NEWLINE> <NL> h_argsort = h_cnt . argsort ( ) [ : : - 1 ] <NEWLINE> w_argsort = w_cnt . argsort ( ) [ : : - 1 ] <NEWLINE> <NL> bomber = 0 <NEWLINE> for hi in h_argsort : <NEWLINE> <INDENT> if h_cnt [ hi ] + w_max <= bomber : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for wi in w_argsort : <NEWLINE> <INDENT> if h_cnt [ hi ] + w_cnt [ wi ] <= bomber : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if ( hi , wi ) in bom_cord : <NEWLINE> <INDENT> bomber = max ( bomber , h_cnt [ hi ] + w_cnt [ wi ] - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bomber = max ( bomber , h_cnt [ hi ] + w_cnt [ wi ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( bomber ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n > 0 : <NEWLINE> <INDENT> ps = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> nums = [ n for n in range ( - 1 , 102 ) if n not in ps ] <NEWLINE> <NL> abs_plus = sorted ( [ n - x for n in nums if n - x >= 0 ] ) <NEWLINE> abs_minus = sorted ( [ - ( n - x ) for n in nums if n - x < 0 ] ) <NEWLINE> if abs_plus == [ ] : <NEWLINE> <INDENT> print ( x - abs_minus [ 0 ] ) <NEWLINE> <DEDENT> elif abs_minus == [ ] : <NEWLINE> <INDENT> print ( x + abs_plus [ 0 ] ) <NEWLINE> <DEDENT> elif abs_plus [ 0 ] >= abs_minus [ 0 ] : <NEWLINE> <INDENT> print ( x - abs_minus [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x + abs_plus [ 0 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> rel = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> rel [ x - 1 ] . append ( y - 1 ) <NEWLINE> rel [ y - 1 ] . append ( x - 1 ) <NEWLINE> <NL> <DEDENT> ans = [ - 1 ] * n <NEWLINE> def hoge ( parent , pos ) : <NEWLINE> <INDENT> for i in rel [ pos ] : <NEWLINE> <INDENT> if ans [ i ] >= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ i ] = pos <NEWLINE> hoge ( pos , i ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ans [ i ] < 0 : <NEWLINE> <INDENT> hoge ( 0 , i ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> numbers = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> numbers = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sort_numbers = sorted ( numbers ) <NEWLINE> <COMMENT> <NL> left = sort_numbers [ n // 2 - 1 ] <NEWLINE> right = sort_numbers [ n // 2 ] <NEWLINE> <COMMENT> <NL> for i in numbers : <NEWLINE> <INDENT> if i > left : <NEWLINE> <INDENT> print ( left ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( right ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> class Dot : <NEWLINE> <INDENT> x = 0.0 <NEWLINE> y = 0.0 <NEWLINE> def __init__ ( self , x , y ) : <NEWLINE> <INDENT> self . x = x <NEWLINE> self . y = y <NEWLINE> <DEDENT> def __lt__ ( self , other ) : <NEWLINE> <INDENT> return self . x < other . x <NEWLINE> <DEDENT> def print ( self ) : <NEWLINE> <INDENT> x = self . x <NEWLINE> y = self . y <NEWLINE> print ( <STRING> . format ( x , y ) ) <NEWLINE> <DEDENT> <DEDENT> def kock ( n , a , b , dots ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> s = Dot ( ( 2 * a . x + b . x ) / 3 , ( 2 * a . y + b . y ) / 3 ) <NEWLINE> t = Dot ( ( a . x + 2 * b . x ) / 3 , ( a . y + 2 * b . y ) / 3 ) <NEWLINE> rad = math . radians ( 60 ) <NEWLINE> x = ( t . x - s . x ) * math . cos ( rad ) - ( t . y - s . y ) * math . sin ( rad ) + s . x <NEWLINE> y = ( t . x - s . x ) * math . sin ( rad ) + ( t . y - s . y ) * math . cos ( rad ) + s . y <NEWLINE> u = Dot ( x , y ) <NEWLINE> <NL> kock ( n - 1 , a , s , dots ) <NEWLINE> s . print ( ) <NEWLINE> dots . append ( s ) <NEWLINE> kock ( n - 1 , s , u , dots ) <NEWLINE> u . print ( ) <NEWLINE> dots . append ( u ) <NEWLINE> kock ( n - 1 , u , t , dots ) <NEWLINE> t . print ( ) <NEWLINE> dots . append ( t ) <NEWLINE> kock ( n - 1 , t , b , dots ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> dots = [ ] <NEWLINE> dot1 = Dot ( 0 , 0 ) <NEWLINE> dot2 = Dot ( 100 , 0 ) <NEWLINE> dots . append ( dot1 ) <NEWLINE> dots . append ( dot2 ) <NEWLINE> dot1 . print ( ) <NEWLINE> kock ( n , dot1 , dot2 , dots ) <NEWLINE> dot2 . print ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = [ 0 ] * n <NEWLINE> y = [ 0 ] * n <NEWLINE> z = [ ] <NEWLINE> w = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x [ i ] , y [ i ] = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> z . append ( x [ i ] + y [ i ] ) <NEWLINE> w . append ( x [ i ] - y [ i ] ) <NEWLINE> <DEDENT> a = max ( z ) - min ( z ) <NEWLINE> b = max ( w ) - min ( w ) <NEWLINE> print ( max ( a , b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> suma = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> suma *= i <NEWLINE> if suma > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( suma ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * a + b - k ) <NEWLINE> <DEDENT>
n , k , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> d = [ 2 * k ] * n <NEWLINE> while k : n = - a [ - n ] + 1 ; d [ n ] = k = ~ - k % ( d [ n ] + 1 - k ) <NEWLINE> print ( 1 - n ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = { } <NEWLINE> r = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i + 1 + a [ i ] in l : <NEWLINE> <INDENT> l [ i + 1 + a [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ i + 1 + a [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> if i + 1 - a [ i ] in r : <NEWLINE> <INDENT> r [ i + 1 - a [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r [ i + 1 - a [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> c = 0 <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if i in l and i in r : <NEWLINE> <INDENT> c += l [ i ] * r [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import copy <NEWLINE> h = w = 0 <NEWLINE> mymap = [ ] <NEWLINE> const_mymap = [ ] <NEWLINE> qlist = [ ] <NEWLINE> ans = 0 <NEWLINE> def bfs ( n ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if len ( qlist ) != 0 : <NEWLINE> <INDENT> temp = qlist . pop ( 0 ) <NEWLINE> x = temp [ 0 ] <NEWLINE> y = temp [ 1 ] <NEWLINE> deep = temp [ 2 ] <NEWLINE> <NL> <COMMENT> <NL> if mymap [ y ] [ x ] == str ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> return temp <NEWLINE> <DEDENT> if mymap [ y ] [ x ] != <STRING> : <NEWLINE> <INDENT> mymap [ y ] = mymap [ y ] [ : x ] + <STRING> + mymap [ y ] [ x + 1 : ] <NEWLINE> <NL> if x + 1 < w : <NEWLINE> <INDENT> if mymap [ y ] [ x + 1 ] not in <STRING> : <NEWLINE> <INDENT> qlist . append ( [ x + 1 , y , deep + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if x - 1 >= 0 : <NEWLINE> <INDENT> if mymap [ y ] [ x - 1 ] not in <STRING> : <NEWLINE> <INDENT> qlist . append ( [ x - 1 , y , deep + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if y + 1 < h : <NEWLINE> <INDENT> if mymap [ y + 1 ] [ x ] not in <STRING> : <NEWLINE> <INDENT> qlist . append ( [ x , y + 1 , deep + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if y - 1 >= 0 : <NEWLINE> <INDENT> if mymap [ y - 1 ] [ x ] not in <STRING> : <NEWLINE> <INDENT> qlist . append ( [ x , y - 1 , deep + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> h , w , n = list ( map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> for i in range ( 0 , h ) : <NEWLINE> <INDENT> const_mymap . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> mymap = copy . deepcopy ( const_mymap ) <NEWLINE> <NL> for i in range ( 0 , h ) : <NEWLINE> <INDENT> for j in range ( 0 , w ) : <NEWLINE> <INDENT> if mymap [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> nstart = [ j , i , 0 ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> qlist . append ( nstart ) <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> mymap = copy . deepcopy ( const_mymap ) <NEWLINE> xy = bfs ( i + 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans = xy [ 2 ] <NEWLINE> qlist = [ ] <NEWLINE> qlist . append ( xy ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 2018 <NEWLINE> <NL> for i in range ( L , min ( R , L + 2100 ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , min ( R + 1 , i + 2100 ) ) : <NEWLINE> <INDENT> if ( i * j ) % 2019 <= ans : <NEWLINE> <INDENT> ans = ( i * j ) % 2019 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) ) <NEWLINE> q = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> command = sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> q . appendleft ( command [ 7 : ] ) <NEWLINE> <DEDENT> elif command [ 6 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> q . remove ( command [ 7 : ] ) <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif command [ 6 ] == <STRING> : <NEWLINE> <INDENT> q . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( q ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> l = 0 <NEWLINE> man = 0 <NEWLINE> for i , v in enumerate ( s ) : <NEWLINE> <INDENT> if v == <STRING> : <NEWLINE> <INDENT> man += i - l <NEWLINE> l += 1 <NEWLINE> <DEDENT> <DEDENT> print ( man ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = li [ 0 ] <NEWLINE> if 0 in li : <NEWLINE> <INDENT> m = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> m = m * li [ i ] <NEWLINE> if m > 10 ** 18 : <NEWLINE> <INDENT> m = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( m ) <NEWLINE> <NL>
<NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> sumA = sum ( A ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += ( A [ i ] * ( sumA - A [ i ] ) ) <NEWLINE> <NL> <DEDENT> ans = ans // 2 <NEWLINE> print ( ans % mod ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
main = input ( ) <NEWLINE> word = input ( ) <NEWLINE> temp = main <NEWLINE> resultArray = [ ] <NEWLINE> final = len ( word ) <NEWLINE> for j in range ( len ( main ) - ( len ( word ) - 1 ) ) : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> for i in range ( len ( word ) ) : <NEWLINE> <INDENT> if main [ j + i ] == word [ i ] : <NEWLINE> <INDENT> result += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += <STRING> <NEWLINE> <DEDENT> <DEDENT> resultArray . append ( result ) <NEWLINE> <DEDENT> for i in resultArray : <NEWLINE> <INDENT> if i . count ( <STRING> ) < final : <NEWLINE> <INDENT> final = i . count ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( final ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> s = list ( input ( ) ) [ : : - 1 ] <NEWLINE> ary_mod = [ 0 ] * 2019 <NEWLINE> ary_mod [ 0 ] = 1 <NEWLINE> now = 0 <NEWLINE> <NL> for i , ss in enumerate ( s ) : <NEWLINE> <INDENT> now += int ( ss ) * pow ( 10 , i , 2019 ) <NEWLINE> remind = now % 2019 <NEWLINE> ary_mod [ remind ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i , n in enumerate ( ary_mod ) : <NEWLINE> <INDENT> ans += ( n * ( n - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> abcdabcd = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> abcd . append ( abcdabcd ) <NEWLINE> <COMMENT> <NL> <DEDENT> def cal ( A ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> for abcdi in abcd : <NEWLINE> <INDENT> a = abcdi [ 0 ] <NEWLINE> b = abcdi [ 1 ] <NEWLINE> c = abcdi [ 2 ] <NEWLINE> d = abcdi [ 3 ] <NEWLINE> if A [ b - 1 ] - A [ a - 1 ] == c : <NEWLINE> <INDENT> t += d <NEWLINE> <DEDENT> <DEDENT> return t <NEWLINE> <NL> <DEDENT> maxi = 0 <NEWLINE> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if N == 1 : <NEWLINE> <INDENT> maxi = max ( maxi , cal ( [ i ] ) ) <NEWLINE> <DEDENT> for j in range ( i , M + 1 ) : <NEWLINE> <INDENT> if N == 2 : <NEWLINE> <INDENT> maxi = max ( maxi , cal ( [ i , j ] ) ) <NEWLINE> <DEDENT> for k in range ( j , M + 1 ) : <NEWLINE> <INDENT> if N == 3 : <NEWLINE> <INDENT> maxi = max ( maxi , cal ( [ i , j , k ] ) ) <NEWLINE> <DEDENT> for l in range ( k , M + 1 ) : <NEWLINE> <INDENT> if N == 4 : <NEWLINE> <INDENT> maxi = max ( maxi , cal ( [ i , j , k , l ] ) ) <NEWLINE> <DEDENT> for m in range ( l , M + 1 ) : <NEWLINE> <INDENT> if N == 5 : <NEWLINE> <INDENT> maxi = max ( maxi , cal ( [ i , j , k , l , m ] ) ) <NEWLINE> <DEDENT> for n in range ( m , M + 1 ) : <NEWLINE> <INDENT> if N == 6 : <NEWLINE> <INDENT> maxi = max ( maxi , cal ( [ i , j , k , l , m , n ] ) ) <NEWLINE> <DEDENT> for o in range ( n , M + 1 ) : <NEWLINE> <INDENT> if N == 7 : <NEWLINE> <INDENT> maxi = max ( maxi , cal ( [ i , j , k , l , m , n , o ] ) ) <NEWLINE> <DEDENT> for p in range ( o , M + 1 ) : <NEWLINE> <INDENT> if N == 8 : <NEWLINE> <INDENT> maxi = max ( maxi , cal ( [ i , j , k , l , m , n , o , p ] ) ) <NEWLINE> <DEDENT> for q in range ( p , M + 1 ) : <NEWLINE> <INDENT> if N == 9 : <NEWLINE> <INDENT> maxi = max ( maxi , cal ( [ ij , k , l , m , n , o , p , q ] ) ) <NEWLINE> <DEDENT> for r in range ( q , M + 1 ) : <NEWLINE> <INDENT> if N == 10 : <NEWLINE> <INDENT> maxi = max ( maxi , cal ( [ i , j , k , l , m , n , o , p , q , r ] ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( maxi ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> result *= a <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> W = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> print ( W [ ( W . index ( S ) + 1 ) % 3 ] ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> if X == 0 : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = D <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt = X // D <NEWLINE> if cnt >= K : <NEWLINE> <INDENT> ans = X - ( D * K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= cnt <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> ans = X - ( D * cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = D - ( X - ( D * cnt ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> , i , <STRING> , x , sep = <STRING> ) <NEWLINE> i = i + 1 ; <NEWLINE> <DEDENT>
import pprint as pp <NEWLINE> <NL> class Main ( ) : <NEWLINE> <INDENT> def exchange ( self , n1 , n2 ) : <NEWLINE> <INDENT> tmp = self . A [ n1 ] <NEWLINE> self . A [ n1 ] = self . A [ n2 ] <NEWLINE> self . A [ n2 ] = tmp <NEWLINE> <NL> <DEDENT> def left ( self , i ) : <NEWLINE> <INDENT> return i * 2 <NEWLINE> <NL> <DEDENT> def right ( self , i ) : <NEWLINE> <INDENT> return i * 2 + 1 <NEWLINE> <NL> <DEDENT> def maxHeapify ( self , i ) : <NEWLINE> <INDENT> l = self . left ( i ) <NEWLINE> r = self . right ( i ) <NEWLINE> if l <= self . H and self . A [ l ] > self . A [ i ] : <NEWLINE> <INDENT> largest = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest = i <NEWLINE> <DEDENT> if r <= self . H and self . A [ r ] > self . A [ largest ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <DEDENT> if largest != i : <NEWLINE> <INDENT> self . exchange ( i , largest ) <NEWLINE> self . maxHeapify ( largest ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> def buildMaxHeap ( self ) : <NEWLINE> <INDENT> for i in reversed ( range ( 1 , self . H // 2 + 1 ) ) : <NEWLINE> <INDENT> self . maxHeapify ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( self ) : <NEWLINE> <INDENT> self . H = int ( input ( ) ) <NEWLINE> self . A = [ 0 ] <NEWLINE> inputData = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> self . A . extend ( inputData ) <NEWLINE> self . buildMaxHeap ( ) <NEWLINE> for i in range ( 1 , self . H + 1 ) : <NEWLINE> <INDENT> print ( <STRING> + str ( self . A [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> M = Main ( ) <NEWLINE> M . main ( ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bn = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_sum = [ 0 ] <NEWLINE> b_sum = [ 0 ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a_sum . append ( a_sum [ i - 1 ] + an [ i - 1 ] ) <NEWLINE> <DEDENT> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> b_sum . append ( b_sum [ j - 1 ] + bn [ j - 1 ] ) <NEWLINE> <NL> <DEDENT> idx = len ( bn ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> while a_sum [ i ] + b_sum [ idx ] > k : <NEWLINE> <INDENT> idx -= 1 <NEWLINE> if idx == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if idx == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = max ( ans , i + idx ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
<COMMENT> <NL> from math import gcd <NEWLINE> K = int ( input ( ) ) + 1 <NEWLINE> Sum = 0 <NEWLINE> for i in range ( 1 , K ) : <NEWLINE> <INDENT> for j in range ( 1 , K ) : <NEWLINE> <INDENT> d = gcd ( i , j ) <NEWLINE> for k in range ( 1 , K ) : <NEWLINE> <INDENT> Sum += gcd ( d , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( Sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Stock = 0 <NEWLINE> Money = 1000 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + 1 ] : <NEWLINE> <NL> <INDENT> Stock = Money // A [ i ] <NEWLINE> Money %= A [ i ] <NEWLINE> Money += Stock * A [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( Money ) <NEWLINE>
k , s = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> count = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - ( x + y ) <= k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <NL> import bisect <NEWLINE> <NL> class BIT : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . tree = [ 0 ] * ( n + 1 ) <NEWLINE> self . n = n <NEWLINE> <NL> <DEDENT> def add ( self , i , v ) : <NEWLINE> <INDENT> while i <= self . n : <NEWLINE> <INDENT> self . tree [ i ] += v <NEWLINE> i += i & - i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def _sum ( self , i ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> while i : <NEWLINE> <INDENT> ret += self . tree [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def sum ( self , l , h ) : <NEWLINE> <INDENT> return self . _sum ( h ) - self . _sum ( l - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> vx = [ ] <NEWLINE> xs = set ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> if x1 == x2 : <NEWLINE> <INDENT> if y1 > y2 : <NEWLINE> <INDENT> y1 , y2 = y2 , y1 <NEWLINE> <DEDENT> vx . append ( ( y1 , float ( <STRING> ) , x1 ) ) <NEWLINE> vx . append ( ( y2 , float ( <STRING> ) , x2 ) ) <NEWLINE> xs . add ( x1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x1 > x2 : <NEWLINE> <INDENT> x1 , x2 = x2 , x1 <NEWLINE> <DEDENT> vx . append ( ( y1 , x1 , x2 ) ) <NEWLINE> <DEDENT> <DEDENT> vx . sort ( ) <NEWLINE> <NL> bit = BIT ( len ( xs ) ) <NEWLINE> xs = [ float ( <STRING> ) ] + sorted ( xs ) <NEWLINE> ix = { v : i for i , v in enumerate ( xs ) } <NEWLINE> ans = 0 <NEWLINE> <NL> for y , j , x2 in vx : <NEWLINE> <INDENT> if j == float ( <STRING> ) : <NEWLINE> <INDENT> bit . add ( ix [ x2 ] , 1 ) <NEWLINE> <DEDENT> elif j == float ( <STRING> ) : <NEWLINE> <INDENT> bit . add ( ix [ x2 ] , - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = bisect . bisect_left ( xs , j ) <NEWLINE> r = bisect . bisect ( xs , x2 ) - 1 <NEWLINE> ans += bit . sum ( l , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> residents = [ [ [ <STRING> for rooms in range ( 10 ) ] for floor in range ( 3 ) ] for builds in range ( 4 ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> b , f , r , v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> new_number = int ( residents [ b - 1 ] [ f - 1 ] [ r - 1 ] ) + v <NEWLINE> residents [ b - 1 ] [ f - 1 ] [ r - 1 ] = str ( new_number ) <NEWLINE> <NL> <DEDENT> for buils_num in range ( 4 ) : <NEWLINE> <INDENT> for floor_num in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( residents [ buils_num ] [ floor_num ] ) ) <NEWLINE> <DEDENT> if buils_num < 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> s = 0 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> bit = np . count_nonzero ( a & 1 ) <NEWLINE> s += bit * ( n - bit ) * ( 2 ** i ) <NEWLINE> a >>= 1 <NEWLINE> <DEDENT> print ( s % mod ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <NL> def pop_cnt ( n ) : <NEWLINE> <INDENT> return bin ( n ) . count ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def f ( n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while n != 0 : <NEWLINE> <INDENT> n = n % pop_cnt ( n ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> n = int ( readline ( ) ) <NEWLINE> x2 = list ( readline ( ) . decode ( ) . rstrip ( ) ) <NEWLINE> x10 = int ( <STRING> . join ( x2 ) , 2 ) <NEWLINE> <NL> c = x2 . count ( <STRING> ) <NEWLINE> mod1 = x10 % ( c + 1 ) <NEWLINE> mod2 = x10 % ( c - 1 ) if c - 1 != 0 else 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> if x2 [ i ] == <STRING> : <NEWLINE> <INDENT> t = ( mod1 + pow ( 2 , n - i - 1 , c + 1 ) ) % ( c + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if c - 1 != 0 : <NEWLINE> <INDENT> t = ( mod2 - pow ( 2 , n - i - 1 , c - 1 ) ) % ( c - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT> ans = f ( t ) + 1 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import collections <NEWLINE> import numpy as np <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> from scipy . sparse . csgraph import floyd_warshall <NEWLINE> <NL> H , W , * S = open ( 0 ) . read ( ) . split ( ) <NEWLINE> H , W = [ int ( _ ) for _ in [ H , W ] ] <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for i in range ( H * W ) : <NEWLINE> <INDENT> x , y = divmod ( i , W ) <NEWLINE> if S [ x ] [ y ] == <STRING> : <NEWLINE> <INDENT> for dx , dy in ( ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ) : <NEWLINE> <INDENT> nx , ny = x + dx , y + dy <NEWLINE> if not ( 0 <= nx < H and 0 <= ny < W ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ nx ] [ ny ] == <STRING> : <NEWLINE> <INDENT> A += [ i ] <NEWLINE> B += [ nx * W + ny ] <NEWLINE> C += [ 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> F = floyd_warshall ( csr_matrix ( ( C , ( A , B ) ) , shape = ( H * W , H * W ) ) ) <NEWLINE> print ( int ( np . max ( F [ F != np . inf ] ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ A [ 0 ] ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> S . append ( S [ i - 1 ] + A [ i ] ) <NEWLINE> <DEDENT> x = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x += ( A [ i ] * ( S [ - 1 ] - S [ i ] ) ) % 1000000007 <NEWLINE> <DEDENT> x = x % 1000000007 <NEWLINE> print ( x ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = [ 0 ] * N <NEWLINE> <NL> <NL> for i in A : <NEWLINE> <INDENT> L [ i - 1 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( L [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ 0 ] * ( M + 1 ) <NEWLINE> A [ 0 ] = X <NEWLINE> D = [ 0 ] * ( M + 1 ) <NEWLINE> <NL> s = N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> a = A [ i - 1 ] ** 2 % M <NEWLINE> if D [ a ] == 1 : <NEWLINE> <INDENT> s = A . index ( a ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ i ] = a <NEWLINE> D [ a ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if s == N : <NEWLINE> <INDENT> ans = sum ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = A [ : i ] <NEWLINE> <NL> ans = 0 <NEWLINE> l = len ( A ) - s <NEWLINE> ans += sum ( A [ : s ] ) <NEWLINE> S = sum ( A [ s : ] ) <NEWLINE> T = ( N - s ) // l <NEWLINE> ans += T * S <NEWLINE> K = N - s - l * T <NEWLINE> ans += sum ( A [ s : ( s + K ) ] ) <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A_input = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> j_sum = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> j_sum = j_sum + A_input [ j ] <NEWLINE> <NL> <NL> <DEDENT> sum = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> j_sum = j_sum - A_input [ i ] <NEWLINE> sum = sum + A_input [ i ] * j_sum <NEWLINE> <NL> <DEDENT> print ( sum % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> <NL> <NL> def is_prime ( q ) : <NEWLINE> <INDENT> q = abs ( q ) <NEWLINE> if q == 2 : return True <NEWLINE> if q < 2 or q & 1 == 0 : return False <NEWLINE> return pow ( 2 , q - 1 , q ) == 1 <NEWLINE> <NL> <DEDENT> for s in sys . stdin : <NEWLINE> <INDENT> n = int ( s ) <NEWLINE> <NL> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if is_prime ( i ) : <NEWLINE> <INDENT> answer0 = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n + 1 , 100000 , 1 ) : <NEWLINE> <INDENT> if is_prime ( i ) : <NEWLINE> <INDENT> answer1 = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer0 , answer1 ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if K - A <= 0 : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if K - ( A + B ) <= 0 : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> elif K == A + B + C : <NEWLINE> <INDENT> print ( A - C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - ( A + B ) ) ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> l . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans += l [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = n - r - g <NEWLINE> <NL> ans = r * g * b <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if ( j + i * 2 >= n ) : break <NEWLINE> d1 , d2 , d3 = s [ j ] , s [ j + i ] , s [ j + i * 2 ] <NEWLINE> if ( not ( d1 == d2 or d2 == d3 or d1 == d3 ) ) : ans -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , V = map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) <NEWLINE> B , W = map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> if ( abs ( A - B ) <= ( V - W ) * T ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> C = deque ( list ( input ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> while len ( C ) > 1 : <NEWLINE> <INDENT> if C [ 0 ] == <STRING> and C [ - 1 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> C . popleft ( ) <NEWLINE> C . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if C [ 0 ] == <STRING> : <NEWLINE> <INDENT> C . popleft ( ) <NEWLINE> <DEDENT> if C [ - 1 ] == <STRING> : <NEWLINE> <INDENT> C . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
counter = [ 0 for i in range ( 10 ** 6 + 1 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> counter [ i ] += 1 <NEWLINE> <DEDENT> l = [ 0 for i in range ( 10 ** 6 + 1 ) ] <NEWLINE> cou = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b = a [ i ] <NEWLINE> if l [ b ] == 0 : <NEWLINE> <INDENT> cou += 1 <NEWLINE> for j in range ( b , 10 ** 6 + 1 , b ) : <NEWLINE> <INDENT> l [ j ] = 1 <NEWLINE> <DEDENT> if counter [ b ] >= 2 : <NEWLINE> <INDENT> cou -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cou ) <NEWLINE>
from math import ceil <NEWLINE> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> l = 0 <NEWLINE> r = max ( h ) <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for i in range ( n ) : res += ceil ( max ( 0 , ( h [ i ] - b * x ) ) / ( a - b ) ) <NEWLINE> return res <= x <NEWLINE> <NL> <DEDENT> while l + 1 < r : <NEWLINE> <INDENT> m = ( l + r ) // 2 <NEWLINE> if f ( m ) : r = m <NEWLINE> else : l = m <NEWLINE> <DEDENT> print ( r ) <NEWLINE>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> SUM = [ 0 ] * ( N + 1 ) <NEWLINE> MOD = 2019 <NEWLINE> <NL> r = 1 <COMMENT> <NEWLINE> S = S [ : : - 1 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = r * int ( S [ i ] ) <NEWLINE> SUM [ i + 1 ] = ( SUM [ i ] + A ) % MOD <NEWLINE> r = r * 10 % MOD <NEWLINE> <NL> <DEDENT> cnt = [ 0 ] * 2019 <NEWLINE> ans = 0 <NEWLINE> for x in SUM : <NEWLINE> <INDENT> ans += cnt [ x ] <NEWLINE> cnt [ x ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> a_copy = sorted ( a ) <NEWLINE> a_max = a_copy [ - 1 ] <NEWLINE> a_second = a_copy [ - 2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == a_max : <NEWLINE> <INDENT> print ( a_second ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a_max ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
s = input ( ) <NEWLINE> if s [ 0 ] == <STRING> and s [ 2 : - 1 ] . count ( <STRING> ) == 1 : <NEWLINE> <INDENT> sc = s . index ( <STRING> ) <NEWLINE> if ( s [ 1 : sc ] + s [ sc + 1 : ] ) . islower ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> y = 0 <NEWLINE> x = [ i % 10 for i in a ] <NEWLINE> if max ( x ) > 0 : <NEWLINE> <INDENT> y = 10 - min ( filter ( lambda i : i != 0 , x ) ) <NEWLINE> <DEDENT> b = [ ( i + 9 ) // 10 * 10 for i in a ] <NEWLINE> print ( sum ( b ) - y ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> thld = pow ( 10 , 18 ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > thld : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1 <NEWLINE> <NL> a = sorted ( a ) <NEWLINE> <NL> if a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> x = x * a [ i ] <NEWLINE> <NL> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if i == n - 1 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> A = dict ( zip ( list ( range ( len ( a ) ) ) , a ) ) <NEWLINE> ans = 0 <NEWLINE> suma = 0 <NEWLINE> suma = sum ( a ) <NEWLINE> <NL> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> suma -= A [ i ] <NEWLINE> ans = ( ans + A [ i ] * suma ) % 1000000007 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> N , M , Q = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> abcd = [ 0 ] * Q <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> abcd [ q ] = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> abcd . sort ( key = lambda x : ( x [ 0 ] , x [ 1 ] ) ) <NEWLINE> vecs = [ ] <NEWLINE> <NL> def makevecs ( n , vecs , A ) : <NEWLINE> <INDENT> if n == N : <NEWLINE> <INDENT> vecs . append ( A ) <NEWLINE> return None <NEWLINE> <DEDENT> for b in range ( A [ - 1 ] , M + 1 ) : <NEWLINE> <INDENT> makevecs ( n + 1 , vecs , A + [ b ] ) <NEWLINE> <DEDENT> return None <NEWLINE> <NL> <DEDENT> makevecs ( 1 , vecs , [ 1 ] ) <NEWLINE> ans = 0 <NEWLINE> for vec in vecs : <NEWLINE> <INDENT> ans_ = 0 <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = abcd [ q ] <NEWLINE> if vec [ b - 1 ] - vec [ a - 1 ] == c : <NEWLINE> <INDENT> ans_ += d <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , ans_ ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> line = input ( ) . split ( <STRING> ) <NEWLINE> <NL> tot = 1 <NEWLINE> <NL> for a in line : <NEWLINE> <INDENT> if a == <STRING> : <NEWLINE> <INDENT> tot = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if tot == 1 : <NEWLINE> <INDENT> for a in line : <NEWLINE> <INDENT> tot *= int ( a ) <NEWLINE> if tot > 10 ** 18 : <NEWLINE> <INDENT> tot = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( tot ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> soui = 0 <NEWLINE> moji = s [ 0 ] <NEWLINE> <NL> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == s [ i - 1 ] and soui == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> soui = 1 <NEWLINE> <DEDENT> elif soui == 1 : <NEWLINE> <INDENT> soui = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> flag = 0 <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> <NL> while s [ 0 ] == s [ a ] and a != len ( s ) - 1 : <NEWLINE> <INDENT> a += 1 <NEWLINE> <NL> <DEDENT> while s [ len ( s ) - 1 - b ] == s [ len ( s ) - 1 ] and b != len ( s ) - 1 : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <NL> <DEDENT> if s [ 0 ] == s [ len ( s ) - 1 ] : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <NL> <DEDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if moji != s [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif i == len ( s ) - 1 : <NEWLINE> <INDENT> flag = 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( ( k * ans ) - ( ( k - 1 ) * ( ( a // 2 ) + ( b // 2 ) - ( ( a + b ) // 2 ) ) ) ) <NEWLINE> <DEDENT> elif flag == 2 : <NEWLINE> <INDENT> print ( ( k * len ( s ) ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( k * ans ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> N -= 1 <NEWLINE> L = [ 26 ** ( i + 1 ) for i in range ( 15 ) ] <NEWLINE> sL = list ( accumulate ( L ) ) <NEWLINE> result = [ ] <NEWLINE> k = 0 <NEWLINE> for i in range ( 15 ) : <NEWLINE> <INDENT> if N + 1 <= sL [ i ] and N >= 25 : <NEWLINE> <INDENT> N -= sL [ i - 1 ] <NEWLINE> k = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for m in range ( k ) : <NEWLINE> <INDENT> time = 0 <NEWLINE> while N >= L [ k - m - 1 ] : <NEWLINE> <INDENT> N -= L [ k - m - 1 ] <NEWLINE> time += 1 <NEWLINE> <DEDENT> result . append ( chr ( time + 97 ) ) <NEWLINE> <DEDENT> result . append ( chr ( N + 97 ) ) <NEWLINE> print ( <STRING> . join ( result ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for d in range ( n ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> <NL> <COMMENT> <NL> route2 = [ [ ] for n in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> for a , b in zip ( A , B ) : <NEWLINE> <INDENT> route2 [ a - 1 ] . append ( b - 1 ) <NEWLINE> route2 [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> room_sign = [ None ] * N <NEWLINE> <NL> queue = deque ( [ ] ) <NEWLINE> visited = set ( ) <NEWLINE> <NL> queue . append ( 0 ) <NEWLINE> visited . add ( 0 ) <NEWLINE> <NL> while len ( queue ) > 0 : <NEWLINE> <INDENT> now = queue . popleft ( ) <NEWLINE> for i in route2 [ now ] : <NEWLINE> <INDENT> if i not in visited : <NEWLINE> <INDENT> queue . append ( i ) <NEWLINE> visited . add ( i ) <NEWLINE> <NL> room_sign [ i ] = now + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for s in room_sign [ 1 : ] : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
class Dice : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> self . t = 1 <NEWLINE> self . s = 2 <NEWLINE> self . e = 3 <NEWLINE> self . w = 4 <NEWLINE> self . n = 5 <NEWLINE> self . b = 6 <NEWLINE> self . rotway = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 , <STRING> : 3 } <NEWLINE> <NL> <DEDENT> def __init__ ( self , t , s , e , w , n , b ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . t = t <NEWLINE> self . s = s <NEWLINE> self . e = e <NEWLINE> self . w = w <NEWLINE> self . n = n <NEWLINE> self . b = b <NEWLINE> self . rotway = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 , <STRING> : 3 } <NEWLINE> <NL> <DEDENT> def rot ( self , way ) : <NEWLINE> <INDENT> if way == 0 : <NEWLINE> <INDENT> self . t , self . s , self . e , self . w , self . n , self . b = self . n , self . t , self . e , self . w , self . b , self . s <NEWLINE> <DEDENT> elif way == 1 : <NEWLINE> <INDENT> self . t , self . s , self . e , self . w , self . n , self . b = self . s , self . b , self . e , self . w , self . t , self . n <NEWLINE> <DEDENT> elif way == 2 : <NEWLINE> <INDENT> self . t , self . s , self . e , self . w , self . n , self . b = self . w , self . s , self . t , self . b , self . n , self . e <NEWLINE> <DEDENT> elif way == 3 : <NEWLINE> <INDENT> self . t , self . s , self . e , self . w , self . n , self . b = self . e , self . s , self . b , self . t , self . n , self . w <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import random <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> diceList = [ [ 0 for _ in range ( 6 ) ] for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> diceList [ i ] [ 0 ] , diceList [ i ] [ 1 ] , diceList [ i ] [ 2 ] , diceList [ i ] [ 3 ] , diceList [ i ] [ 4 ] , diceList [ i ] [ 5 ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> flag = 0 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dice_a = Dice ( diceList [ i ] [ 0 ] , diceList [ i ] [ 1 ] , diceList [ i ] [ 2 ] , diceList [ i ] [ 3 ] , diceList [ i ] [ 4 ] , diceList [ i ] [ 5 ] ) <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> dice_b = Dice ( diceList [ j ] [ 0 ] , diceList [ j ] [ 1 ] , diceList [ j ] [ 2 ] , diceList [ j ] [ 3 ] , diceList [ j ] [ 4 ] , diceList [ j ] [ 5 ] ) <NEWLINE> <NL> for _ in range ( 200 ) : <NEWLINE> <INDENT> if ( dice_a . t , dice_a . s , dice_a . e , dice_a . w , dice_a . n , dice_a . b ) == ( dice_b . t , dice_b . s , dice_b . e , dice_b . w , dice_b . n , dice_b . b ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> seed = random . randint ( 0 , 3 ) <NEWLINE> dice_a . rot ( seed ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> if len ( set ( x ) ) == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for p in range ( min ( x ) , max ( x ) ) : <NEWLINE> <INDENT> meter = 0 <NEWLINE> for xi in x : <NEWLINE> <INDENT> meter += pow ( ( xi - p ) , 2 ) <NEWLINE> <DEDENT> ans . append ( meter ) <NEWLINE> <DEDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in reversed ( range ( 1 , x + 1 ) ) : <NEWLINE> <INDENT> for j in range ( 2 , 101 ) : <NEWLINE> <INDENT> for k in range ( 2 , 101 ) : <NEWLINE> <INDENT> number = j ** k <NEWLINE> if number == i : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> Apos = A <NEWLINE> Bpos = B <NEWLINE> count = 0 <NEWLINE> rev = False <NEWLINE> if B > A : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rev = True <NEWLINE> <NL> <DEDENT> if rev == False : <NEWLINE> <NL> <NL> <NL> <INDENT> A = A + V * K <NEWLINE> B = B + W * K <NEWLINE> if A >= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> A = A - V * K <NEWLINE> B = B - W * K <NEWLINE> if A <= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += gcd ( k , gcd ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> <NL> ans = len ( T ) <NEWLINE> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if S [ i + j ] != T [ j ] : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , s ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( i , k + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> cnt += 2 * math . gcd ( tmp , l ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += math . gcd ( tmp , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> B [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( B [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> mat = [ [ 0 ] * n for _ in range ( n ) ] <NEWLINE> d , f = [ 0 ] * n , [ 0 ] * n <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> adj = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = adj [ 0 ] <NEWLINE> v = adj [ 2 : ] <NEWLINE> for j in v : <NEWLINE> <INDENT> mat [ i - 1 ] [ j - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> time , current = 0 , 0 <NEWLINE> stack = [ ] <NEWLINE> while 0 in f : <NEWLINE> <INDENT> if not stack : <NEWLINE> <INDENT> for i , v in enumerate ( f ) : <NEWLINE> <INDENT> if v == 0 : <NEWLINE> <INDENT> stack . append ( i ) <NEWLINE> time += 1 <NEWLINE> d [ i ] = time <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> time += 1 <NEWLINE> current = stack [ - 1 ] <NEWLINE> for i in range ( len ( mat [ current ] ) ) : <NEWLINE> <INDENT> if mat [ current ] [ i ] and not d [ i ] : <NEWLINE> <INDENT> current = i <NEWLINE> d [ i ] = time <NEWLINE> stack . append ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> f [ current ] = time <NEWLINE> current = stack . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for l in zip ( range ( 1 , n + 1 ) , d , f ) : <NEWLINE> <INDENT> print ( * l ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> from collections import deque <NEWLINE> a = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a . append ( list ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> count += x . count ( <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> b = [ [ - 1 for i in range ( m ) ] for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> <NL> x = [ 0 , 0 , - 1 , 1 ] <NEWLINE> y = [ - 1 , 1 , 0 , 0 ] <NEWLINE> queue = deque ( [ [ 0 , 0 ] ] ) <NEWLINE> b [ 0 ] [ 0 ] = 1 <NEWLINE> while queue : <NEWLINE> <INDENT> now = queue . popleft ( ) <NEWLINE> if now == [ n - 1 , m - 1 ] : <NEWLINE> <INDENT> print ( n * m - ( b [ n - 1 ] [ m - 1 ] + count ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a [ now [ 0 ] ] [ now [ 1 ] ] = <STRING> <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if 0 <= now [ 0 ] + y [ i ] < n and 0 <= now [ 1 ] + x [ i ] < m and b [ now [ 0 ] + y [ i ] ] [ now [ 1 ] + x [ i ] ] == - 1 : <NEWLINE> <INDENT> if a [ now [ 0 ] + y [ i ] ] [ now [ 1 ] + x [ i ] ] == <STRING> : <NEWLINE> <INDENT> queue . append ( [ now [ 0 ] + y [ i ] , now [ 1 ] + x [ i ] ] ) <NEWLINE> b [ now [ 0 ] + y [ i ] ] [ now [ 1 ] + x [ i ] ] = b [ now [ 0 ] ] [ now [ 1 ] ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <NL>
t = int ( input ( ) ) <NEWLINE> S = 0 <NEWLINE> for i in list ( range ( t + 1 ) ) : <NEWLINE> <INDENT> if i % 5 != 0 and i % 3 != 0 : <NEWLINE> <INDENT> S += i <NEWLINE> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> GCD = math . gcd ( N , M ) <NEWLINE> L = N * M // GCD <NEWLINE> <NL> dist_N = L // N <NEWLINE> dist_M = L // M <NEWLINE> <NL> <COMMENT> <NL> for i in range ( GCD ) : <NEWLINE> <COMMENT> <NL> <INDENT> s = dist_M * i <NEWLINE> t = dist_N * i <NEWLINE> if S [ s ] != T [ t ] : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = L <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( n + 1 ) : <NEWLINE> <INDENT> for y in range ( n + 1 ) : <NEWLINE> <INDENT> if 0 <= s - x - y <= n : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math as m <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N >= B : print ( m . floor ( A * - 1 / B ) - A * m . floor ( - 1 / B ) ) <NEWLINE> else : print ( m . floor ( A * N / B ) - A * m . floor ( N / B ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = N * ( N - 1 ) // 2 <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL>
<NL> from bisect import bisect_left <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> H , W , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ 0 ] * ( H + 1 ) <NEWLINE> w = [ 0 ] * ( W + 1 ) <NEWLINE> c = [ [ - 1 , 10 ** 6 ] for i in range ( H + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> h [ a ] += 1 <NEWLINE> w [ b ] += 1 <NEWLINE> c [ a ] . append ( b ) <NEWLINE> <DEDENT> mh = max ( h ) <NEWLINE> mw = max ( w ) <NEWLINE> hkouho = [ ] <NEWLINE> wkouho = [ ] <NEWLINE> for i in range ( H + 1 ) : <NEWLINE> <INDENT> if h [ i ] == mh : <NEWLINE> <INDENT> hkouho . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( W + 1 ) : <NEWLINE> <INDENT> if w [ i ] == mw : <NEWLINE> <INDENT> wkouho . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( H + 1 ) : <NEWLINE> <INDENT> c [ i ] . sort ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> for i in hkouho : <NEWLINE> <INDENT> for j in wkouho : <NEWLINE> <COMMENT> <NL> <INDENT> if c [ i ] [ bisect_left ( c [ i ] , j ) ] != j : <NEWLINE> <INDENT> print ( mh + mw ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( mh + mw - 1 ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , M = LI ( ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = LI_ ( ) <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] <NEWLINE> visited = [ False ] * N <NEWLINE> def dfs ( c , depth ) : <NEWLINE> <INDENT> visited [ c ] = True <NEWLINE> if depth == N - 1 : <NEWLINE> <INDENT> ans [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for n in G [ c ] : <NEWLINE> <INDENT> if not visited [ n ] : <NEWLINE> <INDENT> dfs ( n , depth + 1 ) <NEWLINE> visited [ n ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , 0 ) <NEWLINE> <NL> print ( ans [ 0 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i , v in enumerate ( A ) : <NEWLINE> <INDENT> if i >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x *= A [ i ] <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
import numpy as np <NEWLINE> <NL> m = 998244353 <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> span = [ ] <NEWLINE> for K in range ( K ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> span . append ( [ l , r ] ) <NEWLINE> <NL> <DEDENT> add = [ 0 , 1 ] <COMMENT> <NEWLINE> ans = [ 1 ] <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for s in span : <NEWLINE> <INDENT> l , r = s [ 0 ] , s [ 1 ] + 1 <NEWLINE> if l > len ( ans ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif r >= len ( ans ) + 1 : <NEWLINE> <INDENT> r = len ( ans ) + 1 <NEWLINE> <DEDENT> tmp += ( add [ i - l ] - add [ i - r ] ) % m <NEWLINE> <DEDENT> ans . append ( tmp % m ) <NEWLINE> add . append ( add [ - 1 ] + tmp ) <NEWLINE> <NL> <DEDENT> print ( ans [ - 1 ] % m ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> bc = [ map ( int , input ( ) . split ( ) ) for _ in range ( Q ) ] <NEWLINE> b , c = [ list ( i ) for i in zip ( * bc ) ] <NEWLINE> <NL> mydict = { } <NEWLINE> for i in A : <NEWLINE> <INDENT> if i in mydict : <NEWLINE> <INDENT> score = mydict [ i ] <NEWLINE> mydict [ i ] = score + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mydict [ i ] = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for k , v in mydict . items ( ) : <NEWLINE> <INDENT> count = count + k * v <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> if b [ i ] in mydict : <NEWLINE> <INDENT> if c [ i ] in mydict : <NEWLINE> <INDENT> score1 = mydict [ b [ i ] ] <NEWLINE> score2 = mydict [ c [ i ] ] <NEWLINE> <NL> count1 = score1 * b [ i ] <NEWLINE> count2 = score1 * c [ i ] <NEWLINE> del mydict [ b [ i ] ] <NEWLINE> mydict [ c [ i ] ] = score1 + score2 <NEWLINE> count = count - count1 + count2 <NEWLINE> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> count = count - b [ i ] * mydict [ b [ i ] ] + c [ i ] * mydict [ b [ i ] ] <NEWLINE> mydict [ c [ i ] ] = mydict [ b [ i ] ] <NEWLINE> del mydict [ b [ i ] ] <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> rank = 0 <NEWLINE> ans = 0 <NEWLINE> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A + B >= K and K > A : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tem = K - A - B <NEWLINE> ans = A - tem <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> len_s = len ( s ) <NEWLINE> pre = 0 <NEWLINE> mod = [ 0 ] * 2019 <NEWLINE> mod [ 0 ] = 1 <NEWLINE> x = 1 <NEWLINE> for i in range ( len_s ) : <NEWLINE> <INDENT> pre = ( x * int ( s [ len_s - i - 1 ] ) + pre ) % 2019 <NEWLINE> mod [ pre ] += 1 <NEWLINE> x *= 10 <NEWLINE> x %= 2019 <NEWLINE> <DEDENT> print ( sum ( [ m * ( m - 1 ) // 2 for m in mod ] ) ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , numpy , string <NEWLINE> import sys <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> N = I ( ) <NEWLINE> A = LI ( ) <NEWLINE> <COMMENT> <NL> i = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> if min ( A ) == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > i : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 1 <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> total *= A [ i ] <NEWLINE> if total > 10 ** 18 : <NEWLINE> <INDENT> count += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif count == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( total ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> from math import gcd <NEWLINE> <NL> y = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> y += gcd ( x , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( y ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> sum = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if ( k < N ) : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ i ] != S [ k ] : <NEWLINE> <INDENT> sum -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <NL>
from numpy import * ; N , K = map ( int , input ( ) . split ( ) ) ; m = zeros ( ( 3 * K , 3 * K ) , dtype = int ) ; L = 2 * K ; o = 0 <NEWLINE> for _ in [ 0 ] * N : x , y , c = input ( ) . split ( ) ; t = c == <STRING> ; m [ int ( x ) % L , int ( y ) % L ] += 2 * t - 1 ; o += t <NEWLINE> for _ in [ 0 , 0 ] : m [ L : ] = m [ : K ] ; m = cumsum ( m , axis = 0 ) ; m [ : L ] -= m [ K : ] ; m = m . T <NEWLINE> m = m [ : L , : L ] ; print ( o - int ( ( m + roll ( roll ( m , K , axis = 0 ) , K , axis = 1 ) ) . min ( ) ) ) <NEWLINE>
for i in range ( 0 , 100000000 ) : <NEWLINE> <INDENT> txt = input ( <STRING> ) <NEWLINE> txt1 , txt2 = txt . split ( <STRING> ) <NEWLINE> a = int ( txt1 ) <NEWLINE> b = int ( txt2 ) <NEWLINE> if ( a == 0 & b == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 0 , a ) : <NEWLINE> <INDENT> for j in range ( 0 , b ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = 105 <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = [ 0 ] * 10050 <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> for l in range ( 1 , n ) : <NEWLINE> <INDENT> for r in range ( 1 , n ) : <NEWLINE> <INDENT> value = j * j + l * l + r * r + j * l + j * r + l * r <NEWLINE> if value < 10050 : <NEWLINE> <INDENT> ans [ value ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> adj = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> adj [ a ] . append ( b ) <NEWLINE> adj [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> def dfs ( v , p = - 1 ) : <NEWLINE> <INDENT> global ans <NEWLINE> <NL> res = 1 <NEWLINE> ts = [ ] <NEWLINE> for u in adj [ v ] : <NEWLINE> <INDENT> if ( u == p ) : continue <NEWLINE> t = dfs ( u , v ) <NEWLINE> res += t <NEWLINE> ts . append ( t ) <NEWLINE> <NL> <DEDENT> if p != - 1 : <NEWLINE> <INDENT> ts . append ( N - res ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> now = pows [ N - 1 ] - 1 <NEWLINE> for t in ts : <NEWLINE> <COMMENT> <NL> <INDENT> now -= pows [ t ] - 1 <NEWLINE> <DEDENT> ans += now <NEWLINE> return res <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> pows = [ 1 ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> pows [ i ] = ( pows [ i - 1 ] * 2 ) % MOD <NEWLINE> <NL> <DEDENT> dfs ( 1 ) <NEWLINE> print ( ( ans * pow ( pows [ N ] , MOD - 2 , MOD ) ) % MOD ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> b = [ ] <NEWLINE> c = list ( map ( int , <STRING> * n ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> c [ i ] += A [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> <NL> def depth_first_search ( s ) : <NEWLINE> <INDENT> if int ( s ) > n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> ret = 1 if all ( s . count ( c ) > 0 for c in <STRING> ) else 0 <NEWLINE> for c in <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ret += depth_first_search ( s + c ) <NEWLINE> <COMMENT> <NL> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> print ( depth_first_search ( <STRING> ) ) <NEWLINE>
T = list ( input ( ) ) <NEWLINE> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> T = <STRING> . join ( T ) <NEWLINE> print ( T ) <NEWLINE>
<COMMENT> <NL> k = int ( input ( ) ) <NEWLINE> ans = - 1 <NEWLINE> x = 7 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> if x % k == 0 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> x = ( 10 * x + 7 ) % k <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = input ( ) <NEWLINE> print ( S [ : k - 1 ] + S [ k - 1 ] . lower ( ) + S [ k : ] ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> n = int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> a = np . fromstring ( sys . stdin . buffer . readline ( ) , dtype = np . int64 , sep = <STRING> ) <NEWLINE> ans = 0 <NEWLINE> b = 1 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> s = int ( ( a & 1 ) . sum ( ) ) <NEWLINE> ans = ( ans + s * ( n - s ) * b ) % mod <NEWLINE> a >>= 1 <NEWLINE> b = b * 2 % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> def dfs ( v , tm ) : <NEWLINE> <INDENT> dts [ v ] = est [ v ] = tm + 1 <NEWLINE> child = 0 <NEWLINE> <NL> for i in adj [ v ] : <NEWLINE> <INDENT> if est [ i ] == float ( <STRING> ) : <NEWLINE> <INDENT> child += 1 <NEWLINE> parents [ i ] = v <NEWLINE> dfs ( i , tm + 1 ) <NEWLINE> est [ v ] = min ( est [ v ] , est [ i ] ) <NEWLINE> <NL> if parents [ v ] is None and child > 1 : aps [ v ] = True <NEWLINE> if parents [ v ] is not None and est [ i ] >= dts [ v ] : aps [ v ] = True <NEWLINE> <NL> <DEDENT> elif parents [ v ] != i : <NEWLINE> <INDENT> est [ v ] = min ( est [ v ] , dts [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> nv , ne = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> adj = [ [ ] for _ in range ( nv ) ] <NEWLINE> est = [ float ( <STRING> ) ] * nv <NEWLINE> parents = [ None ] * nv <NEWLINE> aps = [ False ] * nv <NEWLINE> dts = [ 0 ] * nv <NEWLINE> <NL> for _ in range ( ne ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> adj [ s ] . append ( t ) <NEWLINE> adj [ t ] . append ( s ) <NEWLINE> <NL> <DEDENT> dfs ( 0 , 0 ) <NEWLINE> <NL> for i in range ( nv ) : <NEWLINE> <INDENT> if aps [ i ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> al = <STRING> <NEWLINE> AL = al . upper ( ) <NEWLINE> <NL> s = deque ( X ( ) ) <NEWLINE> n = k ( ) <NEWLINE> normal = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> if int ( a [ 0 ] ) == 1 : <NEWLINE> <INDENT> normal ^= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = int ( a [ 1 ] ) - 1 <NEWLINE> k ^= normal <NEWLINE> if k == 1 : <NEWLINE> <INDENT> s . append ( a [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . appendleft ( a [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( s ) if normal == 0 else <STRING> . join ( list ( s ) [ : : - 1 ] ) ) <NEWLINE>
S = input ( ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ int ( S [ 5 : 7 ] + S [ 8 : 10 ] ) > 430 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> SUM = sum ( ls ) <NEWLINE> for i in range ( len ( ls ) ) : <NEWLINE> <INDENT> SUM -= ls [ i ] <NEWLINE> ans += ls [ i ] * SUM <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE>
s = list ( map ( int , input ( ) ) ) <NEWLINE> s . reverse ( ) <NEWLINE> t = len ( s ) <NEWLINE> mod = 2019 <NEWLINE> <NL> arr = [ 0 ] * ( t + 1 ) <NEWLINE> arr [ - 2 ] = s [ 0 ] <NEWLINE> for i in range ( 1 , t ) : <NEWLINE> <INDENT> arr [ t - i - 1 ] = ( arr [ t - i ] + s [ i ] * pow ( 10 , i , mod ) ) % mod <NEWLINE> <NL> <DEDENT> from collections import Counter <NEWLINE> arr = Counter ( arr ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in arr : <NEWLINE> <INDENT> ans += ( arr [ i ] - 1 ) * arr [ i ] // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ int ( input ( ) ) for s in range ( n ) ] <NEWLINE> s1 = [ ] <NEWLINE> sum0 = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i % 10 == 0 : <NEWLINE> <INDENT> sum0 += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s1 . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( s1 ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum1 = sum ( s1 ) <NEWLINE> if sum1 % 10 != 0 : <NEWLINE> <INDENT> print ( sum0 + sum1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum0 + sum1 - min ( s1 ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> def is_odd ( num ) : <NEWLINE> <INDENT> return num % 2 <NEWLINE> <NL> <DEDENT> n , _ , _ = map ( int , f . readline ( ) . split ( ) ) <COMMENT> <NEWLINE> a = list ( map ( int , f . readline ( ) . split ( ) ) ) <NEWLINE> q = list ( map ( int , f . readline ( ) . split ( ) ) ) <NEWLINE> <NL> s = list ( range ( n ) ) <NEWLINE> <NL> pos = 0 <NEWLINE> for ai in a : <NEWLINE> <INDENT> pos += - ai if is_odd ( ai ) else ai <NEWLINE> pos %= len ( s ) <NEWLINE> s . pop ( pos ) <NEWLINE> <NL> <DEDENT> for qi in q : <NEWLINE> <INDENT> print ( 1 if qi in s else 0 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> def binary_search ( a , key ) : <NEWLINE> <INDENT> n = len ( a ) <NEWLINE> left = 0 <NEWLINE> right = n <NEWLINE> while left < right : <NEWLINE> <COMMENT> <NL> <INDENT> mid = ( right + left ) // 2 <NEWLINE> if a [ mid ] == key : <NEWLINE> <INDENT> return mid <NEWLINE> <DEDENT> elif a [ mid ] > key : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> <DEDENT> return n <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> q = int ( input ( ) ) <NEWLINE> t = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in t : <NEWLINE> <INDENT> if binary_search ( s , i ) < n : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
class Matrix : <NEWLINE> <INDENT> def __init__ ( self , rows , cols , values = None ) : <NEWLINE> <INDENT> self . rows = rows <NEWLINE> self . cols = cols <NEWLINE> if values is not None : <NEWLINE> <INDENT> self . values = values <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> row = [ 0 for i in range ( cols ) ] <NEWLINE> self . values = [ row [ : ] for j in range ( rows ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> def row ( self , i ) : <NEWLINE> <INDENT> return self . values [ i - 1 ] <NEWLINE> <NL> <DEDENT> def col ( self , j ) : <NEWLINE> <INDENT> return [ row [ j - 1 ] for row in self . values ] <NEWLINE> <NL> <DEDENT> def __mul__ ( self , other ) : <NEWLINE> <INDENT> assert self . cols == other . rows <NEWLINE> <NL> m = self . __class__ ( self . rows , other . cols ) <NEWLINE> for i in range ( self . rows ) : <NEWLINE> <INDENT> for j in range ( other . cols ) : <NEWLINE> <INDENT> m [ i , j ] = sum ( a * b for ( a , b ) in zip ( self . row ( i ) , <NEWLINE> <INDENT> other . col ( j ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return m <NEWLINE> <NL> <DEDENT> def __getitem__ ( self , idx ) : <NEWLINE> <INDENT> row , col = idx <NEWLINE> return self . values [ row - 1 ] [ col - 1 ] <NEWLINE> <NL> <DEDENT> def __setitem__ ( self , idx , val ) : <NEWLINE> <INDENT> row , col = idx <NEWLINE> self . values [ row - 1 ] [ col - 1 ] = val <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> s = [ ] <NEWLINE> for row in self . values : <NEWLINE> <INDENT> s . append ( <STRING> . join ( [ str ( i ) for i in row ] ) ) <NEWLINE> <DEDENT> return <STRING> . join ( s ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> n , m , l = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> <NL> m1 = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m1 . append ( [ int ( v ) for v in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> m2 = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> m2 . append ( [ int ( v ) for v in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> print ( Matrix ( n , m , m1 ) * Matrix ( m , l , m2 ) ) <NEWLINE> <NL> <NL> <DEDENT> run ( ) <NEWLINE>
import itertools <NEWLINE> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ ] <NEWLINE> A = dict ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> CA = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C . append ( CA [ 0 ] ) <NEWLINE> for j in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if j in A : <NEWLINE> <INDENT> A [ j ] . append ( CA [ j ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ j ] = [ CA [ j ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> cost = float ( <STRING> ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for pm in itertools . combinations ( list ( range ( 1 , N + 1 ) ) , r = i ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> k = dict ( ) <NEWLINE> for p in pm : <NEWLINE> <INDENT> c += C [ p - 1 ] <NEWLINE> <NL> for m in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if m in k : <NEWLINE> <INDENT> k [ m ] += A [ m ] [ p - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k [ m ] = A [ m ] [ p - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if min ( k . values ( ) ) >= X : <NEWLINE> <INDENT> cost = min ( cost , c ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if cost == float ( <STRING> ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cost ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> black = c . count ( <STRING> ) <NEWLINE> white = c . count ( <STRING> ) <NEWLINE> <NL> if black == n : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> b = 0 <NEWLINE> w = 0 <NEWLINE> now = 0 <NEWLINE> ans = float ( <STRING> ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> w = ( i + 1 ) - b <NEWLINE> <NL> now = b + ( white - w ) <NEWLINE> ans = min ( ans , now ) <NEWLINE> <NL> <DEDENT> print ( min ( ans , white ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> ans = a [ 0 ] <NEWLINE> w = n // 2 <NEWLINE> for aa in a [ 1 : w ] : <NEWLINE> <INDENT> ans += aa * 2 <NEWLINE> <DEDENT> if n % 2 != 0 : <NEWLINE> <INDENT> ans += a [ w ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string <NEWLINE> from collections import defaultdict as D <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> import os <NEWLINE> from operator import mul <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def _S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( _S ( ) ) <NEWLINE> def LS ( ) : return list ( _S ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , LS ( ) ) ) <NEWLINE> <NL> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> inputFile = basename_without_ext = os . path . splitext ( os . path . basename ( __file__ ) ) [ 0 ] + <STRING> <NEWLINE> sys . stdin = open ( inputFile , <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> _ , k = LI ( ) <NEWLINE> a = LI ( ) <NEWLINE> <COMMENT> <NL> a = list ( map ( lambda x : x - 1 , a ) ) <NEWLINE> <COMMENT> <NL> <NL> s = set ( [ 0 ] ) <NEWLINE> <NL> <COMMENT> <NL> def rec ( visited , next ) : <NEWLINE> <INDENT> if next in s : <NEWLINE> <COMMENT> <NL> <INDENT> return visited , visited . index ( next ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . add ( next ) <NEWLINE> visited . append ( next ) <NEWLINE> return rec ( visited , a [ next ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> visited = [ 0 ] <NEWLINE> <COMMENT> <NL> visited , loopStart = rec ( visited , a [ 0 ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> if k < len ( visited ) : <NEWLINE> <INDENT> townIndex = visited [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visitedLoop = visited [ loopStart : ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> index = ( k - ( loopStart ) ) % len ( visitedLoop ) <NEWLINE> <COMMENT> <NL> townIndex = visitedLoop [ index ] <NEWLINE> <NL> <DEDENT> print ( townIndex + 1 ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> x , y = [ a , b ] if a > b else [ b , a ] <NEWLINE> while y : <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def solve ( a , b ) : <NEWLINE> <INDENT> if b == 1 : <NEWLINE> <INDENT> return 0 , 1 <NEWLINE> <DEDENT> elif a == 1 : <NEWLINE> <INDENT> return 1 , 0 <NEWLINE> <NL> <DEDENT> A , B , Q , R = [ a ] , [ b ] , [ b // a ] , [ b % a ] <NEWLINE> i = 0 <NEWLINE> while R [ i ] != 0 : <NEWLINE> <INDENT> B . append ( A [ i ] ) <NEWLINE> A . append ( R [ i ] ) <NEWLINE> Q . append ( B [ i + 1 ] // A [ i + 1 ] ) <NEWLINE> R . append ( B [ i + 1 ] % A [ i + 1 ] ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> x , y = - 1 * Q [ len ( Q ) - 2 ] , 1 <NEWLINE> for i in range ( len ( A ) - 3 , - 1 , - 1 ) : <NEWLINE> <INDENT> x , y = y - x * Q [ i ] , x <NEWLINE> <NL> <DEDENT> return x , y <NEWLINE> <NL> <DEDENT> a , b = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> c = gcd ( a , b ) <NEWLINE> a , b = a // c , b // c <NEWLINE> <NL> x , y = solve ( a , b ) <NEWLINE> print ( x , y ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for d in range ( N ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> L = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> t , I = 0 , [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> I . append ( t ) <NEWLINE> <DEDENT> for l in L : <NEWLINE> <INDENT> print ( I [ l [ 1 ] - 1 ] - I [ l [ 0 ] - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = l [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a *= l [ i ] <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if a > 10 ** 18 and l . count ( 0 ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif l . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> data = [ 0 ] * 100001 <NEWLINE> <NL> def my_sum ( d ) : <NEWLINE> <INDENT> retval = 0 <NEWLINE> <NL> for i in range ( len ( d ) ) : <NEWLINE> <INDENT> if d [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> retval += d [ i ] * i <NEWLINE> <DEDENT> return retval <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <INDENT> data [ i ] += 1 <NEWLINE> <NL> <DEDENT> sum_val = my_sum ( data ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> sum_val = sum_val - ( data [ B ] * B ) + ( data [ B ] * C ) <NEWLINE> <NL> data [ C ] += data [ B ] <NEWLINE> data [ B ] = 0 <NEWLINE> <NL> print ( sum_val ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> r = [ ] <NEWLINE> for i , j in enumerate ( A ) : <NEWLINE> <INDENT> l . append ( i + j ) <NEWLINE> r . append ( i - j ) <NEWLINE> <NL> <DEDENT> num_l = Counter ( l ) <NEWLINE> num_r = Counter ( r ) <NEWLINE> <NL> ans = 0 <NEWLINE> for k , v in num_l . items ( ) : <NEWLINE> <INDENT> ans += num_r [ k ] * v <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from heapq import heappop , heappush <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> heappush ( B , - A [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> a = heappop ( B ) <NEWLINE> a /= 2 <NEWLINE> heappush ( B , a ) <NEWLINE> <NL> <DEDENT> print ( sum ( [ int ( - B [ i ] ) for i in range ( N ) ] ) ) <NEWLINE>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> flag = False <NEWLINE> <NL> l = [ ] <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> for k in range ( K + 1 ) : <NEWLINE> <INDENT> if i + j + k == K : <NEWLINE> <INDENT> m = [ i , j , k ] <NEWLINE> l . append ( m ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> m = l [ i ] <NEWLINE> a = A * ( 2 ** m [ 0 ] ) <NEWLINE> b = B * ( 2 ** m [ 1 ] ) <NEWLINE> c = C * ( 2 ** m [ 2 ] ) <NEWLINE> <NL> if a < b and b < c : <NEWLINE> <INDENT> flag = False <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> if A <= K : <NEWLINE> <INDENT> K -= A <NEWLINE> ans = A <NEWLINE> if B <= K : <NEWLINE> <INDENT> K -= B <NEWLINE> if C <= K : <NEWLINE> <INDENT> ans -= C <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans -= K <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> B = K - B <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = K <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def S ( ) : <NEWLINE> <INDENT> return input ( ) . rstrip ( ) <NEWLINE> <NL> <NL> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def MI ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> n = I ( ) <NEWLINE> a = list ( MI ( ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> c -= 1 <NEWLINE> d -= 1 <NEWLINE> maze = [ input ( ) for _ in range ( h ) ] <NEWLINE> dx = [ 1 , - 1 , 0 , 0 ] <NEWLINE> dy = [ 0 , 0 , 1 , - 1 ] <NEWLINE> depth = [ [ float ( <STRING> ) for _ in range ( w ) ] for _ in range ( h ) ] <NEWLINE> dq = deque ( [ ( b , a ) ] ) <NEWLINE> depth [ a ] [ b ] = 0 <NEWLINE> while dq : <NEWLINE> <INDENT> x , y = dq . popleft ( ) <NEWLINE> if x == d and y == c : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> nx , ny , K = x , y , k <NEWLINE> while K : <NEWLINE> <INDENT> K -= 1 <NEWLINE> nx += dx [ i ] <NEWLINE> ny += dy [ i ] <NEWLINE> if 0 <= nx <= w - 1 and 0 <= ny <= h - 1 and maze [ ny ] [ nx ] != <STRING> and depth [ ny ] [ nx ] > depth [ y ] [ x ] : <NEWLINE> <INDENT> if depth [ ny ] [ nx ] == depth [ y ] [ x ] + 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> depth [ ny ] [ nx ] = depth [ y ] [ x ] + 1 <NEWLINE> dq . append ( ( nx , ny ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( depth [ c ] [ d ] if depth [ c ] [ d ] != float ( <STRING> ) else - 1 ) <NEWLINE>
s = input ( ) <NEWLINE> r = set ( map ( chr , range ( 97 , 97 + 26 ) ) ) <NEWLINE> r = r - set ( s ) <NEWLINE> if len ( r ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = min ( r ) <NEWLINE> print ( r ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> ans = 0 <NEWLINE> arr = [ 0 ] * ( n + 1 ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> arr [ i ] = ( arr [ i + 1 ] + int ( s [ i ] ) * pow ( 10 , n - i - 1 , 2019 ) ) % 2019 <NEWLINE> <DEDENT> m = Counter ( arr ) <NEWLINE> for j in m . keys ( ) : <NEWLINE> <INDENT> ans += m [ j ] * ( m [ j ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
d = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> s = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s += a [ i ] <NEWLINE> s %= d <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> b = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b += a [ i ] ** 2 <NEWLINE> b %= d <NEWLINE> <NL> <DEDENT> ans = s ** 2 - b <NEWLINE> ans %= d <NEWLINE> <NL> if ans % 2 == 0 : <NEWLINE> <INDENT> ans //= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += d <NEWLINE> ans //= 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = list ( map ( int , input ( ) ) ) <NEWLINE> l = [ sum ( n ) ] <NEWLINE> for i in range ( 1 , len ( n ) ) : <NEWLINE> <INDENT> n [ - i ] = 9 <NEWLINE> n [ - i - 1 ] -= 1 <NEWLINE> l . append ( sum ( n ) ) <NEWLINE> <DEDENT> print ( max ( l ) ) <NEWLINE>
class Mint : <NEWLINE> <NL> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def __init__ ( self , x = 0 ) : <NEWLINE> <INDENT> self . x = ( x % self . MOD + self . MOD ) % self . MOD <NEWLINE> <NL> <DEDENT> def __iadd__ ( self , other ) : <NEWLINE> <INDENT> self . x += other . x <NEWLINE> if self . x >= self . MOD : <NEWLINE> <INDENT> self . x -= self . MOD <NEWLINE> <DEDENT> return self <NEWLINE> <NL> <DEDENT> def __isub__ ( self , other ) : <NEWLINE> <INDENT> self . x += self . MOD - other . x <NEWLINE> if ( self . x >= self . MOD ) : <NEWLINE> <INDENT> self . x -= self . MOD <NEWLINE> <DEDENT> return self <NEWLINE> <NL> <DEDENT> def __imul__ ( self , other ) : <NEWLINE> <INDENT> self . x *= other . x <NEWLINE> self . x %= self . MOD ; <NEWLINE> return self ; <NEWLINE> <NL> <DEDENT> def __add__ ( self , other ) : <NEWLINE> <INDENT> ans = Mint ( self . x ) <NEWLINE> ans += other <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> def __sub__ ( self , other ) : <NEWLINE> <INDENT> ans = Mint ( self . x ) <NEWLINE> ans -= other <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> def __mul__ ( self , other ) : <NEWLINE> <INDENT> ans = Mint ( self . x ) <NEWLINE> ans *= other <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> def __pow__ ( self , n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return Mint ( 1 ) <NEWLINE> <DEDENT> a = self . __pow__ ( n >> 1 ) <NEWLINE> a *= a <NEWLINE> if n & 1 : <NEWLINE> <INDENT> a *= self <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def inv ( self ) : <NEWLINE> <INDENT> return self ** ( self . MOD - 2 ) <NEWLINE> <NL> <DEDENT> def __ifloordiv__ ( self , other ) : <NEWLINE> <INDENT> self *= other . inv ( ) <NEWLINE> return self <NEWLINE> <NL> <DEDENT> def __floordiv__ ( self , other ) : <NEWLINE> <INDENT> ans = Mint ( self . x ) <NEWLINE> ans //= other <NEWLINE> return ans <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def Main ( N , K ) : <NEWLINE> <INDENT> ans = Mint ( 0 ) <NEWLINE> for i in range ( K , N + 2 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans += Mint ( i ) * Mint ( N - i + 1 ) + Mint ( 1 ) <NEWLINE> <DEDENT> return ans . x <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( Main ( N , K ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> ret = 0 <NEWLINE> S = [ A [ 0 ] ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> S . append ( S [ i - 1 ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ret += A [ i ] * ( S [ - 1 ] - S [ i ] ) <NEWLINE> ret = ret % MOD <NEWLINE> <DEDENT> print ( ret ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> from bisect import bisect_left <NEWLINE> import sys <NEWLINE> n , * s = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> t = sorted ( s ) <NEWLINE> for ss in s : <NEWLINE> <INDENT> x = bisect_left ( t , ss ) <NEWLINE> if x == n - 1 : <NEWLINE> <INDENT> print ( t [ - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t [ - 1 ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N , M , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> max = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> t = K - a [ i ] <NEWLINE> if t < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > t : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> if i + j > max : <NEWLINE> <INDENT> max = i + j <NEWLINE> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> bi , ci = map ( int , input ( ) . split ( ) ) <NEWLINE> b . append ( bi ) <NEWLINE> c . append ( ci ) <NEWLINE> <NL> <DEDENT> count = collections . Counter ( a ) <NEWLINE> sums = sum ( a ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> sums += count [ b [ i ] ] * ( c [ i ] - b [ i ] ) <NEWLINE> print ( sums ) <NEWLINE> count [ c [ i ] ] += count [ b [ i ] ] <NEWLINE> count [ b [ i ] ] = 0 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a == b : <NEWLINE> <INDENT> if a % n == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif a % n == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while a < b : <NEWLINE> <INDENT> a += 1 <NEWLINE> if a % n == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> abn = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = min ( abn [ 1 ] - 1 , abn [ 2 ] ) <NEWLINE> m = math . floor ( abn [ 0 ] * x / abn [ 1 ] ) - abn [ 0 ] * math . floor ( x / abn [ 1 ] ) <NEWLINE> print ( m ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = list ( sorted ( input ( ) ) for _ in range ( n ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> for li in s : <NEWLINE> <INDENT> st = <STRING> <NEWLINE> for x in li : <NEWLINE> <INDENT> st += x <NEWLINE> <DEDENT> l . append ( st ) <NEWLINE> <NL> <DEDENT> c = collections . Counter ( l ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in c . values ( ) : <NEWLINE> <INDENT> ans += x * ( x - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import functools <NEWLINE> import operator <NEWLINE> <NL> def nCr ( n , r ) : <NEWLINE> <INDENT> if n < r : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> if r == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> num = functools . reduce ( operator . mul , range ( n , n - r , - 1 ) ) <NEWLINE> den = functools . reduce ( operator . mul , range ( 1 , r + 1 ) ) <NEWLINE> return num // den % mod <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> print ( nCr ( k - 1 , i - 1 ) * nCr ( n - k + 1 , i ) % mod ) <NEWLINE> <DEDENT>
<NL> url = <STRING> <NEWLINE> import itertools <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> route = [ ] <NEWLINE> istuka = [ 0 ] * ( n + 1 ) <NEWLINE> next = 1 <NEWLINE> <COMMENT> <NL> for _ in range ( k ) : <NEWLINE> <INDENT> if istuka [ next ] == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> istuka [ next ] = 1 <NEWLINE> route . append ( next ) <NEWLINE> <DEDENT> next = a [ next - 1 ] <NEWLINE> <DEDENT> if n >= k : <NEWLINE> <INDENT> print ( next ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = route [ route . index ( next ) : ] <NEWLINE> idx = ( k - route . index ( next ) ) % len ( ans ) <NEWLINE> print ( ans [ idx ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> n = a <NEWLINE> i = 2 <NEWLINE> fc = [ ] <NEWLINE> while i * i <= a : <NEWLINE> <INDENT> while a % i == 0 : <NEWLINE> <INDENT> a //= i <NEWLINE> fc . append ( i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if a > 1 : <NEWLINE> <INDENT> fc . append ( a ) <NEWLINE> <DEDENT> print ( str ( n ) + <STRING> + <STRING> . join ( str ( b ) for b in fc ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mx = max ( a ) <NEWLINE> <NL> c = Counter ( a ) <NEWLINE> nu = { k for k , v in c . items ( ) if v > 1 } <NEWLINE> <NL> s = set ( ) <NEWLINE> u = set ( ) <NEWLINE> for aa in a : <NEWLINE> <INDENT> m = 2 <NEWLINE> if aa in s or aa in u : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> u . add ( aa ) <NEWLINE> while aa * m <= mx : <NEWLINE> <INDENT> s . add ( aa * m ) <NEWLINE> m += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> o = 0 <NEWLINE> for aa in a : <NEWLINE> <INDENT> if aa in s or aa in nu : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> o += 1 <NEWLINE> <NL> <DEDENT> print ( o ) <NEWLINE>
from itertools import groupby , accumulate <NEWLINE> <NL> <NL> def solve ( t ) : <NEWLINE> <INDENT> if t [ 0 ] == <STRING> : <NEWLINE> <INDENT> preceding_zeros = len ( t ) <NEWLINE> t = t . lstrip ( <STRING> ) <NEWLINE> preceding_zeros -= len ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> preceding_zeros = 0 <NEWLINE> <NL> <DEDENT> if len ( t ) == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> grp = [ ( c , len ( list ( itr ) ) ) for c , itr in groupby ( t ) ] <NEWLINE> even_ones = 0 <NEWLINE> zeros_splitting_odd_ones = [ preceding_zeros ] <NEWLINE> for c , cnt in grp : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> if cnt % 2 == 0 : <NEWLINE> <INDENT> even_ones += cnt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> even_ones += cnt - 1 <NEWLINE> zeros_splitting_odd_ones . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> zeros_splitting_odd_ones [ - 1 ] += cnt <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ad = int ( zeros_splitting_odd_ones [ 0 ] % 2 == 0 ) <NEWLINE> is_added_init = [ ad ] <NEWLINE> for cnt in zeros_splitting_odd_ones [ 1 : ] : <NEWLINE> <INDENT> ad ^= ( cnt % 2 ) ^ 1 <NEWLINE> is_added_init . append ( ad ) <NEWLINE> <DEDENT> is_added_init . pop ( ) <NEWLINE> acc_added_init = list ( accumulate ( reversed ( is_added_init ) ) ) <COMMENT> <NEWLINE> acc_added_init . reverse ( ) <NEWLINE> <NL> odd_ones = len ( is_added_init ) <NEWLINE> ans = 0 <NEWLINE> <NL> if odd_ones > 0 : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> zso = zeros_splitting_odd_ones [ 0 ] <NEWLINE> zso1 = zso // 2 <NEWLINE> zso0 = zso - zso1 <NEWLINE> ans += acc_added_init [ 0 ] * zso0 <NEWLINE> ans += ( odd_ones - acc_added_init [ 0 ] ) * zso1 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> ad = int ( zeros_splitting_odd_ones [ 0 ] % 2 == 0 ) <NEWLINE> for i in range ( 1 , odd_ones ) : <NEWLINE> <INDENT> zso = zeros_splitting_odd_ones [ i ] - 1 <NEWLINE> zso1 = zso // 2 <NEWLINE> zso0 = zso - zso1 <NEWLINE> fixed_ones = i <NEWLINE> right_ones = odd_ones - fixed_ones <NEWLINE> ans += fixed_ones * zso <NEWLINE> if ad : <NEWLINE> <COMMENT> <NL> <INDENT> ans += acc_added_init [ i ] * zso0 <NEWLINE> ans += ( right_ones - acc_added_init [ i ] ) * zso1 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ans += ( right_ones - acc_added_init [ i ] ) * zso0 <NEWLINE> ans += acc_added_init [ i ] * zso1 <NEWLINE> <DEDENT> ad ^= zso % 2 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> ans += zeros_splitting_odd_ones [ - 1 ] * odd_ones <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> for i in range ( 1 , odd_ones ) : <NEWLINE> <INDENT> left_ones = odd_ones - i <NEWLINE> right_ones = i <NEWLINE> ans += left_ones + ( right_ones + 1 ) // 2 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> all_ones = odd_ones + even_ones <NEWLINE> ao1 = all_ones // 2 <NEWLINE> ao0 = all_ones - ao1 <NEWLINE> ans += ( ao0 * ( ao0 + 1 ) + ao1 * ( ao1 + 1 ) ) // 2 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> all_zeros = len ( t ) - all_ones + preceding_zeros <NEWLINE> ans += all_zeros * ( even_ones // 2 ) <NEWLINE> <NL> return ans <NEWLINE> <NL> <NL> <DEDENT> t = input ( ) <NEWLINE> print ( solve ( t ) ) <NEWLINE>
( X , K , D ) = map ( int , input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> if X - K * D > 0 : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> print ( min ( abs ( X % ( 2 * D ) ) , abs ( X % ( 2 * D ) - 2 * D ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( abs ( ( X + D ) % ( 2 * D ) ) , abs ( ( X + D ) % ( 2 * D ) - 2 * D ) ) ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> if k >= a : <NEWLINE> <INDENT> k = k - a <COMMENT> <NEWLINE> cnt = cnt + 1 * a <COMMENT> <NEWLINE> <NL> if k >= b : <NEWLINE> <INDENT> k = k - b <COMMENT> <NEWLINE> <NL> if k >= c : <NEWLINE> <INDENT> cnt = cnt + - 1 * c <NEWLINE> k = k - c <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> cnt = cnt + - 1 * k <NEWLINE> k = k - k <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> k = k - k <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt = cnt + 1 * k <NEWLINE> k = k - k <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a . sort ( ) <NEWLINE> maxa = max ( a ) <NEWLINE> a_s = set ( a ) <NEWLINE> s = set ( ) <NEWLINE> s1 = set ( ) <NEWLINE> same_s = set ( ) <NEWLINE> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i in s1 : <NEWLINE> <INDENT> same_s . add ( i ) <NEWLINE> <DEDENT> if i not in s : <NEWLINE> <INDENT> s1 . add ( i ) <NEWLINE> for j in range ( i , maxa + 1 , i ) : <NEWLINE> <INDENT> s . add ( j ) <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans - len ( same_s ) ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] [ : : - 1 ] <NEWLINE> dp = [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> if bisect . bisect_right ( dp , i ) == len ( dp ) : <NEWLINE> <INDENT> dp . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ bisect . bisect_right ( dp , i ) ] = i <NEWLINE> <DEDENT> <DEDENT> print ( len ( dp ) ) <NEWLINE>
import math <NEWLINE> import numpy as np <NEWLINE> from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xyz_lim = int ( math . sqrt ( N - 2 ) ) - 1 <NEWLINE> <NL> def f ( x , y , z ) : <NEWLINE> <INDENT> return ( ( x + y ) ** 2 + ( y + z ) ** 2 + ( z + x ) ** 2 ) // 2 <NEWLINE> <NL> <DEDENT> cnt = Counter ( ) <NEWLINE> for _x in range ( xyz_lim ) : <NEWLINE> <INDENT> for _y in range ( xyz_lim ) : <NEWLINE> <INDENT> x , y = _x + 1 , _y + 1 <NEWLINE> cnt . update ( [ f ( x , y , _z + 1 ) for _z in range ( xyz_lim ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for _n in range ( N ) : <NEWLINE> <INDENT> n = _n + 1 <NEWLINE> print ( cnt [ n ] ) <NEWLINE> <DEDENT> <DEDENT>
from math import log10 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 1 <NEWLINE> threshold = 10 ** 18 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> s *= a <NEWLINE> if s > threshold : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
N = input ( ) <NEWLINE> Alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MultipliedNum = 1 <NEWLINE> index = 0 <NEWLINE> <NL> if min ( Alist ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> index = 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in Alist : <NEWLINE> <INDENT> MultipliedNum *= i <NEWLINE> <NL> if MultipliedNum > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> index = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if index == 0 : <NEWLINE> <INDENT> print ( MultipliedNum ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> S = input ( ) <NEWLINE> q = deque ( ) <NEWLINE> for s in list ( S ) : <NEWLINE> <INDENT> q . append ( s ) <NEWLINE> <DEDENT> Q = int ( input ( ) ) <NEWLINE> direction = True <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> if line [ 0 ] == <STRING> : <NEWLINE> <INDENT> direction = not direction <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( direction and line [ 2 ] == <STRING> ) or ( not direction and line [ 2 ] == <STRING> ) : <NEWLINE> <INDENT> q . appendleft ( line [ 4 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . append ( line [ 4 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( q ) if direction else <STRING> . join ( reversed ( q ) ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> for j in ans : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ls = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> d = [ 0 ] <NEWLINE> pre = 0 <NEWLINE> c = 0 <NEWLINE> <NL> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> d . append ( d [ i ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . append ( d [ i ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> for start , end in ls : <NEWLINE> <INDENT> print ( d [ end - 1 ] - d [ start - 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> N , T = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N0 = 2 ** ( N - 1 ) . bit_length ( ) <NEWLINE> data = [ 0 ] * ( 2 * N0 ) <NEWLINE> <NL> <COMMENT> <NL> def init ( A ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> data [ i + N0 - 1 ] = A [ i ] <NEWLINE> <DEDENT> for i in range ( N0 - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> data [ i ] = max ( data [ 2 * i + 1 ] , data [ 2 * i + 2 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def update ( k , x ) : <NEWLINE> <INDENT> k += N0 - 1 <NEWLINE> data [ k ] = x <NEWLINE> while k >= 0 : <NEWLINE> <INDENT> k = ( k - 1 ) // 2 <NEWLINE> data [ k ] = max ( data [ 2 * k + 1 ] , data [ 2 * k + 2 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def query ( l , r ) : <NEWLINE> <INDENT> L = l + N0 ; R = r + N0 <NEWLINE> s = 0 <NEWLINE> while L < R : <NEWLINE> <INDENT> if R & 1 : <NEWLINE> <INDENT> R -= 1 <NEWLINE> s = max ( s , data [ R - 1 ] ) <NEWLINE> <NL> <DEDENT> if L & 1 : <NEWLINE> <INDENT> s = max ( s , data [ L - 1 ] ) <NEWLINE> L += 1 <NEWLINE> <DEDENT> L >>= 1 ; R >>= 1 <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> init ( A ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> high = query ( i + 1 , N + 1 ) <NEWLINE> p = high - a <NEWLINE> d [ p ] += 1 <NEWLINE> <DEDENT> d = sorted ( d . items ( ) , reverse = True ) <NEWLINE> print ( d [ 0 ] [ 1 ] ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> def resolve_v1 ( N , S ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> for k in range ( N ) : <COMMENT> <NEWLINE> <INDENT> for j in range ( k ) : <COMMENT> <NEWLINE> <INDENT> for i in range ( 1 , j ) : <COMMENT> <NEWLINE> <INDENT> if S [ k ] != S [ j ] and S [ j ] != S [ i ] and S [ i ] != S [ k ] and not k - j == j - i : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> def resolve_v2 ( N , S ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if S [ i ] == S [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> if S [ i ] == S [ k ] or S [ j ] == S [ k ] or k - j == j - i : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> def resolve_v3 ( N , S ) : <NEWLINE> <INDENT> r , g , b = 0 , 0 , 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = r * g * b <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> <NL> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ i ] != S [ k ] : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> count = resolve_v3 ( N , S ) <NEWLINE> print ( count ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = 0 <NEWLINE> c = [ 0 ] * n + [ 0 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> c [ a [ i ] ] += 1 <NEWLINE> <DEDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( c [ j ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from math import gcd <NEWLINE> <NL> <NL> stdin = sys . stdin <NEWLINE> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def nm ( ) : return map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> def nl ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = ni ( ) <NEWLINE> A = nl ( ) <NEWLINE> c = A [ 0 ] <NEWLINE> b = [ ] <NEWLINE> <NL> cnt = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> c = gcd ( c , a ) <NEWLINE> cnt [ a ] += 1 <NEWLINE> <NL> <DEDENT> max_num = 0 <NEWLINE> for i in range ( 2 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> max_num = max ( max_num , sum ( cnt [ i : : i ] ) ) <NEWLINE> <NL> <DEDENT> if c == 1 and max_num <= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif c == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( math . pi * r * r , 2 * math . pi * r ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> sum = 0 ; <NEWLINE> <NL> nn = n // 2 ; <NEWLINE> nnn = n - nn <NEWLINE> if n <= 5000000 : <NEWLINE> <INDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = n // i ; <NEWLINE> sum += i * x * ( x + 1 ) // 2 ; <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , 5000000 + 1 ) : <NEWLINE> <INDENT> x = n // i ; <NEWLINE> sum += i * x * ( x + 1 ) // 2 ; <NEWLINE> <DEDENT> sum += ( n - 5000000 ) * ( 5000001 + n ) // 2 ; <NEWLINE> <DEDENT> print ( sum ) ; <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> print ( math . factorial ( n ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
import math <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> S = input ( ) [ : : - 1 ] <NEWLINE> ans = 0 <NEWLINE> <NL> mods = [ 0 ] * 2019 <COMMENT> <NEWLINE> mods [ 0 ] = 1 <NEWLINE> current = 0 <NEWLINE> tmp = 1 <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> current = ( int ( S [ i ] ) * tmp + current ) % 2019 <NEWLINE> mod = current % 2019 <NEWLINE> ans += mods [ mod ] <NEWLINE> mods [ mod ] += 1 <NEWLINE> tmp = tmp * 10 % 2019 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
from sys import stdin <NEWLINE> <NL> n = int ( stdin . readline ( ) ) <NEWLINE> q = [ ] <NEWLINE> bottom = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cmd = stdin . readline ( ) [ : - 1 ] <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> q . append ( cmd [ 7 : ] ) <NEWLINE> <DEDENT> elif cmd [ 6 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> q . pop ( ~ q [ : : - 1 ] . index ( cmd [ 7 : ] ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif cmd [ 6 ] == <STRING> : <NEWLINE> <INDENT> q . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bottom += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( q [ bottom : ] [ : : - 1 ] ) ) <NEWLINE>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> max = - 2 <NEWLINE> if n < b : <NEWLINE> <INDENT> max = math . floor ( a * n / b ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> max = math . floor ( a * ( b - 1 ) / b ) <NEWLINE> <NL> <NL> <DEDENT> print ( max ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mul = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> mul *= a <NEWLINE> if mul > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( mul ) <NEWLINE> <DEDENT>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ARR = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> ARR . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> def calculate ( h , w , m , arr ) : <NEWLINE> <INDENT> points = set ( ) <NEWLINE> <NL> <NL> <NL> rowSum = [ 0 for i in range ( h ) ] <NEWLINE> columnSum = [ 0 for i in range ( w ) ] <NEWLINE> <NL> for ar in arr : <NEWLINE> <INDENT> points . add ( ( ar [ 0 ] - 1 , ar [ 1 ] - 1 ) ) <NEWLINE> rowSum [ ar [ 0 ] - 1 ] += 1 <NEWLINE> columnSum [ ar [ 1 ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> maxRowSum = max ( rowSum ) <NEWLINE> maxColumnSum = max ( columnSum ) <NEWLINE> <NL> <NL> a0 = [ ] <NEWLINE> <NL> for i in range ( len ( rowSum ) ) : <NEWLINE> <INDENT> if rowSum [ i ] == maxRowSum : <NEWLINE> <INDENT> a0 . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> a1 = [ ] <NEWLINE> for i in range ( len ( columnSum ) ) : <NEWLINE> <INDENT> if columnSum [ i ] == maxColumnSum : <NEWLINE> <INDENT> a1 . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> result = 0 <NEWLINE> for hIndex in a0 : <NEWLINE> <INDENT> for wIndex in a1 : <NEWLINE> <NL> <INDENT> if ( hIndex , wIndex ) in points : <NEWLINE> <INDENT> result = max ( result , maxRowSum + maxColumnSum - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = max ( result , maxRowSum + maxColumnSum ) <NEWLINE> print ( result ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> calculate ( H , W , M , ARR ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> r = [ i + 1 - j for i , j in enumerate ( a ) ] <NEWLINE> l = [ j + i + 1 for i , j in enumerate ( a ) ] <NEWLINE> nl = Counter ( l ) <NEWLINE> nr = Counter ( r ) <NEWLINE> <NL> ans = 0 <NEWLINE> for k , v in nl . items ( ) : <NEWLINE> <INDENT> ans += nr [ k ] * v <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
1 <NEWLINE> 2 <NEWLINE> 3 <NEWLINE> 4 <NEWLINE> 5 <NEWLINE> 6 <NEWLINE> 7 <NEWLINE> 8 <NEWLINE> 9 <NEWLINE> 10 <NEWLINE> 11 <NEWLINE> 12 <NEWLINE> 13 <NEWLINE> 14 <NEWLINE> 15 <NEWLINE> 16 <NEWLINE> 17 <NEWLINE> 18 <NEWLINE> 19 <NEWLINE> 20 <NEWLINE> 21 <NEWLINE> 22 <NEWLINE> 23 <NEWLINE> 24 <NEWLINE> 25 <NEWLINE> 26 <NEWLINE> 27 <NEWLINE> 28 <NEWLINE> 29 <NEWLINE> 30 <NEWLINE> 31 <NEWLINE> 32 <NEWLINE> 33 <NEWLINE> 34 <NEWLINE> 35 <NEWLINE> 36 <NEWLINE> 37 <NEWLINE> 38 <NEWLINE> 39 <NEWLINE> 40 <NEWLINE> 41 <NEWLINE> 42 <NEWLINE> 43 <NEWLINE> 44 <NEWLINE> 45 <NEWLINE> 46 <NEWLINE> 47 <NEWLINE> 48 <NEWLINE> 49 <NEWLINE> 50 <NEWLINE> 51 <NEWLINE> 52 <NEWLINE> 53 <NEWLINE> 54 <NEWLINE> 55 <NEWLINE> 56 <NEWLINE> 57 <NEWLINE> 58 <NEWLINE> 59 <NEWLINE> 60 <NEWLINE> 61 <NEWLINE> 62 <NEWLINE> 63 <NEWLINE> 64 <NEWLINE> 65 <NEWLINE> 66 <NEWLINE> 67 <NEWLINE> 68 <NEWLINE> import sys <NEWLINE> <NL> def extractMax ( A ) : <NEWLINE> <INDENT> x = A [ 0 ] <NEWLINE> A [ 0 ] = A [ - 1 ] <NEWLINE> A . pop ( ) <NEWLINE> H = len ( A ) <NEWLINE> i = 0 <NEWLINE> while i < H : <COMMENT> <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> rv = 0 <NEWLINE> lv = 0 <NEWLINE> r = ( i + 1 ) * 2 <NEWLINE> l = r - 1 <NEWLINE> if l < H : <NEWLINE> <INDENT> lv = A [ l ] <NEWLINE> if r < H : <NEWLINE> <INDENT> rv = A [ r ] <NEWLINE> <NL> <DEDENT> <DEDENT> if v < lv and lv > rv : <NEWLINE> <INDENT> A [ l ] = v <NEWLINE> A [ i ] = lv <NEWLINE> i = l <NEWLINE> <DEDENT> elif v < rv : <NEWLINE> <INDENT> A [ r ] = v <NEWLINE> A [ i ] = rv <NEWLINE> i = r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def insert ( A , n ) : <NEWLINE> <INDENT> i = len ( A ) <NEWLINE> A . append ( n ) <NEWLINE> while i > 0 : <COMMENT> <NEWLINE> <INDENT> p = int ( ( i + 1 ) / 2 ) - 1 <NEWLINE> v = A [ i ] <NEWLINE> pv = A [ p ] <NEWLINE> if pv < v : <COMMENT> <NEWLINE> <INDENT> A [ p ] = v <NEWLINE> A [ i ] = pv <NEWLINE> i = p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> istr = sys . stdin . read ( ) <NEWLINE> cmds = list ( istr . splitlines ( ) ) <NEWLINE> <NL> end = False <NEWLINE> S = [ ] <NEWLINE> for cmd in cmds : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> insert ( S , int ( cmd [ 7 : ] ) ) <NEWLINE> <NL> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> a = extractMax ( S ) <NEWLINE> print ( a ) <NEWLINE> <NL> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> end = True <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sumA = sum ( A ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x = A [ i ] <NEWLINE> sumA -= x <NEWLINE> ans += sumA * x <NEWLINE> <DEDENT> print ( ans % ( ( 10 ** 9 ) + 7 ) ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> while i <= x : <NEWLINE> <INDENT> if ( x - i ) in p and ( x + i ) in p : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> elif ( x - i ) in p : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( x + i ) in p : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> if str ( i ) in s [ : - 2 ] : <NEWLINE> <INDENT> s1 = s . index ( str ( i ) ) <NEWLINE> <NL> for j in range ( 10 ) : <NEWLINE> <INDENT> if str ( j ) in s [ s1 + 1 : - 1 ] : <NEWLINE> <INDENT> s2 = s [ s1 + 1 : ] . index ( str ( j ) ) + s1 + 1 <NEWLINE> <NL> for k in range ( 10 ) : <NEWLINE> <INDENT> if str ( k ) in s [ s2 + 1 : ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if ( 0 in a ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for num in a : <NEWLINE> <INDENT> ans *= num <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if b != 0 : <NEWLINE> <INDENT> return ( gcd ( b , a % b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> s = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> m = gcd ( i , j ) <NEWLINE> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if i == j and j == k : <NEWLINE> <INDENT> s = s + gcd ( m , k ) <NEWLINE> <DEDENT> elif i == j and j != k : <NEWLINE> <INDENT> s = s + gcd ( m , k ) * 3 <NEWLINE> <DEDENT> elif i != j and j == k : <NEWLINE> <INDENT> s = s + gcd ( m , k ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s + gcd ( m , k ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> list = [ ] <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> list . append ( s ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> print ( len ( set ( list ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> A = sorted ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> _ = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( _ ) <NEWLINE> <DEDENT> a = sorted ( a , key = lambda x : x [ 2 ] , reverse = True ) <NEWLINE> <NL> check = False <NEWLINE> <NL> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> b = 0 <NEWLINE> while b < n : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> h = abs ( i - a [ b ] [ 0 ] ) + abs ( j - a [ b ] [ 1 ] ) + a [ b ] [ 2 ] <NEWLINE> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> de = max ( h - abs ( i - a [ b ] [ 0 ] ) - abs ( j - a [ b ] [ 1 ] ) , 0 ) <NEWLINE> if de == a [ b ] [ 2 ] : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if b == n : <NEWLINE> <INDENT> ans = str ( i ) + <STRING> + str ( j ) + <STRING> + str ( h ) <NEWLINE> check = True <NEWLINE> <DEDENT> if check : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if check : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> l_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s_a = list ( set ( l_a ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> dub_a = [ 0 ] * ( max ( s_a ) + 1 ) <NEWLINE> <NL> for i in l_a : <NEWLINE> <INDENT> dub_a [ i ] += 1 <NEWLINE> <NL> <DEDENT> dp = [ 1 ] * ( max ( s_a ) + 1 ) <NEWLINE> <NL> for i in s_a : <NEWLINE> <INDENT> for j in range ( 2 * i , len ( dp ) , i ) : <NEWLINE> <INDENT> dp [ j ] = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in s_a : <NEWLINE> <INDENT> if dp [ i ] == 1 and dub_a [ i ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 11 <NEWLINE> for a in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % a != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> b = n // a <NEWLINE> ans = min ( ans , max ( len ( str ( a ) ) , len ( str ( b ) ) ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ 0 ] * ( n ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> cnt [ lis [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> S = deque ( input ( ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> re = True <NEWLINE> cnt = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> q = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> if q [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if re == True : <NEWLINE> <INDENT> re = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re = True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if re == True : <NEWLINE> <INDENT> if q [ 1 ] == <STRING> : <NEWLINE> <INDENT> S . appendleft ( q [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . append ( q [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if q [ 1 ] == <STRING> : <NEWLINE> <INDENT> S . appendleft ( q [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . append ( q [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if cnt % 2 == 1 : <NEWLINE> <INDENT> S . reverse ( ) <NEWLINE> <DEDENT> print ( * S , sep = <STRING> ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> dp = [ [ h * w ] * w for _ in range ( h ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 0 if s [ 0 ] [ 0 ] == <STRING> else 1 <NEWLINE> <NL> for x0 in range ( w ) : <NEWLINE> <INDENT> for y0 in range ( h ) : <NEWLINE> <INDENT> for i , j in [ ( 0 , 1 ) , ( 1 , 0 ) ] : <NEWLINE> <INDENT> x = x0 + i <NEWLINE> y = y0 + j <NEWLINE> if x < w and y < h : <NEWLINE> <INDENT> n = 1 if s [ y0 ] [ x0 ] == <STRING> and s [ y ] [ x ] == <STRING> else 0 <NEWLINE> dp [ y ] [ x ] = min ( dp [ y0 ] [ x0 ] + n , dp [ y ] [ x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] [ - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = 2 <NEWLINE> ans = 0 <NEWLINE> <NL> while a < n / 2 : <NEWLINE> <INDENT> b = 2 <NEWLINE> while a * b < n : <NEWLINE> <INDENT> ans += 1 <NEWLINE> b += 1 <NEWLINE> <DEDENT> a += 1 <NEWLINE> <NL> <DEDENT> print ( ans + 2 * ( n - 2 ) + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> reb_a = a [ : : - 1 ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> res = reb_a [ : : 2 ] + a [ : : 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = reb_a [ : : 2 ] + a [ 1 : : 2 ] <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( res ) ) <NEWLINE>
N , C = map ( int , input ( ) . split ( ) ) <NEWLINE> events = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> events . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> L = 250 <NEWLINE> dp = [ [ - 10 ** 18 ] * ( L + 1 ) for i in range ( C + 1 ) ] <NEWLINE> for j in range ( C + 1 ) : <NEWLINE> <INDENT> dp [ j ] [ 0 ] = 0 <NEWLINE> <DEDENT> for a , b , c in events : <NEWLINE> <INDENT> for j in range ( C - c , - 1 , - 1 ) : <NEWLINE> <INDENT> for k in range ( L + 1 ) : <NEWLINE> <INDENT> if k + ( b - a ) <= 0 : <NEWLINE> <INDENT> dp [ j + c ] [ a - k - b ] = max ( dp [ j + c ] [ a - k - b ] , dp [ j ] [ k ] + k + b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ j + c ] [ k + b - a ] = max ( dp [ j + c ] [ k + b - a ] , dp [ j ] [ k ] + a ) <NEWLINE> <DEDENT> if k + ( a - b ) <= L : <NEWLINE> <INDENT> dp [ j + c ] [ k + a - b ] = max ( dp [ j + c ] [ k + a - b ] , dp [ j ] [ k ] + b ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for j in range ( C + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , max ( dp [ j ] ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> print ( solve ( ) ) <NEWLINE>
from collections import * <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> b = deque ( ) <NEWLINE> <NL> b . append ( a [ 0 ] ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if ( i % 2 == 1 ) : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . appendleft ( a [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if ( n % 2 == 0 ) : <NEWLINE> <INDENT> b . reverse ( ) <NEWLINE> <NL> <NL> <DEDENT> print ( <STRING> . join ( map ( str , b ) ) ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> q = int ( input ( ) ) <NEWLINE> M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> memo = [ [ None for i in range ( 2000 ) ] for j in range ( n + 1 ) ] <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if memo [ i ] [ m ] is not None : <NEWLINE> <INDENT> return memo [ i ] [ m ] <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif i >= n : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <INDENT> res0 = solve ( i + 1 , m ) <NEWLINE> <COMMENT> <NL> res1 = solve ( i + 1 , m - A [ i ] ) <NEWLINE> <NL> if res0 or res1 : <NEWLINE> <INDENT> memo [ i ] [ m ] = True <NEWLINE> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memo [ i ] [ m ] = False <NEWLINE> return False <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for m in M : <NEWLINE> <INDENT> result = solve ( 0 , m ) <NEWLINE> if result : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans , a = 0 , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] not in a : <NEWLINE> <INDENT> a += [ s [ i ] ] <NEWLINE> b = [ ] <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if s [ j ] not in b : <NEWLINE> <INDENT> b += [ s [ j ] ] <NEWLINE> c = [ ] <NEWLINE> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> if s [ k ] not in c : <NEWLINE> <INDENT> c += [ s [ k ] ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = 0 <NEWLINE> w = input ( ) . lower ( ) <NEWLINE> while True : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> l = line . lower ( ) . split ( ) <NEWLINE> n += l . count ( w ) <NEWLINE> <DEDENT> print ( n ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> d = { } <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> d [ i ] = d . get ( i , 0 ) + 1 <NEWLINE> <NL> <DEDENT> d = sorted ( d . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> maxv = d [ 0 ] [ 1 ] <NEWLINE> ans = [ ] <NEWLINE> for s in d : <NEWLINE> <INDENT> if s [ 1 ] == maxv : <NEWLINE> <INDENT> ans . append ( s [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for p in sorted ( ans ) : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> tmp = 0 <NEWLINE> max = 0 <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> d = [ ] <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( A ) <NEWLINE> b . append ( B ) <NEWLINE> c . append ( C ) <NEWLINE> d . append ( D ) <NEWLINE> <NL> <DEDENT> nums = range ( 1 , m + 1 ) <NEWLINE> <NL> for retsu in itertools . combinations_with_replacement ( nums , n ) : <NEWLINE> <INDENT> for i in range ( q ) : <NEWLINE> <INDENT> if int ( retsu [ b [ i ] - 1 ] ) - int ( retsu [ a [ i ] - 1 ] ) == c [ i ] : <NEWLINE> <INDENT> tmp = tmp + d [ i ] <NEWLINE> <DEDENT> if max < tmp : <NEWLINE> <INDENT> max = tmp <NEWLINE> <DEDENT> <DEDENT> tmp = 0 <NEWLINE> <NL> <DEDENT> print ( max ) <NEWLINE>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> def divisor ( n ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> table = [ ] <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> table . append ( i ) <NEWLINE> table . append ( n // i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> table = list ( set ( table ) ) <NEWLINE> return table <NEWLINE> <NL> <DEDENT> n , m = MAP ( ) <NEWLINE> a = sorted ( divisor ( m ) ) <NEWLINE> print ( m // a [ bisect_left ( a , n ) ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = { } <NEWLINE> t = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if not i in d . keys ( ) : <NEWLINE> <INDENT> d [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <DEDENT> t += int ( i ) <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( str , input ( ) . split ( ) ) <NEWLINE> diff = 0 <NEWLINE> if b in d . keys ( ) and c in d . keys ( ) : <NEWLINE> <INDENT> diff = ( int ( c ) - int ( b ) ) * d [ b ] <NEWLINE> d [ c ] += d [ b ] <NEWLINE> d . pop ( b ) <NEWLINE> <DEDENT> elif b in d . keys ( ) : <NEWLINE> <INDENT> diff = int ( c ) * d [ b ] - int ( b ) * d [ b ] <NEWLINE> d [ c ] = d [ b ] <NEWLINE> d . pop ( b ) <NEWLINE> <DEDENT> t += diff <NEWLINE> print ( t ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> E_list = [ [ ] for i in range ( N ) ] <NEWLINE> <NL> marks = [ False for i in range ( N ) ] <NEWLINE> m = 1 <NEWLINE> def dfs ( n ) : <NEWLINE> <INDENT> global E_list <NEWLINE> global marks <NEWLINE> global N , M <NEWLINE> <NL> marks [ n ] = True <NEWLINE> <NL> steps = 1 <NEWLINE> <NL> for nx in E_list [ n ] : <NEWLINE> <INDENT> if not marks [ nx ] : <NEWLINE> <INDENT> marks [ nx ] = True <NEWLINE> steps += dfs ( nx ) <NEWLINE> <NL> <DEDENT> <DEDENT> return steps <NEWLINE> <NL> <NL> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> e1 , e2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> E_list [ e1 - 1 ] . append ( e2 - 1 ) <NEWLINE> E_list [ e2 - 1 ] . append ( e1 - 1 ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> E_list [ i ] = list ( set ( E_list [ i ] ) ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if not marks [ i ] : <NEWLINE> <INDENT> st = dfs ( i ) <NEWLINE> <NL> <DEDENT> m = max ( m , st ) <NEWLINE> <NL> <DEDENT> print ( m ) <NEWLINE>
def aaa ( a_list ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in a_list : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> N = input ( ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> a = [ int ( i ) for i in a ] <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( aaa ( a ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> X = int ( input ( ) ) <NEWLINE> for a in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for b in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> from math import gcd <NEWLINE> N = int ( input ( ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> L = defaultdict ( lambda : [ 0 , 0 ] ) <NEWLINE> zero = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A == 0 : d = B <NEWLINE> elif B == 0 : d = A <NEWLINE> else : d = gcd ( A , B ) <NEWLINE> if d != 0 : <NEWLINE> <INDENT> A , B = A // d , B // d <NEWLINE> if A < 0 : A , B = - A , - B <NEWLINE> if B > 0 : L [ ( A , B ) ] [ 0 ] += 1 <NEWLINE> else : L [ ( - B , A ) ] [ 1 ] += 1 <NEWLINE> <DEDENT> else : zero += 1 <NEWLINE> <NL> <DEDENT> res = 1 <NEWLINE> <NL> for x , y in L . values ( ) : <NEWLINE> <INDENT> res *= pow ( 2 , x , MOD ) + pow ( 2 , y , MOD ) - 1 <NEWLINE> res %= MOD <NEWLINE> <DEDENT> print ( ( res + zero - 1 ) % MOD ) <NEWLINE> <NL>
from collections import defaultdict <NEWLINE> import sys <NEWLINE> <NL> h , w , m = map ( lambda x : int ( x ) , input ( ) . split ( ) ) <NEWLINE> <NL> y_to_num = [ 0 ] * h <NEWLINE> x_to_num = [ 0 ] * w <NEWLINE> existing_h_to_w = defaultdict ( set ) <NEWLINE> <NL> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> hh , ww = map ( lambda x : int ( x ) , input ( ) . split ( ) ) <NEWLINE> y_to_num [ hh - 1 ] += 1 <NEWLINE> x_to_num [ ww - 1 ] += 1 <NEWLINE> existing_h_to_w [ hh - 1 ] . add ( ww - 1 ) <NEWLINE> <NL> <DEDENT> max_vertical_num = max ( y_to_num ) <NEWLINE> max_horizontal_num = max ( x_to_num ) <NEWLINE> <NL> y_coor_with_max_num = [ i for i , num in enumerate ( y_to_num ) if num == max_vertical_num ] <NEWLINE> x_coor_with_max_num = [ i for i , num in enumerate ( x_to_num ) if num == max_horizontal_num ] <NEWLINE> <NL> <COMMENT> <NL> <NL> for y in y_coor_with_max_num : <NEWLINE> <INDENT> for x in x_coor_with_max_num : <NEWLINE> <INDENT> if x not in existing_h_to_w [ y ] : <NEWLINE> <INDENT> print ( max_vertical_num + max_horizontal_num ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max_vertical_num + max_horizontal_num - 1 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from sys import stdin <NEWLINE> n , k = map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> As = [ 0 ] + As <NEWLINE> g = set ( { 1 } ) <NEWLINE> l = [ 0 , 1 ] <NEWLINE> now = 1 <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> i += 1 <NEWLINE> now = As [ now ] <NEWLINE> if now in g : <NEWLINE> <INDENT> j = l . index ( now ) <NEWLINE> print ( l [ j + ( k - i ) % ( i + 1 - j ) ] ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> g . add ( now ) <NEWLINE> l . append ( now ) <NEWLINE> <NL> <DEDENT> if i == k : <NEWLINE> <INDENT> print ( now ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = input ( ) <NEWLINE> list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> flg = True <NEWLINE> if 0 in list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> flg = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prod = 1 <NEWLINE> for a in list : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( prod ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ls = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> dp = [ 0 ] * ( ls [ - 1 ] + 1 ) <NEWLINE> for i in ls : <NEWLINE> <INDENT> dp [ i ] += 1 <NEWLINE> if dp [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( i * 2 , ls [ - 1 ] + 1 , i ) : <NEWLINE> <INDENT> dp [ j ] += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp . count ( 1 ) ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <INDENT> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lsh = [ 0 ] * h <NEWLINE> lsw = [ 0 ] * w <NEWLINE> <NL> bom = set ( ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> m1 , m2 = map ( int , input ( ) . split ( ) ) <NEWLINE> lsh [ m1 - 1 ] += 1 <NEWLINE> lsw [ m2 - 1 ] += 1 <NEWLINE> bom . add ( ( m1 - 1 , m2 - 1 ) ) <NEWLINE> <NL> <DEDENT> lshmax = max ( lsh ) <NEWLINE> lswmax = max ( lsw ) <NEWLINE> <NL> hin = [ i for i in range ( h ) if lsh [ i ] == lshmax ] <NEWLINE> win = [ i for i in range ( w ) if lsw [ i ] == lswmax ] <NEWLINE> <NL> for i in hin : <NEWLINE> <INDENT> for j in win : <NEWLINE> <INDENT> if ( i , j ) not in bom : <NEWLINE> <INDENT> print ( lshmax + lswmax ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( lshmax + lswmax - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> s = input ( ) [ : : - 1 ] <NEWLINE> n = len ( s ) <NEWLINE> cs = [ 0 ] * ( n + 1 ) <NEWLINE> ten = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cs [ i + 1 ] = int ( s [ i ] ) * ten % 2019 <NEWLINE> ten = ten * 10 % 2019 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> cs [ i + 1 ] = ( cs [ i + 1 ] + cs [ i ] ) % 2019 <NEWLINE> <DEDENT> cnt = [ 0 ] * 2019 <NEWLINE> for i , x in enumerate ( cs ) : <NEWLINE> <INDENT> cnt [ x ] += 1 <NEWLINE> <DEDENT> ans = sum ( x * ( x - 1 ) // 2 for x in cnt ) <NEWLINE> print ( ans ) <NEWLINE>
<STRING> <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <STRING> <NEWLINE> A = [ int ( i ) - 1 for i in A ] <NEWLINE> B = [ ] <NEWLINE> cnt = [ 0 ] * n <NEWLINE> m = 0 <NEWLINE> for i in range ( 2 * 10 ** 5 ) : <NEWLINE> <INDENT> B . append ( m ) <NEWLINE> cnt [ m ] += 1 <NEWLINE> if cnt [ m ] > 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m = A [ m ] <NEWLINE> <DEDENT> c = len ( B ) - ( B . index ( m ) + 1 ) <NEWLINE> print ( 1 + B [ ( max ( k - B . index ( m ) , 0 ) ) % c + min ( B . index ( m ) , k ) ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 10 == 3 or <STRING> in str ( i ) : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> sum_W = [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> sum_W . append ( sum_W [ i - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum_W . append ( sum_W [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> sum_E = [ S [ 1 : ] . count ( <STRING> ) ] <NEWLINE> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> sum_E . append ( sum_E [ i ] - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum_E . append ( sum_E [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> counts = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> counts . append ( sum_W [ i ] + sum_E [ i ] ) <NEWLINE> <NL> <DEDENT> print ( min ( counts ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = ( 2 * 10 ** 5 ) + 1 <NEWLINE> b = [ 0 ] * l <NEWLINE> <NL> <NL> def nC2 ( n ) : <NEWLINE> <INDENT> return n * ( n - 1 ) // 2 <NEWLINE> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> b [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> ttl = 0 <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> ttl += b [ j ] * ( b [ j ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> for k in range ( n ) : <NEWLINE> <INDENT> print ( ttl - nC2 ( b [ a [ k ] ] ) + nC2 ( b [ a [ k ] ] - 1 ) ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for i in range ( m ) ] ) <NEWLINE> broken = [ False ] * ( n + 1 ) <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> broken [ i ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> MOD = 1000000007 <NEWLINE> <NL> <NL> dp = [ 0 for i in range ( n + 1 ) ] <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if 1 in a : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if broken [ i - 1 ] and broken [ i - 2 ] : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> elif broken [ i - 1 ] : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 2 ] % MOD <NEWLINE> <DEDENT> elif broken [ i - 2 ] : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] % MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE> <DEDENT>
from operator import itemgetter as get <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> A = map ( int , input ( ) . split ( ) ) <NEWLINE> SB = 0 <NEWLINE> ABI = sorted ( ( ( b : = max ( N - i , i - 1 ) * a , SB : = SB + b ) and ( a , b , i ) for i , a in enumerate ( A , 1 ) ) , reverse = True ) <NEWLINE> <NL> def solve ( a , i , prev , th ) : <NEWLINE> <INDENT> pl , pr , ps = 0 , - 1 , 0 <NEWLINE> for l , r , s in prev : <NEWLINE> <INDENT> if s < th : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if pr == r - 1 : <NEWLINE> <INDENT> yield l , r - 1 , max ( s + abs ( r - i ) * a , ps + abs ( i - pl ) * a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if pl : <NEWLINE> <INDENT> yield pl + 1 , pr , ps + abs ( i - pl ) * a <NEWLINE> <DEDENT> yield l , r - 1 , s + abs ( r - i ) * a <NEWLINE> <DEDENT> pl , pr , ps = l , r , s <NEWLINE> <DEDENT> yield pl + 1 , pr , ps + abs ( i - pl ) * a <NEWLINE> <NL> <DEDENT> prev = [ ( 1 , N , 0 ) ] <NEWLINE> pm = 0 <NEWLINE> for j , ( a , b , i ) in enumerate ( ABI ) : <NEWLINE> <INDENT> M = 0 <NEWLINE> prev = [ ( M : = max ( M , s ) , ) and ( l , r , s ) for l , r , s in solve ( a , i , prev , pm - SB ) ] <NEWLINE> pm = M <NEWLINE> SB -= b <NEWLINE> <NL> <DEDENT> print ( pm ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> list = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> list . append ( s ) <NEWLINE> <DEDENT> print ( len ( set ( list ) ) ) <NEWLINE>
from itertools import accumulate <NEWLINE> from bisect import bisect_right <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> SA = list ( accumulate ( A ) ) <NEWLINE> SB = list ( accumulate ( B ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for n in range ( len ( SA ) ) : <NEWLINE> <INDENT> tmp = K - SA [ n ] <NEWLINE> if tmp < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m = bisect_right ( SB , tmp ) <NEWLINE> ans = max ( ans , n + m ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ 0 for _ in range ( M ) ] <NEWLINE> B = [ 0 for _ in range ( M ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ i ] -= 1 <NEWLINE> B [ i ] -= 1 <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> uf = UnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> uf . union ( A [ i ] , B [ i ] ) <NEWLINE> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = ( 10 ** 6 + 1 ) * [ 0 ] <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> B [ a ] += 1 <NEWLINE> if B [ a ] == 1 : <NEWLINE> <INDENT> for n in range ( 2 * a , 10 ** 6 + 1 , a ) : <NEWLINE> <INDENT> B [ n ] += 10 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( B . count ( 1 ) ) <NEWLINE>
def main ( ) : <NEWLINE> <NL> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cur = 1 <NEWLINE> visited = [ - 1 ] * ( N + 1 ) <NEWLINE> visited [ cur ] = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> next_cur = A [ cur ] <NEWLINE> if next_cur == cur : <NEWLINE> <INDENT> print ( next_cur ) <NEWLINE> return <NEWLINE> <DEDENT> elif visited [ next_cur ] != - 1 : <NEWLINE> <INDENT> mod = i - visited [ next_cur ] <NEWLINE> start = visited [ next_cur ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited [ next_cur ] = visited [ cur ] + 1 <NEWLINE> cur = next_cur <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( next_cur ) <NEWLINE> return <NEWLINE> <DEDENT> K = ( K - start ) % mod <NEWLINE> print ( visited . index ( K + start ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> class UnionFind ( object ) : <NEWLINE> <INDENT> def __init__ ( self , n = 1 ) : <NEWLINE> <INDENT> self . par = [ i for i in range ( n ) ] <NEWLINE> self . rank = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x != y : <NEWLINE> <INDENT> if self . rank [ x ] < self . rank [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ x ] += 1 <NEWLINE> <DEDENT> self . par [ y ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> def is_same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf1 = UnionFind ( N ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> uf1 . union ( x - 1 , y - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> uf1 . find ( i ) <NEWLINE> <DEDENT> c = list ( Counter ( uf1 . par ) . values ( ) ) <NEWLINE> print ( max ( c ) ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> bl = X . count ( <STRING> ) <NEWLINE> bitp = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> bitp += int ( X [ i ] ) * pow ( 2 , N - 1 - i , bl + 1 ) <NEWLINE> bitp %= bl + 1 <NEWLINE> <DEDENT> bitm = 0 <NEWLINE> if bl > 1 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> bitm += int ( X [ i ] ) * pow ( 2 , N - 1 - i , bl - 1 ) <NEWLINE> bitm %= bl - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ 0 ] * N <NEWLINE> dp = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> dp [ i ] = dp [ i % ( bin ( i ) . count ( <STRING> ) ) ] + 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> bl1 = bl - 1 <NEWLINE> if bl1 == 0 : <NEWLINE> <INDENT> ans [ i ] = 0 <NEWLINE> continue <NEWLINE> <DEDENT> bit1 = bitm - pow ( 2 , N - 1 - i , bl1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bl1 = bl + 1 <NEWLINE> bit1 = bitp + pow ( 2 , N - 1 - i , bl1 ) <NEWLINE> <DEDENT> ans [ i ] = dp [ bit1 % bl1 ] + 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> print ( * solve ( ) , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> def div ( n ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> count += 1 if n % i == 0 else 0 <NEWLINE> <DEDENT> return count <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , int ( input ( ) ) + 1 ) : <NEWLINE> <INDENT> ans += 1 if i % 2 == 1 and div ( i ) == 8 else 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> S = list ( S ) <NEWLINE> <NL> for j in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ j ] == <STRING> : <NEWLINE> <INDENT> if j == K - 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> x = [ i for i in S if i != <STRING> ] <NEWLINE> ans = x [ 0 ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <DEDENT> x = 0 <NEWLINE> bj = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( bj , - 1 , - 1 ) : <NEWLINE> <INDENT> if a [ i ] + b [ j ] <= K : <NEWLINE> <INDENT> bj = j <NEWLINE> x = max ( x , i + j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> limit = 10 ** 18 <NEWLINE> A . sort ( ) <NEWLINE> result = A [ 0 ] <NEWLINE> for a in A [ 1 : ] : <NEWLINE> <INDENT> result *= a <NEWLINE> if result > limit : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def floor ( t ) : <NEWLINE> <INDENT> return int ( t ) <NEWLINE> <NL> <DEDENT> list = [ ] <NEWLINE> <NL> if N + 1 > B : <NEWLINE> <INDENT> print ( floor ( ( A * ( B - 1 ) ) / B ) - A * floor ( ( B - 1 ) / B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( floor ( ( A * N / B ) - A * floor ( N / B ) ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ip2 = input ( ) <NEWLINE> A_sub = ip2 . split ( <STRING> ) <NEWLINE> A = [ ] <NEWLINE> for a in A_sub : A . append ( int ( a ) ) <NEWLINE> <NL> l = [ 0 ] * N <NEWLINE> for a in A : <NEWLINE> <INDENT> l [ a - 1 ] += 1 <NEWLINE> <DEDENT> for sl in l : print ( sl ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> from math import gcd <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> c = c + gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import sys , math <NEWLINE> from itertools import permutations , combinations <NEWLINE> from collections import defaultdict , Counter , deque <NEWLINE> from math import factorial <COMMENT> <NEWLINE> from bisect import bisect_left <COMMENT> <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> enu = enumerate <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> def input ( ) : return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> def pri ( x ) : print ( <STRING> . join ( map ( str , x ) ) ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> Rs = [ ] <NEWLINE> Gs = [ ] <NEWLINE> Bs = [ ] <NEWLINE> for index , s in enu ( S ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> Rs . append ( index + 1 ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> Gs . append ( index + 1 ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> Bs . append ( index + 1 ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> cnt = len ( Rs ) * len ( Gs ) * len ( Bs ) <NEWLINE> sBs = set ( Bs ) <NEWLINE> <NL> for rr in Rs : <NEWLINE> <INDENT> for gg in Gs : <NEWLINE> <INDENT> r , g = sorted ( [ rr , gg ] ) <NEWLINE> <NL> pt1 = g + ( g - r ) <NEWLINE> pt2 = - 1 <NEWLINE> if ( g - r ) % 2 == 0 : <NEWLINE> <INDENT> pt2 = r + ( g - r ) // 2 <NEWLINE> <DEDENT> pt3 = r - ( g - r ) <NEWLINE> <NL> chks = [ val for val in [ pt1 , pt2 , pt3 ] if val > 0 ] <NEWLINE> for chk in chks : <NEWLINE> <INDENT> if chk in sBs : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ ] <NEWLINE> A = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmpA = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C += [ tmpA [ 0 ] ] <NEWLINE> A [ i ] = tmpA [ 1 : ] <NEWLINE> <NL> <DEDENT> costmin = float ( <STRING> ) <NEWLINE> for k in range ( 2 ** N ) : <NEWLINE> <INDENT> tansaku = k <NEWLINE> koubai = [ 0 for i in range ( N ) ] <NEWLINE> rikaido = [ 0 for i in range ( M ) ] <NEWLINE> cost = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> koubai [ i ] = tansaku // ( 2 ** ( N - i - 1 ) ) <NEWLINE> tansaku = tansaku % ( 2 ** ( N - i - 1 ) ) <NEWLINE> <DEDENT> koubai [ - 1 ] = tansaku <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if koubai [ i ] == 1 : <NEWLINE> <INDENT> cost += C [ i ] <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> rikaido [ j ] += A [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> if rikaido [ i ] < X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> costmin = min ( costmin , cost ) <NEWLINE> <DEDENT> <DEDENT> if costmin != float ( <STRING> ) : <NEWLINE> <INDENT> print ( costmin ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> rw_lst = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> rw_lst [ a ] . append ( b ) <NEWLINE> rw_lst [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> sign_lst = [ - 1 for _ in range ( n + 1 ) ] <NEWLINE> sign_lst [ 1 ] = 0 <NEWLINE> check_lst = [ False for _ in range ( n + 1 ) ] <NEWLINE> check_lst [ 1 ] = True <NEWLINE> <NL> queue = deque ( [ 1 ] ) <NEWLINE> while queue : <NEWLINE> <INDENT> room = queue . popleft ( ) <NEWLINE> for way in rw_lst [ room ] : <NEWLINE> <INDENT> if not check_lst [ way ] : <NEWLINE> <INDENT> check_lst [ way ] = True <NEWLINE> sign_lst [ way ] = room <NEWLINE> queue . append ( way ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> check = True <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> check = check and check_lst [ i ] <NEWLINE> <NL> <DEDENT> if check : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( sign_lst [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> N = INT ( ) <NEWLINE> A = LIST ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> cnt = [ 0 , 0 , 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * cnt . count ( A [ i ] ) % mod <NEWLINE> if A [ i ] in cnt : <NEWLINE> <INDENT> cnt [ cnt . index ( A [ i ] ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for a in range ( k + 1 ) : <NEWLINE> <INDENT> for b in range ( k + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> for c in range ( k + 1 ) : <NEWLINE> <INDENT> if a != 0 and b != 0 and c != 0 : <NEWLINE> <INDENT> sum = sum + math . gcd ( tmp , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Y = sorted ( X ) <NEWLINE> a = Y [ N // 2 - 1 ] <NEWLINE> b = Y [ N // 2 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] <= a : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ps = sorted ( p ) <NEWLINE> tmp = list ( range ( - 201 , 200 ) ) <NEWLINE> ans_list = list ( set ( tmp ) ^ set ( ps ) ) <NEWLINE> ans_list = sorted ( ans_list ) <NEWLINE> <COMMENT> <NL> diff = [ ] <NEWLINE> <NL> for i in ans_list : <NEWLINE> <INDENT> diff . append ( abs ( i - x ) ) <NEWLINE> <NL> <DEDENT> print ( ans_list [ diff . index ( min ( diff ) ) ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = [ input ( ) for i in range ( n ) ] <NEWLINE> print ( - len ( A ) + len ( set ( A ) ) + n ) <NEWLINE>
from sys import stdin <NEWLINE> nii = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> lnii = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> def divisore ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <NL> <DEDENT> ans_l = divisore ( n - 1 ) [ 1 : ] <NEWLINE> <NL> d = divisore ( n ) <NEWLINE> for i in d [ 1 : ] : <NEWLINE> <INDENT> nn = n <NEWLINE> while nn % i == 0 : <NEWLINE> <INDENT> nn //= i <NEWLINE> <DEDENT> if nn % i == 1 : <NEWLINE> <INDENT> ans_l . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( ans_l ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> num = r * g * b <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for d in range ( n ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> num -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
S = input ( ) <NEWLINE> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> num , d = 0 , 1 <NEWLINE> <NL> for s in S [ : : - 1 ] : <NEWLINE> <INDENT> num += int ( s ) * d <NEWLINE> d *= 10 <NEWLINE> num %= 2019 <NEWLINE> d %= 2019 <NEWLINE> counts [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for count in counts : <NEWLINE> <INDENT> ans += count * ( count - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
MOD = 1000000007 <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> B = [ 0 ] * ( N - 1 ) <NEWLINE> sumA = sum ( A ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> sumA -= A [ i - 1 ] <NEWLINE> B [ i - 1 ] = sumA <NEWLINE> <DEDENT> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * B [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for a in sorted ( A , reverse = True ) : <NEWLINE> <INDENT> ans *= a <NEWLINE> if 10 ** 18 < ans : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> a = 0 <NEWLINE> for i in range ( 0 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
import sys <NEWLINE> import numpy <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = numpy . zeros ( n , dtype = int ) <NEWLINE> <NL> city = 1 <NEWLINE> count = 0 <NEWLINE> while b [ city - 1 ] == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> b [ city - 1 ] = 1 <NEWLINE> <NL> city = a [ city - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if k < count : <NEWLINE> <INDENT> cc = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> cc = a [ cc - 1 ] <NEWLINE> <DEDENT> print ( cc ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> c = 1 <NEWLINE> cnt = 0 <NEWLINE> while c != city : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> c = a [ c - 1 ] <NEWLINE> <NL> <DEDENT> loop = count - cnt <NEWLINE> <NL> d = ( k - count ) % loop <NEWLINE> <NL> for i in range ( d ) : <NEWLINE> <INDENT> city = a [ city - 1 ] <NEWLINE> <NL> <DEDENT> print ( city ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> def divlist ( n ) : <NEWLINE> <INDENT> sl = [ ] <NEWLINE> ll = [ ] <NEWLINE> for x in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % x == 0 : <NEWLINE> <INDENT> sl . append ( x ) <NEWLINE> ll . append ( n // x ) <NEWLINE> <DEDENT> <DEDENT> ll . reverse ( ) <NEWLINE> sl . extend ( ll ) <NEWLINE> return sl <NEWLINE> <NL> <DEDENT> def f ( b , n ) : <NEWLINE> <INDENT> if n < b : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return f ( b , n // b ) + ( n % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( n , s ) : <NEWLINE> <INDENT> if n < s : <NEWLINE> <INDENT> return print ( - 1 ) <NEWLINE> <DEDENT> elif n == s : <NEWLINE> <INDENT> return print ( n + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dl = divlist ( n - s ) <NEWLINE> for x in dl : <NEWLINE> <INDENT> if s == f ( x + 1 , n ) : <NEWLINE> <INDENT> return print ( x + 1 ) <NEWLINE> <DEDENT> <DEDENT> return print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> s = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> <NL> main ( n , s ) <NEWLINE>
import sys <NEWLINE> n = input ( ) <NEWLINE> list_num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> output = 1 <NEWLINE> if 0 in list_num : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in list_num : <NEWLINE> <INDENT> output = output * i <NEWLINE> if output > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( output ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> temp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( temp , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> import numpy as np <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> N , K = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> is_prime = np . zeros ( K + 10 , np . bool ) <NEWLINE> is_prime [ 2 ] = 1 <NEWLINE> is_prime [ 3 : : 2 ] = 1 <NEWLINE> for p in range ( 3 , K + 10 , 2 ) : <NEWLINE> <INDENT> if p * p > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if is_prime [ p ] : <NEWLINE> <INDENT> is_prime [ p * p : : p + p ] = 0 <NEWLINE> <DEDENT> <DEDENT> primes = np . where ( is_prime ) [ 0 ] <NEWLINE> <NL> <NL> A = [ 0 ] * ( K + 1 ) <NEWLINE> for d in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> A [ d ] = pow ( K // d , N , MOD ) <NEWLINE> <NL> <DEDENT> for p in primes . tolist ( ) : <NEWLINE> <INDENT> for i in range ( K // p + 1 ) : <NEWLINE> <INDENT> A [ i ] -= A [ i * p ] <NEWLINE> <NL> <DEDENT> <DEDENT> answer = sum ( i * x for i , x in enumerate ( A ) ) <NEWLINE> print ( answer % MOD ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> ans = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> c , a , b = input ( ) . split ( ) <NEWLINE> a , b = int ( a ) - 1 , int ( b ) - 1 <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> ans += [ a + b * n + z * n ** 2 for z in range ( n ) ] <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> ans += [ a + y * n + b * n ** 2 for y in range ( n ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += [ x + a * n + b * n ** 2 for x in range ( n ) ] <NEWLINE> <DEDENT> <DEDENT> print ( n ** 3 - len ( set ( ans ) ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> for i in range ( H - 2 ) : <NEWLINE> <INDENT> print ( <STRING> + ( <STRING> * ( W - 2 ) ) + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> print ( ) <NEWLINE> <DEDENT>
def g ( x ) : <NEWLINE> <INDENT> S = format ( x , <STRING> ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 20 ) : <NEWLINE> <INDENT> if S [ - 1 - i ] == <STRING> : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> <DEDENT> <DEDENT> return x % cnt <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> a = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> a = a + 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if a == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> if a == 1 : <NEWLINE> <INDENT> if X [ - 1 ] == <STRING> : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( 2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> D = [ 0 ] * n <NEWLINE> E = [ 0 ] * n <NEWLINE> D [ 0 ] = 1 % ( a - 1 ) <NEWLINE> E [ 0 ] = 1 % ( a + 1 ) <NEWLINE> b = int ( X [ - 1 ] ) % ( a - 1 ) <NEWLINE> c = int ( X [ - 1 ] ) % ( a + 1 ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> D [ i + 1 ] = ( D [ i ] * 2 ) % ( a - 1 ) <NEWLINE> E [ i + 1 ] = ( E [ i ] * 2 ) % ( a + 1 ) <NEWLINE> if X [ - 2 - i ] == <STRING> : <NEWLINE> <INDENT> b = ( b + D [ i + 1 ] ) % ( a - 1 ) <NEWLINE> c = ( c + E [ i + 1 ] ) % ( a + 1 ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> x = ( b + a - 1 - D [ - 1 - i ] ) % ( a - 1 ) <NEWLINE> ans = 1 <NEWLINE> while x != 0 : <NEWLINE> <INDENT> x = g ( x ) <NEWLINE> ans = ans + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = ( c + E [ - 1 - i ] ) % ( a + 1 ) <NEWLINE> ans = 1 <NEWLINE> while x != 0 : <NEWLINE> <INDENT> x = g ( x ) <NEWLINE> ans = ans + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B_to_C = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B_to_C . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> dict_A = { } <NEWLINE> sums = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a in dict_A : <NEWLINE> <INDENT> dict_A [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict_A [ a ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for k , v in dict_A . items ( ) : <NEWLINE> <INDENT> sums += k * v <NEWLINE> <NL> <DEDENT> for B , C in B_to_C : <NEWLINE> <INDENT> if B in dict_A : <NEWLINE> <INDENT> count_of_num = dict_A [ B ] <NEWLINE> if C in dict_A : <NEWLINE> <INDENT> dict_A [ C ] += dict_A [ B ] <NEWLINE> del dict_A [ B ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict_A [ C ] = dict_A [ B ] <NEWLINE> del dict_A [ B ] <NEWLINE> <NL> <DEDENT> sums = sums - B * count_of_num + C * count_of_num <NEWLINE> print ( sums ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( sums ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True , key = lambda x : abs ( x ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> nega = 0 <NEWLINE> posi = 0 <NEWLINE> zero = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] > 0 : <NEWLINE> <INDENT> posi += 1 <NEWLINE> <DEDENT> elif a [ i ] == 0 : <NEWLINE> <INDENT> zero += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nega += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if n == k : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= abs ( a [ i ] ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> if nega % 2 == 1 : <NEWLINE> <INDENT> ans *= - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> elif posi == 0 : <NEWLINE> <NL> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= abs ( a [ i ] ) <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if zero > 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . reverse ( ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= abs ( a [ i ] ) <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> ans *= - 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> posi = 0 <NEWLINE> nega = 0 <NEWLINE> zero = 0 <NEWLINE> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= abs ( a [ i ] ) <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> if a [ i ] > 0 : <NEWLINE> <INDENT> posi += 1 <NEWLINE> <DEDENT> elif a [ i ] < 0 : <NEWLINE> <INDENT> nega += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> zero += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if zero > 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> elif nega % 2 != 0 : <NEWLINE> <INDENT> minposi = 0 <NEWLINE> minnega = 0 <NEWLINE> for i in range ( k - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if a [ i ] > 0 : <NEWLINE> <INDENT> if minposi == 0 : <NEWLINE> <INDENT> minposi = a [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if minnega == 0 : <NEWLINE> <INDENT> minnega = a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> maxposi = 0 <NEWLINE> maxnega = 0 <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > 0 : <NEWLINE> <INDENT> if maxposi == 0 : <NEWLINE> <INDENT> maxposi = a [ i ] <NEWLINE> <DEDENT> <DEDENT> elif a [ i ] < 0 : <NEWLINE> <INDENT> if maxnega == 0 : <NEWLINE> <INDENT> maxnega = a [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if minposi == 0 : <NEWLINE> <INDENT> ans *= pow ( abs ( minnega ) , mod - 2 , mod ) <NEWLINE> ans *= abs ( maxposi ) <NEWLINE> <NL> <DEDENT> elif abs ( minposi * maxposi ) <= abs ( minnega * maxnega ) : <NEWLINE> <INDENT> ans *= pow ( abs ( minposi ) , mod - 2 , mod ) <NEWLINE> ans *= abs ( maxnega ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans *= pow ( abs ( minnega ) , mod - 2 , mod ) <NEWLINE> ans *= abs ( maxposi ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mnm = 2 * 10 ** 5 <NEWLINE> ans = 0 <NEWLINE> for i in p : <NEWLINE> <INDENT> if i <= mnm : <NEWLINE> <INDENT> mnm = i <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> ar = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum_val = sum ( ar ) <NEWLINE> <NL> unique_val = dict ( ) <NEWLINE> <NL> for i in ar : <NEWLINE> <INDENT> if i in unique_val : <NEWLINE> <INDENT> unique_val [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> unique_val [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> while ( q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a in unique_val : <NEWLINE> <INDENT> value = ( b - a ) * unique_val [ a ] <NEWLINE> sum_val += value <NEWLINE> if b in unique_val : <NEWLINE> <INDENT> unique_val [ b ] = unique_val [ b ] + unique_val . pop ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> unique_val [ b ] = unique_val . pop ( a ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( sum_val ) <NEWLINE> q -= 1 <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> <NL> <DEDENT> AA = sorted ( A , reverse = True ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] != AA [ 0 ] : <NEWLINE> <INDENT> print ( AA [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( AA [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> while cnt < 1000001 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> ans = ( ans * 10 + 7 ) % K <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> n , m , q = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> a = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> d = [ ] <NEWLINE> <NL> <NL> for i in range ( q ) : <NEWLINE> <INDENT> l . append ( [ ] ) <NEWLINE> l [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in itertools . combinations_with_replacement ( a [ : m ] , r = n ) : <COMMENT> <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( b ) ) : <COMMENT> <NEWLINE> <INDENT> d . append ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> w = l [ i ] [ 0 ] - 1 <COMMENT> <NEWLINE> x = l [ i ] [ 1 ] - 1 <COMMENT> <NEWLINE> y = l [ i ] [ 2 ] <COMMENT> <NEWLINE> z = l [ i ] [ 3 ] <COMMENT> <NEWLINE> for j in range ( len ( b ) ) : <NEWLINE> <INDENT> if b [ j ] [ x ] - b [ j ] [ w ] == y : <NEWLINE> <INDENT> d [ j ] += z <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max ( d ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ x - 1 ] . append ( y - 1 ) <NEWLINE> <NL> <DEDENT> dp = [ - 1 ] * N <NEWLINE> <NL> def rec ( v ) : <NEWLINE> <INDENT> if dp [ v ] != - 1 : <NEWLINE> <INDENT> return dp [ v ] <NEWLINE> <DEDENT> res = 0 <NEWLINE> for next_v in G [ v ] : <NEWLINE> <INDENT> res = max ( res , rec ( next_v ) + 1 ) <NEWLINE> <DEDENT> dp [ v ] = res <NEWLINE> return dp [ v ] <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> dp [ i ] = rec ( i ) <NEWLINE> <NL> <DEDENT> print ( max ( dp ) ) <NEWLINE>
dic = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 , <STRING> : 3 , <NEWLINE> <INDENT> <STRING> : 4 , <STRING> : 5 , <STRING> : 6 , <STRING> : 7 , <NEWLINE> <STRING> : 8 , <STRING> : 9 , <STRING> : 10 , <STRING> : 11 } <NEWLINE> <DEDENT> t = int ( input ( ) ) <NEWLINE> for _ in range ( t ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> t_lst = [ - 100 ] + list ( map ( lambda x : dic [ x ] , input ( ) . split ( ) ) ) <NEWLINE> s_lst = list ( map ( lambda x : dic [ x ] , input ( ) . split ( ) ) ) <NEWLINE> s_lst . reverse ( ) <NEWLINE> <NL> def search ( stack ) : <NEWLINE> <INDENT> t_index , s_index = stack . pop ( ) <NEWLINE> if s_index == m : return t_index == 0 <NEWLINE> if t_index <= 0 or t_index > n : return False <NEWLINE> base = t_lst [ t_index ] <NEWLINE> proc = s_lst [ s_index ] <NEWLINE> diff = ( proc - base ) % 12 <NEWLINE> if diff == 1 : stack . append ( ( t_index - 2 , s_index + 1 ) ) <NEWLINE> if diff == 0 : stack . append ( ( t_index - 1 , s_index + 1 ) ) <NEWLINE> if diff == 11 : stack . append ( ( t_index + 1 , s_index + 1 ) ) <NEWLINE> return False <NEWLINE> <DEDENT> stack = [ ( n , 0 ) , ( n - 1 , 0 ) ] <NEWLINE> while stack : <NEWLINE> <INDENT> if search ( stack ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = str ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> s += int ( i ) <NEWLINE> <DEDENT> print ( <STRING> if s % 9 == 0 else <STRING> ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> print ( A - B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B - A ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( h == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
from collections import deque <COMMENT> <NEWLINE> <NL> letter = [ <STRING> ] + [ chr ( i ) for i in range ( 97 , 123 ) ] <COMMENT> <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> i = 0 <NEWLINE> n_24 = deque ( ) <NEWLINE> <NL> while N > 0 : <NEWLINE> <INDENT> n_24 . appendleft ( N % 26 ) <NEWLINE> if N % 26 == 0 : <NEWLINE> <INDENT> N -= 26 <NEWLINE> <DEDENT> N = N // 26 <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> <NL> for dig in ( n_24 ) : <NEWLINE> <INDENT> ans += letter [ dig ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> if x == 1 : <NEWLINE> <INDENT> print ( 0 , - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> def divisorize ( fct ) : <NEWLINE> <INDENT> b , e = fct . pop ( ) <COMMENT> <NEWLINE> pre_div = divisorize ( fct ) if fct else [ [ ] ] <NEWLINE> suf_div = [ [ ( b , k ) ] for k in range ( e + 1 ) ] <NEWLINE> return [ pre + suf for pre in pre_div for suf in suf_div ] <NEWLINE> <NL> <NL> <DEDENT> def factorize ( n ) : <NEWLINE> <INDENT> fct = [ ] <COMMENT> <NEWLINE> b , e = 2 , 0 <COMMENT> <NEWLINE> while b * b <= n : <NEWLINE> <INDENT> while n % b == 0 : <NEWLINE> <INDENT> n = n // b <NEWLINE> e = e + 1 <NEWLINE> <DEDENT> if e > 0 : <NEWLINE> <INDENT> fct . append ( ( b , e ) ) <NEWLINE> <DEDENT> b , e = b + 1 , 0 <NEWLINE> <DEDENT> if n > 1 : <NEWLINE> <INDENT> fct . append ( ( n , 1 ) ) <NEWLINE> <DEDENT> return fct <NEWLINE> <NL> <NL> <DEDENT> def num ( fct ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> for base , exponent in fct : <NEWLINE> <INDENT> a = a * base ** exponent <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> c = [ ] <NEWLINE> fct = factorize ( x ) <NEWLINE> for div in divisorize ( fct ) : <NEWLINE> <INDENT> c . append ( num ( div ) ) <NEWLINE> <NL> <DEDENT> chk = False <NEWLINE> for s in c : <NEWLINE> <INDENT> if chk : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 1000 ) : <NEWLINE> <INDENT> if ( i + s ) ** 5 - i ** 5 > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( i + s ) ** 5 - i ** 5 == x : <NEWLINE> <INDENT> ans = ( i + s , i ) <NEWLINE> chk = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if s < 1000 : <NEWLINE> <INDENT> for p in range ( s , 1000 ) : <NEWLINE> <INDENT> j = - 1 * p <NEWLINE> <COMMENT> <NL> if ( j + s ) ** 5 - j ** 5 > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( j + s ) ** 5 - j ** 5 == x : <NEWLINE> <INDENT> ans = ( j + s , j ) <NEWLINE> chk = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for ww in range ( 1 , ( s + 1 ) // 2 ) [ : : - 1 ] : <NEWLINE> <INDENT> jj = - 1 * ww <NEWLINE> if ( jj + s ) ** 5 - jj ** 5 > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( jj + s ) ** 5 - jj ** 5 == x : <NEWLINE> <INDENT> ans = ( jj + s , jj ) <NEWLINE> chk = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if len ( s ) <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : k ] + <STRING> ) <NEWLINE> <DEDENT>
from math import ceil <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def check ( Min ) : <NEWLINE> <INDENT> kill = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> kill += ( ceil ( a / Min ) - 1 ) <NEWLINE> <DEDENT> return kill <= K <NEWLINE> <NL> <DEDENT> l = 0 <NEWLINE> r = 1000000000 <NEWLINE> <NL> while r - l > 1 : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> if check ( mid ) : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
X , Y , Z , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> e = [ ] <NEWLINE> s = [ ] <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> for j in B : <NEWLINE> <INDENT> e . append ( i + j ) <NEWLINE> <DEDENT> <DEDENT> e = sorted ( e , reverse = True ) <NEWLINE> <NL> if K < len ( e ) : <NEWLINE> <INDENT> e = e [ 0 : K ] <NEWLINE> <NL> <DEDENT> for i in e : <NEWLINE> <INDENT> for j in C : <NEWLINE> <INDENT> s . append ( i + j ) <NEWLINE> <NL> <DEDENT> <DEDENT> s = sorted ( s , reverse = True ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> <DEDENT>
N , K = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> A = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> <NL> x = 1 <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> sum_a = sum ( a ) <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans += a [ i ] * ( sum_a - a [ i ] ) <NEWLINE> sum_a -= a [ i ] <NEWLINE> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> answer = 0 <NEWLINE> if B > N : <NEWLINE> <INDENT> mae = ( A * N ) // B <NEWLINE> usiro = A * ( N // B ) <NEWLINE> l = mae - usiro <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = ( B - 1 ) <NEWLINE> mae = ( A * i ) // B <NEWLINE> usiro = A * ( i // B ) <NEWLINE> l = mae - usiro <NEWLINE> <DEDENT> print ( l ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> C = N - N % B <NEWLINE> ans = A * ( C - 1 ) // B - A * ( ( C - 1 ) // B ) <NEWLINE> if B > N : <NEWLINE> <INDENT> ans = A * N // B - A * ( N // B ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> for a in range ( - 118 , 120 ) : <NEWLINE> <INDENT> for b in range ( - 119 , 119 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( A ) <NEWLINE> ans = 0 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s -= A [ i ] <NEWLINE> ans += s * A [ i ] % MOD <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> dic = defaultdict ( int ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : dic [ input ( ) ] += 1 <NEWLINE> lis = sorted ( dic . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> M = lis [ 0 ] [ 1 ] <NEWLINE> ans = [ ] <NEWLINE> for i in range ( len ( lis ) ) : <NEWLINE> <INDENT> if lis [ i ] [ 1 ] == M : ans . append ( lis [ i ] [ 0 ] ) <NEWLINE> else : break <NEWLINE> <DEDENT> ans . sort ( ) <NEWLINE> for i in ans : print ( i ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , a % b ) <NEWLINE> <DEDENT> <DEDENT> import collections <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> cnt = collections . defaultdict ( int ) <NEWLINE> <COMMENT> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> cnt [ gcd ( a , b ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for gcd_of_ab in cnt . keys ( ) : <NEWLINE> <INDENT> ans += gcd ( gcd_of_ab , c ) * cnt [ gcd_of_ab ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def remain ( pos , length ) : <NEWLINE> <INDENT> p = pos <NEWLINE> for c , d in moves : <NEWLINE> <INDENT> if s [ p ] == c : <NEWLINE> <INDENT> if d == <STRING> : <NEWLINE> <INDENT> p -= 1 <NEWLINE> <DEDENT> if d == <STRING> : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> if p < 0 or p >= length : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> moves = [ list ( map ( str , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> l = - 1 <NEWLINE> r = n <NEWLINE> while r - l != 1 : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> if remain ( mid , n ) == True : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> <DEDENT> remain_left = r <NEWLINE> if remain_left == n : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> l = remain_left <NEWLINE> r = n <NEWLINE> while r - l != 1 : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> if remain ( mid , n ) == True : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> <DEDENT> remain_right = l <NEWLINE> print ( remain_right - remain_left + 1 ) <NEWLINE>
_ = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> a = 1 <NEWLINE> if min ( A ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for Ai in A : <NEWLINE> <INDENT> a *= Ai <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
( n , m ) = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> hights = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> bads = set ( [ ] ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> ( s , d ) = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if hights [ s - 1 ] < hights [ d - 1 ] : <NEWLINE> <INDENT> bads . add ( s ) <NEWLINE> <DEDENT> elif hights [ s - 1 ] > hights [ d - 1 ] : <NEWLINE> <INDENT> bads . add ( d ) <NEWLINE> <DEDENT> elif hights [ s - 1 ] == hights [ d - 1 ] : <NEWLINE> <INDENT> bads . add ( s ) <NEWLINE> bads . add ( d ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( hights ) - len ( bads ) ) <NEWLINE>
from math import sqrt <NEWLINE> <NL> def is_prime ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> if len ( arr ) > 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> base = int ( input ( ) ) <NEWLINE> tmp = base <NEWLINE> num = [ ] <NEWLINE> if is_prime ( base ) : <NEWLINE> <INDENT> num . append ( base ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 2 , base + 1 ) : <NEWLINE> <INDENT> if i > tmp : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if tmp % i == 0 and len ( factorization ( i ) ) == 1 : <NEWLINE> <INDENT> num . append ( i ) <NEWLINE> tmp /= i <NEWLINE> if is_prime ( tmp ) : <NEWLINE> <INDENT> num . append ( tmp ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( list ( set ( num ) ) ) ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> def LS ( ) : <NEWLINE> <INDENT> return list ( input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> S = deque ( input ( ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> rev = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> A = LS ( ) <NEWLINE> if A [ 0 ] == <STRING> : <NEWLINE> <INDENT> rev += 1 <NEWLINE> rev %= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A [ 1 ] == <STRING> : <NEWLINE> <INDENT> if rev == 0 : <NEWLINE> <INDENT> S . appendleft ( A [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . append ( A [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if rev == 0 : <NEWLINE> <INDENT> S . append ( A [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . appendleft ( A [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if rev == 0 : <NEWLINE> <INDENT> print ( <STRING> . join ( S ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . reverse ( ) <NEWLINE> print ( <STRING> . join ( S ) ) <NEWLINE> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> flag = 0 <NEWLINE> <NL> if ( V - W ) <= 0 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( ( V - W ) * T ) >= abs ( A - B ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math as ma <NEWLINE> <COMMENT> <NL> x = float ( input ( ) ) <NEWLINE> <NL> pi = ( x * x ) * ma . pi <NEWLINE> <COMMENT> <NL> pi_line = ( x + x ) * ma . pi <NEWLINE> <NL> print ( <STRING> . format ( pi , pi_line ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> result = 0 <NEWLINE> for A in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> result += ( N - 1 ) // A <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
T = list ( input ( ) ) <NEWLINE> N = len ( T ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> if T == [ <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if i == 0 : <NEWLINE> <INDENT> if T [ 1 ] == <STRING> : <NEWLINE> <INDENT> T [ 0 ] = <STRING> <NEWLINE> <DEDENT> elif T [ 1 ] == <STRING> : <NEWLINE> <INDENT> T [ 0 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ 0 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif i == N - 1 : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if T [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( T ) ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> a_idx = ord ( <STRING> ) <NEWLINE> S_Lis = { 0 : [ ] , 1 : [ ] , 2 : [ ] , 3 : [ ] , 4 : [ ] , 5 : [ ] , 6 : [ ] , 7 : [ ] , 8 : [ ] , 9 : [ ] , 10 : [ ] , 11 : [ ] , 12 : [ ] , <NEWLINE> <INDENT> 13 : [ ] , 14 : [ ] , 15 : [ ] , 16 : [ ] , 17 : [ ] , 18 : [ ] , 19 : [ ] , 20 : [ ] , 21 : [ ] , 22 : [ ] , 23 : [ ] , 24 : [ ] , 25 : [ ] } <NEWLINE> <DEDENT> T_Lis = { 0 : [ ] , 1 : [ ] , 2 : [ ] , 3 : [ ] , 4 : [ ] , 5 : [ ] , 6 : [ ] , 7 : [ ] , 8 : [ ] , 9 : [ ] , 10 : [ ] , 11 : [ ] , 12 : [ ] , <NEWLINE> <INDENT> 13 : [ ] , 14 : [ ] , 15 : [ ] , 16 : [ ] , 17 : [ ] , 18 : [ ] , 19 : [ ] , 20 : [ ] , 21 : [ ] , 22 : [ ] , 23 : [ ] , 24 : [ ] , 25 : [ ] } <NEWLINE> <DEDENT> leng = len ( S ) <NEWLINE> for i in range ( leng ) : <NEWLINE> <INDENT> S_Lis [ ord ( S [ i ] ) - a_idx ] . append ( i ) <NEWLINE> T_Lis [ ord ( T [ i ] ) - a_idx ] . append ( i ) <NEWLINE> <DEDENT> if sorted ( S_Lis . values ( ) ) == sorted ( T_Lis . values ( ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
mod = 10 ** 9 + 7 <NEWLINE> <NL> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x + y ) % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if x * 2 < y or y * 2 < x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> z = ( x + y ) // 3 <NEWLINE> <NL> x -= z <NEWLINE> y -= z <NEWLINE> <NL> n = x + y <NEWLINE> r = x <NEWLINE> <NL> if x == 0 or y == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> lst = [ 0 ] + [ 1 ] <NEWLINE> for i in range ( 2 , n + 10 ) : <NEWLINE> <INDENT> lst . append ( ( lst [ - 1 ] * i ) % mod ) <NEWLINE> <NL> <NL> <DEDENT> xxx = lst [ n ] <NEWLINE> xxx *= pow ( lst [ n - r ] , 10 ** 9 + 5 , mod ) <NEWLINE> xxx %= mod <NEWLINE> xxx *= pow ( lst [ r ] , 10 ** 9 + 5 , mod ) <NEWLINE> xxx %= mod <NEWLINE> <NL> print ( xxx ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A . sort ( reverse = True ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if a > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> E = [ 0 ] * ( N + 1 ) <NEWLINE> W = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> E [ i + 1 ] = E [ i ] + 1 <NEWLINE> W [ i + 1 ] = W [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> E [ i + 1 ] = E [ i ] <NEWLINE> W [ i + 1 ] = W [ i ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> min = N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S = W [ i ] - W [ 0 ] + E [ N ] - E [ i + 1 ] <NEWLINE> if S < min : <NEWLINE> <INDENT> min = S <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ) <NEWLINE>
<COMMENT> <NL> <NL> import random <NEWLINE> import sys <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> def _ ( f ) : <NEWLINE> <INDENT> for l in f : <NEWLINE> <INDENT> for i in l . split ( ) : <NEWLINE> <INDENT> yield ( int ( i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> g = _ ( sys . stdin ) <NEWLINE> <NL> N = next ( g ) <NEWLINE> <NL> a = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( next ( g ) ) <NEWLINE> <NL> <DEDENT> a . sort ( ) <NEWLINE> <NL> S = 1 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> S *= i <NEWLINE> <NL> if S == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> elif S > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( S ) <NEWLINE> <DEDENT>
li2 = sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] , reverse = True ) <NEWLINE> print ( li2 [ 0 ] ) <NEWLINE> print ( li2 [ 1 ] ) <NEWLINE> print ( li2 [ 2 ] ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a < k and k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - ( a + b ) ) ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
NML = input ( ) . split ( ) <NEWLINE> n = int ( NML [ 0 ] ) <NEWLINE> m = int ( NML [ 1 ] ) <NEWLINE> l = int ( NML [ 2 ] ) <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( [ ] ) <NEWLINE> A_r = input ( ) . split ( ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> A [ i ] . append ( int ( A_r [ j ] ) ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( [ ] ) <NEWLINE> B_r = input ( ) . split ( ) <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> B [ i ] . append ( int ( B_r [ j ] ) ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> out = 0 <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> out += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <DEDENT> print ( str ( out ) , end = <STRING> ) <NEWLINE> if j != l - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> n = n % 1000 <NEWLINE> if 1000 - n == 1000 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - n ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> N_half = int ( math . sqrt ( N ) ) <NEWLINE> for A in range ( 1 , N_half + 1 ) : <NEWLINE> <INDENT> for B in range ( 1 , N ) : <NEWLINE> <INDENT> if A * B < N : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if B > N_half : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <COMMENT> <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <NL> ans = 0 <NEWLINE> max_val = A [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if max_val > A [ i ] : <NEWLINE> <INDENT> ans += max_val - A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_val = A [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> H , W , D = map ( int , input ( ) . split ( ) ) <NEWLINE> cost = [ [ 0 for _ in range ( ( H * W ) // D + 1 ) ] for i in range ( D ) ] <NEWLINE> L = [ 0 ] * ( H * W ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> L1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> L [ L1 [ j ] - 1 ] = [ i , j ] <NEWLINE> if L1 [ j ] % D != 0 : <NEWLINE> <INDENT> cost [ L1 [ j ] % D ] [ L1 [ j ] // D ] = [ i , j , 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cost [ L1 [ j ] % D ] [ ( L1 [ j ] // D ) - 1 ] = [ i , j , 0 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> for j in range ( 1 , len ( cost [ i ] ) ) : <NEWLINE> <INDENT> if cost [ i ] [ j ] != 0 : <NEWLINE> <INDENT> cost [ i ] [ j ] [ 2 ] = cost [ i ] [ j - 1 ] [ 2 ] + abs ( cost [ i ] [ j ] [ 0 ] - cost [ i ] [ j - 1 ] [ 0 ] ) + abs ( cost [ i ] [ j ] [ 1 ] - cost [ i ] [ j - 1 ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> c = A % D <NEWLINE> a = A // D <NEWLINE> b = B // D <NEWLINE> if c == 0 : <NEWLINE> <INDENT> a , b = a - 1 , b - 1 <NEWLINE> <DEDENT> print ( cost [ c ] [ b ] [ 2 ] - cost [ c ] [ a ] [ 2 ] ) <NEWLINE> <DEDENT>
x , n = input ( ) . split ( ) <NEWLINE> x = int ( x ) <NEWLINE> n = int ( n ) <NEWLINE> <NL> array = [ [ 0 ] ] * 200 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 200 ) : <NEWLINE> <INDENT> array [ i ] = 0 <NEWLINE> <DEDENT> tmp = input ( ) . split ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> array [ int ( tmp [ i ] ) ] = 1 <NEWLINE> <NL> <DEDENT> dif_tmp = 999 <NEWLINE> ret = 999 <NEWLINE> for i in range ( 200 ) : <NEWLINE> <INDENT> if array [ 199 - i ] == 0 : <NEWLINE> <INDENT> if abs ( x - ( 199 - i ) ) <= dif_tmp : <NEWLINE> <INDENT> ret = 199 - i <NEWLINE> dif_tmp = abs ( x - ( 199 - i ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> if abs ( x + i ) <= dif_tmp : <NEWLINE> <INDENT> ret = - i <NEWLINE> dif_tmp = abs ( x + i ) <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> gacha_set = set ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> gacha_set . add ( s ) <NEWLINE> <NL> <DEDENT> print ( len ( gacha_set ) ) <NEWLINE>
import sys <NEWLINE> S = list ( input ( ) ) <NEWLINE> s = list ( set ( S ) ) <NEWLINE> s . sort ( ) <NEWLINE> alfa = list ( <STRING> ) <NEWLINE> ans = 0 <NEWLINE> if ( len ( s ) == len ( alfa ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if ( s [ i ] != alfa [ i ] ) : <NEWLINE> <INDENT> print ( alfa [ i ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( alfa [ len ( s ) ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> C = input ( ) <NEWLINE> <NL> tmp = C <NEWLINE> tmp2 = len ( tmp . replace ( <STRING> , <STRING> ) ) <NEWLINE> tmp3 = C [ 0 : tmp2 ] <NEWLINE> ans = len ( tmp3 . replace ( <STRING> , <STRING> ) ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> X = input ( ) . strip ( ) <NEWLINE> <NL> def solve ( N , X ) : <NEWLINE> <INDENT> if not <STRING> in X : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> def popcount ( n ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> k = bin ( n ) . count ( <STRING> ) <NEWLINE> n %= k <NEWLINE> t += 1 <NEWLINE> <DEDENT> return t <NEWLINE> <NL> <DEDENT> X1 = X . count ( <STRING> ) <NEWLINE> <NL> Rp1 = [ ] <NEWLINE> Rm1 = [ ] <NEWLINE> Bp1 = [ ] <NEWLINE> Bm1 = [ ] <NEWLINE> <NL> for i , x in enumerate ( list ( X [ : : - 1 ] ) ) : <NEWLINE> <INDENT> tp1 = pow ( 2 , i , X1 + 1 ) <NEWLINE> if X1 - 1 > 0 : <NEWLINE> <INDENT> tm1 = pow ( 2 , i , X1 - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tm1 = 0 <NEWLINE> <DEDENT> Bp1 . append ( tp1 ) <NEWLINE> Bm1 . append ( tm1 ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> Rp1 . append ( tp1 ) <NEWLINE> Rm1 . append ( tm1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Rp1 . append ( 0 ) <NEWLINE> Rm1 . append ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> basep1 = sum ( Rp1 ) % ( X1 + 1 ) <NEWLINE> if X1 - 1 > 0 : <NEWLINE> <INDENT> basem1 = sum ( Rm1 ) % ( X1 - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> basem1 = 0 <NEWLINE> <DEDENT> Rp1 = Rp1 [ : : - 1 ] <NEWLINE> Rm1 = Rm1 [ : : - 1 ] <NEWLINE> Bp1 = Bp1 [ : : - 1 ] <NEWLINE> Bm1 = Bm1 [ : : - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> for bp1 , bm1 , x in zip ( Bp1 , Bm1 , X ) : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> t = basem1 - bm1 <NEWLINE> MOD = X1 - 1 <NEWLINE> if MOD <= 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> t = basep1 + bp1 <NEWLINE> MOD = X1 + 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( popcount ( t % MOD ) + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> solve ( N , X ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> cnt_0 = a . count ( 0 ) <NEWLINE> if cnt_0 >= 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ws = list ( map ( int , sys . stdin . read ( ) . split ( ) ) ) <NEWLINE> <NL> def check ( A , n , k , mid ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> p = mid <NEWLINE> s = 0 <NEWLINE> while ( s + A [ j ] ) <= p : <NEWLINE> <INDENT> s += A [ j ] <NEWLINE> j += 1 <NEWLINE> if ( j == n ) : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return j <NEWLINE> <NL> <DEDENT> def solve ( A , n , k ) : <NEWLINE> <INDENT> h = 100000 * 10000 <NEWLINE> l = 0 <NEWLINE> while 1 < ( h - l ) : <NEWLINE> <INDENT> mid = ( h + l ) // 2 <NEWLINE> v = check ( A , n , k , mid ) <NEWLINE> if v < n : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h = mid <NEWLINE> <DEDENT> <DEDENT> return h <NEWLINE> <NL> <DEDENT> print ( solve ( ws , n , k ) ) <NEWLINE>
N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> prices = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> print ( sum ( prices [ : K ] ) ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> <COMMENT> <NL> <NL> D = int ( readline ( ) ) <NEWLINE> <NL> C = list ( map ( int , readline ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <NL> last_submit = [ - 26 ] * 26 <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> S = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> fin = False <NEWLINE> for j in range ( len ( last_submit ) ) : <NEWLINE> <INDENT> if i - last_submit [ j ] >= 52 : <NEWLINE> <INDENT> print ( j + 1 ) <NEWLINE> last_submit [ j ] = i <NEWLINE> fin = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if fin : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( len ( S ) ) : <NEWLINE> <INDENT> S [ j ] = ( S [ j ] , j ) <NEWLINE> <DEDENT> S = sorted ( S , key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> topval = S [ 0 ] [ 0 ] <NEWLINE> for j in range ( len ( S ) ) : <NEWLINE> <INDENT> val = S [ j ] [ 0 ] <NEWLINE> if val < topval // 2 : <NEWLINE> <INDENT> continue <COMMENT> <NEWLINE> <DEDENT> index = S [ j ] [ 1 ] <NEWLINE> if i - last_submit [ index ] < 26 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> print ( index + 1 ) <NEWLINE> last_submit [ index ] = i <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ 0 ] [ 1 ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> flag = 1 <NEWLINE> ans = 1 <NEWLINE> r = 7 % k <NEWLINE> p = r <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> while flag != 0 : <NEWLINE> <INDENT> if r % k == 0 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> p = ( p * 10 ) % k <NEWLINE> r += p <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> i = 0 <NEWLINE> cnt = 1 <NEWLINE> cmpr = [ 0 ] <NEWLINE> while A [ i ] != 2 : <NEWLINE> <INDENT> if A [ i ] == i + 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> i = A [ i ] - 1 <NEWLINE> cmpr . append ( i ) <NEWLINE> cnt += 1 <NEWLINE> if cnt > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> out = 1 <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> check = True <NEWLINE> if 0 in an : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in an : <NEWLINE> <INDENT> out *= a <NEWLINE> if out > 1000000000000000000 : <NEWLINE> <INDENT> check = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if check : <NEWLINE> <INDENT> print ( out ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> N , H = MAP ( ) <NEWLINE> ab = [ LIST ( ) for _ in range ( N ) ] <NEWLINE> <NL> a , b = zip ( * ab ) <NEWLINE> b = list ( b ) <NEWLINE> <NL> b . sort ( ) <NEWLINE> A = max ( a ) <NEWLINE> <NL> B = b [ bisect ( b , A ) : ] [ : : - 1 ] <NEWLINE> if B : <NEWLINE> <INDENT> B = list ( accumulate ( B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = [ 0 ] <NEWLINE> <NL> <NL> <DEDENT> if H <= B [ - 1 ] : <NEWLINE> <INDENT> print ( bisect_left ( B , H ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if B [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( ceil ( H / A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( B ) + ceil ( ( H - B [ - 1 ] ) / A ) ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> <NL> def gcd ( x , y ) : <NEWLINE> <INDENT> while y : <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> total = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> subg = gcd ( a , b ) <NEWLINE> subtotal = 0 <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> subtotal += gcd ( subg , c ) <NEWLINE> <DEDENT> total += subtotal <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import math <NEWLINE> <NL> a , b , h , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> deg_a = ( 60 * h + m ) * ( 360 / ( 60 * 12 ) ) <NEWLINE> deg_b = m * ( 360 / 60 ) <NEWLINE> deg = abs ( deg_a - deg_b ) <NEWLINE> rad = math . radians ( deg ) <NEWLINE> <NL> c2 = a ** 2 + b ** 2 - 2 * a * b * math . cos ( rad ) <NEWLINE> print ( c2 ** 0.5 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <DEDENT> p = make_divisors ( n ) <NEWLINE> x = 0 <NEWLINE> i = 1 <NEWLINE> ans = 0 <NEWLINE> def countf ( x ) : <NEWLINE> <INDENT> for j in range ( 1 , x + 2 ) : <NEWLINE> <INDENT> if ( 1 + j ) * j // 2 > x : <NEWLINE> <INDENT> return j - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> while n != 1 : <NEWLINE> <INDENT> if n % p [ i ] == 0 : <NEWLINE> <INDENT> x += 1 <NEWLINE> n = n // p [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x != 0 : <NEWLINE> <INDENT> ans += countf ( x ) <NEWLINE> x = 0 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> ans += countf ( x ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> input_len = int ( input ( ) ) <NEWLINE> l = input ( ) . split ( ) <NEWLINE> sort_line = [ 0 for i in range ( input_len ) ] <NEWLINE> for i in range ( input_len ) : <NEWLINE> <INDENT> sort_line [ i ] = int ( l [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> for k in range ( input_len ) : <NEWLINE> <INDENT> if ( k > 0 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> sys . stdout . write ( str ( sort_line [ k ] ) ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> for i in range ( 1 , input_len ) : <NEWLINE> <INDENT> v = sort_line [ i ] <NEWLINE> j = i - 1 <NEWLINE> while ( j >= 0 and v < sort_line [ j ] ) : <NEWLINE> <INDENT> sort_line [ j + 1 ] = sort_line [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> sort_line [ j + 1 ] = v <NEWLINE> <NL> for k in range ( input_len ) : <NEWLINE> <INDENT> if ( k > 0 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> sys . stdout . write ( str ( sort_line [ k ] ) ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) . split ( <STRING> ) <NEWLINE> nums = list ( map ( int , s ) ) <NEWLINE> flag = 1 <NEWLINE> koukan = 0 <NEWLINE> while flag : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if nums [ i ] < nums [ i - 1 ] : <NEWLINE> <INDENT> w = nums [ i ] <NEWLINE> nums [ i ] = nums [ i - 1 ] <NEWLINE> nums [ i - 1 ] = w <NEWLINE> koukan += 1 <NEWLINE> flag = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> print ( nums [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( nums [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( koukan ) <NEWLINE>
s = input ( ) [ : : - 1 ] <COMMENT> <NEWLINE> <NL> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> <NL> num , d = 0 , 1 <NEWLINE> <NL> for char in s : <NEWLINE> <INDENT> num += int ( char ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> counts [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in counts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <COMMENT> <NEWLINE>
t = input ( ) <NEWLINE> <NL> s = list ( t ) <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if i > 0 and s [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> elif i < len ( s ) - 1 and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from collections import Counter <NEWLINE> a = Counter ( a ) <NEWLINE> lis = [ ] <NEWLINE> <NL> for i , j in a . items ( ) : <NEWLINE> <INDENT> lis += [ i ] * ( j // 2 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> lis . sort ( reverse = True ) <NEWLINE> if len ( lis ) <= 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = lis [ 0 ] * lis [ 1 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> if A >= 1 : <NEWLINE> <INDENT> if K >= A : <NEWLINE> <INDENT> ans = A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = K <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> tmp = K - A - B <NEWLINE> if tmp >= 1 : <NEWLINE> <INDENT> ans -= tmp <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for A in range ( 1 , N ) : <NEWLINE> <INDENT> cnt += ( N - 1 ) // A <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> n = len ( S ) <NEWLINE> l_res = [ 0 ] <NEWLINE> r_res = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> l_res . append ( l_res [ i ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l_res . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> inv_S = S [ : : - 1 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if inv_S [ i ] == <STRING> : <NEWLINE> <INDENT> r_res . append ( r_res [ i ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r_res . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> res = 0 <NEWLINE> for l_cnt , r_cnt in zip ( l_res , r_res [ : : - 1 ] ) : <NEWLINE> <INDENT> res += max ( l_cnt , r_cnt ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ None ] * N <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> result = 1 <NEWLINE> flag = False <NEWLINE> is_zero = False <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in A : <NEWLINE> <INDENT> result = result * x <NEWLINE> if result > 1e18 : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s_list = [ ] <NEWLINE> a_list = [ 0 ] * ( n + 1 ) <NEWLINE> b_list = [ 0 ] * ( n + 1 ) <NEWLINE> a_list [ 1 ] = 1 <NEWLINE> b_list [ 1 ] = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> s_list . append ( [ l , r + 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for l , r in s_list : <NEWLINE> <INDENT> t2 = max ( 0 , i - l ) <NEWLINE> t1 = max ( 0 , i - r ) <NEWLINE> a_list [ i ] += b_list [ t2 ] - b_list [ t1 ] <NEWLINE> <DEDENT> b_list [ i ] = ( b_list [ i - 1 ] + a_list [ i ] ) % 998244353 <NEWLINE> <NL> <DEDENT> print ( a_list [ n ] % 998244353 ) <NEWLINE> <NL>
<COMMENT> <NL> import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( A ) <NEWLINE> A = set ( A ) <NEWLINE> MAX_A = 10 ** 6 <NEWLINE> X = [ 0 ] * ( MAX_A + 1 ) <COMMENT> <NEWLINE> for i in A : <NEWLINE> <INDENT> for j in range ( i , MAX_A + 1 , i ) : <NEWLINE> <INDENT> X [ j ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = len ( [ a for a in A if ( X [ a ] == 1 ) and ( c [ a ] == 1 ) ] ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in list : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * list [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 0 <NEWLINE> total2 = 0 <NEWLINE> i = 1 <NEWLINE> for i in range ( a - 1 ) : <NEWLINE> <INDENT> if b [ i + 1 ] <= b [ i ] : <NEWLINE> <INDENT> total += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if total2 <= total : <NEWLINE> <INDENT> total2 = total <NEWLINE> <DEDENT> total = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max ( total2 , total ) ) <NEWLINE>
<COMMENT> <NL> import re <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> R = set ( [ m . start ( ) for m in re . finditer ( <STRING> , s ) ] ) <NEWLINE> G = set ( [ m . start ( ) for m in re . finditer ( <STRING> , s ) ] ) <NEWLINE> B = set ( [ m . start ( ) for m in re . finditer ( <STRING> , s ) ] ) <NEWLINE> <COMMENT> <NL> x = 0 <NEWLINE> li = [ ] <NEWLINE> for r in R : <NEWLINE> <INDENT> for g in G : <NEWLINE> <NL> <INDENT> if r < g : <NEWLINE> <INDENT> gr = g - r <NEWLINE> li . extend ( [ r - gr in B , g + gr in B , ( gr % 2 == 0 and r + gr // 2 in B ) ] ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> rg = r - g <NEWLINE> li . extend ( [ g - rg in B , r + rg in B , ( rg % 2 == 0 and g + rg // 2 in B ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( R ) * len ( G ) * len ( B ) - sum ( li ) ) <NEWLINE>
from heapq import heappush , heappop <NEWLINE> <NL> infi = 10 ** 20 <NEWLINE> n , m , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = min ( s , 2500 ) <NEWLINE> <NL> edges = [ [ ] for _ in range ( 51 * 2501 + 1 ) ] <NEWLINE> <COMMENT> <NL> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> u , v , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , 2501 ) : <NEWLINE> <INDENT> edges [ v + 50 * i ] . append ( ( b , u + 50 * ( i - a ) ) ) <NEWLINE> edges [ u + 50 * i ] . append ( ( b , v + 50 * ( i - a ) ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for edge_num in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> for i in range ( 2501 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if edge_num + ( i + c ) * 50 <= 51 * 2501 : <NEWLINE> <INDENT> edges [ edge_num + i * 50 ] . append ( ( d , edge_num + min ( ( i + c ) , 2500 ) * 50 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> start = 1 + 50 * s <NEWLINE> <NL> <NL> def dijkstra ( edges , start ) : <NEWLINE> <INDENT> time = [ infi ] * ( 51 * 2501 + 1 ) <NEWLINE> used = [ False ] * ( 51 * 2501 + 1 ) <NEWLINE> <COMMENT> <NL> time [ start ] = 0 <NEWLINE> edgelist = [ ] <NEWLINE> heappush ( edgelist , ( 0 , start ) ) <NEWLINE> while edgelist : <NEWLINE> <INDENT> nowtime , nowedge = heappop ( edgelist ) <NEWLINE> if used [ nowedge ] is True : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> used [ nowedge ] = True <NEWLINE> time [ nowedge ] = nowtime <NEWLINE> for vt , v in edges [ nowedge ] : <NEWLINE> <INDENT> if used [ v ] is True : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> newtime = nowtime + vt <NEWLINE> heappush ( edgelist , ( newtime , v ) ) <NEWLINE> <DEDENT> <DEDENT> return time <NEWLINE> <NL> <NL> <DEDENT> time = dijkstra ( edges , start ) <NEWLINE> <NL> ans = [ infi ] * ( 51 ) <NEWLINE> for i in range ( 1 , 51 * 2501 + 1 ) : <NEWLINE> <INDENT> temp = time [ i ] <NEWLINE> a = i % 50 <NEWLINE> if a == 0 : <NEWLINE> <INDENT> a += 50 <NEWLINE> <DEDENT> ans [ a ] = min ( temp , ans [ a ] ) <NEWLINE> <NL> <DEDENT> print ( * ans [ 2 : ( n + 1 ) ] , sep = <STRING> ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if ( i == 0 ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l2 , r2 = map ( int , input ( ) . split ( ) ) <NEWLINE> l = max ( l , l2 ) <NEWLINE> r = min ( r , r2 ) <NEWLINE> <DEDENT> <DEDENT> if ( l > r ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r - l + 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> score = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> adj_list = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> adj_list [ A - 1 ] . append ( B - 1 ) <NEWLINE> adj_list [ B - 1 ] . append ( A - 1 ) <NEWLINE> <NL> <DEDENT> score_ = 0 <NEWLINE> for i , adjs in enumerate ( adj_list ) : <NEWLINE> <INDENT> is_max = True <NEWLINE> for adj in adjs : <NEWLINE> <INDENT> if score [ i ] <= score [ adj ] : <NEWLINE> <INDENT> is_max = False <NEWLINE> <DEDENT> <DEDENT> if is_max : <NEWLINE> <INDENT> score_ += 1 <NEWLINE> <DEDENT> <DEDENT> print ( score_ ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> x = len ( S ) <NEWLINE> if <STRING> in S : <NEWLINE> <INDENT> y0 = S . count ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y0 = 0 <NEWLINE> <DEDENT> if <STRING> in S : <NEWLINE> <INDENT> y1 = S . count ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y1 = 0 <NEWLINE> <NL> <DEDENT> d = abs ( y0 - y1 ) <NEWLINE> print ( x - d ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> rgb = [ 0 , 0 , 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> if l [ i ] == rgb [ j ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> p = rgb . index ( l [ i ] ) <NEWLINE> if not 0 <= p <= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> rgb [ p ] += 1 <NEWLINE> ans *= c <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( h ) ] <NEWLINE> <NL> t = np . zeros ( ( h , w ) , dtype = np . int32 ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> t [ i ] [ j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> l = np . zeros ( ( h , w ) , dtype = np . int32 ) <NEWLINE> r = np . zeros ( ( h , w ) , dtype = np . int32 ) <NEWLINE> u = np . zeros ( ( h , w ) , dtype = np . int32 ) <NEWLINE> d = np . zeros ( ( h , w ) , dtype = np . int32 ) <NEWLINE> <NL> for i in range ( w ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> l [ : , i ] = t [ : , i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ : , i ] = ( l [ : , i - 1 ] + 1 ) * t [ : , i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( w - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if i == w - 1 : <NEWLINE> <INDENT> r [ : , i ] = t [ : , i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r [ : , i ] = ( r [ : , i + 1 ] + 1 ) * t [ : , i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> u [ i ] = t [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> u [ i ] = ( u [ i - 1 ] + 1 ) * t [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( h - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if i == h - 1 : <NEWLINE> <INDENT> d [ i ] = t [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] = ( d [ i + 1 ] + 1 ) * t [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> lrud = l + r + u + d - 3 <NEWLINE> print ( np . max ( lrud ) ) <NEWLINE>
from math import floor <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> print ( floor ( a * x / b ) - a * floor ( x / b ) ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for _ in range ( m ) ] ) <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if 1 in a and 2 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif 1 in a : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> dp [ 2 ] = 1 <NEWLINE> <DEDENT> elif 2 in a : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> dp [ 2 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> dp [ 2 ] = 2 <NEWLINE> <NL> <DEDENT> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % MOD <NEWLINE> <DEDENT> <DEDENT> print ( dp [ - 1 ] % MOD ) <NEWLINE>
import numpy as np <NEWLINE> from itertools import combinations_with_replacement <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> rgb = <STRING> <NEWLINE> <NL> nr = S . count ( rgb [ 0 ] ) <NEWLINE> ng = S . count ( rgb [ 1 ] ) <NEWLINE> nb = N - nr - ng <NEWLINE> nlst = np . array ( [ nr , ng , nb ] ) <NEWLINE> <NL> nmax = np . argmax ( nlst ) <NEWLINE> nmin = np . argmin ( nlst ) <NEWLINE> if nmax == nmin : nmin = 2 <NEWLINE> <NL> minlst , midlst = [ ] , [ ] <NEWLINE> maxlst = [ 0 ] * N <NEWLINE> <NL> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if s == rgb [ nmax ] : maxlst [ i ] = 1 <NEWLINE> elif s == rgb [ nmin ] : minlst . append ( i ) <NEWLINE> else : midlst . append ( i ) <NEWLINE> <DEDENT> minlst . sort ( ) <NEWLINE> midlst . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for midl in midlst : <NEWLINE> <INDENT> for minl in minlst : <NEWLINE> <INDENT> mm = abs ( midl - minl ) <NEWLINE> mmin = min ( minl , midl ) - mm <NEWLINE> mmax = max ( minl , midl ) + mm <NEWLINE> if mmin >= 0 : <NEWLINE> <INDENT> if maxlst [ mmin ] : ans += 1 <NEWLINE> <DEDENT> if mmax <= N - 1 : <NEWLINE> <INDENT> if maxlst [ mmax ] : ans += 1 <NEWLINE> <DEDENT> if mm % 2 == 0 and maxlst [ ( minl + midl ) // 2 ] : ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( nr * ng * nb - ans ) <NEWLINE>
MOD = 998244353 <NEWLINE> <NL> <NL> class Combination : <NEWLINE> <COMMENT> <NL> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . fac = [ 1 ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> self . fac [ i ] = ( self . fac [ i - 1 ] * i ) % MOD <NEWLINE> <DEDENT> self . invmod = [ 1 ] * ( N + 1 ) <NEWLINE> <COMMENT> <NL> self . invmod [ N ] = pow ( self . fac [ N ] , MOD - 2 , MOD ) <NEWLINE> for i in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> self . invmod [ i - 1 ] = ( self . invmod [ i ] * i ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> def calc ( self , n , k ) : <COMMENT> <NEWLINE> <INDENT> return self . fac [ n ] * self . invmod [ k ] % MOD * self . invmod [ n - k ] % MOD <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> C = Combination ( N ) <NEWLINE> <NL> ans = 0 <NEWLINE> for k in range ( K + 1 ) : <NEWLINE> <INDENT> tmp = C . calc ( N - 1 , N - k - 1 ) * M * pow ( M - 1 , N - k - 1 , MOD ) % MOD <NEWLINE> ans = ( ans + tmp ) % MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> A = abs ( abs ( x ) - abs ( y ) ) <NEWLINE> <NL> if x * y > 0 : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> B = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = 2 <NEWLINE> <DEDENT> <DEDENT> elif x == 0 : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> B = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = 1 <NEWLINE> <DEDENT> <DEDENT> elif y == 0 : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> B = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> B = 1 <NEWLINE> <NL> <DEDENT> print ( A + B ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> sub_list = [ list ( input ( ) . split ( ) ) for _ in range ( m ) ] <NEWLINE> <NL> penalty_list = [ 0 ] * n <COMMENT> <NEWLINE> result_list = [ 0 ] * n <COMMENT> <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> if sub_list [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> result_list [ int ( sub_list [ i ] [ 0 ] ) - 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if result_list [ int ( sub_list [ i ] [ 0 ] ) - 1 ] == 0 : <NEWLINE> <INDENT> penalty_list [ int ( sub_list [ i ] [ 0 ] ) - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ac_count = 0 <NEWLINE> wa_count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if result_list [ i ] == 1 : <NEWLINE> <INDENT> ac_count += 1 <NEWLINE> wa_count += penalty_list [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] , reverse = True ) <NEWLINE> if A [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> m *= a <NEWLINE> if m > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( m if m <= 10 ** 18 else - 1 ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( k , len ( l ) ) : <NEWLINE> <INDENT> if l [ i ] <= l [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> if x - d * k >= 0 : <NEWLINE> <INDENT> print ( abs ( x - d * k ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = x // d <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> if a % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( x - d * a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x - d * ( a + 1 ) ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( x - d * ( a + 1 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x - d * a ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
i = str ( input ( ) ) <NEWLINE> w = <STRING> <NEWLINE> for let in i : <NEWLINE> <INDENT> if ( let == let . upper ( ) ) : <NEWLINE> <INDENT> w = w + let . lower ( ) <NEWLINE> <DEDENT> elif ( let == let . lower ( ) ) : <NEWLINE> <INDENT> w = w + let . upper ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w = w + let <NEWLINE> <DEDENT> <DEDENT> print ( w ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> num = 10 ** N - 2 * ( 9 ** N ) + 8 ** N <NEWLINE> print ( num % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL>
from collections import deque <NEWLINE> n , m = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> F = [ { } for i in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> i , j = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> F [ i ] [ j ] = 1 <NEWLINE> F [ j ] [ i ] = 1 <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> DP = [ 0 for i in range ( n ) ] <NEWLINE> c = 1 <NEWLINE> d = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not DP [ i ] : <NEWLINE> <INDENT> d . append ( i ) <NEWLINE> <DEDENT> while ( len ( d ) > 0 ) : <NEWLINE> <INDENT> tmp = d . pop ( ) <NEWLINE> DP [ tmp ] = c <NEWLINE> for i in F [ tmp ] : <NEWLINE> <INDENT> if not DP [ i ] : <NEWLINE> <INDENT> d . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> c += 1 <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> s , t = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if DP [ s ] == DP [ t ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> backList = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> backList . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> def capa ( p , k ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> pcopy = p <NEWLINE> num = 0 <NEWLINE> for back in backList : <NEWLINE> <INDENT> if back > p : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if back <= pcopy : <NEWLINE> <INDENT> pcopy -= back <NEWLINE> cnt += 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif back > pcopy : <NEWLINE> <INDENT> if num == k - 1 : <NEWLINE> <INDENT> return cnt <NEWLINE> <DEDENT> pcopy = p - back <NEWLINE> cnt += 1 <NEWLINE> num += 1 <NEWLINE> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> p_min = 0 <NEWLINE> p_max = 100000 * 10000 <NEWLINE> def biSearch ( p_min , p_max ) : <NEWLINE> <INDENT> p = p_max - p_min <NEWLINE> if p_max - p_min <= 1 : <NEWLINE> <INDENT> return p_max <NEWLINE> <DEDENT> if p % 2 == 0 : <NEWLINE> <INDENT> c = p_min + int ( p / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = p_min + int ( ( p + 1 ) / 2 ) <NEWLINE> <DEDENT> v = capa ( c , k ) <NEWLINE> if v < n : <NEWLINE> <INDENT> p_min = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p_max = c <NEWLINE> <NL> <DEDENT> return biSearch ( p_min , p_max ) <NEWLINE> <NL> <NL> <DEDENT> p = biSearch ( p_min , p_max ) <NEWLINE> n_init = n <NEWLINE> while n_init <= n : <NEWLINE> <INDENT> p -= 1 <NEWLINE> n = capa ( p , k ) <NEWLINE> <NL> <DEDENT> print ( p + 1 ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> s = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s [ i ] = input ( ) <NEWLINE> <DEDENT> print ( len ( set ( s ) ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> k = int ( x , 2 ) <NEWLINE> p = x . count ( <STRING> ) <NEWLINE> if p > 1 : <NEWLINE> <INDENT> kp0 = k % ( p - 1 ) <NEWLINE> <DEDENT> kp1 = k % ( p + 1 ) <NEWLINE> f = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> f [ i ] = f [ i % bin ( i ) . count ( <STRING> ) ] + 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> pi = p - 1 <NEWLINE> if pi == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> print ( f [ ( kp0 - pow ( 2 , n - i - 1 , pi ) ) % pi ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pi = p + 1 <NEWLINE> print ( f [ ( kp1 + pow ( 2 , n - i - 1 , pi ) ) % pi ] + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> MAX = 10 ** 18 <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> result = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> result *= A [ i ] <NEWLINE> if result > MAX : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> homework_day = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> homework_day = homework_day + A [ i ] <NEWLINE> <DEDENT> if homework_day > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - homework_day ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> def GCD ( x , y ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> if x < y : <NEWLINE> <INDENT> d = y <NEWLINE> y = x <NEWLINE> x = d <NEWLINE> <DEDENT> if y == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> GCD ( y , x % y ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> x = int ( a . split ( <STRING> ) [ 0 ] ) <NEWLINE> y = int ( a . split ( <STRING> ) [ 1 ] ) <NEWLINE> GCD ( x , y ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( min ( n % k , abs ( n % k - k ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> X = sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> def popcount ( n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> cnt += n & 1 <NEWLINE> n //= 2 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def f ( n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while n != 0 : <NEWLINE> <INDENT> n = n % popcount ( n ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> pcnt = X . count ( <STRING> ) <NEWLINE> MOD1 = pcnt + 1 <NEWLINE> MOD2 = pcnt - 1 <NEWLINE> <NL> nXp = 0 <NEWLINE> nXm = 0 <NEWLINE> <NL> pow1 = [ 1 ] * N <NEWLINE> pow2 = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> pow1 [ i ] = ( pow1 [ i - 1 ] * 2 ) % MOD1 <NEWLINE> <DEDENT> if MOD2 != 0 : <NEWLINE> <INDENT> pow2 [ 0 ] = 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> pow2 [ i ] = ( pow2 [ i - 1 ] * 2 ) % MOD2 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> nXp += pow1 [ N - 1 - i ] <NEWLINE> <DEDENT> <DEDENT> nXp %= MOD1 <NEWLINE> <NL> if MOD2 != 0 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> nXm += pow2 [ N - 1 - i ] <NEWLINE> <NL> <DEDENT> <DEDENT> nXm %= MOD2 <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 0 , N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> k = ( nXp + pow1 [ N - 1 - i ] ) % MOD1 <NEWLINE> print ( f ( k ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if MOD2 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = ( nXm - pow2 [ N - 1 - i ] ) % MOD2 <NEWLINE> print ( f ( k ) + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> from collections import defaultdict <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> As = np . array ( [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> mods = As % K <NEWLINE> csum_mods = np . cumsum ( mods ) <NEWLINE> magic_array = ( csum_mods - np . arange ( 0 , N + 1 ) ) % K <NEWLINE> <NL> indices = defaultdict ( list ) <NEWLINE> for i , m in enumerate ( magic_array . tolist ( ) ) : <NEWLINE> <INDENT> indices [ m ] . append ( i ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for ls in indices . values ( ) : <NEWLINE> <INDENT> j = 1 <NEWLINE> for i in range ( len ( ls ) ) : <NEWLINE> <INDENT> while j < len ( ls ) : <NEWLINE> <INDENT> if ls [ j ] - ls [ i ] < K : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans += j - i - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ input ( ) for _ in range ( h ) ] <NEWLINE> visited = [ [ 0 ] * w for _ in range ( h ) ] <NEWLINE> moves = ( ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if not visited [ i ] [ j ] : <NEWLINE> <INDENT> bcnt , wcnt = 0 , 0 <NEWLINE> q = deque ( [ ( i , j ) ] ) <NEWLINE> while q : <NEWLINE> <INDENT> cx , cy = q . popleft ( ) <NEWLINE> if visited [ cx ] [ cy ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if grid [ cx ] [ cy ] == <STRING> : <NEWLINE> <INDENT> bcnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wcnt += 1 <NEWLINE> <DEDENT> visited [ cx ] [ cy ] = 1 <NEWLINE> for ( dx , dy ) in moves : <NEWLINE> <INDENT> if 0 <= cx + dx < h and 0 <= cy + dy < w and not visited [ cx + dx ] [ cy + dy ] and grid [ cx + dx ] [ cy + dy ] != grid [ cx ] [ cy ] : <NEWLINE> <INDENT> q . append ( ( cx + dx , cy + dy ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans += bcnt * wcnt <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) ; <NEWLINE> ans = 1 ; <NEWLINE> <NL> x = 10 ** 18 <NEWLINE> flag = 0 ; <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> if ans > x : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from __future__ import division , print_function <NEWLINE> from sys import stdin <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> num_mat = int ( stdin . readline ( ) ) <NEWLINE> r = [ int ( s ) for s in stdin . readline ( ) . split ( ) ] <NEWLINE> for _ in range ( num_mat - 1 ) : <NEWLINE> <INDENT> _ , row = ( int ( s ) for s in stdin . readline ( ) . split ( ) ) <NEWLINE> r . append ( row ) <NEWLINE> <NL> <DEDENT> if num_mat < 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> elif num_mat < 3 : <NEWLINE> <INDENT> print ( r [ 0 ] * r [ 1 ] * r [ 2 ] ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> M = [ ] <NEWLINE> M . append ( [ 0 ] * num_mat ) <NEWLINE> M . append ( [ r [ i ] * r [ i + 1 ] * r [ i + 2 ] for i in range ( len ( M [ - 1 ] ) - 1 ) ] ) <NEWLINE> <NL> for i in range ( 2 , num_mat ) : <NEWLINE> <INDENT> N = [ ] <NEWLINE> for j in range ( num_mat - i ) : <NEWLINE> <INDENT> N . append ( min ( M [ k ] [ j ] + M [ i - 1 - k ] [ 1 + j + k ] + r [ j ] * r [ 1 + j + k ] * r [ i + 1 + j ] <NEWLINE> <INDENT> for k in range ( i ) ) ) <NEWLINE> <DEDENT> <DEDENT> M . append ( N ) <NEWLINE> <DEDENT> print ( M [ - 1 ] [ 0 ] ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
N , K , * p = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> sortp = sorted ( p ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in range ( K ) : <NEWLINE> <INDENT> ans += sortp [ x ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_count_list = collections . Counter ( A_list ) <NEWLINE> A_sum = sum ( A_list ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> A_sum += ( C - B ) * A_count_list [ B ] <NEWLINE> A_count_list [ C ] += A_count_list [ B ] <NEWLINE> A_count_list [ B ] = 0 <NEWLINE> print ( A_sum ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> answer = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> answer = answer * i % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( answer ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> m = max ( A ) + 1 <NEWLINE> dp = [ 1 ] * m <NEWLINE> for a in A : <NEWLINE> <INDENT> if dp [ a - 1 ] == 1 : <NEWLINE> <INDENT> dp [ a - 1 ] = 2 <NEWLINE> for i in range ( a * 2 , m , a ) : <NEWLINE> <INDENT> dp [ i - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> elif dp [ a - 1 ] == 2 : <NEWLINE> <INDENT> dp [ a - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( [ 1 for a in A if dp [ a - 1 ] ] ) ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> index_lst = [ ] <NEWLINE> grid_0 = [ 0 ] * ( W + 1 ) <NEWLINE> grid_0 [ 1 ] = 1 <NEWLINE> for _ in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> grid_1 = [ 0 ] * ( W + 1 ) <NEWLINE> for i , j in enumerate ( input ( ) , 1 ) : <NEWLINE> <INDENT> if j == <STRING> : <NEWLINE> <INDENT> grid_1 [ i ] = ( grid_0 [ i ] + grid_1 [ i - 1 ] ) % m <NEWLINE> <DEDENT> <DEDENT> grid_0 = grid_1 <NEWLINE> <NL> <DEDENT> print ( grid_0 [ - 1 ] ) <NEWLINE>
def pluss_zero ( a , L ) : <NEWLINE> <INDENT> a = str ( a ) <NEWLINE> while len ( a ) < L : <NEWLINE> <INDENT> a = <STRING> + a <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def make_maxminnum ( a ) : <NEWLINE> <INDENT> a = list ( a ) <NEWLINE> a . sort ( ) <NEWLINE> maxa = int ( <STRING> . join ( a [ : : - 1 ] ) ) <NEWLINE> mina = int ( <STRING> . join ( a ) ) <NEWLINE> return maxa - mina <NEWLINE> <NL> <DEDENT> ans_list = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> a , L = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and L == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a_list = [ a ] <NEWLINE> for i in range ( 21 ) : <NEWLINE> <INDENT> a = make_maxminnum ( pluss_zero ( a , L ) ) <NEWLINE> a_list . append ( a ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 21 ) : <NEWLINE> <INDENT> for j in range ( 21 ) : <NEWLINE> <INDENT> if i < j and a_list [ i ] == a_list [ j ] : <NEWLINE> <INDENT> ans = [ str ( i ) , str ( a_list [ i ] ) , str ( j - i ) ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans_list . append ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in ans_list : <NEWLINE> <COMMENT> <NL> <INDENT> print ( <STRING> . join ( i ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> lis = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> lis [ A ] . append ( B ) <NEWLINE> lis [ B ] . append ( A ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> seen = [ False ] * ( N + 1 ) <NEWLINE> def dfs ( v , graph ) : <NEWLINE> <INDENT> global cnt <NEWLINE> seen [ v ] = True <NEWLINE> for next_v in graph [ v ] : <NEWLINE> <INDENT> if seen [ next_v ] == True : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if seen [ next_v ] == [ ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> dfs ( next_v , graph ) <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> ma = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> if seen [ j ] == True : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ma = max ( ma , dfs ( j , lis ) ) <NEWLINE> <DEDENT> print ( ma + 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> d = { <NEWLINE> <INDENT> <STRING> : { } , <NEWLINE> <STRING> : { } , <NEWLINE> <STRING> : { } <NEWLINE> <DEDENT> } <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> d [ s ] [ i ] = True <NEWLINE> <DEDENT> answer = len ( d [ <STRING> ] ) * len ( d [ <STRING> ] ) * len ( d [ <STRING> ] ) <NEWLINE> for r in d [ <STRING> ] . keys ( ) : <NEWLINE> <INDENT> for g in d [ <STRING> ] . keys ( ) : <NEWLINE> <INDENT> if 2 * r - g in d [ <STRING> ] : <NEWLINE> <INDENT> answer -= 1 <NEWLINE> <DEDENT> if 2 * g - r in d [ <STRING> ] : <NEWLINE> <INDENT> answer -= 1 <NEWLINE> <DEDENT> if ( ( r + g ) % 2 == 0 and ( ( r + g ) // 2 ) in d [ <STRING> ] ) : <NEWLINE> <INDENT> answer -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
import math <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = list ( str ( input ( ) ) ) <NEWLINE> T = list ( str ( input ( ) ) ) <NEWLINE> g = math . gcd ( N , M ) <NEWLINE> gn , gm = N // g , M // g <NEWLINE> for i in range ( g ) : <NEWLINE> <INDENT> if S [ i * gn ] != T [ i * gm ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( gn * gm * g ) <NEWLINE>
inp = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> while inp [ 1 ] >= inp [ 0 ] : <NEWLINE> <INDENT> a = inp [ 1 ] % inp [ 0 ] <NEWLINE> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> inp [ 1 ] = inp [ 0 ] <NEWLINE> inp [ 0 ] = a <NEWLINE> <NL> <DEDENT> print ( inp [ 0 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> ci = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <DEDENT> S . sort ( ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] != S [ i + 1 ] : <NEWLINE> <INDENT> ci += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ci ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> p *= i <NEWLINE> if p > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
def subset_sum ( s , a ) : <NEWLINE> <INDENT> dict = { } <NEWLINE> return subset_rec ( 0 , s , a , dict ) <NEWLINE> <NL> <DEDENT> def subset_rec ( i , s , a , dict ) : <NEWLINE> <INDENT> key = str ( i ) + <STRING> + str ( s ) <NEWLINE> ret = False <NEWLINE> if key in dict : <NEWLINE> <INDENT> ret = dict [ key ] <NEWLINE> <DEDENT> elif s == 0 : <NEWLINE> <INDENT> ret = True <NEWLINE> <DEDENT> elif i >= len ( a ) : <NEWLINE> <INDENT> ret = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = subset_rec ( i + 1 , s - a [ i ] , a , dict ) or subset_rec ( i + 1 , s , a , dict ) <NEWLINE> <DEDENT> dict [ key ] = ret <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = int ( input ( ) ) <NEWLINE> q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( p ) : <NEWLINE> <INDENT> if subset_sum ( q [ i ] , a ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = ( S - h * 3600 ) // 60 <NEWLINE> s = S - h * 3600 - m * 60 <NEWLINE> <NL> print ( str ( h ) + <STRING> + str ( m ) + <STRING> + str ( s ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> <NL> <NL> def dfs ( s ) : <NEWLINE> <INDENT> for i in to [ s ] : <NEWLINE> <INDENT> if not toflag [ i ] : <NEWLINE> <INDENT> toflag [ i ] = True <NEWLINE> dfs ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def rdfs ( s ) : <NEWLINE> <INDENT> for i in ot [ s ] : <NEWLINE> <INDENT> if not otflag [ i ] : <NEWLINE> <INDENT> otflag [ i ] = True <NEWLINE> rdfs ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def bellman_ford ( ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> upd = False <NEWLINE> for a , b , c in edges : <NEWLINE> <INDENT> if d [ b ] > d [ a ] + c : <NEWLINE> <INDENT> upd = True <NEWLINE> d [ b ] = d [ a ] + c <NEWLINE> <DEDENT> <DEDENT> if not upd : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i == n - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b , c = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> edges . append ( [ a , b , - ( c + 1 - p ) ] ) <NEWLINE> to [ a ] . append ( b ) <NEWLINE> ot [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> toflag [ 0 ] = True <NEWLINE> otflag [ n - 1 ] = True <NEWLINE> dfs ( 0 ) <COMMENT> <NEWLINE> rdfs ( n - 1 ) <COMMENT> <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b , c = edges [ i ] <NEWLINE> if toflag [ a ] and otflag [ a ] and toflag [ b ] and otflag [ b ] : continue ; <NEWLINE> edges [ i ] = [ 0 , 0 , 0 ] <NEWLINE> <NL> <DEDENT> d [ 0 ] = 0 <NEWLINE> bellman_ford ( ) <NEWLINE> print ( max ( 0 , - d [ - 1 ] ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m , p = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ ] <NEWLINE> to = [ [ ] for i in range ( n ) ] <NEWLINE> ot = [ [ ] for i in range ( n ) ] <NEWLINE> toflag = [ False ] * n <NEWLINE> otflag = [ False ] * n <NEWLINE> d = [ 10 ** 9 ] * n <NEWLINE> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import numpy as np <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if 10 ** 18 < ans : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = 10005 <NEWLINE> f = [ 0 ] * 10005 <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) ) : <NEWLINE> <INDENT> a = n - i ** 2 <NEWLINE> if a >= 1 : <NEWLINE> <INDENT> for j in range ( 1 , int ( a ** 0.5 ) ) : <NEWLINE> <INDENT> b = n - i ** 2 - j ** 2 <NEWLINE> if b >= 1 : <NEWLINE> <INDENT> for k in range ( 1 , int ( b ** 0.5 ) ) : <NEWLINE> <INDENT> c = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> if c <= 10001 : <NEWLINE> <INDENT> f [ c ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( f [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> nr = s . count ( <STRING> ) <NEWLINE> ng = s . count ( <STRING> ) <NEWLINE> nb = s . count ( <STRING> ) <NEWLINE> ans = nr * ng * nb <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if n <= k or k <= j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans - cnt ) <NEWLINE>
<STRING> <NEWLINE> K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> Z = S - i - j <NEWLINE> if 0 <= Z <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from decimal import Decimal , ROUND_DOWN , getcontext <NEWLINE> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> getcontext ( ) . prec = 19 <NEWLINE> getcontext ( ) . rounding = ROUND_DOWN <NEWLINE> x = Decimal ( a ) <NEWLINE> y = Decimal ( b ) <NEWLINE> print ( <STRING> . format ( Decimal ( int ( x * y ) ) , rounding = ROUND_DOWN ) ) <NEWLINE> <NL> <NL>
MOD = 998244353 <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 1 <NEWLINE> cnt = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> cnt += c * m * pow ( m - 1 , n - 1 - x , MOD ) <NEWLINE> cnt %= MOD <NEWLINE> c *= ( n - x - 1 ) * pow ( x + 1 , MOD - 2 , MOD ) <NEWLINE> c %= MOD <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> aa = sorted ( a ) <NEWLINE> th = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( len ( aa ) ) : <NEWLINE> <INDENT> if aa [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> ans *= aa [ i ] <NEWLINE> if ans > th : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> if i == len ( aa ) - 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
from numba import njit <NEWLINE> @ njit ( cache = True ) <NEWLINE> def func ( n , k , a ) : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> b = [ ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> b . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> l = max ( 0 , i - a [ i ] ) <NEWLINE> r = min ( n , i + a [ i ] + 1 ) <NEWLINE> b [ l ] += 1 <NEWLINE> b [ r ] -= 1 <NEWLINE> <DEDENT> for i in range ( len ( b ) - 1 ) : <NEWLINE> <INDENT> b [ i + 1 ] += b [ i ] <NEWLINE> <DEDENT> b = b [ : n ] <NEWLINE> if a == b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = b <NEWLINE> <DEDENT> <DEDENT> return b <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = func ( n , k , a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( b [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
f = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> n , m = f ( ) <NEWLINE> p = [ - 1 ] * n <NEWLINE> def root ( x ) : <NEWLINE> <INDENT> while p [ x ] >= 0 : x = p [ x ] <NEWLINE> return x <NEWLINE> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x , y = root ( x ) , root ( y ) <NEWLINE> if x == y : return <NEWLINE> if x > y : x , y = y , x <NEWLINE> p [ x ] += p [ y ] <NEWLINE> p [ y ] = x <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = f ( ) <NEWLINE> unite ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> print ( - min ( p ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> h = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> h . append ( int ( input ( ) ) + h [ i ] ) <NEWLINE> <DEDENT> w = [ 0 ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> w . append ( int ( input ( ) ) + w [ i ] ) <NEWLINE> <NL> <DEDENT> hDict = { } <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = abs ( h [ i ] - h [ j ] ) <NEWLINE> if diff in hDict : <NEWLINE> <INDENT> hDict [ diff ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hDict [ diff ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> wDict = { } <NEWLINE> for i in range ( m + 1 ) : <NEWLINE> <INDENT> for j in range ( i , m + 1 ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = abs ( w [ i ] - w [ j ] ) <NEWLINE> if diff in wDict : <NEWLINE> <INDENT> wDict [ diff ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wDict [ diff ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for diff in hDict . keys ( ) : <NEWLINE> <INDENT> if diff in wDict : <NEWLINE> <INDENT> ans += hDict [ diff ] * wDict [ diff ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from decimal import Decimal <NEWLINE> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> log2 = [ 0 ] * ( N + 1 ) <NEWLINE> log5 = [ 0 ] * ( N + 1 ) <NEWLINE> acc = [ [ 0 for i in range ( 19 ) ] for j in range ( 19 ) ] <NEWLINE> Ans = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> wk = Decimal ( input ( ) ) <NEWLINE> wk = int ( wk * 1000000000 ) <NEWLINE> <NL> <COMMENT> <NL> for cnt in range ( 1 , 19 ) : <NEWLINE> <INDENT> if wk % 2 == 0 : <NEWLINE> <INDENT> log2 [ i ] += 1 <NEWLINE> wk = wk // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for cnt in range ( 1 , 19 ) : <NEWLINE> <INDENT> if wk % 5 == 0 : <NEWLINE> <INDENT> log5 [ i ] += 1 <NEWLINE> wk = wk // 5 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> acc [ log2 [ i ] ] [ log5 [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 0 , 19 ) : <NEWLINE> <INDENT> for j in range ( 0 , 19 ) : <NEWLINE> <INDENT> for k in range ( i , 19 ) : <NEWLINE> <INDENT> for l in range ( 0 , 19 ) : <NEWLINE> <INDENT> if ( i + k ) >= 18 and ( j + l ) >= 18 and ( i < k or ( i == k and j <= l ) ) : <NEWLINE> <INDENT> if acc [ i ] [ j ] > 0 and acc [ k ] [ l ] > 0 : <NEWLINE> <INDENT> Ans += acc [ i ] [ j ] * acc [ k ] [ l ] <NEWLINE> if i >= 9 and j >= 9 and i == k and j == l : <NEWLINE> <INDENT> Ans -= int ( ( acc [ i ] [ j ] * ( acc [ i ] [ j ] + 1 ) ) / 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( int ( Ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> s = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( a ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> file_input = sys . stdin <NEWLINE> <NL> H , W , N = map ( int , file_input . readline ( ) . split ( ) ) <NEWLINE> <NL> town_map = file_input . read ( ) <NEWLINE> <NL> start_index = town_map . index ( <STRING> ) <NEWLINE> <NL> mouse = [ start_index , 0 ] <NEWLINE> <COMMENT> <NL> <NL> from collections import deque <NEWLINE> <NL> for goal in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> q = deque ( ) <NEWLINE> unvisited = [ True ] * len ( town_map ) <NEWLINE> unvisited [ mouse [ 0 ] ] = False <NEWLINE> goal = str ( goal ) <NEWLINE> while True : <NEWLINE> <INDENT> cur_pos = mouse [ 0 ] <NEWLINE> <NL> ew_pos = cur_pos % ( W + 1 ) <NEWLINE> if ew_pos < ( W - 1 ) : <NEWLINE> <INDENT> next_pos = cur_pos + 1 <NEWLINE> lot = town_map [ next_pos ] <NEWLINE> if lot != <STRING> and unvisited [ next_pos ] : <NEWLINE> <INDENT> if lot == goal : <NEWLINE> <INDENT> mouse = [ next_pos , mouse [ 1 ] + 1 ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = [ next_pos , mouse [ 1 ] + 1 ] <NEWLINE> unvisited [ next_pos ] = False <NEWLINE> q . append ( m ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ew_pos > 0 : <NEWLINE> <INDENT> next_pos = cur_pos - 1 <NEWLINE> lot = town_map [ next_pos ] <NEWLINE> if lot != <STRING> and unvisited [ next_pos ] : <NEWLINE> <INDENT> if lot == goal : <NEWLINE> <INDENT> mouse = [ next_pos , mouse [ 1 ] + 1 ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = [ next_pos , mouse [ 1 ] + 1 ] <NEWLINE> unvisited [ next_pos ] = False <NEWLINE> q . append ( m ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ns_pos = cur_pos // ( W + 1 ) <NEWLINE> if ns_pos < ( H - 1 ) : <NEWLINE> <INDENT> next_pos = cur_pos + W + 1 <NEWLINE> lot = town_map [ next_pos ] <NEWLINE> if lot != <STRING> and unvisited [ next_pos ] : <NEWLINE> <INDENT> if lot == goal : <NEWLINE> <INDENT> mouse = [ next_pos , mouse [ 1 ] + 1 ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = [ next_pos , mouse [ 1 ] + 1 ] <NEWLINE> unvisited [ next_pos ] = False <NEWLINE> q . append ( m ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ns_pos > 0 : <NEWLINE> <INDENT> next_pos = cur_pos - W - 1 <NEWLINE> lot = town_map [ next_pos ] <NEWLINE> if lot != <STRING> and unvisited [ next_pos ] : <NEWLINE> <INDENT> if lot == goal : <NEWLINE> <INDENT> mouse = [ next_pos , mouse [ 1 ] + 1 ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = [ next_pos , mouse [ 1 ] + 1 ] <NEWLINE> unvisited [ next_pos ] = False <NEWLINE> q . append ( m ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> mouse = q . popleft ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mouse [ 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> cnt += ( n - 1 ) // i <NEWLINE> <COMMENT> <NL> <DEDENT> print ( cnt ) <NEWLINE>
import random , math <NEWLINE> random . seed ( ) <NEWLINE> def gen ( a , b , num ) : <NEWLINE> <INDENT> result = set ( ) <NEWLINE> while 1 : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> v = random . randint ( a , b ) // 2 * 2 + 1 <NEWLINE> if v not in result : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for x in range ( 3 , int ( math . sqrt ( v ) ) + 1 , 2 ) : <NEWLINE> <INDENT> if v % x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> result . add ( v ) <NEWLINE> if len ( result ) == num : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return result <NEWLINE> <DEDENT> class RH ( ) : <NEWLINE> <INDENT> def __init__ ( self , s , base , mod ) : <NEWLINE> <INDENT> self . base = base <NEWLINE> self . mod = mod <NEWLINE> self . rev = pow ( base , mod - 2 , mod ) <NEWLINE> <NL> l = len ( s ) <NEWLINE> self . h = h = [ 0 ] * ( l + 1 ) <NEWLINE> tmp = 0 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> num = ord ( s [ i ] ) <NEWLINE> tmp = ( tmp * base + num ) % mod <NEWLINE> h [ i + 1 ] = tmp <NEWLINE> <DEDENT> <DEDENT> def calc ( self , l , r ) : <NEWLINE> <INDENT> return ( self . h [ r ] - self . h [ l ] * pow ( self . base , r - l , self . mod ) ) % self . mod <NEWLINE> <DEDENT> def fixed ( self , length ) : <NEWLINE> <INDENT> v = pow ( self . base , length , self . mod ) <NEWLINE> h = self . h ; mod = self . mod <NEWLINE> def fixed_calc ( l ) : <NEWLINE> <INDENT> return ( h [ length + l ] - h [ l ] * v ) % mod <NEWLINE> <DEDENT> return fixed_calc <NEWLINE> <DEDENT> <DEDENT> class RRH ( ) : <NEWLINE> <INDENT> def __init__ ( self , s , num = 10 , primes = None ) : <NEWLINE> <INDENT> primes = primes or gen ( 2 , 10 ** 3 , num ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> self . rhs = [ RH ( s , p , MOD ) for p in primes ] <NEWLINE> <DEDENT> def calc ( self , l , r ) : <NEWLINE> <INDENT> return [ rh . calc ( l , r ) for rh in self . rhs ] <NEWLINE> <DEDENT> def fixed ( self , length ) : <NEWLINE> <INDENT> fs = [ rh . fixed ( length ) for rh in self . rhs ] <NEWLINE> def multi_fixed_calc ( l ) : <NEWLINE> <INDENT> return list ( f ( l ) for f in fs ) <NEWLINE> <DEDENT> return multi_fixed_calc <NEWLINE> <NL> <DEDENT> <DEDENT> T = input ( ) ; P = input ( ) <NEWLINE> primes = gen ( 2 , 10 ** 3 , 2 ) <NEWLINE> HT = RRH ( T , primes = primes ) <NEWLINE> HP = RRH ( P , primes = primes ) <NEWLINE> <NL> pv = HP . calc ( 0 , len ( P ) ) <NEWLINE> calc = HT . fixed ( len ( P ) ) <NEWLINE> for i in range ( len ( T ) - len ( P ) + 1 ) : <NEWLINE> <INDENT> if calc ( i ) == pv : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C , K = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> score = 0 <NEWLINE> <NL> if K < A : <NEWLINE> <INDENT> score = K <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> score = A <NEWLINE> K = K - A <NEWLINE> if K > 0 and K < B : <NEWLINE> <INDENT> score = score <NEWLINE> <DEDENT> elif K > 0 and K >= B : <NEWLINE> <INDENT> score = score <NEWLINE> K = K - B <NEWLINE> <NL> if K > 0 : <NEWLINE> <INDENT> score = score - K <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( score ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> command = [ 0 for i in range ( n ) ] <NEWLINE> k = [ 0 for i in range ( n ) ] <NEWLINE> k_queue = deque ( [ ] ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> command [ i ] , k [ i ] = s , 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> command [ i ] , k [ i ] = s . split ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if command [ i ] == <STRING> : <NEWLINE> <INDENT> k_queue . appendleft ( k [ i ] ) <NEWLINE> <DEDENT> elif command [ i ] == <STRING> : <NEWLINE> <INDENT> k_queue . popleft ( ) <NEWLINE> <DEDENT> elif command [ i ] == <STRING> : <NEWLINE> <INDENT> k_queue . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : k_queue . remove ( k [ i ] ) <NEWLINE> except ValueError : y = 0 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , k_queue ) ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> h_list = input ( ) . split ( ) <NEWLINE> h_list = [ int ( h ) for h in h_list ] <NEWLINE> <NL> count = 0 <NEWLINE> result_dict = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> key = ( i + 1 ) + h_list [ i ] <NEWLINE> value = result_dict . get ( key , 0 ) <NEWLINE> result_dict [ key ] = value + 1 <NEWLINE> <NL> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> key = ( j + 1 ) - h_list [ j ] <NEWLINE> count += result_dict . get ( key , 0 ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> adj = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> adj [ x ] . append ( y ) <NEWLINE> adj [ y ] . append ( x ) <NEWLINE> <NL> <NL> <DEDENT> def dfs ( v , p ) : <NEWLINE> <INDENT> nim = 0 <NEWLINE> for u in adj [ v ] : <NEWLINE> <INDENT> if u == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> nim ^= dfs ( u , v ) <NEWLINE> <DEDENT> if p == - 1 : <NEWLINE> <INDENT> return nim <NEWLINE> <DEDENT> nim += 1 <NEWLINE> return nim <NEWLINE> <NL> <DEDENT> res = dfs ( 0 , - 1 ) <NEWLINE> <NL> if res : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> arr = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <NL> <INDENT> a = int ( input ( ) ) <NEWLINE> arr . append ( a ) <NEWLINE> <NL> <DEDENT> c = collections . Counter ( arr ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for j in c . values ( ) : <NEWLINE> <INDENT> if j % 2 != 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> w = int ( input ( ) ) <NEWLINE> idx = 0 <NEWLINE> ans = <STRING> <NEWLINE> while idx < len ( S ) : <NEWLINE> <INDENT> ans += S [ idx ] <NEWLINE> idx += w <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> x = s . count ( <STRING> ) <NEWLINE> y = s . count ( <STRING> ) <NEWLINE> print ( min ( x , y ) * 2 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * ( n - k ) <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> ans [ i - k ] = ( a [ i ] > a [ i - k ] ) <NEWLINE> <DEDENT> for i in range ( 0 , n - k ) : <NEWLINE> <INDENT> print ( <STRING> if ans [ i ] else <STRING> ) <NEWLINE> <DEDENT>
N , M = [ int ( s ) for s in input ( ) . split ( <STRING> ) ] <NEWLINE> ac = 0 <NEWLINE> wa = 0 <NEWLINE> result = dict ( ) <NEWLINE> fail = dict ( ) <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( <STRING> ) <NEWLINE> if p in result and result [ p ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> fail [ p ] = fail . get ( p , 0 ) + 1 <NEWLINE> result [ p ] = s <NEWLINE> <DEDENT> elif s == <STRING> : <COMMENT> <NEWLINE> <INDENT> ac += 1 <NEWLINE> wa += fail . get ( p , 0 ) <NEWLINE> result [ p ] = s <NEWLINE> <NL> <DEDENT> <DEDENT> print ( str ( ac ) + <STRING> + str ( wa ) ) <NEWLINE>
M = 10 ** 6 + 1 <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> not_divisible = [ True ] * ( M ) <NEWLINE> <COMMENT> <NL> <NL> result = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> target = A [ i ] <NEWLINE> if not_divisible [ target ] : <NEWLINE> <INDENT> if i + 1 <= N - 1 and A [ i + 1 ] == A [ i ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += 1 <NEWLINE> <DEDENT> for j in range ( target , M , target ) : <NEWLINE> <INDENT> not_divisible [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum_l = sum ( a_list ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> sum_l -= a_list [ i ] <NEWLINE> ans += sum_l * a_list [ i ] <NEWLINE> <DEDENT> print ( ans % 1000000007 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> R , G , B = s . count ( <STRING> ) , s . count ( <STRING> ) , s . count ( <STRING> ) <NEWLINE> ans = R * G * B <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if 2 * j - i > n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ 2 * j - i ] and s [ 2 * j - i ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> e = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> e [ a ] . append ( b ) <NEWLINE> e [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> dist = [ 1000000 ] * n <NEWLINE> ans = [ None ] * n <NEWLINE> not_visited = set ( range ( n ) ) <NEWLINE> not_visited . remove ( 0 ) <NEWLINE> vs = deque ( [ 0 ] ) <NEWLINE> dist [ 0 ] = 0 <NEWLINE> while vs : <NEWLINE> <INDENT> v = vs . popleft ( ) <NEWLINE> for other_side in e [ v ] : <NEWLINE> <INDENT> if other_side in not_visited : <NEWLINE> <INDENT> vs . append ( other_side ) <NEWLINE> not_visited . remove ( other_side ) <NEWLINE> if dist [ other_side ] > dist [ v ] + 1 : <NEWLINE> <INDENT> dist [ other_side ] = dist [ v ] + 1 <NEWLINE> ans [ other_side ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in ans [ 1 : ] : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( a * min ( n , b - 1 ) ) // b ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> out = 0 <NEWLINE> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> c . sort ( ) <NEWLINE> for i in b : <NEWLINE> <INDENT> na = bisect . bisect_left ( a , i ) <NEWLINE> nc = bisect . bisect ( c , i ) <NEWLINE> out += na * ( len ( c ) - nc ) <NEWLINE> <DEDENT> print ( out ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> C = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> C [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( C [ i ] ) <NEWLINE> <DEDENT>
n , t = map ( int , input ( ) . split ( ) ) <NEWLINE> ct = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> ct = [ i [ 0 ] for i in ct if i [ 1 ] <= t ] <NEWLINE> if not ct : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( ct ) ) <NEWLINE> <DEDENT>
import operator <NEWLINE> <NL> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> abs_val_dict = { } <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <NL> <DEDENT> for i in range ( X - N , X + N ) : <NEWLINE> <INDENT> if i not in p : <NEWLINE> <INDENT> abs_val_dict [ i ] = abs ( i - X ) <NEWLINE> <NL> <DEDENT> <DEDENT> if abs_val_dict != { } : <NEWLINE> <INDENT> print ( min ( abs_val_dict . items ( ) , key = operator . itemgetter ( 1 ) ) [ 0 ] ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> double = [ gcd ( i , j ) for i in range ( 1 , k + 1 ) for j in range ( 1 , k + 1 ) ] <NEWLINE> triple = [ gcd ( i , j ) for i in range ( 1 , k + 1 ) for j in double ] <NEWLINE> print ( sum ( triple ) ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> for A in range ( - 118 , 120 ) : <NEWLINE> <INDENT> for B in range ( - 119 , 119 ) : <NEWLINE> <INDENT> A5 = pow ( A , 5 ) <NEWLINE> B5 = pow ( B , 5 ) <NEWLINE> if ( ( A5 - B5 ) == X ) : <NEWLINE> <INDENT> ans = str ( A ) + <STRING> + str ( B ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( A ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i in c . keys ( ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> x = [ ] <NEWLINE> y = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> x += [ i ] <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> y += [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> <NL> while True : <NEWLINE> <INDENT> if len ( y ) == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> elif len ( x ) == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> elif x [ - 1 ] > y [ 0 ] : <NEWLINE> <INDENT> x . pop ( ) <NEWLINE> y . pop ( 0 ) <NEWLINE> ans += 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
L , R = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> c = set ( ) <NEWLINE> <NL> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> t = i % 2019 <NEWLINE> if t in c : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c . add ( t ) <NEWLINE> <NL> <NL> <DEDENT> m = float ( <STRING> ) <NEWLINE> l = list ( c ) <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( l ) ) : <NEWLINE> <INDENT> m = min ( m , l [ i ] * l [ j ] % 2019 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> min = 0 <NEWLINE> new_list = list ( reversed ( a ) ) <NEWLINE> <NL> for i in range ( len ( new_list ) - 1 ) : <NEWLINE> <INDENT> min += new_list [ i ] <NEWLINE> ans += min * new_list [ i + 1 ] <NEWLINE> <NL> <NL> <DEDENT> print ( ans % 1000000007 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ar = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x ^= ar [ i ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ar [ i ] ^ x , end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v0 = v [ 0 : n - 1 : 2 ] <NEWLINE> v1 = v [ 1 : n : 2 ] <NEWLINE> from collections import Counter <NEWLINE> V0 = Counter ( v0 ) <NEWLINE> V1 = Counter ( v1 ) <NEWLINE> if V0 . most_common ( ) [ 0 ] [ 0 ] != V1 . most_common ( ) [ 0 ] [ 0 ] : <NEWLINE> <INDENT> a = V0 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> b = V1 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if V0 . most_common ( ) [ 0 ] [ 1 ] > V1 . most_common ( ) [ 0 ] [ 1 ] : <NEWLINE> <INDENT> if len ( V1 ) > 1 : <NEWLINE> <INDENT> a = V0 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> b = V1 . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = V0 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> b = 0 <NEWLINE> <DEDENT> <DEDENT> elif V0 . most_common ( ) [ 0 ] [ 1 ] < V1 . most_common ( ) [ 0 ] [ 1 ] : <NEWLINE> <INDENT> if len ( V0 ) > 1 : <NEWLINE> <INDENT> a = V1 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> b = V0 . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> b = V1 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if len ( V0 ) == 1 and len ( V1 ) == 1 : <NEWLINE> <INDENT> a = 0 <NEWLINE> b = V0 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> <DEDENT> elif len ( V0 ) == 1 : <NEWLINE> <INDENT> a = V0 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> b = V1 . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <DEDENT> elif len ( V1 ) == 1 : <NEWLINE> <INDENT> a = V0 . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> b = V1 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = V0 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> b = max ( V0 . most_common ( ) [ 1 ] [ 1 ] , V1 . most_common ( ) [ 1 ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( n - a - b ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 1 <NEWLINE> flag = 0 <NEWLINE> zero_flag = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> zero_flag = 1 <NEWLINE> result = 0 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = result * a <NEWLINE> if result > pow ( 10 , 18 ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> result = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag == 1 and zero_flag != 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = [ 1 ] * N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ a - 1 ] <= H [ b - 1 ] : <NEWLINE> <INDENT> result [ a - 1 ] *= 0 <NEWLINE> <DEDENT> if H [ a - 1 ] >= H [ b - 1 ] : <NEWLINE> <INDENT> result [ b - 1 ] *= 0 <NEWLINE> <DEDENT> <DEDENT> print ( result . count ( 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> state = 1 <NEWLINE> chklist = [ 0 ] * ( N + 1 ) <NEWLINE> chklist_flag = [ False ] * ( N + 1 ) <NEWLINE> <NL> chkmod = 0 <NEWLINE> chkrem = K <NEWLINE> <NL> chklist_flag [ 0 ] = True <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> state = A [ state - 1 ] <NEWLINE> if chklist_flag [ state - 1 ] : <NEWLINE> <INDENT> chkmod = ( K - chklist [ state - 1 ] ) % ( i - chklist [ state - 1 ] ) <NEWLINE> chkrem = chklist [ state - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> chklist [ state - 1 ] = i <NEWLINE> chklist_flag [ state - 1 ] = True <NEWLINE> <NL> <DEDENT> state = 1 <NEWLINE> <NL> for i in range ( chkrem + chkmod ) : <NEWLINE> <INDENT> state = A [ state - 1 ] <NEWLINE> <NL> <DEDENT> print ( state ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import math <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def isOK ( minVal ) : <NEWLINE> <INDENT> tmpK = 0 <NEWLINE> for a in A : <NEWLINE> <COMMENT> <NL> <INDENT> tmpK += ( ( - ( - a // minVal ) ) - 1 ) <NEWLINE> <NL> <DEDENT> if tmpK <= K : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> ok = max ( A ) <NEWLINE> ng = 0 <NEWLINE> <NL> while ( math . ceil ( ok ) != math . ceil ( ng ) ) : <NEWLINE> <INDENT> mid = ( ok + ng ) / 2 <NEWLINE> if isOK ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( math . ceil ( ok ) ) <NEWLINE>
def Qc ( ) : <NEWLINE> <INDENT> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if 0 < n : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> if x - i not in p : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if x + i not in p : <NEWLINE> <INDENT> res = x + 1 <NEWLINE> print ( x + i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Qc ( ) <NEWLINE> <DEDENT>
a , b , c , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> max = 0 <NEWLINE> if ( a >= k ) : <NEWLINE> <INDENT> max = k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max = a <NEWLINE> k -= a <NEWLINE> if ( b >= k ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= b <NEWLINE> max -= k <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> path = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> graph = [ [ ] for _ in range ( n ) ] <NEWLINE> for a , b in path : <NEWLINE> <INDENT> graph [ a - 1 ] . append ( b - 1 ) ; graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> parents = [ - 1 ] * n <NEWLINE> tmparr = [ ] <NEWLINE> children = [ 0 ] <NEWLINE> flags = [ True ] * n <NEWLINE> flags [ 0 ] = False <NEWLINE> <NL> while any ( flags ) : <NEWLINE> <INDENT> while children : <NEWLINE> <INDENT> tmp = children . pop ( ) <NEWLINE> for node in graph [ tmp ] : <NEWLINE> <INDENT> if flags [ node ] : <NEWLINE> <INDENT> flags [ node ] = False <NEWLINE> parents [ node ] = tmp <NEWLINE> tmparr . append ( node ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> children = tmparr [ : ] <NEWLINE> tmparr = [ ] <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for i in parents [ 1 : ] : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> iim = lambda : map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> X = ( 10 ** 18 ) . bit_length ( ) <NEWLINE> <NL> def f ( a , s , n ) : <NEWLINE> <INDENT> if s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> B = [ None ] * X <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> ai , si = a [ i ] , s [ i ] <NEWLINE> <NL> if si == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> x = ai . bit_length ( ) - 1 <NEWLINE> if B [ x ] == ai : break <NEWLINE> elif B [ x ] == None : <NEWLINE> <INDENT> B [ x ] = ai <NEWLINE> break <NEWLINE> <DEDENT> ai ^= B [ x ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> x = ai . bit_length ( ) - 1 <NEWLINE> if B [ x ] == ai : break <NEWLINE> elif B [ x ] == None : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> ai ^= B [ x ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> T = int ( input ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in range ( T ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( iim ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ans . append ( f ( A , S , N ) ) <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> class Node : <NEWLINE> <INDENT> __slots__ = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> def __init__ ( self , value = None , left = None , right = None ) : <NEWLINE> <INDENT> self . value = value <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <DEDENT> <DEDENT> class BinTree : <NEWLINE> <INDENT> __slots__ = [ <STRING> , <STRING> ] <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> self . _tree = None <NEWLINE> <DEDENT> def insert ( self , value ) : <NEWLINE> <INDENT> p = None <NEWLINE> c = self . _tree <NEWLINE> while c is not None : <NEWLINE> <INDENT> p = c <NEWLINE> if value < c . value : <NEWLINE> <INDENT> c = c . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = c . right <NEWLINE> <DEDENT> <DEDENT> if p is None : <NEWLINE> <INDENT> self . _tree = Node ( value ) <NEWLINE> <DEDENT> elif value < p . value : <NEWLINE> <INDENT> p . left = Node ( value ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . right = Node ( value ) <NEWLINE> <DEDENT> <DEDENT> def find ( self , value ) : <NEWLINE> <INDENT> c = self . _tree <NEWLINE> while c is not None : <NEWLINE> <INDENT> if value == c . value : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif value < c . value : <NEWLINE> <INDENT> c = c . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = c . right <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT> def delete ( self , value ) : <NEWLINE> <INDENT> def node_move ( p , c , a ) : <NEWLINE> <INDENT> if p . left == c : <NEWLINE> <INDENT> p . left = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . right = a <NEWLINE> <DEDENT> <DEDENT> p = None <NEWLINE> c = self . _tree <NEWLINE> while c . value != value : <NEWLINE> <INDENT> p = c <NEWLINE> if c is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if value < c . value : <NEWLINE> <INDENT> c = c . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = c . right <NEWLINE> <DEDENT> <DEDENT> if c . left is None : <NEWLINE> <INDENT> node_move ( p , c , c . right ) <NEWLINE> <DEDENT> elif c . right is None : <NEWLINE> <INDENT> node_move ( p , c , c . left ) <NEWLINE> <DEDENT> elif c . right . left is None : <NEWLINE> <INDENT> c . right . left = c . left <NEWLINE> node_move ( p , c , c . right ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q = c . right <NEWLINE> while q . left . left is not None : <NEWLINE> <INDENT> q = q . left <NEWLINE> <DEDENT> c . value = q . left . value <NEWLINE> q . left = q . left . right <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> def preoder_walk ( self ) : <NEWLINE> <INDENT> self . result = [ ] <NEWLINE> def preoder ( node ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> self . result . append ( node . value ) <NEWLINE> preoder ( node . left ) <NEWLINE> preoder ( node . right ) <NEWLINE> <DEDENT> <DEDENT> preoder ( self . _tree ) <NEWLINE> print ( <STRING> + <STRING> . join ( map ( str , self . result ) ) ) <NEWLINE> <DEDENT> def inorder_walk ( self ) : <NEWLINE> <INDENT> self . result = [ ] <NEWLINE> def inorder ( node ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> inorder ( node . left ) <NEWLINE> self . result . append ( node . value ) <NEWLINE> inorder ( node . right ) <NEWLINE> <DEDENT> <DEDENT> inorder ( self . _tree ) <NEWLINE> print ( <STRING> + <STRING> . join ( map ( str , self . result ) ) ) <NEWLINE> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> tree = BinTree ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> com = readline ( ) . split ( ) <NEWLINE> if com [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree . insert ( int ( com [ 1 ] ) ) <NEWLINE> <DEDENT> elif com [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> if tree . find ( int ( com [ 1 ] ) ) else <STRING> ) <NEWLINE> <DEDENT> elif com [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree . delete ( int ( com [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree . inorder_walk ( ) <NEWLINE> tree . preoder_walk ( ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> List . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in List : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> from math import prod <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> s = 1 <NEWLINE> a . sort ( ) <NEWLINE> x = True <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> s = s * a [ i ] <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> x = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if x : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ float ( <STRING> ) ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = h [ i ] <NEWLINE> for j in range ( 1 , min ( k + 1 , n - i ) ) : <NEWLINE> <INDENT> num = dp [ i ] + abs ( a - h [ i + j ] ) <NEWLINE> if num < dp [ i + j ] : <NEWLINE> <INDENT> dp [ i + j ] = num <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
def check ( p , k , arr ) : <NEWLINE> <INDENT> subtotal = 0 <NEWLINE> num_of_tracks = 1 <NEWLINE> for a in arr : <NEWLINE> <INDENT> subtotal += a <NEWLINE> if subtotal > p : <NEWLINE> <INDENT> num_of_tracks += 1 <NEWLINE> if num_of_tracks > k : return False <NEWLINE> subtotal = a <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> min_p = max ( arr ) <NEWLINE> max_p = sum ( arr ) <NEWLINE> while min_p < max_p : <NEWLINE> <INDENT> mid_p = ( min_p + max_p ) // 2 <NEWLINE> if check ( mid_p , k , arr ) : <NEWLINE> <INDENT> max_p = mid_p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_p = mid_p + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min_p ) <NEWLINE>
def binom ( n , r ) : <NEWLINE> <INDENT> if ( r < 0 ) or ( n < r ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return fact [ n ] * factinv [ r ] * factinv [ n - r ] % p <NEWLINE> <NL> <DEDENT> def power ( n , r ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> res *= n <NEWLINE> res %= p <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = 998244353 <NEWLINE> <NL> fact = [ 1 , 1 ] <NEWLINE> factinv = [ 1 , 1 ] <NEWLINE> inv = [ 0 , 1 ] <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % p ) <NEWLINE> inv . append ( ( - inv [ p % i ] * ( p // i ) ) % p ) <NEWLINE> factinv . append ( ( factinv [ - 1 ] * inv [ - 1 ] ) % p ) <NEWLINE> <NL> <DEDENT> num = 0 <NEWLINE> <NL> pw = ( m - 1 ) ** ( n - k - 1 ) % p <NEWLINE> <NL> for i in range ( k + 1 ) : <NEWLINE> <INDENT> num += m * pw * binom ( n - 1 , k - i ) <NEWLINE> num %= p <NEWLINE> pw *= m - 1 <NEWLINE> pw %= p <NEWLINE> <NL> <DEDENT> print ( num ) <NEWLINE>
while True : <NEWLINE> <INDENT> l = input ( ) . split ( ) <NEWLINE> h = int ( l [ 0 ] ) <NEWLINE> w = int ( l [ 1 ] ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if j % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if min ( A ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import heapq <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> Price_List = list ( map ( lambda x : x * ( - 1 ) , map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> heapq . heapify ( Price_List ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> val = heapq . heappop ( Price_List ) * - 1 // 2 * - 1 <NEWLINE> heapq . heappush ( Price_List , val ) <NEWLINE> <DEDENT> print ( - sum ( Price_List ) ) <NEWLINE>
import math <NEWLINE> <NL> <NL> temp = 0 <NEWLINE> K = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for A in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for B in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> temp = math . gcd ( A , B ) <NEWLINE> for C in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum = sum + math . gcd ( temp , C ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL>
from itertools import combinations_with_replacement <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> comb = combinations_with_replacement ( range ( 1 , m + 1 ) , n ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 ] * q ] <NEWLINE> <NL> ans = 0 <NEWLINE> for A in comb : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for a , b , c , d in abcd : <NEWLINE> <INDENT> if A [ b - 1 ] - A [ a - 1 ] == c : <NEWLINE> <INDENT> cnt += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> N , Q = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> tree_list = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = [ int ( n ) - 1 for n in input ( ) . split ( ) ] <NEWLINE> tree_list [ a ] . append ( b ) <NEWLINE> tree_list [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> score_list = [ 0 ] * N <NEWLINE> for j in range ( Q ) : <NEWLINE> <INDENT> p , x = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> score_list [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> reached = [ False ] * N <NEWLINE> def dfs ( v ) : <NEWLINE> <INDENT> reached [ v ] = True <NEWLINE> for next_v in tree_list [ v ] : <NEWLINE> <INDENT> if reached [ next_v ] == True : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> score_list [ next_v ] += score_list [ v ] <NEWLINE> dfs ( next_v ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * score_list ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> C = [ c for c in input ( ) ] <NEWLINE> Red = [ ] <NEWLINE> White = [ ] <NEWLINE> len_Red = 0 <NEWLINE> len_White = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if C [ i ] == <STRING> : <NEWLINE> <INDENT> Red . append ( i ) <NEWLINE> len_Red += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> White . append ( i ) <NEWLINE> len_White += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> w = 0 <NEWLINE> r = len_Red - 1 <NEWLINE> while True : <NEWLINE> <INDENT> if w < len_White : <NEWLINE> <INDENT> cnt = White [ w ] <NEWLINE> w += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if r >= 0 and cnt < Red [ r ] : <NEWLINE> <INDENT> C [ cnt ] , C [ r ] = C [ r ] , C [ cnt ] <NEWLINE> ans += 1 <NEWLINE> r -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> flag = False <NEWLINE> limit = 1000000000000000000 <NEWLINE> a = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> if ( i == 0 ) : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ( ans > limit ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ( flag ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif ( ans > limit ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> <NL> def factorize ( n ) : <NEWLINE> <INDENT> facts = defaultdict ( int ) <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> n //= 2 <NEWLINE> facts [ 2 ] += 1 <NEWLINE> <DEDENT> m = 3 <NEWLINE> while m * m <= n : <NEWLINE> <INDENT> while n % m == 0 : <NEWLINE> <INDENT> facts [ m ] += 1 <NEWLINE> n //= m <NEWLINE> <DEDENT> m += 2 <NEWLINE> <DEDENT> if 1 < n : <NEWLINE> <INDENT> facts [ n ] += 1 <NEWLINE> <DEDENT> return facts <NEWLINE> <NL> <NL> <DEDENT> MOD = 10 ** 9 + 7 <COMMENT> <NEWLINE> MAX = 10 ** 5 + 100 <NEWLINE> FACTS = [ 1 ] * ( MAX + 1 ) <NEWLINE> for i in range ( 1 , MAX + 1 ) : <NEWLINE> <INDENT> FACTS [ i ] = FACTS [ i - 1 ] * i % MOD <NEWLINE> <DEDENT> FACTINVS = [ 1 ] * ( MAX + 1 ) <NEWLINE> INVS = [ 1 ] * ( MAX + 1 ) <NEWLINE> for i in range ( 2 , MAX + 1 ) : <NEWLINE> <INDENT> q , r = divmod ( MOD , i ) <NEWLINE> INVS [ i ] = - INVS [ r ] * q % MOD <NEWLINE> FACTINVS [ i ] = FACTINVS [ i - 1 ] * INVS [ i ] % MOD <NEWLINE> <NL> <NL> <DEDENT> def nCr ( n , r ) : <NEWLINE> <INDENT> return FACTS [ n ] * FACTINVS [ r ] * FACTINVS [ n - r ] <NEWLINE> <NL> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> factors = factorize ( M ) <NEWLINE> ans = 1 <NEWLINE> for p , e in factors . items ( ) : <NEWLINE> <INDENT> ans = ans * nCr ( N - 1 + e , e ) % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> L = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> tmp = bisect_left ( L , L [ i ] + L [ j ] ) <NEWLINE> cnt += tmp - j - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> N , K = LI ( ) <NEWLINE> A = LI ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> hist = [ ] <NEWLINE> now = 0 <NEWLINE> chk = [ - 1 ] * N <NEWLINE> while True : <NEWLINE> <INDENT> hist . append ( now + 1 ) <NEWLINE> if chk [ now ] != - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <DEDENT> chk [ now ] = len ( hist ) - 1 <NEWLINE> now = A [ now ] - 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> loopstart = chk [ hist [ len ( hist ) - 1 ] - 1 ] + 1 <NEWLINE> if K >= len ( hist ) : <NEWLINE> <INDENT> K -= loopstart <NEWLINE> K %= len ( hist ) - loopstart <NEWLINE> print ( hist [ loopstart + K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( hist [ K ] ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> for i in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for j in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> a = i <NEWLINE> b = j <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE>
<NL> import collections <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> ufb = UnionFind ( n ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> ufb . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> c = collections . Counter ( [ ufb . find ( i ) for i in range ( n ) ] ) <NEWLINE> print ( max ( c . values ( ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> res = 1 <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> j = i <NEWLINE> if j % 2 == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> while j % 2 == 0 : <NEWLINE> <INDENT> j //= 2 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if ans < cnt : <NEWLINE> <INDENT> res = i <NEWLINE> ans = cnt <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> <COMMENT> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = len ( s ) - r - g <NEWLINE> total = r * g * b <NEWLINE> <NL> <COMMENT> <NL> for p in range ( 1 , ( n - 1 ) // 2 + 1 ) : <NEWLINE> <INDENT> for i in range ( 0 , n - ( 2 * p ) ) : <NEWLINE> <INDENT> si , sj , sk = s [ i ] , s [ i + p ] , s [ i + 2 * p ] <NEWLINE> if si != sj and sj != sk and sk != si : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if 3 <= H and W <= 300 : <NEWLINE> <INDENT> print ( W * ( <STRING> ) + <STRING> + ( H - 2 ) * ( ( <STRING> + ( ( <STRING> ) * ( W - 2 ) ) + <STRING> ) + <STRING> ) + W * ( <STRING> ) ) <NEWLINE> <DEDENT> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> lst = [ [ 0 , 0 , 0 , 0 ] for _ in range ( N ) ] <NEWLINE> p = [ 0 ] * N <NEWLINE> m = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> lst [ i ] [ 0 ] = x <NEWLINE> lst [ i ] [ 1 ] = y <NEWLINE> p [ i ] = x + y <NEWLINE> m [ i ] = x - y <NEWLINE> <NL> <DEDENT> d = max ( max ( p ) - min ( p ) , max ( m ) - min ( m ) ) <NEWLINE> print ( d ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( <STRING> + <STRING> . join ( map ( str , [ x for x in range ( 3 , n + 1 ) if x % 3 == 0 or <STRING> in str ( x ) ] ) ) ) <NEWLINE>
from collections import * <NEWLINE> from operator import mul <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> <NL> A_dic = Counter ( A ) <NEWLINE> A_sum = sum ( A ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp = A_dic [ b ] <NEWLINE> A_dic [ c ] += tmp <NEWLINE> A_dic [ b ] = 0 <NEWLINE> A_sum += tmp * ( c - b ) <NEWLINE> print ( A_sum ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
char = input ( ) <NEWLINE> print ( char . swapcase ( ) ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> DIV = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> pluslist = [ ] <NEWLINE> minuslist = [ ] <NEWLINE> zerocnt = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] > 0 : <NEWLINE> <INDENT> pluslist . append ( A [ i ] ) <NEWLINE> <DEDENT> elif A [ i ] < 0 : <NEWLINE> <INDENT> minuslist . append ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> zerocnt += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if N - zerocnt < K : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> if K % 2 == 1 and len ( pluslist ) == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> if zerocnt > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <COMMENT> <NL> <DEDENT> minuslist = sorted ( minuslist , reverse = True ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans *= minuslist [ i ] <NEWLINE> ans %= DIV <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> if K + zerocnt == N : <NEWLINE> <INDENT> if len ( minuslist ) % 2 == 1 and zerocnt > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for p in pluslist : <NEWLINE> <INDENT> ans *= p <NEWLINE> ans %= DIV <NEWLINE> <DEDENT> for m in minuslist : <NEWLINE> <INDENT> ans *= m <NEWLINE> ans %= DIV <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> pluslist = sorted ( pluslist , reverse = True ) <NEWLINE> minuslist = sorted ( minuslist ) <NEWLINE> from collections import deque <NEWLINE> <NL> plusq = deque ( pluslist ) <NEWLINE> minusq = deque ( minuslist ) <NEWLINE> <NL> ans = 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if K % 2 == 1 and len ( plusq ) > 0 : <NEWLINE> <INDENT> ans *= plusq . popleft ( ) <COMMENT> <NEWLINE> K -= 1 <NEWLINE> <NL> <DEDENT> for i in range ( K // 2 ) : <NEWLINE> <INDENT> p = None <NEWLINE> m = None <NEWLINE> if len ( plusq ) >= 2 : <NEWLINE> <INDENT> p1 = plusq . popleft ( ) <NEWLINE> p2 = plusq . popleft ( ) <NEWLINE> p = p1 * p2 <NEWLINE> <DEDENT> if len ( minusq ) >= 2 : <NEWLINE> <INDENT> m1 = minusq . popleft ( ) <NEWLINE> m2 = minusq . popleft ( ) <NEWLINE> m = m1 * m2 <NEWLINE> <DEDENT> if p is None and m is None : <NEWLINE> <INDENT> ans *= ( minusq . popleft ( ) * plusq . popleft ( ) ) % DIV <NEWLINE> continue <NEWLINE> <DEDENT> if m is None : <NEWLINE> <INDENT> ans *= p % DIV <NEWLINE> ans %= DIV <NEWLINE> continue <NEWLINE> <DEDENT> if p is None : <NEWLINE> <INDENT> ans *= m % DIV <NEWLINE> ans %= DIV <NEWLINE> continue <NEWLINE> <DEDENT> if p > m : <NEWLINE> <INDENT> ans *= p % DIV <NEWLINE> ans %= DIV <NEWLINE> minusq . appendleft ( m2 ) <NEWLINE> minusq . appendleft ( m1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= m % DIV <NEWLINE> ans %= DIV <NEWLINE> plusq . appendleft ( p2 ) <NEWLINE> plusq . appendleft ( p1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> from collections import deque <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , Q = map ( int , readline ( ) . split ( ) ) <NEWLINE> AB = list ( list ( map ( int , readline ( ) . split ( ) ) ) for _ in range ( N - 1 ) ) <NEWLINE> PX = list ( list ( map ( int , readline ( ) . split ( ) ) ) for _ in range ( Q ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> value = [ 0 ] * N <NEWLINE> for p , x in PX : <NEWLINE> <INDENT> value [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> que = deque ( [ 0 ] ) <NEWLINE> visited = [ False ] * N <NEWLINE> while que : <NEWLINE> <INDENT> x = que . popleft ( ) <NEWLINE> visited [ x ] = True <NEWLINE> for y in graph [ x ] : <NEWLINE> <INDENT> if visited [ y ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> value [ y ] += value [ x ] <NEWLINE> que . append ( y ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , value ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
from itertools import groupby , accumulate , product , permutations , combinations <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( reverse = True ) <NEWLINE> ans = sum ( L [ : K ] ) <NEWLINE> return ans <NEWLINE> <DEDENT> print ( solve ( ) ) <NEWLINE>
for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> input ( ) <NEWLINE> * a , = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> b = [ ] <NEWLINE> ans = 0 <NEWLINE> for x , p in zip ( a [ : : - 1 ] , s [ : : - 1 ] ) : <NEWLINE> <INDENT> for y in b : <NEWLINE> <INDENT> x = min ( x , x ^ y ) <NEWLINE> <DEDENT> if x : <NEWLINE> <INDENT> if p == <STRING> : <NEWLINE> <INDENT> ans = 1 <NEWLINE> break <NEWLINE> <DEDENT> b . append ( x ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> cc = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> memo = [ ] <NEWLINE> aa = [ <STRING> ] * N <NEWLINE> a = 1 <NEWLINE> while aa [ a - 1 ] == <STRING> : <NEWLINE> <INDENT> memo . append ( a ) <NEWLINE> aa [ a - 1 ] = <STRING> <NEWLINE> a = cc [ a - 1 ] <NEWLINE> <DEDENT> if len ( memo ) > K : <NEWLINE> <INDENT> print ( memo [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = memo . index ( a ) <NEWLINE> m = len ( memo ) - b <NEWLINE> mm = ( K - b ) % m <NEWLINE> del memo [ : b ] <NEWLINE> print ( memo [ mm ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = input ( ) . split ( ) <NEWLINE> <NL> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> out = a [ ( n - i - 1 ) ] <NEWLINE> b . append ( out ) <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , b ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> max_num = max ( l ) <NEWLINE> max_index = l . index ( max ( l ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i != max_index : <NEWLINE> <INDENT> print ( max_num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . remove ( max_num ) <NEWLINE> print ( max ( l ) ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> x1 , y1 , x2 , y2 = [ float ( s ) for s in input ( ) . split ( ) ] <NEWLINE> print ( math . sqrt ( ( math . fabs ( x1 - x2 ) ** 2 ) + ( math . fabs ( y1 - y2 ) ** 2 ) ) ) <NEWLINE>
<COMMENT> <NL> <NL> x = int ( input ( ) ) <NEWLINE> t = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if t * ( t + 1 ) / 2 >= x : <NEWLINE> <INDENT> print ( t ) <NEWLINE> break <NEWLINE> <DEDENT> t += 1 <NEWLINE> <DEDENT>
n , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> cnt [ 0 ] = - 9999999999 <NEWLINE> mx = [ 0 , cnt [ 0 ] ] <NEWLINE> <NL> <NL> def spam ( ) : <NEWLINE> <INDENT> max_v = max ( cnt ) <NEWLINE> idx = min ( [ i for i , value in enumerate ( cnt ) if value == max_v ] ) <NEWLINE> return idx , max_v <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> a , v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt [ a ] += v <NEWLINE> if mx [ 0 ] == a and v > 0 : <NEWLINE> <INDENT> mx [ 1 ] += v <NEWLINE> <NL> <DEDENT> elif mx [ 0 ] == a : <NEWLINE> <INDENT> mx [ 0 ] , mx [ 1 ] = spam ( ) <NEWLINE> <NL> <DEDENT> elif mx [ 1 ] < cnt [ a ] : <NEWLINE> <INDENT> mx [ 0 ] , mx [ 1 ] = a , cnt [ a ] <NEWLINE> <NL> <DEDENT> elif mx [ 1 ] == cnt [ a ] and mx [ 0 ] > a : <NEWLINE> <INDENT> mx [ 0 ] , mx [ 1 ] = a , cnt [ a ] <NEWLINE> <NL> <DEDENT> print ( <STRING> % ( mx [ 0 ] , mx [ 1 ] ) ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> elif i % 10 == 3 : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> elif ( i // 10 ) % 10 == 3 : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> elif ( ( i // 10 ) // 10 ) % 10 == 3 : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> elif ( ( i // 10 ) // 10 ) // 10 % 10 == 3 : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> elif ( ( i // 10 ) // 10 ) // 10 // 10 % 10 == 3 : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> elif ( ( i // 10 ) // 10 ) // 10 // 10 // 10 % 10 == 3 : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> for i in b : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE>
from collections import defaultdict <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> record = defaultdict ( int ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> cur = i - A [ i ] <NEWLINE> count += record [ cur ] <NEWLINE> record [ i + A [ i ] ] += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
s = [ 0 , 0 , 0 ] <NEWLINE> n , s [ 0 ] , s [ 1 ] , s [ 2 ] = map ( int , input ( ) . split ( ) ) <NEWLINE> T = [ 0 ] * n <NEWLINE> ABC = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = input ( ) <NEWLINE> if t == <STRING> : T [ i ] = 2 <NEWLINE> if t == <STRING> : T [ i ] = 0 <NEWLINE> if t == <STRING> : T [ i ] = 1 <NEWLINE> <DEDENT> ans = [ <STRING> for _ in range ( n ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if sum ( s ) == 2 : <NEWLINE> <INDENT> if s . count ( 0 ) == 1 : <NEWLINE> <INDENT> now = s . index ( 0 ) <NEWLINE> i = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if T [ 0 ] != s . index ( 2 ) : <NEWLINE> <INDENT> now = T [ 0 ] <NEWLINE> i = 1 <NEWLINE> nxt = [ 0 , 1 , 2 ] <NEWLINE> nxt . remove ( T [ 0 ] ) <NEWLINE> nxt . remove ( s . index ( 2 ) ) <NEWLINE> ans [ 0 ] = ABC [ nxt [ 0 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> while i < n - 1 : <NEWLINE> <INDENT> if T [ i ] == T [ i + 1 ] : <NEWLINE> <INDENT> if T [ i ] == now : <NEWLINE> <INDENT> ans [ i ] = ABC [ ( now - 1 ) % 3 ] <NEWLINE> ans [ i + 1 ] = ABC [ ( now - 2 ) % 3 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> if j not in [ T [ i ] , now ] : <NEWLINE> <INDENT> ans [ i + 1 ] = ABC [ j ] <NEWLINE> <DEDENT> <DEDENT> ans [ i ] = ABC [ now ] <NEWLINE> <DEDENT> i += 2 <NEWLINE> <DEDENT> elif T [ i ] == now : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> if j not in [ T [ i + 1 ] , now ] : ans [ i ] = ABC [ j ] <NEWLINE> <DEDENT> ans [ i + 1 ] = ABC [ T [ i ] ] <NEWLINE> now = T [ i + 1 ] <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = ABC [ now ] <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> if j not in [ T [ i ] , now ] : <NEWLINE> <INDENT> now = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> if i == n - 1 : <NEWLINE> <INDENT> if T [ i ] == now : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> if j not in [ now , T [ i ] ] : ans [ i ] = ABC [ j ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = ABC [ now ] <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i , t in enumerate ( T ) : <NEWLINE> <INDENT> nxt = [ 0 , 1 , 2 ] <NEWLINE> nxt . remove ( t ) <NEWLINE> if s [ nxt [ 0 ] ] < s [ nxt [ 1 ] ] : <NEWLINE> <INDENT> ans [ i ] = ABC [ nxt [ 0 ] ] <NEWLINE> s [ nxt [ 0 ] ] += 1 <NEWLINE> s [ nxt [ 1 ] ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = ABC [ nxt [ 1 ] ] <NEWLINE> s [ nxt [ 0 ] ] -= 1 <NEWLINE> s [ nxt [ 1 ] ] += 1 <NEWLINE> <DEDENT> if - 1 in s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE> <DEDENT> <DEDENT>
def fibonacci ( n ) : <NEWLINE> <INDENT> a , b = 1 , 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = b , a + b <NEWLINE> <NL> <DEDENT> return b <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> print ( fibonacci ( n ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flag = False <NEWLINE> sum = 1 <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> if not flag : <NEWLINE> <INDENT> if sum * i > 10 ** 18 : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum *= i <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> c = [ 0 ] * ( n + 2 ) <NEWLINE> f = 0 ; <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if a == 0 : f = 1 <NEWLINE> else : c [ a ] = 1 <NEWLINE> <DEDENT> ans = w0 = w = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if c [ i ] : w += 1 <NEWLINE> elif w > 0 : <NEWLINE> <INDENT> if w0 + w + f > ans : ans = w0 + w + f <NEWLINE> w0 = w if f and c [ i + 1 ] else 0 <NEWLINE> w = 0 <NEWLINE> <DEDENT> <DEDENT> if w0 + w + f > ans : ans = w0 + w + f <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
def InputData ( ) : <NEWLINE> <NL> <INDENT> sequence_len = int ( input ( ) ) <NEWLINE> sequence = [ int ( a ) for a in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> return sequence_len , sequence <NEWLINE> <NL> <DEDENT> def bubbleSort ( A ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> for j in range ( len ( A ) - 1 , i + 1 , - 1 ) : <NEWLINE> <INDENT> if A [ j ] < A [ j - 1 ] : <NEWLINE> <INDENT> A [ j ] , A [ j - 1 ] = A [ j - 1 ] , A [ j ] <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def merge ( sequence , left , mid , right ) : <NEWLINE> <INDENT> global merge_cnt <NEWLINE> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> sequence_left = sequence [ left : left + n1 ] <NEWLINE> sequence_right = sequence [ mid : mid + n2 ] <NEWLINE> sequence_left . append ( float ( <STRING> ) ) <NEWLINE> sequence_right . append ( float ( <STRING> ) ) <NEWLINE> <NL> left_cnt = 0 <NEWLINE> right_cnt = 0 <NEWLINE> for i in range ( left , right ) : <NEWLINE> <INDENT> if sequence_left [ left_cnt ] <= sequence_right [ right_cnt ] : <NEWLINE> <COMMENT> <NL> <INDENT> sequence [ i ] = sequence_left [ left_cnt ] <NEWLINE> left_cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> sequence [ i ] = sequence_right [ right_cnt ] <NEWLINE> right_cnt += 1 <NEWLINE> merge_cnt += n1 - left_cnt <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( sequence , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <COMMENT> <NL> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergeSort ( sequence , left , mid ) <NEWLINE> mergeSort ( sequence , mid , right ) <NEWLINE> merge ( sequence , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def PrintOut ( cnt ) : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> [ sequence_len , sequence ] = InputData ( ) <NEWLINE> <COMMENT> <NL> global merge_cnt <NEWLINE> merge_cnt = 0 <NEWLINE> mergeSort ( sequence , 0 , sequence_len ) <NEWLINE> PrintOut ( merge_cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> stone = input ( ) <NEWLINE> <NL> R_count = 0 <NEWLINE> W_count = 0 <NEWLINE> for i in range ( len ( stone ) ) : <NEWLINE> <INDENT> if stone [ i ] == <STRING> : <NEWLINE> <INDENT> R_count = R_count + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> W_count = W_count + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> W = 0 <NEWLINE> R = R_count <NEWLINE> try_num_prev = - 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if R_count == 0 or W_count == 0 : <NEWLINE> <INDENT> try_num = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> if W <= R : <NEWLINE> <INDENT> try_num = R <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try_num = W <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if try_num_prev >= 0 and try_num_prev < try_num : <NEWLINE> <INDENT> try_num = try_num_prev <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try_num_prev = try_num <NEWLINE> if stone [ i ] == <STRING> : <NEWLINE> <INDENT> R = R - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> W = W + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( try_num ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <COMMENT> <NEWLINE> from collections import deque <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> dist = [ - 1 for _ in range ( N ) ] <NEWLINE> chk = [ 0 for _ in range ( N ) ] <NEWLINE> dist [ 0 ] = 0 <NEWLINE> prev = [ - 1 for _ in range ( N ) ] <NEWLINE> <NL> <NL> que = deque ( ) <NEWLINE> que . append ( ( 0 , - 1 ) ) <NEWLINE> <NL> while ( len ( que ) ) : <NEWLINE> <INDENT> v , p = que . popleft ( ) <NEWLINE> for tmp in G [ v ] : <NEWLINE> <INDENT> if dist [ tmp ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ tmp ] = dist [ v ] + 1 <NEWLINE> prev [ tmp ] = v <NEWLINE> que . append ( ( tmp , v ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> print ( prev [ i ] + 1 ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> L1 = [ 1 , 9 , 30 , 76 , 141 , 267 , 400 , 624 , 885 , 1249 , 1590 , 2208 , 2689 , 3411 , 4248 , 5248 , 6081 , 7485 , 8530 , 10248 , 11889 , 13687 , 15228 , 17988 , 20053 , 22569 , 25242 , 28588 , 31053 , 35463 , 38284 , 42540 , 46581 , 50893 , 55362 , 61824 , 65857 , 71247 , 76884 , 84388 , 89349 , 97881 , 103342 , 111528 , 120141 , 128047 , 134580 , 146316 , 154177 , 164817 , 174438 , 185836 , 194157 , 207927 , 218812 , 233268 , 245277 , 257857 , 268182 , 288216 , 299257 , 313635 , 330204 , 347836 , 362973 , 383709 , 397042 , 416448 , 434025 , 456967 , 471948 , 499740 , 515581 , 536073 , 559758 , 583960 , 604833 , 633651 , 652216 , 683712 , 709065 , 734233 , 754734 , 793188 , 818917 , 846603 , 874512 , 909496 , 933081 , 977145 , 1006126 , 1041504 , 1073385 , 1106467 , 1138536 , 1187112 , 1215145 , 1255101 , 1295142 , 1342852 , 1373253 , 1422195 , 1453816 , 1502376 , 1553361 , 1595437 , 1629570 , 1691292 , 1726717 , 1782111 , 1827492 , 1887772 , 1925853 , 1986837 , 2033674 , 2089776 , 2145333 , 2197483 , 2246640 , 2332104 , 2379085 , 2434833 , 2490534 , 2554600 , 2609625 , 2693919 , 2742052 , 2813988 , 2875245 , 2952085 , 3003306 , 3096024 , 3157249 , 3224511 , 3306240 , 3388576 , 3444609 , 3533637 , 3591322 , 3693924 , 3767085 , 3842623 , 3912324 , 4027884 , 4102093 , 4181949 , 4270422 , 4361548 , 4427853 , 4548003 , 4616104 , 4718640 , 4812789 , 4918561 , 5003286 , 5131848 , 5205481 , 5299011 , 5392008 , 5521384 , 5610705 , 5739009 , 5818390 , 5930196 , 6052893 , 6156139 , 6239472 , 6402720 , 6493681 , 6623853 , 6741078 , 6864016 , 6953457 , 7094451 , 7215016 , 7359936 , 7475145 , 7593865 , 7689630 , 7886244 , 7984165 , <NEWLINE> 8130747 , 8253888 , 8403448 , 8523897 , 8684853 , 8802826 , 8949612 , 9105537 , 9267595 , 9376656 , 9574704 , 9686065 , 9827097 , 9997134 , 10174780 , 10290813 , 10493367 , 10611772 , 10813692 ] <NEWLINE> print ( L1 [ K - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> xy = [ map ( int , input ( ) . split ( ) ) for _ in range ( N ) ] <NEWLINE> x , y = [ list ( i ) for i in zip ( * xy ) ] <NEWLINE> flag = 0 <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if x [ i ] == y [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count >= 3 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ns = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ns [ i ] <= sum ( ns ) / n : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
mod = 10 ** 9 + 7 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list . sort ( a_i ) <NEWLINE> ans = 1 <NEWLINE> isminus = False <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = n - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = n - 2 <NEWLINE> ans *= a_i [ n - 1 ] <NEWLINE> <DEDENT> if ans < 0 : isminus = True <NEWLINE> for x in range ( k // 2 ) : <NEWLINE> <INDENT> ans_L = a_i [ left ] * a_i [ left + 1 ] <NEWLINE> ans_R = a_i [ right ] * a_i [ right - 1 ] <NEWLINE> if ( isminus == False and ans_L < ans_R ) or ( isminus == True and ans_L > ans_R ) : <NEWLINE> <INDENT> ans *= ans_R <NEWLINE> right -= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= ans_L <NEWLINE> left += 2 <NEWLINE> <DEDENT> if ans < 0 or ans >= mod : ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m > 0 : <NEWLINE> <INDENT> p , s = zip ( * [ input ( ) . split ( ) for _ in range ( m ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = [ ] <NEWLINE> s = [ ] <NEWLINE> <NL> <DEDENT> ac_dict = { str ( i ) : False for i in range ( 1 , n + 1 ) } <NEWLINE> wa_dict = { str ( i ) : 0 for i in range ( 1 , n + 1 ) } <NEWLINE> ac_num = 0 <NEWLINE> wa_num = 0 <NEWLINE> for p_i , s_i in zip ( p , s ) : <NEWLINE> <INDENT> if ac_dict [ p_i ] == False : <NEWLINE> <INDENT> if s_i == <STRING> : <NEWLINE> <INDENT> ac_num += 1 <NEWLINE> wa_num += wa_dict [ p_i ] <NEWLINE> ac_dict [ p_i ] = True <NEWLINE> <DEDENT> elif s_i == <STRING> : <NEWLINE> <INDENT> wa_dict [ p_i ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . format ( ac_num , wa_num ) ) <NEWLINE>
<NL> import sys <NEWLINE> sys . setrecursionlimit ( int ( 2e5 + 999 ) ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) [ 0 : 2 ] ) <NEWLINE> <NL> fa = list ( range ( 0 , n + 1 ) ) <NEWLINE> sz = [ 1 ] * ( n + 1 ) <NEWLINE> def gf ( x ) : <NEWLINE> <INDENT> if x == fa [ x ] : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> fa [ x ] = gf ( fa [ x ] ) <NEWLINE> return fa [ x ] <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( gf , map ( int , input ( ) . split ( ) [ 0 : 2 ] ) ) <NEWLINE> if a != b : <NEWLINE> <INDENT> fa [ a ] = b <NEWLINE> sz [ b ] += sz [ a ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , sz [ gf ( i ) ] ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ls = [ ] <NEWLINE> count = 0 <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> ls . append ( input ( ) ) <NEWLINE> <DEDENT> ls = set ( ls ) <NEWLINE> print ( len ( ls ) ) <NEWLINE>
N , M , X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = [ [ ] ] * N <NEWLINE> a = [ [ [ ] ] * M ] * N <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> temp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c [ n ] = temp [ 0 ] <NEWLINE> a [ n ] = temp [ 1 : M + 1 ] <NEWLINE> <NL> <NL> <DEDENT> ans = 10 ** 7 <NEWLINE> <NL> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> price = 0 <NEWLINE> intelligence = [ 0 for _ in range ( M ) ] <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> price += c [ j ] <NEWLINE> for k in range ( M ) : <NEWLINE> <INDENT> intelligence [ k ] += a [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> flag = 1 <NEWLINE> for k in range ( M ) : <NEWLINE> <INDENT> if intelligence [ k ] < X : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> ans = min ( ans , price ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == 10 ** 7 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> summ = sum ( lst ) <NEWLINE> summ_sq = summ ** 2 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += lst [ i ] ** 2 <NEWLINE> <NL> <DEDENT> res = ( summ_sq - ans ) // 2 <NEWLINE> print ( res % ( ( 10 ** 9 ) + 7 ) ) <NEWLINE>
import math <NEWLINE> <NL> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> H_angle = 30 * H + 0.5 * M <COMMENT> <NEWLINE> M_angle = 6 * M <COMMENT> <NEWLINE> HM_angle = abs ( H_angle - M_angle ) <NEWLINE> <NL> if HM_angle == 0 : <NEWLINE> <INDENT> print ( abs ( A - B ) ) <NEWLINE> <DEDENT> elif HM_angle == 180 : <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( A ** 2 + B ** 2 - 2 * A * B * math . cos ( math . radians ( HM_angle ) ) ) ** 0.5 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> readline = sys . stdin . readline <NEWLINE> readall = sys . stdin . read <NEWLINE> ns = lambda : readline ( ) . rstrip ( ) <NEWLINE> ni = lambda : int ( readline ( ) . rstrip ( ) ) <NEWLINE> nm = lambda : map ( int , readline ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> prn = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> <NL> def popcount ( x ) : <NEWLINE> <INDENT> x = x - ( ( x >> 1 ) & 0x55555555 ) <NEWLINE> x = ( x & 0x33333333 ) + ( ( x >> 2 ) & 0x33333333 ) <NEWLINE> x = ( x + ( x >> 4 ) ) & 0x0f0f0f0f <NEWLINE> x = x + ( x >> 8 ) <NEWLINE> x = x + ( x >> 16 ) <NEWLINE> return x & 0x0000007f <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> n = ni ( ) <NEWLINE> X = list ( map ( int , list ( ns ( ) ) ) ) <NEWLINE> p = sum ( X ) <NEWLINE> pl , ps = p + 1 , p - 1 <NEWLINE> <NL> g = [ - 1 ] * ( n + 5 ) <NEWLINE> g [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n + 5 ) : <NEWLINE> <INDENT> g [ i ] = g [ i % popcount ( i ) ] + 1 <NEWLINE> <DEDENT> ql = qs = 0 <NEWLINE> for x in X : <NEWLINE> <INDENT> ql = ( ql * 2 + x ) % pl <NEWLINE> if ps > 0 : <NEWLINE> <INDENT> qs = ( qs * 2 + x ) % ps <NEWLINE> <DEDENT> <DEDENT> vl = vs = 1 <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if X [ i ] : <NEWLINE> <INDENT> if ps > 0 : <NEWLINE> <INDENT> ans [ i ] = g [ ( qs - vs ) % ps ] + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = g [ ( ql + vl ) % pl ] + 1 <NEWLINE> <DEDENT> if ps > 0 : <NEWLINE> <INDENT> vs = vs * 2 % ps <NEWLINE> <DEDENT> vl = vl * 2 % pl <NEWLINE> <DEDENT> prn ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
import sys <NEWLINE> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> bomb_h = [ 0 ] * h <NEWLINE> bomb_w = [ 0 ] * w <NEWLINE> place = list ( ) <NEWLINE> <COMMENT> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> bomb_h [ x - 1 ] += 1 <NEWLINE> bomb_w [ y - 1 ] += 1 <NEWLINE> place . append ( [ x - 1 , y - 1 ] ) <NEWLINE> <DEDENT> x_cand = list ( ) <NEWLINE> x_max = 0 <NEWLINE> <COMMENT> <NL> for x in range ( h ) : <NEWLINE> <INDENT> if x_max < bomb_h [ x ] : <NEWLINE> <INDENT> x_cand = [ x ] <NEWLINE> x_max = bomb_h [ x ] <NEWLINE> <DEDENT> elif x_max == bomb_h [ x ] : <NEWLINE> <INDENT> x_cand . append ( x ) <NEWLINE> <DEDENT> <DEDENT> y_cand = list ( ) <NEWLINE> y_max = 0 <NEWLINE> <COMMENT> <NL> for y in range ( w ) : <NEWLINE> <INDENT> if y_max < bomb_w [ y ] : <NEWLINE> <INDENT> y_cand = [ y ] <NEWLINE> y_max = bomb_w [ y ] <NEWLINE> <DEDENT> elif y_max == bomb_w [ y ] : <NEWLINE> <INDENT> y_cand . append ( y ) <NEWLINE> <DEDENT> <DEDENT> ans = x_max + y_max <NEWLINE> <COMMENT> <NL> cnt = 0 <NEWLINE> <COMMENT> <NL> for p in place : <NEWLINE> <INDENT> if bomb_h [ p [ 0 ] ] == x_max and bomb_w [ p [ 1 ] ] == y_max : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if len ( x_cand ) * len ( y_cand ) > cnt : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = 1 <NEWLINE> m = 10 ** 18 <NEWLINE> for ai in a : <NEWLINE> <INDENT> x *= ai <NEWLINE> if x > m : <NEWLINE> <INDENT> x = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE> <DEDENT>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> Y //= 1000 <NEWLINE> for nog in range ( N + 1 ) : <NEWLINE> <INDENT> for hig in range ( N + 1 - nog ) : <NEWLINE> <INDENT> yuk = N - nog - hig <NEWLINE> if nog + hig * 5 + yuk * 10 == Y : <NEWLINE> <INDENT> print ( yuk , hig , nog ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) [ : : - 1 ] <NEWLINE> ans = 0 <NEWLINE> dp = [ 0 ] * 2019 <NEWLINE> dp [ 0 ] = 1 <NEWLINE> val = <STRING> <NEWLINE> m = 0 <NEWLINE> x_10 = 1 <NEWLINE> for s in S : <NEWLINE> <INDENT> m = ( m + int ( s ) * x_10 ) % 2019 <NEWLINE> dp [ m ] += 1 <NEWLINE> x_10 = ( x_10 * 10 ) % 2019 <NEWLINE> <DEDENT> for i in dp : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = input ( ) . split ( ) <NEWLINE> scores = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> <NL> N = int ( N ) <NEWLINE> K = int ( K ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if scores [ i ] <= scores [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
MAX_INT = 10 ** 6 <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> room = [ set ( ) for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> room [ a ] . add ( b ) <NEWLINE> room [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> dis = [ MAX_INT ] * ( N + 1 ) <NEWLINE> sign = [ - 1 ] * ( N + 1 ) <NEWLINE> dis [ 1 ] = 0 <NEWLINE> def sign_root ( n ) : <NEWLINE> <INDENT> nxt = [ ] <NEWLINE> for i in room [ n ] : <NEWLINE> <INDENT> if dis [ n ] + 1 < dis [ i ] : <NEWLINE> <INDENT> sign [ i ] = n <NEWLINE> dis [ i ] = dis [ n ] + 1 <NEWLINE> nxt += [ i ] <NEWLINE> <DEDENT> <DEDENT> return nxt <NEWLINE> <NL> <DEDENT> nxt = sign_root ( 1 ) <NEWLINE> while nxt != [ ] : <NEWLINE> <INDENT> for i in nxt . copy ( ) : <NEWLINE> <INDENT> nxt . pop ( 0 ) <NEWLINE> nxt += sign_root ( i ) <NEWLINE> <DEDENT> <DEDENT> if MAX_INT in dis [ 2 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in sign [ 2 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> a = sorted ( A , reverse = True ) <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <COMMENT> <NL> DEBUG = False <NEWLINE> if DEBUG : <NEWLINE> <INDENT> f = open ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = sys . stdin <NEWLINE> <COMMENT> <NL> <DEDENT> def cnt_func ( num ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while num : <NEWLINE> <INDENT> num %= bin ( num ) . count ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> return cnt + 1 <NEWLINE> <DEDENT> n = int ( f . readline ( ) . strip ( ) ) <NEWLINE> s = f . readline ( ) . strip ( ) <NEWLINE> input_val = int ( s , 2 ) <NEWLINE> input_one_count = s . count ( <STRING> ) <NEWLINE> <COMMENT> <NL> zero_first = input_val % ( input_one_count + 1 ) <NEWLINE> one_first = input_val % ( input_one_count - 1 ) if input_one_count > 1 else 0 <NEWLINE> ans = 0 <NEWLINE> for idx , emt in enumerate ( s ) : <NEWLINE> <INDENT> p = n - idx - 1 <NEWLINE> if emt == <STRING> : <COMMENT> <NEWLINE> <INDENT> ans = cnt_func ( ( zero_first + ( pow ( 2 , p , input_one_count + 1 ) ) ) % ( input_one_count + 1 ) ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> if input_one_count > 1 : <NEWLINE> <INDENT> ans = cnt_func ( ( one_first - ( pow ( 2 , p , input_one_count - 1 ) ) ) % ( input_one_count - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> f . close ( ) <NEWLINE>
print ( <STRING> . join ( map ( str , sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) ) ) ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ca = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> c = [ ca [ i ] [ 0 ] for i in range ( n ) ] <NEWLINE> a = [ ca [ i ] [ 1 : ] for i in range ( n ) ] <NEWLINE> <NL> price = sum ( c ) <NEWLINE> l = 0 <NEWLINE> <NL> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> kari = 0 <NEWLINE> skill = [ 0 ] * m <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> skill = [ x + y for ( x , y ) in zip ( skill , a [ j ] ) ] <NEWLINE> kari += c [ j ] <NEWLINE> <DEDENT> <DEDENT> if all ( [ z >= x for z in skill ] ) : <NEWLINE> <INDENT> price = min ( price , kari ) <NEWLINE> l += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if l == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( price ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> alist . insert ( 0 , 1e7 ) <NEWLINE> alist . append ( 1e7 ) <NEWLINE> core = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> core += min ( alist [ i ] , alist [ i + 1 ] ) <NEWLINE> <DEDENT> print ( core ) <NEWLINE>
from collections import deque <NEWLINE> <NL> s = deque ( list ( input ( ) ) ) <NEWLINE> flag = 0 <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> dir = input ( ) . split ( ) <NEWLINE> if int ( dir [ 0 ] ) == 1 : flag += 1 <NEWLINE> else : <NEWLINE> <INDENT> if int ( dir [ 1 ] ) == 1 : <NEWLINE> <INDENT> if flag % 2 == 0 : s . appendleft ( dir [ 2 ] ) <NEWLINE> else : s . append ( dir [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if flag % 2 == 0 : s . append ( dir [ 2 ] ) <NEWLINE> else : s . appendleft ( dir [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> s = list ( s ) <NEWLINE> if flag % 2 == 1 : s . reverse ( ) <NEWLINE> print ( * s , sep = <STRING> ) <NEWLINE>
from itertools import permutations as pe <NEWLINE> INT = lambda : int ( input ( ) ) <NEWLINE> INTM = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> STRM = lambda : map ( str , input ( ) . split ( ) ) <NEWLINE> STR = lambda : str ( input ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LISTS = lambda : list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> def do ( ) : <NEWLINE> <INDENT> n = INT ( ) <NEWLINE> ns = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ns . append ( str ( i ) ) <NEWLINE> <DEDENT> p = LISTS ( ) <NEWLINE> q = LISTS ( ) <NEWLINE> ct = 0 <NEWLINE> for v in pe ( ns , n ) : <NEWLINE> <INDENT> v = list ( v ) <NEWLINE> <COMMENT> <NL> ct += 1 <NEWLINE> if p == v : <NEWLINE> <INDENT> a = ct <NEWLINE> <DEDENT> if q == v : <NEWLINE> <INDENT> b = ct <NEWLINE> <NL> <DEDENT> <DEDENT> print ( abs ( a - b ) ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> do ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = list ( <STRING> ) <NEWLINE> a = 1 <NEWLINE> while N > 26 ** a : <NEWLINE> <INDENT> N = N - 26 ** a <NEWLINE> a += 1 <NEWLINE> <NL> <DEDENT> pre = [ ] <NEWLINE> for i in reversed ( range ( 1 , a ) ) : <NEWLINE> <INDENT> r = ( N - 1 ) // 26 ** i <NEWLINE> pre . append ( r ) <NEWLINE> N = int ( N % ( 26 ** i ) ) <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> for i in pre : <NEWLINE> <INDENT> ans += L [ i ] <NEWLINE> <DEDENT> print ( ans + L [ N - 1 ] ) <NEWLINE>
x = input ( ) <NEWLINE> n = len ( x ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> ans . append ( x [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( ans ) > 0 : <NEWLINE> <INDENT> if ans [ - 1 ] == <STRING> : <NEWLINE> <INDENT> ans . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( x [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( x [ i ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> x = 7 <NEWLINE> ans = 1 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> if x % K == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> x = ( x * 10 + 7 ) % K <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( - 1 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if n // k != 0 : <NEWLINE> <INDENT> n -= ( n // k ) * k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def p ( n ) : <NEWLINE> <INDENT> if n > abs ( n - k ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> while p ( n ) : <NEWLINE> <INDENT> n = abs ( n - k ) <NEWLINE> <NL> <DEDENT> print ( n ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> n , k , * a = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + a <NEWLINE> check = [ 0 ] * ( n + 1 ) <NEWLINE> check [ 1 ] = 1 <NEWLINE> <NL> i = 0 <NEWLINE> nw = 1 <NEWLINE> path = [ 1 ] <NEWLINE> while 1 : <NEWLINE> <INDENT> nx = a [ nw ] <NEWLINE> i += 1 <NEWLINE> if i == k : <NEWLINE> <INDENT> print ( nx ) <NEWLINE> break <NEWLINE> <DEDENT> if check [ nx ] : <NEWLINE> <INDENT> j = path . index ( nx ) <NEWLINE> d = j + ( k - i ) % ( i - j ) <NEWLINE> print ( path [ d ] ) <NEWLINE> break <NEWLINE> <DEDENT> path . append ( nx ) <NEWLINE> check [ nx ] = 1 <NEWLINE> nw = nx <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( r * b * g - cnt ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> B = [ 1 ] <NEWLINE> <NL> <COMMENT> <NL> C = [ False ] * ( n + 1 ) <NEWLINE> C [ 1 ] = True <NEWLINE> <NL> <NL> while True : <NEWLINE> <INDENT> B . append ( A [ B [ - 1 ] ] ) <NEWLINE> if C [ B [ - 1 ] ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> C [ B [ - 1 ] ] = True <NEWLINE> <NL> <DEDENT> s = B . index ( B [ - 1 ] ) <NEWLINE> <NL> if k < s : <NEWLINE> <INDENT> print ( B [ k ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> B = B [ B . index ( B [ - 1 ] ) : - 1 ] <NEWLINE> print ( B [ ( k - s ) % len ( B ) ] ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = collections . defaultdict ( int ) <NEWLINE> for val in arr : <COMMENT> <NEWLINE> <INDENT> cnt [ val ] += 1 <NEWLINE> <DEDENT> sums = sum ( arr ) <COMMENT> <NEWLINE> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> diff = ( c - b ) * ( cnt [ b ] ) <NEWLINE> sums += diff <NEWLINE> print ( sums ) <NEWLINE> cnt [ c ] += cnt [ b ] <COMMENT> <NEWLINE> cnt [ b ] = 0 <COMMENT> <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def f ( t ) : <NEWLINE> <INDENT> if t != 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> c += i // t if i != t else 0 <NEWLINE> <DEDENT> return c <= K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return all ( i <= t for i in A ) <NEWLINE> <NL> <DEDENT> <DEDENT> left , right = - 1 , 10 ** 10 <NEWLINE> while right - left > 1 : <NEWLINE> <INDENT> m = ( right + left ) // 2 <NEWLINE> if f ( m ) : <NEWLINE> <INDENT> right = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = m <NEWLINE> <NL> <DEDENT> <DEDENT> print ( right ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> num1 = ( a - 1 ) // d <NEWLINE> num2 = ( c - 1 ) // b <NEWLINE> <NL> print ( <STRING> if num1 >= num2 else <STRING> ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if i + 1 > K : <NEWLINE> <INDENT> if a > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from collections import OrderedDict <NEWLINE> import sys <NEWLINE> <NL> cnt = OrderedDict ( ) <NEWLINE> for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) : <NEWLINE> <INDENT> cnt [ chr ( i ) ] = 0 <NEWLINE> <NL> <DEDENT> S = sys . stdin . readlines ( ) <NEWLINE> for s in S : <NEWLINE> <INDENT> s = s . lower ( ) <NEWLINE> for i in s : <NEWLINE> <INDENT> if i in cnt : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for k , v in cnt . items ( ) : <NEWLINE> <INDENT> print ( <STRING> . format ( k , v ) ) <NEWLINE> <DEDENT>
num = int ( input ( ) ) <NEWLINE> <NL> digits = len ( str ( num ) ) <NEWLINE> <NL> ans = digits <NEWLINE> <NL> for i in range ( 1 , 10 ** ( digits // 2 + 1 ) ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> target = max ( len ( str ( i ) ) , len ( str ( num // i ) ) ) <NEWLINE> if ans >= target : <NEWLINE> <INDENT> ans = target <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( str ( a * b ) + <STRING> + str ( 2 * a + 2 * b ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> from itertools import combinations <NEWLINE> <NL> mod = 1000000007 <COMMENT> <NEWLINE> <NL> s = 0 <NEWLINE> ans = 0 <NEWLINE> for n in A : <NEWLINE> <INDENT> s += n <NEWLINE> s %= mod <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> s -= A [ i ] <NEWLINE> ans += A [ i ] * s <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , v ) : <NEWLINE> <INDENT> if self . parents [ v ] < 0 : <NEWLINE> <INDENT> return v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ v ] = self . find ( self . parents [ v ] ) <NEWLINE> return self . parents [ v ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , u , v ) : <NEWLINE> <INDENT> u = self . find ( u ) <NEWLINE> v = self . find ( v ) <NEWLINE> <NL> if u == v : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ u ] > self . parents [ v ] : <NEWLINE> <INDENT> u , v = v , u <NEWLINE> <NL> <DEDENT> self . parents [ u ] += self . parents [ v ] <NEWLINE> self . parents [ v ] = u <NEWLINE> <NL> <DEDENT> def size ( self , v ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( v ) ] <NEWLINE> <NL> <DEDENT> def same ( self , u , v ) : <NEWLINE> <INDENT> return self . find ( u ) == self . find ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N + 1 ) <NEWLINE> F = [ 0 ] * ( N + 1 ) <NEWLINE> B = [ 0 ] * ( N + 1 ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . unite ( a , b ) <NEWLINE> F [ a ] += 1 <NEWLINE> F [ b ] += 1 <NEWLINE> <NL> <DEDENT> for _ in range ( K ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if uf . same ( c , d ) : <NEWLINE> <INDENT> B [ c ] += 1 <NEWLINE> B [ d ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans = uf . size ( i ) - F [ i ] - B [ i ] - 1 <NEWLINE> print ( ans , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> X = int ( input ( ) . rstrip ( ) ) <NEWLINE> f = 0 <NEWLINE> for a in range ( - 150 , 150 ) : <NEWLINE> <INDENT> for b in range ( - 150 , 150 ) : <NEWLINE> <INDENT> i = a ** 5 - b ** 5 <NEWLINE> if i == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> f = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst . sort ( ) <NEWLINE> lst . reverse ( ) <NEWLINE> x = sum ( lst ) <NEWLINE> if ( lst [ m - 1 ] < x / 4 / m ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max = 0 <NEWLINE> if k >= a : <NEWLINE> <INDENT> max += a <NEWLINE> if k >= a + b : <NEWLINE> <INDENT> max -= k - a - b <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> max += k <NEWLINE> <DEDENT> print ( max ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def cross_section_diagram ( diagram ) : <NEWLINE> <INDENT> stack = [ ] <NEWLINE> area = [ ] <NEWLINE> for i , ch in enumerate ( diagram ) : <NEWLINE> <INDENT> if ch == <STRING> : <NEWLINE> <INDENT> stack . append ( i ) <NEWLINE> <DEDENT> elif ch == <STRING> : <NEWLINE> <INDENT> if stack : <NEWLINE> <INDENT> point = stack . pop ( ) <NEWLINE> area . insert ( 0 , ( point , i - point ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> result = [ ] <NEWLINE> if area : <NEWLINE> <INDENT> p1 , cnt1 = area . pop ( 0 ) <NEWLINE> for p2 , cnt2 in area : <NEWLINE> <INDENT> if p1 < p2 : <NEWLINE> <INDENT> cnt1 += cnt2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . insert ( 0 , cnt1 ) <NEWLINE> p1 = p2 <NEWLINE> cnt1 = cnt2 <NEWLINE> <DEDENT> <DEDENT> result . insert ( 0 , cnt1 ) <NEWLINE> <NL> <DEDENT> print ( sum ( result ) ) <NEWLINE> result . insert ( 0 , len ( result ) ) <NEWLINE> print ( <STRING> . join ( [ str ( n ) for n in result ] ) ) <NEWLINE> return result <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> diagram = [ val for val in sys . stdin . read ( ) . splitlines ( ) ] <NEWLINE> cross_section_diagram ( diagram [ 0 ] ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ( H , W ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> print ( <STRING> * W ) <NEWLINE> for i in range ( H - 2 ) : <NEWLINE> <INDENT> print ( <STRING> , <STRING> * ( W - 2 ) , <STRING> , sep = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> print ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if n % k == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( n % k , abs ( ( n % k ) - k ) ) ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> michi = [ 0 ] * N <NEWLINE> hikui = [ 0 ] * N <NEWLINE> good = 0 <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> michi [ A - 1 ] += 1 <NEWLINE> michi [ B - 1 ] += 1 <NEWLINE> if H [ A - 1 ] > H [ B - 1 ] : <NEWLINE> <INDENT> hikui [ A - 1 ] += 1 <NEWLINE> <DEDENT> if H [ B - 1 ] > H [ A - 1 ] : <NEWLINE> <INDENT> hikui [ B - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if michi [ i ] == hikui [ i ] : <NEWLINE> <INDENT> good += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( good ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> u , v = map ( int , readline ( ) . split ( ) ) <NEWLINE> G [ u - 1 ] . append ( v - 1 ) <NEWLINE> <DEDENT> S , T = map ( int , readline ( ) . split ( ) ) <NEWLINE> S -= 1 <NEWLINE> T -= 1 <NEWLINE> <NL> dist = [ [ - 1 ] * 3 for _ in range ( N ) ] <NEWLINE> dist [ S ] [ 0 ] = 0 <NEWLINE> queue = deque ( [ ( S , 0 ) ] ) <NEWLINE> while queue : <NEWLINE> <INDENT> v , step = queue . popleft ( ) <NEWLINE> if step == 0 and v == T : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for nv in G [ v ] : <NEWLINE> <INDENT> if dist [ nv ] [ ( step - 1 ) % 3 ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ nv ] [ ( step - 1 ) % 3 ] = dist [ v ] [ step ] + 1 <NEWLINE> queue . append ( ( nv , ( step - 1 ) % 3 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if dist [ T ] [ 0 ] == - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dist [ T ] [ 0 ] // 3 ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> from math import sqrt <NEWLINE> <NL> MAX = 1000000 <NEWLINE> <NL> table = [ True ] * 1000000 <NEWLINE> table [ 0 ] = table [ 1 ] = False <NEWLINE> <NL> primes = [ ] <NEWLINE> counted = 0 <NEWLINE> <NL> for i in range ( MAX ) : <NEWLINE> <INDENT> if table [ i ] : <NEWLINE> <INDENT> primes . append ( i ) <NEWLINE> for j in range ( 2 * i , MAX , i ) : <NEWLINE> <INDENT> table [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> n = int ( line ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for prime in primes : <NEWLINE> <INDENT> if prime > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> l . sort ( ) <NEWLINE> set_l = set ( l ) <NEWLINE> set_l = sorted ( set_l ) <NEWLINE> limit = 10 ** 6 + 1 <NEWLINE> mp = [ 0 ] * ( limit ) <NEWLINE> pre = None <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num = l [ i ] <NEWLINE> if ( pre == num ) : <NEWLINE> <INDENT> mp [ num ] += 1 <NEWLINE> <DEDENT> pre = num <NEWLINE> <NL> <DEDENT> for x in set_l : <NEWLINE> <INDENT> for y in range ( x , limit , x ) : <NEWLINE> <INDENT> mp [ y ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for num in set_l : <NEWLINE> <INDENT> if ( mp [ num ] == 1 ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <NL>
t = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> if len ( t ) != 1 : <NEWLINE> <INDENT> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if i != 0 and i != len ( t ) - 1 : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> if t [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> elif t [ i + 1 ] == <STRING> or t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif i == 0 : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> if t [ i + 1 ] == <STRING> or t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if t [ 0 ] == <STRING> : <NEWLINE> <INDENT> t [ 0 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( t ) ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> dl = deque ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> cmd = input ( ) <NEWLINE> if <STRING> in cmd : <NEWLINE> <INDENT> op , v = cmd . split ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> op = cmd <NEWLINE> <DEDENT> if op == <STRING> : dl . appendleft ( v ) <NEWLINE> elif op == <STRING> : <NEWLINE> <INDENT> try : dl . remove ( v ) <NEWLINE> except ValueError : pass <NEWLINE> <DEDENT> elif op == <STRING> : dl . popleft ( ) <NEWLINE> elif op == <STRING> : dl . pop ( ) <NEWLINE> <DEDENT> print ( * dl ) <NEWLINE>
from bisect import bisect <NEWLINE> import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = [ int ( i . rstrip ( <STRING> ) ) for i in sys . stdin . readlines ( ) ] <NEWLINE> <COMMENT> <NL> L = [ ] <NEWLINE> def LIS ( ) : <NEWLINE> <INDENT> L . append ( A [ 0 ] ) <NEWLINE> length = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if L [ length ] < A [ i ] : <NEWLINE> <INDENT> length += 1 <NEWLINE> L . append ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A [ i ] in L : continue <NEWLINE> j = bisect ( L , A [ i ] , 0 , length ) <COMMENT> <NEWLINE> L [ j ] = A [ i ] <NEWLINE> <DEDENT> <DEDENT> return length + 1 <NEWLINE> <NL> <DEDENT> print ( LIS ( ) ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> print ( s . replace ( <STRING> , <STRING> ) ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> N , M , X = 0 , 0 , 0 <NEWLINE> BOOKS = [ ] <NEWLINE> <NL> <NL> def calc_price ( book_combinations ) : <NEWLINE> <INDENT> price = 0 <NEWLINE> understandings = [ 0 ] * M <NEWLINE> for i in range ( len ( book_combinations ) ) : <NEWLINE> <INDENT> if book_combinations [ i ] : <NEWLINE> <INDENT> price += BOOKS [ i ] [ 0 ] <NEWLINE> for j in range ( len ( BOOKS [ i ] [ 1 : ] ) ) : <NEWLINE> <INDENT> understandings [ j ] += BOOKS [ i ] [ j + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for u in understandings : <NEWLINE> <INDENT> if u < X : <COMMENT> <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return price <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> global N , M , X , BOOKS <NEWLINE> N , M , X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> BOOKS = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> ans = float ( <STRING> ) <NEWLINE> for i in range ( 1 , 2 ** N ) : <COMMENT> <NEWLINE> <INDENT> price = calc_price ( [ ( i >> j ) & 1 for j in range ( N ) ] ) <NEWLINE> if 0 < price and price < ans : <NEWLINE> <INDENT> ans = price <NEWLINE> <DEDENT> <DEDENT> if ans == float ( <STRING> ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> mydict = { } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> tmp = sorted ( input ( ) , key = str . lower ) <NEWLINE> tmp = <STRING> . join ( sorted ( tmp ) ) <NEWLINE> if tmp in mydict : <NEWLINE> <INDENT> mydict [ tmp ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mydict . setdefault ( tmp , 1 ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in mydict . values ( ) : <NEWLINE> <INDENT> ans += i * ( i - 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE> <NL>
from collections import defaultdict <NEWLINE> from itertools import accumulate <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> prime_counter = defaultdict ( int ) <NEWLINE> acc = tuple ( accumulate ( range ( 1 , 42 ) ) ) <COMMENT> <NEWLINE> <NL> f = 2 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> n //= f <NEWLINE> prime_counter [ f ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 1 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> prime_counter [ n ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for c in prime_counter . values ( ) : <NEWLINE> <INDENT> for i , x in enumerate ( acc ) : <NEWLINE> <INDENT> if c < x : <NEWLINE> <INDENT> tmp = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> ans += tmp <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> l = 0 <NEWLINE> r = len ( s ) - 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> while l < r : <NEWLINE> <INDENT> lx = 0 <NEWLINE> while s [ l ] == <STRING> and l < len ( s ) - 1 : <NEWLINE> <INDENT> lx += 1 <NEWLINE> l += 1 <NEWLINE> <NL> <DEDENT> rx = 0 <NEWLINE> while s [ r ] == <STRING> and r > 0 : <NEWLINE> <INDENT> rx += 1 <NEWLINE> r -= 1 <NEWLINE> <NL> <DEDENT> if s [ l ] == s [ r ] : <NEWLINE> <INDENT> cnt += abs ( rx - lx ) <NEWLINE> <NL> l += 1 <NEWLINE> r -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A , B = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> num , x = 0 , m <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if A [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while A [ i ] + B [ x ] > k : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> num = max ( num , i + x ) <NEWLINE> <NL> <DEDENT> print ( num ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> if n % 1000 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - ( n % 1000 ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( b - 1 , n ) <NEWLINE> <NL> res = math . floor ( ( a * x ) / b ) - a * math . floor ( x / b ) <NEWLINE> print ( res ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> if <STRING> in N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = [ s for s in input ( ) ] <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if N - 1 < k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ k ] != S [ i ] and S [ k ] != S [ j ] and S [ i ] != S [ j ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> A = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> C = [ x for x in range ( - 10 , 110 ) ] <NEWLINE> C = set ( C ) <NEWLINE> B = set ( B ) <NEWLINE> C = C . difference ( B ) <NEWLINE> C = list ( C ) <NEWLINE> X = A [ 0 ] <NEWLINE> N = A [ 1 ] <NEWLINE> record = 200 <NEWLINE> number = 1000 <NEWLINE> K = 0 <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> K = 1 <NEWLINE> <NL> <DEDENT> for t in C : <NEWLINE> <INDENT> diff = abs ( t - X ) <NEWLINE> if diff < record : <NEWLINE> <INDENT> record = diff <NEWLINE> number = t <NEWLINE> <DEDENT> elif diff == record : <NEWLINE> <INDENT> number = min ( number , t ) <NEWLINE> <NL> <DEDENT> <DEDENT> if K == 0 : <NEWLINE> <INDENT> print ( number ) <NEWLINE> <DEDENT>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> k_1 = set ( ) <NEWLINE> k_2 = set ( ) <NEWLINE> tmp = list ( ) <NEWLINE> loop_number = 0 <NEWLINE> loop_sum = 0 <NEWLINE> while x not in k_1 : <NEWLINE> <INDENT> k_1 . add ( x ) <NEWLINE> x = x * x % m <NEWLINE> <DEDENT> while x not in k_2 : <NEWLINE> <INDENT> k_2 . add ( x ) <NEWLINE> tmp . append ( x ) <NEWLINE> loop_number += 1 <NEWLINE> loop_sum += x <NEWLINE> x = x * x % m <NEWLINE> <DEDENT> ans = 0 <NEWLINE> k_1 = list ( k_1 ) <NEWLINE> for i in range ( len ( k_1 ) ) : <NEWLINE> <INDENT> ans += k_1 [ i ] <NEWLINE> <DEDENT> ans = ans + loop_sum * ( ( n - len ( k_1 ) ) // loop_number ) <NEWLINE> for i in range ( ( n - len ( k_1 ) ) % loop_number ) : <NEWLINE> <INDENT> ans += tmp [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> num = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( num , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> from collections import defaultdict <NEWLINE> <NL> I = sys . stdin . readline <NEWLINE> <NL> n = int ( I ( ) ) <NEWLINE> arr = sorted ( list ( map ( int , I ( ) . split ( ) ) ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> <NL> for i in arr : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> visited = [ 0 ] * ( arr [ - 1 ] + 1 ) <NEWLINE> for i in arr : <NEWLINE> <INDENT> if d [ i ] == 1 and visited [ i ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> for j in range ( i , arr [ - 1 ] + 1 , i ) : <NEWLINE> <INDENT> visited [ j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ - a for a in map ( int , input ( ) . split ( ) ) ] <NEWLINE> heapq . heapify ( A ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> x = - heapq . heappop ( A ) <NEWLINE> heapq . heappush ( A , - ( x // 2 ) ) <NEWLINE> <DEDENT> ans = - sum ( A ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> data = [ ] <NEWLINE> csum = [ 0 ] * c <NEWLINE> <NL> for i in range ( r ) : <NEWLINE> <INDENT> data . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( r ) : <NEWLINE> <INDENT> for j in range ( c ) : <NEWLINE> <INDENT> print ( <STRING> . format ( data [ i ] [ j ] ) , end = <STRING> ) <NEWLINE> csum [ j ] += data [ i ] [ j ] <NEWLINE> <DEDENT> print ( sum ( data [ i ] ) ) <NEWLINE> <NL> <DEDENT> for j in range ( c ) : <NEWLINE> <INDENT> print ( <STRING> . format ( csum [ j ] ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( sum ( csum ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> S = input ( ) [ : : - 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> X = [ 0 ] <NEWLINE> <NL> <COMMENT> <NL> <NL> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> X . append ( ( X [ - 1 ] + int ( s ) * pow ( 10 , i , 2019 ) ) % 2019 ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> C = Counter ( X ) <NEWLINE> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for v in C . values ( ) : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> h , w , * s = open ( 0 ) . read ( ) . split ( ) <NEWLINE> h = int ( h ) <NEWLINE> w = int ( w ) <NEWLINE> <NL> q = deque ( ) <NEWLINE> used = [ False ] * ( h * w ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if not used [ i * w + j ] : <NEWLINE> <INDENT> bcnt = 0 <NEWLINE> cnt = 0 <NEWLINE> <NL> q . append ( ( i , j ) ) <NEWLINE> used [ i * w + j ] = True <NEWLINE> cnt += 1 <NEWLINE> bcnt += s [ i ] [ j ] == <STRING> <NEWLINE> <NL> while len ( q ) : <NEWLINE> <INDENT> y , x = q . popleft ( ) <NEWLINE> for dy , dx in [ ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( - 1 , 0 ) ] : <NEWLINE> <INDENT> ny = y + dy <NEWLINE> nx = x + dx <NEWLINE> if 0 <= nx < w and 0 <= ny < h and s [ y ] [ x ] != s [ ny ] [ nx ] and not used [ ny * w + nx ] : <NEWLINE> <INDENT> q . append ( ( ny , nx ) ) <NEWLINE> used [ ny * w + nx ] = True <NEWLINE> cnt += 1 <NEWLINE> bcnt += s [ ny ] [ nx ] == <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans += bcnt * ( cnt - bcnt ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> if Y == 0 : <NEWLINE> <INDENT> answer = X <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list_1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mylist = list ( range ( - 100 , 200 ) ) <NEWLINE> <NL> list_2 = list ( filter ( lambda x : x not in list_1 , mylist ) ) <NEWLINE> <NL> list_3 = list ( map ( lambda x : x - X , list_2 ) ) <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> abslist = np . abs ( list_3 ) <NEWLINE> <NL> min_num = min ( abslist ) <NEWLINE> <NL> answer_lisbef = [ X - min_num , X + min_num ] <NEWLINE> <NL> answer_lisaf = list ( filter ( lambda x : x not in list_1 , answer_lisbef ) ) <NEWLINE> <NL> answer = min ( answer_lisaf ) <NEWLINE> <DEDENT> print ( answer ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> num [ x ] += 1 <NEWLINE> <NL> <DEDENT> pairwise = True <NEWLINE> for i in range ( 2 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> cnt = sum ( num [ i : : i ] ) <NEWLINE> if cnt == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if cnt > 1 : <NEWLINE> <INDENT> pairwise = False <NEWLINE> <NL> <DEDENT> <DEDENT> if pairwise : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from math import sqrt , ceil <NEWLINE> <NL> def_val = 2 ** 31 - 1 <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> unit = ceil ( sqrt ( n ) ) <NEWLINE> <NL> l = [ ( def_val , [ def_val ] * unit ) for _ in range ( unit ) ] <NEWLINE> <NL> while q : <NEWLINE> <INDENT> op , s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> sd , sm = s // unit , s % unit <NEWLINE> if op : <NEWLINE> <INDENT> td , tm = t // unit , t % unit <NEWLINE> if sd == td : <NEWLINE> <INDENT> print ( min ( l [ sd ] [ 1 ] [ sm : tm + 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> unit_min = min ( ( tup [ 0 ] for tup in l [ sd + 1 : td ] ) , default = def_val ) <NEWLINE> s_min = min ( l [ sd ] [ 1 ] [ sm : ] , default = def_val ) <NEWLINE> t_min = min ( l [ td ] [ 1 ] [ : tm + 1 ] , default = def_val ) <NEWLINE> print ( min ( unit_min , s_min , t_min ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> unit_list = l [ sd ] [ 1 ] <NEWLINE> unit_list [ sm ] = t <NEWLINE> l [ sd ] = ( min ( unit_list ) , unit_list ) <NEWLINE> <DEDENT> q -= 1 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> y = n // i <NEWLINE> ans += i * y * ( y + 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if not x in p : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> up = x + 1 <NEWLINE> down = x - 1 <NEWLINE> while True : <NEWLINE> <INDENT> if not down in p : <NEWLINE> <INDENT> print ( down ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif not up in p : <NEWLINE> <INDENT> print ( up ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> up += 1 <NEWLINE> down -= 1 <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> def isPrime_np ( n ) : <NEWLINE> <INDENT> maxp = int ( np . sqrt ( n ) ) <NEWLINE> searchlist = [ i for i in range ( 2 , n + 1 ) ] <NEWLINE> primeNum = [ ] <NEWLINE> <NL> while searchlist [ 0 ] <= maxp : <NEWLINE> <INDENT> primeNum . append ( searchlist [ 0 ] ) <NEWLINE> tmp = searchlist [ 0 ] <NEWLINE> searchlist = [ i for i in searchlist if i % tmp != 0 ] <NEWLINE> <DEDENT> primeNum . extend ( searchlist ) <NEWLINE> <NL> return primeNum <NEWLINE> <NL> <DEDENT> MaxQ = 10 ** 5 + 1 <NEWLINE> Q = int ( input ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> a = [ 0 ] * MaxQ <NEWLINE> s = [ 0 ] * MaxQ <NEWLINE> prime = isPrime_np ( MaxQ ) <NEWLINE> pset = set ( prime ) <NEWLINE> for p in prime : <NEWLINE> <INDENT> if ( p + 1 ) / 2 in pset : <NEWLINE> <INDENT> a [ p ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for i in range ( MaxQ - 1 ) : <NEWLINE> <INDENT> s [ i + 1 ] = s [ i ] + a [ i ] <NEWLINE> <NL> <DEDENT> for l , r in lr : <NEWLINE> <INDENT> ans . append ( s [ r + 1 ] - s [ l ] ) <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> E = int ( input ( ) ) <NEWLINE> <NL> if A % 10 == 0 : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 10 - A % 10 <NEWLINE> <NL> <DEDENT> if B % 10 == 0 : <NEWLINE> <INDENT> b = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = 10 - B % 10 <NEWLINE> <NL> <DEDENT> if C % 10 == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = 10 - C % 10 <NEWLINE> <NL> <DEDENT> if D % 10 == 0 : <NEWLINE> <INDENT> d = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = 10 - D % 10 <NEWLINE> <NL> <DEDENT> if E % 10 == 0 : <NEWLINE> <INDENT> e = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e = 10 - E % 10 <NEWLINE> <NL> <DEDENT> sum = A + B + C + D + E + a + b + c + d + e - max ( a , b , c , d , e ) <NEWLINE> <NL> print ( sum ) <NEWLINE>
<NL> import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> t = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> m = math . gcd ( t , k ) <NEWLINE> count += m <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from collections import deque , defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> data = [ [ ] for _ in range ( n ) ] <NEWLINE> sides = [ ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> data [ a ] . append ( b ) <NEWLINE> data [ b ] . append ( a ) <NEWLINE> sides . append ( ( a , b ) ) <NEWLINE> <DEDENT> I = defaultdict ( lambda : 0 ) <NEWLINE> cs = [ 0 ] * n <NEWLINE> used = [ 0 ] * n <NEWLINE> q = deque ( [ 0 ] ) <NEWLINE> used [ 0 ] = 1 <NEWLINE> k = 0 <NEWLINE> while q : <NEWLINE> <INDENT> u = q . popleft ( ) <NEWLINE> if k < len ( data [ u ] ) : <NEWLINE> <INDENT> k = len ( data [ u ] ) <NEWLINE> <DEDENT> cur = 1 <NEWLINE> for v in data [ u ] : <NEWLINE> <INDENT> if used [ v ] : continue <NEWLINE> if cur == cs [ u ] : cur += 1 <NEWLINE> cs [ v ] = cur <NEWLINE> I [ ( u , v ) ] = cur <NEWLINE> I [ ( v , u ) ] = cur <NEWLINE> cur += 1 <NEWLINE> used [ v ] = 1 <NEWLINE> q . append ( v ) <NEWLINE> <DEDENT> <DEDENT> print ( k ) <NEWLINE> for i , j in sides : <NEWLINE> <INDENT> print ( I [ ( i , j ) ] ) <NEWLINE> <DEDENT>
from itertools import combinations <NEWLINE> <NL> <NL> N , K , * XY = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> X = sorted ( XY [ : : 2 ] ) <NEWLINE> Y = sorted ( XY [ 1 : : 2 ] ) <NEWLINE> <NL> ans = 10 ** 20 <NEWLINE> for x1 , x2 in combinations ( X , 2 ) : <NEWLINE> <INDENT> for y1 in Y [ : - 1 ] : <NEWLINE> <INDENT> y2s = sorted ( y for x , y in zip ( * [ iter ( XY ) ] * 2 ) if x1 <= x <= x2 and y1 <= y ) <NEWLINE> if len ( y2s ) < K : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans = min ( ans , ( x2 - x1 ) * ( y2s [ K - 1 ] - y1 ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
from collections import deque , defaultdict <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> outs = defaultdict ( list ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> v1 , v2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> outs [ v1 ] . append ( v2 ) <NEWLINE> outs [ v2 ] . append ( v1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> q = deque ( [ 1 ] ) <NEWLINE> depth = defaultdict ( int ) <NEWLINE> depth [ 1 ] = 0 <NEWLINE> visit = [ False ] * N <COMMENT> <NEWLINE> visit [ 0 ] = True <NEWLINE> <COMMENT> <NL> while q : <NEWLINE> <INDENT> v1 = q . popleft ( ) <NEWLINE> <COMMENT> <NL> for v2 in outs [ v1 ] : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> if visit [ v2 - 1 ] == False : <NEWLINE> <INDENT> visit [ v2 - 1 ] = True <NEWLINE> depth [ v2 ] = v1 <NEWLINE> q . append ( v2 ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> b = sorted ( depth . items ( ) ) <NEWLINE> <COMMENT> <NL> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( b [ i ] [ 1 ] ) <NEWLINE> <DEDENT>
from math import pow <NEWLINE> def get_table ( ) : <NEWLINE> <INDENT> table = [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> a = int ( pow ( 10 , i ) ) <NEWLINE> table . append ( a % 2019 ) <NEWLINE> <DEDENT> return table <NEWLINE> <NL> <DEDENT> table = get_table ( ) <NEWLINE> <COMMENT> <NL> <NL> def get_power_2019 ( idx ) : <NEWLINE> <INDENT> if ( idx < len ( table ) ) : <NEWLINE> <INDENT> return table [ idx ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = int ( idx / 2 ) <NEWLINE> i = idx - j <NEWLINE> return ( get_power_2019 ( i ) * get_power_2019 ( j ) ) % 2019 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 10 , 10000 ) : <NEWLINE> <INDENT> curr = get_power_2019 ( i ) <NEWLINE> table . append ( curr ) <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> mod_dict = { } <NEWLINE> <NL> last_mod = 0 <NEWLINE> for i in range ( len ( s ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> current_lowest_digit = int ( s [ i ] ) <NEWLINE> current_mod = ( ( current_lowest_digit * get_power_2019 ( len ( s ) - 1 - i ) ) % 2019 + last_mod ) % 2019 <NEWLINE> if ( current_mod not in mod_dict . keys ( ) ) : <NEWLINE> <INDENT> mod_dict [ current_mod ] = [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mod_dict [ current_mod ] . append ( i ) <NEWLINE> <DEDENT> last_mod = current_mod <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> count = 0 <NEWLINE> for k in mod_dict . keys ( ) : <NEWLINE> <INDENT> n = len ( mod_dict [ k ] ) <NEWLINE> count += int ( n * ( n - 1 ) / 2 ) <NEWLINE> if ( k == 0 ) : <NEWLINE> <INDENT> count += n <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
nq = str ( input ( ) ) . split ( ) <NEWLINE> n = int ( nq [ 0 ] ) <NEWLINE> q = int ( nq [ 1 ] ) <NEWLINE> p = [ str ( input ( ) ) . split ( ) for i in range ( n ) ] <NEWLINE> p = [ ( str ( i [ 0 ] ) , int ( i [ 1 ] ) ) for i in p ] <NEWLINE> ans = [ ] <NEWLINE> time = 0 <NEWLINE> while len ( p ) != 0 : <NEWLINE> <INDENT> t = p . pop ( 0 ) <NEWLINE> if t [ 1 ] > q : <NEWLINE> <COMMENT> <NL> <INDENT> time += q <NEWLINE> p . append ( ( t [ 0 ] , t [ 1 ] - q ) ) <NEWLINE> <DEDENT> elif t [ 1 ] <= q : <NEWLINE> <COMMENT> <NL> <INDENT> ans . append ( ( t [ 0 ] , t [ 1 ] + time ) ) <NEWLINE> time += t [ 1 ] <NEWLINE> <DEDENT> <DEDENT> for t in ans : <NEWLINE> <INDENT> print ( <STRING> . format ( t [ 0 ] , t [ 1 ] ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> i = 1 <NEWLINE> while i ** 2 < N : <NEWLINE> <INDENT> j = i <NEWLINE> while i * j < N : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 2 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> u = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ans > u : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> nk = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = nk [ 0 ] <NEWLINE> k = nk [ 1 ] <NEWLINE> dp = [ 10 ** 9 ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ j ] + abs ( h [ i ] - h [ j ] ) for j in range ( max ( 0 , i - k ) , i ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = [ [ [ 0 for z in range ( 10 ) ] for y in range ( 3 ) ] for x in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> , * a [ i ] [ j ] ) <NEWLINE> <DEDENT> if i != 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
def f2 ( cnt , n , ci ) : <NEWLINE> <INDENT> if ci >= 10 or n > 45 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif n < ci : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif n == ci and cnt > 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif n == ci and cnt == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v = f2 ( cnt - 1 , n - ci , ci + 1 ) <NEWLINE> v += f2 ( cnt , n , ci + 1 ) <NEWLINE> return v <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> n , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and s == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( f2 ( n , s , 0 ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> a_nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> tmp_1 = { } <NEWLINE> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i + a_nums [ i - 1 ] in tmp_1 : <NEWLINE> <INDENT> tmp_1 [ i + a_nums [ i - 1 ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp_1 [ i + a_nums [ i - 1 ] ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if j - a_nums [ j - 1 ] in tmp_1 : <NEWLINE> <INDENT> ans += tmp_1 [ j - a_nums [ j - 1 ] ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * ( 10 ** 5 + 3 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> dp [ a [ i ] + j ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( max ( dp ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a1 = sorted ( a , reverse = True ) <NEWLINE> a2 = sorted ( a ) <NEWLINE> ans = 1 <NEWLINE> if len ( a ) < 90 : <NEWLINE> <INDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a2 [ 0 ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif a1 [ 90 ] > 1 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> del a1 [ 90 : ] <NEWLINE> for i in range ( len ( a1 ) ) : <NEWLINE> <INDENT> ans *= a1 [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sums = sum ( a ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <COMMENT> <NL> <INDENT> if i >= ( sums / ( M * 4 ) ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if count >= M : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( [ 0 ] + [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> B = np . array ( [ 0 ] + [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> A . cumsum ( out = A ) <NEWLINE> B . cumsum ( out = B ) <NEWLINE> <NL> ans = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if A [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while B [ j ] + A [ i ] > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> import sys <NEWLINE> <NL> N , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> T = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> T . sort ( ) <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> <NL> if T [ 0 ] + K >= T [ - 1 ] : <NEWLINE> <INDENT> if N % C == 0 : <NEWLINE> <INDENT> print ( N // C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N // C + 1 ) <NEWLINE> <DEDENT> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> t = bisect . bisect_right ( T , T [ i ] + K ) <NEWLINE> if t - i > C : <NEWLINE> <INDENT> i += C <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = t <NEWLINE> <DEDENT> ans += 1 <NEWLINE> if i == N - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> if i > N - 1 : <NEWLINE> <INDENT> i = N - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) ) <NEWLINE> inp = sys . stdin . readlines ( ) <NEWLINE> lis = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> com = inp [ i ] . split ( ) <NEWLINE> if com [ 0 ] == <STRING> : <NEWLINE> <INDENT> lis . add ( com [ 1 ] ) <NEWLINE> <DEDENT> elif com [ 1 ] in lis : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> r , c , m = map ( int , input ( ) . split ( ) ) <NEWLINE> q = set ( tuple ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) for _ in range ( m ) ) <NEWLINE> rows = [ 0 ] * r <NEWLINE> cols = [ 0 ] * c <NEWLINE> <NL> for i , j in q : <NEWLINE> <INDENT> rows [ i ] += 1 <NEWLINE> cols [ j ] += 1 <NEWLINE> <NL> <DEDENT> MAXR = max ( rows ) <NEWLINE> MAXC = max ( cols ) <NEWLINE> <NL> ans = MAXR + MAXC - 1 <NEWLINE> <NL> rlist = [ ] <NEWLINE> clist = [ ] <NEWLINE> <NL> for i in range ( r ) : <NEWLINE> <INDENT> if rows [ i ] == MAXR : <NEWLINE> <INDENT> rlist . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( c ) : <NEWLINE> <INDENT> if cols [ j ] == MAXC : <NEWLINE> <INDENT> clist . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in rlist : <NEWLINE> <INDENT> for j in clist : <NEWLINE> <INDENT> if ( i , j ) in q : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> results = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> print ( <STRING> if results [ i ] < results [ i + k ] else <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
rank = sorted ( [ int ( input ( ) ) for i in range ( 10 ) ] , reverse = True ) <NEWLINE> print ( <STRING> . join ( map ( str , rank [ : 3 ] ) ) ) <NEWLINE>
import sys <NEWLINE> import string <NEWLINE> <NL> alphabets = list ( string . ascii_lowercase ) <NEWLINE> <NL> s = input ( ) <NEWLINE> <NL> l = len ( s ) <NEWLINE> <NL> hm = lambda a , string : sum ( [ x == a for x in string ] ) <NEWLINE> <NL> for x in range ( l - 1 ) : <NEWLINE> <INDENT> if s [ x ] == s [ x + 1 ] : <NEWLINE> <INDENT> print ( <STRING> . format ( x + 1 , x + 2 ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for n in range ( l - 3 ) : <NEWLINE> <INDENT> for a in alphabets : <NEWLINE> <INDENT> if hm ( a , s [ n : n + 3 ] ) > 1 : <NEWLINE> <INDENT> print ( <STRING> . format ( n + 1 , n + 3 ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import collections <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> Q = collections . deque ( [ int ( i ) for i in range ( 1 , 10 ) ] ) <NEWLINE> chk = False <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> x = Q . popleft ( ) <NEWLINE> if i + len ( Q ) > k : <NEWLINE> <INDENT> chk = True <NEWLINE> <DEDENT> if chk : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x % 10 : <NEWLINE> <INDENT> Q . append ( 10 * x + x % 10 - 1 ) <NEWLINE> <DEDENT> Q . append ( 10 * x + x % 10 ) <NEWLINE> if x % 10 != 9 : <NEWLINE> <INDENT> Q . append ( 10 * x + x % 10 + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( x ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = n % k <NEWLINE> y = abs ( x - k ) <NEWLINE> <NL> if x < y : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y ) <NEWLINE> <NL> <NL> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A [ i ] >= A [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> <NL> m = { } <NEWLINE> <NL> for i in range ( 1000000 ) : <NEWLINE> <INDENT> m [ i ] = 0 <NEWLINE> <NL> <DEDENT> for e in a : <NEWLINE> <INDENT> m [ e ] += 1 <NEWLINE> <NL> <DEDENT> ans = sum ( a ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , q = map ( int , input ( ) . split ( ) ) <NEWLINE> diff = ( q - b ) * m [ b ] <NEWLINE> <NL> m [ q ] += m [ b ] <NEWLINE> m [ b ] = 0 <NEWLINE> <NL> ans += diff <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in i : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for num in range ( N ) : <NEWLINE> <INDENT> ans = ans * i [ num ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> a = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( a * a * math . pi , ( a + a ) * math . pi ) ) <NEWLINE>
a = 0 <NEWLINE> while a < 100 : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif h == 1 and w == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif h == 2 and w == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> elif h % 2 == 0 and w % 2 == 0 : <NEWLINE> <INDENT> b = 0 <NEWLINE> while b <= ( h - 2 ) / 2 : <NEWLINE> <INDENT> for i in range ( int ( w / 2 ) ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> for j in range ( int ( w / 2 ) ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> b += 1 <NEWLINE> <DEDENT> <DEDENT> elif h % 2 == 1 and w % 2 == 0 : <NEWLINE> <INDENT> b = 0 <NEWLINE> while b < ( h - 2 ) / 2 : <NEWLINE> <INDENT> for i in range ( int ( w / 2 ) ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> for j in range ( int ( w / 2 ) ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> b += 1 <NEWLINE> <DEDENT> for i in range ( int ( w / 2 ) ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> elif h % 2 == 0 and w % 2 == 1 : <NEWLINE> <INDENT> b = 0 <NEWLINE> while b <= ( h - 2 ) / 2 : <NEWLINE> <INDENT> for i in range ( int ( w / 2 ) ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for j in range ( int ( w / 2 ) ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> b += 1 <NEWLINE> <DEDENT> <DEDENT> elif h % 2 == 1 and w % 2 == 1 : <NEWLINE> <INDENT> b = 0 <NEWLINE> while b <= ( h - 2 ) / 2 : <NEWLINE> <INDENT> for i in range ( int ( w / 2 ) ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for j in range ( int ( w / 2 ) ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> b += 1 <NEWLINE> <DEDENT> for i in range ( int ( w / 2 ) ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> a += 1 <NEWLINE> <DEDENT>
class Dice : <NEWLINE> <INDENT> def __init__ ( self , l1 , l2 , l3 , l4 , l5 , l6 ) : <NEWLINE> <INDENT> self . l1 = l1 <NEWLINE> self . l2 = l2 <NEWLINE> self . l3 = l3 <NEWLINE> self . l4 = l4 <NEWLINE> self . l5 = l5 <NEWLINE> self . l6 = l6 <NEWLINE> self . top = 1 <NEWLINE> self . front = 2 <NEWLINE> self . right = 3 <NEWLINE> <NL> <DEDENT> def get_top ( self ) : <NEWLINE> <INDENT> return eval ( <STRING> + <STRING> + str ( self . top ) ) <NEWLINE> <NL> <DEDENT> def get_right ( self ) : <NEWLINE> <INDENT> return eval ( <STRING> + <STRING> + str ( self . right ) ) <NEWLINE> <NL> <DEDENT> def get_front ( self ) : <NEWLINE> <INDENT> return eval ( <STRING> + <STRING> + str ( self . front ) ) <NEWLINE> <NL> <DEDENT> def get_bottom ( self ) : <NEWLINE> <INDENT> return eval ( <STRING> + <STRING> + str ( 7 - self . top ) ) <NEWLINE> <NL> <DEDENT> def get_left ( self ) : <NEWLINE> <INDENT> return eval ( <STRING> + <STRING> + str ( 7 - self . right ) ) <NEWLINE> <NL> <DEDENT> def get_back ( self ) : <NEWLINE> <INDENT> return eval ( <STRING> + <STRING> + str ( 7 - self . front ) ) <NEWLINE> <NL> <DEDENT> def rot ( self ) : <NEWLINE> <INDENT> self . front , self . right = self . right , 7 - self . front <NEWLINE> <NL> <DEDENT> def move ( self , order ) : <NEWLINE> <INDENT> if order == <STRING> : <NEWLINE> <INDENT> pretop = self . top <NEWLINE> self . top = 7 - self . front <NEWLINE> self . front = pretop <NEWLINE> <DEDENT> elif order == <STRING> : <NEWLINE> <INDENT> pretop = self . top <NEWLINE> self . top = 7 - self . right <NEWLINE> self . right = pretop <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def match_top ( dice , target ) : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> dice . move ( <STRING> ) <NEWLINE> if dice . get_top ( ) == target : <NEWLINE> <INDENT> return dice <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d1 = Dice ( l [ 0 ] , l [ 1 ] , l [ 2 ] , l [ 3 ] , l [ 4 ] , l [ 5 ] ) <NEWLINE> <NL> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d2 = Dice ( l [ 0 ] , l [ 1 ] , l [ 2 ] , l [ 3 ] , l [ 4 ] , l [ 5 ] ) <NEWLINE> <NL> d1_top = d1 . get_top ( ) <NEWLINE> d1_front = d1 . get_front ( ) <NEWLINE> d1_right = d1 . get_right ( ) <NEWLINE> d1_bottom = d1 . get_bottom ( ) <NEWLINE> d1_back = d1 . get_back ( ) <NEWLINE> d1_left = d1 . get_left ( ) <NEWLINE> ret = match_top ( d2 , d1_top ) <NEWLINE> <NL> if ret == False : <NEWLINE> <INDENT> d2 . move ( <STRING> ) <NEWLINE> ret = match_top ( d2 , d1_top ) <NEWLINE> <DEDENT> if ret == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> matched = False <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> d2 . rot ( ) <NEWLINE> if d2 . get_front ( ) == d1_front and d2 . get_right ( ) == d1_right and d2 . get_bottom ( ) == d1_bottom and d2 . get_left ( ) == d1_left and d2 . get_back ( ) == d1_back : <NEWLINE> <INDENT> matched = True <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not matched : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b , n = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> def floor ( x ) : <NEWLINE> <INDENT> return ( ( a * x / b ) // 1 ) - a * ( ( x / b ) // 1 ) <NEWLINE> <NL> <DEDENT> ans = floor ( min ( b - 1 , n ) ) <NEWLINE> <NL> print ( int ( ans ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if b - 1 <= n : <NEWLINE> <INDENT> cand = [ b - 1 , n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cand = [ n ] <NEWLINE> <DEDENT> print ( max ( a * x // b - a * ( x // b ) for x in cand ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> lena = int ( len ( a ) ) <NEWLINE> for j in range ( lena ) : <NEWLINE> <INDENT> l . append ( a [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> c = Counter ( l ) <NEWLINE> print ( n - len ( c ) ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> ru = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ru . append ( int ( i + 1 + a [ i ] ) ) <NEWLINE> <NL> <DEDENT> c = collections . Counter ( ru ) <NEWLINE> <COMMENT> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> tmp = i + 1 - a [ i ] <NEWLINE> ans += c [ tmp ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> max_v = A [ 1 ] - A [ 0 ] <NEWLINE> <NL> l = 0 <NEWLINE> r = 1 <NEWLINE> while r + 1 < N : <NEWLINE> <INDENT> if A [ l ] > A [ r ] : <NEWLINE> <INDENT> l = r <NEWLINE> <DEDENT> elif A [ r ] > A [ r + 1 ] : <NEWLINE> <INDENT> max_v = max ( max_v , A [ r ] - A [ l ] ) <NEWLINE> if A [ l ] > A [ r + 1 ] : <NEWLINE> <INDENT> l = r + 1 <NEWLINE> r = l <NEWLINE> <DEDENT> <DEDENT> r += 1 <NEWLINE> <DEDENT> if r < N : <NEWLINE> <INDENT> max_v = max ( max_v , A [ r ] - A [ l ] ) <NEWLINE> <DEDENT> print ( max_v ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> d = deque ( ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> d = deque ( ) <NEWLINE> for i in g [ 1 ] : <NEWLINE> <INDENT> d . append ( i ) <NEWLINE> ans [ i ] = 1 <NEWLINE> <NL> <DEDENT> while d : <NEWLINE> <INDENT> tmp = d [ 0 ] <NEWLINE> for i in g [ tmp ] : <NEWLINE> <INDENT> if ans [ i ] == 0 : <NEWLINE> <INDENT> ans [ i ] = tmp <NEWLINE> d . append ( i ) <NEWLINE> <DEDENT> <DEDENT> d . popleft ( ) <NEWLINE> <NL> <DEDENT> if 0 in ans [ 2 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> def main ( ) : <NEWLINE> <INDENT> w , h , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == 0 or y == 0 : <NEWLINE> <INDENT> print ( w * h / 2 , 0 ) <NEWLINE> <DEDENT> elif w / x == 2 and h / y == 2 : <NEWLINE> <INDENT> r = x * h <NEWLINE> print ( r , 1 ) <NEWLINE> <DEDENT> elif w / x == 2 or h / y == 2 : <NEWLINE> <INDENT> if w / x == 2 : <NEWLINE> <INDENT> r = x * h <NEWLINE> print ( r , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = y * w <NEWLINE> print ( r , 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( w * h / 2 , 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> <NL> dict = { } <NEWLINE> num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> length = len ( num_list ) <NEWLINE> count = [ 0 ] * ( s + 1000 ) <NEWLINE> for i in range ( length ) : <NEWLINE> <INDENT> count [ num_list [ i ] ] += 1 <NEWLINE> dict [ num_list [ i ] ] = count [ num_list [ i ] ] <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> <COMMENT> <NL> for k , v in dict . items ( ) : <NEWLINE> <INDENT> sum += k * v <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> count = 0 <NEWLINE> d = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if dict . get ( a ) != None : <NEWLINE> <INDENT> d = ( b - a ) * dict [ a ] <NEWLINE> <COMMENT> <NL> if dict . get ( b ) != None : <NEWLINE> <INDENT> count = dict [ b ] <NEWLINE> dict [ b ] = dict [ a ] + dict [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict [ b ] = dict [ a ] <NEWLINE> <DEDENT> dict [ a ] = 0 <NEWLINE> sum += d <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> d = 0 <NEWLINE> print ( sum ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import namedtuple <NEWLINE> <NL> Task = namedtuple ( <STRING> , <STRING> ) <NEWLINE> <NL> class Queue : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . _l = [ None for _ in range ( self . n + 1 ) ] <NEWLINE> self . _head = 0 <NEWLINE> self . _tail = 0 <NEWLINE> <NL> <DEDENT> def enqueue ( self , x ) : <NEWLINE> <INDENT> self . _l [ self . _tail ] = x <NEWLINE> self . _tail += 1 <NEWLINE> if self . _tail > self . n : <NEWLINE> <INDENT> self . _tail -= self . n <NEWLINE> <NL> <DEDENT> <DEDENT> def dequeue ( self ) : <NEWLINE> <INDENT> if self . isEmpty ( ) : <NEWLINE> <INDENT> raise IndexError ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e = self . _l [ self . _head ] <NEWLINE> self . _l [ self . _head ] = None <NEWLINE> self . _head += 1 <NEWLINE> if self . _head > self . n : <NEWLINE> <INDENT> self . _head -= self . n <NEWLINE> <DEDENT> return e <NEWLINE> <NL> <DEDENT> <DEDENT> def isEmpty ( self ) : <NEWLINE> <INDENT> return self . _head == self . _tail <NEWLINE> <NL> <DEDENT> def isFull ( self ) : <NEWLINE> <INDENT> return self . _tail == self . n <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> queue = Queue ( n + 1 ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> name , time = input ( ) . split ( ) <NEWLINE> time = int ( time ) <NEWLINE> queue . enqueue ( Task ( name = name , time = time ) ) <NEWLINE> <NL> <DEDENT> now = 0 <NEWLINE> while not queue . isEmpty ( ) : <NEWLINE> <INDENT> task = queue . dequeue ( ) <NEWLINE> t = task . time <NEWLINE> if t <= q : <NEWLINE> <INDENT> now += t <NEWLINE> print ( task . name , now ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now += q <NEWLINE> queue . enqueue ( Task ( task . name , t - q ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> inf = 10 ** 7 <NEWLINE> dp = [ inf ] * 100005 <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - j ] + abs ( h [ i - j ] - h [ i ] ) for j in range ( 1 , min ( k , i ) + 1 ) ) <NEWLINE> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> mlt = 1 <NEWLINE> for x in l : <NEWLINE> <INDENT> mlt *= x <NEWLINE> if mlt > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( mlt ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 0 <NEWLINE> t = 1 <NEWLINE> d = 0 <NEWLINE> hoge_list = [ ] <NEWLINE> hoge_set = set ( ) <NEWLINE> while a < k : <NEWLINE> <INDENT> hoge_list . append ( t ) <NEWLINE> hoge_set . add ( t ) <NEWLINE> t = a_list [ t - 1 ] <NEWLINE> a += 1 <NEWLINE> if t in hoge_set : <NEWLINE> <INDENT> b = hoge_list . index ( t ) <NEWLINE> d += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if d == 0 : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e = ( k - b ) % ( a - b ) <NEWLINE> print ( hoge_list [ b + e ] ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> z = 998244353 <NEWLINE> if n <= k + 1 : <NEWLINE> <INDENT> a = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = a * m % z <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = [ ] <NEWLINE> b = [ ] <NEWLINE> d = [ 1 , 1 ] <NEWLINE> e = [ 1 , 1 ] <NEWLINE> f = [ 0 , 1 ] <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> d . append ( d [ - 1 ] * i % z ) <NEWLINE> f . append ( ( - f [ z % i ] * ( z // i ) ) % z ) <NEWLINE> e . append ( e [ - 1 ] * f [ - 1 ] % z ) <NEWLINE> <DEDENT> for i in range ( k + 1 ) : <NEWLINE> <INDENT> b . append ( d [ n - 1 ] * e [ i ] * e [ n - i - 1 ] % z ) <NEWLINE> <DEDENT> x = 0 <NEWLINE> g = [ 1 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> g . append ( g [ i ] * ( m - 1 ) % z ) <NEWLINE> <DEDENT> for i in range ( k + 1 ) : <NEWLINE> <INDENT> a . append ( b [ i ] * m * g [ n - i - 1 ] % z ) <NEWLINE> <DEDENT> for i in range ( k + 1 ) : <NEWLINE> <INDENT> x = ( x + a [ i ] ) % z <NEWLINE> <DEDENT> print ( x ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n != 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> smaller = 0 <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> if x - i in p : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> smaller = x - i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> bigger = 2 * x <NEWLINE> for j in range ( x ) : <NEWLINE> <INDENT> if x + j in p : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bigger = x + j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = smaller if x - smaller <= bigger - x else bigger <NEWLINE> <COMMENT> <NL> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> s = S ( ) <NEWLINE> ans = 0 <NEWLINE> w_cnt = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += i - w_cnt <COMMENT> <NEWLINE> w_cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> m = abs ( x ) // d <NEWLINE> if m >= k : <NEWLINE> <INDENT> print ( abs ( x ) - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= m <NEWLINE> if x >= 0 : <NEWLINE> <INDENT> x -= m * d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x += m * d <NEWLINE> <NL> <DEDENT> if x >= 0 : <NEWLINE> <INDENT> x -= d <NEWLINE> if x <= 0 : <NEWLINE> <INDENT> if ( k - 1 ) % 2 == 1 : <NEWLINE> <INDENT> x += d <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> x += d <NEWLINE> if x >= 0 : <NEWLINE> <INDENT> if ( k - 1 ) % 2 == 1 : <NEWLINE> <INDENT> x -= d <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( abs ( x ) ) <NEWLINE> <DEDENT>
from heapq import heappush , heappop <NEWLINE> <NL> s , r = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( s ) ] <NEWLINE> for _ in range ( r ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> edges [ u ] . append ( ( v , w ) ) <NEWLINE> edges [ v ] . append ( ( u , w ) ) <NEWLINE> <NL> <DEDENT> a , b , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> <NL> <NL> def dijkstra ( start ) : <NEWLINE> <INDENT> INF = 10 ** 20 <NEWLINE> dist = [ INF ] * s <NEWLINE> dist [ start ] = 0 <NEWLINE> parents = [ [ ] for _ in range ( s ) ] <NEWLINE> que = [ ] <NEWLINE> heappush ( que , ( 0 , start ) ) <NEWLINE> while que : <NEWLINE> <INDENT> score , node = heappop ( que ) <NEWLINE> for to , w in edges [ node ] : <NEWLINE> <INDENT> if dist [ to ] > score + w : <NEWLINE> <INDENT> dist [ to ] = score + w <NEWLINE> parents [ to ] = { node } <NEWLINE> heappush ( que , ( score + w , to ) ) <NEWLINE> <DEDENT> elif dist [ to ] == score + w : <NEWLINE> <INDENT> parents [ to ] . add ( node ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dist , parents <NEWLINE> <NL> <NL> <DEDENT> def on_shortest_path ( c , d , mem ) : <NEWLINE> <INDENT> if c == d : return True <NEWLINE> if d in mem : return False <NEWLINE> mem . add ( d ) <NEWLINE> if dist_from_a [ c ] >= dist_from_a [ d ] : return False <NEWLINE> for parent in parents [ d ] : <NEWLINE> <INDENT> if on_shortest_path ( c , parent , mem ) : return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> dist_from_a , parents = dijkstra ( a ) <NEWLINE> dist_from_b , _ = dijkstra ( b ) <NEWLINE> shortest = dist_from_a [ b ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> c -= 1 <NEWLINE> d -= 1 <NEWLINE> if dist_from_a [ c ] + dist_from_b [ c ] == shortest and dist_from_a [ d ] + dist_from_b [ d ] == shortest and on_shortest_path ( c , d , set ( ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
count = 0 <NEWLINE> <NL> def marge ( A , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> for i in range ( left , n1 + left ) : <NEWLINE> <INDENT> L . append ( A [ i ] ) <NEWLINE> <DEDENT> for i in range ( mid , n2 + mid ) : <NEWLINE> <INDENT> R . append ( A [ i ] ) <NEWLINE> <NL> <DEDENT> L . append ( float ( <STRING> ) ) <NEWLINE> R . append ( float ( <STRING> ) ) <NEWLINE> <NL> r_id , l_id = 0 , 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if ( L [ l_id ] <= R [ r_id ] ) : <NEWLINE> <INDENT> A [ k ] = L [ l_id ] <NEWLINE> l_id += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ r_id ] <NEWLINE> r_id += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def margeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> margeSort ( A , left , mid ) <NEWLINE> margeSort ( A , mid , right ) <NEWLINE> marge ( A , left , mid , right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> s = raw_input ( ) <NEWLINE> A = [ ] <NEWLINE> A = map ( int , s . split ( ) ) <NEWLINE> <NL> margeSort ( A , 0 , n ) <NEWLINE> <NL> A_str = map ( str , A ) <NEWLINE> print ( <STRING> . join ( list ( A_str ) ) ) <NEWLINE> print count <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> u = v [ 0 ] - 1 <NEWLINE> for j in v [ 2 : ] : <NEWLINE> <INDENT> a [ u ] . append ( j - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> d = [ - 1 ] * n <NEWLINE> isDiscovered = [ False ] * n <NEWLINE> <NL> def bfs ( x ) : <NEWLINE> <INDENT> for i in a [ x ] : <NEWLINE> <INDENT> if not isDiscovered [ i ] : <NEWLINE> <INDENT> isDiscovered [ i ] = True <NEWLINE> d [ i ] = d [ x ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> d_ = 0 <NEWLINE> isDiscovered [ 0 ] = True <NEWLINE> d [ 0 ] = 0 <NEWLINE> bfs ( 0 ) <NEWLINE> <NL> flag = True <NEWLINE> while flag : <NEWLINE> <INDENT> flag = False <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if d [ i ] is d_ : <NEWLINE> <INDENT> flag = True <NEWLINE> bfs ( i ) <NEWLINE> <DEDENT> <DEDENT> d_ += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( i + 1 , d [ i ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> A . sort ( ) <NEWLINE> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <DEDENT> N = 10 ** 5 <NEWLINE> g1 = [ 1 , 1 ] <COMMENT> <NEWLINE> g2 = [ 1 , 1 ] <COMMENT> <NEWLINE> inverse = [ 0 , 1 ] <COMMENT> <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <DEDENT> ans , bns = 0 , 0 <NEWLINE> for j in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = ( ans + ( A [ n - j - 1 ] - A [ j ] ) * cmb ( n - j - 1 , k - 1 , mod ) ) % mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = sum ( a ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> t -= a [ i ] <NEWLINE> ans = ( ans + ( a [ i ] * t % MOD ) ) % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import random <NEWLINE> <NL> name = input ( ) <NEWLINE> start = random . randint ( 0 , len ( name ) - 3 ) <NEWLINE> nickname = name [ start : start + 3 ] <NEWLINE> print ( nickname ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> rsl = np . zeros ( n ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> rsl [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( int ( rsl [ i ] ) ) <NEWLINE> <DEDENT>
def hoge ( S ) : <NEWLINE> <INDENT> cum = 0 <NEWLINE> mi = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> cum += 1 if s == <STRING> else - 1 <NEWLINE> mi = min ( mi , cum ) <NEWLINE> <DEDENT> return ( - mi , cum - mi ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> S = [ hoge ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> plus = [ ] <NEWLINE> minus = [ ] <NEWLINE> <NL> for l , r in S : <NEWLINE> <INDENT> if l <= r : <NEWLINE> <INDENT> plus . append ( ( l , r ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus . append ( ( l , r ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> plus . sort ( key = lambda a : a [ 0 ] ) <NEWLINE> minus . sort ( key = lambda a : a [ 1 ] , reverse = True ) <NEWLINE> M = 0 <NEWLINE> for l , r in ( plus + minus ) : <NEWLINE> <INDENT> M -= l <NEWLINE> if M < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> M += r <NEWLINE> <NL> <DEDENT> print ( <STRING> if M == 0 else <STRING> ) <NEWLINE>
<COMMENT> <NL> import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_amount = dict ( collections . Counter ( A ) ) <NEWLINE> <NL> result = sum ( A ) <NEWLINE> <NL> Q = int ( input ( ) ) <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> B_elem = A_amount . get ( B , None ) <NEWLINE> if B_elem is not None : <NEWLINE> <INDENT> C_elem = A_amount . get ( C , None ) <NEWLINE> if C_elem is not None : <NEWLINE> <INDENT> A_amount . pop ( B ) <NEWLINE> A_amount [ C ] = B_elem + C_elem <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A_amount . pop ( B ) <NEWLINE> A_amount [ C ] = B_elem <NEWLINE> <NL> <DEDENT> result += ( C - B ) * B_elem <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> <NL> <NL> def generate_adj_table ( _edges ) : <NEWLINE> <INDENT> for edge in _edges : <NEWLINE> <INDENT> vx , vy = map ( int , edge ) <NEWLINE> init_adj_table [ vx ] . append ( vy ) <NEWLINE> <NL> <DEDENT> return init_adj_table <NEWLINE> <NL> <NL> <DEDENT> def graph_dfs ( current , matching , visited ) : <NEWLINE> <INDENT> for adj in range ( y_num ) : <NEWLINE> <INDENT> if adj in adj_table [ current ] and not visited [ adj ] : <NEWLINE> <INDENT> visited [ adj ] = True <NEWLINE> if matching [ adj ] == - 1 or graph_dfs ( matching [ adj ] , matching , visited ) : <NEWLINE> <INDENT> matching [ adj ] = current <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> def mbm ( ) : <NEWLINE> <INDENT> matching = [ - 1 ] * y_num <NEWLINE> res = 0 <NEWLINE> for v in range ( x_num ) : <NEWLINE> <INDENT> visited = [ False ] * y_num <NEWLINE> if graph_dfs ( v , matching , visited ) : <NEWLINE> <INDENT> res += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> x_num , y_num , e_num = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> edges = map ( lambda x : x . split ( ) , _input [ 1 : ] ) <NEWLINE> <NL> <COMMENT> <NL> init_adj_table = [ [ ] for _ in range ( x_num ) ] <NEWLINE> adj_table = generate_adj_table ( edges ) <NEWLINE> print ( mbm ( ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> input = sys . stdin . readline <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> dp = np . zeros ( n , dtype = int ) <NEWLINE> <COMMENT> <NL> h = np . array ( h ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> start = max ( 0 , i - k ) <NEWLINE> <COMMENT> <NL> dp [ i ] = min ( dp [ start : i ] + np . abs ( h [ i ] - h [ start : i ] ) ) <NEWLINE> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : break <NEWLINE> for x in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
<NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mx = 0 <NEWLINE> <NL> nn = n // b <NEWLINE> <NL> mm = ( a * n ) // b - a * ( nn ) <NEWLINE> <NL> if nn > 0 : <NEWLINE> <INDENT> x = b * nn - 1 <NEWLINE> mx = ( a * x ) // b - a * ( nn - 1 ) <NEWLINE> mm = max ( mm , mx ) <NEWLINE> <NL> <DEDENT> print ( mm ) <NEWLINE>
<COMMENT> <NL> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> acum1 = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> acum1 . append ( acum1 [ - 1 ] + arr1 [ i ] ) <NEWLINE> <DEDENT> acum2 = [ 0 ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> acum2 . append ( acum2 [ - 1 ] + arr2 [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if acum1 [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while acum2 [ j ] > k - acum1 [ i ] and j > 0 : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
<NL> x = int ( input ( ) ) <NEWLINE> y = int ( pow ( x , 1 / 5 ) ) * 2 <NEWLINE> A = [ i ** 5 for i in range ( y + 1 ) ] <NEWLINE> B = [ i ** 5 for i in range ( y + 1 ) ] <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> for j in range ( len ( B ) ) : <NEWLINE> <INDENT> if ( A [ i ] + B [ j ] ) == x : <NEWLINE> <INDENT> if A [ i ] > B [ j ] : <NEWLINE> <INDENT> exit ( print ( i , - j ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> exit ( print ( j , - i ) ) <NEWLINE> <DEDENT> <DEDENT> elif ( A [ i ] - B [ j ] ) == x : <NEWLINE> <INDENT> exit ( print ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> from collections import defaultdict <NEWLINE> <NL> mxn = 10 ** 6 + 1 <NEWLINE> spf = [ i for i in range ( mxn ) ] <NEWLINE> <NL> for i in range ( 4 , mxn , 2 ) : <NEWLINE> <INDENT> spf [ i ] = 2 <NEWLINE> <DEDENT> i = 3 <NEWLINE> while i * i <= mxn : <NEWLINE> <INDENT> if spf [ i ] == i : <NEWLINE> <INDENT> for j in range ( i * i , mxn , i ) : <NEWLINE> <INDENT> if spf [ j ] == j : <NEWLINE> <INDENT> spf [ j ] = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> ph = defaultdict ( lambda : False ) <NEWLINE> pc = True <NEWLINE> def getFactors ( n ) : <NEWLINE> <INDENT> global pc <NEWLINE> while n != 1 : <NEWLINE> <INDENT> temp = spf [ n ] <NEWLINE> if ph [ temp ] == True : <NEWLINE> <INDENT> pc = False <NEWLINE> break <NEWLINE> <DEDENT> ph [ temp ] = True <NEWLINE> while n % temp == 0 : <NEWLINE> <INDENT> n //= temp <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i , g = n - 2 , a [ n - 1 ] <NEWLINE> while i >= 0 : <NEWLINE> <INDENT> g = gcd ( g , a [ i ] ) <NEWLINE> i -= 1 <NEWLINE> <DEDENT> if g != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> if not pc : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> getFactors ( i ) <NEWLINE> <DEDENT> if not pc : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def solve ( N , P ) : <NEWLINE> <INDENT> prime_list = [ ] <NEWLINE> for i in range ( 2 , int ( P ** ( 1 / 2 ) ) + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while P % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> P //= i <NEWLINE> <DEDENT> if cnt : <NEWLINE> <INDENT> prime_list . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if P != 1 : <NEWLINE> <INDENT> prime_list . append ( [ P , 1 ] ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for prime , cnt in prime_list : <NEWLINE> <INDENT> if cnt >= N : <NEWLINE> <INDENT> ans *= prime ** ( cnt // N ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( solve ( n , p ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> <NL> visited = [ False for _ in range ( N ) ] <NEWLINE> <NL> A = list ( map ( lambda n : int ( n ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> tmp = 0 <COMMENT> <NEWLINE> visited [ 0 ] = True <NEWLINE> <COMMENT> <NL> log = [ 0 ] <COMMENT> <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = A [ tmp ] <NEWLINE> if visited [ tmp ] : <NEWLINE> <INDENT> start = log . index ( tmp ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> visited [ tmp ] = True <NEWLINE> log . append ( tmp ) <NEWLINE> <NL> <DEDENT> if i == K : <NEWLINE> <INDENT> print ( tmp + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop = log [ start : i + 1 ] <NEWLINE> period = len ( loop ) <NEWLINE> remain = K - i <NEWLINE> print ( loop [ remain % period ] + 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> from numba . types import i8 <NEWLINE> ni8 = np . int64 <NEWLINE> MOD = 998244353 <NEWLINE> <NL> <NL> @ njit ( ( i8 [ : , : : - 1 ] , i8 [ : ] , i8 , i8 ) , cache = True ) <NEWLINE> def solve ( lr , dp , n , k ) : <NEWLINE> <INDENT> acc_dp = np . ones_like ( dp ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> val = 0 <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> a = i - lr [ j , 0 ] <NEWLINE> if a < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> b = i - lr [ j , 1 ] - 1 <NEWLINE> val += acc_dp [ a ] - ( acc_dp [ b ] if b >= 0 else 0 ) <NEWLINE> <DEDENT> dp [ i ] = val % MOD <NEWLINE> acc_dp [ i ] = ( acc_dp [ i - 1 ] + dp [ i ] ) % MOD <NEWLINE> <DEDENT> return dp [ n - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> f = open ( 0 ) <NEWLINE> n , k = [ int ( x ) for x in f . readline ( ) . split ( ) ] <NEWLINE> lr = np . fromstring ( f . read ( ) , ni8 , sep = <STRING> ) . reshape ( ( - 1 , 2 ) ) <NEWLINE> dp = np . zeros ( n , ni8 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> ans = solve ( lr , dp , n , k ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import math as m <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> prev = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> prev += m . log ( a [ i ] ) <NEWLINE> <DEDENT> for i in range ( k , n ) : <NEWLINE> <INDENT> cur = prev + m . log ( a [ i ] ) <NEWLINE> cur -= m . log ( a [ i - k ] ) <NEWLINE> print ( <STRING> if cur > prev else <STRING> ) <NEWLINE> prev = cur <NEWLINE> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - x - y <= K : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> l = [ str ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> print ( len ( set ( l ) ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> edge = [ [ ] for _ in range ( n ) ] <NEWLINE> dist = [ - 1 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ x - 1 ] . append ( [ y - 1 , z ] ) <NEWLINE> edge [ y - 1 ] . append ( [ x - 1 , z ] ) <NEWLINE> <DEDENT> def dfs ( node , d ) : <NEWLINE> <INDENT> dist [ node ] = d <NEWLINE> for i in edge [ node ] : <NEWLINE> <INDENT> if dist [ i [ 0 ] ] == - 1 : <NEWLINE> <INDENT> dfs ( i [ 0 ] , d + i [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , 0 ) <NEWLINE> print ( * [ i % 2 for i in dist ] , sep = <STRING> ) <NEWLINE>
x , y , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( reverse = True ) <NEWLINE> q . sort ( reverse = True ) <NEWLINE> r . sort ( reverse = True ) <NEWLINE> <NL> ans = p [ : x ] + q [ : y ] + r <NEWLINE> ans . sort ( reverse = True ) <NEWLINE> <NL> print ( sum ( ans [ : x + y ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = input ( ) <NEWLINE> S . append ( A ) <NEWLINE> <DEDENT> print ( len ( set ( S ) ) ) <NEWLINE>
import random <NEWLINE> <NL> <NL> class Dice ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . t = 1 <NEWLINE> self . s = 2 <NEWLINE> self . e = 3 <NEWLINE> self . w = 4 <NEWLINE> self . n = 5 <NEWLINE> self . b = 6 <NEWLINE> <NL> <DEDENT> def __init__ ( self , faces ) : <NEWLINE> <INDENT> self . t = faces [ 0 ] <NEWLINE> self . s = faces [ 1 ] <NEWLINE> self . e = faces [ 2 ] <NEWLINE> self . w = faces [ 3 ] <NEWLINE> self . n = faces [ 4 ] <NEWLINE> self . b = faces [ 5 ] <NEWLINE> <NL> <DEDENT> def roll ( self , direct ) : <NEWLINE> <INDENT> if direct == 0 : <NEWLINE> <INDENT> self . t , self . s , self . b , self . n = self . n , self . t , self . s , self . b <NEWLINE> <DEDENT> elif direct == 1 : <NEWLINE> <INDENT> self . t , self . w , self . b , self . e = self . e , self . t , self . w , self . b <NEWLINE> <DEDENT> elif direct == 2 : <NEWLINE> <INDENT> self . n , self . w , self . s , self . e = self . w , self . s , self . e , self . n <NEWLINE> <NL> <DEDENT> <DEDENT> def is_equal ( self , dice ) : <NEWLINE> <INDENT> if self . t == dice . t and self . s == dice . s and self . e == dice . e and self . w == dice . w and self . n == dice . n and self . b == dice . b : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def get_nums ( self ) : <NEWLINE> <INDENT> return { self . t , self . s , self . e , self . w , self . n , self . b } <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> dice_list = [ ] <NEWLINE> flag_list = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> flag = False <NEWLINE> faces = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dice_list . append ( Dice ( faces ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> dice_a = dice_list [ - 1 ] <NEWLINE> for i in range ( len ( dice_list ) - 1 ) : <NEWLINE> <INDENT> dice_b = dice_list [ i ] <NEWLINE> <NL> if ( dice_a . get_nums ( ) == dice_b . get_nums ( ) ) : <NEWLINE> <INDENT> for i in range ( 1000 ) : <NEWLINE> <INDENT> dice_b . roll ( random . randint ( 0 , 3 ) ) <NEWLINE> if dice_a . is_equal ( dice_b ) : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> flag_list . append ( flag ) <NEWLINE> <NL> <DEDENT> <DEDENT> if any ( flag_list ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
from collections import Counter <NEWLINE> <NL> n , k , l = map ( int , input ( ) . split ( ) ) <NEWLINE> city1 = [ i for i in range ( n ) ] <NEWLINE> city2 = [ i for i in range ( n ) ] <NEWLINE> <NL> def root ( c , x ) : <NEWLINE> <INDENT> if x == c [ x ] : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ x ] = root ( c , c [ x ] ) <NEWLINE> return c [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( c , x , y ) : <NEWLINE> <INDENT> rx = root ( c , x ) <NEWLINE> ry = root ( c , y ) <NEWLINE> if rx > ry : <NEWLINE> <INDENT> c [ rx ] = ry <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ ry ] = rx <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> union ( city1 , a - 1 , b - 1 ) <NEWLINE> <DEDENT> for i in range ( l ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> union ( city2 , a - 1 , b - 1 ) <NEWLINE> <DEDENT> r = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> r . append ( ( root ( city1 , i ) , root ( city2 , i ) ) ) <NEWLINE> <DEDENT> c = Counter ( r ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = c [ r [ i ] ] <NEWLINE> if i == n - 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> counter = Counter ( a ) <NEWLINE> sum_res = sum ( a ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> sum_res += ( c - b ) * counter [ b ] <NEWLINE> <NL> counter [ c ] += counter [ b ] <NEWLINE> counter [ b ] = 0 <NEWLINE> <NL> print ( sum_res ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> S = len ( s ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> tmp_ans = pow ( 26 , n , mod ) <NEWLINE> div = pow ( 26 , - 1 , mod ) <NEWLINE> <NL> ans = tmp_ans <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> tmp_ans = ( tmp_ans * 25 * div ) % mod <NEWLINE> tmp_ans = ( ( tmp_ans * ( S - 1 + i ) ) * pow ( i , - 1 , mod ) ) % mod <NEWLINE> ans = ( ans + tmp_ans ) % mod <NEWLINE> <NL> <DEDENT> ans %= mod <NEWLINE> <NL> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> a , b , n = list ( map ( lambda x : int ( x ) , sys . stdin . readline ( ) . split ( <STRING> ) ) ) <NEWLINE> old = 0 <NEWLINE> if 0 <= b - 1 and b - 1 <= n : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> print ( math . floor ( a * x / b ) - a * math . floor ( x / b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = n <NEWLINE> print ( math . floor ( a * x / b ) - a * math . floor ( x / b ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sorted ( A ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> <NL> for j in range ( N - 1 ) : <NEWLINE> <INDENT> i = A [ j ] - 1 <NEWLINE> ans [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lst_a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> lst_b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> j = 0 <NEWLINE> flag = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> if lst_a [ i ] != lst_a [ i - 1 ] : <NEWLINE> <INDENT> j = 0 <NEWLINE> <DEDENT> <DEDENT> if lst_a [ i ] != lst_b [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> while j != n : <NEWLINE> <INDENT> if lst_a [ i ] != lst_b [ j ] and lst_a [ j ] != lst_b [ i ] : <NEWLINE> <INDENT> lst_b [ i ] , lst_b [ j ] = lst_b [ j ] , lst_b [ i ] <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> if not flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if not flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> lst_b = [ str ( i ) for i in lst_b ] <NEWLINE> print ( <STRING> . join ( lst_b ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = 1 <NEWLINE> b = m - 1 <NEWLINE> c = m <NEWLINE> d = [ i for i in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> if m % 2 == 0 and i < m / 2 : <NEWLINE> <INDENT> print ( d [ a ] , d [ a + b ] ) <NEWLINE> print ( d [ - a - c ] , d [ - a ] ) <NEWLINE> a = a + 1 <NEWLINE> b = b - 2 <NEWLINE> c = c - 2 <NEWLINE> <NL> <DEDENT> elif m % 2 != 0 and i < m / 2 : <NEWLINE> <INDENT> print ( d [ - a - c ] , d [ - a ] ) <NEWLINE> if i == ( m + 1 ) / 2 - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( d [ a ] , d [ a + b ] ) <NEWLINE> a = a + 1 <NEWLINE> b = b - 2 <NEWLINE> c = c - 2 <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> from collections import Counter <NEWLINE> <NL> c = Counter ( a ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n , 0 , - 1 ) : <NEWLINE> <INDENT> j = int ( i ** 0.5 ) <NEWLINE> if int ( j ) ** 2 == i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
import fileinput <NEWLINE> <NL> ps = set ( ) <NEWLINE> for i in range ( 3 , 10001 , 2 ) : <NEWLINE> <INDENT> for p in ps : <NEWLINE> <INDENT> if p > 100 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i % p == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ps . add ( i ) <NEWLINE> <DEDENT> i += 2 <NEWLINE> <DEDENT> ps . add ( 2 ) <NEWLINE> <NL> for line in fileinput . input ( ) : <NEWLINE> <INDENT> n = int ( line ) <NEWLINE> print ( sum ( i in ps and ( n + 1 - i ) in ps for i in range ( 2 , n + 1 ) ) ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> c = Counter ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> li = [ 0 ] <NEWLINE> li . extend ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> tuita = [ 0 ] * ( n + 1 ) <NEWLINE> cnt = 0 <NEWLINE> town = 1 <NEWLINE> <NL> lastTown = 1 <NEWLINE> while True : <NEWLINE> <INDENT> town = li [ town ] <NEWLINE> cnt += 1 <NEWLINE> if tuita [ town ] == 0 : <NEWLINE> <INDENT> tuita [ town ] = cnt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k < tuita [ town ] : <NEWLINE> <INDENT> lastTown = 1 <NEWLINE> times = k <NEWLINE> <DEDENT> elif k == tuita [ town ] : <NEWLINE> <INDENT> lastTown = town <NEWLINE> times = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lastTown = town <NEWLINE> times = ( k - tuita [ town ] ) % ( cnt - tuita [ town ] ) <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> town = lastTown <NEWLINE> while times > 0 : <NEWLINE> <INDENT> if times <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> times -= 1 <NEWLINE> town = li [ town ] <NEWLINE> <DEDENT> print ( town ) <NEWLINE>
n , t = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b <= t : <NEWLINE> <INDENT> ans . append ( a ) <NEWLINE> <DEDENT> <DEDENT> if len ( ans ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> <NL> cnt = [ 0 ] * 100005 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> cnt [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> tot = 0 <NEWLINE> for j in range ( len ( cnt ) ) : <NEWLINE> <INDENT> tot += j * cnt [ j ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for k in range ( q ) : <NEWLINE> <INDENT> b = bc [ k ] [ 0 ] <NEWLINE> c = bc [ k ] [ 1 ] <NEWLINE> tot -= b * cnt [ b ] <NEWLINE> tot -= c * cnt [ c ] <NEWLINE> cnt [ c ] += cnt [ b ] <NEWLINE> cnt [ b ] = 0 <NEWLINE> tot += b * cnt [ b ] <NEWLINE> tot += c * cnt [ c ] <NEWLINE> print ( tot ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = set ( input ( ) for i in range ( n ) ) <NEWLINE> print ( len ( s ) ) <NEWLINE>
MOD = 1000000007 <NEWLINE> def maxProductSubarrayOfSizeK ( A , n , k ) : <NEWLINE> <NL> <INDENT> A . sort ( ) <NEWLINE> <NL> product = 1 <NEWLINE> <NL> if ( A [ n - 1 ] == 0 and ( k & 1 ) ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> if ( A [ n - 1 ] < 0 and ( k & 1 ) ) : <NEWLINE> <INDENT> A . reverse ( ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> product *= A [ i ] <NEWLINE> if abs ( product ) >= MOD : <NEWLINE> <INDENT> product = product % MOD <NEWLINE> <DEDENT> <DEDENT> return product <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> <NL> j = n - 1 <NEWLINE> <NL> if ( k & 1 ) : <NEWLINE> <INDENT> product *= A [ j ] <NEWLINE> product %= MOD <NEWLINE> j -= 1 <NEWLINE> k -= 1 <NEWLINE> <NL> <DEDENT> k >>= 1 <NEWLINE> <NL> for itr in range ( k ) : <NEWLINE> <NL> <INDENT> left_product = A [ i ] * A [ i + 1 ] <NEWLINE> <NL> right_product = A [ j ] * A [ j - 1 ] <NEWLINE> <NL> if ( left_product > right_product ) : <NEWLINE> <INDENT> product *= left_product <NEWLINE> product %= MOD <NEWLINE> i += 2 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> product *= right_product <NEWLINE> product %= MOD <NEWLINE> j -= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> return product <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> numbers = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> ans = maxProductSubarrayOfSizeK ( numbers , n , k ) <NEWLINE> <COMMENT> <NL> print ( ( ans + MOD ) % MOD ) <NEWLINE>
from numba import jit <NEWLINE> @ jit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = - 10 ** 18 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> start , count = i , 1 <NEWLINE> val = c [ start ] <NEWLINE> while p [ start ] - 1 != i : <NEWLINE> <INDENT> start = p [ start ] - 1 <NEWLINE> count += 1 <NEWLINE> val += c [ start ] <NEWLINE> <DEDENT> start = i <NEWLINE> if val > 0 : <NEWLINE> <INDENT> a = ( k // count - 1 ) * val <NEWLINE> ans = max ( a , ans ) <NEWLINE> num = count + k % count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> num = min ( k , count ) <NEWLINE> <DEDENT> for _ in range ( num ) : <NEWLINE> <INDENT> a += c [ start ] <NEWLINE> start = p [ start ] - 1 <NEWLINE> ans = max ( a , ans ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> mod = 998244353 <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( k ) ] <NEWLINE> <NL> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> dp [ i + 1 ] += dp [ i ] <NEWLINE> for l , r in lr : <NEWLINE> <INDENT> dp [ i + 1 ] += dp [ max ( i - l + 1 , 0 ) ] - dp [ max ( i - r , 0 ) ] <NEWLINE> dp [ i + 1 ] %= mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ( dp [ n ] - dp [ n - 1 ] ) % mod ) <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> from io import BytesIO , IOBase <NEWLINE> from collections import deque as dq <NEWLINE> <NL> BUFSIZE = 8192 <NEWLINE> <NL> <NL> class FastIO ( IOBase ) : <NEWLINE> <INDENT> newlines = 0 <NEWLINE> <NL> def __init__ ( self , file ) : <NEWLINE> <INDENT> self . _fd = file . fileno ( ) <NEWLINE> self . buffer = BytesIO ( ) <NEWLINE> self . writable = <STRING> in file . mode or <STRING> not in file . mode <NEWLINE> self . write = self . buffer . write if self . writable else None <NEWLINE> <NL> <DEDENT> def read ( self ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) <NEWLINE> if not b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ptr = self . buffer . tell ( ) <NEWLINE> self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) <NEWLINE> <DEDENT> self . newlines = 0 <NEWLINE> return self . buffer . read ( ) <NEWLINE> <NL> <DEDENT> def readline ( self ) : <NEWLINE> <INDENT> while self . newlines == 0 : <NEWLINE> <INDENT> b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) <NEWLINE> self . newlines = b . count ( <STRING> ) + ( not b ) <NEWLINE> ptr = self . buffer . tell ( ) <NEWLINE> self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) <NEWLINE> <DEDENT> self . newlines -= 1 <NEWLINE> return self . buffer . readline ( ) <NEWLINE> <NL> <DEDENT> def flush ( self ) : <NEWLINE> <INDENT> if self . writable : <NEWLINE> <INDENT> os . write ( self . _fd , self . buffer . getvalue ( ) ) <NEWLINE> self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class IOWrapper ( IOBase ) : <NEWLINE> <INDENT> def __init__ ( self , file ) : <NEWLINE> <INDENT> self . buffer = FastIO ( file ) <NEWLINE> self . flush = self . buffer . flush <NEWLINE> self . writable = self . buffer . writable <NEWLINE> self . write = lambda s : self . buffer . write ( s . encode ( <STRING> ) ) <NEWLINE> self . read = lambda : self . buffer . read ( ) . decode ( <STRING> ) <NEWLINE> self . readline = lambda : self . buffer . readline ( ) . decode ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( <STRING> ) <NEWLINE> <COMMENT> <NL> from collections import deque as dq <NEWLINE> L = dq ( list ( input ( ) ) ) <NEWLINE> C = 0 <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> S = input ( ) . split ( ) <NEWLINE> if S == [ <STRING> ] : <NEWLINE> <INDENT> C += 1 <NEWLINE> <DEDENT> elif C % 2 == 0 : <NEWLINE> <INDENT> if S [ 1 ] == <STRING> : <NEWLINE> <INDENT> L . appendleft ( S [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L . append ( S [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> elif C % 2 != 0 : <NEWLINE> <INDENT> if S [ 1 ] == <STRING> : <NEWLINE> <INDENT> L . append ( S [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L . appendleft ( S [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if C % 2 != 0 : <NEWLINE> <INDENT> L . reverse ( ) <NEWLINE> <DEDENT> print ( <STRING> . join ( L ) ) <NEWLINE> <NL>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> s = input ( ) <NEWLINE> k = INT ( ) <NEWLINE> a = set ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> t = s [ i ] <NEWLINE> a . add ( t ) <NEWLINE> if i < len ( s ) - 1 : <NEWLINE> <INDENT> for j in range ( i + 1 , min ( i + k + 1 , len ( s ) ) ) : <NEWLINE> <INDENT> t += s [ j ] <NEWLINE> a . add ( t ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> b = sorted ( list ( a ) ) <NEWLINE> print ( b [ k - 1 ] ) <NEWLINE>
def calc ( n , x ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 2 , i ) : <NEWLINE> <INDENT> if i + j < x < i + 2 * j : <NEWLINE> <INDENT> result += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return str ( result ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans . append ( calc ( n , x ) ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> mn = P [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if mn >= P [ i ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> mn = P [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> total = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a . append ( sum ( a ) ) <NEWLINE> for j in range ( n + 1 ) : <NEWLINE> <INDENT> print ( <STRING> % ( a [ j ] ) , end = <STRING> ) <NEWLINE> total [ j ] += a [ j ] <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> print ( <STRING> % ( total [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> A = list ( map ( lambda x : int ( x ) % MOD , input ( ) . split ( ) ) ) <NEWLINE> S = [ ] <NEWLINE> <NL> tmp_s = 0 <NEWLINE> for A_i in A [ : : - 1 ] : <NEWLINE> <INDENT> tmp_s += A_i <NEWLINE> S . append ( tmp_s % MOD ) <NEWLINE> <DEDENT> S . pop ( - 1 ) <NEWLINE> S = S [ : : - 1 ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += ( A [ i ] * S [ i ] ) % MOD <NEWLINE> ans = ans % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def fun ( d ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in d : <NEWLINE> <INDENT> cnt += i * d [ i ] <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> from collections import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d [ A [ i ] ] += 1 <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> cnt = sum ( A ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b in d : <NEWLINE> <INDENT> cnt += ( - b * d [ b ] + c * d [ b ] ) <NEWLINE> d [ c ] += d [ b ] <NEWLINE> d [ b ] = 0 <NEWLINE> <COMMENT> <NL> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> x = dict ( collections . Counter ( A ) ) <NEWLINE> ans = sum ( k * v for k , v in x . items ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> b = x . get ( B , 0 ) <NEWLINE> c = x . get ( C , 0 ) <NEWLINE> <NL> ans -= b * B <NEWLINE> ans += b * C <NEWLINE> <NL> x [ C ] = c + b <NEWLINE> x [ B ] = 0 <NEWLINE> <NL> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <COMMENT> <NEWLINE> <INDENT> k = n // i <NEWLINE> ans += i * ( k * ( k + 1 ) // 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<NL> import itertools <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> list1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> list2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum1 = set ( ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = list ( itertools . combinations ( list1 , i ) ) <NEWLINE> for j in x : <NEWLINE> <INDENT> sum1 . add ( sum ( j ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in list2 : <NEWLINE> <INDENT> if i in sum1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , m , x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> c = [ ] <NEWLINE> arr = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> c . append ( l [ 0 ] ) <NEWLINE> arr [ i ] = l [ 1 : ] <NEWLINE> <NL> <DEDENT> inf = 10 ** 18 <NEWLINE> ans = inf <NEWLINE> <NL> limit = 2 ** n <NEWLINE> for bit in range ( 1 , limit ) : <NEWLINE> <INDENT> sum = [ 0 for i in range ( m ) ] <NEWLINE> cost = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( 1 << i & bit ) : <NEWLINE> <INDENT> cost += c [ i ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> sum [ j ] += arr [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> flag = 1 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if sum [ i ] < x : <NEWLINE> <INDENT> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans = min ( ans , cost ) <NEWLINE> <DEDENT> if ans != inf : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
flg = False <NEWLINE> while True : <NEWLINE> <NL> <INDENT> H , W = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if H == 0 and W == 0 : break <NEWLINE> <NL> <NL> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x < 0 : <NEWLINE> <INDENT> if x + k * d < 0 : <NEWLINE> <INDENT> print ( - x - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = - x // d <NEWLINE> x += a * d <NEWLINE> if ( k - a ) % 2 == 0 : <NEWLINE> <INDENT> print ( - x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x + d ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if x - k * d > 0 : <NEWLINE> <INDENT> print ( x - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = x // d <NEWLINE> x -= a * d <NEWLINE> if ( k - a ) % 2 == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d - x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> n = float ( input ( ) ) <NEWLINE> <NL> L = 2 * math . pi * n <NEWLINE> S = n * n * math . pi <NEWLINE> <NL> print ( <STRING> % ( S ) , <STRING> % ( L ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> t = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> p = N // i <NEWLINE> t += i * p * ( 1 + p ) / 2 <NEWLINE> <NL> <NL> <DEDENT> print ( int ( t ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = Counter ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> temp , a = listed ( a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> for b , c in bc : <NEWLINE> <INDENT> t = a [ b ] <NEWLINE> if t == 0 : <NEWLINE> <INDENT> print ( temp ) <NEWLINE> continue <NEWLINE> <DEDENT> a [ b ] = 0 <NEWLINE> temp -= b * t <NEWLINE> a [ c ] += t <NEWLINE> temp += c * t <NEWLINE> print ( temp ) <NEWLINE> <NL> <DEDENT> <DEDENT> def listed ( a ) : <NEWLINE> <INDENT> x = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> kei = 0 <NEWLINE> for i , v in a . items ( ) : <NEWLINE> <INDENT> x [ i ] = v <NEWLINE> kei += i * v <NEWLINE> <DEDENT> return kei , x <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> d = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( d , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( key = int ) <NEWLINE> l = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> while l < len ( A ) and A [ l ] == i + 1 : <NEWLINE> <INDENT> l += 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> q = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> l = q . pop ( 0 ) <NEWLINE> if l % 10 != 0 : <NEWLINE> <INDENT> q . append ( 10 * l + l % 10 - 1 ) <NEWLINE> <DEDENT> q . append ( 10 * l + l % 10 ) <NEWLINE> if l % 10 != 9 : <NEWLINE> <INDENT> q . append ( 10 * l + l % 10 + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sysread = sys . stdin . readline <NEWLINE> def run ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> mods = [ [ ] for _ in range ( 2019 ) ] <NEWLINE> mods [ 0 ] . append ( 0 ) <NEWLINE> <NL> tmp = 0 <NEWLINE> tmp10 = 1 <NEWLINE> for i in range ( 1 , len ( S ) + 1 ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> tmp10 = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp10 = ( tmp10 * 10 ) % 2019 <NEWLINE> <DEDENT> tmp = ( tmp10 * int ( S [ - i ] ) + tmp ) % 2019 <NEWLINE> mods [ tmp ] . append ( i ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for ns in mods : <NEWLINE> <INDENT> l = len ( ns ) <NEWLINE> count += l * ( l - 1 ) // 2 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = [ 0 ] * n <NEWLINE> w = 0 <NEWLINE> c = 0 <NEWLINE> ac = set ( ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> p , s = map ( str , input ( ) . split ( ) ) <NEWLINE> p = int ( p ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> l [ p - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if p not in ac : <NEWLINE> <INDENT> c += 1 <NEWLINE> w += l [ p - 1 ] <NEWLINE> ac . add ( p ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( c , w ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> b = 0 <NEWLINE> <NL> for a in range ( 1 , n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> b = ( n - 1 ) // a <NEWLINE> ans += b <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> t = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> a += 7 * t <NEWLINE> a = a % K <NEWLINE> t = t * 10 <NEWLINE> t = t % K <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> visited = [ ] <NEWLINE> search = set ( ) <NEWLINE> now = 1 <COMMENT> <NEWLINE> next_town = A [ now - 1 ] <NEWLINE> count = 1 <NEWLINE> while ( count <= N ) : <NEWLINE> <INDENT> if next_town in search : <COMMENT> <NEWLINE> <INDENT> break <COMMENT> <NEWLINE> <DEDENT> visited . append ( now ) <COMMENT> <NEWLINE> search . add ( now ) <NEWLINE> next_town = A [ now - 1 ] <COMMENT> <NEWLINE> now = next_town <COMMENT> <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> first_roop_city = A [ visited [ - 1 ] - 1 ] <COMMENT> <NEWLINE> first_roop_city_index = visited . index ( first_roop_city ) <COMMENT> <NEWLINE> if K < len ( visited ) : <NEWLINE> <INDENT> print ( visited [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited = visited [ first_roop_city_index : ] <NEWLINE> L = len ( visited ) <NEWLINE> print ( visited [ ( K - first_roop_city_index ) % L ] ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x % y == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = collections . Counter ( A ) <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> print ( ans [ n + 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum1 = sum ( a ) <NEWLINE> sum2 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum2 += a [ i ] ** 2 <NEWLINE> <DEDENT> sum3 = ( sum1 * sum1 - sum2 ) // 2 <NEWLINE> print ( sum3 % ( 10 ** 9 + 7 ) ) <NEWLINE>
import time <NEWLINE> <NL> x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> b = int ( min ( x , y ) ) <NEWLINE> a = int ( max ( x , y ) ) <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if a % b != 0 : <NEWLINE> <INDENT> r = a % b <NEWLINE> return gcd ( b , r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <NL> <DEDENT> <DEDENT> gcd ( a , b ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> import math <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> if x == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif x == 2 : <NEWLINE> <INDENT> return 9 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = 0 <NEWLINE> for j in range ( 1 , x ) : <NEWLINE> <INDENT> m += math . gcd ( j , x ) * 6 <NEWLINE> <DEDENT> for i in range ( 1 , x - 1 ) : <NEWLINE> <INDENT> for k in range ( i + 1 , x ) : <NEWLINE> <INDENT> m += math . gcd ( x , math . gcd ( i , k ) ) * 6 <NEWLINE> <DEDENT> <DEDENT> return m + x + f ( x - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( f ( K ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d_tmp = sum ( p [ 0 : k ] ) <NEWLINE> d_max = sum ( p [ 0 : k ] ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> d_tmp = d_tmp + p [ k + i ] - p [ i ] <NEWLINE> d_max = max ( d_max , d_tmp ) <NEWLINE> <NL> <DEDENT> ans = ( d_max + k ) / 2 <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> amx = max ( a ) + 1 <NEWLINE> l = [ True ] * amx <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if l [ a [ i ] ] : <NEWLINE> <INDENT> for j in range ( a [ i ] , amx , a [ i ] ) : <NEWLINE> <INDENT> l [ j ] = False <NEWLINE> <DEDENT> if a [ i ] < a [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if l [ - 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> if V <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if A < B : <NEWLINE> <INDENT> A = A + T * V <NEWLINE> B = B + T * W <NEWLINE> if A >= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> A = A - T * V <NEWLINE> B = B - T * W <NEWLINE> if A <= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> sample_input = list ( range ( 3 ) ) <NEWLINE> sample_input [ 0 ] = <STRING> <NEWLINE> sample_input [ 1 ] = <STRING> <NEWLINE> sample_input [ 2 ] = <STRING> <NEWLINE> give_sample_input = None <NEWLINE> if give_sample_input is not None : <NEWLINE> <INDENT> sample_input_list = sample_input [ give_sample_input ] . split ( <STRING> ) <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sample_input_list . pop ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> num_of_S = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> num_of_T = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> def binary_search ( increasing_list , elem ) : <NEWLINE> <INDENT> index_min = 0 <NEWLINE> index_max = num_of_S - 1 <NEWLINE> <NL> while index_max - index_min >= 2 : <NEWLINE> <INDENT> index_middle = int ( ( index_min + index_max ) / 2 ) <NEWLINE> if increasing_list [ index_middle ] == elem : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif increasing_list [ index_middle ] > elem : <NEWLINE> <INDENT> index_max = index_middle <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index_min = index_middle <NEWLINE> <NL> <DEDENT> <DEDENT> if increasing_list [ index_min ] == elem : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif increasing_list [ index_max ] == elem : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for t in T : <NEWLINE> <INDENT> if binary_search ( S , t ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def mapint_inp ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def intinp ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> N , K = mapint_inp ( ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( K , N + 2 ) : <NEWLINE> <INDENT> mn = i * ( i - 1 ) // 2 <NEWLINE> mx = i * ( 2 * N - i + 1 ) // 2 <NEWLINE> ans += mx - mn + 1 <NEWLINE> <NL> <DEDENT> print ( ans % MOD ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> <NL> readline = sys . stdin . readline <NEWLINE> <NL> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> teleport = { 1 : True } <NEWLINE> next_town = 1 <NEWLINE> roop_exist = False <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> next_town = A [ next_town - 1 ] <COMMENT> <NEWLINE> try : <COMMENT> <NEWLINE> <INDENT> teleport [ next_town ] <NEWLINE> dupulicate_town = next_town <NEWLINE> <COMMENT> <NL> teleport = list ( teleport . keys ( ) ) <NEWLINE> dupulicate_index = teleport . index ( dupulicate_town ) <NEWLINE> dupulicate_list = teleport [ dupulicate_index : ] <NEWLINE> roop_exist = True <NEWLINE> break <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> teleport [ next_town ] = True <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if not roop_exist : <NEWLINE> <INDENT> teleport = list ( teleport . keys ( ) ) <NEWLINE> <NL> <DEDENT> if len ( teleport ) - 1 == K : <NEWLINE> <INDENT> print ( teleport [ - 1 ] ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> consumption = len ( teleport ) - 1 <NEWLINE> roop_num = K - consumption <NEWLINE> roop_index = roop_num % len ( dupulicate_list ) <NEWLINE> if roop_index == 0 : <NEWLINE> <INDENT> print ( dupulicate_list [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dupulicate_list [ roop_index - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> f = [ set ( ) for _ in range ( N ) ] <NEWLINE> v = [ False for _ in range ( N ) ] <NEWLINE> ans = 1 <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> f [ a ] . add ( b ) <NEWLINE> f [ b ] . add ( a ) <NEWLINE> <NL> <NL> <DEDENT> def dfs ( fi ) : <NEWLINE> <INDENT> if v [ fi ] : return 0 <NEWLINE> <NL> v [ fi ] = True <NEWLINE> cnt = 1 <NEWLINE> <NL> for fr in f [ fi ] : <NEWLINE> <INDENT> cnt += dfs ( fr ) <NEWLINE> <NL> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> cnt = dfs ( i ) <NEWLINE> ans = max ( ans , cnt ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> S = pi * r * r <NEWLINE> R = 2 * pi * r <NEWLINE> print ( <STRING> . format ( S , R ) ) <NEWLINE>
a , b , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n < b : <NEWLINE> <INDENT> print ( int ( a / b * n ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( a / b * ( b - 1 ) ) ) <NEWLINE> <DEDENT>
W , H , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if x != 0 and y != 0 : <NEWLINE> <INDENT> if W / x == 2 and H / y == 2 : <NEWLINE> <INDENT> print ( W * H / 2 , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( W * H / 2 , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( W * H / 2 , <STRING> ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LLI ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = I ( ) <NEWLINE> a_li = sorted ( LI ( ) ) <NEWLINE> b_li = sorted ( LI ( ) ) <NEWLINE> c_li = sorted ( LI ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> B = b_li [ i ] <NEWLINE> k = n - bisect . bisect_right ( c_li , B ) <NEWLINE> l = bisect . bisect_left ( a_li , B ) <NEWLINE> ans += k * l <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> bcs = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> total = sum ( A ) <NEWLINE> c = collections . Counter ( A ) <NEWLINE> ans = [ 0 for i in range ( Q ) ] <NEWLINE> <NL> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> B = bcs [ i ] [ 0 ] <NEWLINE> C = bcs [ i ] [ 1 ] <NEWLINE> if c [ B ] != 0 : <NEWLINE> <INDENT> total += c [ B ] * ( C - B ) <NEWLINE> ans [ i ] = total <NEWLINE> c [ C ] += c [ B ] <NEWLINE> c [ B ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = total <NEWLINE> <DEDENT> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> p = int ( input ( ) ) <NEWLINE> <NL> dir = 0 <NEWLINE> mae = [ ] <NEWLINE> usi = [ ] <NEWLINE> <NL> for _ in range ( p ) : <NEWLINE> <INDENT> Q = input ( ) . split ( ) <NEWLINE> if Q [ 0 ] == <STRING> : <NEWLINE> <INDENT> dir = not dir <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( int ( Q [ 1 ] ) - 1 ) == dir : <NEWLINE> <INDENT> mae . append ( Q [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> usi . append ( Q [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = <STRING> . join ( mae [ : : - 1 ] ) + s + <STRING> . join ( usi ) <NEWLINE> <NL> if not dir : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans [ : : - 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def solve ( N : int , A : <STRING> ) : <NEWLINE> <INDENT> A = sorted ( enumerate ( A ) , reverse = True , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( 0 , N - i ) : <NEWLINE> <INDENT> idx , a = A [ i + j ] <NEWLINE> <COMMENT> <NL> dp [ i + 1 ] [ j ] = max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j ] + a * abs ( idx - i ) ) <NEWLINE> dp [ i ] [ j + 1 ] = max ( dp [ i ] [ j + 1 ] , dp [ i ] [ j ] + a * abs ( N - 1 - j - idx ) ) <NEWLINE> <DEDENT> <DEDENT> result = - 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = dp [ i ] [ N - i ] <NEWLINE> if tmp > result : <NEWLINE> <INDENT> result = tmp <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> return <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> A = [ int ( next ( tokens ) ) for _ in range ( N ) ] <COMMENT> <NEWLINE> solve ( N , A ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> def GCD ( a , b ) : <NEWLINE> <COMMENT> <NL> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return GCD ( b , a % b ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> k = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> count = [ 0 ] * k <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> count [ GCD ( i , j ) - 1 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j , n in enumerate ( count ) : <NEWLINE> <INDENT> sum = sum + GCD ( i , j + 1 ) * n <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
<COMMENT> <NL> X = int ( input ( ) ) <NEWLINE> <NL> for i in range ( - 118 , 120 ) : <NEWLINE> <INDENT> for j in range ( - 119 , 119 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> <NL> A_set = set ( A ) <NEWLINE> <NL> if len ( A ) == len ( A_set ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> a [ i - k ] = ( n * i - i ** 2 + i + 1 ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( sum ( a ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ - 1 for _ in range ( n ) ] <NEWLINE> f = 0 <NEWLINE> if n != 1 : <NEWLINE> <NL> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a [ s - 1 ] == - 1 or a [ s - 1 ] == c : <NEWLINE> <INDENT> a [ s - 1 ] = c <NEWLINE> <DEDENT> if a [ s - 1 ] != - 1 and a [ s - 1 ] != c : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> if s == 1 and c == 0 : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> <DEDENT> for q in range ( n ) : <NEWLINE> <INDENT> if q != 0 and a [ q ] == - 1 : <NEWLINE> <INDENT> a [ q ] = 0 <NEWLINE> <DEDENT> if q == 0 and a [ q ] == - 1 : <NEWLINE> <INDENT> a [ q ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for t in range ( n ) : <NEWLINE> <INDENT> ans += a [ n - t - 1 ] * ( 10 ** t ) <NEWLINE> <DEDENT> print ( ans if f == 0 else - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <NL> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> d = c <NEWLINE> <DEDENT> if d != c : <NEWLINE> <INDENT> f = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if m != 0 : <NEWLINE> <NL> <INDENT> print ( c if f == 0 else - 1 ) <NEWLINE> <DEDENT> if m == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
from itertools import accumulate <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = [ 0 ] + list ( accumulate ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> lnow = 1 <NEWLINE> rnow = 3 <NEWLINE> for center in range ( 2 , n - 1 ) : <NEWLINE> <NL> <INDENT> laim = l [ center ] // 2 <NEWLINE> while lnow + 1 < center and l [ lnow + 1 ] < laim : lnow += 1 <NEWLINE> if rnow <= center : rnow = center + 1 <NEWLINE> raim = ( l [ - 1 ] - l [ center ] ) // 2 <NEWLINE> while rnow + 1 < n and l [ rnow + 1 ] - l [ center ] < raim : rnow += 1 <NEWLINE> for i , j in ( ( 0 , 0 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 0 , 1 ) ) : <NEWLINE> <INDENT> if lnow + i < center and rnow + j < n : <NEWLINE> <INDENT> a = ( l [ lnow + i ] , l [ center ] - l [ lnow + i ] , l [ rnow + j ] - l [ center ] , l [ - 1 ] - l [ rnow + j ] ) <NEWLINE> ans = min ( ans , max ( a ) - min ( a ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> bl = input ( ) . split ( ) <NEWLINE> A = int ( bl [ 0 ] ) <NEWLINE> B = int ( bl [ 1 ] ) <NEWLINE> C = int ( bl [ 2 ] ) <NEWLINE> <NL> if C < B : <NEWLINE> <INDENT> m = math . floor ( A * C / B ) - A * math . floor ( C / B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = math . floor ( A * ( B - 1 ) / B ) <NEWLINE> <NL> <DEDENT> print ( m ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> alist = [ int ( s ) for s in input ( ) . split ( <STRING> ) ] <NEWLINE> adict = { } <NEWLINE> ans = 0 <NEWLINE> for a in alist : <NEWLINE> <INDENT> ans += a <NEWLINE> if a in adict : <NEWLINE> <INDENT> adict [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> adict [ a ] = 1 <NEWLINE> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> bclist = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = [ int ( s ) for s in input ( ) . split ( <STRING> ) ] <NEWLINE> bclist . append ( [ b , c ] ) <NEWLINE> <NL> <DEDENT> for b , c in bclist : <NEWLINE> <INDENT> if c in adict and b in adict : <NEWLINE> <INDENT> ans += ( c - b ) * adict [ b ] <NEWLINE> adict [ c ] += adict [ b ] <NEWLINE> del adict [ b ] <NEWLINE> <DEDENT> elif b in adict : <NEWLINE> <INDENT> ans += ( c - b ) * adict [ b ] <NEWLINE> adict [ c ] = adict [ b ] <NEWLINE> del adict [ b ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> xy = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for xy in range ( N ) ] ) <NEWLINE> o = np . array ( [ 0 , 0 ] ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if np . linalg . norm ( xy [ i ] - o ) <= D : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a = [ [ [ 0 ] * 10 for i in range ( 3 ) ] for j in range ( 4 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> [ b , f , r , v ] = [ int ( j ) - 1 for j in input ( ) . split ( ) ] <NEWLINE> a [ b ] [ f ] [ r ] += v + 1 <NEWLINE> <NL> <DEDENT> for i , d in enumerate ( a ) : <NEWLINE> <INDENT> for c in d : print ( <STRING> , * c ) <NEWLINE> if i != len ( a ) - 1 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> plus = [ ] <NEWLINE> minus = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> min_v = 0 <NEWLINE> sum_v = 0 <NEWLINE> s = input ( ) <NEWLINE> for j in s : <NEWLINE> <INDENT> sum_v += 1 if j == <STRING> else - 1 <NEWLINE> min_v = min ( min_v , sum_v ) <NEWLINE> <DEDENT> if sum_v > 0 : <NEWLINE> <INDENT> plus . append ( ( min_v , sum_v ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus . append ( ( min_v - sum_v , - sum_v ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> plus . sort ( key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> minus . sort ( key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> <NL> sum_plus = 0 <NEWLINE> for min_v , sum_v in plus : <NEWLINE> <INDENT> if sum_plus + min_v < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> sum_plus += sum_v <NEWLINE> <NL> <DEDENT> sum_minus = 0 <NEWLINE> for min_v , sum_v in minus : <NEWLINE> <INDENT> if sum_minus + min_v < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> sum_minus += sum_v <NEWLINE> <NL> <DEDENT> if sum_plus == sum_minus : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ 0 ] * ( N ) <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> A [ i ] = math . floor ( ( N - 1 ) / ( i + 1 ) ) <NEWLINE> <DEDENT> print ( sum ( A ) ) <NEWLINE>
from collections import Counter <NEWLINE> import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( readline ( ) ) <NEWLINE> A = [ int ( i ) for i in readline ( ) . split ( ) ] <NEWLINE> <NL> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for i , a in enumerate ( A , start = 1 ) : <NEWLINE> <INDENT> B . append ( i + a ) <NEWLINE> C . append ( i - a ) <NEWLINE> <NL> <DEDENT> b = Counter ( B ) <NEWLINE> c = Counter ( C ) <NEWLINE> <NL> ans = 0 <NEWLINE> for k , v in b . items ( ) : <NEWLINE> <INDENT> if k in c : <NEWLINE> <INDENT> ans += v * c [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a - 1 ] . append ( b - 1 ) <NEWLINE> edges [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> INF = 10 ** 6 <NEWLINE> <NL> def dijkstra_travel ( edges ) : <NEWLINE> <INDENT> dists = [ INF for _ in range ( n ) ] <NEWLINE> paths = [ None for _ in range ( n ) ] <NEWLINE> <NL> dists [ 0 ] = 0 <NEWLINE> paths [ 0 ] = 0 <NEWLINE> <NL> next_travel = [ 0 ] <NEWLINE> <NL> def travel_adjacent ( ) : <NEWLINE> <INDENT> n = next_travel . pop ( 0 ) <NEWLINE> <NL> adjacent_nodes = list ( <NEWLINE> <INDENT> map ( <NEWLINE> <INDENT> lambda node : ( node , paths [ node ] ) , <NEWLINE> edges [ n ] , <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> for node , path in adjacent_nodes : <NEWLINE> <INDENT> if path is None or dists [ node ] > dists [ n ] + 1 : <NEWLINE> <INDENT> dists [ node ] = dists [ n ] + 1 <NEWLINE> paths [ node ] = n <NEWLINE> next_travel . append ( node ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> while len ( next_travel ) > 0 : <NEWLINE> <INDENT> travel_adjacent ( ) <NEWLINE> <NL> <DEDENT> return paths [ 1 : ] <NEWLINE> <NL> <DEDENT> result = dijkstra_travel ( edges ) <NEWLINE> <NL> if all ( map ( lambda x : x is not None , result ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> for x in result : <NEWLINE> <INDENT> print ( x + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
Row = int ( input ( ) ) <NEWLINE> dictA = { } <NEWLINE> a = <STRING> <NEWLINE> mid = 0 <NEWLINE> for i in range ( Row ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> dictA . setdefault ( a , 0 ) <NEWLINE> dictA [ a ] += 1 <NEWLINE> mid = max ( mid , dictA [ a ] ) <NEWLINE> <DEDENT> sDict = sorted ( dictA . items ( ) ) <NEWLINE> for i in range ( len ( dictA ) ) : <NEWLINE> <INDENT> if sDict [ i ] [ 1 ] == mid : <NEWLINE> <INDENT> print ( sDict [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> from collections import defaultdict , deque , Counter <NEWLINE> from copy import deepcopy <NEWLINE> from bisect import bisect , bisect_right , bisect_left <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> def RD ( ) : return input ( ) . rstrip ( ) <NEWLINE> def F ( ) : return float ( input ( ) . rstrip ( ) ) <NEWLINE> def I ( ) : return int ( input ( ) . rstrip ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MF ( ) : return map ( float , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def TI ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LF ( ) : return list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> def Init ( H , W , num ) : return [ [ num for i in range ( W ) ] for j in range ( H ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> L = [ LI ( ) for i in range ( N ) ] <NEWLINE> <NL> for x in range ( 101 ) : <NEWLINE> <INDENT> for y in range ( 101 ) : <NEWLINE> <INDENT> max_num = float ( <STRING> ) <NEWLINE> ans = 0 <NEWLINE> res = True <NEWLINE> for xn , yn , hn in L : <NEWLINE> <INDENT> if hn == 0 : <NEWLINE> <INDENT> max_num = min ( max_num , abs ( x - xn ) + abs ( y - yn ) ) <NEWLINE> if max_num == 0 : <NEWLINE> <INDENT> res = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> temp = abs ( x - xn ) + abs ( y - yn ) + hn <NEWLINE> if ans != 0 and ans != temp : <NEWLINE> <INDENT> res = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = temp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ( max_num >= 2 and ans == 0 ) or ans > max_num : <NEWLINE> <INDENT> res = False <NEWLINE> <NL> <DEDENT> if res : <NEWLINE> <INDENT> if ans != 0 : <NEWLINE> <INDENT> print ( x , y , ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x , y , 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if B - A >= 2 * K : <NEWLINE> <INDENT> for i in range ( A , A + K - 1 + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( B - K + 1 , B + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
var = [ 0 ] * 3 <NEWLINE> n , var [ 0 ] , var [ 1 ] , var [ 2 ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> choice = [ input ( ) for i in range ( n ) ] <NEWLINE> selVar = [ ] <NEWLINE> addVar = 0 <NEWLINE> res = [ ] <NEWLINE> flag = True <NEWLINE> <NL> for i in range ( len ( choice ) ) : <NEWLINE> <INDENT> if choice [ i ] == <STRING> : <NEWLINE> <INDENT> selVar = [ 0 , 1 ] <NEWLINE> <DEDENT> elif choice [ i ] == <STRING> : <NEWLINE> <INDENT> selVar = [ 1 , 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> selVar = [ 0 , 2 ] <NEWLINE> <DEDENT> if var [ 0 ] + var [ 1 ] + var [ 2 ] == 0 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> elif var [ 0 ] + var [ 1 ] + var [ 2 ] == 1 : <NEWLINE> <INDENT> if var [ selVar [ 0 ] ] == 0 and var [ selVar [ 1 ] ] == 0 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> elif var [ selVar [ 0 ] ] == 0 : <NEWLINE> <INDENT> var [ selVar [ 0 ] ] += 1 <NEWLINE> var [ selVar [ 1 ] ] -= 1 <NEWLINE> addVar = selVar [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> var [ selVar [ 0 ] ] -= 1 <NEWLINE> var [ selVar [ 1 ] ] += 1 <NEWLINE> addVar = selVar [ 1 ] <NEWLINE> <DEDENT> <DEDENT> elif var [ 0 ] + var [ 1 ] + var [ 2 ] >= 2 : <NEWLINE> <INDENT> if var [ selVar [ 0 ] ] == 0 and var [ selVar [ 1 ] ] == 0 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> elif var [ selVar [ 0 ] ] == 0 : <NEWLINE> <INDENT> var [ selVar [ 0 ] ] += 1 <NEWLINE> var [ selVar [ 1 ] ] -= 1 <NEWLINE> addVar = selVar [ 0 ] <NEWLINE> <DEDENT> elif var [ selVar [ 1 ] ] == 0 : <NEWLINE> <INDENT> var [ selVar [ 0 ] ] -= 1 <NEWLINE> var [ selVar [ 1 ] ] += 1 <NEWLINE> addVar = selVar [ 1 ] <NEWLINE> <DEDENT> elif var [ 0 ] + var [ 1 ] + var [ 2 ] == 2 : <NEWLINE> <INDENT> if i < len ( choice ) - 1 : <NEWLINE> <INDENT> if choice [ i ] != choice [ i + 1 ] : <NEWLINE> <INDENT> commonLet = set ( list ( choice [ i ] ) ) & set ( list ( choice [ i + 1 ] ) ) <NEWLINE> if <STRING> in commonLet : <NEWLINE> <INDENT> var [ 0 ] += 1 <NEWLINE> addVar = 0 <NEWLINE> if selVar [ 0 ] == 0 : <NEWLINE> <INDENT> var [ selVar [ 1 ] ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> var [ selVar [ 0 ] ] -= 1 <NEWLINE> <DEDENT> <DEDENT> if <STRING> in commonLet : <NEWLINE> <INDENT> var [ 1 ] += 1 <NEWLINE> addVar = 1 <NEWLINE> if selVar [ 0 ] == 1 : <NEWLINE> <INDENT> var [ selVar [ 1 ] ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> var [ selVar [ 0 ] ] -= 1 <NEWLINE> <DEDENT> <DEDENT> if <STRING> in commonLet : <NEWLINE> <INDENT> var [ 2 ] += 1 <NEWLINE> addVar = 2 <NEWLINE> if selVar [ 0 ] == 2 : <NEWLINE> <INDENT> var [ selVar [ 1 ] ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> var [ selVar [ 0 ] ] -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> var [ selVar [ 0 ] ] -= 1 <NEWLINE> var [ selVar [ 1 ] ] += 1 <NEWLINE> addVar = selVar [ 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> var [ selVar [ 0 ] ] -= 1 <NEWLINE> var [ selVar [ 1 ] ] += 1 <NEWLINE> addVar = selVar [ 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if var [ selVar [ 0 ] ] < var [ selVar [ 1 ] ] : <NEWLINE> <INDENT> var [ selVar [ 0 ] ] += 1 <NEWLINE> var [ selVar [ 1 ] ] -= 1 <NEWLINE> addVar = selVar [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> var [ selVar [ 0 ] ] -= 1 <NEWLINE> var [ selVar [ 1 ] ] += 1 <NEWLINE> addVar = selVar [ 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if addVar == 0 : <NEWLINE> <INDENT> res . append ( <STRING> ) <NEWLINE> <DEDENT> elif addVar == 1 : <NEWLINE> <INDENT> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if not flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for re in res : <NEWLINE> <INDENT> print ( re ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> S = list ( input ( ) ) <NEWLINE> <NL> cnt_b = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> cnt_b += 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> ans += cnt_b <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import copy <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = copy . deepcopy ( a ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> l = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 2 , int ( a [ i ] ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if a [ i ] % j == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while a [ i ] % j == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> a [ i ] = a [ i ] // j <NEWLINE> <DEDENT> if l . get ( j ) == None : <NEWLINE> <INDENT> l [ j ] = cnt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ j ] = max ( cnt , l [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if a [ i ] != 1 : <NEWLINE> <INDENT> if l . get ( a [ i ] ) == None : <NEWLINE> <INDENT> l [ a [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> L = 1 <NEWLINE> for k in l . keys ( ) : <NEWLINE> <INDENT> L *= pow ( k , l [ k ] , mod ) <NEWLINE> <DEDENT> L = L % mod <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += L * pow ( A [ i ] , mod - 2 , mod ) % mod <NEWLINE> ans = ans % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def bubble_sort_revision ( target_list ) : <COMMENT> <NEWLINE> <NL> <INDENT> list_length = len ( target_list ) <NEWLINE> <NL> flag = True <NEWLINE> change_count = 0 <NEWLINE> <NL> for top_index in range ( 1 , list_length ) : <NEWLINE> <INDENT> for i in range ( top_index , list_length ) [ : : - 1 ] : <NEWLINE> <INDENT> if target_list [ i ] < target_list [ i - 1 ] and target_list [ top_index ] >= target_list [ i ] : <NEWLINE> <INDENT> tmp = target_list [ i ] <NEWLINE> target_list [ i ] = target_list [ i - 1 ] <NEWLINE> target_list [ i - 1 ] = tmp <NEWLINE> change_count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return change_count <NEWLINE> <NL> <DEDENT> def my_add ( bit , i , x ) : <NEWLINE> <INDENT> while i <= len ( bit ) - 1 : <NEWLINE> <INDENT> bit [ i ] += x <NEWLINE> i += int ( bin ( i & - i ) , 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def my_sum ( bit , i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> s += bit [ i ] <NEWLINE> i -= int ( bin ( i & - i ) , 2 ) <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def merge ( l , r ) : <NEWLINE> <INDENT> global count <NEWLINE> l_index = 0 <NEWLINE> r_index = 0 <NEWLINE> merge_list = [ ] <NEWLINE> l . append ( pow ( 10 , 9 ) + 1 ) <NEWLINE> r . append ( pow ( 10 , 9 ) + 1 ) <NEWLINE> <NL> len_l = len ( l ) - 1 <NEWLINE> for k in range ( len ( l ) + len ( r ) - 2 ) : <NEWLINE> <INDENT> if l [ l_index ] < r [ r_index ] : <NEWLINE> <INDENT> merge_list . append ( l [ l_index ] ) <NEWLINE> l_index += 1 <NEWLINE> len_l -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += len_l <NEWLINE> merge_list . append ( r [ r_index ] ) <NEWLINE> r_index += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return merge_list <NEWLINE> <NL> <DEDENT> def merge_sort ( target_list ) : <NEWLINE> <INDENT> if len ( target_list ) == 1 : <NEWLINE> <INDENT> return target_list <NEWLINE> <NL> <DEDENT> mid = int ( len ( target_list ) / 2 ) <NEWLINE> <NL> r = merge_sort ( target_list [ mid : ] ) <NEWLINE> l = merge_sort ( target_list [ : mid ] ) <NEWLINE> <NL> return merge ( l , r ) <NEWLINE> <NL> <DEDENT> def bit_solve ( n , target_list ) : <COMMENT> <NEWLINE> <INDENT> bit = [ 0 for i in range ( max ( target_list ) + 2 ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += i - my_sum ( bit , target_list [ i ] + 1 ) <NEWLINE> my_add ( bit , target_list [ i ] + 1 , 1 ) <NEWLINE> print ( ans , target_list [ i ] , bit ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> global count <NEWLINE> count = 0 <NEWLINE> l = int ( input ( ) ) <NEWLINE> target_list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> merge_sort ( target_list ) <NEWLINE> print ( count ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if len ( S ) == len ( T ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ i ] != S [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> countbox = [ ] <NEWLINE> for n in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ i ] != S [ i + n ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> countbox . append ( count ) <NEWLINE> <DEDENT> print ( min ( countbox ) ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d = int ( a / b ) <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> print ( <STRING> . format ( d , r , f ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> data = [ 0 ] * n <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , v = [ int ( el ) for el in input ( ) . split ( ) ] <NEWLINE> data [ a - 1 ] += v <NEWLINE> <DEDENT> result = max ( data ) <NEWLINE> print ( data . index ( result ) + 1 , result ) <NEWLINE>
import math <NEWLINE> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> y = ( a ** 2 ) * b <NEWLINE> h = x / ( a ** 2 ) <NEWLINE> <NL> def get_angle_from_sides ( a , b , c ) : <NEWLINE> <INDENT> return math . acos ( ( a ** 2 + b ** 2 - c ** 2 ) / ( 2 * a * b ) ) <NEWLINE> <NL> <DEDENT> def checkio ( a , b , c ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> angles = [ get_angle_from_sides ( * abc ) for abc in ( ( a , b , c ) , ( b , c , a ) , ( c , a , b ) ) ] <NEWLINE> result = sorted ( ( math . degrees ( a ) ) for a in angles ) <NEWLINE> return [ 0 , 0 , 0 ] if 0 in result else result <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> return [ 0 , 0 , 0 ] <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> if y == x : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif y / 2 <= x : <NEWLINE> <INDENT> if a >= 2 * ( b - h ) : <NEWLINE> <INDENT> m = checkio ( a , 2 * ( b - h ) , math . sqrt ( a ** 2 + ( 2 * ( b - h ) ) ** 2 ) ) <NEWLINE> count = m [ 0 ] <NEWLINE> <DEDENT> elif a < 2 * ( b - h ) : <NEWLINE> <INDENT> m = checkio ( a , 2 * ( b - h ) , math . sqrt ( a ** 2 + ( 2 * ( b - h ) ) ** 2 ) ) <NEWLINE> count = m [ 1 ] <NEWLINE> <DEDENT> <DEDENT> elif y / 2 > x : <NEWLINE> <INDENT> z = 2 * x / ( a * b ) <NEWLINE> if b >= z : <NEWLINE> <INDENT> m = checkio ( b , z , math . sqrt ( b ** 2 + ( z ) ** 2 ) ) <NEWLINE> count = m [ 1 ] <NEWLINE> <DEDENT> elif b < z : <NEWLINE> <INDENT> m = checkio ( b , z , math . sqrt ( b ** 2 + ( z ) ** 2 ) ) <NEWLINE> count = m [ 0 ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> x = ( N // B ) * B - 1 <NEWLINE> ans = ( A * N ) // B - A * ( N // B ) <NEWLINE> if N >= B : <NEWLINE> <INDENT> ans = max ( ans , ( A * x ) // B - A * ( x // B ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) . split ( ) [ 0 ] ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ i for i in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> c2 = filter ( lambda n : n <= i , c ) <NEWLINE> for j in c2 : <NEWLINE> <INDENT> if j <= i and dp [ i - j ] + 1 < dp [ i ] : <NEWLINE> <INDENT> dp [ i ] = dp [ i - j ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE>
import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> foot = [ 0 ] <NEWLINE> is_loop = False <NEWLINE> ed = np . zeros ( [ n ] , dtype = int ) <NEWLINE> ed [ 0 ] = 1 <NEWLINE> <NL> for i in range ( 1 , k ) : <NEWLINE> <INDENT> go = a [ foot [ - 1 ] ] <NEWLINE> foot . append ( go ) <NEWLINE> if ed [ go ] == 1 : <NEWLINE> <INDENT> st_i = foot . index ( foot [ - 1 ] ) <NEWLINE> lo_size = len ( foot ) - 1 - st_i <NEWLINE> <NL> k -= st_i <NEWLINE> k %= lo_size <NEWLINE> <NL> print ( foot [ st_i + k ] + 1 ) <NEWLINE> is_loop = True <NEWLINE> break <NEWLINE> <DEDENT> ed [ go ] = 1 <NEWLINE> <NL> <DEDENT> if not is_loop : <NEWLINE> <INDENT> print ( a [ foot [ - 1 ] ] + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> n = len ( N ) <NEWLINE> ans = 0 <NEWLINE> if n < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if n > 3 : <NEWLINE> <INDENT> for i in range ( 3 , n ) : <NEWLINE> <INDENT> ans += 3 ** i - 3 * ( 2 ** i ) + 3 <NEWLINE> <DEDENT> <DEDENT> a = int ( N [ 0 ] ) <NEWLINE> if a > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 1 ) - 2 * ( 2 ** ( n - 1 ) ) + 1 <NEWLINE> <DEDENT> if a > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 1 ) - 2 * ( 2 ** ( n - 1 ) ) + 1 <NEWLINE> <DEDENT> if a > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 1 ) - 2 * ( 2 ** ( n - 1 ) ) + 1 <NEWLINE> <DEDENT> b = int ( N [ 1 ] ) <NEWLINE> c = int ( N [ 2 ] ) <NEWLINE> if a == 3 : <NEWLINE> <INDENT> if b > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 2 ) - 2 * ( 2 ** ( n - 2 ) ) + 1 <NEWLINE> <DEDENT> if b > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 2 ) - ( 2 ** ( n - 2 ) ) <NEWLINE> <DEDENT> if b > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 2 ) - ( 2 ** ( n - 2 ) ) <NEWLINE> <DEDENT> if b == 3 : <NEWLINE> <INDENT> if c > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - 2 * ( 2 ** ( n - 3 ) ) + 1 <NEWLINE> <DEDENT> if c > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> <DEDENT> if b == 5 : <NEWLINE> <INDENT> if c > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) <NEWLINE> <DEDENT> <DEDENT> if b == 7 : <NEWLINE> <INDENT> if c > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) <NEWLINE> <DEDENT> if c > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif a == 5 : <NEWLINE> <INDENT> if b > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 2 ) - ( 2 ** ( n - 2 ) ) <NEWLINE> <DEDENT> if b > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 2 ) - 2 * ( 2 ** ( n - 2 ) ) + 1 <NEWLINE> <DEDENT> if b > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 2 ) - ( 2 ** ( n - 2 ) ) <NEWLINE> <DEDENT> if b == 3 : <NEWLINE> <INDENT> if c > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) <NEWLINE> <DEDENT> <DEDENT> if b == 5 : <NEWLINE> <INDENT> if c > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - 2 * ( 2 ** ( n - 3 ) ) + 1 <NEWLINE> <DEDENT> if c > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> <DEDENT> if b == 7 : <NEWLINE> <INDENT> if c > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) <NEWLINE> <DEDENT> if c > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif a == 7 : <NEWLINE> <INDENT> if b > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 2 ) - ( 2 ** ( n - 2 ) ) <NEWLINE> <DEDENT> if b > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 2 ) - ( 2 ** ( n - 2 ) ) <NEWLINE> <DEDENT> if b > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 2 ) - 2 * ( 2 ** ( n - 2 ) ) + 1 <NEWLINE> <DEDENT> if b == 3 : <NEWLINE> <INDENT> if c > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) <NEWLINE> <DEDENT> if c > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> <DEDENT> if b == 5 : <NEWLINE> <INDENT> if c > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) <NEWLINE> <DEDENT> if c > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> <DEDENT> if b == 7 : <NEWLINE> <INDENT> if c > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - 2 * ( 2 ** ( n - 3 ) ) + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( a == 3 or a == 5 or a == 7 ) and ( b == 3 or b == 5 or b == 7 ) and ( c == 3 or c == 5 or c == 7 ) : <NEWLINE> <INDENT> d = ( a * 100 + b * 10 + c ) * 10 ** ( n - 3 ) <NEWLINE> e = int ( N ) + 1 <NEWLINE> t = { <STRING> , <STRING> , <STRING> } <NEWLINE> for i in range ( d , e ) : <NEWLINE> <INDENT> u = set ( str ( i ) ) <NEWLINE> if u == t : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> to = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> to [ a ] . append ( b ) <NEWLINE> to [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = [ - 1 for _ in range ( n ) ] <NEWLINE> d = deque ( ) <NEWLINE> d . append ( 0 ) <NEWLINE> while len ( d ) > 0 : <NEWLINE> <INDENT> now = d . popleft ( ) <NEWLINE> for v in to [ now ] : <NEWLINE> <INDENT> if ans [ v ] > - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ v ] = now <NEWLINE> d . append ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] + 1 ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = Counter ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( s [ i + 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> tot = 0 <NEWLINE> tot += s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < n and s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> tot -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( tot ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ [ 0 ] for _ in range ( n ) ] <NEWLINE> for _ in [ 0 ] * m : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> L [ a - 1 ] . append ( b - 1 ) <NEWLINE> L [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> L [ 0 ] [ 0 ] = 1 <NEWLINE> ans = [ 0 ] * n <NEWLINE> dq = deque ( [ 0 ] ) <NEWLINE> while dq : <NEWLINE> <INDENT> t = dq . popleft ( ) <NEWLINE> for i in range ( 1 , len ( L [ t ] ) ) : <NEWLINE> <INDENT> next = L [ t ] [ i ] <NEWLINE> if ans [ next ] != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ next ] = t + 1 <NEWLINE> dq . append ( next ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ t ] [ 0 ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * ans [ 1 : ] , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
m = int ( input ( ) ) <NEWLINE> N = input ( ) <NEWLINE> cnt = N . count ( <STRING> ) * N . count ( <STRING> ) * N . count ( <STRING> ) <NEWLINE> <COMMENT> <NL> for i in range ( m - 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> for j in range ( i + 1 , int ( ( m + i - 1 ) / 2 ) + 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> <COMMENT> <NL> if N [ k ] != N [ j ] and N [ j ] != N [ i ] and N [ i ] != N [ k ] : <NEWLINE> <COMMENT> <NL> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> from sys import stdin <NEWLINE> from operator import itemgetter <NEWLINE> from collections import deque , Counter <NEWLINE> import math <NEWLINE> import pprint <NEWLINE> from functools import reduce <NEWLINE> <COMMENT> <NL> <NL> MOD = 1000000007 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> alpha = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> def keta ( kazu ) : <COMMENT> <NEWLINE> <INDENT> kazu_str = str ( kazu ) <NEWLINE> kazu_list = [ int ( kazu_str [ i ] ) for i in range ( 0 , len ( kazu_str ) ) ] <NEWLINE> return kazu_list <NEWLINE> <NL> <DEDENT> def gcd ( * numbers ) : <COMMENT> <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> def combination ( m , n ) : <COMMENT> <NEWLINE> <NL> <INDENT> if n > m : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return math . factorial ( m ) // ( math . factorial ( m - n ) * math . factorial ( n ) ) <NEWLINE> <NL> <DEDENT> def pow_k ( x , n ) : <COMMENT> <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> K = 1 <NEWLINE> while n > 1 : <NEWLINE> <INDENT> if n % 2 != 0 : <NEWLINE> <INDENT> K *= x <NEWLINE> <DEDENT> x *= x <NEWLINE> n //= 2 <NEWLINE> <DEDENT> return K * x <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> a = list ( map ( int , [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] ) ) <NEWLINE> dic = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] in dic : <NEWLINE> <INDENT> dic [ a [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ a [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> for k , v in dic . items ( ) : <NEWLINE> <INDENT> if v != 0 : <NEWLINE> <INDENT> ans += k * v <NEWLINE> <DEDENT> <DEDENT> q = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> if b in dic : <NEWLINE> <INDENT> ans += ( c - b ) * dic [ b ] <NEWLINE> print ( ans ) <NEWLINE> if c in dic : <NEWLINE> <INDENT> dic [ c ] += dic [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ c ] = dic [ b ] <NEWLINE> <DEDENT> dic [ b ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
from itertools import combinations <NEWLINE> <NL> n = 2019 <NEWLINE> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if l // n < r // n : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( ( i * j ) % n for i , j in combinations ( range ( l % n , r % n + 1 ) , 2 ) ) ) <NEWLINE> <DEDENT>
num = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> prime_check = [ 1 ] * 1000100 <NEWLINE> count = 2 <NEWLINE> while num > 1 : <NEWLINE> <INDENT> if prime_check [ count ] == 1 : <COMMENT> <NEWLINE> <INDENT> tmp = 0 <NEWLINE> while num % count == 0 : <COMMENT> <NEWLINE> <INDENT> num /= count <NEWLINE> tmp += 1 <NEWLINE> <DEDENT> tmp2 = 1 <NEWLINE> while tmp >= tmp2 : <COMMENT> <NEWLINE> <INDENT> ans += 1 <NEWLINE> tmp -= tmp2 <NEWLINE> tmp2 += 1 <NEWLINE> <DEDENT> tmp = count <NEWLINE> while tmp * count <= 1e6 : <NEWLINE> <INDENT> prime_check [ tmp * count ] = 0 <NEWLINE> tmp += 1 <NEWLINE> <DEDENT> <DEDENT> count += 1 <NEWLINE> if ( count > 1e6 ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i + a [ i ] in d . keys ( ) : <NEWLINE> <INDENT> d [ i + a [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i + a [ i ] ] = 1 <NEWLINE> <DEDENT> if i - a [ i ] in d . keys ( ) : <NEWLINE> <INDENT> ans += d [ i - a [ i ] ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * pi ) , <STRING> . format ( 2 * r * pi ) ) <NEWLINE>
cin = open ( 0 ) . read ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> <NL> n , k = map ( int , cin [ 0 ] . split ( <STRING> ) ) <NEWLINE> a = list ( map ( int , cin [ 1 ] . split ( <STRING> ) ) ) <NEWLINE> <NL> history = [ 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> history . append ( a [ history [ i ] - 1 ] ) <NEWLINE> <NL> <DEDENT> if n >= k : <NEWLINE> <INDENT> print ( history [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> times = [ - 1 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if times [ history [ i ] - 1 ] == - 1 : <NEWLINE> <INDENT> times [ history [ i ] - 1 ] = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cycle = i - times [ history [ i ] - 1 ] <NEWLINE> pre = times [ history [ i ] - 1 ] <NEWLINE> mod = ( k - pre ) % cycle <NEWLINE> print ( history [ pre + mod ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> a = <STRING> <NEWLINE> for b in sys . stdin : <NEWLINE> <INDENT> b = b . strip ( ) <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> c = <STRING> . join ( a [ ord ( e ) - 97 - i ] if e in a else e for e in b ) <NEWLINE> if any ( ( <STRING> in c , <STRING> in c , <STRING> in c ) ) : print ( c ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> distance = n [ 1 ] <NEWLINE> points = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n [ 0 ] ) ] <NEWLINE> ans = 0 <NEWLINE> for i in points : <NEWLINE> <INDENT> x = i [ 0 ] <NEWLINE> y = i [ 1 ] <NEWLINE> d = math . sqrt ( x ** 2 + y ** 2 ) <NEWLINE> if d <= distance : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> al = <STRING> <NEWLINE> AL = al . upper ( ) <NEWLINE> <NL> n , k = I ( ) <NEWLINE> h = l ( ) <NEWLINE> h . sort ( reverse = True ) <NEWLINE> <NL> print ( sum ( h [ k : ] ) ) <NEWLINE>
from itertools import groupby <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> grouped = groupby ( s ) <NEWLINE> <NL> res = [ ] <NEWLINE> <NL> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> res . append ( ( 1 , 0 ) ) <NEWLINE> <NL> <DEDENT> for l , v in grouped : <NEWLINE> <INDENT> res . append ( ( l , len ( list ( v ) ) ) ) <NEWLINE> <NL> <DEDENT> if s [ len ( s ) - 1 ] == <STRING> : <NEWLINE> <INDENT> res . append ( ( 1 , 0 ) ) <NEWLINE> <NL> <DEDENT> now = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( min ( len ( res ) , 2 * k + 1 ) ) : <NEWLINE> <INDENT> now += res [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> ans = max ( ans , now ) <NEWLINE> <NL> for i in range ( 2 * k + 1 , len ( res ) , 2 ) : <NEWLINE> <INDENT> now -= res [ i - 2 * k - 1 ] [ 1 ] <NEWLINE> now -= res [ i - 2 * k ] [ 1 ] <NEWLINE> <NL> now += res [ i ] [ 1 ] <NEWLINE> now += res [ i + 1 ] [ 1 ] <NEWLINE> <NL> ans = max ( ans , now ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> Line = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> Line . sort ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in Line : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif ans == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ret = min ( A , K ) <NEWLINE> if A < K : <NEWLINE> <INDENT> ret -= max ( 0 , K - A - B ) <NEWLINE> <DEDENT> print ( ret ) <NEWLINE>
import numpy as np <NEWLINE> def resolve ( ) : <NEWLINE> <INDENT> s = [ int ( num ) for num in input ( ) ] <NEWLINE> <NL> ten = 1 <NEWLINE> num = 0 <NEWLINE> mod_table = np . zeros ( shape = 2019 , dtype = int ) <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> num += s [ len ( s ) - i - 1 ] * ten <NEWLINE> num %= 2019 <NEWLINE> mod_table [ num ] += 1 <NEWLINE> ten = ( ten * 10 ) % 2019 <NEWLINE> <NL> <DEDENT> ans = sum ( ( mod_table * ( mod_table - 1 ) ) // 2 ) <NEWLINE> ans += mod_table [ 0 ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - x - y <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if ( i + 1 ) * i // 2 >= x : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> import collections <NEWLINE> s = [ int ( c ) for c in input ( ) ] <NEWLINE> tmp = 1 <NEWLINE> mod = 0 <NEWLINE> count = collections . defaultdict ( int ) <NEWLINE> for i , num in enumerate ( s [ : : - 1 ] ) : <NEWLINE> <INDENT> mod = ( tmp * num + mod ) % 2019 <NEWLINE> count [ mod ] += 1 <NEWLINE> tmp *= 10 <NEWLINE> tmp %= 2019 <NEWLINE> <DEDENT> count [ 0 ] += 1 <NEWLINE> print ( sum ( ( item * ( item - 1 ) // 2 for item in count . values ( ) ) ) ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) + [ 10 ** 6 + 1 ] <NEWLINE> a = sorted ( a ) <NEWLINE> flag = np . array ( [ 0 for i in range ( 10 ** 6 + 1 ) ] ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if flag [ a [ i ] ] == 0 : <NEWLINE> <INDENT> flag [ : : a [ i ] ] = 1 <NEWLINE> if a [ i ] != a [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> from functools import lru_cache <NEWLINE> <NL> @ lru_cache ( maxsize = 10000 ) <NEWLINE> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> res = 0 <NEWLINE> <NL> for a in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> gcdab = gcd ( a , b ) <NEWLINE> for c in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> res += gcd ( gcdab , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 998244353 <NEWLINE> <NL> fac = [ 1 ] * ( N + 1 ) <NEWLINE> inv = [ 1 ] * ( N + 1 ) <NEWLINE> ifac = [ 1 ] * ( N + 1 ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> fac [ i ] = ( fac [ i - 1 ] * i ) % MOD <NEWLINE> inv [ i ] = - ( inv [ MOD % i ] * ( MOD // i ) ) % MOD <NEWLINE> ifac [ i ] = ( ifac [ i - 1 ] * inv [ i ] ) % MOD <NEWLINE> <NL> <DEDENT> cmbarr = [ 1 ] * N <NEWLINE> for r in range ( N - 1 ) : <NEWLINE> <INDENT> cmbarr [ r + 1 ] = cmbarr [ r ] * ( N - 1 - r ) * inv [ r + 1 ] % MOD <NEWLINE> <NL> <DEDENT> A = [ M * pow ( M - 1 , N - 1 - i , MOD ) * cmbarr [ i ] % MOD for i in range ( K + 1 ) ] <NEWLINE> print ( sum ( A ) % MOD ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> i , ans = 1 , 0 <NEWLINE> <NL> while i ** 2 <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> num = n // i <NEWLINE> ans = max ( len ( str ( num ) ) , len ( str ( i ) ) ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> <NL> def lunlun ( d , v , L ) : <NEWLINE> <INDENT> L . append ( v ) <NEWLINE> if d == 10 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for i in range ( - 1 , 2 ) : <NEWLINE> <INDENT> t = v % 10 + i <NEWLINE> <COMMENT> <NL> if 0 <= t <= 9 : <NEWLINE> <INDENT> lunlun ( d + 1 , v * 10 + t , L ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for v in range ( 1 , 10 ) : <NEWLINE> <INDENT> lunlun ( 1 , v , L ) <NEWLINE> <DEDENT> print ( sorted ( L ) [ k - 1 ] ) <NEWLINE>
<COMMENT> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> class ModInt : <NEWLINE> <INDENT> def __init__ ( self , x ) : <NEWLINE> <INDENT> if type ( x ) is str : <NEWLINE> <INDENT> x = int ( x ) <NEWLINE> <DEDENT> self . x = x % MOD <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return str ( self . x ) <NEWLINE> <NL> <DEDENT> __repr__ = __str__ <NEWLINE> <NL> def __add__ ( self , other ) : <NEWLINE> <INDENT> return ( <NEWLINE> <INDENT> ModInt ( self . x + other . x ) <NEWLINE> if isinstance ( other , ModInt ) <NEWLINE> else ModInt ( self . x + other ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> def __sub__ ( self , other ) : <NEWLINE> <INDENT> return ( <NEWLINE> <INDENT> ModInt ( self . x - other . x ) <NEWLINE> if isinstance ( other , ModInt ) <NEWLINE> else ModInt ( self . x - other ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> def __mul__ ( self , other ) : <NEWLINE> <INDENT> return ( <NEWLINE> <INDENT> ModInt ( self . x * other . x ) <NEWLINE> if isinstance ( other , ModInt ) <NEWLINE> else ModInt ( self . x * other ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> def __truediv__ ( self , other ) : <NEWLINE> <INDENT> return ( <NEWLINE> <INDENT> ModInt ( self . x * pow ( other . x , MOD - 2 , MOD ) ) <NEWLINE> if isinstance ( other , ModInt ) <NEWLINE> else ModInt ( self . x * pow ( other , MOD - 2 , MOD ) ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> def __pow__ ( self , other ) : <NEWLINE> <INDENT> return ( <NEWLINE> <INDENT> ModInt ( pow ( self . x , other . x , MOD ) ) <NEWLINE> if isinstance ( other , ModInt ) <NEWLINE> else ModInt ( pow ( self . x , other , MOD ) ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> __radd__ = __add__ <NEWLINE> <NL> def __rsub__ ( self , other ) : <NEWLINE> <INDENT> return ( <NEWLINE> <INDENT> ModInt ( other . x - self . x ) <NEWLINE> if isinstance ( other , ModInt ) <NEWLINE> else ModInt ( other - self . x ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> __rmul__ = __mul__ <NEWLINE> <NL> def __rtruediv__ ( self , other ) : <NEWLINE> <INDENT> return ( <NEWLINE> <INDENT> ModInt ( other . x * pow ( self . x , MOD - 2 , MOD ) ) <NEWLINE> if isinstance ( other , ModInt ) <NEWLINE> else ModInt ( other * pow ( self . x , MOD - 2 , MOD ) ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> def __rpow__ ( self , other ) : <NEWLINE> <INDENT> return ( <NEWLINE> <INDENT> ModInt ( pow ( other . x , self . x , MOD ) ) <NEWLINE> if isinstance ( other , ModInt ) <NEWLINE> else ModInt ( pow ( other , self . x , MOD ) ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ls = list ( map ( ModInt , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = ModInt ( 0 ) <NEWLINE> <NL> sm = sum ( ls ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans += ls [ i ] * sm <NEWLINE> <NL> <DEDENT> sub = ModInt ( 0 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sub += ls [ i ] * ls [ i ] <NEWLINE> <NL> <DEDENT> ans -= sub <NEWLINE> <NL> ans = ans / 2 <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
def kakko ( S ) : <NEWLINE> <INDENT> cum = 0 <NEWLINE> mi = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> cum += 1 if s == <STRING> else - 1 <NEWLINE> mi = min ( mi , cum ) <NEWLINE> <DEDENT> return ( - mi , cum - mi ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> S = [ kakko ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> plus = [ ] <NEWLINE> minus = [ ] <NEWLINE> <NL> for l , r in S : <NEWLINE> <INDENT> if l <= r : <NEWLINE> <INDENT> plus . append ( ( l , r ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus . append ( ( l , r ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> plus . sort ( key = lambda a : a [ 0 ] ) <NEWLINE> minus . sort ( key = lambda a : a [ 1 ] , reverse = True ) <NEWLINE> M = 0 <NEWLINE> for l , r in ( plus + minus ) : <NEWLINE> <INDENT> M -= l <NEWLINE> if M < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> M += r <NEWLINE> <NL> <DEDENT> print ( <STRING> if M == 0 else <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> <NL> n , quantum = map ( int , input ( ) . split ( ) ) <NEWLINE> q = deque ( ) <NEWLINE> total_time = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> name , time = input ( ) . split ( ) <NEWLINE> q . append ( [ name , int ( time ) ] ) <NEWLINE> <NL> <DEDENT> while q : <NEWLINE> <INDENT> ps_name , ps_time = q . popleft ( ) <NEWLINE> if ps_time <= quantum : <NEWLINE> <INDENT> total_time += ps_time <NEWLINE> print ( ps_name , total_time ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total_time += quantum <NEWLINE> ps_time -= quantum <NEWLINE> q . append ( [ ps_name , ps_time ] ) <NEWLINE> <DEDENT> <DEDENT>
n , m , k = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> p = 998244353 <NEWLINE> <STRING> <NEWLINE> def cmb ( n , r , p ) : <NEWLINE> <INDENT> if ( r < 0 ) or ( n < r ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return fact [ n ] * factinv [ r ] * factinv [ n - r ] % p <NEWLINE> <NL> <DEDENT> p = 998244353 <NEWLINE> N = n <COMMENT> <NEWLINE> fact = [ 1 , 1 ] <COMMENT> <NEWLINE> factinv = [ 1 , 1 ] <COMMENT> <NEWLINE> inv = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % p ) <NEWLINE> inv . append ( ( - inv [ p % i ] * ( p // i ) ) % p ) <NEWLINE> factinv . append ( ( factinv [ - 1 ] * inv [ - 1 ] ) % p ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> ans += m * pow ( m - 1 , n - 1 - i , p ) * cmb ( n - 1 , i , p ) <NEWLINE> ans %= p <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> <NL> T = int ( input ( ) ) <NEWLINE> Ns = [ ] <NEWLINE> cases = [ ] * T <NEWLINE> for i in range ( T ) : <NEWLINE> <INDENT> Ns . append ( int ( input ( ) ) ) <NEWLINE> cases . append ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Ns [ - 1 ] ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( T ) : <NEWLINE> <INDENT> answer = 0 <NEWLINE> N = Ns [ i ] <NEWLINE> case = cases [ i ] <NEWLINE> <NL> sa = [ case [ j ] [ 2 ] - case [ j ] [ 1 ] for j in range ( N ) ] <NEWLINE> pluss = [ ] <NEWLINE> minuss = [ ] <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if sa [ j ] >= 0 : <NEWLINE> <INDENT> pluss . append ( [ case [ j ] [ 0 ] , case [ j ] [ 1 ] , case [ j ] [ 2 ] , sa [ j ] ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minuss . append ( [ case [ j ] [ 0 ] , case [ j ] [ 1 ] , case [ j ] [ 2 ] , sa [ j ] ] ) <NEWLINE> <DEDENT> <DEDENT> pluss = sorted ( pluss ) <NEWLINE> minuss = sorted ( minuss , reverse = True ) <NEWLINE> hq = [ ] <NEWLINE> checking = 0 <NEWLINE> for j in range ( N - len ( pluss ) , N ) : <NEWLINE> <INDENT> if checking < len ( pluss ) : <NEWLINE> <INDENT> while j > pluss [ checking ] [ 0 ] - 1 : <NEWLINE> <INDENT> heapq . heappush ( hq , [ - pluss [ checking ] [ 3 ] , pluss [ checking ] [ 1 ] , pluss [ checking ] [ 2 ] , pluss [ checking ] [ 0 ] ] ) <NEWLINE> checking += 1 <NEWLINE> if checking >= len ( pluss ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( hq ) > 0 : <NEWLINE> <INDENT> temp = heapq . heappop ( hq ) <NEWLINE> answer += temp [ 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( checking , len ( pluss ) ) : <NEWLINE> <INDENT> heapq . heappush ( hq , [ - pluss [ j ] [ 3 ] , pluss [ j ] [ 1 ] , pluss [ j ] [ 2 ] , pluss [ j ] [ 0 ] ] ) <NEWLINE> <NL> <DEDENT> for j in range ( len ( hq ) ) : <NEWLINE> <INDENT> temp = heapq . heappop ( hq ) <NEWLINE> answer += temp [ 1 ] <NEWLINE> <NL> <DEDENT> hq = [ ] <NEWLINE> checking = 0 <NEWLINE> for j in range ( len ( minuss ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if checking < len ( minuss ) : <NEWLINE> <INDENT> while j <= minuss [ checking ] [ 0 ] - 1 : <NEWLINE> <INDENT> heapq . heappush ( hq , [ minuss [ checking ] [ 3 ] , minuss [ checking ] [ 1 ] , minuss [ checking ] [ 2 ] , minuss [ checking ] [ 0 ] ] ) <NEWLINE> checking += 1 <NEWLINE> if checking >= len ( minuss ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( hq ) > 0 : <NEWLINE> <INDENT> temp = heapq . heappop ( hq ) <NEWLINE> answer += temp [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( checking , len ( minuss ) ) : <NEWLINE> <INDENT> heapq . heappush ( hq , [ minuss [ j ] [ 3 ] , minuss [ j ] [ 1 ] , minuss [ j ] [ 2 ] , minuss [ j ] [ 0 ] ] ) <NEWLINE> <NL> <DEDENT> for j in range ( len ( hq ) ) : <NEWLINE> <INDENT> temp = heapq . heappop ( hq ) <NEWLINE> answer += temp [ 2 ] <NEWLINE> <DEDENT> print ( answer ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> DP = [ 0 ] * ( N + 1 ) <NEWLINE> DP [ 1 ] = 1 <NEWLINE> <NL> S = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> S . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> for l , r in S : <NEWLINE> <INDENT> DP [ i ] += ( DP [ max ( i - l , 0 ) ] - DP [ max ( i - r - 1 , 0 ) ] ) <NEWLINE> <DEDENT> DP [ i ] += DP [ i - 1 ] <NEWLINE> DP [ i ] %= 998244353 <NEWLINE> <NL> <DEDENT> print ( ( DP [ N ] - DP [ N - 1 ] ) % 998244353 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> print ( len ( set ( S ) ) ) <NEWLINE>
import numpy as np <NEWLINE> def main ( ) : <NEWLINE> <INDENT> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> max_value = 0 <NEWLINE> x = np . min ( [ B - 1 , N ] ) <NEWLINE> max_value = int ( np . floor ( A * x / B ) ) <NEWLINE> print ( max_value ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> <NL> n = int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> a = list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> c . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for j in b : <NEWLINE> <INDENT> ans += ( n - bisect_right ( c , j ) ) * bisect_left ( a , j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> a1 = a <NEWLINE> nokori = 0 <NEWLINE> nokori_1 = 0 <NEWLINE> nokori_2 = 0 <NEWLINE> tensuu = 0 <NEWLINE> <NL> if k - a1 > 0 : <NEWLINE> <INDENT> tensuu += a1 <NEWLINE> nokori = k - a <NEWLINE> <NL> <DEDENT> if nokori > 0 : <NEWLINE> <INDENT> tensuu += 0 <NEWLINE> nokori2 = nokori - b <NEWLINE> if nokori2 > 0 : <NEWLINE> <INDENT> tensuu -= nokori2 <NEWLINE> <DEDENT> <DEDENT> if k - a1 <= 0 : <NEWLINE> <INDENT> tensuu = k <NEWLINE> <DEDENT> print ( tensuu ) <NEWLINE>
import math <NEWLINE> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cyaku = b // c <NEWLINE> dyaku = b // d <NEWLINE> <NL> <NL> cds = b // ( ( c * d ) // ( math . gcd ( c , d ) ) ) <NEWLINE> <NL> x = b - ( cyaku + dyaku - cds ) <NEWLINE> <NL> cyaku2 = ( a - 1 ) // c <NEWLINE> dyaku2 = ( a - 1 ) // d <NEWLINE> <NL> cds2 = ( a - 1 ) // ( ( c * d ) // ( math . gcd ( c , d ) ) ) <NEWLINE> <NL> y = ( a - 1 ) - ( cyaku2 + dyaku2 - cds2 ) <NEWLINE> <NL> print ( x - y ) <NEWLINE>
N , M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> Groups = [ 1 for i in range ( N ) ] <NEWLINE> dsts = [ - 1 for i in range ( N ) ] <NEWLINE> ABs = [ [ int ( i ) - 1 for i in input ( ) . split ( ) ] for i in range ( M ) ] <NEWLINE> for A , B in ABs : <NEWLINE> <INDENT> dst = min ( A , B ) <NEWLINE> src = max ( A , B ) <NEWLINE> <COMMENT> <NL> while ( dsts [ dst ] != - 1 ) : <NEWLINE> <INDENT> dst = dsts [ dst ] <NEWLINE> <DEDENT> while ( dsts [ src ] != - 1 ) : <NEWLINE> <INDENT> src = dsts [ src ] <NEWLINE> <DEDENT> if dst != min ( A , B ) : <NEWLINE> <INDENT> omdst = min ( A , B ) <NEWLINE> while ( dsts [ omdst ] != dst ) : <NEWLINE> <INDENT> n_omdst = dsts [ omdst ] <NEWLINE> dsts [ omdst ] = dst <NEWLINE> omdst = n_omdst <NEWLINE> <DEDENT> <DEDENT> if src != max ( A , B ) : <NEWLINE> <INDENT> omsrc = max ( A , B ) <NEWLINE> while ( dsts [ omsrc ] != src ) : <NEWLINE> <INDENT> n_omsrc = dsts [ omsrc ] <NEWLINE> dsts [ omsrc ] = src <NEWLINE> omsrc = n_omsrc <NEWLINE> <NL> <DEDENT> <DEDENT> if dst == src : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dst2 = min ( dst , src ) <NEWLINE> src2 = max ( dst , src ) <NEWLINE> dsts [ src2 ] = dst2 <NEWLINE> Groups [ dst2 ] += Groups [ src2 ] <NEWLINE> Groups [ src2 ] = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( max ( Groups ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> * A , = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> * B , = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> * C , = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lenc = len ( C ) <NEWLINE> <NL> from bisect import * <NEWLINE> <NL> cnt = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> in_a = bisect_left ( A , b ) <NEWLINE> in_c = bisect_right ( C , b ) <NEWLINE> cnt += in_a * ( lenc - in_c ) <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
X , N = input ( ) . split ( ) <NEWLINE> X = int ( X ) <NEWLINE> N = int ( N ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tmp = [ i for i in range ( - 101 , 200 ) ] <NEWLINE> for i in p : <NEWLINE> <INDENT> tmp . remove ( i ) <NEWLINE> <DEDENT> for i in range ( len ( tmp ) ) : <NEWLINE> <INDENT> tmp [ i ] = abs ( tmp [ i ] - X ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in p : <NEWLINE> <INDENT> if X - min ( tmp ) == i : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( X - min ( tmp ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X + min ( tmp ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> n = N // i <COMMENT> <NEWLINE> ans += n * ( 2 * i + ( n - 1 ) * i ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( K ) ] <NEWLINE> MOD = 998244353 <NEWLINE> <NL> dp = [ 1 ] <NEWLINE> cumdp = [ 0 , 1 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for l , r in LR : <NEWLINE> <INDENT> if i - l + 1 <= 0 : continue <NEWLINE> tmp += cumdp [ i - l + 1 ] - cumdp [ max ( 0 , i - r ) ] <NEWLINE> <DEDENT> tmp %= MOD <NEWLINE> dp . append ( tmp ) <NEWLINE> cumdp . append ( ( cumdp [ - 1 ] + tmp ) % MOD ) <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
import heapq <NEWLINE> <NL> a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> inp = input ( ) . split ( ) <NEWLINE> if inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> heapq . heappush ( a , - int ( inp [ 1 ] ) ) <NEWLINE> <DEDENT> elif inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( - heapq . heappop ( a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> length = len ( a ) <NEWLINE> total = sum ( a ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 0 , length ) : <NEWLINE> <INDENT> total -= a [ i ] <NEWLINE> ans += ( a [ i ] * total ) <NEWLINE> <NL> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> for i , v in enumerate ( s [ 0 : - 1 ] ) : <NEWLINE> <INDENT> if v == s [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from numba import jit <NEWLINE> @ jit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lamps = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for ki in range ( k ) : <NEWLINE> <INDENT> lamplog = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lamplog [ max ( 0 , i - lamps [ i ] ) ] += 1 <COMMENT> <NEWLINE> lamplog [ min ( i + lamps [ i ] + 1 , n ) ] -= 1 <COMMENT> <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( n ) : <COMMENT> <NEWLINE> <INDENT> lamplog [ i + 1 ] += lamplog [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> lamplog . pop ( ) <NEWLINE> if ( lamplog == lamps ) : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> lamps = lamplog <COMMENT> <NEWLINE> <DEDENT> return lamplog <NEWLINE> <NL> <DEDENT> lamplog = main ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( lamplog ) ) : <NEWLINE> <INDENT> ans += str ( lamplog [ i ] ) + <STRING> <NEWLINE> <DEDENT> print ( ans . rstrip ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> <NL> p = [ 0 ] * n <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> p [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in p : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> edge [ a ] . append ( b ) <NEWLINE> edge [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> label = [ - 1 ] * n <NEWLINE> <NL> i = 0 <NEWLINE> for start in range ( n ) : <NEWLINE> <INDENT> if label [ start ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> label [ start ] = i <NEWLINE> <DEDENT> f = deque ( [ start ] ) <NEWLINE> while f : <NEWLINE> <INDENT> v = f . popleft ( ) <NEWLINE> for e in edge [ v ] : <NEWLINE> <INDENT> if label [ e ] == - 1 : <NEWLINE> <INDENT> label [ e ] = i <NEWLINE> f . append ( e ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> Renketsu = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in label : <NEWLINE> <INDENT> Renketsu [ i ] += 1 <NEWLINE> <NL> <DEDENT> Block = [ 0 ] * n <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> c , d = c - 1 , d - 1 <NEWLINE> if label [ c ] == label [ d ] : <NEWLINE> <INDENT> Block [ c ] += 1 <NEWLINE> Block [ d ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> ans . append ( Renketsu [ label [ k ] ] - 1 - len ( edge [ k ] ) - Block [ k ] ) <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
r , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> a [ i ] += [ sum ( a [ i ] ) ] <NEWLINE> print ( * a [ i ] ) <NEWLINE> <DEDENT> a = list ( zip ( * a ) ) <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> print ( sum ( a [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( sum ( a [ c ] ) ) <NEWLINE> <NL>
import heapq <NEWLINE> <NL> x , y , z , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( reverse = True ) <NEWLINE> b . sort ( reverse = True ) <NEWLINE> c . sort ( reverse = True ) <NEWLINE> <NL> hq = [ [ - a [ 0 ] - b [ 0 ] - c [ 0 ] , 0 , 0 , 0 ] ] <NEWLINE> heapq . heapify ( hq ) <NEWLINE> visited = { ( 0 , 0 , 0 ) } <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> ii , ia , ib , ic = heapq . heappop ( hq ) <NEWLINE> print ( - ii ) <NEWLINE> na = min ( ia + 1 , x - 1 ) <NEWLINE> nb = min ( ib + 1 , y - 1 ) <NEWLINE> nc = min ( ic + 1 , z - 1 ) <NEWLINE> if not ( na , ib , ic ) in visited : <NEWLINE> <INDENT> heapq . heappush ( hq , [ - a [ na ] - b [ ib ] - c [ ic ] , na , ib , ic ] ) <NEWLINE> visited . add ( ( na , ib , ic ) ) <NEWLINE> <DEDENT> if not ( ia , nb , ic ) in visited : <NEWLINE> <INDENT> heapq . heappush ( hq , [ - a [ ia ] - b [ nb ] - c [ ic ] , ia , nb , ic ] ) <NEWLINE> visited . add ( ( ia , nb , ic ) ) <NEWLINE> <DEDENT> if not ( ia , ib , nc ) in visited : <NEWLINE> <INDENT> heapq . heappush ( hq , [ - a [ ia ] - b [ ib ] - c [ nc ] , ia , ib , nc ] ) <NEWLINE> visited . add ( ( ia , ib , nc ) ) <NEWLINE> <DEDENT> <DEDENT>
a = input ( ) <NEWLINE> t = list ( a ) <NEWLINE> if t [ len ( t ) - 1 ] == <STRING> : <NEWLINE> <INDENT> t [ len ( t ) - 1 ] = <STRING> <NEWLINE> <DEDENT> if t [ 0 ] == <STRING> : <NEWLINE> <INDENT> if t [ 1 ] == <STRING> or t [ 1 ] == <STRING> : <NEWLINE> <INDENT> t [ 0 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ 0 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , len ( t ) - 1 ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> and t [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> elif t [ i ] == <STRING> and t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> elif t [ i ] == <STRING> and t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> elif t [ i ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> answer = <STRING> . join ( t ) <NEWLINE> print ( answer ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : break <NEWLINE> for x in range ( int ( H / 2 ) ) : <NEWLINE> <INDENT> if W % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> * int ( W / 2 ) + <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> * int ( W / 2 ) ) <NEWLINE> if W % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> * int ( W / 2 ) + <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> * int ( W / 2 ) ) <NEWLINE> <DEDENT> if H % 2 != 0 : <NEWLINE> <INDENT> if W % 2 != 0 : print ( <STRING> * int ( W / 2 ) + <STRING> ) <NEWLINE> else : print ( <STRING> * int ( W / 2 ) ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> l . append ( 0 ) <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> l [ i - 1 ] += 1 <NEWLINE> <DEDENT> for x in l : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> <NL> T = [ 0 ] * 2001 <NEWLINE> for a in range ( 1001 ) : <NEWLINE> <INDENT> for b in range ( 1001 ) : <NEWLINE> <INDENT> T [ a + b ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for s in sys . stdin : <NEWLINE> <INDENT> n = int ( s ) <NEWLINE> <NL> sum_n_num = 0 <NEWLINE> for a_b_sum in range ( 0 , n + 1 ) : <NEWLINE> <INDENT> c_d_sum = n - a_b_sum <NEWLINE> if a_b_sum <= 2000 and c_d_sum <= 2000 : <NEWLINE> <INDENT> sum_n_num += T [ a_b_sum ] * T [ c_d_sum ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum_n_num ) <NEWLINE> <DEDENT>
from math import ceil <NEWLINE> x , k , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> xi = abs ( x ) <NEWLINE> if abs ( x ) > d * k : <NEWLINE> <INDENT> m = min ( abs ( x + d * k ) , abs ( x - d * k ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = ceil ( xi / d ) <NEWLINE> if ( n + k ) % 2 == 0 : <NEWLINE> <INDENT> m = abs ( xi - d * n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = abs ( xi - d * ( n - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( max ( a ) + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , c [ i ] + c [ i - 1 ] + c [ i + 1 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = max ( a ) <NEWLINE> <NL> def min_factor ( k ) : <NEWLINE> <INDENT> d = [ ] <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> d . append ( i ) <NEWLINE> <NL> <DEDENT> i = 2 <NEWLINE> while i * i <= k : <NEWLINE> <INDENT> if d [ i ] == i : <NEWLINE> <INDENT> j = i * i <NEWLINE> while j <= k : <NEWLINE> <INDENT> if d [ j ] == j : <NEWLINE> <INDENT> d [ j ] = i <NEWLINE> <DEDENT> j += i <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> return d <NEWLINE> <NL> <DEDENT> def prime_factor_set ( p ) : <NEWLINE> <INDENT> s = set ( ) <NEWLINE> while p != 1 : <NEWLINE> <INDENT> s . add ( d [ p ] ) <NEWLINE> p //= d [ p ] <NEWLINE> <NL> <DEDENT> return s <NEWLINE> <NL> <NL> <DEDENT> d = min_factor ( A ) <NEWLINE> cur = set ( ) <NEWLINE> flg = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = prime_factor_set ( a [ i ] ) <NEWLINE> if len ( cur & tmp ) >= 1 : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <DEDENT> cur |= tmp <NEWLINE> <NL> <DEDENT> import numpy as np <NEWLINE> <NL> g = np . gcd . reduce ( a ) <NEWLINE> <NL> if flg : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif not flg and g == 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , read ( ) . split ( ) ) <NEWLINE> a = { int ( read ( ) ) - 1 for _ in range ( m ) } <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> dp = [ 0 ] * n <NEWLINE> if 0 not in a : <NEWLINE> <INDENT> dp [ 0 ] = 1 <NEWLINE> <DEDENT> if 1 not in a : <NEWLINE> <INDENT> dp [ 1 ] = 1 + dp [ 0 ] <NEWLINE> <DEDENT> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % mod <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> input = sys . stdin . buffer . readline <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> return a if b == 0 else gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // gcd ( a , b ) <NEWLINE> <NL> <DEDENT> def prime_factorize ( n ) : <NEWLINE> <INDENT> pf = { } <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> pf [ i ] = pf . get ( i , 0 ) + 1 <NEWLINE> n //= i <NEWLINE> <DEDENT> <DEDENT> if n > 1 : pf [ n ] = 1 <NEWLINE> return pf <NEWLINE> <NL> <DEDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> pf = prime_factorize ( gcd ( A , B ) ) <NEWLINE> print ( len ( pf ) + 1 ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = Counter ( v [ : : 2 ] ) . most_common ( ) <NEWLINE> b = Counter ( v [ 1 : : 2 ] ) . most_common ( ) <NEWLINE> a . append ( [ 0 , 0 ] ) <NEWLINE> b . append ( [ 0 , 0 ] ) <NEWLINE> <NL> if a [ 0 ] [ 0 ] != b [ 0 ] [ 0 ] : <NEWLINE> <INDENT> print ( n - a [ 0 ] [ 1 ] - b [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( n - a [ 1 ] [ 1 ] - b [ 0 ] [ 1 ] , n - a [ 0 ] [ 1 ] - b [ 1 ] [ 1 ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> write = sys . stdout . write <NEWLINE> n , q = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> N0 = 2 ** ( n - 1 ) . bit_length ( ) <NEWLINE> INF = 2 ** 31 - 1 <NEWLINE> data = [ INF ] * ( 2 * N0 ) <NEWLINE> <NL> def update ( k , x ) : <NEWLINE> <INDENT> k += N0 - 1 <NEWLINE> data [ k ] = x <NEWLINE> while k >= 0 : <NEWLINE> <INDENT> k = ( k - 1 ) // 2 <NEWLINE> data [ k ] = min ( data [ 2 * k + 1 ] , data [ 2 * k + 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def query ( l , r ) : <NEWLINE> <INDENT> L = l + N0 ; R = r + N0 <NEWLINE> s = INF <NEWLINE> while L < R : <NEWLINE> <INDENT> if R & 1 : <NEWLINE> <INDENT> R -= 1 <NEWLINE> s = min ( s , data [ R - 1 ] ) <NEWLINE> <NL> <DEDENT> if L & 1 : <NEWLINE> <INDENT> s = min ( s , data [ L - 1 ] ) <NEWLINE> L += 1 <NEWLINE> <DEDENT> L >>= 1 ; R >>= 1 <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <NL> <DEDENT> ans = [ ] <NEWLINE> for q in range ( q ) : <NEWLINE> <INDENT> t , x , y = map ( int , readline ( ) . split ( ) ) <NEWLINE> if t : <NEWLINE> <INDENT> ans . append ( str ( query ( x , y + 1 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> update ( x , y ) <NEWLINE> <DEDENT> <DEDENT> write ( <STRING> . join ( ans ) ) <NEWLINE> write ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ 2 , 1 ] <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> a . append ( a [ i ] + a [ i + 1 ] ) <NEWLINE> <DEDENT> print ( a [ n ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> X = sorted ( [ a for a in A if a >= 0 ] ) <NEWLINE> Y = sorted ( [ a for a in A if a < 0 ] , key = lambda x : abs ( x ) ) <NEWLINE> <NL> if 2 * ( min ( K , len ( Y ) ) // 2 ) + len ( X ) >= K : <NEWLINE> <INDENT> ans = 1 <NEWLINE> if K % 2 == 1 : <NEWLINE> <INDENT> ans *= X . pop ( ) <NEWLINE> K -= 1 <NEWLINE> <NL> <DEDENT> XX = [ ( x1 * x2 ) for x1 , x2 in zip ( * [ iter ( X [ : : - 1 ] ) ] * 2 ) ] <NEWLINE> YY = [ ( y1 * y2 ) for y1 , y2 in zip ( * [ iter ( Y [ : : - 1 ] ) ] * 2 ) ] <NEWLINE> ZZ = sorted ( XX + YY ) <NEWLINE> <NL> for i in range ( K // 2 ) : <NEWLINE> <INDENT> ans *= ZZ . pop ( ) <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> Z = sorted ( X + Y , key = lambda x : abs ( x ) , reverse = True ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans *= Z . pop ( ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> step = sum ( [ 90 * 100 ** i for i in range ( len ( str ( N ) ) // 2 ) ] ) <NEWLINE> dance_floor = sum ( [ 9 * 100 ** i for i in range ( len ( str ( N ) ) // 2 ) ] ) <NEWLINE> <NL> ans = len ( str ( N ) ) % 2 * ( N - step ) + - 1 * ( len ( str ( N ) ) % 2 - 1 ) * dance_floor <NEWLINE> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in arr : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> a = 1 <NEWLINE> for i in arr : <NEWLINE> <INDENT> a *= i <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AB = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> AB . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> new = [ 0 for i in range ( N ) ] <NEWLINE> for ab in AB : <NEWLINE> <INDENT> if H [ ab [ 0 ] - 1 ] <= H [ ab [ 1 ] - 1 ] : <NEWLINE> <INDENT> new [ ab [ 0 ] - 1 ] += 1 <NEWLINE> <DEDENT> if H [ ab [ 0 ] - 1 ] >= H [ ab [ 1 ] - 1 ] : <NEWLINE> <INDENT> new [ ab [ 1 ] - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( new . count ( 0 ) ) <NEWLINE>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> ab = int ( A / B ) <NEWLINE> if ab == 0 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = int ( len ( bin ( ab ) ) - 2 ) <NEWLINE> <DEDENT> B1 = B * ( 2 ** x ) <NEWLINE> bc = int ( B1 / C ) <NEWLINE> if bc == 0 : <NEWLINE> <INDENT> y = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = int ( len ( bin ( bc ) ) - 2 ) <NEWLINE> <DEDENT> if x + y <= K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = sum ( a ) <NEWLINE> counter = collections . Counter ( a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> num = counter [ b ] <NEWLINE> counter [ b ] = 0 <NEWLINE> counter [ c ] += num <NEWLINE> ans += ( c - b ) * num <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> c = collections . Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> defo = sum ( a ) <NEWLINE> default = [ 0 ] * 100001 <NEWLINE> for i in a : <NEWLINE> <INDENT> default [ i ] += 1 <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> defo = defo + ( c - b ) * default [ b ] <NEWLINE> print ( defo ) <NEWLINE> default [ c ] += default [ b ] <NEWLINE> default [ b ] = 0 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . add ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( a ) ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = len ( A ) <NEWLINE> ans = 1 <NEWLINE> a = 0 <NEWLINE> for a in range ( B ) : <NEWLINE> <INDENT> ans = ans * A [ a ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> res = <STRING> <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if len ( S ) == 1 : <NEWLINE> <INDENT> res += <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> if i == 0 : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> res += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += <STRING> <NEWLINE> <DEDENT> <DEDENT> elif i == len ( S ) - 1 : <NEWLINE> <INDENT> res += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if res [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> res += <STRING> <NEWLINE> <DEDENT> elif S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> res += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res += S [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def f ( x ) : <NEWLINE> <INDENT> return math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> <NL> <NL> <DEDENT> print ( f ( min ( B - 1 , N ) ) ) <NEWLINE>
import math <NEWLINE> nums = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> n = nums [ 0 ] <NEWLINE> x = nums [ 1 ] <NEWLINE> y = nums [ 2 ] <NEWLINE> res = [ 0 for i in range ( 2010 ) ] <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> dis = j - i <NEWLINE> dis = min ( dis , abs ( i - x ) + abs ( j - y ) + 1 ) <NEWLINE> res [ dis ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( res [ i ] ) <NEWLINE> <DEDENT>
<NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> digits = [ ] <NEWLINE> <NL> while N != 0 : <NEWLINE> <INDENT> digits . append ( N % 26 ) <NEWLINE> if digits [ - 1 ] == 0 : <NEWLINE> <INDENT> digits [ - 1 ] = 26 <NEWLINE> N //= 26 <NEWLINE> N -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N //= 26 <NEWLINE> <DEDENT> <DEDENT> digits . reverse ( ) <NEWLINE> for d in digits : <NEWLINE> <INDENT> print ( chr ( 96 + d ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> from collections import defaultdict <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> res . append ( 2 ) <NEWLINE> <DEDENT> for i in range ( 3 , math . floor ( n // 2 ) + 1 , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in res : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <DEDENT> def fact2 ( n ) : <NEWLINE> <INDENT> p = factorization ( n ) <NEWLINE> res = [ ] <NEWLINE> for i in p : <NEWLINE> <INDENT> c = 0 <NEWLINE> z = n <NEWLINE> while 1 : <NEWLINE> <INDENT> if z % i == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> z /= i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> res . append ( [ i , c ] ) <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> def fact ( n ) : <COMMENT> <NEWLINE> <INDENT> ans = 1 <NEWLINE> m = n <NEWLINE> for _i in range ( n - 1 ) : <NEWLINE> <INDENT> ans *= m <NEWLINE> m -= 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> def comb ( n , r ) : <COMMENT> <NEWLINE> <INDENT> l = min ( r , n - r ) <NEWLINE> m = n <NEWLINE> u = 1 <NEWLINE> for _i in range ( l ) : <NEWLINE> <INDENT> u *= m <NEWLINE> m -= 1 <NEWLINE> <DEDENT> return u // fact ( l ) <NEWLINE> <NL> <NL> <DEDENT> S = readChar ( ) <NEWLINE> <NL> re = [ 0 ] * len ( S ) <NEWLINE> res = [ 0 ] * len ( S ) <NEWLINE> res [ - 1 ] = int ( S [ - 1 ] ) <NEWLINE> <NL> for i in range ( 2 , len ( S ) + 1 ) : <NEWLINE> <INDENT> re = int ( S [ i * - 1 ] ) * pow ( 10 , i - 1 , 2019 ) <NEWLINE> res [ i * - 1 ] = ( res [ i * - 1 + 1 ] + re ) % 2019 <NEWLINE> <NL> <DEDENT> d = defaultdict ( int ) <NEWLINE> for i in res : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <NL> <DEDENT> ans = d [ 0 ] <NEWLINE> for key in d : <NEWLINE> <INDENT> if d [ key ] > 1 : <NEWLINE> <INDENT> ans += comb ( d [ key ] , 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) . split ( ) <NEWLINE> S . sort ( ) <NEWLINE> ans = 1 <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> A = int ( S [ i ] ) <NEWLINE> if ( A == 0 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= A <NEWLINE> <DEDENT> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i - k ] < a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> def partition ( A , p , r ) : <NEWLINE> <INDENT> x = A [ r ] [ 1 ] <NEWLINE> i = p - 1 <NEWLINE> for k in range ( p , r ) : <NEWLINE> <INDENT> if A [ k ] [ 1 ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> A [ i ] , A [ k ] = A [ k ] , A [ i ] <NEWLINE> <DEDENT> <DEDENT> A [ i + 1 ] , A [ r ] = A [ r ] , A [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <NL> <DEDENT> def quick_sort ( A , p , r ) : <NEWLINE> <INDENT> if p < r : <NEWLINE> <INDENT> q = partition ( A , p , r ) <NEWLINE> quick_sort ( A , p , q - 1 ) <NEWLINE> quick_sort ( A , q + 1 , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> def bubble_sort ( c , n ) : <NEWLINE> <INDENT> x = c [ : ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for k in range ( n - 1 , i , - 1 ) : <NEWLINE> <INDENT> if x [ k ] [ 1 ] < x [ k - 1 ] [ 1 ] : <NEWLINE> <INDENT> x [ k ] , x [ k - 1 ] = x [ k - 1 ] , x [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def is_stable ( _in , out ) : <NEWLINE> <INDENT> n = len ( _in ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for k in range ( i + 1 , n ) : <NEWLINE> <INDENT> for a in range ( n ) : <NEWLINE> <INDENT> for b in range ( a + 1 , n ) : <NEWLINE> <INDENT> if _in [ i ] [ 1 ] == _in [ k ] [ 1 ] and _in [ i ] == out [ b ] and _in [ k ] == out [ a ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> mrk , num = input ( ) . split ( ) <NEWLINE> num = int ( num ) <NEWLINE> a . append ( ( mrk , num ) ) <NEWLINE> <DEDENT> b = a [ : ] <NEWLINE> quick_sort ( b , 0 , n - 1 ) <NEWLINE> if n > 10000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = bubble_sort ( a [ : ] , n ) <NEWLINE> if b == c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> for i in b : <NEWLINE> <INDENT> print ( * i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> dp = [ 0 ] * ( 10 ** 6 + 10 ) <NEWLINE> for x in A : <NEWLINE> <INDENT> i = 0 <NEWLINE> while x + i <= 10 ** 6 + 10 : <NEWLINE> <INDENT> if dp [ ( x - 1 ) ] == 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ ( x - 1 ) + i ] += 1 <NEWLINE> i += x <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for x in A : <NEWLINE> <INDENT> if dp [ x - 1 ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> def factorize_rec ( n , factor ) : <NEWLINE> <INDENT> for i in range ( 2 , math . floor ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> factor . append ( i ) <NEWLINE> return factorize_rec ( n / i , factor ) <NEWLINE> <DEDENT> <DEDENT> factor . append ( int ( n ) ) <NEWLINE> return factor <NEWLINE> <NL> <DEDENT> def factorize ( n ) : <NEWLINE> <INDENT> return factorize_rec ( n , [ ] ) <NEWLINE> <NL> <DEDENT> print ( str ( n ) + <STRING> , end = <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( * factorize ( n ) , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def run ( ) : <NEWLINE> <INDENT> q = [ ] <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> if line . startswith ( <STRING> ) : <NEWLINE> <INDENT> v = int ( line [ 7 : ] ) <NEWLINE> q . append ( v ) <NEWLINE> i = len ( q ) - 1 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> p = ( i - 1 ) // 2 <NEWLINE> vp = q [ p ] <NEWLINE> if vp < v : <NEWLINE> <INDENT> q [ p ] , q [ i ] = v , vp <NEWLINE> i = p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif line . startswith ( <STRING> ) : <NEWLINE> <NL> <INDENT> size = len ( q ) - 1 <NEWLINE> if size < 0 : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <NL> <DEDENT> v = q [ 0 ] <NEWLINE> last = q . pop ( ) <NEWLINE> if size > 0 : <NEWLINE> <INDENT> q [ 0 ] = last <NEWLINE> i = 0 <NEWLINE> while i < size // 2 : <NEWLINE> <INDENT> top , vt = i , last <NEWLINE> left = ( i + 1 ) * 2 - 1 <NEWLINE> right = ( i + 1 ) * 2 <NEWLINE> if left < size : <NEWLINE> <INDENT> vl = q [ left ] <NEWLINE> if vl > vt : <NEWLINE> <INDENT> top , vt = left , vl <NEWLINE> <DEDENT> <DEDENT> if right < size : <NEWLINE> <INDENT> vr = q [ right ] <NEWLINE> if vr > vt : <NEWLINE> <INDENT> top , vt = right , vr <NEWLINE> <NL> <DEDENT> <DEDENT> if top > i : <NEWLINE> <INDENT> q [ top ] , q [ i ] = last , vt <NEWLINE> i = top <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( v ) <NEWLINE> <DEDENT> elif line . startswith ( <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ValueError ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] * ( n - k ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> l [ i ] = a [ i + k ] / a [ i ] <NEWLINE> <DEDENT> for i in range ( n - k ) : <NEWLINE> <INDENT> if l [ i ] > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> <NL> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> if a == <STRING> or b == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> ans += int ( a ) * int ( b [ 0 ] ) * 100 <NEWLINE> ans += int ( a ) * int ( b [ 2 ] ) * 10 <NEWLINE> ans += int ( a ) * int ( b [ 3 ] ) <NEWLINE> tmp = list ( str ( ans ) ) <NEWLINE> if len ( tmp ) == 1 or len ( tmp ) == 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> tmp . pop ( - 1 ) <NEWLINE> tmp . pop ( - 1 ) <NEWLINE> print ( int ( <STRING> . join ( tmp ) ) ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> r = range ( a , b + 1 ) <NEWLINE> for i in sorted ( set ( r [ : k ] ) | set ( r [ - k : ] ) ) : print ( i ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> d = list ( input ( ) for _ in range ( n ) ) <NEWLINE> D = Counter ( d ) <NEWLINE> m = max ( D . values ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i , j in D . most_common ( ) : <NEWLINE> <INDENT> if m != j : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> l . append ( i ) <NEWLINE> <DEDENT> l . sort ( ) <NEWLINE> for i in l : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> appendStrs = [ ] <NEWLINE> line = line . strip ( ) <NEWLINE> for i in range ( 0 , len ( line ) ) : <NEWLINE> <INDENT> if line [ i ] == <STRING> : <NEWLINE> <INDENT> appendStrs . append ( ( line [ i : i + 3 ] , <STRING> . join ( [ line [ i + 2 ] for _ in range ( 0 , int ( line [ i + 1 ] ) ) ] ) ) ) ; <NEWLINE> <DEDENT> <DEDENT> for a in appendStrs : <NEWLINE> <INDENT> line = line . replace ( * a , 1 ) <NEWLINE> <DEDENT> print ( line ) <NEWLINE> <NL> <DEDENT>
a , b , n = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if int ( n / b ) == 0 : <NEWLINE> <INDENT> print ( int ( ( a * n ) / b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( ( a * ( b - 1 ) ) / b ) ) <NEWLINE> <DEDENT>
<NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ - 1 for i in range ( M ) ] <NEWLINE> B = [ - 1 for i in range ( M ) ] <NEWLINE> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> uf = UnionFind ( N ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> uf . union ( A [ i ] - 1 , B [ i ] - 1 ) <NEWLINE> <NL> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> sn = len ( s ) <NEWLINE> tn = len ( t ) <NEWLINE> <NL> if sn < tn : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( sn - tn , - 1 , - 1 ) : <NEWLINE> <INDENT> matched = True <NEWLINE> for j in range ( tn ) : <NEWLINE> <INDENT> if s [ i + j ] != t [ j ] and s [ i + j ] != <STRING> : <NEWLINE> <INDENT> matched = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if matched : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if not matched : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> ans = [ <STRING> ] * sn <NEWLINE> for j in range ( 0 , i ) : <NEWLINE> <INDENT> if s [ j ] != <STRING> : <NEWLINE> <INDENT> ans [ j ] = s [ j ] <NEWLINE> <DEDENT> <DEDENT> for j in range ( tn ) : <NEWLINE> <INDENT> ans [ i + j ] = t [ j ] <NEWLINE> <DEDENT> for j in range ( i + tn , sn ) : <NEWLINE> <INDENT> if s [ j ] != <STRING> : <NEWLINE> <INDENT> ans [ j ] = s [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> from heapq import heappush , heappop <NEWLINE> from collections import Counter <NEWLINE> class HeapSet : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . minQue = [ ] <NEWLINE> self . maxQue = [ ] <NEWLINE> self . counter = Counter ( ) <NEWLINE> <NL> <DEDENT> def insert ( self , x ) : <NEWLINE> <INDENT> heappush ( self . minQue , x ) <NEWLINE> <COMMENT> <NL> self . counter [ x ] += 1 <NEWLINE> <NL> <DEDENT> def erase ( self , x ) : <NEWLINE> <INDENT> self . counter [ x ] -= 1 <NEWLINE> <NL> <DEDENT> def max ( self ) : <NEWLINE> <INDENT> while self . maxQue and self . counter [ - self . maxQue [ 0 ] ] == 0 : <NEWLINE> <INDENT> heappop ( self . maxQue ) <NEWLINE> <DEDENT> return - self . maxQue [ 0 ] if self . maxQue else None <NEWLINE> <NL> <DEDENT> def min ( self ) : <NEWLINE> <INDENT> while self . minQue and self . counter [ self . minQue [ 0 ] ] == 0 : <NEWLINE> <INDENT> heappop ( self . minQue ) <NEWLINE> <DEDENT> return self . minQue [ 0 ] if self . minQue else None <NEWLINE> <NL> <DEDENT> <DEDENT> MOD = 998244353 <NEWLINE> def resolve ( ) : <NEWLINE> <INDENT> def dfs ( v ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> for to in to_edge [ v ] : <NEWLINE> <INDENT> res *= dfs ( to ) <NEWLINE> res %= MOD <NEWLINE> <DEDENT> return res + 1 <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> AB = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> AB . sort ( ) <NEWLINE> st = HeapSet ( ) <NEWLINE> to_edge = [ [ ] for _ in range ( N ) ] <NEWLINE> <COMMENT> <NL> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> x = AB [ i ] [ 0 ] <COMMENT> <NEWLINE> d = AB [ i ] [ 1 ] <COMMENT> <NEWLINE> <NL> while st . min ( ) and st . min ( ) [ 0 ] < x + d : <NEWLINE> <INDENT> to_edge [ i ] . append ( st . min ( ) [ 1 ] ) <NEWLINE> st . erase ( st . min ( ) ) <NEWLINE> <DEDENT> st . insert ( ( x , i ) ) <COMMENT> <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for ( x , v ) in st . minQue : <NEWLINE> <INDENT> ans *= dfs ( v ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import copy <NEWLINE> <NL> s = list ( input ( ) ) <NEWLINE> <NL> s . reverse ( ) <NEWLINE> n = len ( s ) <NEWLINE> MOD = 2019 <NEWLINE> m = [ 0 ] * n <NEWLINE> msum = [ 0 ] * ( n + 1 ) <NEWLINE> cnt = [ 0 ] * ( MOD ) <NEWLINE> cnt [ 0 ] = 1 <NEWLINE> t = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m [ i ] = int ( s [ i ] ) * t % MOD <NEWLINE> msum [ i + 1 ] = ( msum [ i ] + m [ i ] ) % MOD <NEWLINE> cnt [ msum [ i + 1 ] ] += 1 <NEWLINE> t = t * 10 % MOD <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( MOD ) : <NEWLINE> <INDENT> ans += cnt [ i ] * ( cnt [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in lst : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in lst : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import re <NEWLINE> import queue <NEWLINE> import collections <NEWLINE> from math import ceil , floor , sqrt , pi , factorial , gcd <NEWLINE> from copy import deepcopy <NEWLINE> from collections import Counter , deque <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from itertools import accumulate , product , combinations , combinations_with_replacement <NEWLINE> from bisect import bisect , bisect_left , bisect_right <NEWLINE> from functools import reduce <NEWLINE> from decimal import Decimal , getcontext <NEWLINE> <COMMENT> <NL> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> def lcm ( a , b ) : return a * b // gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> num_list = [ ] <NEWLINE> str_list = [ ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = i_map ( ) <NEWLINE> m = 998244353 <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> for i in range ( 0 , K ) : <NEWLINE> <INDENT> tmpL , tmpR = i_map ( ) <NEWLINE> L . append ( tmpL ) <NEWLINE> R . append ( tmpR ) <NEWLINE> <NL> <DEDENT> a = [ ] <NEWLINE> a . append ( 0 ) <NEWLINE> a . append ( - 1 ) <NEWLINE> for i in range ( 2 , 3 * N ) : <NEWLINE> <INDENT> a . append ( 0 ) <NEWLINE> <NL> <DEDENT> f = [ ] <NEWLINE> f . append ( 1 ) <NEWLINE> <NL> for i in range ( 0 , N ) : <NEWLINE> <INDENT> for j in range ( 0 , K ) : <NEWLINE> <INDENT> a [ i + L [ j ] ] += f [ i ] <NEWLINE> a [ i + R [ j ] + 1 ] += - f [ i ] <NEWLINE> <DEDENT> f . append ( ( f [ i ] + a [ i + 1 ] ) % m ) <NEWLINE> <NL> <DEDENT> print ( f [ N - 1 ] % m ) <NEWLINE> <NL> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 4100000 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a - 1 ] . append ( b - 1 ) <NEWLINE> edges [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ 0 ] * N <NEWLINE> <NL> c . sort ( reverse = True ) <NEWLINE> <NL> def dfs ( x , par , index ) : <NEWLINE> <INDENT> L [ x ] = c [ index ] <NEWLINE> for u in edges [ x ] : <NEWLINE> <INDENT> if u != par : <NEWLINE> <INDENT> index += 1 <NEWLINE> index = dfs ( u , x , index ) <NEWLINE> <DEDENT> <DEDENT> return index <NEWLINE> <NL> <DEDENT> dfs ( 0 , - 1 , 0 ) <NEWLINE> <NL> print ( sum ( L [ 1 : ] ) ) <NEWLINE> print ( * L ) <NEWLINE>
sum = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> sum += 1 <NEWLINE> if ( sum != 1 ) : <NEWLINE> <INDENT> print ( ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( H == 0 and W == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if ( i == 1 ) : <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT> for j in range ( W ) : <NEWLINE> <INDENT> if ( i == 0 or j == 0 or i == H - 1 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> elif ( j == W - 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
N = list ( input ( ) ) <NEWLINE> A = 0 <NEWLINE> <NL> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> B = int ( N [ i ] ) <NEWLINE> A += B <NEWLINE> <DEDENT> if A % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 for x in range ( 10001 ) ] <NEWLINE> <NL> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> for j in range ( 1 , 100 ) : <NEWLINE> <INDENT> for k in range ( 1 , 100 ) : <NEWLINE> <INDENT> v = i * i + j * j + k * k + i * j + i * k + j * k <NEWLINE> if v < 10001 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ( i % 3 == 0 or i % 10 == 3 or <STRING> in str ( i ) ) : <NEWLINE> <INDENT> i = str ( i ) <NEWLINE> sys . stdout . write ( <STRING> + i ) <NEWLINE> i = int ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 7 <NEWLINE> cnt = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> if ans % k == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> ans *= 10 <NEWLINE> ans += 7 <NEWLINE> ans %= k <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
import math , sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ 0 ] * a <NEWLINE> <STRING> <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> c [ b [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> result = <STRING> . join ( map ( str , c ) ) <NEWLINE> print ( result ) <NEWLINE>
class Heap : <NEWLINE> <INDENT> def __init__ ( self , L ) : <NEWLINE> <INDENT> self . H = len ( L ) <NEWLINE> self . heap = L <NEWLINE> self . heap . insert ( 0 , 0 ) <NEWLINE> <NL> <DEDENT> def parent ( self , i ) : <NEWLINE> <INDENT> return i // 2 <NEWLINE> <NL> <DEDENT> def left ( self , i ) : <NEWLINE> <INDENT> return 2 * i <NEWLINE> <NL> <DEDENT> def right ( self , i ) : <NEWLINE> <INDENT> return 2 * i + 1 <NEWLINE> <NL> <DEDENT> def maxHeapify ( self , i ) : <NEWLINE> <INDENT> l = self . left ( i ) <NEWLINE> r = self . right ( i ) <NEWLINE> if l <= H and self . heap [ l ] > self . heap [ i ] : <NEWLINE> <INDENT> largest = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest = i <NEWLINE> <NL> <DEDENT> if r <= H and self . heap [ r ] > self . heap [ largest ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <NL> <DEDENT> if largest != i : <NEWLINE> <INDENT> self . heap [ i ] , self . heap [ largest ] = self . heap [ largest ] , self . heap [ i ] <NEWLINE> self . maxHeapify ( largest ) <NEWLINE> <NL> <DEDENT> <DEDENT> def buildMaxHeap ( self ) : <NEWLINE> <INDENT> for i in range ( self . H // 2 , 0 , - 1 ) : <NEWLINE> <INDENT> self . maxHeapify ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> H = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> heap = Heap ( L ) <NEWLINE> heap . buildMaxHeap ( ) <NEWLINE> heap . heap . pop ( 0 ) <NEWLINE> print ( <STRING> + <STRING> . join ( [ str ( a ) for a in heap . heap ] ) ) <NEWLINE>
<NL> def check ( N , c ) : <NEWLINE> <INDENT> RinRight = c . count ( <STRING> ) <NEWLINE> WinLeft = 0 <NEWLINE> r = RinRight <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> RinRight -= 1 <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> WinLeft += 1 <NEWLINE> <DEDENT> r = min ( r , max ( RinRight , WinLeft ) ) <NEWLINE> <NL> <DEDENT> return r <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> print ( check ( N , c ) ) <NEWLINE>
print <STRING> . join ( [ str ( x ) for x in ( sorted ( [ input ( ) for i in range ( 10 ) ] ) [ : - 4 : - 1 ] ) ] ) <NEWLINE>
from collections import deque <NEWLINE> q = deque ( ) <NEWLINE> <NL> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> b = input ( ) <NEWLINE> if b [ 0 ] == <STRING> : <NEWLINE> <INDENT> q . appendleft ( b [ 7 : ] ) <NEWLINE> <DEDENT> elif b [ 6 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> q . remove ( b [ 7 : ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif len ( b ) > 10 : <NEWLINE> <INDENT> q . popleft ( ) <NEWLINE> <DEDENT> elif len ( b ) > 6 : <NEWLINE> <INDENT> q . pop ( ) <NEWLINE> <DEDENT> <DEDENT> print ( * q ) <NEWLINE>
import math <NEWLINE> a = input ( ) <NEWLINE> b = int ( a ) <NEWLINE> c = 1000 <NEWLINE> if len ( a ) < 4 : <NEWLINE> <INDENT> print ( c - b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a [ - 4 ] != <STRING> : <NEWLINE> <INDENT> b = int ( a [ - 3 : ] ) <NEWLINE> if b == 0 : <NEWLINE> <INDENT> print ( int ( 0 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c - b ) <NEWLINE> <DEDENT> <DEDENT> elif a [ - 3 ] != <STRING> : <NEWLINE> <INDENT> b = int ( a [ - 2 : ] ) <NEWLINE> print ( c - b ) <NEWLINE> <DEDENT> elif a [ - 2 ] != <STRING> : <NEWLINE> <INDENT> b = int ( a [ - 1 : ] ) <NEWLINE> print ( c - b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( 0 ) ) <NEWLINE> <DEDENT> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def judge ( ) : <NEWLINE> <INDENT> l = x if x > 0 else - x <NEWLINE> i = l // d <NEWLINE> r = l % d <NEWLINE> <NL> if ( k - i ) % 2 == 0 : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d - r ) <NEWLINE> <DEDENT> <STRING> <NEWLINE> <NL> <DEDENT> if x == 0 : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> <DEDENT> elif x < 0 : <NEWLINE> <INDENT> if k * d + x > 0 : <NEWLINE> <INDENT> judge ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( k * d + x ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if x - k * d < 0 : <NEWLINE> <INDENT> judge ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x - k * d ) ) <NEWLINE> <DEDENT> <DEDENT>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ [ ] for _ in range ( n ) ] <NEWLINE> c = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> c_as = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c [ i ] , A [ i ] = c_as [ 0 ] , c_as [ 1 : ] <NEWLINE> <NL> <DEDENT> INF = 10 ** 9 <NEWLINE> ans = INF <NEWLINE> <NL> for s in range ( 0 , 1 << n ) : <NEWLINE> <INDENT> skill = [ 0 ] * m <NEWLINE> money = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( s >> i ) % 2 == 0 : continue <NEWLINE> money += c [ i ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> skill [ j ] += A [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> ok = True <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if skill [ j ] < x : <NEWLINE> <INDENT> ok = False <NEWLINE> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> ans = min ( ans , money ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == INF : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> bom = set ( ) <NEWLINE> row = [ 0 ] * H <NEWLINE> col = [ 0 ] * W <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> bom . add ( ( h - 1 , w - 1 ) ) <NEWLINE> row [ h - 1 ] += 1 <NEWLINE> col [ w - 1 ] += 1 <NEWLINE> <NL> <DEDENT> max_row = max ( row ) <NEWLINE> max_col = max ( col ) <NEWLINE> ans = max_row + max_col - 1 <NEWLINE> <NL> p , q = [ ] , [ ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> if row [ i ] == max_row : <NEWLINE> <INDENT> p . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( W ) : <NEWLINE> <INDENT> if col [ j ] == max_col : <NEWLINE> <INDENT> q . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> flag = False <NEWLINE> for i in p : <NEWLINE> <INDENT> for j in q : <NEWLINE> <INDENT> if ( i , j ) not in bom : <NEWLINE> <INDENT> ans += 1 <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def solve ( n , s , lst ) : <NEWLINE> <INDENT> if n == 0 and s == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> return ( 1 ) <NEWLINE> <DEDENT> elif n == 0 or len ( lst ) == 0 or s < lst [ 0 ] : <NEWLINE> <INDENT> return ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( solve ( n - 1 , s - lst [ 0 ] , lst [ 1 : ] ) + solve ( n , s , lst [ 1 : ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n == 0 and s == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( solve ( n , s , list ( range ( 10 ) ) ) ) <NEWLINE> <NL> if n == 0 and s == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ss = set ( [ ] ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> ss . add ( s ) <NEWLINE> <NL> <DEDENT> print ( len ( ss ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> min = N % K <NEWLINE> if min > abs ( min - K ) : <NEWLINE> <INDENT> min = abs ( min - K ) <NEWLINE> <NL> <DEDENT> print ( min ) <NEWLINE>
from itertools import product <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> d = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> for _ in range ( a ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if i + 1 not in d : <NEWLINE> <INDENT> d [ i + 1 ] = [ ] <NEWLINE> <DEDENT> d [ i + 1 ] . append ( ( x , y ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ret = 0 <NEWLINE> for x in product ( ( 0 , 1 ) , repeat = n ) : <NEWLINE> <INDENT> tmp = [ - 1 ] * n <NEWLINE> ok = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == 1 and i + 1 in d : <NEWLINE> <INDENT> for y in d [ i + 1 ] : <NEWLINE> <INDENT> if tmp [ y [ 0 ] - 1 ] == - 1 : <NEWLINE> <INDENT> tmp [ y [ 0 ] - 1 ] = y [ 1 ] <NEWLINE> <DEDENT> elif tmp [ y [ 0 ] - 1 ] != y [ 1 ] : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if not ok : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ok and all ( a == b or b == - 1 for a , b in zip ( x , tmp ) ) : <NEWLINE> <INDENT> ret = max ( ret , sum ( x ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> s = [ 0 for i in range ( n - 1 ) ] <NEWLINE> s [ 0 ] = sum ( a ) - a [ 0 ] <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> s [ i ] = s [ i - 1 ] - a [ i ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> k = a [ i ] * s [ i ] % mod <NEWLINE> ans += k <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> if x >= 1800 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> elif x >= 1600 : <NEWLINE> <INDENT> ans = 2 <NEWLINE> <DEDENT> elif x >= 1400 : <NEWLINE> <INDENT> ans = 3 <NEWLINE> <DEDENT> elif x >= 1200 : <NEWLINE> <INDENT> ans = 4 <NEWLINE> <DEDENT> elif x >= 1000 : <NEWLINE> <INDENT> ans = 5 <NEWLINE> <DEDENT> elif x >= 800 : <NEWLINE> <INDENT> ans = 6 <NEWLINE> <DEDENT> elif x >= 600 : <NEWLINE> <INDENT> ans = 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 8 <NEWLINE> <NL> <DEDENT> print ( str ( int ( ans ) ) ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = input ( ) . split ( ) <NEWLINE> p = [ int ( i ) for i in p ] <NEWLINE> if not ( x in p ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 101 ) : <NEWLINE> <INDENT> if not ( x - i in p ) : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> break <NEWLINE> <DEDENT> elif not ( x + i in p ) : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> high = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> <NL> for x in range ( m ) : <NEWLINE> <INDENT> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( b ) <NEWLINE> <NL> <NL> <DEDENT> loser = [ ] <NEWLINE> <NL> for y in a : <NEWLINE> <INDENT> high1 = high [ y [ 0 ] - 1 ] <NEWLINE> high2 = high [ y [ 1 ] - 1 ] <NEWLINE> if high1 > high2 : <NEWLINE> <INDENT> loser . append ( y [ 1 ] ) <NEWLINE> <DEDENT> elif high1 == high2 : <NEWLINE> <INDENT> loser . append ( y [ 0 ] ) <NEWLINE> loser . append ( y [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loser . append ( y [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> new_loser = list ( set ( loser ) ) <NEWLINE> print ( n - len ( new_loser ) ) <NEWLINE>
from collections import deque <NEWLINE> import math <NEWLINE> <NL> def Next ( ) : return input ( ) <NEWLINE> def NextInt ( ) : return int ( Next ( ) ) <NEWLINE> def NextInts ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def Nexts ( ) : return map ( str , input ( ) . split ( ) ) <NEWLINE> def NextIntList ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def RowInts ( n ) : return [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> a = int ( input ( ) ) <NEWLINE> print ( a ** 3 + a ** 2 + a ) <NEWLINE>
from collections import deque <NEWLINE> s = input ( ) [ : : - 1 ] <NEWLINE> l = [ 0 ] * 2019 <NEWLINE> ten = 1 <NEWLINE> sm = 0 <NEWLINE> cnt = 0 <NEWLINE> l [ 0 ] = 1 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> sm += int ( s [ i ] ) * ten <NEWLINE> sm %= 2019 <NEWLINE> cnt += l [ sm ] <NEWLINE> l [ sm ] += 1 <NEWLINE> ten = ten * 10 % 2019 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> sum = 0 <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> if A < K <= ( A + B ) : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> if ( A + B ) < K <= ( A + B + C ) : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = [ ] <NEWLINE> g = [ ] <NEWLINE> b = [ ] <NEWLINE> rdict = { } <NEWLINE> gdict = { } <NEWLINE> bdict = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> rdict [ 2 * i ] = 2 * i <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> g . append ( i ) <NEWLINE> gdict [ 2 * i ] = 2 * i <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> bdict [ 2 * i ] = 2 * i <NEWLINE> <DEDENT> <DEDENT> ans = len ( r ) * len ( g ) * len ( b ) <NEWLINE> for i in r : <NEWLINE> <INDENT> for j in g : <NEWLINE> <INDENT> if i + j in bdict : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in g : <NEWLINE> <INDENT> for j in b : <NEWLINE> <INDENT> if i + j in rdict : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in b : <NEWLINE> <INDENT> for j in r : <NEWLINE> <INDENT> if i + j in gdict : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ( ans == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
t = list ( input ( ) ) <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <NL> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> if len ( t ) == 1 : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> if i == 0 : <NEWLINE> <INDENT> if t [ 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if i == len ( t ) - 1 : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> a = <STRING> <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> a += t [ i ] <NEWLINE> <NL> <DEDENT> print ( a ) <NEWLINE>
import math <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> blue = math . factorial ( K - 1 ) // ( math . factorial ( i - 1 ) * math . factorial ( K - i ) ) <NEWLINE> if N - K + 1 - i < 0 : <NEWLINE> <INDENT> red = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> red = math . factorial ( N - K + 1 ) // ( math . factorial ( i ) * math . factorial ( N - K + 1 - i ) ) <NEWLINE> <DEDENT> ans = blue * red <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> print ( int ( ans ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( range ( N + 1 ) ) <NEWLINE> for n in range ( N + 1 ) : <NEWLINE> <INDENT> if n % 3 == 0 or n % 5 == 0 : <NEWLINE> <INDENT> A [ n ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> l . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( l ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> cnt = [ 0 ] * ( 10 ** 5 + 2 ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> cnt [ i + 1 ] += 1 <NEWLINE> cnt [ i + 2 ] += 1 <NEWLINE> <NL> <DEDENT> print ( max ( cnt ) ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> n_a = a // x <NEWLINE> n_b = b // x <NEWLINE> if a % x == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> ans += n_b - n_a <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 for i in range ( 10 ** 5 + 1 ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] > 10 ** 5 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ a [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 10 ** 5 + 1 ) : <NEWLINE> <INDENT> if 0 < l [ i ] < i : <NEWLINE> <INDENT> ans += l [ i ] <NEWLINE> <DEDENT> if i < l [ i ] : <NEWLINE> <INDENT> t = l [ i ] - i <NEWLINE> ans += t <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 1 <NEWLINE> c = 0 <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> for x in A : <NEWLINE> <INDENT> ans = ans * x <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> c = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif ans > 10 ** ( 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> c = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> from heapq import heappop , heappush <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> EPS = 1e-8 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def mapline ( t = int ) : <NEWLINE> <INDENT> return map ( t , sysread ( ) . split ( ) ) <NEWLINE> <DEDENT> def mapread ( t = int ) : <NEWLINE> <INDENT> return map ( t , read ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> N , * A = mapread ( ) <NEWLINE> ans = 1 <NEWLINE> current = [ 0 , 0 , 0 ] <NEWLINE> for a in A : <NEWLINE> <INDENT> transition = 0 <NEWLINE> cache = 1 <NEWLINE> for i , c in enumerate ( current ) : <NEWLINE> <INDENT> if c == a : <NEWLINE> <INDENT> transition += 1 <NEWLINE> cache = i <NEWLINE> <DEDENT> <DEDENT> ans *= transition <NEWLINE> ans %= mod <NEWLINE> current [ cache ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . reverse ( ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( a [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( a [ n - 1 ] ) <NEWLINE>
import heapq <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( lambda x : x * ( - 1 ) , a ) ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> heapq . heappush ( a , ( ( heapq . heappop ( a ) * ( - 1 ) ) // 2 ) * ( - 1 ) ) <NEWLINE> <DEDENT> print ( abs ( sum ( a ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = [ 0 ] * ( N + 1 ) <NEWLINE> L [ 0 ] = 2 <NEWLINE> L [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> L [ i ] = L [ i - 1 ] + L [ i - 2 ] <NEWLINE> <NL> <DEDENT> print ( L [ N ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> flag = True <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in A : <NEWLINE> <INDENT> ans *= j <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> if A > K : <NEWLINE> <INDENT> ans += 1 * K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 * A <NEWLINE> K = K - A <NEWLINE> if B > K : <NEWLINE> <INDENT> ans += 0 * K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 0 * B <NEWLINE> K = K - B <NEWLINE> if C > K : <NEWLINE> <INDENT> ans += - 1 * K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += - 1 * C <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
h , w = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> <NL> flag = True <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> sub_flag = False <NEWLINE> if i > 0 and s [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> sub_flag = True <NEWLINE> <DEDENT> if j > 0 and s [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> sub_flag = True <NEWLINE> <DEDENT> if i < h - 1 and s [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> sub_flag = True <NEWLINE> <DEDENT> if j < w - 1 and s [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> sub_flag = True <NEWLINE> <NL> <DEDENT> if sub_flag : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> import numpy as np <NEWLINE> C = np . array ( [ 0 ] * n ) <NEWLINE> A = np . array ( [ [ 0 ] * m ] * n ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C [ i ] += l [ 0 ] <NEWLINE> A [ i ] += np . array ( l [ 1 : ] ) <NEWLINE> <NL> <DEDENT> def L ( i ) : <NEWLINE> <INDENT> X = [ ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> X . append ( i % 2 ) <NEWLINE> i = i // 2 <NEWLINE> <DEDENT> X . reverse ( ) <NEWLINE> return np . array ( X ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for k in range ( 2 ** n ) : <NEWLINE> <INDENT> D = np . dot ( L ( k ) , A ) <NEWLINE> if min ( D ) >= x : <NEWLINE> <INDENT> ans . append ( np . dot ( C , L ( k ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == [ ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> N , K = MAP ( ) <NEWLINE> S = [ int ( s ) for s in input ( ) ] + [ 1 ] <NEWLINE> <NL> r = - 1 <NEWLINE> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> used = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for l in range ( N ) : <NEWLINE> <INDENT> if S [ l ] + S [ l - 1 ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> while r < N and used [ r ] - used [ l - 1 ] <= K : <NEWLINE> <INDENT> r += 1 <NEWLINE> if S [ r - 1 ] == 1 and S [ r ] == 0 : <NEWLINE> <INDENT> used [ r ] = used [ r - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> used [ r ] = used [ r - 1 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , r - l ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> S %= 3600 <NEWLINE> m = S // 60 <NEWLINE> S %= 60 <NEWLINE> s = S <NEWLINE> print ( h , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( m , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( s , end = <STRING> ) <NEWLINE> print ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> s = input ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> rs = 0 <NEWLINE> gs = 0 <NEWLINE> bs = 0 <NEWLINE> for x in s : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> rs += 1 <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> gs += 1 <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> bs += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> i = 0 <NEWLINE> d = 1 <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> d = 1 <NEWLINE> while ( i + 2 * d < n ) : <NEWLINE> <INDENT> ok = s [ i ] != s [ i + d ] and s [ i + d ] != s [ i + 2 * d ] and s [ i ] != s [ i + 2 * d ] <NEWLINE> if ok : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> d += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( rs * gs * bs - count ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> <COMMENT> <NL> adj = [ [ ] for j in range ( N ) ] <NEWLINE> for edge in edges : <NEWLINE> <INDENT> x , y = edge <NEWLINE> adj [ x - 1 ] . append ( y ) <NEWLINE> adj [ y - 1 ] . append ( x ) <NEWLINE> <NL> <DEDENT> color = [ 0 ] * N <NEWLINE> <NL> <COMMENT> <NL> def dfs ( node , c ) : <NEWLINE> <INDENT> color [ node - 1 ] = c <NEWLINE> for i in adj [ node - 1 ] : <NEWLINE> <INDENT> if c == color [ i - 1 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if color [ i - 1 ] == 0 and not dfs ( i , - c ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if dfs ( 1 , 1 ) : <NEWLINE> <INDENT> black = color . count ( 1 ) <NEWLINE> white = N - black <NEWLINE> print ( black * white - M ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N * ( N - 1 ) // 2 - M ) <NEWLINE> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> temp = math . gcd ( i , j ) <NEWLINE> for m in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum = sum + math . gcd ( m , temp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = [ ] <NEWLINE> for i in [ 0 ] * m : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> if h [ a ] == h [ b ] : <NEWLINE> <INDENT> k += [ a ] + [ b ] <NEWLINE> <DEDENT> if h [ a ] > h [ b ] : <NEWLINE> <INDENT> k += [ b ] <NEWLINE> <DEDENT> if h [ a ] < h [ b ] : <NEWLINE> <INDENT> k += [ a ] <NEWLINE> <DEDENT> <DEDENT> print ( n - len ( set ( k ) ) ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> HW = [ 0 ] * H <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> HW [ i ] = str ( input ( ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> visited = [ [ 0 ] * W for i in range ( H ) ] <NEWLINE> def bfs ( x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> if visited [ x ] [ y ] == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> visited [ x ] [ y ] = 1 <NEWLINE> <NL> if HW [ x ] [ y ] == <STRING> : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> queue = [ [ 0 , 1 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ - 1 , 0 ] ] <NEWLINE> tt = 0 <NEWLINE> for i , j in queue : <NEWLINE> <INDENT> if ( 0 <= x + i < H ) and ( 0 <= y + j < W ) : <NEWLINE> <INDENT> if HW [ x + i ] [ y + j ] == <STRING> : <NEWLINE> <INDENT> tt = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if tt == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <COMMENT> <NL> <INDENT> st = bfs ( i , j ) <NEWLINE> <COMMENT> <NL> if st == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> N , Q = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> connection = { i : set ( ) for i in range ( 1 , N + 1 ) } <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> connection [ a ] . add ( b ) <NEWLINE> connection [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> point = { i : 0 for i in range ( 1 , N + 1 ) } <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> point [ p ] += x <NEWLINE> <NL> <DEDENT> def DFS ( now , prev = - 1 ) : <NEWLINE> <INDENT> for next in connection [ now ] : <NEWLINE> <COMMENT> <NL> <INDENT> if next == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> point [ next ] += point [ now ] <NEWLINE> DFS ( next , now ) <NEWLINE> <NL> <DEDENT> <DEDENT> DFS ( 1 ) <NEWLINE> print ( * point . values ( ) ) <NEWLINE>
def isprime ( x ) : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if x < 2 or x & 1 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return pow ( 2 , x - 1 , x ) == 1 <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if isprime ( a ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> L = [ 0 ] <NEWLINE> R = [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> L . append ( cnt ) <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> s = s [ : : - 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> R . append ( cnt ) <NEWLINE> <NL> <DEDENT> R = R [ : : - 1 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> ans += max ( R [ i ] , L [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = n , 1 <NEWLINE> V = [ False for d in range ( 1 , n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> d = min ( a - b , n - ( a - b ) ) <NEWLINE> if 2 * d == n or V [ d ] : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> print ( a , b ) <NEWLINE> d = min ( a - b , n - ( a - b ) ) <NEWLINE> V [ d ] = True <NEWLINE> a -= 1 <NEWLINE> b += 1 <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> plus = [ ] <NEWLINE> zero = [ ] <NEWLINE> minus = [ ] <NEWLINE> ans = 1 <NEWLINE> <NL> for k in range ( N ) : <NEWLINE> <INDENT> if A [ k ] > 0 : <NEWLINE> <INDENT> plus . append ( A [ k ] ) <NEWLINE> <DEDENT> elif A [ k ] < 0 : <NEWLINE> <INDENT> minus . append ( - 1 * A [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> zero . append ( A [ k ] ) <NEWLINE> <DEDENT> <DEDENT> plus . sort ( reverse = True ) <NEWLINE> minus . sort ( reverse = True ) <NEWLINE> lp = len ( plus ) <NEWLINE> lm = len ( minus ) <NEWLINE> <NL> if len ( zero ) + K > N : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif lp == 0 : <NEWLINE> <INDENT> if K % 2 == 1 : <NEWLINE> <INDENT> if len ( zero ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( K ) : <NEWLINE> <INDENT> ans = ans * ( - 1 ) * minus [ - k - 1 ] % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( K ) : <NEWLINE> <INDENT> ans = ans * ( - 1 ) * minus [ k ] % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> elif lm == 0 : <NEWLINE> <INDENT> for k in range ( K ) : <NEWLINE> <INDENT> ans = ans * plus [ k ] % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> p = 0 <NEWLINE> m = 0 <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> if plus [ p ] >= minus [ m ] : <NEWLINE> <INDENT> p += 1 <NEWLINE> if p == lp : <NEWLINE> <INDENT> m = K - p <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> m += 1 <NEWLINE> if m == lm : <NEWLINE> <INDENT> p = K - m <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( mp , mm , plus , minus , mod , K ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for k in range ( mp ) : <NEWLINE> <INDENT> ans = ans * plus [ k ] % mod <NEWLINE> <DEDENT> for k in range ( mm ) : <NEWLINE> <INDENT> ans = ans * ( - 1 ) * minus [ k ] % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if m % 2 == 0 : <NEWLINE> <INDENT> main ( p , m , plus , minus , mod , K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if p == lp : <NEWLINE> <INDENT> if m != lm : <NEWLINE> <INDENT> main ( p - 1 , m + 1 , plus , minus , mod , K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( zero ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> main ( p , m , plus , minus , mod , K ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif m == lm : <NEWLINE> <INDENT> main ( p + 1 , m - 1 , plus , minus , mod , K ) <NEWLINE> <DEDENT> elif p == 0 : <NEWLINE> <INDENT> main ( p + 1 , m - 1 , plus , minus , mod , K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if plus [ p ] * plus [ p - 1 ] > minus [ m - 1 ] * minus [ m ] : <NEWLINE> <INDENT> main ( p + 1 , m - 1 , plus , minus , mod , K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> main ( p - 1 , m + 1 , plus , minus , mod , K ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from math import sqrt <NEWLINE> <NL> def f ( n ) : <NEWLINE> <INDENT> if n == 2 : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> for i in range ( 3 , round ( sqrt ( n ) + 1 ) , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def g ( n ) : <NEWLINE> <INDENT> d = { } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> i = int ( input ( ) ) <NEWLINE> if not ( i in d ) : <NEWLINE> <INDENT> d [ i ] = f ( i ) <NEWLINE> <DEDENT> yield d [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( sum ( g ( n ) ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> for i in range ( 3 , x + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
<COMMENT> <NL> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> seisulist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> numlist = [ i for i in range ( 0 , 102 ) if i not in seisulist ] <NEWLINE> xretu = [ x ] * len ( numlist ) <NEWLINE> hikizan = [ abs ( s - t ) for ( s , t ) in zip ( numlist , xretu ) ] <NEWLINE> sa = min ( hikizan ) <NEWLINE> if x - sa not in seisulist : <NEWLINE> <INDENT> print ( x - sa ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x + sa ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( a ) <NEWLINE> ans = 1 <NEWLINE> c = 10 ** 18 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> for b in a : <NEWLINE> <INDENT> ans *= b <NEWLINE> if ( ans > c ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> C = [ ] <NEWLINE> if len ( S ) == len ( T ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if S [ j ] == T [ j ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> C . append ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> s = S [ i : len ( T ) + i ] <NEWLINE> c = 0 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if s [ j ] == T [ j ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> C . append ( c ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( T ) - max ( C ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <COMMENT> <NEWLINE> <INDENT> if i % 3 == 0 or i % 10 == 3 or <STRING> in str ( i ) : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> wa = 0 <NEWLINE> aa = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> aa = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> wa += math . gcd ( aa , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( wa ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> x = a <NEWLINE> a = b <NEWLINE> b = x <NEWLINE> <DEDENT> if b > c : <NEWLINE> <INDENT> x = b <NEWLINE> b = c <NEWLINE> c = x <NEWLINE> if a > b : <NEWLINE> <INDENT> x = a <NEWLINE> a = b <NEWLINE> b = x <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a , b , c , sep = <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL>
import bisect <NEWLINE> from collections import Counter <NEWLINE> import sys <NEWLINE> <NL> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> <NL> n , m = LI ( ) <NEWLINE> a = LI ( ) <NEWLINE> a = sorted ( a ) [ : : - 1 ] <NEWLINE> bc = LIR ( m ) <NEWLINE> bc = sorted ( bc , key = lambda x : x [ 1 ] ) [ : : - 1 ] <NEWLINE> all_c = [ ] <NEWLINE> for bi , ci in bc : <NEWLINE> <INDENT> all_c += [ ci ] * bi <NEWLINE> if len ( all_c ) >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if len ( all_c ) < n : <NEWLINE> <INDENT> all_c += [ 0 ] * ( n - len ( all_c ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> a_i = 0 <NEWLINE> c_i = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> if a [ a_i ] > all_c [ c_i ] : <NEWLINE> <INDENT> ans += a [ a_i ] <NEWLINE> a_i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += all_c [ c_i ] <NEWLINE> c_i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> ans = - 1 <NEWLINE> num = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> num = ( 10 * num + 7 ) % K <NEWLINE> if num == 0 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import itertools <NEWLINE> <NL> K = int ( input ( ) ) + 1 <NEWLINE> L = list ( itertools . combinations_with_replacement ( list ( range ( 1 , K ) ) , 3 ) ) <NEWLINE> a = 1 <NEWLINE> A = 0 <NEWLINE> for i in L : <NEWLINE> <INDENT> if len ( set ( i ) ) == 3 : <NEWLINE> <INDENT> a = 6 <NEWLINE> <DEDENT> elif len ( set ( i ) ) == 2 : <NEWLINE> <INDENT> a = 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> A += math . gcd ( math . gcd ( i [ 0 ] , i [ 1 ] ) , i [ 2 ] ) * a <NEWLINE> <DEDENT> print ( A ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> def solve1 ( ) : <NEWLINE> <INDENT> return [ ( i + 2 , N - i ) for i in range ( M ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def solve2 ( ) : <NEWLINE> <INDENT> t = ( N - 2 ) // 4 <NEWLINE> l = [ ( i + 2 , N - i ) for i in range ( t ) ] <NEWLINE> n = ( N - 2 ) // 2 - t <NEWLINE> l = l + [ ( N // 2 + 1 + i , N // 2 - i ) for i in range ( n ) ] <NEWLINE> return l [ : M ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> l = solve1 ( ) if N % 2 else solve2 ( ) <NEWLINE> for ans in l : <NEWLINE> <INDENT> print ( * ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <NL> if b <= n : <NEWLINE> <INDENT> beta = ( b - 1 ) / b - int ( ( b - 1 ) / b ) <NEWLINE> <NL> <DEDENT> elif b > n : <NEWLINE> <INDENT> beta = n / b - int ( n / b ) <NEWLINE> <NL> <DEDENT> ans = int ( a * beta ) <NEWLINE> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , M = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> PY = np . array ( [ list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) for _ in range ( M ) ] ) <NEWLINE> <NL> l = [ [ ] for n in range ( N ) ] <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> l [ PY [ m , 0 ] - 1 ] . append ( PY [ m , 1 ] ) <NEWLINE> <NL> <DEDENT> dp = { } <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> if l [ n ] : <NEWLINE> <INDENT> l [ n ] . sort ( ) <NEWLINE> for i in range ( len ( l [ n ] ) ) : <NEWLINE> <INDENT> city = <STRING> + str ( n + 1 ) <NEWLINE> num = <STRING> + str ( i + 1 ) <NEWLINE> dp [ ( n , l [ n ] [ i ] - 1 ) ] = str ( city [ - 6 : ] + num [ - 6 : ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for m in range ( M ) : <NEWLINE> <INDENT> print ( dp [ ( PY [ m , 0 ] - 1 , PY [ m , 1 ] - 1 ) ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> i = k <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> while i < n : <NEWLINE> <INDENT> old = a [ i - k ] <NEWLINE> now = a [ i ] <NEWLINE> print ( <STRING> if now > old else <STRING> ) <NEWLINE> i += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
from sys import stdin <NEWLINE> s = stdin . readline ( ) . rstrip ( ) <NEWLINE> n = len ( s ) <NEWLINE> dic = { } <NEWLINE> dic [ 0 ] = 1 <NEWLINE> now = 0 <NEWLINE> mul = 1 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> now = ( now + ( 10 * mul ) * int ( s [ i ] ) ) % 2019 <NEWLINE> if now in dic : <NEWLINE> <INDENT> dic [ now ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ now ] = 1 <NEWLINE> <DEDENT> mul *= 10 <NEWLINE> mul %= 2019 <NEWLINE> <DEDENT> print ( sum ( dic [ i ] * ( dic [ i ] - 1 ) // 2 for i in dic ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> if a [ n - 1 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def call2 ( n ) : <NEWLINE> <INDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = i <NEWLINE> if i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while x : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> x = x // 10 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> call2 ( int ( input ( ) ) ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xn = list ( range ( 0 , 102 ) ) <NEWLINE> answer = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> xn . remove ( n [ i ] ) <NEWLINE> <DEDENT> mindis = 100 <NEWLINE> for i in range ( len ( xn ) ) : <NEWLINE> <INDENT> dis = abs ( X - xn [ i ] ) <NEWLINE> if dis < mindis : <NEWLINE> <INDENT> mindis = dis <NEWLINE> answer = xn [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
<COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> e_p = [ ] <NEWLINE> for i in range ( len ( P ) ) : <NEWLINE> <INDENT> e_p . append ( ( P [ i ] + 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> s = [ 0 ] * ( len ( P ) + 1 ) <NEWLINE> for i in range ( len ( P ) ) : <NEWLINE> <INDENT> s [ i + 1 ] = s [ i ] + e_p [ i ] <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> res = max ( res , s [ i + k ] - s [ i ] ) <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
INF = 10000000000 <NEWLINE> dx = [ 0 , 0 , 1 , - 1 ] <NEWLINE> dy = [ - 1 , 1 , 0 , 0 ] <NEWLINE> <NL> def dfs ( x , y , m ) : <NEWLINE> <INDENT> if y > N : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if mem [ x ] [ y ] [ m ] != INF : <NEWLINE> <INDENT> return mem [ x ] [ y ] [ m ] <NEWLINE> <DEDENT> n = INF <NEWLINE> for j in range ( 2 if m > 0 else 1 ) : <NEWLINE> <INDENT> for i , s in enumerate ( st [ y + 1 + j ] ) : <NEWLINE> <INDENT> srip = max ( 0 , st [ y ] [ x ] [ 1 ] + s [ 1 ] ) <NEWLINE> l = abs ( st [ y ] [ x ] [ 0 ] - s [ 0 ] ) <NEWLINE> n = min ( dfs ( i , y + 1 + j , m - j ) + srip * l , n ) <NEWLINE> <DEDENT> <DEDENT> mem [ x ] [ y ] [ m ] = n <NEWLINE> return mem [ x ] [ y ] [ m ] <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> N , M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> st = [ [ [ - INF , - INF ] ] for i in range ( N + 3 ) ] <NEWLINE> for s in st [ 1 : - 2 ] : <NEWLINE> <INDENT> v = list ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> del s [ 0 ] <NEWLINE> for i in range ( 1 , len ( v ) , 2 ) : <NEWLINE> <INDENT> s . append ( [ v [ i ] , v [ i + 1 ] ] ) <NEWLINE> <DEDENT> <DEDENT> mem = [ [ [ INF for i in range ( M + 1 ) ] for j in range ( N + 1 ) ] for k in range ( N + 4 ) ] <NEWLINE> print ( dfs ( 0 , 0 , M ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> NN , K = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> p = 10 ** 9 + 7 <NEWLINE> seq = [ i for i in range ( NN + 1 ) ] <COMMENT> <NEWLINE> ans = [ 0 ] * ( NN + 1 ) <NEWLINE> st = [ 0 ] * ( NN + 1 ) <NEWLINE> fi = [ 0 ] * ( NN + 1 ) <NEWLINE> st [ 0 ] = sum ( seq [ : K ] ) <NEWLINE> fi [ 0 ] = sum ( seq [ - K : ] ) <NEWLINE> ans [ 0 ] = fi [ 0 ] - st [ 0 ] + 1 <NEWLINE> if NN == 1 and K == 1 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( NN - K + 1 ) : <NEWLINE> <INDENT> st [ i + 1 ] = st [ i ] + seq [ K + i ] <NEWLINE> fi [ i + 1 ] = fi [ i ] + seq [ - K - i - 1 ] <NEWLINE> ans [ i + 1 ] = ( fi [ i + 1 ] - st [ i + 1 ] + 1 ) <NEWLINE> <DEDENT> print ( sum ( ans ) % p ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> res = 1 <NEWLINE> zero = 0 <NEWLINE> for e in range ( n ) : <NEWLINE> <INDENT> if int ( a [ e ] ) == 0 : <NEWLINE> <INDENT> zero = 1 <NEWLINE> <DEDENT> <DEDENT> for e in range ( n ) : <NEWLINE> <INDENT> res *= int ( a [ e ] ) <NEWLINE> if res > 1000000000000000000 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if zero == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif res > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT>
array = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> array . append ( n . split ( ) ) <NEWLINE> <DEDENT> for i in range ( len ( array ) ) : <NEWLINE> <INDENT> for i2 in range ( int ( array [ i ] [ 0 ] ) ) : <NEWLINE> <INDENT> for i3 in range ( int ( array [ i ] [ 1 ] ) ) : <NEWLINE> <INDENT> if i3 == int ( array [ i ] [ 1 ] ) - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( N + 1 ) <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> fn = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if fn > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ fn ] = ans [ fn ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ n ] ) <NEWLINE> <DEDENT>
def calc_k_constP ( P ) : <NEWLINE> <INDENT> tmp_total_w = 0 <NEWLINE> tmp_k = 1 <NEWLINE> for w in w_s : <NEWLINE> <INDENT> tmp_total_w += w <NEWLINE> if tmp_total_w > P : <NEWLINE> <INDENT> tmp_k += 1 <NEWLINE> tmp_total_w = w <NEWLINE> <NL> <DEDENT> <DEDENT> return tmp_k <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> w_s = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> max_w = max ( w_s ) <NEWLINE> <NL> left , right = max_w , 10000 * n <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = ( right + left ) // 2 <NEWLINE> tmp_k = calc_k_constP ( mid ) <NEWLINE> if tmp_k <= k : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( left ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if A [ k + i ] > A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
S = int ( input ( ) ) <NEWLINE> a = [ 0 ] * ( 2000 + 1 ) <NEWLINE> a [ 3 ] = 1 <NEWLINE> for i in range ( 4 , S + 1 ) : <NEWLINE> <INDENT> a [ i ] = a [ i - 3 ] + a [ i - 1 ] <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> print ( a [ S ] % mod ) <NEWLINE>
from scipy . special import comb <NEWLINE> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> red = N - K <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = comb ( N - K + 1 , i , exact = True ) * comb ( K - 1 , i - 1 , exact = True ) % mod <NEWLINE> print ( tmp ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> wa = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> wa += gcd ( gcd ( a , b ) , c ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( wa ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> a = ( x + y + z ) ** 2 - ( x * y + y * z + z * x ) <NEWLINE> if a <= n : <NEWLINE> <INDENT> ans [ a - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
class Union : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . root ( self . parents [ x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . root ( x ) <NEWLINE> y = self . root ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> uni = Union ( n ) <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> uni . unite ( a , b ) <NEWLINE> <DEDENT> print ( - min ( uni . parents ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <DEDENT> Ans = [ ] <NEWLINE> s = 0 <NEWLINE> for i in range ( 11 ) : <NEWLINE> <INDENT> s += 26 ** i <NEWLINE> S = s + 26 ** ( i + 1 ) <NEWLINE> if s <= N < S : <NEWLINE> <INDENT> I = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( I + 1 ) : <NEWLINE> <INDENT> N -= 26 ** i <NEWLINE> <DEDENT> while I >= 0 : <NEWLINE> <INDENT> for i in range ( 0 , 26 ) : <NEWLINE> <INDENT> n = N - 26 ** I * i <NEWLINE> if n < 26 ** I : <NEWLINE> <INDENT> Ans . append ( l [ i ] ) <NEWLINE> N = n <NEWLINE> I -= 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( Ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> mod = 10 ** 18 <NEWLINE> for i in A : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif ans != - 1 : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > mod : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ ] <NEWLINE> a = [ ] <NEWLINE> n_1 = [ i for i in range ( 1 , n + 1 ) ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d . append ( int ( input ( ) ) ) <NEWLINE> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> a_1 = list ( itertools . chain . from_iterable ( a ) ) <NEWLINE> c = list ( set ( n_1 ) - set ( a_1 ) ) <NEWLINE> print ( len ( c ) ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( a , K + 1 ) : <NEWLINE> <INDENT> for c in range ( b , K + 1 ) : <NEWLINE> <INDENT> s = math . gcd ( a , b ) <NEWLINE> t = math . gcd ( s , c ) <NEWLINE> if a == c : <NEWLINE> <INDENT> ans += t <NEWLINE> <DEDENT> elif ( a == b or b == c ) and a != c : <NEWLINE> <INDENT> ans += 3 * t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 6 * t <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> x = 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> x += int ( i ) <NEWLINE> <DEDENT> print ( <STRING> if x % 9 == 0 else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> di = [ ] <NEWLINE> ans = 0 <NEWLINE> now = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ls [ i ] == i + 1 : <NEWLINE> <INDENT> now += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if now != 0 : <NEWLINE> <INDENT> di . append ( now ) <NEWLINE> now = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if now != 0 : <NEWLINE> <INDENT> di . append ( now ) <NEWLINE> <DEDENT> for j in di : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> ans += j // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ( j // 2 ) + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for p in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for q in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gcd1 = gcd ( i , p ) <NEWLINE> <NL> cnt += gcd ( gcd1 , q ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL>
D = int ( input ( ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> <NL> res = 0 <NEWLINE> last = [ 0 for _ in range ( 26 ) ] <NEWLINE> <NL> for d in range ( D ) : <NEWLINE> <INDENT> maxtmp = - 10 ** 18 <NEWLINE> contest = None <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> tmp = res <NEWLINE> lasttmp = last [ : ] <NEWLINE> tmp += S [ d ] [ i ] <NEWLINE> lasttmp [ i ] = d + 1 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> tmp -= C [ j ] * ( ( d + 1 ) - lasttmp [ j ] ) <NEWLINE> <DEDENT> if maxtmp <= tmp : <NEWLINE> <INDENT> maxtmp = tmp <NEWLINE> contest = i <NEWLINE> <DEDENT> <DEDENT> res += S [ d ] [ contest ] <NEWLINE> last [ contest ] = d + 1 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> res -= C [ j ] * ( ( d + 1 ) - last [ j ] ) <NEWLINE> <DEDENT> print ( contest + 1 ) <NEWLINE> <DEDENT>
N , M , X = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ca = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> l . append ( ca ) <NEWLINE> <NL> <DEDENT> A = [ 0 for i in range ( M + 2 ) ] <NEWLINE> flag = 1 <NEWLINE> ans = 10 ** 10 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> cost = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if i >> j & 1 : <NEWLINE> <INDENT> now = l [ N - j - 1 ] <NEWLINE> cost += now [ 0 ] <NEWLINE> for s in range ( M ) : <NEWLINE> <INDENT> A [ s ] += now [ s + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for t in range ( M ) : <NEWLINE> <INDENT> if X <= A [ t ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> ans = min ( ans , cost ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> A = [ 0 for v in range ( M + 2 ) ] <NEWLINE> <NL> <DEDENT> if cnt == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT>
import itertools <NEWLINE> import functools <NEWLINE> import math <NEWLINE> from collections import Counter <NEWLINE> from itertools import combinations <NEWLINE> import re <NEWLINE> <NL> def main_sum ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( len ( P ) ) : <NEWLINE> <INDENT> P [ i ] = ( P [ i ] + 1 ) / 2 <NEWLINE> <NL> <DEDENT> max = sum ( P [ : K ] ) <NEWLINE> add = max <NEWLINE> for i in range ( len ( P ) - K ) : <NEWLINE> <INDENT> add = add + P [ i + K ] - P [ i ] <NEWLINE> if add > max : <NEWLINE> <INDENT> max = add <NEWLINE> <DEDENT> <DEDENT> print ( max ) <NEWLINE> <NL> <NL> <DEDENT> main_sum ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * s ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def floor ( m ) : <NEWLINE> <INDENT> return int ( m ) <NEWLINE> <NL> <DEDENT> if n >= b : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> c = floor ( a * x / b ) - a * floor ( x / b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = n <NEWLINE> c = floor ( a * x / b ) - a * floor ( x / b ) <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE>
import sys ; <NEWLINE> <NL> def init ( n_ ) : <NEWLINE> <INDENT> length = 1 ; <NEWLINE> while ( length < n_ ) : <NEWLINE> <INDENT> length *= 2 <NEWLINE> <DEDENT> element = [ 0 ] * ( 2 * length - 1 ) <NEWLINE> for i in range ( 2 * length - 1 ) : <NEWLINE> <INDENT> element [ i ] = initial <NEWLINE> <DEDENT> return element , length <NEWLINE> <NL> <DEDENT> def update ( k , a , element ) : <NEWLINE> <INDENT> k += n - 1 <NEWLINE> element [ k ] = a <NEWLINE> while ( k > 0 ) : <NEWLINE> <INDENT> k = ( int ) ( ( k - 1 ) / 2 ) <NEWLINE> element [ k ] = min ( element [ k * 2 + 1 ] , element [ k * 2 + 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def findmin ( a , b ) : <NEWLINE> <INDENT> return findquery ( a , b + 1 , 0 , 0 , n ) <NEWLINE> <NL> <DEDENT> def findquery ( a , b , k , l , r ) : <NEWLINE> <INDENT> if ( r <= a or b <= l ) : <NEWLINE> <INDENT> return initial <NEWLINE> <DEDENT> if ( a <= l and r <= b ) : <NEWLINE> <INDENT> return element [ k ] <NEWLINE> <NL> <DEDENT> vl = findquery ( a , b , k * 2 + 1 , l , ( int ) ( ( l + r ) / 2 + 0.5 ) ) <NEWLINE> vr = findquery ( a , b , k * 2 + 2 , ( int ) ( ( l + r ) / 2 ) , r ) <NEWLINE> return min ( vl , vr ) <NEWLINE> <NL> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) ; <NEWLINE> <NL> initial = pow ( 2 , 31 ) - 1 <NEWLINE> element , n = init ( n ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> query , key , value = map ( int , input ( ) . split ( ) ) ; <NEWLINE> if ( query == 0 ) : <NEWLINE> <INDENT> update ( key , value , element ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( findmin ( key , value ) ) <NEWLINE> <DEDENT> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( b - 1 , n ) <NEWLINE> print ( a * x // b - a * ( x // b ) ) <NEWLINE>
def f ( n ) : <NEWLINE> <INDENT> if n == 0 : return <STRING> <NEWLINE> n -= 1 <NEWLINE> return ( f ( n // 26 ) + chr ( ord ( <STRING> ) + n % 26 ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> from builtins import int , map , list , print <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> input = ( lambda : ( sys . stdin . readline ( ) ) . rstrip ( ) ) <NEWLINE> input_list = ( lambda : input ( ) . split ( ) ) <NEWLINE> input_number = ( lambda : int ( input ( ) ) ) <NEWLINE> input_number_list = ( lambda : list ( map ( int , input_list ( ) ) ) ) <NEWLINE> <NL> n = input_number ( ) <NEWLINE> ans = f ( n ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> sl = list ( S ( ) ) <NEWLINE> ans = 0 <NEWLINE> c = 0 <NEWLINE> for i , item in enumerate ( sl ) : <NEWLINE> <INDENT> if item == <STRING> : <NEWLINE> <INDENT> ans += c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> from bisect import bisect_left <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> acc_A = [ 0 ] + list ( accumulate ( A ) ) <NEWLINE> acc_B = [ 0 ] + list ( accumulate ( B ) ) <NEWLINE> res = 0 <NEWLINE> for i , a in enumerate ( acc_A ) : <NEWLINE> <INDENT> if a > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> idx = bisect_left ( acc_B , K - a ) <NEWLINE> idx = min ( idx , M ) <NEWLINE> if acc_B [ idx ] > K - a : <NEWLINE> <INDENT> idx -= 1 <NEWLINE> <DEDENT> res = max ( res , i + idx ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> employees = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> subordinates = [ 0 ] * N <NEWLINE> <NL> for employee in employees : <NEWLINE> <INDENT> subordinates [ employee - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( subordinates [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> % ( r ** 2 * math . pi , 2 * r * math . pi ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> aa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ll = { } <NEWLINE> c = 0 <NEWLINE> for i , a in enumerate ( aa , 1 ) : <NEWLINE> <INDENT> x = i - a <NEWLINE> if x in ll : <NEWLINE> <INDENT> c += len ( ll [ x ] ) <NEWLINE> <DEDENT> y = i + a <NEWLINE> if y in ll : <NEWLINE> <INDENT> ll [ y ] . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ll [ y ] = [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) . rstrip ( <STRING> ) ) <NEWLINE> S = list ( input ( ) . rstrip ( <STRING> ) ) <NEWLINE> score = [ S . count ( <STRING> ) , S . count ( <STRING> ) ] <NEWLINE> sta = <STRING> <NEWLINE> ws = 0 <NEWLINE> rs = S . count ( <STRING> ) <NEWLINE> sto = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] != sta : <NEWLINE> <INDENT> if sta == <STRING> : <NEWLINE> <INDENT> ws += sto <NEWLINE> sto = 1 <NEWLINE> score . append ( max ( rs , ws ) ) <NEWLINE> sta = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rs -= sto <NEWLINE> sto = 1 <NEWLINE> score . append ( max ( rs , ws ) ) <NEWLINE> sta = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> sto += 1 <NEWLINE> <DEDENT> <DEDENT> print ( min ( score ) ) <NEWLINE>
import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if a * a * b == x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> mid = a ** 2 * b / 2 <NEWLINE> c = x / ( a ** 2 ) <NEWLINE> if mid == x : <NEWLINE> <INDENT> ans = 90 - math . degrees ( math . atan ( a / b ) ) <NEWLINE> <DEDENT> elif mid < x : <NEWLINE> <INDENT> d = 2 * x / ( a ** 2 ) - b <NEWLINE> ans = 90 - math . degrees ( math . atan ( a / ( b - d ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = 2 * a * c / b <NEWLINE> ans = 90 - math . degrees ( math . atan ( d / b ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * m <NEWLINE> b = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> <STRING> <NEWLINE> start = [ ] <NEWLINE> leave = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if a [ i ] == 1 : <NEWLINE> <INDENT> start . append ( b [ i ] ) <NEWLINE> <DEDENT> elif b [ i ] == n : <NEWLINE> <INDENT> leave . append ( a [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if set ( start ) & set ( leave ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
visited = [ False ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> if N >= 2 and A [ 1 ] == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if A [ 0 ] == 1 or N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if visited [ A [ i ] ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i < N - 1 and A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> index = 1 <NEWLINE> while A [ i ] * index <= 10 ** 6 : <NEWLINE> <INDENT> visited [ A [ i ] * index ] = True <NEWLINE> index += 1 <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> ans += 1 <NEWLINE> index = 1 <NEWLINE> while A [ i ] * index <= 10 ** 6 : <NEWLINE> <INDENT> visited [ A [ i ] * index ] = True <NEWLINE> index += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> for a in range ( - 500 , 500 ) : <NEWLINE> <INDENT> for b in range ( - 500 , 500 ) : <NEWLINE> <INDENT> n = a ** 5 - b ** 5 <NEWLINE> if n == x : <NEWLINE> <INDENT> print ( a , end = <STRING> ) <NEWLINE> print ( b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> input_q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B . append ( input_q [ 0 ] ) <NEWLINE> C . append ( input_q [ 1 ] ) <NEWLINE> <NL> <DEDENT> A_sum = sum ( A ) <NEWLINE> CONST_MAX = 100001 <NEWLINE> count_list = [ 0 ] * CONST_MAX <NEWLINE> <NL> c = collections . Counter ( A ) <NEWLINE> for k , v in c . items ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> count_list [ k ] = v <NEWLINE> <NL> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> count_list [ C [ i ] ] += count_list [ B [ i ] ] <NEWLINE> A_sum += ( C [ i ] - B [ i ] ) * count_list [ B [ i ] ] <NEWLINE> count_list [ B [ i ] ] = 0 <NEWLINE> <COMMENT> <NL> <NL> print ( A_sum ) <NEWLINE> <DEDENT>
import queue <NEWLINE> h , w , m = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> h_array = [ 0 for i in range ( h ) ] <NEWLINE> w_array = [ 0 for i in range ( w ) ] <NEWLINE> ps = set ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> hi , wi = ( int ( x ) - 1 for x in input ( ) . split ( ) ) <NEWLINE> h_array [ hi ] += 1 <NEWLINE> w_array [ wi ] += 1 <NEWLINE> ps . add ( ( hi , wi ) ) <NEWLINE> <DEDENT> h_great = max ( h_array ) <NEWLINE> w_great = max ( w_array ) <NEWLINE> h_greats = list ( ) <NEWLINE> w_greats = list ( ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if h_array [ i ] == h_great : <NEWLINE> <INDENT> h_greats . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( w ) : <NEWLINE> <INDENT> if w_array [ i ] == w_great : <NEWLINE> <INDENT> w_greats . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = h_great + w_great - 1 <NEWLINE> <NL> escaper = False <NEWLINE> <NL> for i in range ( len ( h_greats ) ) : <NEWLINE> <INDENT> hi = h_greats [ i ] <NEWLINE> for j in range ( len ( w_greats ) ) : <NEWLINE> <INDENT> wi = w_greats [ j ] <NEWLINE> if ( hi , wi ) not in ps : <NEWLINE> <INDENT> ans += 1 <NEWLINE> escaper = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if escaper : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if ( h + w ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> print ( math . sqrt ( math . pow ( x2 - x1 , 2 ) + math . pow ( y2 - y1 , 2 ) ) ) <NEWLINE> <NL>
A = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> stack = [ ] <NEWLINE> for item in A : <NEWLINE> <INDENT> if item != <STRING> and item != <STRING> and item != <STRING> : <NEWLINE> <INDENT> stack . append ( str ( item ) ) <NEWLINE> <DEDENT> elif item == <STRING> : <NEWLINE> <INDENT> v = int ( stack [ - 2 ] ) + int ( stack [ - 1 ] ) <NEWLINE> del stack [ - 2 ] <NEWLINE> del stack [ - 1 ] <NEWLINE> stack . append ( str ( v ) ) <NEWLINE> <DEDENT> elif item == <STRING> : <NEWLINE> <INDENT> v = int ( stack [ - 2 ] ) - int ( stack [ - 1 ] ) <NEWLINE> del stack [ - 2 ] <NEWLINE> del stack [ - 1 ] <NEWLINE> stack . append ( str ( v ) ) <NEWLINE> <DEDENT> elif item == <STRING> : <NEWLINE> <INDENT> v = int ( stack [ - 2 ] ) * int ( stack [ - 1 ] ) <NEWLINE> del stack [ - 2 ] <NEWLINE> del stack [ - 1 ] <NEWLINE> stack . append ( str ( v ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( stack [ - 1 ] ) <NEWLINE> <NL>
import sys <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> a , b , n = map ( int , e . split ( ) ) <NEWLINE> print ( sum ( a * 10 ** ( i + 1 ) // b % 10 for i in range ( n ) ) ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s . split ( ) [ 1 ] == <STRING> : exit ( ) <NEWLINE> print ( int ( eval ( s ) ) ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> a = [ int ( input ( ) ) for _ in [ 0 ] * n ] <NEWLINE> for i in range ( 1 , n ) : a [ i ] = max ( a [ i ] , a [ i ] + a [ i - 1 ] ) <NEWLINE> print ( max ( a ) ) <NEWLINE> <DEDENT>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 998244353 <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <NL> class Prime ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . M = m = int ( math . sqrt ( n ) ) + 10 <NEWLINE> self . A = a = [ True ] * m <NEWLINE> a [ 0 ] = a [ 1 ] = False <NEWLINE> self . T = t = [ ] <NEWLINE> for i in range ( 2 , m ) : <NEWLINE> <INDENT> if not a [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if not ( i % 7 == 1 or i % 7 == 6 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> t . append ( i ) <NEWLINE> for j in range ( i * i , m , i ) : <NEWLINE> <INDENT> a [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def is_prime ( self , n ) : <NEWLINE> <INDENT> return self . A [ n ] <NEWLINE> <NL> <DEDENT> def division ( self , n ) : <NEWLINE> <INDENT> d = [ ] <NEWLINE> for c in self . T : <NEWLINE> <INDENT> if n < c : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n % c == 0 : <NEWLINE> <INDENT> d . append ( c ) <NEWLINE> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> <NL> pr = Prime ( 300000 ** 2 ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> d = pr . division ( n ) <NEWLINE> rr . append ( <STRING> . format ( n , <STRING> . join ( map ( str , d ) ) ) ) <NEWLINE> <NL> <DEDENT> return <STRING> . join ( map ( str , rr ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL> <NL>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] + a [ i + 1 ] <NEWLINE> <DEDENT> a . insert ( 0 , 0 ) <NEWLINE> for i in range ( m - 1 ) : <NEWLINE> <INDENT> b [ i + 1 ] = b [ i ] + b [ i + 1 ] <NEWLINE> <DEDENT> b . insert ( 0 , 0 ) <NEWLINE> <NL> x = 0 <NEWLINE> jmax = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( jmax , - 1 , - 1 ) : <NEWLINE> <INDENT> if b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> jmax = j <NEWLINE> if jmax + i > x : <NEWLINE> <INDENT> x = jmax + i <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c = 0 <NEWLINE> l = [ ] <NEWLINE> d = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if num in d : <NEWLINE> <INDENT> d [ num ] = d [ num ] + x * y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ num ] = x * y <NEWLINE> l . append ( num ) <NEWLINE> <DEDENT> <DEDENT> for i in l : <NEWLINE> <INDENT> if d [ i ] >= 1000000 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if a . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> A . reverse ( ) <NEWLINE> <NL> if A [ N - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( <STRING> ) ) <NEWLINE> alist = list ( map ( int , input ( <STRING> ) . split ( <STRING> ) ) ) <NEWLINE> <NL> if 0 in alist : <NEWLINE> <INDENT> result = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = 1 <NEWLINE> for a in alist : <NEWLINE> <INDENT> result *= a <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
<COMMENT> <NL> <NL> end = 0 <NEWLINE> while end == 0 : <NEWLINE> <INDENT> rectangle = [ int ( i ) for i in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> height = rectangle [ 0 ] <NEWLINE> width = rectangle [ 1 ] <NEWLINE> if [ height , width ] == [ 0 , 0 ] : <NEWLINE> <INDENT> end += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( height ) : <NEWLINE> <INDENT> for j in range ( width ) : <NEWLINE> <INDENT> sum = i + j <NEWLINE> if sum % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> elif sum % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> print ( len ( set ( S ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s += A [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> s -= A [ i ] <NEWLINE> s %= mod <NEWLINE> ans += ( A [ i ] * s ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> mod = int ( 1e9 + 7 ) <NEWLINE> s = sum ( A ) % mod <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> s -= a <NEWLINE> ans += ( a * s ) % mod <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
from time import time <NEWLINE> <NL> start = time ( ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> C = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> scores = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( D ) ] <NEWLINE> t = [ ] <NEWLINE> for i in scores : <NEWLINE> <INDENT> t . append ( i . index ( max ( i ) ) + 1 ) <NEWLINE> <DEDENT> DC = [ 0 ] * 26 <NEWLINE> <NL> def calcScore ( t ) : <NEWLINE> <INDENT> score = [ ] <NEWLINE> S = 0 <NEWLINE> last = [ 0 ] * 26 <NEWLINE> for d in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> S += scores [ d - 1 ] [ t [ d - 1 ] - 1 ] <NEWLINE> last [ t [ d - 1 ] - 1 ] = d <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> S -= C [ i ] * ( d - last [ i ] ) <NEWLINE> DC [ i ] += ( d - last [ i ] ) <NEWLINE> <DEDENT> score . append ( S ) <NEWLINE> <DEDENT> return score [ - 1 ] <NEWLINE> <NL> <DEDENT> from random import randint <NEWLINE> ts = calcScore ( t ) <NEWLINE> i = 0 <NEWLINE> while time ( ) - start < 1.8 : <NEWLINE> <INDENT> d , q = i , randint ( 1 , 26 ) <NEWLINE> temp = [ t [ i ] if d - 1 != i else q for i in range ( D ) ] <NEWLINE> if calcScore ( temp ) > ts : <NEWLINE> <INDENT> t = temp <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , t ) ) ) <NEWLINE>
import math <NEWLINE> <NL> a = float ( input ( ) ) <NEWLINE> <NL> r = a * a * math . pi <NEWLINE> r2 = a * 2 * math . pi <NEWLINE> <NL> print ( <STRING> % ( r , r2 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> B = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( A [ 1 ] ) : <NEWLINE> <INDENT> B [ A [ 0 ] - 1 ] [ A [ j + 2 ] - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> print ( B [ i ] [ j ] , end = <STRING> ) <NEWLINE> if ( j == n - 1 ) : <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> x = 0 <NEWLINE> a = 0 <NEWLINE> <NL> <NL> for a in range ( 121 ) : <NEWLINE> <INDENT> for b in range ( - 120 , 120 ) : <NEWLINE> <INDENT> x = a ** 5 - b ** 5 <NEWLINE> if x == N : <NEWLINE> <INDENT> an = str ( a ) + <STRING> + str ( b ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( an ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def maximum_profit ( profits ) : <NEWLINE> <INDENT> max_v = profits [ 1 ] - profits [ 0 ] <NEWLINE> min_v = profits [ 0 ] <NEWLINE> <NL> for j in range ( 1 , len ( profits ) ) : <NEWLINE> <INDENT> max_v = max ( max_v , profits [ j ] - min_v ) <NEWLINE> min_v = min ( min_v , profits [ j ] ) <NEWLINE> <NL> <DEDENT> print ( max_v ) <NEWLINE> <NL> <NL> <DEDENT> def to_int ( v ) : <NEWLINE> <INDENT> return int ( v ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> l = to_int ( input ( ) ) <NEWLINE> profits = [ to_int ( input ( ) ) for i in range ( l ) ] <NEWLINE> <NL> maximum_profit ( profits ) <NEWLINE> <DEDENT>
<COMMENT> <NL> ma = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> lma = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tma = lambda : tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ni = lambda : int ( input ( ) ) <NEWLINE> yn = lambda fl : print ( <STRING> ) if fl else print ( <STRING> ) <NEWLINE> import collections <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import heapq as hq <NEWLINE> ceil = math . ceil <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n = ni ( ) <NEWLINE> A = lma ( ) <NEWLINE> tree = [ [ ] for i in range ( n ) ] <NEWLINE> INF = 10 ** 10 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> u , v = ma ( ) ; u -= 1 ; v -= 1 <NEWLINE> tree [ u ] . append ( v ) <NEWLINE> tree [ v ] . append ( u ) <NEWLINE> <COMMENT> <NL> <DEDENT> def isok ( num , val ) : <COMMENT> <NEWLINE> <INDENT> return num < val <NEWLINE> <DEDENT> def bisect ( ls , val ) : <COMMENT> <NEWLINE> <INDENT> ok = - 1 <NEWLINE> ng = len ( ls ) <NEWLINE> x = ( ok + ng ) // 2 <NEWLINE> while ng - ok > 1 : <NEWLINE> <INDENT> num = ls [ x ] <NEWLINE> if isok ( num , val ) : <NEWLINE> <INDENT> ok = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = x <NEWLINE> <DEDENT> x = ( ok + ng ) // 2 <NEWLINE> <DEDENT> return ok <COMMENT> <NEWLINE> <DEDENT> def LIS_1 ( x , ls , right ) : <COMMENT> <NEWLINE> <INDENT> idx = bisect ( ls , x ) + 1 <NEWLINE> if idx + 1 > right : <NEWLINE> <INDENT> ret = idx + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = right <NEWLINE> <DEDENT> rewind_idxval . append ( ( idx , ls [ idx ] ) ) <NEWLINE> ls [ idx ] = x <NEWLINE> <COMMENT> <NL> return ret <NEWLINE> <DEDENT> def DFS_LIS ( prev , ls , right ) : <NEWLINE> <INDENT> ans [ prev ] = LIS_1 ( A [ prev ] , ls , right ) <NEWLINE> for node in tree [ prev ] : <NEWLINE> <INDENT> if not visited [ node ] : <NEWLINE> <INDENT> visited [ node ] = True <NEWLINE> DFS_LIS ( node , ls , ans [ prev ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> idx , pval = rewind_idxval . pop ( ) <NEWLINE> ls [ idx ] = pval <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> s = 0 <NEWLINE> right = 0 <NEWLINE> rewind_idxval = collections . deque ( ) <NEWLINE> visited = [ False ] * n <NEWLINE> visited [ s ] = True <NEWLINE> ls = [ INF ] * n <NEWLINE> DFS_LIS ( s , ls , right ) <NEWLINE> <COMMENT> <NL> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ai_char = map ( str , input ( ) . split ( <STRING> ) ) <NEWLINE> Ai = [ ] <NEWLINE> for i in ai_char : <NEWLINE> <INDENT> Ai . append ( int ( i ) ) <NEWLINE> <NL> <DEDENT> mod_val = 1000000007 <NEWLINE> N1 = N - 1 <NEWLINE> sum = 0 <NEWLINE> <NL> sum_tmp = 0 <NEWLINE> for j in range ( 0 , N ) : <NEWLINE> <INDENT> sum_tmp += Ai [ j ] <NEWLINE> <NL> <DEDENT> for i in range ( N1 ) : <NEWLINE> <INDENT> sum_tmp -= Ai [ i ] <NEWLINE> sum += Ai [ i ] * sum_tmp <NEWLINE> <NL> if sum > mod_val : <NEWLINE> <INDENT> sum = sum % mod_val <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( int ( sum ) ) <NEWLINE>
import decimal <NEWLINE> A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = decimal . Decimal ( B ) <NEWLINE> print ( int ( A * B ) ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> five = [ i ** 5 for i in range ( 1000 ) ] <NEWLINE> flg = 0 <NEWLINE> for i in range ( len ( five ) ) : <NEWLINE> <INDENT> for j in range ( len ( five ) ) : <NEWLINE> <INDENT> if five [ i ] + five [ j ] == X : <NEWLINE> <INDENT> flg = 1 <NEWLINE> ans_1 = i <NEWLINE> ans_2 = - j <NEWLINE> <DEDENT> if five [ i ] - five [ j ] == X : <NEWLINE> <INDENT> ans_1 = i <NEWLINE> ans_2 = j <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans_1 , ans_2 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for v in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for u in g [ v ] : <NEWLINE> <INDENT> if arr [ u ] >= arr [ v ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> S = sum ( A ) - A [ 0 ] <NEWLINE> X = A [ 0 ] <NEWLINE> ans = abs ( S - X ) <NEWLINE> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> X += A [ i ] <NEWLINE> S -= A [ i ] <NEWLINE> ans = min ( ans , abs ( S - X ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = set ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> cmd = input ( ) . split ( ) <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> l . add ( cmd [ 1 ] ) <NEWLINE> <DEDENT> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> if cmd [ 1 ] in l : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N , K = LI ( ) <NEWLINE> a = LI ( ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> for i in range ( 2 ** ( N - 1 ) ) : <NEWLINE> <INDENT> bit = [ i >> j & 1 for j in range ( N - 1 ) ] <NEWLINE> if K - 1 != sum ( bit ) : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> cost , kijun = 0 , a [ 0 ] <NEWLINE> for k in range ( N - 1 ) : <NEWLINE> <INDENT> if bit [ k ] == 0 : <NEWLINE> <INDENT> kijun = max ( kijun , a [ k + 1 ] ) <NEWLINE> continue <NEWLINE> <DEDENT> if a [ k + 1 ] >= kijun + 1 : <NEWLINE> <INDENT> kijun = a [ k + 1 ] <NEWLINE> continue <NEWLINE> <DEDENT> cost += ( kijun + 1 ) - a [ k + 1 ] <NEWLINE> kijun += 1 <NEWLINE> <DEDENT> ans = min ( ans , cost ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def set_info ( i , p , d ) : <NEWLINE> <INDENT> r = T [ i ] <NEWLINE> r [ 1 ] , r [ 2 ] = p , d <NEWLINE> for c in r [ 0 ] : <NEWLINE> <INDENT> set_info ( c , i , d + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> T = [ None ] * n <NEWLINE> root = set ( range ( n ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ch = A [ 2 : ] <NEWLINE> T [ A [ 0 ] ] = [ ch , None , None ] <NEWLINE> root -= set ( ch ) <NEWLINE> <NL> <DEDENT> set_info ( root . pop ( ) , - 1 , 0 ) <NEWLINE> <NL> for i , node in enumerate ( T ) : <NEWLINE> <INDENT> ch , p , d = node <NEWLINE> print ( <STRING> . format ( <NEWLINE> <INDENT> i , p , d , <STRING> if not d else <STRING> if ch else <STRING> , ch <NEWLINE> ) ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) + 1 <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K ) : <NEWLINE> <INDENT> for b in range ( 1 , K ) : <NEWLINE> <INDENT> gcdab = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K ) : <NEWLINE> <INDENT> ans += math . gcd ( gcdab , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
input_line1 = input ( ) <NEWLINE> N = int ( input_line1 ) <NEWLINE> input_line2 = input ( ) <NEWLINE> numbers = input_line2 . split ( ) <NEWLINE> num_sum = 1 <NEWLINE> <NL> if <STRING> in numbers : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> num_sum *= int ( numbers [ i ] ) <NEWLINE> if num_sum > 10 ** 18 : <NEWLINE> <INDENT> num_sum = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num_sum ) <NEWLINE> <DEDENT>
_temp = [ ] <NEWLINE> <NL> size = int ( input ( ) . rstrip ( ) ) <NEWLINE> for i in range ( size ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> _temp . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> my_max = - 20000000000000 <NEWLINE> my_min = _temp . pop ( 0 ) <NEWLINE> <NL> <NL> for val in _temp : <NEWLINE> <INDENT> my_max = max ( my_max , ( val - my_min ) ) <NEWLINE> my_min = min ( my_min , val ) <NEWLINE> <NL> <DEDENT> print ( my_max ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> inf = float ( <STRING> ) <COMMENT> <NEWLINE> <NL> s = input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> print ( s . replace ( <STRING> , <STRING> ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans_list = [ 0 for _ in range ( 1 , 10100 ) ] <NEWLINE> <NL> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> for j in range ( 1 , 100 ) : <NEWLINE> <INDENT> for k in range ( 1 , 100 ) : <NEWLINE> <INDENT> value = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> if value <= 10000 : <NEWLINE> <INDENT> ans_list [ value ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans_list [ i ] ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> dx = ( 0 , 0 , 0 , 1 , - 1 , 1 , 1 , - 1 , - 1 , - 2 , 2 , 0 , 0 ) <NEWLINE> dy = ( 0 , 1 , - 1 , 0 , 0 , 1 , - 1 , 1 , - 1 , 0 , 0 , - 2 , 2 ) <NEWLINE> dd = ( 5 , 9 , 13 ) <NEWLINE> <NL> def drop ( fab , start , used , size_list ) : <NEWLINE> <INDENT> for xy in range ( start , 100 ) : <NEWLINE> <INDENT> y = xy % 10 <NEWLINE> x = xy // 10 <NEWLINE> size = size_list [ used ] <NEWLINE> for i in range ( size ) : <NEWLINE> <INDENT> if not fab [ y + dy [ i ] + 2 ] [ x + dx [ i ] + 2 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( size ) : <NEWLINE> <INDENT> fab [ y + dy [ i ] + 2 ] [ x + dx [ i ] + 2 ] -= 1 <NEWLINE> <DEDENT> if sum ( map ( sum , fab ) ) : <NEWLINE> <INDENT> if size == size_list [ used + 1 ] : <NEWLINE> <INDENT> result = drop ( fab , xy , used + 1 , size_list ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = drop ( fab , 0 , used + 1 , size_list ) <NEWLINE> <DEDENT> if result : <NEWLINE> <INDENT> result . append ( [ x , y , dd . index ( size ) + 1 ] ) <NEWLINE> return result <NEWLINE> <DEDENT> for i in range ( size ) : <NEWLINE> <INDENT> fab [ y + dy [ i ] + 2 ] [ x + dx [ i ] + 2 ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return [ [ x , y , dd . index ( size ) + 1 ] ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> fab = [ [ 0 for i in range ( 14 ) ] for j in range ( 14 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 10 ) : <NEWLINE> <INDENT> fab [ i + 2 ] [ 2 : 12 ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> s = sum ( map ( sum , fab ) ) <NEWLINE> d_all = list ( itertools . combinations_with_replacement ( [ 5 , 9 , 13 ] , n ) ) <NEWLINE> d_list = [ l for l in d_all if sum ( l ) == s ] <NEWLINE> <NL> ans = [ 0 for i in range ( n ) ] <NEWLINE> for d in d_list : <NEWLINE> <INDENT> d_tmp = sorted ( d ) [ : : - 1 ] <NEWLINE> ans = drop ( fab , 0 , 0 , d_tmp ) <NEWLINE> if ans : <NEWLINE> <INDENT> for a in ans : <NEWLINE> <INDENT> print ( * a ) <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> d = 10 ** 9 + 7 <NEWLINE> <NL> A = [ i for i in range ( N + 1 ) ] <NEWLINE> A_rev = sorted ( A , reverse = True ) <NEWLINE> ans = 0 <NEWLINE> dp = { <STRING> : sum ( A_rev [ 0 : K ] ) , <STRING> : sum ( A [ 0 : K ] ) } <NEWLINE> ans += dp [ <STRING> ] - dp [ <STRING> ] + 1 <NEWLINE> for i in range ( K , N + 1 ) : <NEWLINE> <INDENT> dp [ <STRING> ] += A_rev [ i ] <NEWLINE> dp [ <STRING> ] += A [ i ] <NEWLINE> ans += dp [ <STRING> ] - dp [ <STRING> ] + 1 <NEWLINE> <DEDENT> print ( ans % d ) <NEWLINE>
class RKSearch : <NEWLINE> <INDENT> shift = 40 <NEWLINE> size = 33554393 <NEWLINE> <NL> def __init__ ( self , s1 , s2 ) : <NEWLINE> <INDENT> self . haystack = self . _encode ( s1 ) <NEWLINE> self . needle = self . _encode ( s2 ) <NEWLINE> <NL> <DEDENT> def find ( self ) : <NEWLINE> <INDENT> m , n = len ( self . haystack ) , len ( self . needle ) <NEWLINE> if m < n : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> h1 = self . _hash ( self . haystack , n ) <NEWLINE> h2 = self . _hash ( self . needle , n ) <NEWLINE> dm = self . shift ** ( n - 1 ) % self . size <NEWLINE> <NL> for i in range ( m - n + 1 ) : <NEWLINE> <INDENT> if h1 == h2 : <NEWLINE> <INDENT> yield i <NEWLINE> <DEDENT> if i + n < m : <NEWLINE> <INDENT> h1 = ( ( h1 - self . haystack [ i ] * dm ) * self . shift <NEWLINE> <INDENT> + self . haystack [ i + n ] ) % self . size <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def _hash ( self , s , length ) : <NEWLINE> <INDENT> h = 0 <NEWLINE> for i in range ( length ) : <NEWLINE> <INDENT> h = ( h * self . shift + s [ i ] ) % self . size <NEWLINE> <NL> <DEDENT> return h <NEWLINE> <NL> <DEDENT> def _encode ( cls , s ) : <NEWLINE> <INDENT> basea = int . from_bytes ( <STRING> , <STRING> ) <NEWLINE> based = int . from_bytes ( <STRING> , <STRING> ) <NEWLINE> bs = [ ] <NEWLINE> for c in s : <NEWLINE> <INDENT> if c . isdigit ( ) : <NEWLINE> <INDENT> bs . append ( int . from_bytes ( c . encode ( <STRING> ) , <STRING> ) - based + 27 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bs . append ( int . from_bytes ( c . encode ( <STRING> ) , <STRING> ) - basea ) <NEWLINE> <NL> <DEDENT> <DEDENT> return bs <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> s1 = input ( ) <NEWLINE> s2 = input ( ) <NEWLINE> rk = RKSearch ( s1 , s2 ) <NEWLINE> for i in rk . find ( ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
import itertools <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> s_l = list ( map ( int , s ) ) <NEWLINE> <COMMENT> <NL> <NL> l = [ i for i in range ( 10 ) ] <NEWLINE> ans = 0 <NEWLINE> for v1 , v2 , v3 in itertools . product ( l , repeat = 3 ) : <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <INDENT> if not v1 in s_l : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index1 = s_l . index ( v1 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> s_l_1 = s_l [ index1 + 1 : ] <NEWLINE> <NL> if not v2 in s_l_1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index2 = s_l_1 . index ( v2 ) <NEWLINE> <NL> <DEDENT> s_l_2 = s_l_1 [ index2 + 1 : ] <NEWLINE> <NL> <NL> if not v3 in s_l_2 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> q = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> q . append ( x ) <NEWLINE> <DEDENT> w = set ( q ) <NEWLINE> ans = len ( w ) <NEWLINE> print ( ans ) <NEWLINE> <NL>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = collections . Counter ( A ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> ans = sum ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += ( C - B ) * X [ B ] <NEWLINE> print ( ans ) <NEWLINE> X [ C ] += X [ B ] <NEWLINE> X [ B ] = 0 <NEWLINE> <DEDENT>
param_x , param_k , param_d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> param_x_tmp = param_x <NEWLINE> <NL> if param_x > 0 : <NEWLINE> <INDENT> int_times_nega_posi = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> int_times_nega_posi = 1 <NEWLINE> <NL> <DEDENT> if ( param_x * int_times_nega_posi * - 1 ) - ( param_k * param_d ) > 0 : <NEWLINE> <INDENT> print ( ( param_x * int_times_nega_posi * - 1 ) - ( param_k * param_d ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> int_time_before_cross_0 = int ( ( param_x * int_times_nega_posi * - 1 ) / param_d ) <NEWLINE> <COMMENT> <NL> <NL> param_x_tmp = param_x + int_time_before_cross_0 * param_d * int_times_nega_posi <NEWLINE> <COMMENT> <NL> <NL> int_move = param_k - int_time_before_cross_0 <COMMENT> <NEWLINE> int_move_devide_2_no_amari = int_move % 2 <NEWLINE> print ( abs ( param_x_tmp + param_d * int_move_devide_2_no_amari * int_times_nega_posi ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> a = sorted ( a ) <NEWLINE> if a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> x = x * i <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> x = N // ( A + B ) <NEWLINE> y = N % ( A + B ) <NEWLINE> ans = x * A + min ( y , A ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> if 2 * j - i >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] != s [ j ] != s [ 2 * j - i ] != s [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( t - cnt ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for j in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> a . append ( [ i , j ] ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( * a [ 0 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = [ int ( i ) for i in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> t = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> sum_array = 0 <NEWLINE> for i in arr : <NEWLINE> <INDENT> dic [ i ] = dic . get ( i , 0 ) + 1 <NEWLINE> sum_array += i <NEWLINE> <NL> <NL> <DEDENT> for _ in range ( t ) : <NEWLINE> <INDENT> a , b = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> if a not in dic : <NEWLINE> <INDENT> print ( sum_array ) <NEWLINE> continue <NEWLINE> <DEDENT> if b in dic : <NEWLINE> <INDENT> dic [ b ] += dic [ a ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ b ] = dic [ a ] <NEWLINE> <NL> <DEDENT> sum_array += dic [ a ] * ( b - a ) <NEWLINE> print ( sum_array ) <NEWLINE> dic [ a ] = 0 <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> def Z ( ) : return int ( input ( ) ) <NEWLINE> def ZZ ( ) : return [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = Z ( ) <NEWLINE> X = input ( ) <NEWLINE> pcnt = 0 <NEWLINE> ans = [ ] <NEWLINE> for x in X : <NEWLINE> <INDENT> if x == <STRING> : pcnt += 1 <NEWLINE> <DEDENT> if pcnt == 0 : <NEWLINE> <INDENT> for _ in range ( N ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> Xinv = X [ : : - 1 ] <NEWLINE> ex1 = ex2 = 1 <NEWLINE> num1 = num2 = 0 <NEWLINE> for x in Xinv : <NEWLINE> <INDENT> num1 += ( ex1 * int ( x ) ) % ( pcnt + 1 ) <NEWLINE> num1 %= ( pcnt + 1 ) <NEWLINE> if pcnt > 1 : <NEWLINE> <INDENT> num2 += ( ex2 * int ( x ) ) % ( pcnt - 1 ) <NEWLINE> num2 %= ( pcnt - 1 ) <NEWLINE> <DEDENT> ex1 *= 2 <NEWLINE> ex1 %= ( pcnt + 1 ) <NEWLINE> ex2 *= 2 <NEWLINE> if pcnt > 1 : ex2 %= ( pcnt - 1 ) <NEWLINE> <NL> <DEDENT> def solve ( n , p , s ) : <NEWLINE> <INDENT> if n == 0 and s > 0 : return s <NEWLINE> n %= p <NEWLINE> p = bin ( n ) . count ( <STRING> ) <NEWLINE> return solve ( n , p , s + 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> p = pcnt - 1 <NEWLINE> if p == 0 : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> num = num2 - pow ( 2 , N - i - 1 , p ) <NEWLINE> ans . append ( solve ( num , p , 0 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = pcnt + 1 <NEWLINE> num = num1 + pow ( 2 , N - i - 1 , p ) <NEWLINE> ans . append ( solve ( num , p , 0 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def ev ( n ) : <NEWLINE> <INDENT> return n * ( n + 1 ) / ( 2 * n ) <NEWLINE> <NL> <DEDENT> q = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> q . append ( ev ( p [ i ] ) ) <NEWLINE> q [ i + 1 ] = q [ i ] + ev ( p [ i ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> tmp = 0 <NEWLINE> for j in range ( n - k + 1 ) : <NEWLINE> <INDENT> if tmp <= q [ j + k ] - q [ j ] : <NEWLINE> <INDENT> tmp = q [ j + k ] - q [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( tmp ) <NEWLINE>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Aii = [ 0 ] * ( N ) <NEWLINE> Ajj = [ 0 ] * ( N ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x = A [ i ] + i + 1 <NEWLINE> y = i + 1 - A [ i ] <NEWLINE> if 1 < x < N : Aii [ x ] += 1 <NEWLINE> if 1 < y < N : Ajj [ y ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += Aii [ i ] * Ajj [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( N , X ) : <NEWLINE> <INDENT> lst = list ( map ( int , list ( X ) ) ) <NEWLINE> num = lst . count ( 1 ) <COMMENT> <NEWLINE> <NL> def func ( x ) : <COMMENT> <NEWLINE> <INDENT> lst = list ( bin ( x ) [ 2 : ] ) <NEWLINE> amari = x % lst . count ( <STRING> ) <NEWLINE> return amari <NEWLINE> <NL> <DEDENT> d = { } <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> d [ i ] = func ( i ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> plus = [ ] <COMMENT> <NEWLINE> minus = [ ] <COMMENT> <NEWLINE> <NL> p = 1 <NEWLINE> m = 1 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> p %= ( num + 1 ) <NEWLINE> plus . append ( p ) <NEWLINE> p *= 2 <NEWLINE> if num - 1 > 0 : <NEWLINE> <INDENT> m %= ( num - 1 ) <NEWLINE> minus . append ( m ) <NEWLINE> m *= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> o = int ( X , 2 ) <COMMENT> <NEWLINE> amari_plus = o % ( num + 1 ) <NEWLINE> if num - 1 > 0 : <NEWLINE> <INDENT> amari_minus = o % ( num - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if lst [ i ] == 0 : <NEWLINE> <INDENT> amari = ( amari_plus + plus [ - i - 1 ] ) % ( num + 1 ) <NEWLINE> <DEDENT> elif num - 1 <= 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> amari = ( amari_minus + ( num - 1 ) - minus [ - i - 1 ] ) % ( num - 1 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> while amari != 0 : <NEWLINE> <INDENT> amari = d [ amari ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> main ( N , X ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> N2 = list ( map ( int , str ( N ) ) ) <NEWLINE> if not ( 1000 <= N <= 9999 ) : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if N2 [ 0 ] == N2 [ 1 ] == N2 [ 2 ] or N2 [ 1 ] == N2 [ 2 ] == N2 [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( input ( ) . split ( ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> <NL> if c . most_common ( ) [ 0 ] [ 1 ] != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) - 1 for i in range ( q ) ] <NEWLINE> point = [ k - q for i in range ( n ) ] <NEWLINE> for i in a : <NEWLINE> <INDENT> point [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in point : <NEWLINE> <INDENT> print ( <STRING> if i > 0 else <STRING> ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> <NL> nv , ne = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> edges = [ set ( ) for _ in range ( nv ) ] <NEWLINE> while ne : <NEWLINE> <INDENT> s , t , w = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ s ] . add ( ( w , t ) ) <NEWLINE> edges [ t ] . add ( ( w , s ) ) <NEWLINE> ne -= 1 <NEWLINE> <NL> <DEDENT> cost = 0 <NEWLINE> queue = list ( edges [ 0 ] ) <NEWLINE> heapq . heapify ( queue ) <NEWLINE> visited = [ False ] * nv <NEWLINE> visited [ 0 ] = True <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> edge_cost , t = heapq . heappop ( queue ) <NEWLINE> if visited [ t ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited [ t ] = True <NEWLINE> cost += edge_cost <NEWLINE> if all ( visited ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for e in edges [ t ] : <NEWLINE> <INDENT> if not visited [ e [ 1 ] ] : <NEWLINE> <INDENT> heapq . heappush ( queue , e ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cost ) <NEWLINE>
import math <NEWLINE> <NL> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <COMMENT> <NEWLINE> N = 10 ** 5 + 5 <NEWLINE> g1 = [ 1 , 1 ] <COMMENT> <NEWLINE> g2 = [ 1 , 1 ] <COMMENT> <NEWLINE> inverse = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <NL> <DEDENT> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = tuple ( A [ i + 1 ] - A [ i ] for i in range ( len ( A ) - 1 ) ) <NEWLINE> lim = math . ceil ( len ( B ) / 2 ) <NEWLINE> <NL> L = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> multi = cmb ( N , K , mod ) <NEWLINE> for j in range ( lim ) : <NEWLINE> <INDENT> front = j + 1 <NEWLINE> back = N - front <NEWLINE> tmp_b = 0 <NEWLINE> tmp_f = 0 <NEWLINE> if front >= K : <NEWLINE> <INDENT> tmp_f = cmb ( front , K , mod ) <NEWLINE> <DEDENT> if back >= K : <NEWLINE> <INDENT> tmp_b = cmb ( back , K , mod ) <NEWLINE> <DEDENT> if j == ( len ( B ) - 1 ) / 2 : <NEWLINE> <INDENT> ans += ( multi - tmp_b - tmp_f ) * ( B [ j ] ) % L <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ( multi - tmp_b - tmp_f ) * ( B [ j ] + B [ len ( B ) - 1 - j ] ) % L <NEWLINE> <DEDENT> <DEDENT> print ( ans % L ) <NEWLINE>
K = input ( ) <NEWLINE> K = int ( K ) <NEWLINE> <NL> def seven ( ) : <NEWLINE> <INDENT> seven_i = 0 <NEWLINE> count = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> seven_i = ( ( 10 * seven_i ) + 7 ) % K <NEWLINE> count += 1 <NEWLINE> if seven_i % K == 0 : <NEWLINE> <INDENT> return count <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <DEDENT> print ( seven ( ) ) <NEWLINE>
x = input ( ) <COMMENT> <NEWLINE> n = ( int ( x ) ** 3 ) <NEWLINE> print ( n ) <NEWLINE>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> mem = [ [ 0 for _ in range ( N ) ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> mem [ L - 1 ] [ R - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for L in range ( N ) : <NEWLINE> <INDENT> for R in range ( 1 , N ) : <NEWLINE> <INDENT> mem [ L ] [ R ] += mem [ L ] [ R - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for R in range ( N ) : <NEWLINE> <INDENT> for L in range ( 1 , N ) : <NEWLINE> <INDENT> mem [ L ] [ R ] += mem [ L - 1 ] [ R ] <NEWLINE> <NL> <DEDENT> <DEDENT> res = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> QL , QR = map ( int , input ( ) . split ( ) ) <NEWLINE> if QL == 1 : <NEWLINE> <INDENT> r = mem [ QR - 1 ] [ QR - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = mem [ QR - 1 ] [ QR - 1 ] - mem [ QL - 2 ] [ QR - 1 ] <NEWLINE> <DEDENT> res . append ( r ) <NEWLINE> <NL> <DEDENT> for r in res : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT>
def prime_factorize ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> n //= 2 <NEWLINE> <DEDENT> arr . append ( [ 2 , cnt ] ) <NEWLINE> <NL> <DEDENT> p = 3 <NEWLINE> while p * p <= n : <NEWLINE> <INDENT> if n % p == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while n % p == 0 : <NEWLINE> <INDENT> n //= p <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> arr . append ( [ p , cnt ] ) <NEWLINE> p += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p += 2 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <NL> <NL> <DEDENT> n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if p == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> pr_list = prime_factorize ( p ) <NEWLINE> <NL> for a , b in pr_list : <NEWLINE> <INDENT> if b >= n : <NEWLINE> <INDENT> ans *= a ** ( b // n ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> inp = input ( ) <NEWLINE> a = [ ] <NEWLINE> ans = [ ] <NEWLINE> total = 0 <NEWLINE> for i in range ( len ( inp ) ) : <NEWLINE> <INDENT> if inp [ i ] == <STRING> : <NEWLINE> <INDENT> a . append ( i ) <NEWLINE> <DEDENT> elif inp [ i ] == <STRING> : <NEWLINE> <INDENT> if len ( a ) != 0 : <NEWLINE> <INDENT> x = a . pop ( ) <NEWLINE> d = i - x <NEWLINE> total += d <NEWLINE> while len ( ans ) != 0 and ans [ - 1 ] [ 0 ] > x : <NEWLINE> <INDENT> d += ans [ - 1 ] [ 1 ] <NEWLINE> ans . pop ( ) <NEWLINE> <DEDENT> ans . append ( [ x , d ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE> if total == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( len ( ans ) ) + <STRING> + ( <STRING> . join ( map ( str , [ x [ 1 ] for x in ans ] ) ) ) ) <NEWLINE> <DEDENT> <DEDENT>
( N , M ) , * miti = [ [ * map ( int , line . split ( ) ) ] for line in open ( 0 ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> A = [ list ( ) for _ in range ( N + 1 ) ] <NEWLINE> for m in miti : <NEWLINE> <INDENT> a , b = m <NEWLINE> A [ a ] . append ( b ) <NEWLINE> A [ b ] . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = [ 0 ] * ( N + 1 ) <NEWLINE> dist = [ N ] * ( N + 1 ) <NEWLINE> R = [ list ( ) for _ in range ( N ) ] <NEWLINE> <NL> dist [ 1 ] = 0 <NEWLINE> R [ 0 ] . append ( 1 ) <NEWLINE> ans [ 1 ] = 88888 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for p in R [ i ] : <NEWLINE> <INDENT> for t in A [ p ] : <NEWLINE> <INDENT> if i + 1 < dist [ t ] : <NEWLINE> <INDENT> dist [ t ] = i + 1 <NEWLINE> R [ i + 1 ] . append ( t ) <NEWLINE> ans [ t ] = p <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dist = dist [ 1 : ] <NEWLINE> ans = ans [ 2 : ] <NEWLINE> if all ( d < N for d in dist ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a = gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += gcd ( a , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> resolve ( ) <NEWLINE>
<COMMENT> <NL> import sys , pprint , readline <NEWLINE> <NL> av = { } <NEWLINE> passed = set ( ) <NEWLINE> <NL> ( N , K ) = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> arrivalary = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> i = 0 <NEWLINE> loopflg = 0 <NEWLINE> pos = 1 <NEWLINE> nextpos = 0 <NEWLINE> loopstartpos = 0 <NEWLINE> loopstartnum = 0 <NEWLINE> loopcount = 0 <NEWLINE> while i < K : <NEWLINE> <INDENT> passed . add ( pos ) <NEWLINE> nextpos = arrivalary [ pos - 1 ] <NEWLINE> <COMMENT> <NL> if loopflg == 0 and nextpos in passed : <NEWLINE> <INDENT> loopflg = 1 <NEWLINE> loopstartpos = nextpos <NEWLINE> loopstartnum = i <NEWLINE> loopcount = 1 <NEWLINE> <DEDENT> elif loopflg == 1 and nextpos == loopstartpos : <NEWLINE> <INDENT> left = ( K - loopstartnum ) % loopcount <NEWLINE> <COMMENT> <NL> i = K - left <NEWLINE> if i == K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> elif loopflg == 1 : <NEWLINE> <INDENT> loopcount += 1 <NEWLINE> <DEDENT> pos = nextpos <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> print ( pos ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> flag = 0 <NEWLINE> z = 0 <NEWLINE> for i in range ( s ) : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if p [ 0 ] == p [ 1 ] : <NEWLINE> <INDENT> z += 1 <NEWLINE> if z == 3 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> z = 0 <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> dp = [ 0 ] * ( s + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if s < 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 3 , s + 1 ) : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] <NEWLINE> dp . append ( dp [ i ] ) <NEWLINE> score = dp [ s ] % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( score ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maxA = max ( A ) <NEWLINE> counter = [ 0 ] * ( maxA + 1 ) <NEWLINE> for ai in A : <NEWLINE> <INDENT> for m in range ( ai , maxA + 1 , ai ) : <NEWLINE> <INDENT> counter [ m ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for ai in A : <NEWLINE> <INDENT> ans += ( counter [ ai ] == 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> cnt = 0 <NEWLINE> ans = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : cnt += 1 <NEWLINE> elif s [ i ] == <STRING> : ans . append ( cnt ) <NEWLINE> else : cnt = 0 <NEWLINE> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
<NL> def submit ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> <NL> if k % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> if k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> d = { } <NEWLINE> for t in [ 1 , 3 , 7 , 9 ] : <NEWLINE> <INDENT> d [ t ] = { } <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> d [ t ] [ t * i % 10 ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> td = k % 10 <NEWLINE> curr = 0 <NEWLINE> count = 0 <NEWLINE> while count == 0 or curr != 0 : <NEWLINE> <INDENT> diff = 7 - ( curr % 10 ) <NEWLINE> if diff != 0 : <NEWLINE> <INDENT> if diff < 0 : <NEWLINE> <INDENT> diff += 10 <NEWLINE> <DEDENT> coef = d [ td ] [ diff ] <NEWLINE> curr += coef * k <NEWLINE> <DEDENT> curr //= 10 <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> submit ( ) <NEWLINE>
t = list ( input ( ) ) <NEWLINE> if t [ 0 ] == <STRING> : <NEWLINE> <INDENT> t [ 0 ] = t [ 0 ] . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> for i in range ( 1 , len ( t ) - 1 ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> and t [ i + 1 ] == <STRING> and t [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = t [ i ] . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> elif t [ i ] == <STRING> and t [ i + 1 ] == <STRING> and t [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = t [ i ] . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> elif t [ i ] == <STRING> and t [ i + 1 ] == <STRING> and t [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = t [ i ] . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> elif t [ i ] == <STRING> and t [ i + 1 ] == <STRING> and t [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = t [ i ] . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> elif t [ i ] == <STRING> and t [ i + 1 ] == <STRING> and t [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = t [ i ] . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> elif t [ i ] == <STRING> and t [ i + 1 ] == <STRING> and t [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = t [ i ] . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if t [ - 1 ] == <STRING> : <NEWLINE> <INDENT> t [ - 1 ] = t [ - 1 ] . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> for i in t : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> n = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> count = { } <NEWLINE> <NL> num = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> num += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if a * b != 0 : <NEWLINE> <INDENT> g = gcd ( a , b ) * ( b // abs ( b ) ) <NEWLINE> <DEDENT> elif a != 0 : <NEWLINE> <INDENT> g = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = b <NEWLINE> <NL> <DEDENT> l = a // g , b // g <NEWLINE> count [ l ] = count . get ( l , 0 ) + 1 <NEWLINE> <NL> <DEDENT> mem = set ( ) <NEWLINE> ans = 1 <NEWLINE> for ( x , y ) , z in count . items ( ) : <NEWLINE> <INDENT> if x * y == 0 : <NEWLINE> <INDENT> k = ( y , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = ( - 1 * x // abs ( x ) * y , abs ( x ) ) <NEWLINE> <DEDENT> if k in mem : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> mem . add ( ( x , y ) ) <NEWLINE> ans *= ( pow ( 2 , z ) + pow ( 2 , count . get ( k , 0 ) ) - 1 ) <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ( ans + num - 1 ) % mod ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> if len ( t ) > len ( s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> s = s [ : : - 1 ] <NEWLINE> t = t [ : : - 1 ] <NEWLINE> <NL> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if j == len ( t ) : <NEWLINE> <INDENT> ans = s [ : i ] + t + s [ i + len ( t ) : ] <NEWLINE> print ( ans [ : : - 1 ] . replace ( <STRING> , <STRING> , len ( ans ) ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if t [ j ] == s [ i + j ] or s [ i + j ] == <STRING> : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > int ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
ans = [ 0 ] * 10000 <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> k = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if k > 10000 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans [ k - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> j = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> while j < N and S [ i : j ] in S [ j : ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> ans = max ( ans , j - i - 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v . sort ( reverse = True ) <NEWLINE> a = v [ : A ] <NEWLINE> b = v [ : B ] <NEWLINE> avg = sum ( a ) / A <NEWLINE> print ( avg ) <NEWLINE> c = [ [ 0 ] * 51 for _ in range ( 51 ) ] <NEWLINE> c [ 0 ] [ 0 ] = 1 <NEWLINE> for i in range ( 50 ) : <NEWLINE> <INDENT> c [ i + 1 ] [ 0 ] = 1 <NEWLINE> c [ i + 1 ] [ i + 1 ] = 1 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> c [ i + 1 ] [ j + 1 ] = c [ i ] [ j ] + c [ i ] [ j + 1 ] <NEWLINE> <DEDENT> <DEDENT> if a [ 0 ] == a [ - 1 ] : <NEWLINE> <INDENT> ans = 0 <NEWLINE> x = v . count ( a [ 0 ] ) <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i <= x : <NEWLINE> <INDENT> ans += c [ x ] [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> x = v . count ( a [ - 1 ] ) <NEWLINE> y = a . count ( a [ - 1 ] ) <NEWLINE> ans = c [ x ] [ y ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> slopes = input ( ) <NEWLINE> total_area = 0 <NEWLINE> slope_queue = deque ( ) <NEWLINE> area_queue = deque ( ) <NEWLINE> <NL> for i , slope in enumerate ( slopes ) : <NEWLINE> <INDENT> if slope == <STRING> : <NEWLINE> <INDENT> slope_queue . append ( i ) <NEWLINE> <DEDENT> elif slope == <STRING> and len ( slope_queue ) != 0 : <NEWLINE> <INDENT> target = slope_queue . pop ( ) <NEWLINE> area = i - target <NEWLINE> total_area += area <NEWLINE> if len ( area_queue ) == 0 : <NEWLINE> <INDENT> area_queue . append ( ( target , area ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp_area = area <NEWLINE> while True : <NEWLINE> <INDENT> target_area = area_queue . pop ( ) <NEWLINE> if target < target_area [ 0 ] : <NEWLINE> <INDENT> temp_area += target_area [ 1 ] <NEWLINE> if len ( area_queue ) == 0 : <NEWLINE> <INDENT> area_queue . append ( ( target , temp_area ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> area_queue . append ( target_area ) <NEWLINE> area_queue . append ( ( target , temp_area ) ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( total_area ) <NEWLINE> if len ( area_queue ) == 0 : <NEWLINE> <INDENT> print ( len ( area_queue ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( area_queue ) , end = <STRING> ) <NEWLINE> <DEDENT> for i , area in enumerate ( area_queue ) : <NEWLINE> <INDENT> if i < len ( area_queue ) - 1 : <NEWLINE> <INDENT> print ( area [ 1 ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( area [ 1 ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> rep = [ <NEWLINE> <INDENT> [ 1 , 2 , 4 , 3 , 1 ] , <NEWLINE> [ 2 , 0 , 3 , 5 , 2 ] , <NEWLINE> [ 0 , 1 , 5 , 4 , 0 ] , <NEWLINE> [ 0 , 4 , 5 , 1 , 0 ] , <NEWLINE> [ 0 , 2 , 5 , 3 , 0 ] , <NEWLINE> [ 1 , 3 , 4 , 2 , 1 ] <NEWLINE> <DEDENT> ] <NEWLINE> d = input ( ) . split ( <STRING> ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> for i in range ( 6 ) : <NEWLINE> <INDENT> dic . update ( { d [ i ] : i } ) <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( <STRING> ) <NEWLINE> for j in range ( 4 ) : <NEWLINE> <INDENT> top = dic [ a ] <NEWLINE> front = dic [ b ] <NEWLINE> if ( d [ rep [ top ] [ j ] ] == d [ front ] ) : <NEWLINE> <INDENT> print ( d [ rep [ top ] [ j + 1 ] ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> ans = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> l = gcd ( i , j ) <NEWLINE> ans += gcd ( k , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> result *= A [ i ] <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . find ( self . parents [ x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> return <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> return self . parents [ x ] * ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> friend = UnionFind ( n ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> friend . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , friend . size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> c = [ [ ] for i in range ( n ) ] <NEWLINE> r = [ 0 ] * n <NEWLINE> q = deque ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> c [ a - 1 ] . append ( b - 1 ) <NEWLINE> c [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> q . append ( 0 ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> ix = q . popleft ( ) <NEWLINE> for i in c [ ix ] : <NEWLINE> <INDENT> if r [ i ] == 0 : <NEWLINE> <INDENT> r [ i ] = ix + 1 <NEWLINE> q . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> jg = <STRING> if r . pop ( 0 ) > 0 else <STRING> <NEWLINE> print ( jg ) <NEWLINE> for i in r : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = 1 <NEWLINE> B = 1 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> A = max ( A , B ) <NEWLINE> B = max ( A , B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A % a == 0 : <NEWLINE> <INDENT> aa = A // a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> aa = A // a + 1 <NEWLINE> <DEDENT> if B % b == 0 : <NEWLINE> <INDENT> bb = B // b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bb = B // b + 1 <NEWLINE> <DEDENT> tmp = max ( aa , bb ) <NEWLINE> A = tmp * a <NEWLINE> B = tmp * b <NEWLINE> <NL> <DEDENT> <DEDENT> print ( A + B ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if ( V - W ) * T >= abs ( B - A ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> rank = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 , <STRING> : 3 } <NEWLINE> Card = collections . namedtuple ( <STRING> , [ <STRING> , <STRING> ] ) <NEWLINE> all_cards = { Card ( suit , str ( num ) ) for suit in [ <STRING> , <STRING> , <STRING> , <STRING> ] for num in range ( 1 , 14 ) } <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> cards = { Card ( * input ( ) . split ( ) ) for _ in range ( n ) } <NEWLINE> lost = sorted ( all_cards - cards , key = lambda x : ( rank [ x . suit ] , int ( x . num ) ) ) <NEWLINE> if lost : <NEWLINE> <INDENT> print ( <STRING> . join ( <STRING> % ( suit , num ) for suit , num in lost ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = int ( 1 ) <NEWLINE> a = input ( ) . split ( <STRING> ) <NEWLINE> <NL> if <STRING> in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= int ( a [ i ] ) <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
A , B , C , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> if A + B + C == K : <NEWLINE> <INDENT> print ( A - C ) <NEWLINE> <NL> <DEDENT> elif A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = K - A - B <NEWLINE> <NL> print ( A - t ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i , N ) : <NEWLINE> <INDENT> if all ( <STRING> . count ( c ) == 1 for c in S [ i : j + 1 ] ) : <NEWLINE> <INDENT> ans = max ( ans , j - i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
alp = input ( ) <NEWLINE> if str . isupper ( alp ) == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = sorted ( p ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> q = [ i for i in range ( 0 , 101 + 1 ) ] <NEWLINE> r = [ ] <NEWLINE> <NL> for i in q : <NEWLINE> <INDENT> if i not in p : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> s = [ abs ( x - i ) for i in r ] <NEWLINE> <NL> print ( r [ s . index ( min ( s ) ) ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( list ( s ) ) - 2 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> and s [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> from bisect import bisect_left <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if len ( A ) != len ( set ( A ) ) or len ( B ) != len ( set ( B ) ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> As = set ( A ) <NEWLINE> Bs = set ( B ) <NEWLINE> res = 1 <NEWLINE> for x in reversed ( range ( 1 , n * m + 1 ) ) : <NEWLINE> <INDENT> if x in As and x in Bs : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif x in As : <NEWLINE> <INDENT> res *= m - bisect_left ( B , x ) <NEWLINE> <DEDENT> elif x in Bs : <NEWLINE> <INDENT> res *= n - bisect_left ( A , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = m - bisect_left ( B , x ) <NEWLINE> t = n - bisect_left ( A , x ) <NEWLINE> res *= s * t - ( n * m - x ) <NEWLINE> <DEDENT> res %= mod <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> S = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> C = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> j = n // 2 <NEWLINE> b = n // 2 <NEWLINE> while T [ i ] != S [ j ] and b > 1 : <NEWLINE> <INDENT> if b % 2 == 1 : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> b //= 2 <NEWLINE> if T [ i ] > S [ j ] : <NEWLINE> <INDENT> j += b <NEWLINE> <DEDENT> elif T [ i ] < S [ j ] : <NEWLINE> <INDENT> j -= b <NEWLINE> <DEDENT> if j >= n : <NEWLINE> <INDENT> j = n - 1 <NEWLINE> <DEDENT> elif j < 0 : <NEWLINE> <INDENT> j = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if T [ i ] == S [ j ] : <NEWLINE> <INDENT> C += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if T [ i ] > S [ j ] : <NEWLINE> <INDENT> j += b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j -= b <NEWLINE> <DEDENT> if T [ i ] == S [ j ] : <NEWLINE> <INDENT> C += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( C ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> Am , Bm = map ( int , input ( ) . split ( ) ) <NEWLINE> Am -= 1 <NEWLINE> Bm -= 1 <NEWLINE> A [ Am ] . append ( Bm ) <NEWLINE> A [ Bm ] . append ( Am ) <NEWLINE> <NL> <NL> <DEDENT> is_visited = [ False for _ in range ( N ) ] <NEWLINE> ans = [ 0 for _ in range ( N ) ] <NEWLINE> def bfs ( ) : <NEWLINE> <INDENT> queue = deque ( ) <NEWLINE> queue . append ( 0 ) <NEWLINE> is_visited [ 0 ] = True <NEWLINE> while queue : <NEWLINE> <INDENT> pos = queue . popleft ( ) <NEWLINE> for next_pos in A [ pos ] : <NEWLINE> <INDENT> if is_visited [ next_pos ] == False : <NEWLINE> <INDENT> is_visited [ next_pos ] = True <NEWLINE> queue . append ( next_pos ) <NEWLINE> ans [ next_pos ] = pos <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> bfs ( ) <NEWLINE> <NL> if False in is_visited : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
s = input ( ) [ : : - 1 ] <NEWLINE> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> sum = 0 <NEWLINE> d = 1 <NEWLINE> for c in s : <NEWLINE> <INDENT> sum += int ( c ) * d <NEWLINE> remain = sum % 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> counts [ remain ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for count in counts : <NEWLINE> <INDENT> ans += count * ( count - 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> import re <NEWLINE> num_li = [ False ] * 1000 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> first_ = S . find ( str ( i ) , 0 , N - 2 ) <NEWLINE> if first_ == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> second_ = S . find ( str ( j ) , first_ + 1 , N - 1 ) <NEWLINE> if second_ == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> third_ = S . find ( str ( k ) , second_ + 1 , N ) <NEWLINE> if third_ == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> num_li [ i * 100 + j * 10 + k ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( num_li ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> List = list ( input ( ) ) <NEWLINE> ans = ( List . count ( <STRING> ) ) * ( List . count ( <STRING> ) ) * ( List . count ( <STRING> ) ) <NEWLINE> <NL> for i in range ( 1 , 2000 ) : <NEWLINE> <INDENT> for j in range ( N - i * 2 ) : <NEWLINE> <INDENT> if { List [ j ] , List [ j + i ] , List [ j + 2 * i ] } == { <STRING> , <STRING> , <STRING> } : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = N <NEWLINE> <NL> if ( N >= B - 1 ) : x = B - 1 <NEWLINE> ans = A * ( x % B ) // B <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( range ( 1 , N + 1 ) ) <COMMENT> <NEWLINE> H = [ sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) for i in range ( N - 1 ) ] <COMMENT> <NEWLINE> F = 0 <NEWLINE> tyouten = int ( N * ( N + 1 ) * ( N + 2 ) / 6 ) <NEWLINE> for i in range ( len ( H ) ) : <NEWLINE> <INDENT> F += H [ i ] [ 0 ] * ( N - H [ i ] [ 1 ] + 1 ) <COMMENT> <NEWLINE> <DEDENT> print ( tyouten - F ) <COMMENT> <NEWLINE>
s = input ( ) <NEWLINE> sr = s [ : : - 1 ] <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> st = i + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if sr [ i ] == <STRING> : <NEWLINE> <INDENT> en = len ( s ) - i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( en - st + 1 ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> buff_readline = sys . stdin . readline <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> INF = 2 ** 62 - 1 <NEWLINE> <NL> <NL> def read_int ( ) : <NEWLINE> <INDENT> return int ( buff_readline ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def read_int_n ( ) : <NEWLINE> <INDENT> return list ( map ( int , buff_readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def read_float ( ) : <NEWLINE> <INDENT> return float ( buff_readline ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def read_float_n ( ) : <NEWLINE> <INDENT> return list ( map ( float , buff_readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def read_str ( ) : <NEWLINE> <INDENT> return readline ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def read_str_n ( ) : <NEWLINE> <INDENT> return readline ( ) . strip ( ) . split ( ) <NEWLINE> <NL> <DEDENT> def error_print ( * args ) : <NEWLINE> <INDENT> print ( * args , file = sys . stderr ) <NEWLINE> <NL> <NL> <DEDENT> def mt ( f ) : <NEWLINE> <INDENT> import time <NEWLINE> <NL> def wrap ( * args , ** kwargs ) : <NEWLINE> <INDENT> s = time . time ( ) <NEWLINE> ret = f ( * args , ** kwargs ) <NEWLINE> e = time . time ( ) <NEWLINE> <NL> error_print ( e - s , <STRING> ) <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> return wrap <NEWLINE> <NL> <NL> <DEDENT> @ mt <NEWLINE> def slv ( N , A ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> A . sort ( ) <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = read_int ( ) <NEWLINE> A = read_int_n ( ) <NEWLINE> print ( slv ( N , A ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ int ( x ) for x in list ( str ( n ) ) ] <NEWLINE> result = sum ( l ) <NEWLINE> if result % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> from math import gcd <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> g = A [ 0 ] <NEWLINE> M = max ( A ) <NEWLINE> X = [ i for i in range ( M + 1 ) ] <NEWLINE> S = [ True for i in range ( M + 1 ) ] <NEWLINE> S [ 0 ] = False <NEWLINE> S [ 1 ] = False <NEWLINE> <NL> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if S [ i ] : <NEWLINE> <INDENT> for j in range ( i , M + 1 , i ) : <NEWLINE> <INDENT> if S [ j ] : <NEWLINE> <INDENT> S [ j ] = False <NEWLINE> X [ j ] = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> flag = True <NEWLINE> s = set ( ) <NEWLINE> ls = 0 <NEWLINE> for x in A : <NEWLINE> <INDENT> tmp = set ( ) <NEWLINE> while ( X [ x ] != 1 ) : <NEWLINE> <INDENT> tmp . add ( X [ x ] ) <NEWLINE> x //= X [ x ] <NEWLINE> <DEDENT> l = len ( tmp ) <NEWLINE> s |= tmp <NEWLINE> if len ( s ) == ls + l : <NEWLINE> <INDENT> ls += l <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in A [ 1 : ] : <NEWLINE> <INDENT> g = gcd ( g , x ) <NEWLINE> <DEDENT> if g == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
MOD = 1000000007 <NEWLINE> N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = len ( A ) <NEWLINE> s = 0 <NEWLINE> B = sum ( A ) <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> B -= A [ i ] <NEWLINE> s += A [ i ] * B <NEWLINE> <DEDENT> print ( s % MOD ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> P = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> cnt = 1 <NEWLINE> min_num = P [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if P [ i ] <= min_num : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> min_num = P [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> Pro = 1 <NEWLINE> PrF = 1 <NEWLINE> PrFF = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> PrF = 0 <NEWLINE> <NL> <DEDENT> if PrF : <NEWLINE> <INDENT> for T in range ( 0 , len ( A ) ) : <NEWLINE> <INDENT> Pro = Pro * A [ T ] <NEWLINE> if Pro > pow ( 10 , 18 ) : <NEWLINE> <INDENT> PrFF = 0 <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if PrF & PrFF : <NEWLINE> <INDENT> print ( Pro ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> import bisect <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : x * y / math . gcd ( x , y ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def f ( A , B , x ) : <NEWLINE> <INDENT> return math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> A , B , N = il ( ) <NEWLINE> print ( f ( A , B , min ( B - 1 , N ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> j = n // i <NEWLINE> if n % i == 0 : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> total += j <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE> <NL>
from numba import jit <NEWLINE> @ jit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = - 10 ** 18 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> start , count = i , 1 <NEWLINE> val = c [ start ] <NEWLINE> while p [ start ] - 1 != i : <COMMENT> <NEWLINE> <INDENT> start = p [ start ] - 1 <NEWLINE> count += 1 <NEWLINE> val += c [ start ] <NEWLINE> <DEDENT> start = i <NEWLINE> if val > 0 : <NEWLINE> <INDENT> a = ( k // count - 1 ) * val <COMMENT> <NEWLINE> ans = max ( a , ans ) <NEWLINE> num = count + k % count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> num = min ( k , count ) <NEWLINE> <DEDENT> for _ in range ( num ) : <NEWLINE> <INDENT> start = p [ start ] - 1 <NEWLINE> a += c [ start ] <NEWLINE> ans = max ( a , ans ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
from math import gcd <NEWLINE> ans = 0 <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( k , gcd ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> pair = [ i for i in range ( n ) ] <NEWLINE> a = [ 0 ] * m <NEWLINE> b = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ai , bi = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ i ] = ai - 1 <NEWLINE> b [ i ] = bi - 1 <NEWLINE> <NL> <DEDENT> def root ( x ) : <NEWLINE> <INDENT> if x == pair [ x ] : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = root ( pair [ x ] ) <NEWLINE> pair [ x ] = tmp <NEWLINE> return tmp <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = root ( x ) <NEWLINE> y = root ( y ) <NEWLINE> if x == y : return <NEWLINE> pair [ x ] = y <NEWLINE> <NL> <DEDENT> icnt = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> pair = [ i for i in range ( n ) ] <NEWLINE> for ii in range ( m ) : <NEWLINE> <INDENT> if ii == i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> unite ( a [ ii ] , b [ ii ] ) <NEWLINE> <NL> <DEDENT> l = [ root ( ii ) for ii in range ( n ) ] <NEWLINE> <COMMENT> <NL> lenpair = len ( set ( l ) ) <NEWLINE> if lenpair != 1 : <NEWLINE> <INDENT> icnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( icnt ) <NEWLINE>
class Node ( object ) : <NEWLINE> <INDENT> def __init__ ( self , value , next = None , prev = None ) : <NEWLINE> <INDENT> self . value = value <NEWLINE> self . next = next <NEWLINE> self . prev = prev <NEWLINE> <NL> <DEDENT> <DEDENT> class LinkedList ( object ) : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . dummy = Node ( None ) <NEWLINE> self . dummy . next = self . dummy <NEWLINE> self . dummy . prev = self . dummy <NEWLINE> <NL> <DEDENT> def insert ( self , x ) : <NEWLINE> <INDENT> node = Node ( x , self . dummy . next , self . dummy ) <NEWLINE> <NL> self . dummy . next . prev = node <NEWLINE> self . dummy . next = node <NEWLINE> <NL> <DEDENT> def delete ( self , x ) : <NEWLINE> <INDENT> node = self . dummy . next <NEWLINE> while node != self . dummy : <NEWLINE> <INDENT> if node . value == x : <NEWLINE> <INDENT> self . __remove_node ( node ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node = node . next <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def deleteFirst ( self ) : <NEWLINE> <INDENT> self . __remove_node ( self . dummy . next ) <NEWLINE> <NL> <DEDENT> def deleteLast ( self ) : <NEWLINE> <INDENT> self . __remove_node ( self . dummy . prev ) <NEWLINE> <NL> <DEDENT> def __remove_node ( self , node ) : <NEWLINE> <INDENT> if node != self . dummy : <NEWLINE> <INDENT> node . prev . next = node . next <NEWLINE> node . next . prev = node . prev <NEWLINE> <NL> <DEDENT> <DEDENT> def items ( self ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> node = self . dummy . next <NEWLINE> while node != self . dummy : <NEWLINE> <INDENT> ret . append ( node . value ) <NEWLINE> node = node . next <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> from sys import stdin <NEWLINE> store = LinkedList ( ) <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> parts = stdin . readline ( ) . strip ( ) . split ( ) <NEWLINE> cmd = parts [ 0 ] <NEWLINE> if cmd == <STRING> : <NEWLINE> <INDENT> store . insert ( parts [ 1 ] ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> store . delete ( parts [ 1 ] ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> store . deleteFirst ( ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> store . deleteLast ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( store . items ( ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = a [ 0 ] <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from functools import lru_cache <NEWLINE> <NL> <NL> sys . setrecursionlimit ( 500000 ) <NEWLINE> <NL> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def rec ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> res = n <NEWLINE> i = 1 <NEWLINE> while i <= n : <NEWLINE> <INDENT> res = min ( res , rec ( n - i ) + 1 ) <NEWLINE> i *= 6 <NEWLINE> <DEDENT> i = 9 <NEWLINE> while i <= n : <NEWLINE> <INDENT> res = min ( res , rec ( n - i ) + 1 ) <NEWLINE> i *= 9 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> print ( rec ( N ) ) <NEWLINE> <NL> <NL>
import collections <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list = [ 1 ] <NEWLINE> i = 0 <NEWLINE> num = a [ 0 ] <NEWLINE> for i in range ( 3 * n ) : <NEWLINE> <INDENT> list . append ( num ) <NEWLINE> num = a [ num - 1 ] <NEWLINE> <NL> <DEDENT> cnt = collections . Counter ( list ) <NEWLINE> onevalue = [ k for k , v in cnt . items ( ) if v == 1 ] <NEWLINE> lstart = len ( onevalue ) <NEWLINE> lroop = len ( set ( list ) ) - lstart <NEWLINE> <NL> if k <= lstart : <NEWLINE> <INDENT> num = a [ 0 ] <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> num = a [ num - 1 ] <NEWLINE> <DEDENT> print ( num ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif lstart == 0 : <NEWLINE> <INDENT> k = ( k - lstart ) % lroop <NEWLINE> num = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> num = a [ num - 1 ] <NEWLINE> <DEDENT> print ( num ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = ( k - lstart ) % lroop <NEWLINE> num = a [ 0 ] <NEWLINE> if lstart > 0 : <NEWLINE> <INDENT> for i in range ( lstart - 1 ) : <NEWLINE> <INDENT> num = a [ num - 1 ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> num = a [ num - 1 ] <NEWLINE> <DEDENT> print ( num ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT>
from math import ceil , floor , comb , factorial , gcd , pow , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heappop , heappush <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> if len ( s ) < len ( t ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> reg = - 1 <NEWLINE> for i in range ( len ( s ) - len ( t ) , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ i + j ] != <STRING> and s [ i + j ] != t [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> reg = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if reg == - 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif reg == len ( s ) - len ( t ) : <NEWLINE> <INDENT> s = s [ : i ] + t <NEWLINE> ans = s . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s [ : i ] + t + s [ i + len ( t ) : ] <NEWLINE> ans = s . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> di = [ 0 ] * k <NEWLINE> Ap = [ 0 ] * n <NEWLINE> for i in range ( 0 , k ) : <NEWLINE> <INDENT> di [ i ] = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ai = 0 <NEWLINE> A . append ( - 100 ) <NEWLINE> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if A [ ai ] == j : <NEWLINE> <INDENT> ai = ai + 1 <NEWLINE> Ap [ j - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> num = 0 <NEWLINE> for l in range ( 0 , n ) : <NEWLINE> <INDENT> if Ap [ l ] == 0 : <NEWLINE> <INDENT> num = num + 1 <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
import heapq <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> if n == k : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> pos = [ ] <NEWLINE> neg = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> if a >= 0 : <NEWLINE> <INDENT> pos . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> neg . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if len ( pos ) == 0 and k % 2 == 1 : <NEWLINE> <INDENT> neg . sort ( reverse = True ) <NEWLINE> ans = 1 <NEWLINE> for a in neg [ : k ] : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> pos = [ - x for x in pos ] <NEWLINE> heapq . heapify ( pos ) <NEWLINE> heapq . heapify ( neg ) <NEWLINE> <NL> L_ans = [ ] <NEWLINE> last_pos = None <NEWLINE> last_neg = None <NEWLINE> <NL> ans_is_neg = False <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> if not neg : <NEWLINE> <INDENT> last_pos = - heapq . heappop ( pos ) <NEWLINE> L_ans . append ( last_pos ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if not pos : <NEWLINE> <INDENT> last_neg = heapq . heappop ( neg ) <NEWLINE> L_ans . append ( last_neg ) <NEWLINE> ans_is_neg = not ans_is_neg <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if pos [ 0 ] <= neg [ 0 ] : <NEWLINE> <INDENT> last_pos = - heapq . heappop ( pos ) <NEWLINE> L_ans . append ( last_pos ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if pos [ 0 ] > neg [ 0 ] : <NEWLINE> <INDENT> last_neg = heapq . heappop ( neg ) <NEWLINE> L_ans . append ( last_neg ) <NEWLINE> ans_is_neg = not ans_is_neg <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT> if ans_is_neg : <NEWLINE> <INDENT> if ( last_pos == None ) or ( not neg ) : <NEWLINE> <INDENT> L_ans . remove ( last_neg ) <NEWLINE> L_ans . append ( - heapq . heappop ( pos ) ) <NEWLINE> <NL> <DEDENT> elif not pos : <NEWLINE> <INDENT> L_ans . remove ( last_pos ) <NEWLINE> L_ans . append ( heapq . heappop ( neg ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> new_pos = - pos [ 0 ] <NEWLINE> new_neg = neg [ 0 ] <NEWLINE> <NL> if new_pos * last_pos >= new_neg * last_neg : <NEWLINE> <INDENT> L_ans . remove ( last_neg ) <NEWLINE> L_ans . append ( new_pos ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L_ans . remove ( last_pos ) <NEWLINE> L_ans . append ( new_neg ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for a in L_ans : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> parents = [ - 1 ] * ( n + 1 ) <NEWLINE> def find ( x ) : <NEWLINE> <INDENT> if parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parents [ x ] = find ( parents [ x ] ) <NEWLINE> return parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if parents [ x ] > parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> parents [ x ] += parents [ y ] <NEWLINE> parents [ y ] = x <NEWLINE> <NL> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> return find ( x ) == find ( y ) <NEWLINE> <NL> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> union ( a , b ) <NEWLINE> <NL> <DEDENT> print ( - min ( parents [ 1 : ] ) ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> query = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> query [ a - 1 ] . append ( ( b - 1 , c ) ) <NEWLINE> query [ b - 1 ] . append ( ( a - 1 , c ) ) <NEWLINE> <DEDENT> q , k = map ( int , input ( ) . split ( ) ) <NEWLINE> stack = deque ( [ ( k - 1 , 0 , - 1 ) ] ) <NEWLINE> dist = [ 0 ] * n <NEWLINE> while stack : <NEWLINE> <INDENT> now , cnt , per = stack . pop ( ) <NEWLINE> lis = query [ now ] <NEWLINE> dist [ now ] = cnt <NEWLINE> for nx , c in lis : <NEWLINE> <INDENT> if nx == per : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if c != 0 : <NEWLINE> <INDENT> stack . append ( ( nx , cnt + c , now ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( dist [ x - 1 ] + dist [ y - 1 ] ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( k <= a ) : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif ( k <= ( a + b ) ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = k - ( a + b ) <NEWLINE> print ( a - x ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> col = [ 0 ] * 9 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> j = min ( 8 , a [ i ] // 400 ) <NEWLINE> col [ j ] += 1 <NEWLINE> <DEDENT> zero = 0 <NEWLINE> cnt = 0 <NEWLINE> for c in range ( len ( col ) - 1 ) : <NEWLINE> <INDENT> if col [ c ] == 0 : <NEWLINE> <INDENT> zero += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> m = max ( cnt , 1 ) <NEWLINE> M = cnt + col [ - 1 ] <NEWLINE> print ( m , M ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> list_A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list_B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list_C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list_A . sort ( ) <NEWLINE> list_B . sort ( ) <NEWLINE> list_C . sort ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b = list_B [ i ] <NEWLINE> left = bisect . bisect_left ( list_A , b ) <NEWLINE> right = n - bisect . bisect_right ( list_C , b ) <NEWLINE> ans += left * right <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = x <NEWLINE> ans = a <NEWLINE> flg = [ 0 ] * m <NEWLINE> flg [ a ] = 1 <NEWLINE> l = [ a ] <NEWLINE> lp = - 1 <NEWLINE> <NL> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> if n <= i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> tmp = ( a * a ) % m <NEWLINE> a = tmp <NEWLINE> if flg [ a ] == 1 : <NEWLINE> <INDENT> lp = l . index ( a ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += tmp <NEWLINE> l . append ( a ) <NEWLINE> flg [ a ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if lp != - 1 : <NEWLINE> <INDENT> l2 = l [ lp : ] <NEWLINE> tmp = sum ( l2 ) <NEWLINE> b = ( n - len ( l ) ) // len ( l2 ) <NEWLINE> c = n - len ( l ) - b * len ( l2 ) <NEWLINE> ans = ans + ( b * tmp ) + sum ( l2 [ : c ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> <DEDENT> mod = 998244353 <NEWLINE> N = 2 * 10 ** 5 <NEWLINE> g1 = [ 1 , 1 ] <COMMENT> <NEWLINE> g2 = [ 1 , 1 ] <COMMENT> <NEWLINE> inverse = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <NL> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k == n - 1 : <NEWLINE> <INDENT> print ( pow ( m , n , mod ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> a = m * pow ( m - 1 , n - 1 - k - 1 , mod ) <NEWLINE> <NL> for i in range ( k , - 1 , - 1 ) : <NEWLINE> <INDENT> a = a * ( m - 1 ) % mod <NEWLINE> <NL> ans += a * cmb ( n - 1 , i , mod ) <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n , m = [ int ( w ) for w in input ( ) . split ( ) ] <NEWLINE> ls = [ [ int ( w ) for w in input ( ) . split ( ) ] for _ in range ( n ) ] <NEWLINE> lp = [ [ int ( w ) for w in input ( ) . split ( ) ] for _ in range ( m ) ] <NEWLINE> <NL> for a , b in ls : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> dist = 10e10 <NEWLINE> for i , ( c , d ) in enumerate ( lp ) : <NEWLINE> <INDENT> d = abs ( a - c ) + abs ( b - d ) <NEWLINE> if d < dist : <NEWLINE> <INDENT> ans = i <NEWLINE> dist = d <NEWLINE> <DEDENT> <DEDENT> print ( ans + 1 ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( A ) <NEWLINE> <NL> over4 = [ ] <NEWLINE> over2 = [ ] <NEWLINE> <NL> for k , v in c . items ( ) : <NEWLINE> <INDENT> if v >= 4 : <NEWLINE> <INDENT> over4 . append ( k ) <NEWLINE> <DEDENT> elif v >= 2 : <NEWLINE> <INDENT> over2 . append ( k ) <NEWLINE> <NL> <DEDENT> <DEDENT> over4 . sort ( reverse = True ) <NEWLINE> over2 . sort ( reverse = True ) <NEWLINE> <NL> s1 , s2 , s3 = 0 , 0 , 0 <NEWLINE> if len ( over4 ) > 0 : <NEWLINE> <INDENT> s1 = over4 [ 0 ] ** 2 <NEWLINE> <DEDENT> if len ( over2 ) >= 2 : <NEWLINE> <INDENT> s2 = over2 [ 0 ] * over2 [ 1 ] <NEWLINE> <DEDENT> if len ( over4 ) > 0 and len ( over2 ) > 0 : <NEWLINE> <INDENT> s3 = over4 [ 0 ] * over2 [ 0 ] <NEWLINE> <NL> <DEDENT> print ( max ( s1 , s2 , s3 ) ) <NEWLINE>
A = input ( ) <NEWLINE> <NL> S = 0 <NEWLINE> lis = [ 0 ] * 2019 <NEWLINE> lis [ 0 ] += 1 <NEWLINE> l = len ( A ) + 1 <NEWLINE> d = 1 <NEWLINE> <NL> for n in reversed ( A ) : <NEWLINE> <INDENT> S += int ( n ) * d <NEWLINE> S %= 2019 <NEWLINE> lis [ S ] += 1 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> <NL> <DEDENT> result = 0 <NEWLINE> <NL> for n in lis : <NEWLINE> <INDENT> result += ( n * ( n - 1 ) // 2 ) <NEWLINE> <NL> <NL> <DEDENT> print ( result ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> if X // D <= K : <NEWLINE> <INDENT> print ( min ( abs ( X % D - ( K - ( X // D ) ) % 2 * D ) , abs ( X % D + ( K - ( X // D ) ) % 2 * D ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( abs ( X - K * D ) , abs ( X + K * D ) ) ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> def main ( ) : <NEWLINE> <INDENT> S = deque ( map ( str , input ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> flag = False <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> A = tuple ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> if A [ 0 ] == <STRING> : <NEWLINE> <INDENT> flag = not ( flag ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( A [ 1 ] == <STRING> and not ( flag ) ) or ( A [ 1 ] == <STRING> and flag ) : <NEWLINE> <INDENT> S . appendleft ( A [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . append ( A [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> . join ( S ) [ : : - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( S ) ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_sq_a = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum_sq_a += a [ i ] ** 2 <NEWLINE> <NL> <DEDENT> ans = ( ( sum ( a ) ) ** 2 - sum_sq_a ) // 2 <NEWLINE> <NL> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> num = N // n <NEWLINE> s = ( ( 1 + num ) * num ) // 2 <NEWLINE> sum += n * s <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> <NL> if ( a * b ) < 0 : <NEWLINE> <INDENT> child = max ( a , b ) - min ( a , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> child = abs ( b - a ) <NEWLINE> <NL> <DEDENT> mother = v - w <NEWLINE> if mother <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> n = child / mother <NEWLINE> if n > 0 and n <= t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if 0 <= z and z <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> score = [ 0 ] * n <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> score [ a - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> s = k + score [ i ] - q <NEWLINE> if s > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
from statistics import median <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ None ] * n <NEWLINE> b = [ None ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> if n % 2 == 1 : <NEWLINE> <INDENT> print ( abs ( median ( b ) - median ( a ) ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( abs ( median ( b ) - median ( a ) ) * 2 ) + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> R = S . count ( <STRING> ) <NEWLINE> G = S . count ( <STRING> ) <NEWLINE> B = S . count ( <STRING> ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if j * 2 - i < N : <NEWLINE> <INDENT> if ( S [ i ] != S [ j ] ) and ( S [ i ] != S [ ( j * 2 ) - i ] ) and ( S [ j ] != S [ ( j * 2 ) - i ] ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( R * G * B - cnt ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> lt = len ( T ) <NEWLINE> ls = len ( S ) <NEWLINE> S += <STRING> * lt <NEWLINE> <NL> if ls < lt : <NEWLINE> <INDENT> flg = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( ls - lt + 1 , - 1 , - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> flg = 1 <NEWLINE> for j in range ( i , i + lt ) : <NEWLINE> <INDENT> s = S [ j ] <NEWLINE> <COMMENT> <NL> if s == <STRING> : continue <NEWLINE> if s == <STRING> or s != T [ j - i ] : <NEWLINE> <INDENT> flg = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( ( S [ 0 : i ] + T + S [ i + lt : ls ] ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for ii in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> a . append ( s ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( len ( list ( set ( a ) ) ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 500 * 500 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> edges = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N - 1 ) ] <NEWLINE> tree = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> <NL> for edge in edges : <NEWLINE> <INDENT> tree [ edge [ 0 ] ] . append ( edge [ 1 ] ) <NEWLINE> tree [ edge [ 1 ] ] . append ( edge [ 0 ] ) <NEWLINE> <NL> <DEDENT> depth = [ - 1 ] * ( N + 1 ) <NEWLINE> depth [ 1 ] = 0 <NEWLINE> count = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> count [ p ] += x <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def dfs ( tree , s ) : <NEWLINE> <INDENT> for l in tree [ s ] : <NEWLINE> <INDENT> if depth [ l ] == - 1 : <NEWLINE> <INDENT> depth [ l ] = 0 <NEWLINE> count [ l ] += count [ s ] <NEWLINE> dfs ( tree , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( tree , 1 ) <NEWLINE> <NL> <NL> for i in count [ 1 : ] : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> if a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( ans == - 1 ) : <NEWLINE> <INDENT> ans = a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ( ans > 1e18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> max = 10 ** 18 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> <NL> for num in a : <NEWLINE> <INDENT> ans *= num <NEWLINE> if ans > max : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if a . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> total = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> total *= i <NEWLINE> <NL> if total > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> gachalist = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> gachalist . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( set ( gachalist ) ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> q = deque ( ) <NEWLINE> <NL> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> command_line = input ( ) . split ( <STRING> ) <NEWLINE> command = command_line [ 0 ] <NEWLINE> arg = <STRING> <NEWLINE> if len ( command_line ) > 1 : arg = command_line [ 1 ] <NEWLINE> <NL> if command == <STRING> : <NEWLINE> <INDENT> q . appendleft ( arg ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> q . remove ( arg ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> q . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( q ) ) <NEWLINE>
def _calc_sum ( cache ) : <NEWLINE> <INDENT> sum_value = 0 <NEWLINE> for v , indices in cache . items ( ) : <NEWLINE> <INDENT> sum_value += v * len ( indices ) <NEWLINE> <DEDENT> return sum_value <NEWLINE> <NL> <NL> <DEDENT> def _main ( N , A_list , Q , BC_list ) : <NEWLINE> <INDENT> cache = { } <NEWLINE> for i , a in enumerate ( A_list ) : <NEWLINE> <INDENT> cache . setdefault ( a , [ ] ) . append ( i ) <NEWLINE> <NL> <DEDENT> sum_value = _calc_sum ( cache ) <NEWLINE> <NL> for b , c in BC_list : <NEWLINE> <INDENT> indices = cache . get ( b , [ ] ) <NEWLINE> cache [ b ] = [ ] <NEWLINE> sum_value -= b * len ( indices ) <NEWLINE> cache . setdefault ( c , [ ] ) . extend ( indices ) <NEWLINE> sum_value += c * len ( indices ) <NEWLINE> print ( sum_value ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def _entry ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC_list = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> BC_list . append ( ( B , C ) ) <NEWLINE> <DEDENT> _main ( N , A_list , Q , BC_list ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _entry ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = [ ] <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> bc . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> num = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = a [ i ] <NEWLINE> num [ x ] += 1 <NEWLINE> <NL> <DEDENT> kk = 0 <NEWLINE> for l in range ( 10 ** 5 + 1 ) : <NEWLINE> <INDENT> kk += l * num [ l ] <NEWLINE> <NL> <DEDENT> for k in range ( q ) : <NEWLINE> <INDENT> b = bc [ k ] [ 0 ] <NEWLINE> c = bc [ k ] [ 1 ] <NEWLINE> kk += c * num [ b ] - b * num [ b ] <NEWLINE> num [ c ] += num [ b ] <NEWLINE> num [ b ] = 0 <NEWLINE> print ( kk ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : break <NEWLINE> print ( ( <STRING> * W + <STRING> ) * H ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> S = 1 <NEWLINE> if <STRING> in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> S *= int ( A [ i ] ) <NEWLINE> if S > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if S > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cnt += d [ i - a [ i ] ] <NEWLINE> d [ a [ i ] + i ] += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
def ii ( ) : return int ( input ( ) ) <NEWLINE> def iim ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def iil ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ism ( ) : return map ( str , input ( ) . split ( ) ) <NEWLINE> def isl ( ) : return list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = ii ( ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> baf = s . count ( <STRING> ) <NEWLINE> raf = s . count ( <STRING> ) <NEWLINE> gaf = s . count ( <STRING> ) <NEWLINE> bbf = 0 <NEWLINE> rbf = 0 <NEWLINE> gbf = 0 <NEWLINE> ans = 0 <NEWLINE> for i , item in enumerate ( s ) : <NEWLINE> <INDENT> if item == <STRING> : <NEWLINE> <INDENT> baf -= 1 <NEWLINE> bbf += 1 <NEWLINE> ans += rbf * gaf <NEWLINE> ans += raf * gbf <NEWLINE> <DEDENT> elif item == <STRING> : <NEWLINE> <INDENT> raf -= 1 <NEWLINE> rbf += 1 <NEWLINE> ans += bbf * gaf <NEWLINE> ans += baf * gbf <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gaf -= 1 <NEWLINE> gbf += 1 <NEWLINE> ans += rbf * baf <NEWLINE> ans += raf * bbf <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num = min ( i , n - 1 - i ) <NEWLINE> for j in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> if s [ i - j ] != s [ i + j ] and s [ i - j ] != s [ i ] and s [ i + j ] != s [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans - cnt ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = sorted ( c ) <NEWLINE> result = 0 <NEWLINE> for i in range ( b ) : <NEWLINE> <INDENT> result += d [ i ] <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> C = Counter ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in C : <NEWLINE> <INDENT> if C [ i ] > i : <NEWLINE> <INDENT> ans += C [ i ] - i <NEWLINE> <DEDENT> elif C [ i ] < i : <NEWLINE> <INDENT> ans += C [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> s1 , s2 = [ ] , [ ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> s1 . append ( i ) <NEWLINE> <DEDENT> if s [ i ] == <STRING> and s1 : <NEWLINE> <INDENT> j = s1 . pop ( ) <NEWLINE> a = i - j <NEWLINE> ans += a <NEWLINE> while s2 and s2 [ - 1 ] [ 0 ] > j : <NEWLINE> <INDENT> a += s2 . pop ( ) [ 1 ] <NEWLINE> <DEDENT> s2 . append ( [ j , a ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> print ( len ( s2 ) , * ( a for j , a in s2 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for ele in a : <NEWLINE> <INDENT> ans = ans * ele <NEWLINE> if ans > max : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def f ( n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for aa in a : <NEWLINE> <INDENT> cuta = ( aa - 1 ) // n <COMMENT> <NEWLINE> cnt += cuta <NEWLINE> <DEDENT> if cnt > k : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> l , r = 0 , max ( a ) <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> m = ( r + l ) // 2 <NEWLINE> if f ( m ) : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = m <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
import math <NEWLINE> <NL> class Point ( ) : <NEWLINE> <INDENT> def __init__ ( self , x = None , y = None ) : <NEWLINE> <INDENT> self . x = x <NEWLINE> self . y = y <NEWLINE> <NL> <DEDENT> <DEDENT> class Vector ( ) : <NEWLINE> <INDENT> def __init__ ( self , x , y ) : <NEWLINE> <INDENT> self . x = x <NEWLINE> self . y = y <NEWLINE> self . abs = math . sqrt ( x * x + y * y ) <NEWLINE> <NL> <DEDENT> def constant_multipled ( self , c ) : <NEWLINE> <INDENT> return Vector ( self . x * c , self . y * c ) <NEWLINE> <NL> <DEDENT> def inner_product ( self , vec ) : <NEWLINE> <INDENT> return self . x * vec . x + self . y * vec . y <NEWLINE> <NL> <DEDENT> <DEDENT> x1 , y1 , x2 , y2 = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> start = Point ( x1 , y1 ) <NEWLINE> base_vec = Vector ( x2 - x1 , y2 - y1 ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> vectors = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> x , y = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> vectors . append ( Vector ( x - start . x , y - start . y ) ) <NEWLINE> <NL> <DEDENT> for vec in vectors : <NEWLINE> <INDENT> if vec . abs == 0 : <NEWLINE> <INDENT> ans_x , ans_y = 0 , 0 <NEWLINE> print ( <STRING> % ans_x , <STRING> % ans_y ) <NEWLINE> continue <NEWLINE> <DEDENT> cos = base_vec . inner_product ( vec ) / ( base_vec . abs * vec . abs ) <NEWLINE> b_cos = vec . abs * cos <NEWLINE> vec_x = base_vec . constant_multipled ( b_cos / base_vec . abs ) <NEWLINE> ans_x , ans_y = vec_x . x + start . x , vec_x . y + start . y <NEWLINE> print ( <STRING> % ans_x , <STRING> % ans_y ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> B = sorted ( A , reverse = True ) <NEWLINE> x = B [ 1 ] <NEWLINE> y = B [ 0 ] <NEWLINE> m = A . index ( max ( A ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i == m : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y ) <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> from heapq import heappop , heappush <NEWLINE> manhattan = [ [ abs ( ( i % 4 ) - ( j % 4 ) ) + abs ( ( i // 4 ) - ( j // 4 ) ) for j in range ( 16 ) ] for i in range ( 16 ) ] <NEWLINE> movables = ( ( 1 , 4 ) , ( 0 , 2 , 5 ) , ( 1 , 3 , 6 ) , ( 2 , 7 ) , ( 0 , 5 , 8 ) , ( 1 , 4 , 6 , 9 ) , ( 2 , 5 , 7 , 10 ) , ( 3 , 6 , 11 ) , <NEWLINE> <INDENT> ( 4 , 9 , 12 ) , ( 5 , 8 , 10 , 13 ) , ( 6 , 9 , 11 , 14 ) , ( 7 , 10 , 15 ) , ( 8 , 13 ) , ( 9 , 12 , 14 ) , ( 10 , 13 , 15 ) , ( 11 , 14 ) ) <NEWLINE> <DEDENT> swap_mul = [ [ ( 1 << mf ) - ( 1 << mt ) for mt in range ( 0 , 64 , 4 ) ] for mf in range ( 0 , 64 , 4 ) ] <NEWLINE> destination = 0xfedcba9876543210 <NEWLINE> i = 0 <NEWLINE> board_init = 0 <NEWLINE> blank_init = 0 <NEWLINE> for _ in range ( 4 ) : <NEWLINE> <INDENT> for n in map ( int , stdin . readline ( ) . split ( ) ) : <NEWLINE> <INDENT> if n : <NEWLINE> <INDENT> n -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = 15 <NEWLINE> blank_init = i <NEWLINE> <DEDENT> board_init += n * 16 ** i <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> estimation_init = sum ( manhattan [ i ] [ ( ( board_init >> ( 4 * i ) ) & 15 ) ] for i in range ( 16 ) if i != blank_init ) <NEWLINE> queue = [ ( estimation_init , board_init , blank_init ) ] <NEWLINE> visited = set ( ) <NEWLINE> while True : <NEWLINE> <INDENT> estimation , board , blank = heappop ( queue ) <NEWLINE> if board in visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif board == destination : <NEWLINE> <INDENT> print ( estimation ) <NEWLINE> break <NEWLINE> <DEDENT> visited . add ( board ) <NEWLINE> for new_blank in movables [ blank ] : <NEWLINE> <INDENT> num = ( board >> ( 4 * new_blank ) ) & 15 <NEWLINE> new_board = board + swap_mul [ new_blank ] [ blank ] * ( 15 - num ) <NEWLINE> if new_board in visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> new_estimation = estimation + 1 - manhattan [ new_blank ] [ num ] + manhattan [ blank ] [ num ] <NEWLINE> if new_estimation > 45 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> heappush ( queue , ( new_estimation , new_board , new_blank ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> list = [ ] <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : <NEWLINE> <INDENT> list . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( end = <STRING> ) <NEWLINE> print ( * list ) <NEWLINE>
S = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> S . reverse ( ) <NEWLINE> a = [ 0 ] * len ( S ) <NEWLINE> y = 2019 <NEWLINE> x = 1 <NEWLINE> t = 0 <NEWLINE> cnt = [ 0 ] * y <NEWLINE> res = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> cnt [ t ] += 1 <NEWLINE> t += S [ i ] * x <NEWLINE> t %= y <NEWLINE> res += cnt [ t ] <NEWLINE> x = x * 10 % y <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> road_list = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> road_list . append ( [ ] ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> H_a , H_b = [ H_list [ a - 1 ] , H_list [ b - 1 ] ] <NEWLINE> <NL> if H_a <= H_b : <NEWLINE> <INDENT> road_list [ a - 1 ] . append ( b ) <NEWLINE> <NL> <DEDENT> if H_b <= H_a : <NEWLINE> <INDENT> road_list [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for road in road_list : <NEWLINE> <INDENT> if len ( road ) == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> if 2 * j - i >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif s [ i ] != s [ j ] and s [ j ] != s [ ( 2 * j - i ) ] and s [ ( 2 * j - i ) ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> class DAG : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . n = n <NEWLINE> self . adj = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> <DEDENT> def addEdge ( self , parent , child ) : <NEWLINE> <INDENT> self . adj [ parent ] . append ( child ) <NEWLINE> <NL> <DEDENT> def dfs ( self , node ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for child in self . adj [ node ] : <NEWLINE> <INDENT> ans = max ( ans , 1 + self . dfs ( child ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def dfsWithMemo ( self , node , memo , visited ) : <NEWLINE> <INDENT> if ( visited [ node ] ) : <NEWLINE> <INDENT> return memo [ node ] <NEWLINE> <DEDENT> visited [ node ] = True <NEWLINE> for child in self . adj [ node ] : <NEWLINE> <INDENT> memo [ node ] = max ( <NEWLINE> <INDENT> memo [ node ] , 1 + self . dfsWithMemo ( child , memo , visited ) ) <NEWLINE> <DEDENT> <DEDENT> return memo [ node ] <NEWLINE> <NL> <DEDENT> def dfsWithDp ( self , node , dp , visited ) : <NEWLINE> <INDENT> if ( visited [ node ] ) : <NEWLINE> <INDENT> return dp [ node ] <NEWLINE> <DEDENT> visited [ node ] = True <NEWLINE> for child in self . adj [ node ] : <NEWLINE> <INDENT> if not visited [ child ] : <NEWLINE> <INDENT> self . dfsWithDp ( child , dp , visited ) <NEWLINE> <DEDENT> dp [ node ] = max ( dp [ node ] , 1 + self . dfsWithDp ( child , dp , visited ) ) <NEWLINE> <DEDENT> return dp [ node ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def findLongestPathNaive ( self ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> ans = max ( ans , self . dfs ( i ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def findLongestPathWithMemo ( self ) : <NEWLINE> <INDENT> visited = [ False ] * self . n <NEWLINE> memo = [ 0 ] * self . n <NEWLINE> ans = 0 <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> ans = max ( ans , self . dfsWithMemo ( i , memo , visited ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def findLongestPathWithDp ( self ) : <NEWLINE> <INDENT> visited = [ False ] * self . n <NEWLINE> dp = [ 0 ] * self . n <COMMENT> <NEWLINE> ans = 0 <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> ans = max ( ans , self . dfsWithDp ( i , dp , visited ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> dag = DAG ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> parent , child = map ( lambda i : int ( i ) - 1 , input ( ) . split ( ) ) <NEWLINE> dag . addEdge ( parent , child ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( dag . findLongestPathWithMemo ( ) ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> if a [ K + i - 1 ] > a [ i - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> a = [ 0 ] <NEWLINE> a [ 0 ] = 7 % K <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> a . append ( ( a [ i ] * 10 + 7 ) % K ) <NEWLINE> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> now = k <NEWLINE> r = 0 <NEWLINE> for i in range ( 1 , k + 100 ) : <NEWLINE> <INDENT> r = ( r * 10 % k + 7 ) % k <NEWLINE> if r == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> m_a = max ( A ) + 1 <NEWLINE> B = [ 0 ] * ( m_a ) <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> B [ i ] += 1 <NEWLINE> if B [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( i * 2 , m_a , i ) : <NEWLINE> <INDENT> B [ j ] += 100 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( B . count ( 1 ) ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <NL> in_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = in_a [ 0 ] <NEWLINE> B = in_a [ 1 ] <NEWLINE> N = in_a [ 2 ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if ( B > N ) : <NEWLINE> <INDENT> X = N <NEWLINE> ans = math . floor ( A * X / B ) - ( A * math . floor ( X / B ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> X = B - 1 <NEWLINE> ans = math . floor ( A * X / B ) - ( A * math . floor ( X / B ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> from collections import deque <NEWLINE> b = deque ( [ ] ) <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> b . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . appendleft ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> print ( * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( * reversed ( b ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> def insertion_sort ( A , N , diff , cnt ) : <NEWLINE> <INDENT> for i in range ( diff , N ) : <NEWLINE> <INDENT> tmp_num = A [ i ] <NEWLINE> j = i - diff <NEWLINE> while j >= 0 and A [ j ] > tmp_num : <NEWLINE> <INDENT> A [ j + diff ] = A [ j ] <NEWLINE> j = j - diff <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + diff ] = tmp_num <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> divide_cnt = 0 <NEWLINE> diffs = [ ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> diffs . append ( 1 ) <NEWLINE> divide_cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> quotient = N <NEWLINE> while quotient != 1 : <NEWLINE> <INDENT> quotient = quotient // 2 <NEWLINE> diffs . append ( quotient ) <NEWLINE> divide_cnt += 1 <NEWLINE> <DEDENT> <DEDENT> for diff in diffs : <NEWLINE> <INDENT> cnt = insertion_sort ( A , N , diff , cnt ) <NEWLINE> <DEDENT> print ( divide_cnt ) <NEWLINE> print ( <STRING> . join ( map ( str , diffs ) ) ) <NEWLINE> print ( cnt ) <NEWLINE> for num in A : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> length = len ( list ( T ) ) <NEWLINE> S_length = len ( list ( S ) ) <NEWLINE> <NL> max_score = 0 <NEWLINE> for i in range ( len ( list ( S ) ) - len ( list ( T ) ) ) : <NEWLINE> <INDENT> tmp_T = np . array ( list ( T ) ) <NEWLINE> tmp_S = np . array ( list ( S ) ) [ i : i + len ( tmp_T ) ] <NEWLINE> score = np . zeros ( len ( tmp_T ) ) <NEWLINE> score [ tmp_T == tmp_S ] = 1 <NEWLINE> score = np . sum ( score ) <NEWLINE> if max_score < score : <NEWLINE> <INDENT> max_score = score <NEWLINE> <NL> <DEDENT> <DEDENT> if S_length == length : <NEWLINE> <INDENT> tmp_T = np . array ( list ( T ) ) <NEWLINE> tmp_S = np . array ( list ( S ) ) <NEWLINE> score = np . zeros ( len ( tmp_T ) ) <NEWLINE> score [ tmp_T == tmp_S ] = 1 <NEWLINE> max_score = np . sum ( score ) <NEWLINE> <DEDENT> print ( int ( length - max_score ) ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] [ : : - 1 ] <NEWLINE> <NL> color_num = [ a [ 0 ] ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if a [ i ] >= color_num [ - 1 ] : <NEWLINE> <INDENT> color_num . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = bisect . bisect_right ( color_num , a [ i ] ) <NEWLINE> color_num [ temp ] = a [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( len ( color_num ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> n_list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> n_list . sort ( ) <NEWLINE> n_list = list ( reversed ( n_list ) ) <NEWLINE> if 0 in n_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in n_list : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> import copy <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> count = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> count *= A [ i ] <NEWLINE> if count > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , read ( ) . split ( ) ) <NEWLINE> s = np . array ( [ [ i == <STRING> for i in read ( ) ] for _ in range ( h ) ] , dtype = int ) <NEWLINE> left = np . zeros ( ( h , w ) , dtype = int ) <NEWLINE> right = np . zeros ( ( h , w ) , dtype = int ) <NEWLINE> up = np . zeros ( ( h , w ) , dtype = int ) <NEWLINE> down = np . zeros ( ( h , w ) , dtype = int ) <NEWLINE> left [ : , 0 ] = s [ : , 0 ] <NEWLINE> right [ : , - 1 ] = s [ : , - 1 ] <NEWLINE> for i in range ( w - 1 ) : <NEWLINE> <INDENT> left [ : , i + 1 ] = ( left [ : , i ] + 1 ) * s [ : , i + 1 ] <NEWLINE> right [ : , - i - 2 ] = ( right [ : , - i - 1 ] + 1 ) * s [ : , - i - 2 ] <NEWLINE> <DEDENT> up [ 0 ] = s [ 0 ] <NEWLINE> down [ - 1 ] = s [ - 1 ] <NEWLINE> for i in range ( h - 1 ) : <NEWLINE> <INDENT> up [ i + 1 ] = ( up [ i ] + 1 ) * s [ i + 1 ] <NEWLINE> down [ - i - 2 ] = ( down [ - i - 1 ] + 1 ) * s [ - i - 2 ] <NEWLINE> <DEDENT> print ( ( left + right + up + down ) . max ( ) - 3 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) ; y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = sum ( [ 1 for i in uf . parents if i < 0 ] ) - 1 <NEWLINE> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a1 , a2 = [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a1 . append ( i + a [ i ] ) <NEWLINE> a2 . append ( i - a [ i ] ) <NEWLINE> <DEDENT> a1 , a2 = Counter ( a1 ) , Counter ( a2 ) <NEWLINE> rng = max ( a2 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , rng + 1 ) : <NEWLINE> <INDENT> if i in a1 and i in a2 : <NEWLINE> <INDENT> ans += a1 [ i ] * a2 [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> print ( sum ( p [ : K ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> if n < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> a = [ 0 ] * ( n ) <NEWLINE> a [ 0 ] = 0 <NEWLINE> a [ 1 ] = 0 <NEWLINE> a [ 2 ] = 1 <NEWLINE> for i in range ( 3 , n ) : <NEWLINE> <INDENT> a [ i ] = ( a [ i - 3 ] + a [ i - 1 ] ) % mod <NEWLINE> <DEDENT> print ( a [ n - 1 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> from sys import setrecursionlimit <NEWLINE> setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> xl = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xl = list ( map ( lambda y : abs ( y - x ) , xl ) ) <NEWLINE> <NL> ans = - 1 <NEWLINE> if len ( xl ) == 1 : <NEWLINE> <INDENT> ans = xl [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = gcd ( * xl ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = sum ( p [ : k ] ) <NEWLINE> q = [ ans ] <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> ans = ans + p [ i ] - p [ i - k ] <NEWLINE> q . append ( ans ) <NEWLINE> <DEDENT> print ( ( max ( q ) + k ) / 2 ) <NEWLINE>
H , W , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> HW = set ( tuple ( int ( x ) - 1 for x in input ( ) . split ( ) ) for _ in range ( M ) ) <NEWLINE> h = [ 0 ] * H <NEWLINE> w = [ 0 ] * W <NEWLINE> for hi , wi in HW : <NEWLINE> <INDENT> h [ hi ] += 1 <NEWLINE> w [ wi ] += 1 <NEWLINE> <DEDENT> hm = max ( h ) <NEWLINE> wm = max ( w ) <NEWLINE> <NL> hh = [ i for i , v in enumerate ( h ) if v == hm ] <NEWLINE> ww = [ i for i , v in enumerate ( w ) if v == wm ] <NEWLINE> <NL> ans = hm + wm - 1 <NEWLINE> for h in hh : <NEWLINE> <INDENT> for w in ww : <NEWLINE> <INDENT> if ( h , w ) not in HW : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> print ( ans [ j ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> pos = k + i <NEWLINE> if A [ pos ] > A [ pos - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( sum ( S - K <= X + Y <= S for X in range ( K + 1 ) for Y in range ( K + 1 ) ) ) <NEWLINE>
<COMMENT> <NL> <NL> rank = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> ref0 = [ 35.5 , 37.5 , 40.0 , 43.0 , 50.0 , 55.0 , 70.0 ] <NEWLINE> ref1 = [ 71.0 , 77.0 , 83.0 , 89.0 , 105.0 , 116.0 , 148.0 ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> t1 , t2 = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( len ( rank ) ) : <NEWLINE> <INDENT> if t1 < ref0 [ i ] and t2 < ref1 [ i ] : <NEWLINE> <INDENT> print rank [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = sorted ( a , reverse = True ) <NEWLINE> res = a [ 0 ] <NEWLINE> for ai in a [ 1 : ] : <NEWLINE> <INDENT> res *= ai <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
r_c_str = input ( ) . split ( ) <NEWLINE> r_c = list ( map ( lambda i : int ( i ) , r_c_str ) ) <NEWLINE> r = r_c [ 0 ] <NEWLINE> c = r_c [ 1 ] <NEWLINE> s_str = [ input ( ) for i in range ( r ) ] <NEWLINE> s_str = [ i . split ( ) for i in s_str ] <NEWLINE> s = [ ] <NEWLINE> for i in s_str : <NEWLINE> <INDENT> s . append ( list ( map ( lambda j : int ( j ) , i ) ) ) <NEWLINE> <DEDENT> for i in range ( r ) : <NEWLINE> <INDENT> s [ i ] . append ( sum ( s [ i ] ) ) <NEWLINE> <DEDENT> s . append ( [ ] ) <NEWLINE> for i in range ( c + 1 ) : <NEWLINE> <INDENT> s [ - 1 ] . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( c ) : <NEWLINE> <INDENT> for j in range ( r ) : <NEWLINE> <INDENT> s [ r ] [ i ] += s [ j ] [ i ] <NEWLINE> <DEDENT> <DEDENT> s [ - 1 ] [ - 1 ] += sum ( s [ r ] ) <NEWLINE> for i in s : <NEWLINE> <INDENT> print ( * i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> f = 0 <NEWLINE> arr . sort ( ) <NEWLINE> for i in arr : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> f = 1 <NEWLINE> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for a in As : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans = min ( ans , 10 ** 18 + 1 ) <NEWLINE> <NL> <DEDENT> if ans == 10 ** 18 + 1 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math , itertools <NEWLINE> from functools import reduce <NEWLINE> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return ( reduce ( math . gcd , numbers ) ) <NEWLINE> <DEDENT> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for numbers in itertools . combinations_with_replacement ( range ( 1 , k + 1 ) , 3 ) : <NEWLINE> <INDENT> a , b , c = numbers <NEWLINE> if a == b == c : <NEWLINE> <INDENT> ans += gcd_list ( numbers ) <NEWLINE> <DEDENT> elif a != b and a != c and b != c : <NEWLINE> <INDENT> ans += 6 * gcd_list ( numbers ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 3 * gcd_list ( numbers ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Ai = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 1 <NEWLINE> i = 0 <NEWLINE> if 0 in Ai : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while i <= N - 1 : <NEWLINE> <INDENT> p = p * Ai [ i ] <NEWLINE> if p > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if i == N - 1 : <NEWLINE> <INDENT> print ( p ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> next = 1 <NEWLINE> List = [ - 1 ] * N <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if List [ next - 1 ] == - 1 : <NEWLINE> <INDENT> List [ next - 1 ] = i <NEWLINE> next = A [ next - 1 ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> loop = i - List [ next - 1 ] <NEWLINE> afterloop = ( K - ( i - loop ) ) % loop <NEWLINE> print ( List . index ( ( i - loop ) + afterloop ) + 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( next ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) ) <NEWLINE> visit = [ False ] * N <NEWLINE> a_now = 1 <NEWLINE> visit [ a_now - 1 ] = True <NEWLINE> step = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a_now = A [ a_now - 1 ] <NEWLINE> step += 1 <NEWLINE> <COMMENT> <NL> if visit [ a_now - 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visit [ a_now - 1 ] = True <NEWLINE> <DEDENT> if step == K : <NEWLINE> <COMMENT> <NL> <INDENT> print ( a_now ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> self_loop = [ ] <NEWLINE> start = a_now <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a_now = A [ a_now - 1 ] <NEWLINE> step += 1 <NEWLINE> self_loop . append ( a_now ) <NEWLINE> if a_now == start : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if step == K : <NEWLINE> <COMMENT> <NL> <INDENT> print ( a_now ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> n = len ( self_loop ) <NEWLINE> left = K - step <NEWLINE> left -= ( left // n ) * n <NEWLINE> <COMMENT> <NL> print ( self_loop [ left - 1 ] ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from collections import Counter <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> n , k = readInts ( ) <NEWLINE> a = readInts ( ) <NEWLINE> <NL> <NL> t = a [ 0 ] <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> be = a [ i - k ] <NEWLINE> af = a [ i ] <NEWLINE> <COMMENT> <NL> if be >= af : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> ans = 0 <NEWLINE> K = int ( input ( ) ) <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( tmp , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> prim_no = { 2 : True } <COMMENT> <NEWLINE> <NL> def is_prime ( no ) : <NEWLINE> <INDENT> if no == 2 or no == 1 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> if no % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> if prim_no . get ( no ) is not None : <NEWLINE> <INDENT> return prim_no . get ( no ) <NEWLINE> <NL> <DEDENT> max_check = int ( math . sqrt ( no ) ) <NEWLINE> for i in range ( 3 , max_check + 1 , 2 ) : <NEWLINE> <INDENT> if no % i == 0 : <NEWLINE> <INDENT> prim_no [ no ] = False <NEWLINE> return False <NEWLINE> <NL> <DEDENT> <DEDENT> prim_no [ no ] = True <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> prim_vals = { } <COMMENT> <NEWLINE> while True : <NEWLINE> <INDENT> num = sys . stdin . readline ( ) <NEWLINE> if num is None or num . strip ( ) == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> num = int ( num . strip ( ) ) <NEWLINE> if prim_vals . get ( num ) is not None : <NEWLINE> <INDENT> cnt = prim_vals . get ( num ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if num == 1 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <COMMENT> <NL> if num % 2 == 0 : <NEWLINE> <INDENT> start_num = num - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start_num = num <NEWLINE> <NL> <DEDENT> for i in range ( start_num , 0 , - 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if prim_vals . get ( i ) is not None : <NEWLINE> <INDENT> cnt += prim_vals . get ( i ) <NEWLINE> <COMMENT> <NL> break <NEWLINE> <NL> <DEDENT> if is_prime ( i ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> prim_vals [ num ] = cnt <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> <NL> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> a = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> a = ( a * 10 + 7 ) % k <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
N = input ( ) <NEWLINE> <NL> if int ( N ) % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> f = [ - 1 ] * n <NEWLINE> f [ 0 ] = 0 <NEWLINE> s1 , s2 , g1 , g2 = 0 , 0 , 0 , 0 <NEWLINE> j = a [ 0 ] - 1 <NEWLINE> jpre = 0 <NEWLINE> c = 1 <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if i >= k : <NEWLINE> <INDENT> s1 , s2 = f [ jpre ] , jpre <NEWLINE> g1 , g2 = 0 , 0 <NEWLINE> break <NEWLINE> <DEDENT> if f [ j ] != - 1 : <NEWLINE> <INDENT> s1 , s2 = f [ jpre ] , jpre <NEWLINE> g1 , g2 = f [ j ] , j <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f [ j ] = c <NEWLINE> c += 1 <NEWLINE> jpre = j <NEWLINE> j = a [ j ] - 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> ans = ( k - g1 ) % ( s1 - g1 + 1 ) + f [ g2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if f [ i ] == ans : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> p . append ( s ) <NEWLINE> <DEDENT> print ( len ( set ( p ) ) ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> n = int ( readline ( ) ) <NEWLINE> a = np . array ( readline ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> ai = np . argsort ( a ) [ : : - 1 ] <NEWLINE> a = a [ ai ] <NEWLINE> ai += 1 <NEWLINE> <NL> dp = np . zeros ( n + 1 , np . int64 ) <NEWLINE> for k , ( i , e ) in enumerate ( zip ( ai , a ) , 1 ) : <NEWLINE> <INDENT> dp_new = dp . copy ( ) <NEWLINE> <NL> add_left = e * abs ( np . arange ( 1 , k + 1 ) - i ) <NEWLINE> dp_new [ 1 : k + 1 ] = np . maximum ( dp_new [ 1 : k + 1 ] , dp [ : k ] + add_left ) <NEWLINE> <NL> add_right = e * abs ( np . arange ( n - k + 1 , n + 1 ) - i ) <NEWLINE> dp_new [ : k ] = np . maximum ( dp_new [ : k ] , dp [ : k ] + add_right ) <NEWLINE> <NL> dp = dp_new . copy ( ) <NEWLINE> <NL> <DEDENT> ans = max ( dp ) <NEWLINE> print ( ans ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> strA = input ( ) . split ( ) <NEWLINE> ans = collections . Counter ( strA ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ str ( i ) ] ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> abcd_list = [ ] <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> abcd_list . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> list_tmp = [ ] <NEWLINE> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> list_tmp . append ( i ) <NEWLINE> <NL> <DEDENT> comb_A = list ( itertools . combinations_with_replacement ( list_tmp , N ) ) <NEWLINE> <NL> <NL> max_score = 0 <NEWLINE> for A in comb_A : <NEWLINE> <INDENT> tmp_score = 0 <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> A_a = A [ abcd_list [ q ] [ 0 ] - 1 ] <NEWLINE> A_b = A [ abcd_list [ q ] [ 1 ] - 1 ] <NEWLINE> <NL> if ( A_b - A_a == abcd_list [ q ] [ 2 ] ) : <NEWLINE> <INDENT> tmp_score += abcd_list [ q ] [ 3 ] <NEWLINE> <NL> <DEDENT> <DEDENT> max_score = max ( max_score , tmp_score ) <NEWLINE> <NL> <DEDENT> print ( max_score ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 1 <NEWLINE> i = 1 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> total = total * li [ i ] <NEWLINE> if total > 1000000000000000000 : <NEWLINE> <INDENT> total = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> if li [ i ] == 0 : <NEWLINE> <INDENT> total = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <COMMENT> <NL> <DEDENT> nque = deque ( [ 1 ] ) <NEWLINE> while nque : <NEWLINE> <INDENT> now_cave = nque . popleft ( ) <NEWLINE> for next_cave in g [ now_cave ] : <NEWLINE> <INDENT> if ans [ next_cave ] == 0 : <NEWLINE> <INDENT> ans [ next_cave ] = now_cave <NEWLINE> nque . append ( next_cave ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> while i < K : <NEWLINE> <INDENT> if B <= A : <NEWLINE> <INDENT> B *= 2 <NEWLINE> <DEDENT> elif C <= B : <NEWLINE> <INDENT> C *= 2 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> if A < B < C : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> N_all = int ( readline ( ) ) <NEWLINE> A_all = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> A = [ A_all [ 0 ] ] <NEWLINE> for i in range ( 1 , N_all ) : <NEWLINE> <INDENT> if A [ - 1 ] != A_all [ i ] : <NEWLINE> <INDENT> A . append ( A_all [ i ] ) <NEWLINE> <DEDENT> <DEDENT> N = len ( A ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1000 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> money = 1000 <NEWLINE> kabu = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if A [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kabu = money // A [ i ] <NEWLINE> money -= kabu * A [ i ] <NEWLINE> <DEDENT> <DEDENT> elif i == N - 1 : <NEWLINE> <INDENT> money += A [ i ] * kabu <NEWLINE> kabu = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A [ i - 1 ] < A [ i ] and A [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> money += A [ i ] * kabu <NEWLINE> kabu = 0 <NEWLINE> <DEDENT> if A [ i - 1 ] > A [ i ] and A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> kabu = money // A [ i ] <NEWLINE> money -= kabu * A [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( money ) <NEWLINE>
s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sunuke = [ ] <NEWLINE> ans = 0 <NEWLINE> for n in range ( s [ 0 ] ) : <NEWLINE> <INDENT> sunuke . append ( 0 ) <NEWLINE> <DEDENT> for n in range ( s [ 1 ] ) : <NEWLINE> <INDENT> d = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for n2 in a : <NEWLINE> <INDENT> sunuke [ n2 - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for n in sunuke : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> n = len ( a ) <NEWLINE> <NL> s = 0 <COMMENT> <NEWLINE> c = [ 0 ] * 2019 <COMMENT> <NEWLINE> c [ s ] += 1 <NEWLINE> d = 1 <COMMENT> <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = ( s + d * int ( a [ n - i - 1 ] ) ) % 2019 <COMMENT> <NEWLINE> d = d * 10 % 2019 <COMMENT> <NEWLINE> c [ s ] += 1 <NEWLINE> <NL> <DEDENT> print ( int ( sum ( [ i * ( i - 1 ) / 2 for i in c ] ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> hoge = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> hoge = hoge + A [ i ] <NEWLINE> hoge = hoge % mod <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> hoge = hoge - A [ i ] <NEWLINE> if hoge < 0 : <NEWLINE> <INDENT> hoge = hoge + mod <NEWLINE> <DEDENT> ans = ans + A [ i ] * hoge <NEWLINE> ans = ans % mod <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> cntH = { } <NEWLINE> cntW = { } <NEWLINE> bomb = set ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> bomb . add ( ( h - 1 , w - 1 ) ) <NEWLINE> cntH [ h - 1 ] = cntH . get ( h - 1 , 0 ) + 1 <NEWLINE> cntW [ w - 1 ] = cntW . get ( w - 1 , 0 ) + 1 <NEWLINE> <NL> <DEDENT> maxH , maxW = max ( cntH . values ( ) ) , max ( cntW . values ( ) ) <NEWLINE> max_H_list = [ kv [ 0 ] for kv in cntH . items ( ) if kv [ 1 ] == maxH ] <NEWLINE> max_W_list = [ kv [ 0 ] for kv in cntW . items ( ) if kv [ 1 ] == maxW ] <NEWLINE> <NL> ans = maxH + maxW - 1 <NEWLINE> flag = False <NEWLINE> for i in max_H_list : <NEWLINE> <INDENT> for j in max_W_list : <NEWLINE> <INDENT> if ( i , j ) not in bomb : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def mitsui2019d_lucky_pin ( ) : <NEWLINE> <INDENT> import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> cnt = 0 <NEWLINE> for t in itertools . product ( range ( 0 , 10 ) , repeat = 2 ) : <NEWLINE> <INDENT> si = <STRING> . join ( map ( str , t ) ) <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if si [ 0 ] != s [ i ] : continue <NEWLINE> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> if si [ 1 ] != s [ j ] : continue <NEWLINE> ss = set ( list ( s [ j + 1 : ] ) ) <NEWLINE> cnt += len ( ss ) <NEWLINE> break <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> mitsui2019d_lucky_pin ( ) <NEWLINE>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ 0 for i in range ( H ) ] <NEWLINE> w = [ 0 for i in range ( W ) ] <NEWLINE> DP = set ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> hh , ww = map ( int , input ( ) . split ( ) ) <NEWLINE> h [ hh - 1 ] += 1 <NEWLINE> w [ ww - 1 ] += 1 <NEWLINE> DP . add ( ( hh - 1 , ww - 1 ) ) <NEWLINE> <NL> <DEDENT> hhh = max ( h ) <NEWLINE> www = max ( w ) <NEWLINE> hhhh = [ i for i , x in enumerate ( h ) if x == hhh ] <NEWLINE> wwww = [ i for i , x in enumerate ( w ) if x == www ] <NEWLINE> check = 0 <NEWLINE> <NL> for i in hhhh : <NEWLINE> <INDENT> for j in wwww : <NEWLINE> <INDENT> if ( i , j ) not in DP : <NEWLINE> <INDENT> print ( hhh + www ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( hhh + www - 1 ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> if s == <STRING> * len ( s ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> idx = i <NEWLINE> num = s [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if idx >= k : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> center1 = ( m + 1 ) // 2 <NEWLINE> center2 = center1 + m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> a = center1 - i // 2 <NEWLINE> b = center1 + i // 2 + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = center2 - i // 2 <NEWLINE> b = center2 + ( i + 1 ) // 2 + 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> i = 1 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> x = int ( sys . stdin . readline ( ) ) <NEWLINE> if ( x == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> % ( i , x ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> s = S ( ) <NEWLINE> n = len ( s ) <NEWLINE> a = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if <STRING> == s [ i ] : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] + 1 <NEWLINE> <DEDENT> <DEDENT> for i in reversed ( range ( len ( s ) ) ) : <NEWLINE> <INDENT> if <STRING> == s [ i ] : <NEWLINE> <INDENT> a [ i ] = max ( a [ i ] , a [ i + 1 ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
<COMMENT> <NL> import bisect <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> g [ u ] . append ( v ) <NEWLINE> g [ v ] . append ( u ) <NEWLINE> <NL> <DEDENT> def dfs ( now , par ) : <NEWLINE> <INDENT> idx = bisect . bisect_left ( dp , a [ now ] ) <NEWLINE> tmp = dp [ idx ] <NEWLINE> dp [ idx ] = a [ now ] <NEWLINE> <COMMENT> <NL> if ans [ par ] <= idx : <NEWLINE> <INDENT> ans [ now ] = idx <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans [ now ] = ans [ par ] <NEWLINE> <NL> <DEDENT> for i in g [ now ] : <NEWLINE> <INDENT> if i != par : <NEWLINE> <COMMENT> <NL> <INDENT> dfs ( i , now ) <NEWLINE> <DEDENT> <DEDENT> dp [ idx ] = tmp <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> dp = [ - INF ] + [ INF ] * n <NEWLINE> dfs ( 0 , - 1 ) <NEWLINE> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
import os <NEWLINE> import sys <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> <NL> def solve ( inp ) : <NEWLINE> <INDENT> def mod_pow ( x , a , MOD ) : <NEWLINE> <INDENT> ret = 1 <NEWLINE> cur = x <NEWLINE> while a : <NEWLINE> <INDENT> if a & 1 : <NEWLINE> <INDENT> ret = ret * cur % MOD <NEWLINE> <DEDENT> cur = cur * cur % MOD <NEWLINE> a >>= 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> h = inp [ 0 ] <NEWLINE> ppp = inp [ 1 : ] <NEWLINE> n = 1 << ( h - 1 ) <NEWLINE> ppp += n - 1 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> cumprods = np . ones ( 2 * n , dtype = np . int64 ) <NEWLINE> cumprods_rev = np . ones ( n , dtype = np . int64 ) <NEWLINE> cumprods_through = np . zeros ( n , dtype = np . int64 ) <NEWLINE> for i in range ( 2 , 2 * n ) : <NEWLINE> <INDENT> cumprods [ i ] = cumprods [ i >> 1 ] * i % MOD <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> cumprods_rev [ i ] = mod_pow ( cumprods [ i ] , MOD - 2 , MOD ) <NEWLINE> cumprods_through [ i ] = cumprods [ i + n ] * cumprods [ ppp [ i ] ] % MOD <NEWLINE> <NL> <DEDENT> cumprods_from_tree1 = np . zeros ( 2 * n , dtype = np . int64 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for lca in range ( 1 , n ) : <NEWLINE> <INDENT> d = lca <NEWLINE> digit = h <NEWLINE> while d : <NEWLINE> <INDENT> d >>= 1 <NEWLINE> digit -= 1 <NEWLINE> <NL> <DEDENT> leftmost_leaf_in_left_subtree = lca << digit <NEWLINE> leftmost_leaf_in_right_subtree = ( ( lca << 1 ) + 1 ) << ( digit - 1 ) <NEWLINE> rightmost_leaf_in_right_subtree = ( lca + 1 ) << digit <NEWLINE> <NL> rev = cumprods_rev [ lca >> 1 ] <NEWLINE> for leaf in range ( leftmost_leaf_in_left_subtree , leftmost_leaf_in_right_subtree ) : <NEWLINE> <INDENT> v = ppp [ leaf - n ] <NEWLINE> cp = cumprods_through [ leaf - n ] * rev % MOD <NEWLINE> while v > 1 : <NEWLINE> <INDENT> cumprods_from_tree1 [ v ] += cp * cumprods_rev [ v >> 1 ] % MOD <NEWLINE> v >>= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> rev = cumprods_rev [ lca ] <NEWLINE> for leaf in range ( leftmost_leaf_in_right_subtree , rightmost_leaf_in_right_subtree ) : <NEWLINE> <INDENT> v = ppp [ leaf - n ] <NEWLINE> cp = cumprods_through [ leaf - n ] * rev % MOD <NEWLINE> while v > 1 : <NEWLINE> <INDENT> ans += cumprods_from_tree1 [ v ^ 1 ] % MOD * cp % MOD * cumprods_rev [ v >> 2 ] % MOD <NEWLINE> v >>= 1 <NEWLINE> <DEDENT> ans %= MOD <NEWLINE> <NL> <DEDENT> for leaf in range ( leftmost_leaf_in_left_subtree , leftmost_leaf_in_right_subtree ) : <NEWLINE> <INDENT> v = ppp [ leaf - n ] <NEWLINE> while cumprods_from_tree1 [ v ] != 0 : <NEWLINE> <INDENT> cumprods_from_tree1 [ v ] = 0 <NEWLINE> v >>= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> <NL> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if os . name == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> from my_module import solve <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> <NL> solve = njit ( <STRING> , cache = True ) ( solve ) <NEWLINE> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <DEDENT> inp = np . fromstring ( sys . stdin . read ( ) , dtype = np . int64 , sep = <STRING> ) <NEWLINE> ans = solve ( inp ) <NEWLINE> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> minr = int ( input ( ) ) <NEWLINE> ans = - 1 * 10 ** 9 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> r = int ( input ( ) ) <NEWLINE> ans = max ( ans , r - minr ) <NEWLINE> minr = min ( minr , r ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> b . append ( x ) <NEWLINE> c . append ( y ) <NEWLINE> <NL> <DEDENT> d = [ 0 ] * 100001 <NEWLINE> for i in a : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <NL> <DEDENT> ans = sum ( a ) <NEWLINE> for m , p in zip ( b , c ) : <NEWLINE> <INDENT> minus = d [ m ] <NEWLINE> d [ m ] = 0 <NEWLINE> d [ p ] += minus <NEWLINE> ans += ( p - m ) * minus <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import collections <NEWLINE> import numpy as np <NEWLINE> <NL> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lst_ = [ ] <NEWLINE> h_lst = [ 0 ] * h <NEWLINE> w_lst = [ 0 ] * w <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> h_ , w_ = map ( int , input ( ) . split ( ) ) <NEWLINE> lst_ . append ( [ h_ , w_ ] ) <NEWLINE> h_lst [ h_ - 1 ] += 1 <NEWLINE> w_lst [ w_ - 1 ] += 1 <NEWLINE> <NL> <DEDENT> h_count = max ( h_lst ) <NEWLINE> w_count = max ( w_lst ) <NEWLINE> h_cand = set ( [ i + 1 for i , h_ in enumerate ( h_lst ) if h_ == h_count ] ) <NEWLINE> w_cand = set ( [ i + 1 for i , w_ in enumerate ( w_lst ) if w_ == w_count ] ) <NEWLINE> <COMMENT> <NL> <NL> count = 0 <NEWLINE> for bomb in lst_ : <NEWLINE> <INDENT> if bomb [ 0 ] in h_cand and bomb [ 1 ] in w_cand : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( h_lst ) + max ( w_lst ) <NEWLINE> if count < len ( h_cand ) * len ( w_cand ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans - 1 ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> b = a [ 0 ] <NEWLINE> c = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> if b == 2 : <NEWLINE> <INDENT> print ( len ( c ) + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if len ( c ) > n : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c . append ( b ) <NEWLINE> b = a [ c [ - 1 ] - 1 ] <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if s [ i ] == s [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> k = 2 * j - i <NEWLINE> if j < k < n and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) - cnt ) <NEWLINE>
n , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> p = [ ( int ( i ) + 1 ) / 2 for i in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> sum_num = sum ( p [ : k ] ) <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> sum_num = sum ( p [ : k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum_num += p [ i + k - 1 ] - p [ i - 1 ] <NEWLINE> <DEDENT> ans = max ( ans , sum_num ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from math import gcd , pi <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import itertools <NEWLINE> from collections import Counter , deque <NEWLINE> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = i_input ( ) <NEWLINE> s = s_input ( ) <NEWLINE> <NL> r_cn = s . count ( <STRING> ) <NEWLINE> g_cn = s . count ( <STRING> ) <NEWLINE> b_cn = s . count ( <STRING> ) <NEWLINE> <NL> ans = r_cn * g_cn * b_cn <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for d in range ( n ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 1 <NEWLINE> flag = True <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> count = count * A [ i ] <NEWLINE> if count > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <DEDENT> <DEDENT>
def func ( n ) : <NEWLINE> <INDENT> x = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> num = i <NEWLINE> if i % 3 == 0 : <NEWLINE> <INDENT> x . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while num : <NEWLINE> <INDENT> if int ( num % 10 ) == 3 : <NEWLINE> <INDENT> x . append ( i ) <NEWLINE> break <NEWLINE> <DEDENT> num = int ( num / 10 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return x <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> rlt = func ( N ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> for i in range ( len ( rlt ) ) : <NEWLINE> <INDENT> if rlt [ i ] == rlt [ - 1 ] : <NEWLINE> <INDENT> print ( rlt [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( rlt [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE>
import bisect <NEWLINE> import collections <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> q = [ [ int ( j ) for j in input ( ) . split ( ) ] for i in range ( M ) ] <NEWLINE> li = collections . defaultdict ( list ) <NEWLINE> <NL> for i , j in sorted ( q ) : <NEWLINE> <INDENT> li [ i ] . append ( j ) <NEWLINE> <NL> <DEDENT> for p , y in q : <NEWLINE> <INDENT> z = bisect . bisect ( li [ p ] , y ) <NEWLINE> print ( <STRING> . format ( p ) + <STRING> . format ( z ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , N ) : <NEWLINE> <INDENT> ans += ( N - 1 ) // a <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def p ( x ) : <NEWLINE> <INDENT> return bin ( x ) . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> def f ( x ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return f ( x % p ( x ) ) + 1 <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> cnt = X . count ( <STRING> ) <NEWLINE> x = int ( X , 2 ) <NEWLINE> a = x % ( cnt + 1 ) <NEWLINE> if cnt != 1 : <NEWLINE> <INDENT> b = x % ( cnt - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> k = a <NEWLINE> k += pow ( 2 , N - i - 1 , cnt + 1 ) <NEWLINE> k %= cnt + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if cnt == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> k = b <NEWLINE> k -= pow ( 2 , N - i - 1 , cnt - 1 ) <NEWLINE> k %= cnt - 1 <NEWLINE> <DEDENT> print ( f ( k ) + 1 ) <NEWLINE> <DEDENT>
class Dice : <NEWLINE> <NL> <INDENT> __top = 0 <NEWLINE> __front = 1 <NEWLINE> __right = 2 <NEWLINE> __left = 3 <NEWLINE> __back = 4 <NEWLINE> __bottom = 5 <NEWLINE> <NL> def __init__ ( self , a , b , c , d , e , f ) : <NEWLINE> <INDENT> self . __dice = [ a , b , c , d , e , f ] <NEWLINE> <NL> <DEDENT> def S ( self ) : <NEWLINE> <INDENT> dice_before = self . __dice [ : ] <NEWLINE> self . __dice [ Dice . __top ] = dice_before [ Dice . __back ] <NEWLINE> self . __dice [ Dice . __front ] = dice_before [ Dice . __top ] <NEWLINE> self . __dice [ Dice . __right ] = dice_before [ Dice . __right ] <NEWLINE> self . __dice [ Dice . __left ] = dice_before [ Dice . __left ] <NEWLINE> self . __dice [ Dice . __back ] = dice_before [ Dice . __bottom ] <NEWLINE> self . __dice [ Dice . __bottom ] = dice_before [ Dice . __front ] <NEWLINE> <NL> <DEDENT> def E ( self ) : <NEWLINE> <INDENT> dice_before = self . __dice [ : ] <NEWLINE> self . __dice [ Dice . __top ] = dice_before [ Dice . __left ] <NEWLINE> self . __dice [ Dice . __front ] = dice_before [ Dice . __front ] <NEWLINE> self . __dice [ Dice . __right ] = dice_before [ Dice . __top ] <NEWLINE> self . __dice [ Dice . __left ] = dice_before [ Dice . __bottom ] <NEWLINE> self . __dice [ Dice . __back ] = dice_before [ Dice . __back ] <NEWLINE> self . __dice [ Dice . __bottom ] = dice_before [ Dice . __right ] <NEWLINE> <NL> <DEDENT> def W ( self ) : <NEWLINE> <INDENT> dice_before = self . __dice [ : ] <NEWLINE> self . __dice [ Dice . __top ] = dice_before [ Dice . __right ] <NEWLINE> self . __dice [ Dice . __front ] = dice_before [ Dice . __front ] <NEWLINE> self . __dice [ Dice . __right ] = dice_before [ Dice . __bottom ] <NEWLINE> self . __dice [ Dice . __left ] = dice_before [ Dice . __top ] <NEWLINE> self . __dice [ Dice . __back ] = dice_before [ Dice . __back ] <NEWLINE> self . __dice [ Dice . __bottom ] = dice_before [ Dice . __left ] <NEWLINE> <NL> <DEDENT> def N ( self ) : <NEWLINE> <INDENT> dice_before = self . __dice [ : ] <NEWLINE> self . __dice [ Dice . __top ] = dice_before [ Dice . __front ] <NEWLINE> self . __dice [ Dice . __front ] = dice_before [ Dice . __bottom ] <NEWLINE> self . __dice [ Dice . __right ] = dice_before [ Dice . __right ] <NEWLINE> self . __dice [ Dice . __left ] = dice_before [ Dice . __left ] <NEWLINE> self . __dice [ Dice . __back ] = dice_before [ Dice . __top ] <NEWLINE> self . __dice [ Dice . __bottom ] = dice_before [ Dice . __back ] <NEWLINE> <NL> <DEDENT> def top ( self ) : <NEWLINE> <INDENT> return ( self . __dice [ Dice . __top ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> a , b , c , d , e , f = input ( ) . split ( ) <NEWLINE> dice = Dice ( a , b , c , d , e , f ) <NEWLINE> com = input ( ) <NEWLINE> for i in com : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> dice . S ( ) <NEWLINE> <NL> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> dice . E ( ) <NEWLINE> <NL> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> dice . W ( ) <NEWLINE> <NL> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> dice . N ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dice . top ( ) ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> max = a [ 1 ] - a [ 0 ] <NEWLINE> mini = a [ 0 ] <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> diff = a [ i ] - mini <NEWLINE> if diff > max : <NEWLINE> <INDENT> max = diff <NEWLINE> <DEDENT> if mini > a [ i ] : <NEWLINE> <INDENT> mini = a [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( max ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> mod = 998244353 <NEWLINE> n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if d [ 0 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> C = Counter ( d ) <NEWLINE> C = dict ( sorted ( C . items ( ) ) ) <NEWLINE> <NL> memo1 = C [ 1 ] <NEWLINE> memo2 = 1 <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if d [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for key in C : <NEWLINE> <INDENT> if key >= 2 : <NEWLINE> <INDENT> if memo2 + 1 != key : <COMMENT> <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = ( ans * memo1 ** C [ key ] ) % mod <COMMENT> <NEWLINE> memo1 = C [ key ] <NEWLINE> memo2 = key <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class Node : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . parent = - 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def dfs ( v , d = 0 ) : <NEWLINE> <INDENT> G [ v ] . depth = d <NEWLINE> for child in G [ v ] . children : <NEWLINE> <INDENT> dfs ( child , d + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> G = [ Node ( ) for _ in range ( N ) ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> idx , k , * children = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> G [ idx ] . children = children <NEWLINE> if k : <NEWLINE> <INDENT> G [ idx ] . type = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> G [ idx ] . type = <STRING> <NEWLINE> <DEDENT> for child in children : <NEWLINE> <INDENT> G [ child ] . parent = idx <NEWLINE> <DEDENT> <DEDENT> root = [ i for i , x in enumerate ( G ) if x . parent == - 1 ] [ 0 ] <NEWLINE> G [ root ] . type = <STRING> <NEWLINE> dfs ( root ) <NEWLINE> for i , node in enumerate ( G ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i , node . parent , node . depth , node . type , <STRING> . join ( map ( str , node . children ) ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> arr = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> arr . sort ( ) <NEWLINE> for each in arr : <NEWLINE> <INDENT> ans *= each <NEWLINE> if ( ans > 1e18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
newlst = [ ] <NEWLINE> lst = [ ] <NEWLINE> m = int ( input ( ) ) <NEWLINE> while m > 0 : <NEWLINE> <INDENT> a = str ( input ( ) ) <NEWLINE> lst . append ( a ) <NEWLINE> m = m - 1 <NEWLINE> <DEDENT> newlst = list ( dict . fromkeys ( lst ) ) <NEWLINE> print ( len ( newlst ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a1 = [ ] <NEWLINE> bn = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> a1 . append ( b ) <NEWLINE> <DEDENT> elif b == n : <NEWLINE> <INDENT> bn . append ( a ) <NEWLINE> <DEDENT> <DEDENT> la = len ( a1 ) <NEWLINE> lb = len ( bn ) <NEWLINE> sa = set ( a1 ) <NEWLINE> sb = set ( bn ) <NEWLINE> if len ( sa | sb ) < la + lb : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> result = 1 <NEWLINE> <COMMENT> <NL> for i in A : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> result = result * i <NEWLINE> if result > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from operator import itemgetter <NEWLINE> from itertools import permutations <NEWLINE> from math import sqrt <NEWLINE> <NL> def solve ( a : list ) : <NEWLINE> <INDENT> length = len ( a ) <NEWLINE> if length <= 3 : <NEWLINE> <INDENT> return min ( sqrt ( ( p1 [ 0 ] - p2 [ 0 ] ) ** 2 + ( p1 [ 1 ] - p2 [ 1 ] ) ** 2 ) for p1 , p2 in permutations ( a , 2 ) ) <NEWLINE> <NL> <DEDENT> x_set_len = len ( set ( x for ( x , _ ) in a ) ) <NEWLINE> axis = 0 if x_set_len > length / 2 else 1 <NEWLINE> a . sort ( key = itemgetter ( axis ) ) <NEWLINE> mid_index = length // 2 <NEWLINE> left , right = a [ : mid_index ] , a [ mid_index : ] <NEWLINE> delta = min ( solve ( left ) , solve ( right ) ) <NEWLINE> median = a [ mid_index ] [ axis ] <NEWLINE> m_a = [ ] <NEWLINE> <NL> for p in left [ : : - 1 ] : <NEWLINE> <INDENT> if p [ axis ] < median - delta : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m_a . append ( p ) <NEWLINE> <DEDENT> for p in right : <NEWLINE> <INDENT> if p [ axis ] > median + delta : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m_a . append ( p ) <NEWLINE> <DEDENT> m_a . sort ( key = itemgetter ( not axis ) ) <NEWLINE> <NL> for i , p1 in enumerate ( m_a ) : <NEWLINE> <INDENT> ub = p1 [ not axis ] + delta <NEWLINE> for j , p2 in enumerate ( m_a [ i + 1 : ] ) : <NEWLINE> <INDENT> if p2 [ not axis ] > ub : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> delta = min ( delta , sqrt ( ( p1 [ 0 ] - p2 [ 0 ] ) ** 2 + ( p1 [ 1 ] - p2 [ 1 ] ) ** 2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> return delta <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> a = [ tuple ( map ( float , l . split ( ) ) ) for l in sys . stdin . readlines ( ) ] <NEWLINE> print ( <STRING> . format ( solve ( a ) ) ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - ( i + j ) <= k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = max ( a ) <NEWLINE> <NL> c = [ 0 for _ in range ( M + 1 ) ] <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if c [ i ] != 0 : <NEWLINE> <INDENT> c [ i ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> for j in range ( i , M + 1 , i ) : <NEWLINE> <INDENT> c [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> answer = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if c [ i ] == 1 : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> Xint = int ( X , 2 ) <NEWLINE> popX = X . count ( <STRING> ) <NEWLINE> if popX == 1 : <NEWLINE> <INDENT> idx = X . find ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i == idx : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i != N - 1 : <NEWLINE> <INDENT> if X [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> Xmod_plus = Xint % ( popX + 1 ) <NEWLINE> Xmod_minus = Xint % ( popX - 1 ) <NEWLINE> <NL> pop_2expi_p = { 0 : 1 } <NEWLINE> pop_2expi_m = { 0 : 1 } <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> pop_2expi_p [ i ] = pop_2expi_p [ i - 1 ] * 2 % ( popX + 1 ) <NEWLINE> pop_2expi_m [ i ] = pop_2expi_m [ i - 1 ] * 2 % ( popX - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> count = 1 <NEWLINE> if X [ i ] == <STRING> : <NEWLINE> <INDENT> nX = ( Xmod_minus - pop_2expi_m [ N - 1 - i ] ) % ( popX - 1 ) <NEWLINE> <DEDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> nX = ( Xmod_plus + pop_2expi_p [ N - 1 - i ] ) % ( popX + 1 ) <NEWLINE> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> if nX == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nX %= bin ( nX ) . count ( <STRING> ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
import math <NEWLINE> <NL> l = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> <NL> for i in range ( 1 , l + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , l + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for j in range ( 1 , l + 1 ) : <NEWLINE> <INDENT> s += math . gcd ( tmp , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
from collections import deque <NEWLINE> <NL> s = deque ( input ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> qq = [ list ( input ( ) . split ( ) ) for i in range ( q ) ] <NEWLINE> <NL> rl = 1 <NEWLINE> fleft = deque ( ) <NEWLINE> fright = deque ( ) <NEWLINE> <NL> for i in qq : <NEWLINE> <INDENT> if i [ 0 ] == <STRING> : <NEWLINE> <INDENT> rl *= - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i [ 1 ] == <STRING> : <NEWLINE> <INDENT> if rl == 1 : <NEWLINE> <INDENT> fleft . appendleft ( i [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fright . append ( i [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if rl == 1 : <NEWLINE> <INDENT> fright . append ( i [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fleft . appendleft ( i [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> fleft . reverse ( ) <NEWLINE> <NL> s . extendleft ( fleft ) <NEWLINE> s . extend ( fright ) <NEWLINE> <NL> if rl == - 1 : <NEWLINE> <INDENT> s . reverse ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> def leftmore ( ln ) : <NEWLINE> <INDENT> ret = [ 0 ] <NEWLINE> cur = 0 <NEWLINE> for c in ln : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> cur += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cur = 0 <NEWLINE> <NL> <DEDENT> ret . append ( cur ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def rightless ( ln ) : <NEWLINE> <INDENT> revl = reversed ( ln ) <NEWLINE> ret = [ 0 ] <NEWLINE> cur = 0 <NEWLINE> for c in revl : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> cur += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cur = 0 <NEWLINE> <DEDENT> ret . append ( cur ) <NEWLINE> <DEDENT> return list ( reversed ( ret ) ) <NEWLINE> <NL> <DEDENT> lm = leftmore ( s ) <NEWLINE> rl = rightless ( s ) <NEWLINE> for i in range ( len ( s ) + 1 ) : <NEWLINE> <INDENT> ans += max ( lm [ i ] , rl [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> s = 0 <NEWLINE> if a >= k : <NEWLINE> <INDENT> s = k <NEWLINE> k = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += a <NEWLINE> k -= a <NEWLINE> if b >= k : <NEWLINE> <INDENT> s += 0 <NEWLINE> k = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += 0 <NEWLINE> k -= b <NEWLINE> if c >= k : <NEWLINE> <INDENT> s -= k <NEWLINE> k = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s -= c <NEWLINE> k = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i + 1 == a [ a [ i ] - 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
def orderN ( N , L , ices ) : <NEWLINE> <INDENT> upPeak = L - ices [ 0 ] <NEWLINE> downPeak = L - ices [ 0 ] <NEWLINE> peaks = [ ] <NEWLINE> for i in range ( len ( ices ) ) : <NEWLINE> <INDENT> if i < N - 1 : <NEWLINE> <INDENT> if ices [ i ] < ices [ i + 1 ] : <NEWLINE> <INDENT> peaks . append ( downPeak ) <NEWLINE> downPeak = L - ices [ i + 1 ] <NEWLINE> upPeak += L - ices [ i + 1 ] <NEWLINE> <DEDENT> elif ices [ i ] > ices [ i + 1 ] : <NEWLINE> <INDENT> peaks . append ( upPeak ) <NEWLINE> upPeak = L - ices [ i + 1 ] <NEWLINE> downPeak += L - ices [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> elif i == N - 1 : <NEWLINE> <INDENT> peaks . append ( upPeak ) <NEWLINE> peaks . append ( downPeak ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( peaks ) ) <NEWLINE> <NL> <DEDENT> N , L = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> ices = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> ice = int ( input ( ) . strip ( ) ) <NEWLINE> ices . append ( ice ) <NEWLINE> if len ( ices ) == N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> orderN ( N , L , ices ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> e = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> e [ a ] . append ( b ) <NEWLINE> e [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> l = deque ( [ 1 ] ) <NEWLINE> s = set ( [ 1 ] ) <NEWLINE> while True : <NEWLINE> <INDENT> check = True <NEWLINE> for nex in e [ l [ - 1 ] ] : <NEWLINE> <INDENT> if nex in s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> l . append ( nex ) <NEWLINE> s . add ( nex ) <NEWLINE> check = False <NEWLINE> break <NEWLINE> <DEDENT> if check : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> check = True <NEWLINE> for nex in e [ l [ 0 ] ] : <NEWLINE> <INDENT> if nex in s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> l . appendleft ( nex ) <NEWLINE> s . add ( nex ) <NEWLINE> check = False <NEWLINE> break <NEWLINE> <DEDENT> if check : <NEWLINE> <INDENT> print ( len ( l ) ) <NEWLINE> print ( * l ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> if a in S : <NEWLINE> <INDENT> S [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ a ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> V = list ( S . values ( ) ) <NEWLINE> c = sum ( [ v * ( v - 1 ) // 2 for v in V ] ) <NEWLINE> <NL> cdiff = 0 <NEWLINE> K = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cdiff = 0 <NEWLINE> a = A [ i ] <NEWLINE> s = S [ a ] <NEWLINE> if s >= 2 : <NEWLINE> <INDENT> cdiff = ( s * ( s - 1 ) - ( s - 1 ) * ( s - 2 ) ) // 2 <NEWLINE> <DEDENT> print ( c - cdiff ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
N = input ( ) <NEWLINE> sum_digit = 0 <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> sum_digit += int ( N [ i ] ) <NEWLINE> <DEDENT> if sum_digit % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( x ) // d >= k : <NEWLINE> <COMMENT> <NL> <INDENT> print ( abs ( x ) - d * k ) <NEWLINE> <DEDENT> elif ( k - abs ( x ) // d ) % 2 == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> print ( abs ( x ) % d ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> print ( d - abs ( x ) % d ) <NEWLINE> <NL> <DEDENT>
from sys import stdin <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans = ans * a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import glob <NEWLINE> import os <NEWLINE> import numpy as np <NEWLINE> <NL> bn = os . path . basename ( __file__ ) . split ( <STRING> ) [ 0 ] <NEWLINE> dn = os . path . dirname ( __file__ ) . split ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> REL_PATH = dn [ len ( dn ) - 2 ] + <STRING> + dn [ len ( dn ) - 1 ] + <STRING> + bn <NEWLINE> <NL> <COMMENT> <NL> TOP_PATH = <STRING> <NEWLINE> <NL> class Common : <NEWLINE> <INDENT> problem = [ ] <NEWLINE> index = 0 <NEWLINE> <NL> def __init__ ( self , rel_path ) : <NEWLINE> <INDENT> self . rel_path = rel_path <NEWLINE> <NL> <DEDENT> def initialize ( self , path ) : <NEWLINE> <INDENT> file = open ( path ) <NEWLINE> self . problem = file . readlines ( ) <NEWLINE> self . index = 0 <NEWLINE> return <NEWLINE> <NL> <DEDENT> def input_data ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> IS_TEST <NEWLINE> self . index += 1 <NEWLINE> return self . problem [ self . index - 1 ] <NEWLINE> <NL> <DEDENT> except NameError : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def resolve ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> def exec_resolve ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> IS_TEST <NEWLINE> for path in glob . glob ( TOP_PATH + <STRING> + self . rel_path + <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> + path ) <NEWLINE> self . initialize ( path ) <NEWLINE> self . resolve ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except NameError : <NEWLINE> <INDENT> self . resolve ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class Solver ( Common ) : <NEWLINE> <NL> <INDENT> def resolve ( self ) : <NEWLINE> <NL> <INDENT> H , W , M = map ( int , self . input_data ( ) . split ( ) ) <NEWLINE> B = [ None for i in range ( M ) ] <NEWLINE> <NL> ver_num = [ 0 for i in range ( W + 1 ) ] <COMMENT> <NEWLINE> hol_num = [ 0 for i in range ( H + 1 ) ] <COMMENT> <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> B [ i ] = list ( map ( int , self . input_data ( ) . split ( ) ) ) <NEWLINE> ver_num [ B [ i ] [ 1 ] ] += 1 <NEWLINE> hol_num [ B [ i ] [ 0 ] ] += 1 <NEWLINE> <NL> <DEDENT> ver_max = np . max ( np . array ( ver_num ) ) <NEWLINE> hol_max = np . max ( np . array ( hol_num ) ) <NEWLINE> <NL> max_columns = [ ] <NEWLINE> max_rows = [ ] <NEWLINE> <NL> for i in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if ver_max == ver_num [ i ] : <NEWLINE> <INDENT> max_columns . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> if hol_max == hol_num [ i ] : <NEWLINE> <INDENT> max_rows . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> b_cross = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> if ver_num [ b [ 1 ] ] == ver_max and hol_num [ b [ 0 ] ] == hol_max : <NEWLINE> <INDENT> b_cross += 1 <NEWLINE> <DEDENT> <DEDENT> if b_cross == len ( max_columns ) * len ( max_rows ) : <NEWLINE> <INDENT> result = ver_max + hol_max - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = ver_max + hol_max <NEWLINE> <DEDENT> print ( str ( result ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> solver = Solver ( REL_PATH ) <NEWLINE> solver . exec_resolve ( ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> if ( a == b ) and ( b == c ) : <NEWLINE> <INDENT> ans += math . gcd ( a , math . gcd ( b , c ) ) <NEWLINE> <DEDENT> if ( ( a != b ) and ( b == c ) ) or ( ( a == b ) and ( b != c ) ) : <NEWLINE> <INDENT> ans += 3 * math . gcd ( a , math . gcd ( b , c ) ) <NEWLINE> <DEDENT> if ( ( a != b ) and ( b != c ) ) : <NEWLINE> <INDENT> ans += 6 * math . gcd ( a , math . gcd ( b , c ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> minint = 10 ** 9 <NEWLINE> <NL> if N == 2 : <NEWLINE> <INDENT> print ( abs ( a [ 0 ] - a [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> s1 = s1 = sum ( a [ 0 : 1 ] ) <NEWLINE> s2 = sum ( a [ 1 : N ] ) <NEWLINE> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> s1 += a [ i ] <NEWLINE> s2 -= a [ i ] <NEWLINE> <NL> minint = min ( minint , abs ( s1 - s2 ) ) <NEWLINE> <NL> <DEDENT> print ( minint ) <NEWLINE> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> mini = 0 <NEWLINE> if abs ( x ) >= k * d : <NEWLINE> <INDENT> mini = abs ( x ) - k * d <NEWLINE> print ( mini ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q = abs ( x ) // d <NEWLINE> s = abs ( x ) % d <NEWLINE> if ( k - q ) % 2 == 0 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( s - d ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a_list = [ i for i in input ( ) . split ( ) ] <NEWLINE> result = [ 0 for i in range ( 1 , N + 1 ) ] <NEWLINE> <NL> for i in a_list : <NEWLINE> <INDENT> result [ int ( i ) - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for a in result : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> loop_li = [ ] <NEWLINE> loop_set = set ( [ ] ) <NEWLINE> a = 1 <NEWLINE> <NL> while a not in loop_set : <NEWLINE> <INDENT> loop_li . append ( a ) <NEWLINE> loop_set . add ( a ) <NEWLINE> a = a_li [ a - 1 ] <NEWLINE> <NL> <DEDENT> length = len ( loop_li ) <NEWLINE> if k < length : <NEWLINE> <INDENT> print ( loop_li [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bp = a_li [ loop_li [ - 1 ] - 1 ] <COMMENT> <NEWLINE> bp_idx = loop_li . index ( bp ) <NEWLINE> t = length - bp_idx <NEWLINE> amari = ( k - bp_idx ) % t <NEWLINE> print ( loop_li [ bp_idx + amari ] ) <NEWLINE> <DEDENT>
n , m = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = [ [ 0 for i in range ( m ) ] for i in range ( n ) ] <NEWLINE> vector = [ 0 for i in range ( m ) ] <NEWLINE> result = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> vector [ i ] = int ( input ( ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> result [ i ] += A [ i ] [ j ] * vector [ j ] <NEWLINE> <DEDENT> <DEDENT> for _ in result : <NEWLINE> <INDENT> print ( _ ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> . format ( math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ) ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> print ( str ( format ( r ** 2 * math . pi , <STRING> ) ) + <STRING> + str ( format ( r * 2 * math . pi , <STRING> ) ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ x - 1 ] . append ( y - 1 ) <NEWLINE> a [ y - 1 ] . append ( x - 1 ) <NEWLINE> <DEDENT> c = [ 0 ] * n <NEWLINE> que = deque ( [ ] ) <NEWLINE> que . append ( 0 ) <NEWLINE> while len ( que ) > 0 : <NEWLINE> <INDENT> e = que . popleft ( ) <NEWLINE> for i in a [ e ] : <NEWLINE> <INDENT> if c [ i ] > 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> c [ i ] = e + 1 <NEWLINE> que . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> p = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = np . zeros ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> dp [ 1 : ] = dp [ : - 1 ] * p [ i - 1 ] + dp [ 1 : ] * ( 1 - p [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( dp [ ( n + 1 ) // 2 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 10 ) : <NEWLINE> <INDENT> a = s . find ( str ( i ) ) <NEWLINE> if a == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> b = s . find ( str ( j ) , a + 1 ) <NEWLINE> if b == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> c = s . find ( str ( k ) , b + 1 ) <NEWLINE> if c == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> s = sorted ( s ) <NEWLINE> t = sorted ( t ) [ : : - 1 ] <NEWLINE> <NL> answer = <STRING> <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if i == len ( t ) : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> s_c = s [ i ] <NEWLINE> t_c = t [ i ] <NEWLINE> if s_c < t_c : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif s_c == t_c : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if s == t : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
[ n , k ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> orl = li [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> in_num = li [ i + k - 1 ] <NEWLINE> if in_num > orl : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> orl = li [ i ] <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> G [ a ] . append ( [ b , c ] ) <NEWLINE> G [ b ] . append ( [ a , c ] ) <NEWLINE> <DEDENT> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> K -= 1 <NEWLINE> dist = [ - 1 for _ in range ( N ) ] <NEWLINE> dist [ K ] = 0 <NEWLINE> q = [ K ] <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> v = q . pop ( ) <NEWLINE> for p in G [ v ] : <NEWLINE> <INDENT> nv = p [ 0 ] <NEWLINE> if dist [ nv ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ nv ] = dist [ v ] + p [ 1 ] <NEWLINE> q . append ( nv ) <NEWLINE> <DEDENT> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( dist [ x - 1 ] + dist [ y - 1 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> x = int ( readline ( ) . rstrip ( ) ) <NEWLINE> ans = x // 100 <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> sur = x - ans * 100 <NEWLINE> print ( 1 if sur / ans <= 5 else 0 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> <NL> if list [ 0 ] > list [ 1 ] : <NEWLINE> <INDENT> a = list [ 0 ] <NEWLINE> b = list [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = list [ 0 ] <NEWLINE> a = list [ 1 ] <NEWLINE> <NL> <NL> <DEDENT> if a % b == 0 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while b > 0 : <NEWLINE> <INDENT> c = a % b <NEWLINE> a = b <NEWLINE> b = c <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <DEDENT>
import sys <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 1 : <NEWLINE> <INDENT> if W == 1 : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt = [ 0 for _ in range ( W ) ] <NEWLINE> s = list ( input ( ) ) <NEWLINE> for w in range ( W ) : <NEWLINE> <INDENT> if w == 0 : <NEWLINE> <INDENT> cnt [ w ] += s [ w + 1 ] == <STRING> <NEWLINE> <DEDENT> elif w == W - 1 : <NEWLINE> <INDENT> cnt [ w ] += s [ w - 1 ] == <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ w ] += s [ w + 1 ] == <STRING> <NEWLINE> cnt [ w ] += s [ w - 1 ] == <STRING> <NEWLINE> <DEDENT> <DEDENT> for w in range ( W ) : <NEWLINE> <INDENT> if s [ w ] == <STRING> : <NEWLINE> <INDENT> cnt [ w ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> ans = map ( str , cnt ) <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE> <DEDENT> sys . exit ( 0 ) <NEWLINE> <DEDENT> if W == 1 : <NEWLINE> <INDENT> cnt = [ 0 for _ in range ( H ) ] <NEWLINE> s = [ ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> if h == 0 : <NEWLINE> <INDENT> cnt [ h ] += s [ h + 1 ] == <STRING> <NEWLINE> <DEDENT> elif h == H - 1 : <NEWLINE> <INDENT> cnt [ h ] += s [ h - 1 ] == <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ h ] += s [ h - 1 ] == <STRING> <NEWLINE> cnt [ h ] += s [ h + 1 ] == <STRING> <NEWLINE> <DEDENT> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> if s [ h ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cnt [ h ] ) <NEWLINE> <DEDENT> <DEDENT> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> S = [ ] <NEWLINE> cnt = [ [ 0 for _ in range ( W ) ] for _ in range ( H ) ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> for w in range ( W ) : <NEWLINE> <INDENT> if w == 0 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += s [ w + 1 ] == <STRING> <NEWLINE> <DEDENT> elif w == W - 1 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += s [ w - 1 ] == <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ h ] [ w ] += s [ w + 1 ] == <STRING> <NEWLINE> cnt [ h ] [ w ] += s [ w - 1 ] == <STRING> <NEWLINE> <DEDENT> <DEDENT> S . append ( s ) <NEWLINE> <NL> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if h == 0 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h + 1 ] [ w ] == <STRING> <NEWLINE> if w == 0 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h + 1 ] [ w + 1 ] == <STRING> <NEWLINE> <DEDENT> elif w == W - 1 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h + 1 ] [ w - 1 ] == <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h + 1 ] [ w - 1 ] == <STRING> <NEWLINE> cnt [ h ] [ w ] += S [ h + 1 ] [ w + 1 ] == <STRING> <NEWLINE> <DEDENT> <DEDENT> elif h == H - 1 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h - 1 ] [ w ] == <STRING> <NEWLINE> if w == 0 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h - 1 ] [ w + 1 ] == <STRING> <NEWLINE> <DEDENT> elif w == W - 1 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h - 1 ] [ w - 1 ] == <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h - 1 ] [ w - 1 ] == <STRING> <NEWLINE> cnt [ h ] [ w ] += S [ h - 1 ] [ w + 1 ] == <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h + 1 ] [ w ] == <STRING> <NEWLINE> if w == 0 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h + 1 ] [ w + 1 ] == <STRING> <NEWLINE> <DEDENT> elif w == W - 1 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h + 1 ] [ w - 1 ] == <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h + 1 ] [ w - 1 ] == <STRING> <NEWLINE> cnt [ h ] [ w ] += S [ h + 1 ] [ w + 1 ] == <STRING> <NEWLINE> <DEDENT> cnt [ h ] [ w ] += S [ h - 1 ] [ w ] == <STRING> <NEWLINE> if w == 0 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h - 1 ] [ w + 1 ] == <STRING> <NEWLINE> <DEDENT> elif w == W - 1 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h - 1 ] [ w - 1 ] == <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h - 1 ] [ w - 1 ] == <STRING> <NEWLINE> cnt [ h ] [ w ] += S [ h - 1 ] [ w + 1 ] == <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> s = S [ h ] <NEWLINE> for w in range ( W ) : <NEWLINE> <INDENT> if s [ w ] == <STRING> : <NEWLINE> <INDENT> cnt [ h ] [ w ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> ans = map ( str , cnt [ h ] ) <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> import math <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> k = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( k , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def D ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r , g , b = [ ] , [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : r . append ( i ) <NEWLINE> elif s [ i ] == <STRING> : g . append ( i ) <NEWLINE> else : b . append ( i ) <NEWLINE> <DEDENT> ans = len ( r ) * len ( g ) * len ( b ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> if j + ( j - i ) >= n : continue <NEWLINE> if s [ i ] != s [ j ] and s [ i ] != s [ 2 * j - i ] and s [ j ] != s [ 2 * j - i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> D ( ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> aa = map ( int , input ( ) . split ( ) ) <NEWLINE> x = 1 <NEWLINE> for a in aa : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> if x < 1000000000000000000 : <NEWLINE> <INDENT> x *= a <NEWLINE> <DEDENT> <DEDENT> if x > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> m = [ ] <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m . append ( <STRING> . join ( sorted ( str ( input ( ) ) ) ) ) <NEWLINE> <DEDENT> m = Counter ( m ) <NEWLINE> ans = 0 <NEWLINE> for j in m . values ( ) : <NEWLINE> <INDENT> ans += j * ( j - 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> numlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> if i == x : <NEWLINE> <INDENT> print ( numlist [ x - i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( numlist [ x - i ] , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys , math , itertools , collections , bisect <NEWLINE> input = lambda : sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> inf = float ( <STRING> ) ; mod = 10 ** 9 + 7 <NEWLINE> mans = inf ; ans = 0 ; count = 0 ; pro = 1 <NEWLINE> <NL> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> e = int ( input ( ) ) <NEWLINE> nn = [ a , b , c , d , e ] <NEWLINE> s = False <NEWLINE> for i in nn : <NEWLINE> <INDENT> if s == False and i % 10 != 0 : <NEWLINE> <INDENT> chk = i % 10 <NEWLINE> last = i <NEWLINE> s = True <NEWLINE> <DEDENT> elif s == False and i % 10 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif s == True and i % 10 != 0 : <NEWLINE> <INDENT> if chk > i % 10 : <NEWLINE> <INDENT> chk = i % 10 <NEWLINE> last = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if s == False : <NEWLINE> <INDENT> last = a <NEWLINE> <COMMENT> <NL> <DEDENT> s = False <NEWLINE> for i in nn : <NEWLINE> <INDENT> if s == False and i == last : <NEWLINE> <INDENT> ans += i <NEWLINE> s = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i % 10 == 0 : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += i + ( 10 - i % 10 ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( n ) : <NEWLINE> <INDENT> for b in range ( a + 1 , n ) : <NEWLINE> <INDENT> c = bisect . bisect_left ( l , l [ a ] + l [ b ] ) <NEWLINE> if c > b : <NEWLINE> <INDENT> ans += c - b - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> t = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if math . gcd ( i , j ) == 1 : <NEWLINE> <INDENT> t += 1 * len ( list ( range ( 1 , k + 1 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> t += gcd ( i , j , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
from math import floor <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( floor ( ( min ( N + 1 , B ) - 1 ) * A / B ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> EPS = 1e-8 <NEWLINE> <NL> <NL> def run ( ) : <NEWLINE> <INDENT> n , * A = map ( int , read ( ) . split ( ) ) <NEWLINE> v = 0 <NEWLINE> acum = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> v += a <NEWLINE> acum . append ( v ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = INF <NEWLINE> for V in ( - 1 , 1 ) : <NEWLINE> <INDENT> cums = 0 <NEWLINE> count = 0 <NEWLINE> for a in acum : <NEWLINE> <COMMENT> <NL> <INDENT> V *= - 1 <NEWLINE> if ( a + cums ) * V > 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> update = abs ( a + cums ) + 1 <NEWLINE> cums += ( update ) * V <NEWLINE> count += update <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = min ( ans , count ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> DICT = { k : 0 for k in range ( 1 , 101 ) } <NEWLINE> <NL> <NL> def solve ( d ) : <NEWLINE> <INDENT> _max = max ( d . values ( ) ) <NEWLINE> for k , v in sorted ( d . items ( ) ) : <NEWLINE> <INDENT> if _max == v : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> DICT [ n ] += 1 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> solve ( DICT ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = dict ( Counter ( a ) ) <NEWLINE> ans = sum ( a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b not in d . keys ( ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> continue <NEWLINE> <DEDENT> ans += ( c * d [ b ] - b * d [ b ] ) <NEWLINE> print ( ans ) <NEWLINE> if c in d . keys ( ) : d [ c ] += d [ b ] <NEWLINE> else : d [ c ] = d [ b ] <NEWLINE> d [ b ] = 0 <NEWLINE> <DEDENT>
import sys <NEWLINE> from itertools import accumulate <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( accumulate ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) ) <NEWLINE> b = [ 0 ] + list ( accumulate ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> j = m <NEWLINE> <NL> <COMMENT> <NL> <NL> for i , item in enumerate ( a ) : <NEWLINE> <INDENT> if k < item : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while k < item + b [ j ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x == 0 : <NEWLINE> <INDENT> if k % 2 == 1 : <NEWLINE> <INDENT> x = d <NEWLINE> <NL> <DEDENT> <DEDENT> elif x > 0 : <NEWLINE> <INDENT> if x >= k * d : <NEWLINE> <INDENT> x -= k * d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = x // d <NEWLINE> x -= n * d <NEWLINE> k -= n <NEWLINE> <NL> if k % 2 == 1 : <NEWLINE> <INDENT> x -= d <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if x <= - ( k * d ) : <NEWLINE> <INDENT> x += k * d <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> n = abs ( x ) // d <NEWLINE> x += n * d <NEWLINE> k -= n <NEWLINE> if k % 2 == 1 : <NEWLINE> <INDENT> x += d <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( abs ( x ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = prev = sum ( P [ : k ] ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> tmp = prev - P [ i - 1 ] + P [ i + k - 1 ] <NEWLINE> prev = tmp <NEWLINE> if tmp > m : <NEWLINE> <INDENT> s = i <NEWLINE> <DEDENT> m = max ( tmp , m ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> d = dict ( ) <NEWLINE> for i in range ( s , s + k ) : <NEWLINE> <INDENT> p = P [ i ] <NEWLINE> if p not in d . keys ( ) : <NEWLINE> <INDENT> tmp = sum ( range ( p + 1 ) ) / p <NEWLINE> ans += tmp <NEWLINE> d [ p ] = tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += d [ p ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def gcd ( x , y ) : <NEWLINE> <INDENT> if y == 0 : return x <NEWLINE> return gcd ( y , x % y ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = A [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a = gcd ( a , A [ i + 1 ] ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
import collections <NEWLINE> import math <NEWLINE> <COMMENT> <NL> k = int ( input ( ) ) <NEWLINE> cnts = collections . defaultdict ( int ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> cnts [ math . gcd ( i , j ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for key in cnts . keys ( ) : <NEWLINE> <INDENT> ans += math . gcd ( i , key ) * cnts [ key ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def gcd ( x , y ) : <NEWLINE> <INDENT> if y == 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x % y <NEWLINE> return gcd ( y , x ) <NEWLINE> <NL> <DEDENT> <DEDENT> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> print ( gcd ( A [ 0 ] , A [ 1 ] ) ) <NEWLINE>
import sys <NEWLINE> import re <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> import itertools <NEWLINE> import fractions <NEWLINE> import functools <NEWLINE> import copy <NEWLINE> import heapq <NEWLINE> import decimal <NEWLINE> import statistics <NEWLINE> import queue <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 10 ** 16 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> ni = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> nb = lambda : list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = ns ( ) <NEWLINE> e = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = ns ( ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> e [ a ] . append ( b ) <NEWLINE> <NL> <DEDENT> s , t = ns ( ) <NEWLINE> s , t = s - 1 , t - 1 <NEWLINE> <NL> visited = [ [ True ] * 3 for _ in range ( n ) ] <NEWLINE> <NL> que = collections . deque ( ) <NEWLINE> que . append ( [ 0 , s ] ) <NEWLINE> visited [ s ] [ 0 ] = False <NEWLINE> cnt = 0 <NEWLINE> ans = - 1 <NEWLINE> flg = True <NEWLINE> <NL> while que and flg : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> for _ in range ( len ( que ) ) : <NEWLINE> <INDENT> i , q = que . popleft ( ) <NEWLINE> for ei in e [ q ] : <NEWLINE> <INDENT> tmp = ( i + 1 ) % 3 <NEWLINE> if tmp == 0 and ei == t : <NEWLINE> <INDENT> ans = cnt // 3 <NEWLINE> flg = False <NEWLINE> break <NEWLINE> <DEDENT> elif visited [ ei ] [ tmp ] : <NEWLINE> <INDENT> visited [ ei ] [ tmp ] = False <NEWLINE> que . append ( [ tmp , ei ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> wa = False <NEWLINE> <NL> if s [ 0 ] != <STRING> : <NEWLINE> <INDENT> wa = True <NEWLINE> <DEDENT> if s [ 2 : - 1 ] . count ( <STRING> ) != 1 : <NEWLINE> <INDENT> wa = True <NEWLINE> <NL> <DEDENT> l_s = list ( s ) <NEWLINE> <NL> if <STRING> in l_s : <NEWLINE> <INDENT> del l_s [ l_s . index ( <STRING> ) ] <NEWLINE> <NL> <DEDENT> if <STRING> in l_s : <NEWLINE> <INDENT> del l_s [ l_s . index ( <STRING> ) ] <NEWLINE> <NL> <DEDENT> for c in l_s : <NEWLINE> <INDENT> if c != c . lower ( ) : <NEWLINE> <INDENT> wa = True <NEWLINE> <NL> <DEDENT> <DEDENT> if wa == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> sys . setrecursionlimit ( 20000000 ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> class UnionFind : <NEWLINE> <COMMENT> <NL> <INDENT> def __init__ ( self , n_nodes ) : <NEWLINE> <INDENT> self . n_nodes = n_nodes <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> self . parent = [ i for i in range ( n_nodes ) ] <NEWLINE> <COMMENT> <NL> self . rank = [ 1 ] * n_nodes <NEWLINE> <COMMENT> <NL> self . size = [ 1 ] * n_nodes <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parent [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> self . parent [ x ] = self . find ( self . parent [ x ] ) <NEWLINE> return self . parent [ x ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <COMMENT> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <COMMENT> <NL> <DEDENT> if self . rank [ x ] > self . rank [ y ] : <NEWLINE> <INDENT> self . parent [ y ] = x <NEWLINE> self . size [ x ] += self . size [ y ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ x ] = y <NEWLINE> self . size [ y ] += self . size [ x ] <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ y ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def check ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def get_size ( self , x ) : <NEWLINE> <INDENT> return self . size [ self . find ( x ) ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def get_parent_list ( self ) : <NEWLINE> <INDENT> return [ i for i in range ( self . n_nodes ) if self . find ( i ) == i ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def get_n_groups ( self ) : <NEWLINE> <INDENT> return len ( self . get_parent_list ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def get_members ( self , x ) : <NEWLINE> <INDENT> parent = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n_nodes ) if self . find ( i ) == parent ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def get_members_dict ( self ) : <NEWLINE> <INDENT> return { par : self . get_members ( par ) for par in self . get_parent_list ( ) } <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> UF = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> UF . unite ( x - 1 , y - 1 ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = P [ i ] - 1 <NEWLINE> if UF . check ( i , a ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> def LI ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def gcd ( x , y ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( y % x , x ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> input ( ) <NEWLINE> A = LI ( ) <NEWLINE> <NL> g = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> g = gcd ( g , a ) <NEWLINE> <DEDENT> if g != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> sosudayo = [ True ] * 1100000 <NEWLINE> sosudayo [ 0 ] = False <NEWLINE> sosudayo [ 1 ] = False <NEWLINE> for i in range ( 2 , 1100000 ) : <NEWLINE> <INDENT> if not sosudayo [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i * i , 1100000 , i ) : <NEWLINE> <INDENT> sosudayo [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> used = [ False ] * 1100000 <NEWLINE> sosu = [ a for a in A if sosudayo [ a ] ] <NEWLINE> for i in sosu : <NEWLINE> <INDENT> used [ i ] = True <NEWLINE> <DEDENT> ruto_sosu = [ a for a in range ( 1100 ) if sosudayo [ a ] ] <NEWLINE> not_sosu = [ a for a in A if not sosudayo [ a ] ] <NEWLINE> <NL> for i in not_sosu : <NEWLINE> <INDENT> for j in ruto_sosu : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i % j != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if used [ j ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> used [ j ] = True <NEWLINE> while i % j == 0 : <NEWLINE> <INDENT> i //= j <NEWLINE> <DEDENT> <DEDENT> if i > 1 : <NEWLINE> <INDENT> if used [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> used [ i ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from collections import defaultdict <NEWLINE> S = input ( ) <NEWLINE> D = defaultdict ( int ) <NEWLINE> D [ 0 ] = 1 <NEWLINE> n = 0 <NEWLINE> i = 0 <NEWLINE> a = [ 0 ] * len ( S ) <NEWLINE> b = 1 <NEWLINE> for s in S [ : : - 1 ] : <NEWLINE> <INDENT> n += int ( s ) * b <NEWLINE> a [ i ] = n % 2019 <NEWLINE> i += 1 <NEWLINE> b = ( b * 10 ) % 2019 <NEWLINE> <NL> <NL> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> D [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = sum ( [ i * ( i - 1 ) // 2 for i in D . values ( ) ] ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> class Tree : <NEWLINE> <INDENT> __slots__ = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> def __init__ ( self , id ) : <NEWLINE> <INDENT> self . id = id <NEWLINE> self . p = - 1 <NEWLINE> self . sibling = - 1 <NEWLINE> self . degree = 0 <NEWLINE> self . depth = 0 <NEWLINE> self . height = 0 <NEWLINE> self . type = <STRING> <NEWLINE> self . c = [ ] <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> tree = tuple ( Tree ( i ) for i in range ( n ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> id , * c = map ( int , readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ) <NEWLINE> if c != [ ] : <NEWLINE> <INDENT> tree [ id ] . type = <STRING> <NEWLINE> tree [ id ] . c = c <NEWLINE> for j in c : <NEWLINE> <INDENT> tree [ j ] . p = id <NEWLINE> <DEDENT> len_c = len ( c ) <NEWLINE> tree [ id ] . degree = len_c <NEWLINE> if len_c == 2 : <NEWLINE> <INDENT> tree [ c [ 0 ] ] . sibling = c [ 1 ] <NEWLINE> tree [ c [ 1 ] ] . sibling = c [ 0 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> root = 0 <NEWLINE> while tree [ root ] . p != - 1 : <NEWLINE> <INDENT> root = tree [ root ] . p <NEWLINE> <DEDENT> tree [ root ] . type = <STRING> <NEWLINE> def depth_height_check ( id , d ) : <NEWLINE> <INDENT> d += 1 <NEWLINE> height = 0 <NEWLINE> for i in tree [ id ] . c : <NEWLINE> <INDENT> tree [ i ] . depth = d <NEWLINE> if tree [ i ] . type != <STRING> : <NEWLINE> <INDENT> tree [ i ] . height = depth_height_check ( i , d ) + 1 <NEWLINE> height = max ( height , tree [ i ] . height ) <NEWLINE> <DEDENT> <DEDENT> return height <NEWLINE> <DEDENT> tree [ root ] . height = depth_height_check ( root , 0 ) + 1 if n > 1 else 0 <NEWLINE> print ( <STRING> . join ( map ( str , tree ) ) ) <NEWLINE> <DEDENT> solve ( ) <NEWLINE> <NL>
a = input ( ) <NEWLINE> if a . isupper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d . sort ( ) <NEWLINE> ans = d [ N // 2 ] - d [ N // 2 - 1 ] <NEWLINE> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> if n * 2 <= m : <NEWLINE> <INDENT> ans += n <NEWLINE> m -= n * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += m // 2 <NEWLINE> m %= 2 <NEWLINE> <NL> <DEDENT> if m >= 4 : <NEWLINE> <INDENT> ans += m // 4 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
s = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> n = int ( len ( s ) / 2 ) <NEWLINE> <NL> a = [ 0 ] * len ( s ) <NEWLINE> b = [ 0 ] * len ( s ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a [ 2 * i ] = 0 <NEWLINE> a [ 2 * i + 1 ] = 1 <NEWLINE> b [ 2 * i ] = 1 <NEWLINE> b [ 2 * i + 1 ] = 0 <NEWLINE> <NL> <DEDENT> if len ( s ) % 2 == 1 : <NEWLINE> <INDENT> a [ len ( s ) - 1 ] = 0 <NEWLINE> b [ len ( s ) - 1 ] = 1 <NEWLINE> <NL> <NL> <DEDENT> an = 0 <NEWLINE> bn = 0 <NEWLINE> <NL> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> if a [ j ] != s [ j ] : <NEWLINE> <INDENT> an += 1 <NEWLINE> <DEDENT> if b [ j ] != s [ j ] : <NEWLINE> <INDENT> bn += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( an , bn ) ) <NEWLINE>
<COMMENT> <NL> while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import datetime <NEWLINE> import string <NEWLINE> import re <NEWLINE> import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> input = input ( ) <NEWLINE> str = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> str . append ( input [ i ] ) <NEWLINE> <DEDENT> str . reverse ( ) <NEWLINE> <NL> count = 0 <NEWLINE> begin = 0 <NEWLINE> end = len ( str ) - 1 <NEWLINE> while True : <NEWLINE> <INDENT> if begin < len ( str ) : <NEWLINE> <INDENT> while str [ begin ] == <STRING> : <NEWLINE> <INDENT> begin += 1 <NEWLINE> if begin == len ( str ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if end >= 0 : <NEWLINE> <INDENT> while str [ end ] == <STRING> : <NEWLINE> <INDENT> end -= 1 <NEWLINE> if end == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if begin < end : <NEWLINE> <INDENT> str [ begin ] = <STRING> <NEWLINE> str [ end ] = <STRING> <NEWLINE> begin += 1 <NEWLINE> end -= 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> elif begin >= len ( str ) and end > - 1 : <NEWLINE> <INDENT> if end != len ( str ) - 1 : <NEWLINE> <INDENT> if str [ end + 1 ] == <STRING> : <NEWLINE> <INDENT> str [ end ] = <STRING> <NEWLINE> end -= 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> end -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> end -= 1 <NEWLINE> <DEDENT> <DEDENT> elif begin < len ( str ) and end <= - 1 : <NEWLINE> <INDENT> if begin != 0 : <NEWLINE> <INDENT> if str [ begin - 1 ] == <STRING> : <NEWLINE> <INDENT> str [ begin ] = <STRING> <NEWLINE> begin += 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> begin += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> begin += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( count ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> <NL> S = list ( S ) <NEWLINE> T = list ( T ) <NEWLINE> <NL> <NL> def check ( S , T ) : <NEWLINE> <INDENT> len_S = len ( S ) <NEWLINE> len_T = len ( T ) <NEWLINE> <NL> for i in range ( len_S ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> result = check ( S , T ) <NEWLINE> print ( result ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flg = [ 0 ] * N <NEWLINE> T = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for m in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> T [ a - 1 ] . append ( b ) <NEWLINE> T [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> if not T [ n ] : <NEWLINE> <INDENT> flg [ n ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> MAX = max ( [ H [ t - 1 ] for t in T [ n ] ] ) <NEWLINE> if H [ n ] > MAX : <NEWLINE> <INDENT> flg [ n ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( flg ) ) <NEWLINE>
from sys import stdin <NEWLINE> readline = stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> v , e = map ( int , readline ( ) . split ( ) ) <NEWLINE> from collections import defaultdict <NEWLINE> g = defaultdict ( list ) <NEWLINE> <NL> for _ in range ( e ) : <NEWLINE> <INDENT> s , t = map ( int , readline ( ) . split ( ) ) <NEWLINE> g [ s ] . append ( t ) <NEWLINE> g [ t ] . append ( s ) <NEWLINE> <NL> <DEDENT> visited = set ( ) <NEWLINE> lowest = [ None ] * v <NEWLINE> parent = [ None ] * v <NEWLINE> prenum = [ None ] * v <NEWLINE> child = defaultdict ( list ) <NEWLINE> root = 0 <NEWLINE> <NL> <COMMENT> <NL> stack = [ ( root , None ) ] <NEWLINE> while stack : <NEWLINE> <INDENT> u , prev = stack . pop ( ) <NEWLINE> if u not in visited : <NEWLINE> <INDENT> parent [ u ] = prev <NEWLINE> if prev is not None : <NEWLINE> <INDENT> child [ prev ] . append ( u ) <NEWLINE> <DEDENT> visited |= { u } <NEWLINE> prenum [ u ] = lowest [ u ] = len ( visited ) <NEWLINE> <NL> <DEDENT> stack . extend ( [ ( v , u ) for v in g [ u ] if v not in visited ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> from collections import Counter <NEWLINE> leaf = [ i for i in range ( v ) if not child [ i ] ] <NEWLINE> unfinished = Counter ( ) <NEWLINE> for li in leaf : <NEWLINE> <INDENT> while li is not None : <NEWLINE> <INDENT> candidate = [ prenum [ li ] ] + [ prenum [ i ] for i in g [ li ] if i != parent [ li ] ] + [ lowest [ i ] for i in child [ li ] ] <NEWLINE> lowest [ li ] = min ( candidate ) <NEWLINE> li = parent [ li ] <NEWLINE> if li is not None and 1 < len ( child [ li ] ) : <NEWLINE> <INDENT> unfinished [ li ] += 1 <NEWLINE> if unfinished [ li ] < len ( child [ li ] ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if 2 <= len ( child [ root ] ) : <NEWLINE> <INDENT> print ( root ) <NEWLINE> <DEDENT> for i in range ( 1 , v ) : <NEWLINE> <INDENT> if child [ i ] and any ( prenum [ i ] <= lowest [ j ] for j in child [ i ] ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> <NL> <NL> class Node ( object ) : <NEWLINE> <INDENT> def __init__ ( self , data ) : <NEWLINE> <INDENT> self . data = data <NEWLINE> self . left , self . right = None , None <NEWLINE> <NL> <DEDENT> def insert ( self , data ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if data < self . data : <NEWLINE> <INDENT> if self . left is None : <NEWLINE> <INDENT> self . left = Node ( data ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . left . insert ( data ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if self . right is None : <NEWLINE> <INDENT> self . right = Node ( data ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . right . insert ( data ) <NEWLINE> <NL> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> def inorder ( node ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> if node . left : <NEWLINE> <INDENT> yield from inorder ( node . left ) <NEWLINE> <DEDENT> yield node . data <NEWLINE> if node . right : <NEWLINE> <INDENT> yield from inorder ( node . right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def preorder ( node ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> yield node . data <NEWLINE> <NL> for n in [ node . left , node . right ] : <NEWLINE> <INDENT> if n : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> yield from preorder ( n ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def action ( command , content ) : <NEWLINE> <INDENT> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree_root . insert ( data = int ( content ) ) <NEWLINE> <NL> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> , * inorder ( node = tree_root ) ) <NEWLINE> print ( <STRING> , * preorder ( node = tree_root ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> array_length = int ( _input [ 0 ] ) <NEWLINE> command_list = list ( map ( lambda x : x . split ( ) , _input [ 1 : ] ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> flag , tree_root = False , None <NEWLINE> for each in command_list : <NEWLINE> <INDENT> command , content = each [ 0 ] , each [ - 1 ] <NEWLINE> if ( not flag ) and command . startswith ( <STRING> ) : <NEWLINE> <INDENT> tree_root = Node ( data = int ( content ) ) <NEWLINE> flag = True <NEWLINE> continue <NEWLINE> <DEDENT> action ( command = command , content = content ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> dic_items = { 0 : <STRING> , 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> , 6 : <STRING> , 7 : <STRING> , 8 : <STRING> , 9 : <STRING> , 10 : <STRING> , 11 : <STRING> , 12 : <STRING> , 13 : <STRING> , 14 : <STRING> , 15 : <STRING> , 16 : <STRING> , 17 : <STRING> , 18 : <STRING> <NEWLINE> <INDENT> , 19 : <STRING> , 20 : <STRING> , 21 : <STRING> , 22 : <STRING> , 23 : <STRING> , 24 : <STRING> , 25 : <STRING> } <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> while n != 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> ans . append ( n % 26 ) <NEWLINE> n = n // 26 <NEWLINE> <DEDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( dic_items [ ans [ len ( ans ) - 1 - i ] ] , end = <STRING> ) <NEWLINE> <NL> <DEDENT>
import numpy as np <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 0 , n - k ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> K = sum ( A ) <NEWLINE> S = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> K = K - A [ i ] <NEWLINE> S = S + A [ i ] * K <NEWLINE> <NL> <DEDENT> ans = S % ( 10 ** 9 + 7 ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = 1 <NEWLINE> from collections import Counter <NEWLINE> count = Counter ( al ) <NEWLINE> cc = count [ 0 ] <NEWLINE> <NL> if cc >= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> res *= al [ i ] <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parent = [ i for i in range ( n ) ] <NEWLINE> self . rank = [ 1 ] * n <COMMENT> <NEWLINE> self . size = [ 1 ] * n <COMMENT> <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <COMMENT> <NEWLINE> <INDENT> if self . parent [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ x ] = self . find ( self . parent [ x ] ) <COMMENT> <NEWLINE> return self . parent [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <COMMENT> <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x != y : <NEWLINE> <INDENT> if self . rank [ x ] < self . rank [ y ] : <COMMENT> <NEWLINE> <INDENT> self . parent [ x ] = y <NEWLINE> self . size [ y ] += self . size [ x ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ y ] = x <NEWLINE> self . size [ x ] += self . size [ y ] <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ x ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def group_size ( self , x ) : <COMMENT> <NEWLINE> <INDENT> return self . size [ self . find ( x ) ] <NEWLINE> <DEDENT> def is_same ( self , x , y ) : <COMMENT> <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> uf = UnionFind ( n ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . unite ( a - 1 , b - 1 ) <NEWLINE> ans [ a - 1 ] -= 1 <NEWLINE> ans [ b - 1 ] -= 1 <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if uf . is_same ( c - 1 , d - 1 ) : <NEWLINE> <INDENT> ans [ c - 1 ] -= 1 <NEWLINE> ans [ d - 1 ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans [ i ] += uf . group_size ( i ) - 1 <NEWLINE> print ( ans [ i ] ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( str ( a * b ) + <STRING> + str ( 2 * a + 2 * b ) ) <NEWLINE>
base1 = 1009 <NEWLINE> base2 = 1013 <NEWLINE> mask = ( 1 << 32 ) - 1 <NEWLINE> def calc_hash ( f , r , c ) : <NEWLINE> <INDENT> global ph , pw , h <NEWLINE> tmp = [ [ 0 ] * c for _ in range ( r ) ] <NEWLINE> dr , dc = r - ph , c - pw <NEWLINE> t1 = 1 <NEWLINE> for _ in range ( pw ) : <NEWLINE> <INDENT> t1 = ( t1 * base1 ) & mask <NEWLINE> <DEDENT> for i in range ( r ) : <NEWLINE> <INDENT> e = 0 <NEWLINE> for j in range ( pw ) : <NEWLINE> <INDENT> e = e * base1 + f [ i ] [ j ] <NEWLINE> <DEDENT> for j in range ( dc ) : <NEWLINE> <INDENT> tmp [ i ] [ j ] = e <NEWLINE> e = ( e * base1 - t1 * f [ i ] [ j ] + f [ i ] [ j + pw ] ) & mask <NEWLINE> <DEDENT> tmp [ i ] [ dc ] = e <NEWLINE> <DEDENT> t2 = 1 <NEWLINE> for _ in range ( ph ) : <NEWLINE> <INDENT> t2 = ( t2 * base2 ) & mask <NEWLINE> <DEDENT> for j in range ( dc + 1 ) : <NEWLINE> <INDENT> e = 0 <NEWLINE> for i in range ( ph ) : <NEWLINE> <INDENT> e = e * base2 + tmp [ i ] [ j ] <NEWLINE> <DEDENT> for i in range ( dr ) : <NEWLINE> <INDENT> h [ i ] [ j ] = e <NEWLINE> e = ( e * base2 - t2 * tmp [ i ] [ j ] + tmp [ i + ph ] [ j ] ) & mask <NEWLINE> <DEDENT> h [ dr ] [ j ] = e <NEWLINE> <DEDENT> <DEDENT> th , tw = map ( int , input ( ) . split ( ) ) <NEWLINE> t = tuple ( tuple ( ord ( c ) for c in input ( ) ) for _ in range ( th ) ) <NEWLINE> ph , pw = map ( int , input ( ) . split ( ) ) <NEWLINE> p = tuple ( tuple ( ord ( c ) for c in input ( ) ) for _ in range ( ph ) ) <NEWLINE> if th >= ph and tw >= pw : <NEWLINE> <INDENT> h = [ [ 0 ] * tw for _ in range ( th ) ] <NEWLINE> calc_hash ( p , ph , pw ) <NEWLINE> key = h [ 0 ] [ 0 ] & mask <NEWLINE> calc_hash ( t , th , tw ) <NEWLINE> for i in range ( th - ph + 1 ) : <NEWLINE> <INDENT> for j in range ( tw - pw + 1 ) : <NEWLINE> <INDENT> if h [ i ] [ j ] & mask == key : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> X = [ None ] * N <NEWLINE> l = list ( input ( ) ) <NEWLINE> Xc = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> X [ i ] = int ( l [ i ] ) <NEWLINE> Xc += X [ i ] <NEWLINE> <NL> <DEDENT> if Xc == 0 : <NEWLINE> <INDENT> [ print ( 1 ) for i in range ( N ) ] <NEWLINE> <DEDENT> elif Xc == 1 : <NEWLINE> <INDENT> d = X . index ( 1 ) <NEWLINE> ans1 = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if X [ j ] : <NEWLINE> <INDENT> ans1 += pow ( 2 , N - 1 - j , Xc + 1 ) <NEWLINE> ans1 %= Xc + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> if d == j : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if d == N - 1 or j == N - 1 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans1 = 0 <NEWLINE> ans2 = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if X [ j ] : <NEWLINE> <INDENT> ans1 += pow ( 2 , N - 1 - j , Xc + 1 ) <NEWLINE> ans1 %= Xc + 1 <NEWLINE> ans2 += pow ( 2 , N - 1 - j , Xc - 1 ) <NEWLINE> ans2 %= Xc - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] : <COMMENT> <NEWLINE> <INDENT> ans = ( ans2 - pow ( 2 , N - 1 - i , Xc - 1 ) ) % ( Xc - 1 ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> ans = ( ans1 + pow ( 2 , N - 1 - i , Xc + 1 ) ) % ( Xc + 1 ) <NEWLINE> <DEDENT> count = 1 <NEWLINE> while ans > 0 : <NEWLINE> <INDENT> tmp = str ( bin ( ans ) ) . count ( <STRING> ) <NEWLINE> ans %= tmp <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
T = input ( ) <NEWLINE> <NL> S = T . replace ( <STRING> , <STRING> ) <NEWLINE> print ( S ) <NEWLINE>
<COMMENT> <NL> import bisect <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> L = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( N - 2 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , N - 1 ) : <NEWLINE> <INDENT> ans += bisect . bisect_right ( L , L [ a ] + L [ b ] - 1 ) - b - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def comb ( n , r , mod ) : <NEWLINE> <INDENT> if r > n - r : <NEWLINE> <INDENT> r = n - r <NEWLINE> <NL> <DEDENT> res_X = 1 <NEWLINE> for i in range ( n - r + 1 , n + 1 ) : <NEWLINE> <INDENT> res_X = ( res_X * i ) % mod <NEWLINE> <NL> <DEDENT> res_Y = 1 <NEWLINE> for i in range ( 1 , r + 1 ) : <NEWLINE> <INDENT> res_Y = ( res_Y * i ) % mod <NEWLINE> <NL> <DEDENT> return ( res_X * pow ( res_Y , mod - 2 , mod ) ) % mod <NEWLINE> <NL> <DEDENT> base = ( pow ( 2 , n , MOD ) - 1 ) % MOD <NEWLINE> a = comb ( n , a , MOD ) <NEWLINE> b = comb ( n , b , MOD ) <NEWLINE> <NL> print ( ( base - a - b ) % MOD ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> L = { } <NEWLINE> R = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i + a [ i ] in L : <NEWLINE> <INDENT> L [ i + a [ i ] ] . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ i + a [ i ] ] = [ i ] <NEWLINE> <DEDENT> if i - a [ i ] in R : <NEWLINE> <INDENT> R [ i - a [ i ] ] . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R [ i - a [ i ] ] = [ i ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i in L and i in R : <NEWLINE> <INDENT> ans += len ( L [ i ] ) * len ( R [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in a : <NEWLINE> <INDENT> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = x * c <NEWLINE> c = z <NEWLINE> if z > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( z ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> rev = 0 <NEWLINE> front , back = [ ] , [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> q = input ( ) <NEWLINE> if len ( q ) == 1 : rev = 1 - rev <NEWLINE> else : <NEWLINE> <INDENT> n , f , c = q . split ( ) <NEWLINE> if f == <STRING> and rev == 0 : <NEWLINE> <INDENT> front . append ( c ) <NEWLINE> <DEDENT> elif f == <STRING> and rev == 1 : <NEWLINE> <INDENT> front . append ( c ) <NEWLINE> <DEDENT> elif f == <STRING> and rev == 1 : <NEWLINE> <INDENT> back . append ( c ) <NEWLINE> <DEDENT> elif f == <STRING> and rev == 0 : <NEWLINE> <INDENT> back . append ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if rev == 0 : <NEWLINE> <INDENT> S = <STRING> . join ( front [ : : - 1 ] ) + S + <STRING> . join ( back ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = <STRING> . join ( back [ : : - 1 ] ) + S [ : : - 1 ] + <STRING> . join ( front ) <NEWLINE> <DEDENT> print ( S ) <NEWLINE>
n , t = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c , tt = map ( int , input ( ) . split ( ) ) <NEWLINE> if tt > t : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> li . append ( c ) <NEWLINE> <DEDENT> if len ( li ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( li ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> import numpy as np <NEWLINE> import queue <NEWLINE> from collections import deque <NEWLINE> import heapq <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> iw0 = 0 <NEWLINE> <NL> def twoxxn ( t , mod ) : <NEWLINE> <INDENT> ni = t <NEWLINE> an = 1 <NEWLINE> n2 = 2 <NEWLINE> while ni > 0 : <NEWLINE> <INDENT> if ni % 2 == 1 : <NEWLINE> <INDENT> an = ( an * n2 ) % mod <NEWLINE> <DEDENT> n2 = ( n2 ** 2 ) % mod <NEWLINE> ni >>= 1 <NEWLINE> <DEDENT> return an <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> d = dict ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> iw0 += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if a == 0 : <NEWLINE> <INDENT> b = 1 <NEWLINE> g = 1 <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> a = 1 <NEWLINE> g = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = math . gcd ( abs ( a ) , abs ( b ) ) <NEWLINE> <DEDENT> if a < 0 : <NEWLINE> <INDENT> a = - a <NEWLINE> b = - b <NEWLINE> <DEDENT> p1 = a // g , b // g <NEWLINE> if p1 in d : <NEWLINE> <INDENT> d [ p1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ p1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> done = [ ] <NEWLINE> for ( i0 , i1 ) , din in d . items ( ) : <NEWLINE> <INDENT> if d . get ( ( - i1 , i0 ) , 1 ) == 0 or d . get ( ( i1 , - i0 ) , 1 ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> w = d . get ( ( i1 , - i0 ) , 0 ) + d . get ( ( - i1 , i0 ) , 0 ) <NEWLINE> aaa = ( twoxxn ( w , mod ) + twoxxn ( din , mod ) - 1 ) % mod <NEWLINE> ans = ( ans * aaa ) % mod <NEWLINE> d [ ( i0 , i1 ) ] = 0 <NEWLINE> <NL> <DEDENT> if len ( d . keys ( ) ) == 0 : <NEWLINE> <INDENT> print ( iw0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = ( iw0 + ans + mod - 1 ) % mod <NEWLINE> print ( ans ) <NEWLINE>
N , point , answer = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> W = [ point ] * N <NEWLINE> for i in range ( answer ) : <NEWLINE> <INDENT> U = int ( input ( ) ) <NEWLINE> W [ U - 1 ] += 1 <NEWLINE> <DEDENT> W = [ n - answer for n in W ] <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> if W [ k ] <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> dp = [ 0 ] * ( x + 105 + 1 ) <NEWLINE> dp [ 100 ] = 1 <NEWLINE> dp [ 101 ] = 1 <NEWLINE> dp [ 102 ] = 1 <NEWLINE> dp [ 103 ] = 1 <NEWLINE> dp [ 104 ] = 1 <NEWLINE> dp [ 105 ] = 1 <NEWLINE> <NL> for i in range ( 100 , x - 105 + 100 ) : <NEWLINE> <INDENT> for j in range ( 100 , 106 ) : <NEWLINE> <INDENT> dp [ i + j ] = max ( dp [ i ] , dp [ i + j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ x ] ) <NEWLINE>
from collections import deque <NEWLINE> <NL> class PriorityQueue : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . nodes = [ ] <NEWLINE> <NL> <DEDENT> def max_heapify ( self , i ) : <NEWLINE> <INDENT> if i >= len ( self . nodes ) : return <NEWLINE> left , right = ( i + 1 ) * 2 - 1 , ( i + 1 ) * 2 <NEWLINE> <NL> largest = i <NEWLINE> if left < len ( self . nodes ) and self . nodes [ i ] < self . nodes [ left ] : largest = left <NEWLINE> if right < len ( self . nodes ) and self . nodes [ largest ] < self . nodes [ right ] : largest = right <NEWLINE> <NL> if largest != i : <NEWLINE> <INDENT> self . nodes [ i ] , self . nodes [ largest ] = self . nodes [ largest ] , self . nodes [ i ] <NEWLINE> self . max_heapify ( largest ) <NEWLINE> <NL> <DEDENT> <DEDENT> def print_element ( self ) : <NEWLINE> <INDENT> for node in self . nodes : <NEWLINE> <INDENT> print ( <STRING> , node , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> pq = PriorityQueue ( ) <NEWLINE> pq . nodes = A <NEWLINE> <NL> for i in range ( ( n - 1 ) // 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> pq . max_heapify ( i ) <NEWLINE> <NL> <DEDENT> pq . print_element ( ) <NEWLINE>
def is_prime ( x ) : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> if x < 2 or x % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( 3 , int ( x ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> i = int ( input ( ) ) <NEWLINE> cnt += is_prime ( i ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL>
import sys <NEWLINE> import numpy as np <NEWLINE> import math <COMMENT> <NEWLINE> import collections <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> from copy import deepcopy <NEWLINE> from itertools import accumulate <COMMENT> <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> from functools import lru_cache <COMMENT> <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) ) <NEWLINE> a = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> q = int ( sys . stdin . readline ( ) ) <NEWLINE> queue = [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> count = collections . Counter ( a ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for k in count : <NEWLINE> <INDENT> ans += k * count [ k ] <NEWLINE> <DEDENT> for b , c in queue : <NEWLINE> <INDENT> if b in count : <NEWLINE> <INDENT> if c in count : <NEWLINE> <INDENT> count [ c ] += count [ b ] <NEWLINE> ans += ( c - b ) * count [ b ] <NEWLINE> del count [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count [ c ] = count [ b ] <NEWLINE> ans += ( c - b ) * count [ b ] <NEWLINE> <NL> del count [ b ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> S = np . array ( [ [ int ( c == <STRING> ) for c in input ( ) ] for _ in range ( H ) ] ) <NEWLINE> <NL> up = S . copy ( ) <NEWLINE> down = S . copy ( ) <NEWLINE> left = S . copy ( ) <NEWLINE> right = S . copy ( ) <NEWLINE> <NL> for i in range ( 1 , H ) : <NEWLINE> <INDENT> up [ i ] = ( up [ i - 1 ] + 1 ) * up [ i ] <NEWLINE> down [ - i - 1 ] = ( down [ - i ] + 1 ) * down [ - i - 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , W ) : <NEWLINE> <INDENT> left [ : , i ] = ( left [ : , i - 1 ] + 1 ) * left [ : , i ] <NEWLINE> right [ : , - i - 1 ] = ( right [ : , - i ] + 1 ) * right [ : , - i - 1 ] <NEWLINE> <NL> <DEDENT> print ( np . max ( up + down + left + right ) - 3 ) <NEWLINE>
ni = lambda : int ( input ( ) ) <NEWLINE> nm = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = ni ( ) <NEWLINE> a = nl ( ) <NEWLINE> nums = [ 0 ] * 10 ** 6 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> nums [ a [ i ] ] += 1 <NEWLINE> <DEDENT> q = ni ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( nums ) ) : <NEWLINE> <INDENT> ans += nums [ i ] * i <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = nm ( ) <NEWLINE> ans -= nums [ b ] * b <NEWLINE> ans += nums [ b ] * c <NEWLINE> nums [ c ] += nums [ b ] <NEWLINE> nums [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = [ ] <NEWLINE> <NL> S = sum ( A2 ) + A1 [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> C . append ( S ) <NEWLINE> S += A1 [ i ] - A2 [ i - 1 ] <NEWLINE> <NL> <DEDENT> if N != 1 : <NEWLINE> <INDENT> print ( max ( C ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A1 [ 0 ] + A2 [ 0 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 0 <NEWLINE> for i , ai in enumerate ( a ) : <NEWLINE> <INDENT> if abs ( ai ) >= m : <NEWLINE> <INDENT> m = abs ( ai ) <NEWLINE> mi = i <NEWLINE> <DEDENT> <DEDENT> ret = [ [ mi + 1 , i + 1 ] for i in range ( n ) ] <NEWLINE> if a [ mi ] >= 0 : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ret . append ( [ i + 1 , i + 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> ret . append ( [ i + 2 , i + 1 ] ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> print ( 2 * n - 1 ) <NEWLINE> for x in ret : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , x ) ) ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ ] <NEWLINE> if k * 2 >= b - a + 1 : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> li . append ( i ) <NEWLINE> <DEDENT> for i in range ( len ( li ) ) : <NEWLINE> <INDENT> print ( li [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> li . append ( a + i ) <NEWLINE> li . append ( b - i ) <NEWLINE> <DEDENT> li . sort ( ) <NEWLINE> for i in range ( len ( li ) ) : <NEWLINE> <INDENT> print ( li [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> for i in range ( - 120 , 120 ) : <NEWLINE> <INDENT> for j in range ( - 120 , 120 ) : <NEWLINE> <INDENT> if ( i ** 5 - j ** 5 == x ) : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> inf = 100000000001 <NEWLINE> n1 , n2 = mid - left , right - mid <NEWLINE> L , R = A [ left : left + n1 ] + [ inf ] , A [ mid : mid + n2 ] + [ inf ] <NEWLINE> i = j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> mergeSort ( A , 0 , n ) <NEWLINE> print ( * A ) <NEWLINE> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> RGB = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> import collections <NEWLINE> if len ( set ( list ( S ) ) ) <= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dct = dict ( collections . Counter ( S ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for k in range ( ( N - 1 - i ) // 2 + 1 ) : <NEWLINE> <INDENT> temp = { S [ i ] , S [ i + k ] , S [ i + k * 2 ] } <NEWLINE> if len ( temp ) == 3 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dct [ <STRING> ] * dct [ <STRING> ] * dct [ <STRING> ] - cnt ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n < b : <NEWLINE> <INDENT> print ( a * n // b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n == b : <NEWLINE> <INDENT> print ( a * ( n - 1 ) // b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = n // b <NEWLINE> print ( max ( ( a * n // b - a * i ) , ( a * ( b * i - 1 ) // b - a * ( i - 1 ) ) ) ) <NEWLINE> <DEDENT> <DEDENT>
def fizzbuzz ( i ) : <NEWLINE> <INDENT> if i % 15 == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif i % 5 == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif i % 3 == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return str ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> <NL> while True : <NEWLINE> <INDENT> m , n = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> if m == n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> member = list ( range ( 1 , m + 1 ) ) <NEWLINE> s = [ f . readline ( ) . strip ( ) for _ in range ( n ) ] <NEWLINE> <NL> pos = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] != fizzbuzz ( i + 1 ) : <NEWLINE> <INDENT> del member [ pos ] <NEWLINE> m = len ( member ) <NEWLINE> if m == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pos += 1 <NEWLINE> <DEDENT> pos %= m <NEWLINE> <NL> <DEDENT> print ( * member ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = [ - 1 ] * N <NEWLINE> s [ 0 ] = 1 <NEWLINE> s [ 1 ] = 1 <NEWLINE> <NL> for m in range ( 0 , M ) : <NEWLINE> <INDENT> i = int ( input ( ) ) <NEWLINE> s [ i ] = 0 <NEWLINE> <NL> <DEDENT> for n in range ( 2 , N ) : <NEWLINE> <INDENT> if s [ n ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> s [ n ] = s [ n - 1 ] + s [ n - 2 ] <NEWLINE> <NL> <DEDENT> print ( ( s [ N - 1 ] + s [ N - 2 ] ) % 1000000007 ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d [ i + 1 ] = a [ i ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if d [ d [ i + 1 ] ] == i + 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> ans //= 2 <NEWLINE> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> C = Counter ( A ) <NEWLINE> C = sorted ( C . items ( ) ) <NEWLINE> <NL> cc = [ ] <NEWLINE> for a , b in C : <NEWLINE> <INDENT> cc . append ( [ a , b ] ) <NEWLINE> <DEDENT> C = cc <NEWLINE> <NL> M = len ( C ) <NEWLINE> <NL> left = 0 <NEWLINE> right = M - 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if C [ left ] [ 1 ] < 2 : <NEWLINE> <INDENT> p_left = left <NEWLINE> for left in range ( p_left , M ) : <NEWLINE> <INDENT> if C [ left ] [ 1 ] > 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if C [ right ] [ 1 ] < 2 : <NEWLINE> <INDENT> p_right = M - right - 1 <NEWLINE> for right in range ( M ) : <NEWLINE> <INDENT> if C [ M - right - 1 ] [ 1 ] > 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> right = M - right - 1 <NEWLINE> <NL> <DEDENT> if C [ left ] [ 1 ] <= 1 and C [ right ] [ 1 ] <= 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if left == right : <NEWLINE> <INDENT> if C [ left ] [ 1 ] >= 3 : <NEWLINE> <INDENT> C [ left ] [ 1 ] -= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = 0 <NEWLINE> C [ left ] [ 1 ] -= 1 <NEWLINE> for i in range ( left + 1 , M ) : <NEWLINE> <INDENT> if C [ i ] [ 1 ] > 0 : <NEWLINE> <INDENT> C [ i ] [ 1 ] -= 1 <NEWLINE> f = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if f == 0 : <NEWLINE> <INDENT> for i in range ( 0 , left ) : <NEWLINE> <INDENT> if C [ i ] [ 1 ] > 0 : <NEWLINE> <INDENT> C [ i ] [ 1 ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> C [ left ] [ 1 ] -= 1 <NEWLINE> C [ right ] [ 1 ] -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a , b in C : <NEWLINE> <INDENT> ans += b <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> import itertools <NEWLINE> <NL> sys . setrecursionlimit ( 500 * 500 ) <NEWLINE> <NL> def yn ( b ) : <NEWLINE> <INDENT> print ( <STRING> if b == 1 else <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> readline = sys . stdin . readline <NEWLINE> <NL> n , m , q = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> aa = [ 0 ] * q <NEWLINE> bb = [ 0 ] * q <NEWLINE> cc = [ 0 ] * q <NEWLINE> dd = [ 0 ] * q <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> aa [ i ] , bb [ i ] , cc [ i ] , dd [ i ] = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> max_score = 0 <NEWLINE> <NL> for a in itertools . combinations_with_replacement ( list ( range ( 1 , m + 1 ) ) , n ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if ( a [ bb [ i ] - 1 ] - a [ aa [ i ] - 1 ] ) == cc [ i ] : <NEWLINE> <INDENT> score += dd [ i ] <NEWLINE> <DEDENT> <DEDENT> max_score = max ( max_score , score ) <NEWLINE> <NL> <DEDENT> print ( max_score ) <NEWLINE> <NL> return <NEWLINE> <NL> <DEDENT> if <STRING> not in globals ( ) : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
from sys import setrecursionlimit , exit <NEWLINE> setrecursionlimit ( 1000000000 ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ( ans > 1e18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a > 0 and b > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a <= 0 and b >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < 0 and b < 0 : <NEWLINE> <INDENT> if ( ( b - a ) - 1 ) % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> result = a . __next__ ( ) <NEWLINE> <NL> for nb in a : <NEWLINE> <INDENT> na = result <NEWLINE> result *= nb <NEWLINE> while nb > 0 : <NEWLINE> <INDENT> na , nb = nb , na % nb <NEWLINE> <DEDENT> result //= na <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> maxCount = len ( T ) <NEWLINE> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> countNotEqual = 0 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if S [ j + i ] != T [ j ] : <NEWLINE> <INDENT> countNotEqual += 1 <NEWLINE> <DEDENT> <DEDENT> if countNotEqual < maxCount : <NEWLINE> <INDENT> maxCount = countNotEqual <NEWLINE> <DEDENT> <DEDENT> print ( maxCount ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 for i in range ( 10001 ) ] <NEWLINE> <NL> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> v = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if v < 10001 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> li = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = input ( ) <NEWLINE> li . append ( tmp ) <NEWLINE> <DEDENT> ans = set ( li ) <NEWLINE> print ( len ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> if ( a [ 0 ] == 0 ) : print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> s = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s *= a [ i ] <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : print ( s ) <NEWLINE> <DEDENT>
jun = 0 <NEWLINE> while True : <NEWLINE> <INDENT> num = 0 <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if jun > 0 : <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % 400 == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> num += 1 <NEWLINE> <DEDENT> elif i % 100 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif i % 4 == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> num += 1 <NEWLINE> <DEDENT> <DEDENT> if num == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> jun += 1 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> lst = [ 2 , 1 ] <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> lst . append ( lst [ i - 1 ] + lst [ i - 2 ] ) <NEWLINE> <DEDENT> print ( lst [ N ] ) <NEWLINE>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> B = [ tuple ( int ( i ) for i in input ( ) . split ( ) ) for i in range ( Q ) ] <NEWLINE> <NL> A = [ 1 ] * N <NEWLINE> def recur ( A = A , index = 0 , lim = M ) : <NEWLINE> <INDENT> if index > len ( A ) - 2 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> while A [ index ] <= lim - 1 : <NEWLINE> <INDENT> A [ index ] += 1 <NEWLINE> yield A [ : : - 1 ] <NEWLINE> yield from recur ( A [ : ] , index + 1 , A [ index ] ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> def get_point ( A ) : <NEWLINE> <INDENT> return sum ( ( A [ b [ 1 ] - 1 ] - A [ b [ 0 ] - 1 ] == b [ 2 ] ) * b [ 3 ] for b in B ) <NEWLINE> <NL> <DEDENT> print ( max ( 0 , get_point ( A ) , * ( get_point ( i ) for i in recur ( ) ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> n = N // i <COMMENT> <NEWLINE> cnt = ( n * ( 2 * i + ( n - 1 ) * i ) ) // 2 <COMMENT> <NEWLINE> ans += cnt <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> suma = [ 0 ] * ( n ) <NEWLINE> sumb = [ 0 ] * ( m ) <NEWLINE> suma [ 0 ] = a [ 0 ] <NEWLINE> sumb [ 0 ] = b [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> suma [ i ] = suma [ i - 1 ] + a [ i ] <NEWLINE> <DEDENT> for j in range ( 1 , m ) : <NEWLINE> <INDENT> sumb [ j ] = sumb [ j - 1 ] + b [ j ] <NEWLINE> <NL> <DEDENT> suma . insert ( 0 , 0 ) <NEWLINE> sumb . insert ( 0 , 0 ) <NEWLINE> <NL> ans , cur = 0 , m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> target = k - suma [ i ] <NEWLINE> if target < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while sumb [ cur ] > target : <NEWLINE> <INDENT> cur -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + cur ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> def calculate_length ( A , B , rad ) : <NEWLINE> <INDENT> length = ( A ** 2 ) + ( B ** 2 ) - ( 2 * A * B * math . cos ( math . pi * rad / 180 ) ) <NEWLINE> return math . sqrt ( length ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> rad = abs ( ( H * 60 + M ) * 0.5 - M * 6 ) <NEWLINE> length = calculate_length ( A , B , rad ) <NEWLINE> print ( length ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> anslist = [ 0 ] * N <NEWLINE> for a in alist : <NEWLINE> <INDENT> anslist [ a - 1 ] += 1 <NEWLINE> <DEDENT> for ans in anslist : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = [ int ( z ) for z in input ( ) . split ( <STRING> ) ] <NEWLINE> tn = n - 1 <NEWLINE> for c in range ( 0 , n ) : <NEWLINE> <INDENT> print ( <STRING> % x [ tn ] , end = <STRING> ) <NEWLINE> if c != n - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> tn -= 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> lines = sys . stdin . readlines ( ) <NEWLINE> for line in lines : <NEWLINE> <INDENT> H , W = map ( int , line . split ( ) ) <NEWLINE> if H == W == 0 : break <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> <NL> class Bt ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . used = [ False ] * 10 <COMMENT> <NEWLINE> self . answers = [ ] <COMMENT> <NEWLINE> self . Q = deque ( ) <COMMENT> <NEWLINE> <NL> <DEDENT> def solve ( self , num , remain ) : <NEWLINE> <COMMENT> <NL> <INDENT> try : <NEWLINE> <INDENT> min_choice = max ( self . Q ) + 1 <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> min_choice = 0 <NEWLINE> <NL> <DEDENT> if min_choice <= remain < 10 and self . used [ remain ] == False and num == 1 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> self . answers . append ( 1 ) <NEWLINE> return <NEWLINE> <DEDENT> elif num < 0 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> for i in range ( min_choice , 10 ) : <NEWLINE> <INDENT> if self . used [ i ] == False and ( remain - i ) >= 0 : <NEWLINE> <INDENT> self . used [ i ] = True <NEWLINE> self . Q . append ( i ) <NEWLINE> self . solve ( num - 1 , remain - i ) <NEWLINE> self . used [ i ] = False <NEWLINE> self . Q . pop ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <COMMENT> <NL> <INDENT> n , s = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> if n == 0 and s == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if 0 <= s <= 45 : <NEWLINE> <COMMENT> <NL> <INDENT> a = Bt ( ) <NEWLINE> a . solve ( n , s ) <NEWLINE> <NL> <COMMENT> <NL> print ( len ( a . answers ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> from collections import deque <NEWLINE> from operator import itemgetter <NEWLINE> from bisect import bisect_left , bisect <NEWLINE> import itertools <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import numpy as np <NEWLINE> import time <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> D = set ( ) <NEWLINE> S = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] in S : <NEWLINE> <INDENT> D . add ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . add ( A [ i ] ) <NEWLINE> <DEDENT> <DEDENT> M = max ( S ) <NEWLINE> X = [ 1 for i in range ( M + 1 ) ] <NEWLINE> for a in S : <NEWLINE> <INDENT> if a in D : <NEWLINE> <INDENT> X [ a ] = 0 <NEWLINE> <DEDENT> for i in range ( 2 * a , M + 1 , a ) : <NEWLINE> <INDENT> X [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ A [ i ] ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if H [ AB [ i ] [ 0 ] - 1 ] > H [ AB [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> ans [ AB [ i ] [ 1 ] - 1 ] += 1 <NEWLINE> <DEDENT> if H [ AB [ i ] [ 0 ] - 1 ] < H [ AB [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> ans [ AB [ i ] [ 0 ] - 1 ] += 1 <NEWLINE> <DEDENT> if H [ AB [ i ] [ 0 ] - 1 ] == H [ AB [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> ans [ AB [ i ] [ 0 ] - 1 ] += 1 <NEWLINE> ans [ AB [ i ] [ 1 ] - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans . count ( 0 ) ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> A = B = C = [ i for i in range ( 1 , K + 1 ) ] <NEWLINE> <NL> L = [ gcd ( a , b ) for a in A for b in B ] <NEWLINE> <NL> cnt = sum ( [ gcd ( l , c ) for l in L for c in C ] ) <NEWLINE> print ( cnt ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> plus = [ A [ i ] for i in range ( N ) if A [ i ] >= 0 ] <NEWLINE> minus = [ A [ i ] for i in range ( N ) if A [ i ] < 0 ] <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> P = len ( plus ) <NEWLINE> M = len ( minus ) <NEWLINE> plus . sort ( reverse = True ) <NEWLINE> minus . sort ( ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> if N == K : <NEWLINE> <INDENT> for x in A : <NEWLINE> <INDENT> ans *= x <NEWLINE> ans %= mod <NEWLINE> <DEDENT> <DEDENT> elif P == 0 : <NEWLINE> <INDENT> if K % 2 == 1 : <NEWLINE> <INDENT> minus . sort ( reverse = True ) <NEWLINE> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> ans *= minus [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> id = 0 <NEWLINE> if K % 2 == 1 : <NEWLINE> <INDENT> ans = plus [ 0 ] <NEWLINE> id = 1 <NEWLINE> P -= 1 <NEWLINE> K -= 1 <NEWLINE> <DEDENT> pp = [ plus [ i ] * plus [ i + 1 ] for i in range ( id , P - 1 + id , 2 ) ] <NEWLINE> mm = [ minus [ i ] * minus [ i + 1 ] for i in range ( 0 , M - 1 , 2 ) ] <NEWLINE> <NL> id = 0 <NEWLINE> id2 = 0 <NEWLINE> <NL> for i in range ( K // 2 ) : <NEWLINE> <INDENT> if id < P // 2 and ( id2 >= M // 2 or pp [ id ] >= mm [ id2 ] ) : <NEWLINE> <INDENT> ans *= pp [ id ] <NEWLINE> id += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= mm [ id2 ] <NEWLINE> id2 += 1 <NEWLINE> <DEDENT> ans %= mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans % mod ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> stack = [ 1 ] <NEWLINE> s = { 1 } <NEWLINE> <NL> def dfs ( a , k ) : <NEWLINE> <INDENT> global stack <NEWLINE> global s <NEWLINE> if k == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> next_a = A [ a ] <NEWLINE> if next_a in s : <NEWLINE> <INDENT> idx = stack . index ( next_a ) <NEWLINE> n = len ( stack ) <NEWLINE> k = ( k - 1 ) % ( n - idx ) <NEWLINE> return stack [ idx + k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . append ( next_a ) <NEWLINE> s . add ( next_a ) <NEWLINE> res = dfs ( next_a , k - 1 ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> print ( dfs ( 1 , K ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ int ( h ) for h in input ( ) . split ( ) ] <NEWLINE> <NL> d = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> d [ i + 1 ] = H [ i ] <NEWLINE> <NL> <DEDENT> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if H [ B - 1 ] >= H [ A - 1 ] : <NEWLINE> <INDENT> d [ A ] = 0 <NEWLINE> <NL> <DEDENT> if H [ B - 1 ] <= H [ A - 1 ] : <NEWLINE> <INDENT> d [ B ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( N - list ( d . values ( ) ) . count ( 0 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> s = x2 - x1 <NEWLINE> t = y2 - y1 <NEWLINE> u = x4 - x3 <NEWLINE> v = y4 - y3 ; <NEWLINE> if ( abs ( s * v - t * u ) < 1e-10 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> c = Counter ( A ) <NEWLINE> summ = 0 <NEWLINE> for k , v in c . items ( ) : <NEWLINE> <INDENT> summ += k * v <NEWLINE> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> B , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> summ += Q * c [ B ] - B * c [ B ] <NEWLINE> c [ Q ] += c [ B ] <NEWLINE> c [ B ] = 0 <NEWLINE> print ( summ ) <NEWLINE> <DEDENT>
int_n = int ( input ( ) ) <NEWLINE> list_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> int_tmp_highet = 0 <NEWLINE> int_count = 0 <NEWLINE> for i in list_a : <NEWLINE> <INDENT> if i > int_tmp_highet : <NEWLINE> <INDENT> int_tmp_highet = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> int_count = int_count + int_tmp_highet - i <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( int_count ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
<COMMENT> <NL> import itertools <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> abcd . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> Abase = [ ] <NEWLINE> for a in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> Abase = Abase + [ a ] <NEWLINE> <DEDENT> A = set ( itertools . combinations_with_replacement ( Abase , N ) ) <NEWLINE> ans = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> temp = 0 <NEWLINE> for j in abcd : <NEWLINE> <INDENT> if i [ j [ 1 ] - 1 ] - i [ j [ 0 ] - 1 ] == j [ 2 ] : <NEWLINE> <INDENT> temp = temp + j [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if temp >= ans : <NEWLINE> <INDENT> ans = temp <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import numpy as np <NEWLINE> from itertools import combinations_with_replacement <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> abcd_array = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> abcd = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd_array . append ( list ( abcd ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> anslist_candidates = combinations_with_replacement ( range ( 1 , M + 1 ) , N ) <NEWLINE> <NL> <NL> max_anslist_score = 0 <NEWLINE> for tmp_anslist in anslist_candidates : <NEWLINE> <INDENT> sum_d = 0 <NEWLINE> <NL> is_valid_anslist = True <NEWLINE> prev_ansitem = tmp_anslist [ 0 ] <NEWLINE> for ansitem in tmp_anslist [ 1 : ] : <NEWLINE> <INDENT> if prev_ansitem > ansitem : <NEWLINE> <INDENT> is_valid_anslist = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not is_valid_anslist : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for ai , bi , ci , di in abcd_array : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if ( ( tmp_anslist [ bi - 1 ] - tmp_anslist [ ai - 1 ] ) == ci ) : <NEWLINE> <INDENT> sum_d += di <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> max_anslist_score = max ( max_anslist_score , sum_d ) <NEWLINE> <NL> <DEDENT> print ( max_anslist_score ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> b . sort ( ) <NEWLINE> if 0 in b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . sort ( reverse = True ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> c *= b [ i ] <NEWLINE> if c > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> if s [ 2 ] == s [ 3 ] and s [ 4 ] == s [ 5 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A , B = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( a [ i ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if A [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while ( A [ i ] + B [ j ] ) > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def bisect_right_reverse ( L , target ) : <NEWLINE> <INDENT> ok = len ( L ) <NEWLINE> ng = - 1 <NEWLINE> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if L [ mid ] < target : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> L = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> k = bisect_right_reverse ( L , A [ i ] ) <NEWLINE> if k == len ( L ) : <NEWLINE> <INDENT> L . append ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ k ] = A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( L ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> taka1 = a // d <NEWLINE> taka2 = a % d <NEWLINE> aoki1 = c // b <NEWLINE> aoki2 = c % b <NEWLINE> <NL> if a % d != 0 : <NEWLINE> <INDENT> taka1 += 1 <NEWLINE> <DEDENT> if c % b != 0 : <NEWLINE> <INDENT> aoki1 += 1 <NEWLINE> <NL> <DEDENT> if taka1 >= aoki1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> cnt = 0 <NEWLINE> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> L = [ A [ i ] for i in range ( left , mid ) ] <NEWLINE> R = [ A [ i ] for i in range ( mid , right ) ] <NEWLINE> L . append ( float ( <STRING> ) ) <NEWLINE> R . append ( float ( <STRING> ) ) <NEWLINE> i = j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> cnt += n1 - i <NEWLINE> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def merge_sort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( A , left , mid ) <NEWLINE> merge_sort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> merge_sort ( a , 0 , len ( a ) ) <NEWLINE> print ( cnt ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> from bisect import bisect_left , bisect_right <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> edge = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> edge [ u ] . append ( v ) <NEWLINE> edge [ v ] . append ( u ) <NEWLINE> <DEDENT> ans = [ - 1 ] * n <NEWLINE> dp = [ 10 ** 10 ] * n <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def EulerTour ( n , s , e ) : <NEWLINE> <INDENT> EulerTour_list = [ ] <NEWLINE> def EulerTour_dfs ( i , root ) : <NEWLINE> <INDENT> EulerTour_list . append ( i ) <NEWLINE> ind = bisect_left ( dp , a [ i ] ) <NEWLINE> bef = dp [ ind ] <NEWLINE> dp [ ind ] = a [ i ] <NEWLINE> ans [ i ] = bisect_left ( dp , 10 ** 10 ) <NEWLINE> for j in e [ i ] : <NEWLINE> <INDENT> if j != root : <NEWLINE> <INDENT> EulerTour_dfs ( j , i ) <NEWLINE> <DEDENT> <DEDENT> if root != - 1 : <NEWLINE> <INDENT> EulerTour_list . append ( root ) <NEWLINE> dp [ ind ] = bef <NEWLINE> <DEDENT> <DEDENT> EulerTour_dfs ( s , - 1 ) <NEWLINE> return EulerTour_list <NEWLINE> <NL> <DEDENT> EulerTour ( n , 0 , edge ) <NEWLINE> print ( * ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = [ <STRING> * 20 if i % 4 == 0 else <STRING> * 10 for i in range ( 1 , 16 ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> h = 4 * b - ( 4 - f ) - 1 <NEWLINE> li [ h ] = li [ h ] . replace ( li [ h ] , <STRING> . join ( [ str ( int ( list ( li [ h ] ) [ r - 1 ] ) + v ) if i == r - 1 else list ( li [ h ] ) [ i ] for i in range ( 10 ) ] ) ) <NEWLINE> <DEDENT> li = [ <STRING> + <STRING> . join ( li [ i ] ) if ( i + 1 ) % 4 != 0 else li [ i ] for i in range ( len ( li ) ) ] <NEWLINE> print ( <STRING> . join ( li ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> counter = Counter ( S ) <NEWLINE> ans = counter [ <STRING> ] * counter [ <STRING> ] * counter [ <STRING> ] <NEWLINE> for l in range ( 1 , N ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i + 2 * l >= N : break <NEWLINE> a , b , c = S [ i ] , S [ i + l ] , S [ i + 2 * l ] <NEWLINE> if a != b and a != c and b != c : ans -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from itertools import groupby <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = [ <STRING> . join ( sorted ( input ( ) ) ) for i in range ( N ) ] <NEWLINE> sizes = [ len ( list ( v ) ) for k , v in groupby ( sorted ( S ) ) ] <NEWLINE> <NL> <NL> def combinations_count ( n , r ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <NL> <DEDENT> ans = sum ( [ combinations_count ( size , 2 ) for size in sizes ] ) <NEWLINE> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 1 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> if H [ A ] <= H [ B ] : <NEWLINE> <INDENT> l [ A ] = 0 <NEWLINE> <DEDENT> if H [ A ] >= H [ B ] : <NEWLINE> <INDENT> l [ B ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( l . count ( 1 ) ) <NEWLINE>
semester , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> score = input ( ) . split ( ) <NEWLINE> <NL> for i in range ( semester - K + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if int ( score [ K - K + i - 1 ] ) < int ( score [ K - 1 + i ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> ref = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> ref = ( 10 * ref + 7 ) % K <NEWLINE> if ref == 0 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> elif i == K - 1 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = A [ 0 ] <NEWLINE> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans = ans * A [ i + 1 ] <NEWLINE> if ans > 10 ** 18 or ans < - 1 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> target_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> check = Counter ( target_list ) <NEWLINE> result = sum ( target_list ) <NEWLINE> <NL> <NL> for index in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if B in check : <NEWLINE> <INDENT> result = result + ( check [ B ] ) * ( C - B ) <NEWLINE> if C in check : <NEWLINE> <INDENT> check [ C ] = check [ C ] + check [ B ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> check [ C ] = check [ B ] <NEWLINE> <DEDENT> check [ B ] = 0 <NEWLINE> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> line = sys . stdin . readlines ( ) <NEWLINE> deq = deque ( ) <NEWLINE> for i in range ( 1 , int ( line [ 0 ] ) + 1 ) : <NEWLINE> <INDENT> input_command = line [ i ] <NEWLINE> <NL> if input_command [ 0 ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> deq . appendleft ( input_command [ 7 : - 1 ] ) <NEWLINE> <DEDENT> elif input_command [ 0 ] == <STRING> : <NEWLINE> <INDENT> if input_command [ 6 ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> key = input_command [ 7 : - 1 ] <NEWLINE> if key in deq : <NEWLINE> <INDENT> deq . remove ( key ) <NEWLINE> <DEDENT> <DEDENT> elif input_command [ 6 ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> deq . popleft ( ) <NEWLINE> <DEDENT> elif input_command [ 6 ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> deq . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( deq ) ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
def GCD ( m , n ) : <NEWLINE> <INDENT> while n != 0 : <NEWLINE> <INDENT> m , n = n , m % n <NEWLINE> <DEDENT> return m <NEWLINE> <NL> <DEDENT> def gcd_all ( a ) : <NEWLINE> <INDENT> n = len ( a ) <NEWLINE> gcd = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> gcd = GCD ( gcd , a [ i ] ) <NEWLINE> <DEDENT> return gcd <NEWLINE> <NL> <DEDENT> def f ( a ) : <NEWLINE> <INDENT> mx = 10 ** 6 <NEWLINE> p = set ( [ ] ) <NEWLINE> sieve = [ i for i in range ( mx + 1 ) ] <NEWLINE> for i in range ( 2 , int ( mx ** 0.5 + 1 ) ) : <NEWLINE> <INDENT> for j in range ( 2 * i , mx + 1 , i ) : <NEWLINE> <INDENT> if sieve [ j ] > i : <NEWLINE> <INDENT> sieve [ j ] = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> pairwise_coprime = True <NEWLINE> for i in a : <NEWLINE> <INDENT> p2 = set ( [ ] ) <NEWLINE> while i > 1 : <NEWLINE> <INDENT> p2 . add ( sieve [ i ] ) <NEWLINE> i //= sieve [ i ] <NEWLINE> <DEDENT> for j in p2 : <NEWLINE> <INDENT> if j in p : <NEWLINE> <INDENT> pairwise_coprime = False <NEWLINE> break <NEWLINE> <DEDENT> p . add ( j ) <NEWLINE> <DEDENT> if pairwise_coprime == False : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> gcd = gcd_all ( a ) <NEWLINE> if pairwise_coprime == False and gcd == 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif pairwise_coprime : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( f ( a ) ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for num in range ( N ) : <NEWLINE> <INDENT> ans *= A [ num ] <NEWLINE> if ans > math . pow ( 10 , 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> iidp = [ list ( map ( int , input ( ) . split ( ) ) ) for q in range ( Q ) ] <NEWLINE> import itertools <NEWLINE> al = 0 <NEWLINE> for s1 in itertools . combinations_with_replacement ( list ( range ( 1 , M + 1 ) ) , N ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> for i1 , i2 , d , p in iidp : <NEWLINE> <INDENT> if s1 [ i2 - 1 ] - s1 [ i1 - 1 ] == d : <NEWLINE> <INDENT> a += p <NEWLINE> <DEDENT> <DEDENT> al = max ( a , al ) <NEWLINE> <NL> <DEDENT> print ( al ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N == 0 or K == 1 : <NEWLINE> <INDENT> N = 0 <NEWLINE> <DEDENT> elif N == K : <NEWLINE> <INDENT> N = 0 <NEWLINE> <DEDENT> elif N % K == 0 : <NEWLINE> <INDENT> N = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N = N % K <NEWLINE> while N != 0 : <NEWLINE> <INDENT> m = abs ( N - K ) <NEWLINE> if N < m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N = m <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( N ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N < 1000 : <NEWLINE> <INDENT> print ( 1000 - N ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> L = str ( N ) <NEWLINE> L1 = str ( L [ - 3 ] + L [ - 2 ] + L [ - 1 ] ) <NEWLINE> N1 = int ( L1 ) <NEWLINE> if N1 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - N1 ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans_ = gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( ans_ , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> max = - 1 <NEWLINE> i = - 1 <NEWLINE> while ( max == - 1 ) : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> if p . count ( x + i ) == 0 : <NEWLINE> <INDENT> max = x + i <NEWLINE> <NL> <DEDENT> <DEDENT> min = - 1 <NEWLINE> j = - 1 <NEWLINE> while ( min == - 1 ) : <NEWLINE> <INDENT> j = j + 1 <NEWLINE> if p . count ( x - j ) == 0 : <NEWLINE> <INDENT> min = x - j <NEWLINE> <NL> <DEDENT> <DEDENT> if ( abs ( x - max ) < abs ( x - min ) ) : <NEWLINE> <INDENT> print ( max ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> numList = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> product = 1 <NEWLINE> toPrint = True <NEWLINE> isZero = False <NEWLINE> for j in numList : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> isZero = True <NEWLINE> <DEDENT> <DEDENT> if not isZero : <NEWLINE> <INDENT> for i in numList : <NEWLINE> <INDENT> product = product * i <NEWLINE> if product > 10 ** 18 : <NEWLINE> <INDENT> toPrint = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if isZero : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if toPrint : <NEWLINE> <INDENT> print ( product ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> from math import gcd <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> temp = gcd ( i , j ) <NEWLINE> for m in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans = ans + gcd ( temp , m ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import bisect <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 202020 ) <NEWLINE> <NL> inf = float ( <STRING> ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> on = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> on [ u - 1 ] . append ( v - 1 ) <NEWLINE> on [ v - 1 ] . append ( u - 1 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> DP = [ inf ] * ( N + 1 ) <NEWLINE> stack = [ ] <NEWLINE> ans = [ - 1 ] * N <NEWLINE> seen = [ False ] * N <NEWLINE> <NL> <COMMENT> <NL> def dfs ( gragh , v ) : <COMMENT> <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> seen [ v ] = True <NEWLINE> ind = bisect . bisect_left ( DP , A [ v ] ) <NEWLINE> mae = DP [ ind ] <NEWLINE> DP [ ind ] = A [ v ] <NEWLINE> stack . append ( [ ind , mae ] ) <NEWLINE> <NL> ans [ v ] = bisect . bisect_left ( DP , inf ) <NEWLINE> <NL> for next_v in gragh [ v ] : <NEWLINE> <INDENT> if seen [ next_v ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> dfs ( gragh , next_v ) <NEWLINE> <NL> <DEDENT> ind , mae = stack . pop ( ) <NEWLINE> DP [ ind ] = mae <NEWLINE> <NL> return <NEWLINE> <NL> <NL> <NL> <DEDENT> dfs ( on , 0 ) <NEWLINE> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <DEDENT>
import itertools <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> p = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in itertools . permutations ( [ i + 1 for i in range ( n ) ] , n ) : <NEWLINE> <INDENT> if i == p : <NEWLINE> <INDENT> a = count <NEWLINE> <DEDENT> if i == q : <NEWLINE> <INDENT> b = count <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> print ( abs ( a - b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> a = a . replace ( <STRING> , <STRING> ) <NEWLINE> print ( a ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> s = stdin . readline ( ) . rstrip ( ) <NEWLINE> t = stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> if ( s == t [ : - 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> over_value = 10 ** 18 <NEWLINE> total = 1 <NEWLINE> cnt = 0 <NEWLINE> while cnt < N : <NEWLINE> <INDENT> total *= A [ cnt ] <NEWLINE> if total > over_value : <NEWLINE> <INDENT> total = - 1 <NEWLINE> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> total = 0 <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> v1 , v2 = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> A . append ( v1 ) <NEWLINE> B . append ( v2 ) <NEWLINE> <NL> <DEDENT> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> <NL> if n % 2 : <NEWLINE> <INDENT> print ( B [ n // 2 ] - A [ n // 2 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( B [ n // 2 ] + B [ n // 2 - 1 ] ) - ( A [ n // 2 ] + A [ n // 2 - 1 ] ) + 1 ) <NEWLINE> <DEDENT>
H , W , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> for _ in range ( B ) : <NEWLINE> <INDENT> print ( <STRING> * A + <STRING> * ( W - A ) ) <NEWLINE> <DEDENT> for _ in range ( H - B ) : <NEWLINE> <INDENT> print ( <STRING> * A + <STRING> * ( W - A ) ) <NEWLINE> <DEDENT>
from typing import List <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> graph : List [ List [ int ] ] = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <DEDENT> prev = [ - 1 ] * N <NEWLINE> prev [ 0 ] = 0 <NEWLINE> import queue <NEWLINE> qu = queue . Queue ( ) <NEWLINE> qu . put ( 0 ) <NEWLINE> while not qu . empty ( ) : <NEWLINE> <INDENT> top = qu . get ( ) <NEWLINE> for nxt in graph [ top ] : <NEWLINE> <INDENT> if prev [ nxt ] == - 1 : <NEWLINE> <INDENT> prev [ nxt ] = top <NEWLINE> qu . put ( nxt ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if all ( x != - 1 for x in prev [ 1 : ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( lambda x : str ( x + 1 ) , prev [ 1 : ] ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_sum = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> a_sum *= a [ i ] <NEWLINE> if a_sum > 10 ** 18 : <NEWLINE> <INDENT> a_sum = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a_sum ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> from bisect import bisect_left , bisect_right , insort_left <NEWLINE> dict = { } <NEWLINE> keytbl = [ ] <NEWLINE> cnt = 0 <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a = list ( input ( ) . split ( ) ) <NEWLINE> ki = int ( a [ 1 ] ) <NEWLINE> if a [ 0 ] == <STRING> : <NEWLINE> <INDENT> if ki not in dict : <NEWLINE> <INDENT> dict [ ki ] = 1 <NEWLINE> insort_left ( keytbl , ki ) <NEWLINE> <DEDENT> else : dict [ ki ] += 1 <NEWLINE> cnt += 1 <NEWLINE> print ( cnt ) <NEWLINE> <DEDENT> elif a [ 0 ] == <STRING> : print ( dict [ ki ] if ki in dict else 0 ) <NEWLINE> elif a [ 0 ] == <STRING> : <NEWLINE> <INDENT> if ki in dict : <NEWLINE> <INDENT> cnt -= dict [ ki ] <NEWLINE> dict [ ki ] = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> L = bisect_left ( keytbl , int ( a [ 1 ] ) ) <NEWLINE> R = bisect_right ( keytbl , int ( a [ 2 ] ) , L ) <NEWLINE> r = [ ] <NEWLINE> for j in range ( L , R ) : r += [ keytbl [ j ] ] * dict [ keytbl [ j ] ] <NEWLINE> if r != [ ] : print ( * r , sep = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> stack = [ ] <NEWLINE> for s in S : <NEWLINE> <INDENT> if not stack : <NEWLINE> <INDENT> stack . append ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s == stack [ - 1 ] : <NEWLINE> <INDENT> stack . append ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . pop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( S ) - len ( stack ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> log_ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Max = max ( log_ls ) <NEWLINE> <NL> def less_k ( min_length , log_ls = log_ls , K = K ) : <NEWLINE> <INDENT> times = 0 <NEWLINE> for log in log_ls : <NEWLINE> <INDENT> if log % min_length == 0 : <NEWLINE> <INDENT> times += log // min_length - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> times += log // min_length <NEWLINE> <DEDENT> <DEDENT> if times <= K : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> def return_min_length ( ) : <NEWLINE> <INDENT> r = Max <NEWLINE> l = - 1 <NEWLINE> while True : <NEWLINE> <INDENT> next_length = ( r + l ) // 2 <NEWLINE> if next_length == 0 or not less_k ( next_length ) : <NEWLINE> <INDENT> l = next_length <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = next_length <NEWLINE> <DEDENT> if r - l == 1 : <NEWLINE> <INDENT> return r <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = return_min_length ( ) <NEWLINE> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> state = 7 <NEWLINE> state %= k <NEWLINE> cnt = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if state == 0 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> break <NEWLINE> <DEDENT> state = state * 10 + 7 <NEWLINE> state %= k <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> suma = 0 <NEWLINE> <NL> <NL> if k > a : <NEWLINE> <INDENT> if k > a + b : <NEWLINE> <INDENT> if k == a + b + c : <NEWLINE> <INDENT> print ( a - c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = k - ( a + b ) <NEWLINE> print ( a - k ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> ls = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ls [ i ] = int ( input ( ) ) <NEWLINE> <DEDENT> ls . sort ( ) <NEWLINE> <COMMENT> <NL> if n == 2 : <NEWLINE> <INDENT> print ( abs ( ls [ 0 ] - ls [ 1 ] ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if n % 2 == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> smaller = ls [ : n // 2 + 1 ] <NEWLINE> bigger = ls [ n // 2 + 1 : ] <NEWLINE> diff_1 = 2 * sum ( bigger ) - 2 * sum ( smaller ) + smaller [ - 1 ] + smaller [ - 2 ] <NEWLINE> <COMMENT> <NL> smaller = ls [ : n // 2 ] <NEWLINE> bigger = ls [ n // 2 : ] <NEWLINE> diff_2 = - 2 * sum ( smaller ) + 2 * sum ( bigger ) - bigger [ 0 ] - bigger [ 1 ] <NEWLINE> diff = max ( diff_1 , diff_2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> smaller = ls [ : n // 2 ] <NEWLINE> bigger = ls [ n // 2 : ] <NEWLINE> diff = 2 * sum ( bigger ) - min ( bigger ) - 2 * sum ( smaller ) + max ( smaller ) <NEWLINE> <NL> <DEDENT> print ( diff ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> threshold = 10 ** 18 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if threshold < ans : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class BinaryTreeNode ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> def __init__ ( self , left = None , right = None , val = None ) : <NEWLINE> <INDENT> self . left = left <NEWLINE> self . right = right <NEWLINE> self . val = val <NEWLINE> <NL> <DEDENT> <DEDENT> class BinarySearchTree ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def insert ( self , val ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = self . root <NEWLINE> while x != None : <NEWLINE> <INDENT> y = x <NEWLINE> if val < x . val : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> node = BinaryTreeNode ( val = val ) <NEWLINE> <NL> if y == None : <NEWLINE> <INDENT> self . root = node <NEWLINE> <DEDENT> elif node . val < y . val : <NEWLINE> <INDENT> y . left = node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = node <NEWLINE> <NL> <DEDENT> <DEDENT> def preorder ( self ) : <NEWLINE> <INDENT> self . preorder_list = [ ] <NEWLINE> self . preorder_bfs ( self . root ) <NEWLINE> return self . preorder_list <NEWLINE> <NL> <DEDENT> def preorder_bfs ( self , u ) : <NEWLINE> <INDENT> if u == None : return <NEWLINE> self . preorder_list . append ( u . val ) <NEWLINE> self . preorder_bfs ( u . left ) <NEWLINE> self . preorder_bfs ( u . right ) <NEWLINE> <NL> <DEDENT> def inorder ( self ) : <NEWLINE> <INDENT> self . inorder_list = [ ] <NEWLINE> self . inorder_dfs ( self . root ) <NEWLINE> return self . inorder_list <NEWLINE> <NL> <DEDENT> def inorder_dfs ( self , u ) : <NEWLINE> <INDENT> if u == None : return <NEWLINE> self . inorder_dfs ( u . left ) <NEWLINE> self . inorder_list . append ( u . val ) <NEWLINE> self . inorder_dfs ( u . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def print_elements ( arr ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( [ str ( item ) for item in arr ] ) ) <NEWLINE> <NL> <DEDENT> m = int ( input ( ) ) <NEWLINE> bst = BinarySearchTree ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> op = input ( ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print_elements ( bst . inorder ( ) ) <NEWLINE> print_elements ( bst . preorder ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = int ( op [ 7 : ] ) <NEWLINE> bst . insert ( num ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> border = N * 2 <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ A [ 0 ] + 1 ] <NEWLINE> <NL> C = [ 0 ] * ( border + 1 ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i , a in enumerate ( A , 1 ) : <NEWLINE> <INDENT> if 0 <= i - a <= border : <NEWLINE> <INDENT> ans += C [ i - a ] <NEWLINE> <DEDENT> if i + a <= border : <NEWLINE> <INDENT> C [ i + a ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> line = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> max = line [ 0 ] <NEWLINE> min = line [ 0 ] <NEWLINE> sum = line [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if max < line [ i ] : <NEWLINE> <INDENT> max = line [ i ] <NEWLINE> <DEDENT> elif min > line [ i ] : <NEWLINE> <INDENT> min = line [ i ] <NEWLINE> <DEDENT> sum += line [ i ] <NEWLINE> <NL> <DEDENT> print ( min , max , sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> n = n % 1000 <NEWLINE> print ( 1000 - n if n != 0 else 0 ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import string <NEWLINE> <NL> def solve ( N : int ) : <NEWLINE> <INDENT> alphabet = string . ascii_lowercase <NEWLINE> digits = [ ] <NEWLINE> nextDigits = [ ] <NEWLINE> last = 0 <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> nd = 26 ** i + last <NEWLINE> last = nd <NEWLINE> if nd <= N : <NEWLINE> <INDENT> digits . append ( nd ) <NEWLINE> nextDigits . append ( 26 ** i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> s = <STRING> <NEWLINE> <COMMENT> <NL> for i in range ( len ( digits ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> isFirstDigit = i == len ( digits ) - 1 <NEWLINE> if isFirstDigit : <NEWLINE> <INDENT> currentBaseNum = digits [ i ] <NEWLINE> index = ( N - currentBaseNum ) // nextDigits [ i ] <NEWLINE> s += alphabet [ index ] <NEWLINE> N = N - currentBaseNum - index * nextDigits [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index = N // nextDigits [ i ] <NEWLINE> s += alphabet [ index ] <NEWLINE> N = N - index * nextDigits [ i ] <NEWLINE> <DEDENT> <DEDENT> return s <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> print ( solve ( N ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> cnt = [ 0 ] * N <NEWLINE> cnt2 = [ ] <NEWLINE> flag = 0 <NEWLINE> <NL> if len ( S ) > 1 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt [ 0 ] += 1 <NEWLINE> <DEDENT> elif S [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt [ 1 ] += 1 <NEWLINE> <DEDENT> elif S [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt [ 2 ] += 1 <NEWLINE> <DEDENT> elif S [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt [ 3 ] += 1 <NEWLINE> <DEDENT> elif S [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt [ 4 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if cnt [ i ] != 0 : <NEWLINE> <INDENT> cnt2 . append ( cnt [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> import math <NEWLINE> import itertools <NEWLINE> ans = 0 <NEWLINE> <NL> for v in itertools . combinations ( cnt2 , 3 ) : <NEWLINE> <INDENT> ans += v [ 0 ] * v [ 1 ] * v [ 2 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> import sys <NEWLINE> import resource <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> f = [ x for x in range ( n ) ] <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> if f [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> root = find ( f [ x ] ) <NEWLINE> f [ x ] = root <NEWLINE> return root <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> if find ( a ) != find ( b ) : <NEWLINE> <INDENT> f [ find ( a ) ] = find ( b ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> find ( i ) <NEWLINE> <NL> <DEDENT> print ( max ( collections . Counter ( f ) . values ( ) ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> n , m = LI ( ) <NEWLINE> s = S ( ) <NEWLINE> t = S ( ) <NEWLINE> <NL> gcd = math . gcd ( n , m ) <NEWLINE> lcm = n * m // gcd <NEWLINE> i_s = n // gcd <NEWLINE> i_t = m // gcd <NEWLINE> for i in range ( gcd ) : <NEWLINE> <INDENT> if s [ i * i_s ] != t [ i * i_t ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( lcm ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> print ( len ( set ( s ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> readline = sys . stdin . readline <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( readline ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , N ) : <NEWLINE> <INDENT> for b in range ( 1 , N ) : <NEWLINE> <INDENT> x = a * b <NEWLINE> if x >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> M = 1000000 <NEWLINE> B = int ( math . sqrt ( M ) + 1 ) // 6 + 1 <NEWLINE> N = M // 6 <NEWLINE> N1 = N + 1 if M % 6 == 5 else N <NEWLINE> N2 = N + 1 if M % 6 >= 1 else N <NEWLINE> l = [ 1 ] * N1 <NEWLINE> m = [ 1 ] * N2 <NEWLINE> i = 5 <NEWLINE> ini = 4 <NEWLINE> for p in range ( B ) : <NEWLINE> <INDENT> if l [ p ] == 1 : <NEWLINE> <INDENT> l [ p + i : : i ] = [ 0 ] * len ( l [ p + i : : i ] ) <NEWLINE> m [ ini - 1 : : i ] = [ 0 ] * len ( m [ ini - 1 : : i ] ) <NEWLINE> <DEDENT> if m [ p ] == 1 : <NEWLINE> <INDENT> m [ p + i + 2 : : i + 2 ] = [ 0 ] * len ( m [ p + i + 2 : : i + 2 ] ) <NEWLINE> l [ ini + 1 : : i + 2 ] = [ 0 ] * len ( l [ ini + 1 : : i + 2 ] ) <NEWLINE> <DEDENT> i += 6 <NEWLINE> ini += 5 <NEWLINE> <NL> <DEDENT> for i in sys . stdin : <NEWLINE> <INDENT> n = int ( i ) <NEWLINE> r = n - 1 if n < 3 else sum ( l [ 0 : ( n + 1 ) // 6 ] ) + sum ( m [ 0 : ( n - 1 ) // 6 ] ) + 2 <NEWLINE> print ( r ) <NEWLINE> <DEDENT>
<COMMENT> <NL> S = list ( map ( int , reversed ( input ( ) ) ) ) <NEWLINE> <COMMENT> <NL> <STRING> <NEWLINE> <COMMENT> <NL> a = [ 0 ] * len ( S ) <NEWLINE> <COMMENT> <NL> sums = [ 0 ] * ( len ( S ) + 1 ) <NEWLINE> <COMMENT> <NL> d = 1 <NEWLINE> <COMMENT> <NL> cnt = [ 0 ] * 2019 <NEWLINE> cnt [ 0 ] = 1 <COMMENT> <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> a [ i ] = ( S [ i ] * d ) % 2019 <NEWLINE> sums [ i + 1 ] = ( sums [ i ] + a [ i ] ) % 2019 <NEWLINE> d = ( d * 10 ) % 2019 <NEWLINE> cnt [ sums [ i + 1 ] ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for i in cnt : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> data = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> data [ i ] = p [ i ] / 2 + float ( 0.5 ) <NEWLINE> <DEDENT> res = sum ( data [ 0 : k ] ) <NEWLINE> ans = sum ( data [ 0 : k ] ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> res -= data [ i ] - data [ i + k ] <NEWLINE> ans = max ( ans , res ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> info = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = input ( ) . split ( ) <NEWLINE> b = int ( b ) <NEWLINE> f = int ( f ) <NEWLINE> r = int ( r ) <NEWLINE> v = int ( v ) <NEWLINE> if info == [ ] : <NEWLINE> <INDENT> info . append ( [ b , f , r , v ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in info : <NEWLINE> <INDENT> if b == x [ 0 ] and f == x [ 1 ] and r == x [ 2 ] : <NEWLINE> <INDENT> x [ 3 ] += v <NEWLINE> isAdded = True <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> isAdded = False <NEWLINE> <DEDENT> <DEDENT> if isAdded == False : <NEWLINE> <INDENT> info . append ( [ b , f , r , v ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for building in range ( 4 ) : <NEWLINE> <INDENT> for floor in range ( 3 ) : <NEWLINE> <INDENT> for room in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> arePeople = False <NEWLINE> for y in info : <NEWLINE> <INDENT> if building + 1 == y [ 0 ] and floor + 1 == y [ 1 ] and room + 1 == y [ 2 ] : <NEWLINE> <INDENT> print ( y [ 3 ] , end = <STRING> ) <NEWLINE> arePeople = True <NEWLINE> <DEDENT> <DEDENT> if arePeople == False : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if building < 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . insert ( 0 , 0 ) <NEWLINE> <NL> v = [ - 1 ] * ( N + 1 ) <NEWLINE> n = 1 <NEWLINE> f = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> v [ n ] = i <NEWLINE> n = A [ n ] <NEWLINE> if v [ n ] != - 1 : <NEWLINE> <INDENT> f = 1 <NEWLINE> s = n <COMMENT> <NEWLINE> t = i <NEWLINE> l = t - v [ s ] + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if t >= K : <NEWLINE> <INDENT> print ( v . index ( K ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = ( K - v [ s ] ) % l <NEWLINE> print ( v . index ( K + v [ s ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> RW_cnt = S . count ( <STRING> ) <NEWLINE> RE_cnt = S . count ( <STRING> ) <NEWLINE> LW_cnt = 0 <NEWLINE> LE_cnt = 0 <NEWLINE> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> RW_cnt -= 1 <NEWLINE> LW_cnt = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> RE_cnt -= 1 <NEWLINE> LE_cnt = 1 <NEWLINE> <DEDENT> ans = RE_cnt <NEWLINE> <COMMENT> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> cnt = LW_cnt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = LW_cnt + RE_cnt <NEWLINE> <DEDENT> if cnt < ans : <NEWLINE> <INDENT> ans = cnt <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> LE_cnt += 1 <NEWLINE> RE_cnt -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> LW_cnt += 1 <NEWLINE> RW_cnt -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = <STRING> <NEWLINE> if a > b : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> <DEDENT> print ( <STRING> % ( c ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> data = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = [ int ( s ) for s in input ( ) . split ( <STRING> ) ] <NEWLINE> data [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> while data : <NEWLINE> <INDENT> building = data . pop ( 0 ) <NEWLINE> for floor in building : <NEWLINE> <INDENT> rooms = <STRING> + <STRING> . join ( [ str ( room ) for room in floor ] ) <NEWLINE> print ( rooms ) <NEWLINE> <DEDENT> if data : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for x in range ( N ) ] <NEWLINE> <NL> import math <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if a [ i ] == 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 2 , int ( math . sqrt ( a [ i ] ) ) + 1 ) : <NEWLINE> <INDENT> if a [ i ] % 2 == 0 : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> break <NEWLINE> <DEDENT> if a [ i ] % j == 0 : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> n , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a . sort ( ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> i = 0 <NEWLINE> j = - 1 <NEWLINE> kk = k <NEWLINE> while kk > 1 : <NEWLINE> <INDENT> if a [ i ] * a [ i + 1 ] > a [ j ] * a [ j - 1 ] : <NEWLINE> <INDENT> ans = ans * a [ i ] * a [ i + 1 ] % mod <NEWLINE> i += 2 <NEWLINE> kk -= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * a [ j ] % mod <NEWLINE> j -= 1 <NEWLINE> kk -= 1 <NEWLINE> <DEDENT> <DEDENT> if kk == 1 : <NEWLINE> <INDENT> ans = ans * a [ j ] % mod <NEWLINE> <NL> <DEDENT> if a [ - 1 ] < 0 and k % 2 == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in a [ n - k : ] : <NEWLINE> <INDENT> ans = ans * i % mod <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> for c in s : <NEWLINE> <INDENT> if ( c . islower ( ) ) : <NEWLINE> <INDENT> print ( c . upper ( ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c . lower ( ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
import sys <NEWLINE> <NL> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> N , K = LI ( ) <NEWLINE> A = LI ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> res = 0 <NEWLINE> print ( res ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> res = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( res > pow ( 10 , 18 ) ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = res * a [ i ] <NEWLINE> <DEDENT> <DEDENT> if ( res > pow ( 10 , 18 ) ) : <NEWLINE> <INDENT> res = - 1 <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( n , b - 1 ) <NEWLINE> <NL> print ( int ( a * x / b ) - a * int ( x / b ) ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> for j in range ( 0 , n ) : <NEWLINE> <INDENT> gcd1 = math . gcd ( i + 1 , j + 1 ) <NEWLINE> <NL> for k in range ( 0 , n ) : <NEWLINE> <INDENT> gcd2 = math . gcd ( gcd1 , k + 1 ) <NEWLINE> a = a + gcd2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> minus_list = [ ] <NEWLINE> plus_list = [ ] <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if ( A [ i ] <= 0 ) : <NEWLINE> <INDENT> minus_list . append ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> plus_list . append ( A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> if N == K : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> ans = ( ans * i ) % mod <NEWLINE> <DEDENT> <DEDENT> elif 0 == len ( plus_list ) and K % 2 == 1 : <NEWLINE> <INDENT> minus_list . sort ( reverse = True ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans = ( ans * minus_list [ i ] ) % mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> minus_list . sort ( reverse = True ) <NEWLINE> plus_list . sort ( ) <NEWLINE> if K % 2 == 1 : <NEWLINE> <INDENT> ans = plus_list . pop ( ) <NEWLINE> <DEDENT> for i in range ( K // 2 ) : <NEWLINE> <INDENT> if ( len ( plus_list ) < 2 ) : <NEWLINE> <INDENT> ans = ( minus_list . pop ( ) * ans ) % mod <NEWLINE> ans = ( minus_list . pop ( ) * ans ) % mod <NEWLINE> <DEDENT> elif ( len ( minus_list ) < 2 ) : <NEWLINE> <INDENT> ans = ( plus_list . pop ( ) * ans ) % mod <NEWLINE> ans = ( plus_list . pop ( ) * ans ) % mod <NEWLINE> <DEDENT> elif ( plus_list [ len ( plus_list ) - 1 ] * plus_list [ len ( plus_list ) - 2 ] > minus_list [ len ( minus_list ) - 1 ] * minus_list [ len ( minus_list ) - 2 ] ) : <NEWLINE> <INDENT> ans = ( plus_list . pop ( ) * ans ) % mod <NEWLINE> ans = ( plus_list . pop ( ) * ans ) % mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( minus_list . pop ( ) * ans ) % mod <NEWLINE> ans = ( minus_list . pop ( ) * ans ) % mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> def f ( A , B , x ) : <NEWLINE> <INDENT> return math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> <NL> <DEDENT> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( N , B - 1 ) <NEWLINE> print ( f ( A , B , x ) ) <NEWLINE>
lvl = [ 1.1 , 0.6 , 0.2 , 0.0 ] <NEWLINE> rst = [ [ 0 ] * 4 for _ in range ( 2 ) ] <NEWLINE> eyes = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> l , r = map ( float , input ( ) . strip ( ) . split ( ) ) <NEWLINE> eyes . append ( [ l , r ] ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for e in eyes : <NEWLINE> <INDENT> for lr in range ( 2 ) : <NEWLINE> <INDENT> for l in range ( len ( lvl ) ) : <NEWLINE> <INDENT> if e [ lr ] >= lvl [ l ] : <NEWLINE> <INDENT> rst [ lr ] [ l ] += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for lv in range ( len ( lvl ) ) : <NEWLINE> <INDENT> print ( <STRING> % ( rst [ 0 ] [ lv ] , rst [ 1 ] [ lv ] ) ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> y = 0 <NEWLINE> if n >= b : <NEWLINE> <INDENT> y = b - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = n <NEWLINE> <DEDENT> print ( int ( a * y / b ) ) <NEWLINE>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if ( a == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> from collections import * <NEWLINE> from itertools import * <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> OVERFLOW = 10 ** 18 <NEWLINE> <NL> seq = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> seq . sort ( ) <NEWLINE> if seq [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> result = 1 <NEWLINE> for n in reversed ( seq ) : <NEWLINE> <INDENT> result *= n <NEWLINE> if result > OVERFLOW : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
<NL> array = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> value = input ( ) . split ( ) <NEWLINE> value = [ int ( x ) for x in value ] <NEWLINE> if value [ 0 ] == 0 and value [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> array . append ( value ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , len ( array ) ) : <NEWLINE> <INDENT> for j in range ( 0 , array [ i ] [ 0 ] ) : <NEWLINE> <INDENT> for k in range ( 0 , array [ i ] [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> minP = P [ 0 ] <NEWLINE> ans = 1 <NEWLINE> for i in P [ 1 : ] : <NEWLINE> <INDENT> if ( i <= minP ) : <NEWLINE> <INDENT> minP = i <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
T = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += T [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x = n // ( a + b ) <NEWLINE> if n - x * ( a + b ) > a : <NEWLINE> <INDENT> Y = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Y = n - x * ( a + b ) <NEWLINE> <DEDENT> print ( a * x + Y ) <NEWLINE>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> while True : <NEWLINE> <INDENT> for b in range ( a + 1 ) : <NEWLINE> <INDENT> if a ** 5 + b ** 5 == x : <NEWLINE> <INDENT> print ( a , - b ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> <NL> <DEDENT> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> S = sum ( A ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> for a in A : <NEWLINE> <INDENT> d [ a ] += 1 <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = d [ b ] <NEWLINE> d [ b ] -= k <NEWLINE> d [ c ] += k <NEWLINE> S += k * ( c - b ) <NEWLINE> print ( S ) <NEWLINE> <NL> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> <NL> def func ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ( rows , columns ) = [ int ( item ) for item in input ( ) . rstrip ( ) . split ( <STRING> ) ] <NEWLINE> data = [ [ int ( item ) for item in input ( ) . rstrip ( ) . split ( <STRING> ) ] for i in range ( rows ) ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> return inputError ( ) <NEWLINE> <NL> <DEDENT> [ item . append ( sum ( item ) ) for item in data ] <NEWLINE> data . append ( [ sum ( [ item [ i ] for item in data ] ) for i in range ( columns + 1 ) ] ) <NEWLINE> <NL> result = <STRING> <NEWLINE> for row in data : <NEWLINE> <INDENT> for item in row : <NEWLINE> <INDENT> result += str ( item ) + <STRING> <NEWLINE> <DEDENT> result = result . rstrip ( ) <NEWLINE> result += <STRING> <NEWLINE> <DEDENT> print ( result . rstrip ( ) ) <NEWLINE> <NL> <DEDENT> def inputError ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> return - 1 <NEWLINE> <NL> <DEDENT> func ( ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> S = list ( input ( ) ) <NEWLINE> L = len ( S ) <NEWLINE> <NL> c = 0 <NEWLINE> t = 0 <NEWLINE> md = [ 0 ] * 2019 <NEWLINE> md [ 0 ] += 1 <NEWLINE> for i in range ( L - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> t += int ( S [ i ] ) * pow ( 10 , c , 2019 ) <NEWLINE> c += 1 <NEWLINE> md [ t % 2019 ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> m = md [ i ] <NEWLINE> <NL> if m == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> ans += m * ( m - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> X = [ i + 1 - A [ i ] for i in range ( N ) ] <NEWLINE> Y = [ i + 1 + A [ i ] for i in range ( N ) ] <NEWLINE> <COMMENT> <NL> dicY = dict ( ) <NEWLINE> for y in Y : <NEWLINE> <INDENT> if not y in dicY : <NEWLINE> <INDENT> dicY [ y ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dicY [ y ] += 1 <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> for x in X : <NEWLINE> <INDENT> if x in dicY : <NEWLINE> <INDENT> count += dicY [ x ] <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> count = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , ( i + n + 1 ) // 2 ) : <NEWLINE> <INDENT> if s [ j ] != s [ i ] and s [ j ] != s [ 2 * j - i ] and s [ i ] != s [ 2 * j - i ] : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> num = 0 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( n ) : <NEWLINE> <INDENT> num *= a [ k ] <NEWLINE> if num > 10 ** 18 : <NEWLINE> <INDENT> num = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> d = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> line = input ( ) . split ( ) <NEWLINE> if len ( line ) == 2 : <NEWLINE> <INDENT> command , ele = line <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> command = line [ 0 ] <NEWLINE> <NL> <DEDENT> if command == <STRING> : <NEWLINE> <INDENT> d . appendleft ( ele ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> if ele in d : <NEWLINE> <INDENT> d . remove ( ele ) <NEWLINE> <DEDENT> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> d . popleft ( ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> d . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( list ( d ) ) ) <NEWLINE>
import numpy as np <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> from collections import Counter <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> Set = set ( ) <NEWLINE> <NL> Amax = A [ len ( A ) - 1 ] <NEWLINE> <NL> counter = Counter ( A ) <NEWLINE> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a in Set : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x = a <NEWLINE> while ( x <= Amax ) : <NEWLINE> <INDENT> Set . add ( x ) <NEWLINE> x += a <NEWLINE> <NL> <DEDENT> if counter [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> <NL> s = <STRING> + input ( ) <NEWLINE> <NL> <NL> while s != <STRING> : <NEWLINE> <INDENT> next_s = s <NEWLINE> <NL> if s [ - 5 : ] == <STRING> : <NEWLINE> <INDENT> next_s = s [ : - 5 ] <NEWLINE> <DEDENT> if s [ - 7 : ] == <STRING> : <NEWLINE> <INDENT> next_s = s [ : - 7 ] <NEWLINE> <DEDENT> if s [ - 5 : ] == <STRING> : <NEWLINE> <INDENT> next_s = s [ : - 5 ] <NEWLINE> <DEDENT> if s [ - 6 : ] == <STRING> : <NEWLINE> <INDENT> next_s = s [ : - 6 ] <NEWLINE> <NL> <DEDENT> if s == next_s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> s = next_s <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> rem = [ 0 ] * m <NEWLINE> chk = [ 0 ] * ( m + 1 ) <NEWLINE> rem [ 0 ] = x <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , m ) : <NEWLINE> <INDENT> rem [ i ] = ( rem [ i - 1 ] ** 2 ) % m <NEWLINE> if chk [ rem [ i - 1 ] ** 2 % m ] > 1 : <NEWLINE> <INDENT> temp1 = ( rem [ i - 1 ] ** 2 ) % m <NEWLINE> temp2 = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp1 = ( rem [ i - 1 ] ** 2 ) % m <NEWLINE> temp2 = i <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if rem [ i ] == temp1 : <NEWLINE> <INDENT> temp3 = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if temp2 != temp3 : <NEWLINE> <INDENT> num = ( n - temp3 ) // ( temp2 - temp3 ) <NEWLINE> S = sum ( rem [ : temp3 ] ) + sum ( rem [ temp3 : temp2 ] ) * num + sum ( rem [ temp3 : n - ( num * ( temp2 - temp3 ) ) ] ) <NEWLINE> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( rem ) ) <NEWLINE> <DEDENT>
import copy <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> sc = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> sc . append ( [ s , str ( c ) ] ) <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> for i in range ( 10 ) : <NEWLINE> <INDENT> flag = True <NEWLINE> tmp = str ( i ) <NEWLINE> tmp = list ( tmp ) <NEWLINE> tmp = [ <STRING> for j in range ( n - len ( tmp ) ) ] + tmp <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if tmp [ sc [ j ] [ 0 ] - 1 ] != sc [ j ] [ 1 ] : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 10 ** ( n - 1 ) , 10 ** n ) : <NEWLINE> <INDENT> flag = True <NEWLINE> tmp = str ( i ) <NEWLINE> tmp = list ( tmp ) <NEWLINE> tmp = [ <STRING> for j in range ( n - len ( tmp ) ) ] + tmp <NEWLINE> <NL> for j in range ( m ) : <NEWLINE> <INDENT> if tmp [ sc [ j ] [ 0 ] - 1 ] != sc [ j ] [ 1 ] : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> l = [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> l [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> answer = sum ( a ) <NEWLINE> <NL> b = collections . Counter ( a ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> num = b [ l [ i ] [ 0 ] ] <NEWLINE> variance = l [ i ] [ 1 ] - l [ i ] [ 0 ] <NEWLINE> answer += variance * num <NEWLINE> print ( answer ) <NEWLINE> b [ l [ i ] [ 0 ] ] = 0 <NEWLINE> b [ l [ i ] [ 1 ] ] += num <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N , L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = [ ] <NEWLINE> for i in range ( L ) : <NEWLINE> <INDENT> while arr and alist [ i ] <= alist [ arr [ - 1 ] ] : <NEWLINE> <INDENT> arr . pop ( ) <NEWLINE> <DEDENT> arr . append ( i ) <NEWLINE> <DEDENT> for i in range ( L , N ) : <NEWLINE> <INDENT> print ( alist [ arr [ 0 ] ] , end = <STRING> ) <NEWLINE> while arr and arr [ 0 ] <= i - L : <NEWLINE> <INDENT> arr . pop ( 0 ) <NEWLINE> <DEDENT> while arr and alist [ i ] <= alist [ arr [ - 1 ] ] : <NEWLINE> <INDENT> arr . pop ( ) <NEWLINE> <DEDENT> arr . append ( i ) <NEWLINE> <DEDENT> print ( alist [ arr [ 0 ] ] ) <NEWLINE> <NL>
<COMMENT> <NL> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> l = len ( S ) <NEWLINE> <NL> if S == T : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in range ( l ) : <NEWLINE> <INDENT> if S [ a ] != T [ a ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
S = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> <NL> pops = 0 <NEWLINE> digi = 1 <NEWLINE> cnt = [ 0 ] * 2019 <NEWLINE> cnt [ 0 ] = 1 <NEWLINE> <NL> while S : <NEWLINE> <INDENT> s = S . pop ( ) <NEWLINE> <NL> pops = ( pops + s * digi ) % 2019 <NEWLINE> digi = ( 10 * digi ) % 2019 <NEWLINE> <NL> cnt [ pops ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( 2019 ) : <NEWLINE> <INDENT> ans += cnt [ i ] * ( cnt [ i ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> from heapq import heappop , heappush , heapreplace <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from collections import Counter as cc <NEWLINE> a = cc ( a ) <NEWLINE> q = [ ] <NEWLINE> for key in a : <NEWLINE> <INDENT> heappush ( q , ( key , a [ key ] ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> now = b <NEWLINE> while q : <NEWLINE> <INDENT> num , cnt = q [ 0 ] <NEWLINE> if c <= num : break <NEWLINE> <NL> if now >= cnt : <NEWLINE> <INDENT> now -= cnt <NEWLINE> heappop ( q ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> heapreplace ( q , ( num , cnt - now ) ) <NEWLINE> now = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if now != b : <NEWLINE> <INDENT> heappush ( q , ( c , b - now ) ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for num , cnt in q : <NEWLINE> <INDENT> ans += num * cnt <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
mod = 10 ** 9 + 7 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) % mod for i in input ( ) . split ( ) ] [ : N ] <NEWLINE> <NL> wa = sum ( A ) <NEWLINE> <NL> total = 0 <NEWLINE> for n in range ( N - 1 ) : <NEWLINE> <INDENT> wa -= A [ n ] <NEWLINE> <NL> total += A [ n ] * wa <NEWLINE> total %= mod <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = 10 ** 9 + 7 <NEWLINE> <NL> S = sum ( A ) <NEWLINE> S2 = sum ( map ( lambda x : x ** 2 , A ) ) <NEWLINE> print ( ( ( S ** 2 - S2 ) // 2 ) % M ) <NEWLINE> <NL>
<COMMENT> <NL> import math as mh <NEWLINE> a = int ( input ( ) ) <NEWLINE> A = [ 0 ] * a <NEWLINE> x = 0 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> A [ i ] = int ( input ( ) ) <NEWLINE> for j in range ( 1 , A [ i ] ) : <NEWLINE> <INDENT> if A [ i ] == 2 : <NEWLINE> <INDENT> x += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if j == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif ( A [ i ] % j ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif j >= mh . sqrt ( A [ i ] ) : <NEWLINE> <INDENT> x += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( x ) <NEWLINE> <NL>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , copy , functools , random <NEWLINE> import sys <NEWLINE> from collections import deque , defaultdict , Counter ; from heapq import heappush , heappop <NEWLINE> from itertools import permutations , combinations , product , accumulate , groupby <NEWLINE> from bisect import bisect_left , bisect_right , insort_left , insort_right <NEWLINE> from operator import itemgetter as ig <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 ; INF = float ( <STRING> ) ; ans = 0 ; tmp = 0 ; ansli = [ ] ; tmpli = [ ] ; candili = [ ] <NEWLINE> eps = 1.0 / 10 ** 10 ; mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] ; ddn = dd + [ ( - 1 , 1 ) , ( 1 , 1 ) , ( 1 , - 1 ) , ( - 1 , - 1 ) ] ; ddn9 = ddn + [ ( 0 , 0 ) ] <NEWLINE> <STRING> <NEWLINE> def wi ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def wip ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <COMMENT> <NEWLINE> def ws ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def i ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def hi ( n ) : return [ i ( ) for _ in range ( n ) ] <NEWLINE> def hs ( n ) : return [ s ( ) for _ in range ( n ) ] <COMMENT> <NEWLINE> def mi ( n ) : return [ wi ( ) for _ in range ( n ) ] <COMMENT> <NEWLINE> def mip ( n ) : return [ wip ( ) for _ in range ( n ) ] <NEWLINE> def ms ( n ) : return [ ws ( ) for _ in range ( n ) ] <NEWLINE> <NL> s = s ( ) <NEWLINE> <NL> mod = 2019 <NEWLINE> num_int = 0 <NEWLINE> mod_dict = defaultdict ( int ) <NEWLINE> mod_dict [ num_int % mod ] += 1 <NEWLINE> s = s [ : : - 1 ] <NEWLINE> t = 1 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> num_int += t * int ( s [ i ] ) <NEWLINE> num_int %= mod <NEWLINE> t *= 10 <NEWLINE> t %= mod <NEWLINE> mod_dict [ num_int ] += 1 <NEWLINE> <NL> <DEDENT> for i in mod_dict : <NEWLINE> <INDENT> ans += ( ( mod_dict [ i ] - 1 ) * mod_dict [ i ] ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
pi = 3.14159265358979 <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * pi ) , <STRING> . format ( 2 * r * pi ) ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = 0 <NEWLINE> if N == 0 : <NEWLINE> <INDENT> result = X <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list = [ i for i in range ( 201 ) ] <NEWLINE> for i in P : <NEWLINE> <INDENT> list . remove ( i ) <NEWLINE> <DEDENT> if len ( list ) == 0 : <NEWLINE> <INDENT> result = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min = 100 <NEWLINE> for i in list : <NEWLINE> <INDENT> if min > abs ( X - i ) : <NEWLINE> <INDENT> min = abs ( X - i ) <NEWLINE> result = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
( a , b ) = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> % ( a * b , a * 2 + b * 2 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> b , f , r , v = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> l [ b ] [ f ] [ r ] += v + 1 <NEWLINE> <DEDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> for k in l [ j ] : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , k ) ) ) <NEWLINE> <DEDENT> if j < 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = deque ( ) <NEWLINE> a_num = 0 <NEWLINE> b = deque ( ) <NEWLINE> c = deque ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a_num = int ( input ( ) ) <NEWLINE> a . append ( a_num ) <NEWLINE> k , p = 0 , 0 <NEWLINE> x = [ 0 ] * N <NEWLINE> b_num = deque ( ) <NEWLINE> for i in range ( a_num ) : <NEWLINE> <INDENT> k , p = map ( int , input ( ) . split ( ) ) <NEWLINE> b_num . append ( k - 1 ) <NEWLINE> x [ k - 1 ] = p <NEWLINE> <DEDENT> b . append ( b_num ) <NEWLINE> c . append ( x ) <NEWLINE> <DEDENT> max_num = 0 <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> two = format ( i , <STRING> ) <NEWLINE> two = two [ : : - 1 ] <NEWLINE> flag = True <NEWLINE> for i , k in enumerate ( two ) : <NEWLINE> <INDENT> if flag == False : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i < N : <NEWLINE> <INDENT> if k == <STRING> : <NEWLINE> <INDENT> for l in range ( a [ i ] ) : <NEWLINE> <INDENT> for j in b [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> if c [ i ] [ j ] != int ( two [ j ] ) : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == False : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == False : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <COMMENT> <NL> <INDENT> max_num = max ( max_num , two . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> print ( max_num ) <NEWLINE>
from itertools import combinations_with_replacement <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for v in combinations_with_replacement ( range ( 1 , M + 1 ) , N ) : <NEWLINE> <INDENT> A = list ( v ) <NEWLINE> temp = 0 <NEWLINE> for a , b , c , d in abcd : <NEWLINE> <INDENT> if A [ b - 1 ] - A [ a - 1 ] == c : <NEWLINE> <INDENT> temp += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , temp ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> <NL> def get_loop ( a , m ) : <NEWLINE> <INDENT> count = 1 <NEWLINE> acc = a <NEWLINE> while acc != 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> acc *= a <NEWLINE> acc %= m <NEWLINE> <DEDENT> return count <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> a1 , m1 , a2 , m2 , a3 , m3 = map ( int , input ( ) . split ( ) ) <NEWLINE> if not a1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> loop_a = get_loop ( a1 , m1 ) <NEWLINE> loop_b = get_loop ( a2 , m2 ) <NEWLINE> loop_c = get_loop ( a3 , m3 ) <NEWLINE> loop_ab = loop_a * loop_b // gcd ( loop_a , loop_b ) <NEWLINE> loop_abc = loop_ab * loop_c // gcd ( loop_ab , loop_c ) <NEWLINE> print ( loop_abc ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> X = abs ( X ) <NEWLINE> now = X <NEWLINE> over_zero_step = 0 <NEWLINE> over_zero = 0 <NEWLINE> not_over_zero = now <NEWLINE> flg = 0 <NEWLINE> <NL> if X < abs ( K * D ) : <NEWLINE> <INDENT> q = X // D <NEWLINE> now = X - q * D <NEWLINE> now = abs ( now ) <NEWLINE> <COMMENT> <NL> for i in range ( q + 1 , K + 1 ) : <NEWLINE> <INDENT> nxt = now - D <NEWLINE> if nxt < 0 : <NEWLINE> <INDENT> over_zero = nxt <NEWLINE> not_over_zero = now <NEWLINE> over_zero_step = i <NEWLINE> break <NEWLINE> <DEDENT> now = nxt <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> remaining_step = 0 <NEWLINE> nearest_point = X - K * D <NEWLINE> flg = 1 <NEWLINE> <NL> <DEDENT> if flg == 0 : <NEWLINE> <NL> <INDENT> if abs ( over_zero ) <= not_over_zero : <NEWLINE> <INDENT> nearest_point = over_zero <NEWLINE> nearest_point_step = over_zero_step <NEWLINE> next_nearest_point = not_over_zero <NEWLINE> remaining_step = K - nearest_point_step <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nearest_point = not_over_zero <NEWLINE> nearest_point_step = over_zero_step - 1 <NEWLINE> next_nearest_point = over_zero <NEWLINE> remaining_step = K - nearest_point_step <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if remaining_step % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( nearest_point ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( next_nearest_point ) ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> <NL> import math <NEWLINE> d = 0 <NEWLINE> e = 0 <NEWLINE> f = 0 <NEWLINE> s = 0 <NEWLINE> ss = 0 <NEWLINE> sss = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> e += 1 <NEWLINE> d = math . gcd ( a , b ) <NEWLINE> <NL> for c in range ( e , k + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if f == 0 : <NEWLINE> <INDENT> ss += math . gcd ( d , c ) <NEWLINE> <COMMENT> <NL> f += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += math . gcd ( d , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> d = 0 <NEWLINE> s *= 2 <NEWLINE> s += ss <NEWLINE> sss += s <NEWLINE> s = 0 <NEWLINE> ss = 0 <NEWLINE> f = 0 <NEWLINE> <DEDENT> e = 0 <NEWLINE> <DEDENT> print ( sss ) <NEWLINE>
<COMMENT> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> now = 0 <NEWLINE> rireki = [ 0 ] * N <NEWLINE> isou = 1 <NEWLINE> hazimete = 0 <NEWLINE> for i in range ( 4 * N ) : <NEWLINE> <INDENT> if rireki [ now ] == 0 : <NEWLINE> <INDENT> rireki [ now ] = 1 <NEWLINE> startnum = i <NEWLINE> start = now <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if hazimete == 1 : <NEWLINE> <INDENT> startnum = i <NEWLINE> start = now <NEWLINE> <DEDENT> hazimte = 1 <NEWLINE> if rireki [ now ] == 1 : <NEWLINE> <INDENT> rireki [ now ] = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if rireki [ now ] == 2 : <NEWLINE> <INDENT> rireki [ now ] = 3 <NEWLINE> isou = i - startnum - 1 <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> now = A [ now ] - 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> amari = ( K - startnum - 1 ) % isou <NEWLINE> <NL> for i in range ( amari ) : <NEWLINE> <INDENT> now = A [ now ] - 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if K > startnum : <NEWLINE> <INDENT> print ( <STRING> . format ( now + 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> now = A [ now ] - 1 <NEWLINE> <DEDENT> print ( <STRING> . format ( now + 1 ) ) <NEWLINE> <DEDENT>
N , M , K = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> B = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> A_deep = 0 <NEWLINE> B_deep = 0 <NEWLINE> time = 0 <NEWLINE> while A_deep < N : <NEWLINE> <INDENT> if K >= time + A [ A_deep ] : <NEWLINE> <INDENT> time += A [ A_deep ] <NEWLINE> A_deep += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> while B_deep < M : <NEWLINE> <INDENT> if K >= time + B [ B_deep ] : <NEWLINE> <INDENT> time += B [ B_deep ] <NEWLINE> B_deep += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> i = A_deep - 1 <NEWLINE> j = B_deep <NEWLINE> ans = i + j + 1 <NEWLINE> while i >= 0 and j < M : <NEWLINE> <INDENT> while i >= 0 : <NEWLINE> <INDENT> time -= A [ i ] <NEWLINE> i -= 1 <NEWLINE> if K - time >= B [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> while j < M : <NEWLINE> <INDENT> if K >= time + B [ j ] : <NEWLINE> <INDENT> time += B [ j ] <NEWLINE> j += 1 <NEWLINE> ans = max ( ans , i + j + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> for j in range ( N - K ) : <NEWLINE> <INDENT> if A [ j + K ] > A [ j ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> ans = 1 <NEWLINE> num = 1000000000000000000 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > num : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> paisen = [ 0 ] * n <NEWLINE> person = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> paisen [ person [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> print ( paisen [ j ] ) <NEWLINE> <DEDENT>
n , a = int ( input ( ) ) , sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> m , s = a [ - 1 ] , [ 0 ] * ( a [ - 1 ] + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> s [ i ] += 1 <NEWLINE> <DEDENT> for i in set ( a ) : <NEWLINE> <INDENT> if s [ i ] : <NEWLINE> <INDENT> for j in range ( i * 2 , m + 1 , i ) : s [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( s . count ( 1 ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( 6 * 10 ** 4 + 10 ) <NEWLINE> <NL> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> ans [ x ** 2 + y ** 2 + z ** 2 + x * y + y * z + x * z - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> modList = [ 0 ] * 2019 <COMMENT> <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> modList [ 0 ] = 1 <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> T = 0 <NEWLINE> a = 1 <NEWLINE> for s in S [ : : - 1 ] : <NEWLINE> <INDENT> T = T + int ( s ) * a <NEWLINE> modList [ T % 2019 ] += 1 <NEWLINE> a *= 10 <NEWLINE> a %= 2019 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for j in modList : <NEWLINE> <INDENT> if j <= 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += j * ( j - 1 ) / 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> maze = [ ] <NEWLINE> <NL> for _ in range ( h ) : <NEWLINE> <INDENT> maze . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> move = [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ] <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if ( maze [ i ] [ j ] == <STRING> ) : <NEWLINE> <INDENT> dist = [ [ 99999999 ] * w for _ in range ( h ) ] <NEWLINE> <NL> dq = deque ( ) <NEWLINE> y = i <NEWLINE> x = j <NEWLINE> d = 0 <NEWLINE> dist [ y ] [ x ] = 0 <NEWLINE> dq . append ( ( y , x , d ) ) <NEWLINE> <NL> while ( len ( dq ) ) : <NEWLINE> <NL> <INDENT> y , x , d = dq . popleft ( ) <NEWLINE> <NL> for m in move : <NEWLINE> <INDENT> if ( ( 0 <= x + m [ 0 ] < w ) and ( 0 <= y + m [ 1 ] < h ) and <NEWLINE> <INDENT> ( dist [ y + m [ 1 ] ] [ x + m [ 0 ] ] > d + 1 ) and <NEWLINE> <INDENT> ( maze [ y + m [ 1 ] ] [ x + m [ 0 ] ] == <STRING> ) ) : <NEWLINE> <INDENT> dist [ y + m [ 1 ] ] [ x + m [ 0 ] ] = d + 1 <NEWLINE> dq . append ( ( y + m [ 1 ] , x + m [ 0 ] , d + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = max ( ans , d ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> N , = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> su = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> S += [ a ] <NEWLINE> <DEDENT> print ( len ( set ( S ) ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = 10 ** 9 <NEWLINE> PI = 3.14159265358979323846 <NEWLINE> <NL> def read_str ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def read_int ( ) : return int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> def read_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_ints2 ( x ) : return map ( lambda num : int ( num ) - x , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_str_list ( ) : return list ( sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_int_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> def GCD ( a : int , b : int ) -> int : return b if a % b == 0 else GCD ( b , a % b ) <NEWLINE> def LCM ( a : int , b : int ) -> int : return ( a * b ) // GCD ( a , b ) <NEWLINE> <NL> <COMMENT> <NL> class PrimeFactorization ( ) : <NEWLINE> <INDENT> def __init__ ( self , num ) : <NEWLINE> <INDENT> self . num = num <NEWLINE> self . factor_table = [ 0 ] * ( num + 1 ) <NEWLINE> self . eratosthenes ( ) <NEWLINE> <NL> <DEDENT> def eratosthenes ( self ) : <NEWLINE> <INDENT> for i in range ( 2 , self . num + 1 ) : <NEWLINE> <INDENT> if self . factor_table [ i ] == 0 : <NEWLINE> <INDENT> self . factor_table [ i ] = i <NEWLINE> for j in range ( i * i , self . num + 1 , i ) : <NEWLINE> <INDENT> if self . factor_table [ j ] == 0 : <NEWLINE> <INDENT> self . factor_table [ j ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def factorization ( self , a ) : <NEWLINE> <INDENT> now = a <NEWLINE> ret = [ ] <NEWLINE> while now > 1 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> prime = self . factor_table [ now ] <NEWLINE> while now % prime == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> now //= prime <NEWLINE> <DEDENT> ret . append ( ( prime , cnt ) ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> <DEDENT> def Main ( ) : <NEWLINE> <INDENT> n = read_int ( ) <NEWLINE> a = read_int_list ( ) <NEWLINE> max_num = max ( a ) <NEWLINE> <NL> pf = PrimeFactorization ( max_num + 1 ) <NEWLINE> used_prime = [ False ] * ( max_num + 1 ) <NEWLINE> for x in a : <NEWLINE> <INDENT> factor = pf . factorization ( x ) <NEWLINE> for prime , cnt in factor : <NEWLINE> <INDENT> if used_prime [ prime ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> used_prime [ prime ] = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> gcd_num = a [ 0 ] <NEWLINE> for x in a [ 1 : ] : <NEWLINE> <INDENT> gcd_num = math . gcd ( gcd_num , x ) <NEWLINE> <DEDENT> print ( <STRING> if gcd_num == 1 else <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> Sn = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> Sn . append ( s ) <NEWLINE> <DEDENT> print ( len ( set ( Sn ) ) ) <NEWLINE> <NL>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> if ( A [ - 1 ] == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = 1 <NEWLINE> for An in A : <NEWLINE> <INDENT> p *= An <NEWLINE> if ( p > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE> <DEDENT>
data = [ <NEWLINE> <INDENT> <STRING> . format ( s , r ) <NEWLINE> for s in ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> for r in range ( 1 , 13 + 1 ) <NEWLINE> ] <NEWLINE> <NL> <DEDENT> count = int ( input ( ) ) <NEWLINE> for c in range ( count ) : <NEWLINE> <INDENT> card = input ( ) <NEWLINE> data . remove ( card ) <NEWLINE> <NL> <DEDENT> for c in data : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> count = 0 <NEWLINE> <NL> if X - K * D >= 0 : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = int ( X / D ) <NEWLINE> kaisuu = K - s <NEWLINE> if kaisuu % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( X - s * D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( X - ( s + 1 ) * D ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> while i % 2 == 0 : <NEWLINE> <INDENT> i //= 2 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> A . reverse ( ) <NEWLINE> conf = [ A [ 0 ] ] <NEWLINE> ans = 0 <NEWLINE> con = deque ( conf ) <NEWLINE> A . pop ( 0 ) <NEWLINE> <NL> <NL> for elem in A : <NEWLINE> <INDENT> ans += con . popleft ( ) <NEWLINE> <NL> for _ in range ( 2 ) : <NEWLINE> <INDENT> con . append ( elem ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> NIL = - 1 <NEWLINE> <NL> def set_depth ( v , depth ) : <NEWLINE> <INDENT> tree [ v ] [ 2 ] = depth <NEWLINE> <NL> for child in tree [ v ] [ 1 ] : <NEWLINE> <INDENT> set_depth ( child , depth + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> tree = [ [ NIL , [ ] , 0 , <STRING> ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> line = [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> t_id = line [ 0 ] <NEWLINE> children = line [ 2 : ] <NEWLINE> tree [ t_id ] [ 1 ] = children <NEWLINE> <NL> if children : <NEWLINE> <INDENT> tree [ t_id ] [ 3 ] = <STRING> <NEWLINE> <NL> <DEDENT> for child in children : <NEWLINE> <INDENT> tree [ child ] [ 0 ] = t_id <NEWLINE> <NL> <DEDENT> <DEDENT> for t_id in range ( N ) : <NEWLINE> <INDENT> if tree [ t_id ] [ 0 ] == NIL : <NEWLINE> <INDENT> tree [ t_id ] [ 3 ] = <STRING> <NEWLINE> r = t_id <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> set_depth ( r , 0 ) <NEWLINE> <NL> for t_id in range ( N ) : <NEWLINE> <INDENT> parent = tree [ t_id ] [ 0 ] <NEWLINE> depth = tree [ t_id ] [ 2 ] <NEWLINE> children = tree [ t_id ] [ 1 ] <NEWLINE> type_t = tree [ t_id ] [ 3 ] <NEWLINE> <NL> print ( <STRING> . format ( t_id , parent , depth , type_t , children ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> t = S [ K - 1 ] <NEWLINE> ans = <STRING> <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == t : <NEWLINE> <INDENT> ans += s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> alist = set ( ) <NEWLINE> adic = { } <NEWLINE> su = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> su += int ( i ) <NEWLINE> if int ( i ) in alist : <NEWLINE> <INDENT> adic [ int ( i ) ] = adic [ int ( i ) ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> alist . add ( int ( i ) ) <NEWLINE> adic [ int ( i ) ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> s = input ( ) . split ( ) <NEWLINE> b = int ( s [ 0 ] ) <NEWLINE> c = int ( s [ 1 ] ) <NEWLINE> if b in alist : <NEWLINE> <INDENT> if not ( c in alist ) : <NEWLINE> <INDENT> adic [ c ] = 0 <NEWLINE> alist . add ( c ) <NEWLINE> <DEDENT> adic [ c ] = adic [ c ] + adic [ b ] <NEWLINE> su = su + ( c * adic [ b ] ) - ( b * adic [ b ] ) <NEWLINE> adic [ b ] = 0 <NEWLINE> <NL> <DEDENT> ans . append ( su ) <NEWLINE> <DEDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
r = float ( input ( ) ) <NEWLINE> pi = 3.141592653589 <NEWLINE> print ( <STRING> . format ( r ** 2 * pi , r * 2 * pi ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> A . insert ( 0 , 0 ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans += A [ N - int ( i / 2 ) ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = sorted ( p ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += s [ i ] <NEWLINE> if i == K - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x = input ( ) . split ( ) <NEWLINE> A = [ ] <NEWLINE> for i in x : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> A . append ( int ( i ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> b = A . pop ( ) <NEWLINE> a = A . pop ( ) <NEWLINE> if i == <STRING> : <NEWLINE> <INDENT> A . append ( a + b ) <NEWLINE> <DEDENT> if i == <STRING> : <NEWLINE> <INDENT> A . append ( a - b ) <NEWLINE> <DEDENT> if i == <STRING> : <NEWLINE> <INDENT> A . append ( a * b ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( A . pop ( ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> x = 0 <NEWLINE> y = [ ] <NEWLINE> while x < a : <NEWLINE> <INDENT> x += 1 <NEWLINE> if <STRING> in str ( x ) or x % 3 == 0 : <NEWLINE> <INDENT> y . append ( str ( x ) ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + <STRING> . join ( y ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> ans = ( x // 11 ) * 2 <NEWLINE> remainder = x % 11 <NEWLINE> if remainder == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> elif 1 <= remainder <= 6 : <NEWLINE> <INDENT> print ( ans + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans + 2 ) <NEWLINE> <DEDENT>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = len ( S ) <NEWLINE> <NL> ans = 1 <NEWLINE> num = 0 <NEWLINE> <NL> for i in range ( l ) : <NEWLINE> <INDENT> num += S [ i ] <NEWLINE> if num <= X : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tallest = A [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for height in A : <NEWLINE> <INDENT> if tallest > height : <NEWLINE> <INDENT> cnt += tallest - height <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tallest = height <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> s = s . split ( <STRING> ) <NEWLINE> print ( max ( [ len ( i ) for i in s ] ) ) <NEWLINE>
import math <NEWLINE> <NL> a , b , n = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> if b > n : <NEWLINE> <INDENT> print ( math . floor ( a * n / b ) - a * math . floor ( n / b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . floor ( a * ( b - 1 ) / b ) - a * math . floor ( ( b - 1 ) / b ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> dic = dict ( ) <NEWLINE> list_sum = sum ( l ) <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> if ( l [ i ] not in dic . keys ( ) ) : <NEWLINE> <INDENT> dic [ l [ i ] ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ l [ i ] ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> s = list_sum <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if ( b in dic and dic [ b ] != 0 ) : <NEWLINE> <INDENT> s += ( c - b ) * dic [ b ] <NEWLINE> if ( c in dic ) : <NEWLINE> <INDENT> dic [ c ] += dic [ b ] <NEWLINE> dic [ b ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ c ] = dic [ b ] <NEWLINE> dic [ b ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <NL> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> <NL> def is_ok ( A , B , X ) : <NEWLINE> <INDENT> return A ** 5 - B ** 5 == X <NEWLINE> <NL> <NL> <DEDENT> def spiral ( ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> p = [ 0 , 0 ] <NEWLINE> yield p <NEWLINE> while True : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> p [ 0 ] += 1 <NEWLINE> yield p <NEWLINE> <DEDENT> for j in range ( i ) : <NEWLINE> <INDENT> p [ 1 ] -= 1 <NEWLINE> yield p <NEWLINE> <DEDENT> i += 1 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> p [ 0 ] -= 1 <NEWLINE> yield p <NEWLINE> <DEDENT> for j in range ( i ) : <NEWLINE> <INDENT> p [ 1 ] += 1 <NEWLINE> yield p <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for a , b in spiral ( ) : <NEWLINE> <INDENT> if is_ok ( a , b , X ) : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> S = [ <STRING> ] * n <NEWLINE> T = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> S [ i ] = input ( ) <NEWLINE> <DEDENT> S . sort ( ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( S [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> cnt = 1 <NEWLINE> mxcnt = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if S [ i ] == S [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> <DEDENT> mxcnt = max ( mxcnt , cnt ) <NEWLINE> <DEDENT> cnt = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if S [ i ] == S [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> <DEDENT> if cnt == mxcnt : <NEWLINE> <INDENT> T . append ( S [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if mxcnt == 1 : <NEWLINE> <INDENT> T . append ( S [ - 1 ] ) <NEWLINE> <DEDENT> for t in T : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b , c = map ( str , input ( ) . split ( ) ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = int ( a ) <NEWLINE> c = int ( c ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> print ( a + c ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( int ( a / c ) ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( a - c ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> nums = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> import numpy as np <NEWLINE> <NL> ans = np . zeros ( max ( nums ) + 1 ) <NEWLINE> <NL> for i in nums : <NEWLINE> <INDENT> if ans [ i ] > 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i : : i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in nums : <NEWLINE> <INDENT> if ans [ i ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , M = [ int ( c ) for c in input ( ) . split ( ) ] <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for c in range ( N ) ] <NEWLINE> cd = [ list ( map ( int , input ( ) . split ( ) ) ) for c in range ( M ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> mi = 2 * 10 ** 9 <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> tmp = abs ( ab [ i ] [ 0 ] - cd [ j ] [ 0 ] ) + abs ( ab [ i ] [ 1 ] - cd [ j ] [ 1 ] ) <NEWLINE> if mi > tmp : <NEWLINE> <INDENT> mi = tmp <NEWLINE> ans = j + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> AjtoN = sum ( A ) <NEWLINE> Asum = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> AjtoN -= A [ i ] <NEWLINE> Asum += A [ i ] * AjtoN <NEWLINE> Asum = Asum % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( Asum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> from collections import Counter <NEWLINE> c = Counter ( l ) <NEWLINE> <NL> total = 0 <NEWLINE> for i in c . values ( ) : <NEWLINE> <INDENT> if i != 1 : <NEWLINE> <INDENT> total += i * ( i - 1 ) // 2 <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( n ) : <COMMENT> <NEWLINE> <INDENT> tmp = c [ l [ j ] ] <NEWLINE> before = tmp * ( tmp - 1 ) // 2 <NEWLINE> after = ( tmp - 1 ) * ( tmp - 2 ) // 2 <NEWLINE> print ( total - before + after ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> from heapq import heappop , heappush <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> from collections import deque <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> C = list ( sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) ) <NEWLINE> <NL> MAX = 2 * 10 ** 5 + 5 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> fac = [ 0 for i in range ( MAX ) ] <NEWLINE> finv = [ 0 for i in range ( MAX ) ] <NEWLINE> inv = [ 0 for i in range ( MAX ) ] <NEWLINE> <NL> def comInit ( mod ) : <NEWLINE> <INDENT> fac [ 0 ] , fac [ 1 ] = 1 , 1 <NEWLINE> finv [ 0 ] , finv [ 1 ] = 1 , 1 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> for i in range ( 2 , MAX ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i % mod <NEWLINE> inv [ i ] = mod - inv [ mod % i ] * ( mod // i ) % mod <NEWLINE> finv [ i ] = finv [ i - 1 ] * inv [ i ] % mod <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def com ( n , r , mod ) : <NEWLINE> <INDENT> if n < r : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if n < 0 or r < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return fac [ n ] * ( finv [ r ] * finv [ n - r ] % mod ) % mod <NEWLINE> <NL> <DEDENT> def p ( n , r , mod ) : <NEWLINE> <INDENT> return fac [ n ] * finv [ n - r ] % mod <NEWLINE> <NL> <DEDENT> comInit ( MOD ) <NEWLINE> <NL> ans = 0 <NEWLINE> pow_list = [ 1 ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> pow_list [ i ] = ( 2 * pow_list [ i - 1 ] ) % MOD <NEWLINE> <DEDENT> base = pow_list [ N ] <NEWLINE> for i , c in enumerate ( C ) : <NEWLINE> <INDENT> now = pow_list [ N - i - 1 ] <NEWLINE> tot = 0 <NEWLINE> if i >= 1 : <NEWLINE> <INDENT> tot = pow_list [ i ] + i * pow_list [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tot = pow_list [ i ] <NEWLINE> <DEDENT> ans += ( tot * now * c ) % MOD <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans * base % MOD ) <NEWLINE> <NL> <NL> <NL>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> PS = [ line . split ( ) for line in readlines ( ) ] <NEWLINE> <NL> AC = [ False ] * ( N + 1 ) <NEWLINE> WA_cnt = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> penal = 0 <NEWLINE> for p , s in PS : <NEWLINE> <INDENT> p = int ( p ) <NEWLINE> if AC [ p ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> WA_cnt [ p ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> AC [ p ] = True <NEWLINE> penal += WA_cnt [ p ] <NEWLINE> <NL> <DEDENT> <DEDENT> ac = sum ( AC ) <NEWLINE> print ( ac , penal ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> d = { } <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> if S in d : <NEWLINE> <INDENT> d [ S ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ S ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> m = max ( d . values ( ) ) <NEWLINE> <NL> for s in sorted ( k for k in d if d [ k ] == m ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ary = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> ary_2 = [ ary [ 0 ] ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ary_2 . append ( ary [ i ] + ary_2 [ i - 1 ] ) <NEWLINE> <DEDENT> ary_2 = [ 0 ] + ary_2 <NEWLINE> <COMMENT> <NL> <NL> from collections import Counter <NEWLINE> c = Counter ( ary_2 ) <NEWLINE> v = ( c . values ( ) ) <NEWLINE> <COMMENT> <NL> <NL> from math import factorial <NEWLINE> def combinations_count ( n , r ) : <NEWLINE> <INDENT> return factorial ( n ) // ( factorial ( n - r ) * factorial ( r ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for j in v : <NEWLINE> <INDENT> if j > 1 : <NEWLINE> <INDENT> ans += combinations_count ( j , 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> pay = 0 <NEWLINE> while pay < n : <NEWLINE> <INDENT> pay += 1000 <NEWLINE> <NL> <DEDENT> print ( pay - n ) <NEWLINE>
import itertools <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = itertools . combinations_with_replacement ( range ( 1 , m + 1 ) , n ) <NEWLINE> quads = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( q ) ] <NEWLINE> max_p = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> p = 0 <NEWLINE> for quad in quads : <NEWLINE> <INDENT> if a [ quad [ 1 ] - 1 ] - a [ quad [ 0 ] - 1 ] == quad [ 2 ] : <NEWLINE> <INDENT> p += quad [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if max_p < p : <NEWLINE> <INDENT> max_p = p <NEWLINE> <DEDENT> <DEDENT> print ( max_p ) <NEWLINE>
import sys ; sys . setrecursionlimit ( 2147483647 ) ; input = sys . stdin . readline <NEWLINE> from math import floor , ceil , sqrt , factorial , log <NEWLINE> from collections import Counter , defaultdict , deque <NEWLINE> from operator import itemgetter <NEWLINE> INF = float ( <STRING> ) ; MOD = 10 ** 9 + 7 <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( MI ( ) ) <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def IS ( ) : return input ( ) . rstrip ( ) <NEWLINE> def gcd_core ( a , b ) : <NEWLINE> <INDENT> if b == 0 : return a <NEWLINE> else : return gcd_core ( b , a % b ) <NEWLINE> <DEDENT> def gcd ( arr ) : <NEWLINE> <INDENT> g = gcd_core ( arr [ 0 ] , arr [ 1 ] ) <NEWLINE> for i in range ( 2 , len ( arr ) ) : g = gcd_core ( g , arr [ i ] ) <NEWLINE> return g <NEWLINE> <DEDENT> def main ( ) : <NEWLINE> <INDENT> K = I ( ) <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( a , K + 1 ) : <NEWLINE> <INDENT> for c in range ( b , K + 1 ) : <NEWLINE> <INDENT> x = len ( { a , b , c } ) <NEWLINE> if x == 1 : pass <NEWLINE> elif x == 2 : x = 3 <NEWLINE> else : x = 6 <NEWLINE> yield gcd ( [ a , b , c ] ) * x <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( sum ( main ( ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ 0 ] * int ( 1e5 + 10 ) <NEWLINE> sum = 0 <NEWLINE> for i in a_list : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> sum += i <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for j in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> sum += ( y - x ) * cnt [ x ] <NEWLINE> cnt [ y ] += cnt [ x ] <NEWLINE> cnt [ x ] = 0 <NEWLINE> print ( sum ) <NEWLINE> <DEDENT>
import sys <NEWLINE> c = 0 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( sys . stdin . readline ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c += 1 <NEWLINE> print ( <STRING> + str ( c ) + <STRING> , x ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N , P = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pascal_triangle = [ ] <NEWLINE> <NL> memo = [ [ 0 for _ in range ( 51 ) ] for _ in range ( 51 ) ] <NEWLINE> <NL> def c ( n , k ) : <NEWLINE> <INDENT> if memo [ n ] [ k ] != 0 : <NEWLINE> <INDENT> return memo [ n ] [ k ] <NEWLINE> <DEDENT> if ( k <= 0 or n <= k ) : <NEWLINE> <INDENT> memo [ n ] [ k ] = 1 <NEWLINE> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = c ( n - 1 , k - 1 ) + c ( n - 1 , k ) <NEWLINE> memo [ n ] [ k ] = ans <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 51 ) : <NEWLINE> <INDENT> pascal_triangle . append ( [ c ( i , j ) for j in range ( i + 1 ) ] ) <NEWLINE> <NL> <DEDENT> Numbers_1 = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Numbers_1 += A [ i ] % 2 <NEWLINE> <NL> <DEDENT> Select_0_count = sum ( pascal_triangle [ N - Numbers_1 ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( Numbers_1 + 1 ) : <NEWLINE> <INDENT> if i % 2 == P : <NEWLINE> <INDENT> ans += pascal_triangle [ Numbers_1 ] [ i ] * Select_0_count <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if B > N : <NEWLINE> <INDENT> print ( int ( A * N / B ) - A * ( int ( N / B ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( A * ( B - 1 ) / B ) - A * ( int ( ( B - 1 ) / B ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> C = Counter ( S ) <NEWLINE> R = C . get ( <STRING> , 0 ) <NEWLINE> G = C . get ( <STRING> , 0 ) <NEWLINE> B = C . get ( <STRING> , 0 ) <NEWLINE> ans = R * G * B <NEWLINE> for left in range ( N ) : <NEWLINE> <INDENT> for mid in range ( left + 1 , N ) : <NEWLINE> <INDENT> right = mid + mid - left <NEWLINE> if right < N : <NEWLINE> <INDENT> if S [ right ] != S [ mid ] and S [ mid ] != S [ left ] and S [ right ] != S [ left ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> r = 2 * m + 1 <NEWLINE> if m % 2 : <NEWLINE> <INDENT> for i in range ( 1 , m // 2 + 1 ) : <NEWLINE> <INDENT> ans . append ( [ i , m + 1 - i ] ) <NEWLINE> <DEDENT> for i in range ( m + 1 , ( m + 1 + r ) // 2 + 1 ) : <NEWLINE> <INDENT> ans . append ( [ i , m + 1 + r - i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , m // 2 + 1 ) : <NEWLINE> <INDENT> ans . append ( [ i , m + 1 - i ] ) <NEWLINE> <DEDENT> for i in range ( m + 1 , ( m + 1 + r ) // 2 ) : <NEWLINE> <INDENT> ans . append ( [ i , m + 1 + r - i ] ) <NEWLINE> <DEDENT> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( * a ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . root ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . root ( x ) <NEWLINE> y = self . root ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . root ( x ) == self . root ( y ) <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . root ( x ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> friend = UnionFind ( N + 1 ) <NEWLINE> block = [ 1 ] * ( N + 1 ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> block [ x ] += 1 <NEWLINE> block [ y ] += 1 <NEWLINE> friend . union ( x , y ) <NEWLINE> <DEDENT> for _ in range ( K ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if friend . same ( x , y ) : <NEWLINE> <INDENT> block [ x ] += 1 <NEWLINE> block [ y ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = [ friend . size ( i ) - block [ i ] for i in range ( 1 , N + 1 ) ] <NEWLINE> print ( * ans ) <NEWLINE>
N , K = input ( ) . split ( ) <NEWLINE> N = int ( N ) <NEWLINE> K = int ( K ) <NEWLINE> scores = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> sums = [ ] <NEWLINE> k = K - 1 <NEWLINE> for i in range ( k , N - 1 ) : <NEWLINE> <INDENT> if ( scores [ i - k ] < scores [ i + 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd as gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> ans1 = 0 <NEWLINE> ans2 = 0 <NEWLINE> ans3 = 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K ) : <NEWLINE> <INDENT> for k in range ( j + 1 , K ) : <NEWLINE> <INDENT> ans1 += gcd ( gcd ( i + 1 , j + 1 ) , k + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K ) : <NEWLINE> <INDENT> ans2 += gcd ( i + 1 , j + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> ans3 += i + 1 <NEWLINE> <NL> <DEDENT> print ( ans1 * 6 + ans2 * 6 + ans3 ) <NEWLINE>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a_score = 0 <NEWLINE> b_score = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> a_score += a + b <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> b_score += a + b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_score += a <NEWLINE> b_score += a <NEWLINE> <DEDENT> <DEDENT> print ( a_score , b_score ) <NEWLINE> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : break <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( k ) ] <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> mod = 998244353 <NEWLINE> dpsum = [ 0 ] * ( n + 1 ) <NEWLINE> dpsum [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> li = max ( i - s [ j ] [ 1 ] , 1 ) <NEWLINE> ri = i - s [ j ] [ 0 ] <NEWLINE> if ri < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] += dpsum [ ri ] - dpsum [ li - 1 ] <NEWLINE> dp [ i ] %= mod <NEWLINE> <DEDENT> dpsum [ i ] = dpsum [ i - 1 ] + dp [ i ] <NEWLINE> <DEDENT> print ( dp [ n ] ) <NEWLINE> <NL>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> limit = 10 ** 18 <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> assert N == len ( A ) <NEWLINE> answer = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> answer *= i <NEWLINE> if answer > limit : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> input = sys . stdin . buffer . readline <NEWLINE> <COMMENT> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> A = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> @ njit ( cache = True ) <NEWLINE> def loop ( A ) : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <COMMENT> <NL> <INDENT> cnt = np . zeros_like ( A ) <NEWLINE> for j , x in enumerate ( A ) : <NEWLINE> <COMMENT> <NL> <INDENT> l = max ( j - x , 0 ) <NEWLINE> r = min ( j + x + 1 , N ) <NEWLINE> cnt [ l ] += 1 <NEWLINE> if r < N : <NEWLINE> <INDENT> cnt [ r ] -= 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> A = np . cumsum ( cnt ) <NEWLINE> if A [ 0 ] == A [ N - 1 ] == N : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> return A <NEWLINE> <NL> <DEDENT> A = loop ( A ) <NEWLINE> print ( * A ) <NEWLINE>
<COMMENT> <NL> import random <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> <NL> C = [ int ( y ) for y in input ( ) . split ( ) ] <NEWLINE> <NL> S = [ ] <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> def scoring ( inp , poi ) : <NEWLINE> <NL> <INDENT> score = 0 <NEWLINE> day = 1 <NEWLINE> last = [ 0 ] * 26 <NEWLINE> <NL> for I in inp : <NEWLINE> <INDENT> score += poi [ day - 1 ] [ I - 1 ] <NEWLINE> last [ I - 1 ] = day <NEWLINE> for ind , J in enumerate ( last ) : <NEWLINE> <INDENT> score -= C [ ind ] * ( day - ind - 1 ) <NEWLINE> <DEDENT> day += 1 <NEWLINE> <NL> <DEDENT> return score <NEWLINE> <NL> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> s = [ int ( y ) for y in input ( ) . split ( ) ] <NEWLINE> S . append ( s ) <NEWLINE> <NL> <DEDENT> for i in S : <NEWLINE> <INDENT> k = 0 <NEWLINE> num = 0 <NEWLINE> for f , t in enumerate ( i ) : <NEWLINE> <INDENT> k = max ( k , t ) <NEWLINE> if k == t : <NEWLINE> <INDENT> num = f + 1 <NEWLINE> <DEDENT> <DEDENT> ans . append ( num ) <NEWLINE> <NL> <DEDENT> counter = 100 <NEWLINE> <NL> base = scoring ( ans , S ) <NEWLINE> nbase = 0 <NEWLINE> d = 0 <NEWLINE> ansc = ans . copy ( ) <NEWLINE> <NL> for i in range ( counter ) : <NEWLINE> <INDENT> p = random . randint ( 0 , 25 ) <NEWLINE> q = random . randint ( 0 , D - 1 ) <NEWLINE> ansc [ q ] = p <NEWLINE> nbase = scoring ( ansc , S ) <NEWLINE> if nbase > base : <NEWLINE> <INDENT> ans = ansc . copy ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ansc = ans . copy ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( <STRING> . format ( int ( i ) ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> thres = 10 ** 18 <NEWLINE> res = A [ 0 ] <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> res *= A [ i + 1 ] <NEWLINE> if res > thres : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
from collections import Counter <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = Counter ( [ ] ) <NEWLINE> X , Y = [ ] , [ ] <NEWLINE> m = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a = A [ m ] - 1 <NEWLINE> C [ m ] += 1 <NEWLINE> X . append ( m ) <NEWLINE> if C [ a ] != 0 : <NEWLINE> <INDENT> Y = X [ X . index ( a ) : ] <NEWLINE> X = X [ : X . index ( a ) ] <NEWLINE> break <NEWLINE> <DEDENT> m = a <NEWLINE> <COMMENT> <NL> <DEDENT> x = len ( X ) <NEWLINE> y = len ( Y ) <NEWLINE> if k <= x - 1 : <NEWLINE> <INDENT> print ( X [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= x <NEWLINE> print ( Y [ k - ( k // y ) * y ] + 1 ) <NEWLINE> <DEDENT>
from _collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> X = [ [ ] for _ in range ( n ) ] <NEWLINE> visited = [ 0 ] * ( n + 1 ) <NEWLINE> ANS = [ 0 ] * n <NEWLINE> ANS [ 0 ] = 1 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> X [ a - 1 ] . append ( b - 1 ) <NEWLINE> X [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> q = deque ( [ 0 ] ) <NEWLINE> visited [ 0 ] = 1 <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> s = q . popleft ( ) <NEWLINE> for x in X [ s ] : <NEWLINE> <INDENT> if visited [ x ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q . append ( x ) <NEWLINE> ANS [ x ] = s <NEWLINE> visited [ x ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for ans in ANS [ 1 : ] : <NEWLINE> <INDENT> print ( ans + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A , reverse = True ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans += A [ i // 2 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_sum = [ 0 ] <NEWLINE> b_sum = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a_sum . append ( a [ i ] + a_sum [ i ] ) <NEWLINE> if a_sum [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b_sum . append ( b [ i ] + b_sum [ i ] ) <NEWLINE> if b_sum [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> y = len ( b_sum ) - 1 <NEWLINE> for i in range ( len ( a_sum ) ) : <NEWLINE> <INDENT> if a_sum [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> time = k - a_sum [ i ] <NEWLINE> for j in range ( y , - 1 , - 1 ) : <NEWLINE> <INDENT> if time >= b_sum [ j ] : <NEWLINE> <INDENT> y = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if time >= b_sum [ len ( b_sum ) - 1 ] : <NEWLINE> <INDENT> j = len ( b_sum ) - 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
NIL = - 1 <NEWLINE> <NL> <NL> class Node : <NEWLINE> <INDENT> parent = NIL <NEWLINE> left = NIL <NEWLINE> right = NIL <NEWLINE> <NL> <NL> <DEDENT> def getDepth ( u ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> while T [ u ] . parent != NIL : <NEWLINE> <INDENT> u = T [ u ] . parent <NEWLINE> d += 1 <NEWLINE> <DEDENT> return d <NEWLINE> <NL> <NL> <DEDENT> def getChildren ( u ) : <NEWLINE> <INDENT> c = T [ u ] . left <NEWLINE> result = [ ] <NEWLINE> while c != NIL : <NEWLINE> <INDENT> result . append ( c ) <NEWLINE> c = T [ c ] . right <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> T = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> T [ i ] = Node ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> id = tmp . pop ( 0 ) <NEWLINE> k = tmp . pop ( 0 ) <NEWLINE> c = tmp <NEWLINE> if k != 0 : <NEWLINE> <INDENT> for j in range ( len ( c ) ) : <NEWLINE> <INDENT> T [ c [ j ] ] . parent = id <NEWLINE> <DEDENT> T [ id ] . left = c [ 0 ] <NEWLINE> for j in range ( len ( c ) - 1 ) : <NEWLINE> <INDENT> T [ c [ j ] ] . right = c [ j + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> d = getDepth ( i ) <NEWLINE> c = getChildren ( i ) <NEWLINE> if d == 0 : <NEWLINE> <INDENT> t = <STRING> <NEWLINE> <DEDENT> elif c == [ ] : <NEWLINE> <INDENT> t = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = <STRING> <NEWLINE> <DEDENT> print ( <STRING> , i , <STRING> , <STRING> , T [ i ] . parent , <STRING> , d , <STRING> , t , <STRING> , c , sep = <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from itertools import combinations_with_replacement as cwr <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def dfs ( n , m ) : <NEWLINE> <INDENT> adj = { } <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> adj [ i ] = [ j for j in range ( i , m + 1 ) ] <NEWLINE> <NL> <DEDENT> stack = [ [ i ] for i in range ( 1 , m + 1 ) ] <NEWLINE> combs = [ ] <NEWLINE> while stack : <NEWLINE> <INDENT> node = stack . pop ( ) <NEWLINE> if len ( node ) == n : <NEWLINE> <INDENT> combs . append ( node ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for child in adj [ node [ - 1 ] ] : <NEWLINE> <INDENT> cand = node + [ child ] <NEWLINE> stack . append ( cand ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return combs <NEWLINE> <NL> <NL> <DEDENT> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A , B , C , D = [ ] , [ ] , [ ] , [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> D . append ( d ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> combs = dfs ( N , M ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans = [ 0 ] * ( len ( combs ) ) <NEWLINE> for i , comb in enumerate ( combs ) : <NEWLINE> <INDENT> for a , b , c , d in zip ( A , B , C , D ) : <NEWLINE> <INDENT> if comb [ b ] - comb [ a ] == c : <NEWLINE> <INDENT> ans [ i ] += d <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE> <NL>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def dfs ( st , depth = 0 ) : <NEWLINE> <INDENT> dist [ st ] = depth <NEWLINE> for to , c in tree [ st ] : <NEWLINE> <INDENT> if dist [ to ] >= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( to , depth + c ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> tree = [ [ ] for _ in range ( N ) ] <NEWLINE> dist = [ - 1 ] * N <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ a - 1 ] . append ( ( b - 1 , c ) ) <NEWLINE> tree [ b - 1 ] . append ( ( a - 1 , c ) ) <NEWLINE> <NL> <DEDENT> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> dfs ( K - 1 , 0 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( dist [ x - 1 ] + dist [ y - 1 ] ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> goods = defaultdict ( lambda : 0 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> goods [ S ] = 0 <NEWLINE> <NL> <DEDENT> print ( len ( goods ) ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ct = collections . Counter ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( ct [ i + 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> MOD2 = 998244353 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> def combinations_count ( n , r ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> S = SI ( ) <NEWLINE> <NL> ls = [ ] <NEWLINE> len_S = len ( S ) <NEWLINE> rem = 0 <NEWLINE> <NL> for s in range ( len_S - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> rem = ( rem + int ( S [ s ] ) * pow ( 10 , len_S - s - 1 , 2019 ) ) % 2019 <NEWLINE> ls . append ( rem ) <NEWLINE> <NL> <DEDENT> import collections <NEWLINE> <NL> cls = collections . Counter ( ls ) <NEWLINE> clsv = list ( cls . values ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for p in clsv : <NEWLINE> <INDENT> ans += combinations_count ( p , 2 ) <NEWLINE> <DEDENT> ans += cls [ 0 ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> alpha = [ <STRING> ] <NEWLINE> alpha . extend ( [ chr ( ord ( <STRING> ) + i ) for i in range ( 26 ) ] ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> q = N <NEWLINE> ans = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> if q <= 26 : <NEWLINE> <INDENT> ans += str ( alpha [ q ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q , mod = divmod ( q , 26 ) <NEWLINE> if mod == 0 : <NEWLINE> <INDENT> q -= 1 <NEWLINE> mod = 26 <NEWLINE> <DEDENT> ans += str ( alpha [ mod ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
<COMMENT> <NL> K = int ( input ( ) ) <NEWLINE> import math <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> for k in range ( K ) : <NEWLINE> <INDENT> x = math . gcd ( i + 1 , k + 1 ) <NEWLINE> if x == 1 : <NEWLINE> <INDENT> ans += K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for l in range ( K ) : <NEWLINE> <INDENT> ans += math . gcd ( x , l + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> Amax = A [ - 1 ] <NEWLINE> dp = [ True ] * ( Amax + 1 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> p = A [ i ] <NEWLINE> if dp [ p ] : <NEWLINE> <INDENT> for j in range ( 1 , Amax // p + 1 ) : <NEWLINE> <INDENT> dp [ p * j ] = False <NEWLINE> <DEDENT> if p != A [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if dp [ Amax ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
flag = False <NEWLINE> while True : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % 400 == 0 or ( i % 100 != 0 and i % 4 == 0 ) : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> flag = True <NEWLINE> if len ( ans ) != 0 : <NEWLINE> <INDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> print ( n * ( n - 1 ) // 2 ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> List = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> sup_list = [ 1 for i in range ( N ) ] <NEWLINE> <NL> for j in range ( M ) : <NEWLINE> <INDENT> if H [ List [ j ] [ 0 ] - 1 ] > H [ List [ j ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> sup_list [ List [ j ] [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ List [ j ] [ 0 ] - 1 ] == H [ List [ j ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> sup_list [ List [ j ] [ 0 ] - 1 ] = 0 <NEWLINE> sup_list [ List [ j ] [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sup_list [ List [ j ] [ 0 ] - 1 ] = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( sum ( sup_list ) ) <NEWLINE>
import sys <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> i = 1 <NEWLINE> l = [ 1 ] * N <NEWLINE> s = set ( [ 1 ] ) <NEWLINE> n = 1 <NEWLINE> while True : <NEWLINE> <INDENT> n = A [ n - 1 ] <NEWLINE> if n in s : <NEWLINE> <INDENT> l = l [ : i ] <NEWLINE> mod = i - l . index ( n ) <NEWLINE> init_len = l . index ( n ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ i ] = n <NEWLINE> s . add ( n ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if K < init_len : <NEWLINE> <INDENT> print ( l [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rest = ( ( K - init_len ) % mod ) <NEWLINE> print ( l [ init_len + rest ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> visited = [ ] <NEWLINE> tf_visited = [ 0 ] * n <NEWLINE> pos = 0 <NEWLINE> count = 0 <NEWLINE> <NL> while tf_visited [ pos ] == 0 : <NEWLINE> <INDENT> visited . append ( pos ) <NEWLINE> tf_visited [ pos ] = 1 <NEWLINE> pos = a [ pos ] - 1 <NEWLINE> count += 1 <NEWLINE> if count >= k : <NEWLINE> <INDENT> print ( pos + 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> loop_start = visited . index ( pos ) <NEWLINE> loop_length = len ( visited ) - loop_start <NEWLINE> pos_t = ( k - loop_start ) % loop_length + loop_start <NEWLINE> print ( visited [ pos_t ] + 1 ) <NEWLINE>
import numpy as np <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> c = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> t = [ np . random . randint ( 1 , 27 ) for _ in range ( D ) ] <NEWLINE> <NL> MAX = 0 <NEWLINE> for _ in range ( 1500 ) : <NEWLINE> <INDENT> d = np . random . randint ( 1 , D + 1 ) <NEWLINE> q = np . random . randint ( 1 , 27 ) <NEWLINE> last = np . array ( [ 0 ] * 26 ) <NEWLINE> v = 0 <NEWLINE> for i in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> if i == d : <NEWLINE> <INDENT> v += s [ d - 1 ] [ q - 1 ] <NEWLINE> last [ q - 1 ] = d <NEWLINE> v -= np . dot ( c , d - last ) <NEWLINE> continue <NEWLINE> <DEDENT> v += s [ i - 1 ] [ t [ i - 1 ] - 1 ] <NEWLINE> last [ t [ i - 1 ] - 1 ] = i <NEWLINE> v -= np . dot ( c , i - last ) <NEWLINE> <DEDENT> if v > MAX : <NEWLINE> <INDENT> MAX = v <NEWLINE> t [ d - 1 ] = q <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> print ( t [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> vs = [ int ( a ) for a in sys . stdin . readline ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> <NL> M = 1000000000 + 7 <NEWLINE> <NL> ret = 0 <NEWLINE> sum = 0 <NEWLINE> for j in range ( 1 , N ) : <NEWLINE> <INDENT> sum += vs [ j - 1 ] <NEWLINE> ret += ( vs [ j ] * sum ) % M <NEWLINE> ret = ret % M <NEWLINE> <DEDENT> print ( ret ) <NEWLINE>
sec = int ( input ( ) ) <NEWLINE> print ( sec // 3600 , <STRING> , ( sec % 3600 ) // 60 , <STRING> , sec % 60 , sep = <STRING> ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def solve ( h , w , ch , cw , dh , dw , s ) : <NEWLINE> <INDENT> W , H = w + 5 , h + 5 <NEWLINE> def pos ( r , c ) : <NEWLINE> <INDENT> return ( r + 2 ) * W + c + 2 <NEWLINE> <DEDENT> G = [ 0 ] * ( W * H ) <NEWLINE> label = 0 <NEWLINE> for r in range ( h ) : <NEWLINE> <INDENT> for c in range ( w ) : <NEWLINE> <INDENT> if ( s [ r ] [ c ] == <STRING> ) and ( G [ pos ( r , c ) ] == 0 ) : <NEWLINE> <INDENT> label += 1 <NEWLINE> que = deque ( [ ( r , c ) ] ) <NEWLINE> G [ pos ( r , c ) ] = label <NEWLINE> while que : <NEWLINE> <INDENT> cr , cc = que . popleft ( ) <NEWLINE> for dr , dc in [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] : <NEWLINE> <INDENT> nr , nc = cr + dr , cc + dc <NEWLINE> if ( 0 <= nr < h ) and ( 0 <= nc < w ) and ( s [ nr ] [ nc ] == <STRING> ) and ( G [ pos ( nr , nc ) ] == 0 ) : <NEWLINE> <INDENT> G [ pos ( nr , nc ) ] = label <NEWLINE> que . append ( ( nr , nc ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> start = pos ( ch - 1 , cw - 1 ) <NEWLINE> goal = pos ( dh - 1 , dw - 1 ) <NEWLINE> <NL> neighbors = [ ( dr * W + dc ) for dc in range ( - 2 , 3 ) for dr in range ( - 2 , 3 ) if abs ( dr ) + abs ( dc ) > 0 ] <NEWLINE> used = [ True ] * ( W * H ) <NEWLINE> for r in range ( h ) : <NEWLINE> <INDENT> for c in range ( w ) : <NEWLINE> <INDENT> used [ pos ( r , c ) ] = ( s [ r ] [ c ] == <STRING> ) <NEWLINE> <DEDENT> <DEDENT> que = deque ( [ ( start , 0 ) ] ) <NEWLINE> label_dist_mapping = [ - 1 ] * ( label + 1 ) <NEWLINE> used [ start ] = True <NEWLINE> label_dist_mapping [ G [ start ] ] = 0 <NEWLINE> while que : <NEWLINE> <INDENT> cpos , n = que . popleft ( ) <NEWLINE> if cpos == goal : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> for d in neighbors : <NEWLINE> <INDENT> npos = cpos + d <NEWLINE> if not used [ npos ] : <NEWLINE> <INDENT> used [ npos ] = True <NEWLINE> m = label_dist_mapping [ G [ npos ] ] <NEWLINE> if ( G [ npos ] == G [ cpos ] ) or ( n == m ) : <COMMENT> <NEWLINE> <INDENT> que . appendleft ( ( npos , n ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> label_dist_mapping [ G [ npos ] ] = n + 1 <NEWLINE> que . append ( ( npos , n + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> ch , cw = map ( int , input ( ) . split ( ) ) <NEWLINE> dh , dw = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for i in range ( h ) ] <NEWLINE> print ( solve ( h , w , ch , cw , dh , dw , s ) ) <NEWLINE>
import math <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> minus_A_plus_i = tuple ( [ - A [ i ] + ( i + 1 ) for i in range ( N ) ] ) <NEWLINE> A_plus_i = tuple ( [ A [ i ] + ( i + 1 ) for i in range ( N ) ] ) <NEWLINE> <NL> cnt = defaultdict ( int ) <NEWLINE> for e in minus_A_plus_i : <NEWLINE> <INDENT> cnt [ e ] += 1 <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> <NL> for item in A_plus_i : <NEWLINE> <INDENT> c += cnt [ item ] <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D , E = [ ] , [ ] <NEWLINE> zcnt , scnt , fcnt = 0 , 0 , 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> zcnt += 1 <NEWLINE> D . append ( 0 ) <NEWLINE> <DEDENT> elif i > 0 : <NEWLINE> <INDENT> D . append ( i ) <NEWLINE> scnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> E . append ( i ) <NEWLINE> fcnt += 1 <NEWLINE> <DEDENT> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> <COMMENT> <NL> if K == N : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> if K % 2 == 1 and max ( A ) < 0 : <NEWLINE> <INDENT> A = sorted ( A ) [ : : - 1 ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> if K > scnt + fcnt : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> D , E = sorted ( D ) [ : : - 1 ] , sorted ( E ) <NEWLINE> <COMMENT> <NL> ans = 1 <NEWLINE> cnt = 0 <NEWLINE> a , b = 0 , 0 <NEWLINE> while K - cnt > 1 : <NEWLINE> <INDENT> if a + 1 <= len ( D ) - 1 and b + 1 <= len ( E ) - 1 : <NEWLINE> <INDENT> d , e = D [ a ] * D [ a + 1 ] , E [ b ] * E [ b + 1 ] <NEWLINE> if d > e : <NEWLINE> <INDENT> ans *= D [ a ] <NEWLINE> a += 1 <NEWLINE> cnt += 1 <NEWLINE> ans %= mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= e <NEWLINE> b += 2 <NEWLINE> ans %= mod <NEWLINE> cnt += 2 <NEWLINE> <DEDENT> <DEDENT> elif a + 1 <= len ( D ) - 1 : <NEWLINE> <INDENT> d = D [ a ] * D [ a + 1 ] <NEWLINE> ans *= D [ a ] <NEWLINE> a += 1 <NEWLINE> cnt += 1 <NEWLINE> ans %= mod <NEWLINE> <DEDENT> elif b + 1 <= len ( E ) - 1 : <NEWLINE> <INDENT> e = E [ b ] * E [ b + 1 ] <NEWLINE> ans *= e <NEWLINE> b += 2 <NEWLINE> cnt += 2 <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> <DEDENT> if K - cnt == 1 : <NEWLINE> <INDENT> Z = [ ] <NEWLINE> if a != scnt : <NEWLINE> <INDENT> Z . append ( D [ a ] ) <NEWLINE> <DEDENT> if b != fcnt : <NEWLINE> <INDENT> Z . append ( E [ - 1 ] ) <NEWLINE> <DEDENT> if 0 in A : <NEWLINE> <INDENT> Z . append ( 0 ) <NEWLINE> <DEDENT> ans *= max ( Z ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n != 0 : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = [ ] <NEWLINE> <NL> <DEDENT> diff = 10 ** 18 <NEWLINE> ans = 10 ** 18 <NEWLINE> <NL> for i in range ( - 10000 , 10000 ) : <NEWLINE> <INDENT> if i in l : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if abs ( x - i ) < diff : <NEWLINE> <INDENT> ans = i <NEWLINE> diff = abs ( x - i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = <STRING> <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ( i % 3 == 0 ) : <NEWLINE> <INDENT> s += <STRING> + str ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = i <NEWLINE> while x : <NEWLINE> <INDENT> if ( x % 10 == 3 ) : <NEWLINE> <INDENT> s += <STRING> + str ( i ) <NEWLINE> break <NEWLINE> <DEDENT> x //= 10 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import numpy as np <NEWLINE> i4 = np . int32 <NEWLINE> i8 = np . int64 <NEWLINE> <NL> <NL> def find ( x , parents ) : <NEWLINE> <INDENT> if parents [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return find ( parents [ x ] , parents ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def union ( x , y , parents , depth ) : <NEWLINE> <INDENT> x = find ( x , parents ) <NEWLINE> y = find ( y , parents ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if depth [ x ] == depth [ y ] : <NEWLINE> <INDENT> depth [ x ] += 1 <NEWLINE> parents [ y ] = x <NEWLINE> <DEDENT> elif depth [ x ] > depth [ y ] : <NEWLINE> <INDENT> parents [ y ] = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parents [ x ] = y <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( in_file ) : <NEWLINE> <INDENT> stdin = open ( in_file ) <NEWLINE> N , M = [ int ( x ) for x in stdin . readline ( ) . split ( ) ] <NEWLINE> a = np . empty ( M , i8 ) <NEWLINE> b = np . empty ( M , i8 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = [ int ( x ) - 1 for x in stdin . readline ( ) . split ( ) ] <NEWLINE> <DEDENT> parents = np . arange ( N ) <NEWLINE> depth = np . zeros ( N , i8 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> union ( a [ i ] , b [ i ] , parents , depth ) <NEWLINE> <DEDENT> num = np . zeros ( N , i8 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> p = find ( i , parents ) <NEWLINE> num [ p ] += 1 <NEWLINE> <DEDENT> ans = num . max ( ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( <STRING> ) <NEWLINE>
from collections import Counter <NEWLINE> from sys import stdin <NEWLINE> N = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> A = [ int ( _ ) for _ in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> CA = Counter ( A ) <NEWLINE> Q = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> ans = sum ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = [ int ( _ ) for _ in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> ans += ( c - b ) * CA [ b ] <NEWLINE> CA [ c ] += CA [ b ] <NEWLINE> CA [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> r , g , b = S . count ( <STRING> ) , S . count ( <STRING> ) , S . count ( <STRING> ) <NEWLINE> ans = r * g * b <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for d in range ( N // 2 + 1 ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= N : break <NEWLINE> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> A . sort ( ) <NEWLINE> C = Counter ( A ) <NEWLINE> MAX = 1010101 <NEWLINE> B = [ 0 ] * MAX <NEWLINE> <NL> ans = 0 <NEWLINE> for a , cnt in C . items ( ) : <NEWLINE> <INDENT> if B [ a ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for i in range ( 2 * a , MAX , a ) : <NEWLINE> <INDENT> B [ i ] = 1 <NEWLINE> <DEDENT> if cnt == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> S = input ( ) <NEWLINE> <NL> R = S . count ( <STRING> ) <NEWLINE> G = S . count ( <STRING> ) <NEWLINE> B = S . count ( <STRING> ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = i + ( ( j - i ) * 2 ) <NEWLINE> if k < N : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( R * G * B - cnt ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for m in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> l . append ( m ) <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> s = input ( ) . split ( ) <NEWLINE> for j in s : <NEWLINE> <INDENT> if int ( j ) in l : <NEWLINE> <INDENT> l . remove ( int ( j ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( l ) ) <NEWLINE>
total , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def total_to_digits ( total ) : <NEWLINE> <INDENT> return map ( int , list ( str ( total ) ) ) <NEWLINE> <NL> <DEDENT> def find_lowest_denomination ( total , d ) : <NEWLINE> <INDENT> res = None <NEWLINE> for i in range ( total , 99999 ) : <NEWLINE> <INDENT> digits = list ( total_to_digits ( i ) ) <NEWLINE> if not ( set ( digits ) & set ( d ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> find_lowest_denomination ( total , d ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> AB_map = [ [ ] for i in range ( N ) ] <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> AB = [ int ( x ) - 1 for x in input ( ) . split ( <STRING> ) ] <NEWLINE> AB_map [ AB [ 0 ] ] . append ( AB [ 1 ] ) <NEWLINE> AB_map [ AB [ 1 ] ] . append ( AB [ 0 ] ) <NEWLINE> <NL> <DEDENT> not_finished = set ( range ( 1 , N + 1 ) ) <NEWLINE> rooms = [ None ] * N <NEWLINE> rooms [ 0 ] = 0 <NEWLINE> room_depths = [ 0 ] * N <NEWLINE> <NL> recent_rooms = [ 0 ] <NEWLINE> depth = 1 <NEWLINE> while len ( not_finished ) != 0 and depth < N : <NEWLINE> <INDENT> temp_recent = set ( ) <NEWLINE> for r in recent_rooms : <NEWLINE> <INDENT> for target in AB_map [ r ] : <NEWLINE> <INDENT> if target in not_finished : <NEWLINE> <INDENT> temp_recent . add ( target ) <NEWLINE> not_finished . remove ( target ) <NEWLINE> rooms [ target ] = r <NEWLINE> room_depths [ target ] = depth <NEWLINE> <DEDENT> <DEDENT> <DEDENT> depth += 1 <NEWLINE> recent_rooms = list ( temp_recent ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for r in rooms [ 1 : ] : <NEWLINE> <INDENT> print ( r + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> broken = set ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> broken . add ( int ( input ( ) ) ) <NEWLINE> <DEDENT> if N == 1 : <NEWLINE> <INDENT> if 1 in broken : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> elif N == 2 : <NEWLINE> <INDENT> if 2 in broken : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif 1 in broken : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp = [ 0 for i in range ( N + 1 ) ] <NEWLINE> if 1 not in broken : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> if 2 not in broken : <NEWLINE> <INDENT> dp [ 2 ] = dp [ 1 ] + 1 <NEWLINE> <DEDENT> for i in range ( 3 , N + 1 ) : <NEWLINE> <INDENT> if i in broken : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> dp [ i ] %= 1000000007 <NEWLINE> <DEDENT> <DEDENT> print ( dp [ N ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . buffer . readline <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def RD ( ) : return sys . stdin . read ( ) <NEWLINE> <NL> <NL> def II ( ) : return int ( input ( ) ) <NEWLINE> <NL> <NL> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def MF ( ) : return map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def LF ( ) : return list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def TI ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = II ( ) <NEWLINE> A = np . array ( [ 0 ] + LI ( ) + [ 10 ** 6 ] ) <NEWLINE> B = np . array ( [ 0 ] + LI ( ) + [ 10 ** 6 ] ) <NEWLINE> Ar = ( A [ : - 1 ] < A [ 1 : ] ) [ 1 : ] <NEWLINE> Al = ( A [ : - 1 ] < A [ 1 : ] ) [ : - 1 ] <NEWLINE> Br = ( B [ : - 1 ] < B [ 1 : ] ) [ 1 : ] <NEWLINE> Bl = ( B [ : - 1 ] < B [ 1 : ] ) [ : - 1 ] <NEWLINE> <NL> A = A [ 1 : - 1 ] <NEWLINE> B = B [ 1 : - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <NL> AAl = np . array ( [ 10 ** 7 ] * ( n + 1 ) ) <NEWLINE> AAr = np . array ( [ 10 ** 7 ] * ( n + 1 ) ) <NEWLINE> BBl = np . array ( [ - 10 ** 7 ] * ( n + 1 ) ) <NEWLINE> BBr = np . array ( [ - 10 ** 7 ] * ( n + 1 ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if Al [ i ] == 1 : <NEWLINE> <INDENT> AAl [ A [ i ] ] = i <NEWLINE> <DEDENT> if Ar [ i ] == 1 : <NEWLINE> <INDENT> AAr [ A [ i ] ] = i <NEWLINE> <DEDENT> if Bl [ i ] == 1 : <NEWLINE> <INDENT> BBl [ B [ i ] ] = i <NEWLINE> <DEDENT> if Br [ i ] == 1 : <NEWLINE> <INDENT> BBr [ B [ i ] ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> L = AAl - BBr <NEWLINE> R = AAr - BBl <NEWLINE> R = R [ R < 10 ** 6 ] <NEWLINE> <COMMENT> <NL> LL = L . min ( ) <NEWLINE> <NL> try : <NEWLINE> <INDENT> RR = max ( R ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> RR = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> if RR - LL + 2 > n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> C = np . concatenate ( [ B [ - LL + 1 : ] , B [ : - LL + 1 ] ] ) <NEWLINE> print ( * C ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ [ ] for _ in range ( n ) ] <NEWLINE> px = [ 0 for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab [ a - 1 ] . append ( b - 1 ) <NEWLINE> ab [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> px [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> ans = px <NEWLINE> queue = deque ( [ ( 0 , 0 ) ] ) <NEWLINE> while len ( queue ) > 0 : <NEWLINE> <INDENT> prev , a = queue . pop ( ) <NEWLINE> for c in ab [ a ] : <NEWLINE> <INDENT> if c != prev : <NEWLINE> <INDENT> ans [ c ] += ans [ a ] <NEWLINE> queue . append ( ( a , c ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE>
<COMMENT> <NL> <NL> class Dice : <NEWLINE> <INDENT> def __init__ ( self , a1 , a2 , a3 , a4 , a5 , a6 ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . face = [ a1 , a2 , a3 , a4 , a5 , a6 ] <NEWLINE> self . v = [ a5 , a1 , a2 , a6 ] <COMMENT> <NEWLINE> self . h = [ a4 , a1 , a3 , a6 ] <COMMENT> <NEWLINE> self . det = 1 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> def top ( self ) : <NEWLINE> <INDENT> return self . v [ 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def north ( self ) : <NEWLINE> <INDENT> newV = [ self . v [ 1 ] , self . v [ 2 ] , self . v [ 3 ] , self . v [ 0 ] ] <NEWLINE> self . v = newV <NEWLINE> self . h [ 1 ] = self . v [ 1 ] <NEWLINE> self . h [ 3 ] = self . v [ 3 ] <NEWLINE> return self . v , self . h <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def south ( self ) : <NEWLINE> <INDENT> newV = [ self . v [ 3 ] , self . v [ 0 ] , self . v [ 1 ] , self . v [ 2 ] ] <NEWLINE> self . v = newV <NEWLINE> self . h [ 1 ] = self . v [ 1 ] <NEWLINE> self . h [ 3 ] = self . v [ 3 ] <NEWLINE> return self . v , self . h <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def east ( self ) : <NEWLINE> <INDENT> newH = [ self . h [ 3 ] , self . h [ 0 ] , self . h [ 1 ] , self . h [ 2 ] ] <NEWLINE> self . h = newH <NEWLINE> self . v [ 1 ] = self . h [ 1 ] <NEWLINE> self . v [ 3 ] = self . h [ 3 ] <NEWLINE> return self . v , self . h <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def west ( self ) : <NEWLINE> <INDENT> newH = [ self . h [ 1 ] , self . h [ 2 ] , self . h [ 3 ] , self . h [ 0 ] ] <NEWLINE> self . h = newH <NEWLINE> self . v [ 1 ] = self . h [ 1 ] <NEWLINE> self . v [ 3 ] = self . h [ 3 ] <NEWLINE> return self . v , self . h <NEWLINE> <NL> <DEDENT> def searchFace ( self , a ) : <NEWLINE> <INDENT> b = 0 <NEWLINE> for i in range ( 6 ) : <NEWLINE> <INDENT> if a == self . face [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> b = i + 1 <NEWLINE> <DEDENT> <DEDENT> return b <NEWLINE> <NL> <DEDENT> def detJudge ( self , x ) : <COMMENT> <NEWLINE> <INDENT> y = int ( 7 / 2 - abs ( x - 7 / 2 ) ) <NEWLINE> if x != y : <NEWLINE> <INDENT> self . det *= - 1 <NEWLINE> <COMMENT> <NL> <DEDENT> return y <NEWLINE> <NL> <DEDENT> def rightSide ( self , top , front ) : <NEWLINE> <INDENT> r = 0 <NEWLINE> if top == 1 and front == 2 : <NEWLINE> <INDENT> r = 3 <NEWLINE> <DEDENT> elif top == 2 and front == 3 : <NEWLINE> <INDENT> r = 1 <NEWLINE> <DEDENT> elif top == 3 and front == 1 : <NEWLINE> <INDENT> r = 2 <NEWLINE> <DEDENT> elif top == 1 and front == 3 : <NEWLINE> <INDENT> r = 5 <NEWLINE> <DEDENT> elif top == 3 and front == 2 : <NEWLINE> <INDENT> r = 6 <NEWLINE> <DEDENT> elif top == 2 and front == 1 : <NEWLINE> <INDENT> r = 4 <NEWLINE> <DEDENT> if self . det == - 1 : <NEWLINE> <INDENT> r = 7 - r <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> <DEDENT> diceAmount = int ( input ( ) ) <NEWLINE> dices = [ ] <NEWLINE> for i in range ( diceAmount ) : <NEWLINE> <INDENT> d = [ int ( j ) for j in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> dice = Dice ( d [ 0 ] , d [ 1 ] , d [ 2 ] , d [ 3 ] , d [ 4 ] , d [ 5 ] ) <NEWLINE> dices . append ( dice ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> import random <NEWLINE> match = 0 <NEWLINE> diceCount = 1 <NEWLINE> while match == 0 and diceCount < diceAmount : <NEWLINE> <INDENT> for d2 in range ( 1 , diceAmount ) : <NEWLINE> <COMMENT> <NL> <INDENT> i = 0 <NEWLINE> while match == 0 and i < 10 : <NEWLINE> <INDENT> j = random . randint ( 0 , 3 ) <NEWLINE> if j == 0 : <NEWLINE> <INDENT> dices [ d2 ] . north ( ) <NEWLINE> <DEDENT> elif j == 1 : <NEWLINE> <INDENT> dices [ d2 ] . south ( ) <NEWLINE> <DEDENT> elif j == 2 : <NEWLINE> <INDENT> dices [ d2 ] . east ( ) <NEWLINE> <DEDENT> elif j == 3 : <NEWLINE> <INDENT> dices [ d2 ] . west ( ) <NEWLINE> <DEDENT> for d1 in range ( d2 ) : <NEWLINE> <INDENT> if ( dices [ d1 ] . v == dices [ d2 ] . v and dices [ d1 ] . h == dices [ d2 ] . h ) : <NEWLINE> <INDENT> match += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> diceCount += 1 <NEWLINE> <DEDENT> if match >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 1 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = 1 <NEWLINE> points = [ p ] <NEWLINE> visited = set ( [ p ] ) <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> p = A [ p ] <NEWLINE> if p in visited : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> points . append ( p ) <NEWLINE> visited . add ( p ) <NEWLINE> <NL> <DEDENT> idx = points . index ( p ) <NEWLINE> <NL> if idx > K : <NEWLINE> <INDENT> print ( points [ K ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> cycle = points [ idx : ] <NEWLINE> <NL> print ( cycle [ ( K - idx ) % len ( cycle ) ] ) <NEWLINE>
i = 1 <NEWLINE> x = int ( input ( ) ) <NEWLINE> while x != 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( i , x ) ) <NEWLINE> i = i + 1 <NEWLINE> x = int ( input ( ) ) <NEWLINE> <DEDENT>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> broken = [ False ] * ( n + 1 ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> broken [ int ( input ( ) ) ] = True <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dp [ 1 ] = 1 if not broken [ 1 ] else 0 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if not broken [ i - 1 ] : <NEWLINE> <INDENT> dp [ i ] += ( dp [ i - 1 ] ) <NEWLINE> <DEDENT> if not broken [ i - 2 ] : <NEWLINE> <INDENT> dp [ i ] += ( dp [ i - 2 ] ) <NEWLINE> <DEDENT> dp [ i ] %= MOD <NEWLINE> <NL> <DEDENT> print ( dp [ n ] ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def solve ( N : int , M : int , K : int , A : <STRING> , B : <STRING> ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> a_n = [ a ] <NEWLINE> for a_i in A : <NEWLINE> <INDENT> a += a_i <NEWLINE> a_n . append ( a ) <NEWLINE> <NL> <DEDENT> b = 0 <NEWLINE> b_n = [ b ] <NEWLINE> for b_i in B : <NEWLINE> <INDENT> b += b_i <NEWLINE> b_n . append ( b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> for i , a in enumerate ( a_n ) : <NEWLINE> <INDENT> if a > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b_n [ j ] > ( K - a ) : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> M = int ( next ( tokens ) ) <COMMENT> <NEWLINE> K = int ( next ( tokens ) ) <COMMENT> <NEWLINE> A = [ int ( next ( tokens ) ) for _ in range ( N ) ] <COMMENT> <NEWLINE> B = [ int ( next ( tokens ) ) for _ in range ( M ) ] <COMMENT> <NEWLINE> print ( solve ( N , M , K , A , B ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
d = { <STRING> : 7 , <STRING> : 6 , <STRING> : 5 , <STRING> : 4 , <STRING> : 3 , <STRING> : 2 , <STRING> : 1 } <NEWLINE> <NL> s = input ( ) <NEWLINE> print ( d [ s ] ) <NEWLINE>
import heapq <NEWLINE> from collections import defaultdict , deque <NEWLINE> from math import ceil , factorial , gcd <NEWLINE> import sys <NEWLINE> import bisect <NEWLINE> <NL> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> si = lambda : input ( ) . strip ( ) <NEWLINE> ii = lambda : int ( input ( ) ) <NEWLINE> mii = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> lmii = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> smii = lambda : sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> N = ii ( ) <NEWLINE> S = si ( ) <NEWLINE> <NL> r_cnt = S . count ( <STRING> ) <NEWLINE> g_cnt = S . count ( <STRING> ) <NEWLINE> b_cnt = S . count ( <STRING> ) <NEWLINE> <NL> ans = r_cnt * g_cnt * b_cnt <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for dist in range ( N ) : <NEWLINE> <INDENT> j = i + dist <NEWLINE> k = j + dist <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> k = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> k [ i ] = int ( s [ i - 1 ] ) <NEWLINE> <DEDENT> t = [ 0 ] * ( n + 1 ) <NEWLINE> t [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> t [ i ] = ( 10 * t [ i - 1 ] + k [ i ] ) % 2019 <NEWLINE> <NL> <DEDENT> p = 1 <NEWLINE> q = [ 0 ] * 448 <NEWLINE> for z in range ( 0 , 448 ) : <NEWLINE> <INDENT> q [ z ] = p % 2019 <NEWLINE> p = 10 * q [ z ] <NEWLINE> <NL> <DEDENT> d = [ 0 ] * n <NEWLINE> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> f = ( n - j ) % 448 <NEWLINE> d [ j - 1 ] = q [ f ] * t [ j ] % 2019 <NEWLINE> <DEDENT> ds = sorted ( d ) <NEWLINE> ct = 0 <NEWLINE> ans = 0 <NEWLINE> if ds [ 0 ] == 0 : <NEWLINE> <INDENT> ct = 1 <NEWLINE> ans = 1 <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if ds [ i + 1 ] == ds [ i ] : <NEWLINE> <INDENT> ct += 1 <NEWLINE> ans += ct <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ct = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = [ 0 , 0 , 0 ] <NEWLINE> Ans = 1 <NEWLINE> MOD = 1000000007 <NEWLINE> for a in A : <NEWLINE> <INDENT> ask = C . count ( a ) <NEWLINE> if ask == 0 : <NEWLINE> <INDENT> Ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> ind = C . index ( a ) <NEWLINE> C [ ind ] += 1 <NEWLINE> Ans = ( Ans * ask ) % MOD <NEWLINE> <DEDENT> print ( Ans ) <NEWLINE>
import sys , collections <NEWLINE> file = sys . stdin <NEWLINE> H , W = map ( int , file . readline ( ) . split ( ) ) <NEWLINE> C = [ list ( map ( int , i . split ( ) ) ) for i in file . readlines ( ) ] <NEWLINE> prev = [ 0 for i in range ( W ) ] <NEWLINE> def height ( C ) : <NEWLINE> <INDENT> global prev <NEWLINE> P = [ ] <NEWLINE> for i in range ( W ) : <NEWLINE> <INDENT> if C [ - 1 ] [ i ] == 1 : <NEWLINE> <INDENT> p = 0 <NEWLINE> <DEDENT> else : p = prev [ i ] + 1 <NEWLINE> P . append ( p ) <NEWLINE> <DEDENT> prev = P [ : ] <NEWLINE> return P <NEWLINE> <NL> <DEDENT> def square ( C ) : <NEWLINE> <INDENT> P = height ( C ) <NEWLINE> G = [ ] <NEWLINE> L = collections . deque ( ) <NEWLINE> for i , v in enumerate ( P ) : <NEWLINE> <INDENT> if not L : <NEWLINE> <INDENT> L . append ( ( i , v ) ) <NEWLINE> continue <NEWLINE> <DEDENT> if v > L [ - 1 ] [ 1 ] : <NEWLINE> <INDENT> L . append ( ( i , v ) ) <NEWLINE> <DEDENT> elif v < L [ - 1 ] [ 1 ] : <NEWLINE> <INDENT> k = i - 1 <NEWLINE> while L and v < L [ - 1 ] [ 1 ] : <NEWLINE> <INDENT> a = L . pop ( ) <NEWLINE> G . append ( ( k - a [ 0 ] + 1 ) * a [ 1 ] ) <NEWLINE> <DEDENT> L . append ( ( a [ 0 ] , v ) ) <NEWLINE> <DEDENT> <DEDENT> while L : <NEWLINE> <INDENT> a = L . pop ( ) <NEWLINE> G . append ( ( len ( P ) - a [ 0 ] ) * a [ 1 ] ) <NEWLINE> <DEDENT> return max ( G ) <NEWLINE> <NL> <DEDENT> def ans ( C ) : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> currentC = C [ : i + 1 ] <NEWLINE> ans . append ( square ( currentC ) ) <NEWLINE> <DEDENT> return str ( max ( ans ) ) <NEWLINE> <DEDENT> print ( ans ( C ) ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = { int ( input ( ) ) for _ in range ( m ) } <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x = dp [ i - 1 ] <NEWLINE> if i > 1 : <NEWLINE> <INDENT> x += dp [ i - 2 ] <NEWLINE> <DEDENT> dp [ i ] = x <NEWLINE> <DEDENT> ans = dp [ n ] % mod <NEWLINE> print ( ans ) <NEWLINE>
from itertools import permutations <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for P in permutations ( range ( N ) , N ) : <NEWLINE> <INDENT> if P [ 0 ] != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if P [ i + 1 ] not in G [ P [ i ] ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> table = [ ] <NEWLINE> sum_rows = [ 0 for i in range ( h ) ] <NEWLINE> sum_cols = [ 0 for i in range ( w ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> h_ , w_ = map ( int , input ( ) . split ( ) ) <NEWLINE> table . append ( ( h_ , w_ ) ) <NEWLINE> sum_rows [ h_ - 1 ] += 1 <NEWLINE> sum_cols [ w_ - 1 ] += 1 <NEWLINE> <NL> <DEDENT> r = max ( sum_rows ) <NEWLINE> c = max ( sum_cols ) <NEWLINE> ans_ = ( r + c ) <NEWLINE> count = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if ans_ == ( sum_rows [ table [ i ] [ 0 ] - 1 ] + sum_cols [ table [ i ] [ 1 ] - 1 ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if count == ( sum_rows . count ( r ) * sum_cols . count ( c ) ) : <NEWLINE> <INDENT> print ( ans_ - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans_ ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> j = 1 << i <NEWLINE> cnt = sum ( ( k & j ) >> i for k in a ) <NEWLINE> ans += ( cnt * ( n - cnt ) ) << i <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> men = { } <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> men [ i ] = 0 <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> men [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( men [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import sys <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ( ans > int ( 1e18 ) ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> if ans > int ( 1e18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
end = [ 1 , 1 , 1 , 1 , 1 ] <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> mp = [ [ 0 ] * 5 for _ in range ( 6000 ) ] <NEWLINE> height = [ 0 ] * 5 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d , p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> q -= 1 <NEWLINE> cnt += p <NEWLINE> if d == 1 : <NEWLINE> <INDENT> pos = max ( height [ q : q + p ] ) <NEWLINE> mp [ pos ] [ q : q + p ] = [ 1 ] * p <NEWLINE> if mp [ pos ] == end : <NEWLINE> <INDENT> cnt -= 5 <NEWLINE> mp . pop ( pos ) <NEWLINE> mp . append ( [ 0 ] * 5 ) <NEWLINE> for x in range ( 5 ) : <NEWLINE> <INDENT> for y in range ( i * 5 - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if mp [ y ] [ x ] == 1 : <NEWLINE> <INDENT> height [ x ] = y + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> height [ x ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> height [ q : q + p ] = [ pos + 1 ] * p <NEWLINE> <NL> <DEDENT> <DEDENT> if d == 2 : <NEWLINE> <INDENT> pop_flag = False <NEWLINE> pos = height [ q ] <NEWLINE> for y in range ( pos , pos + p ) : <NEWLINE> <INDENT> mp [ y ] [ q ] = 1 <NEWLINE> <DEDENT> for y in range ( pos + p - 1 , pos - 1 , - 1 ) : <NEWLINE> <INDENT> if mp [ y ] == end : <NEWLINE> <INDENT> cnt -= 5 <NEWLINE> mp . pop ( y ) <NEWLINE> mp . append ( [ 0 ] * 5 ) <NEWLINE> pop_flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> if pop_flag : <NEWLINE> <INDENT> for x in range ( 5 ) : <NEWLINE> <INDENT> for y in range ( i * 5 - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if mp [ y ] [ x ] == 1 : <NEWLINE> <INDENT> height [ x ] = y + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> height [ x ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> height [ q ] += p <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> row = [ N - 2 ] * ( N + 2 ) <NEWLINE> col = [ N - 2 ] * ( N + 2 ) <NEWLINE> ans = ( N - 2 ) ** 2 <NEWLINE> <NL> miRow = N <NEWLINE> miCol = N <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> q , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if q == 1 : <NEWLINE> <INDENT> for i in range ( x , miRow + 1 ) : <NEWLINE> <INDENT> row [ i ] = min ( row [ i ] , miCol - 2 ) <NEWLINE> <DEDENT> miRow = min ( x , miRow ) <NEWLINE> ans -= row [ x ] <NEWLINE> <NL> <DEDENT> if q == 2 : <NEWLINE> <INDENT> for i in range ( x , miCol + 1 ) : <NEWLINE> <INDENT> col [ i ] = min ( col [ i ] , miRow - 2 ) <NEWLINE> <DEDENT> miCol = min ( x , miCol ) <NEWLINE> ans -= col [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from itertools import combinations <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <COMMENT> <NEWLINE> to_index = lambda x : int ( x ) - 1 <COMMENT> <NEWLINE> print_list_in_2D = lambda x : print ( * x , sep = <STRING> ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> def input_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def map_int_input ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) ) <NEWLINE> <NL> <DEDENT> MII = map_int_input <NEWLINE> <NL> def MII_split ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def MII_to_index ( ) : <NEWLINE> <INDENT> return map ( to_index , input ( ) ) <NEWLINE> <NL> <DEDENT> def MII_split_to_index ( ) : <NEWLINE> <INDENT> return map ( to_index , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def list_int_inputs ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) ) ) <NEWLINE> <NL> <DEDENT> LII = list_int_inputs <NEWLINE> <NL> def LII_split ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def LII_2D ( rows_number ) : <NEWLINE> <INDENT> return [ LII ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> <DEDENT> def LII_split_2D ( rows_number ) : <NEWLINE> <INDENT> return [ LII_split ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> <DEDENT> N , K = MII_split ( ) <NEWLINE> <NL> count = 0 <NEWLINE> p_min_sum = 0 <NEWLINE> p_max_sum = 0 <NEWLINE> for num_nums in range ( K , N + 2 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if num_nums == K : <NEWLINE> <INDENT> p_min_sum = sum ( range ( num_nums ) ) <NEWLINE> p_max_sum = sum ( range ( N - num_nums + 1 , N + 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p_min_sum += num_nums - 1 <NEWLINE> p_max_sum += N - num_nums + 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> count += p_max_sum - p_min_sum + 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( int ( count % ( 1e9 + 7 ) ) ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in c : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= c [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) . strip ( ) ) <NEWLINE> A = [ int ( v ) for v in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> <NL> exist_in_input = [ 0 for _ in range ( 10 ** 6 + 1 ) ] <NEWLINE> if_can_divide = [ 0 for _ in range ( 10 ** 6 + 1 ) ] <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> exist_in_input [ a ] += 1 <NEWLINE> <NL> <DEDENT> counter = 0 <NEWLINE> for i in range ( 1 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if if_can_divide [ i ] == 1 or exist_in_input [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if exist_in_input [ i ] == 1 : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <NL> <DEDENT> for j in range ( 0 , 10 ** 6 + 1 , i ) : <NEWLINE> <INDENT> if_can_divide [ j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> <NL> if K % 2 == 1 and A [ - 1 ] < 0 : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> ans = ans * A [ N - ( i + 1 ) ] % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> l = 0 <NEWLINE> r = N - 1 <NEWLINE> if K % 2 == 1 : <NEWLINE> <INDENT> ans = ans * A [ r ] <NEWLINE> r -= 1 <NEWLINE> <NL> <DEDENT> for _ in range ( K // 2 ) : <NEWLINE> <INDENT> ml = A [ l ] * A [ l + 1 ] <NEWLINE> mr = A [ r ] * A [ r - 1 ] <NEWLINE> if ml > mr : <NEWLINE> <INDENT> ans = ans * ml % mod <NEWLINE> l += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * mr % mod <NEWLINE> r -= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a < b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a > b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> number = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> seki = 1 <NEWLINE> if 0 in number : <NEWLINE> <INDENT> seki = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in number : <NEWLINE> <INDENT> seki = seki * i <NEWLINE> if seki > 10 ** 18 : <NEWLINE> <INDENT> seki = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( seki ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> L [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , len ( L ) ) : <NEWLINE> <INDENT> print ( L [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> from collections import defaultdict <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( sorted ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> print ( sum ( P [ : k ] ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = { } <NEWLINE> R = { } <NEWLINE> for i in range ( 1 , len ( A ) + 1 ) : <NEWLINE> <INDENT> L [ str ( i + A [ i - 1 ] ) ] = L . get ( str ( i + A [ i - 1 ] ) , 0 ) + 1 <NEWLINE> R [ str ( i - A [ i - 1 ] ) ] = R . get ( str ( i - A [ i - 1 ] ) , 0 ) + 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if str ( i ) in L and str ( i ) in R : <NEWLINE> <INDENT> ans += L [ str ( i ) ] * R [ str ( i ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
room = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> <NL> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> room [ n [ 0 ] - 1 ] [ n [ 1 ] - 1 ] [ n [ 2 ] - 1 ] += n [ 3 ] <NEWLINE> <DEDENT> n = 0 <NEWLINE> for i in room : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( list ( map ( str , j ) ) ) ) <NEWLINE> if n == 2 or n == 5 or n == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> ans = 8 <NEWLINE> max = 599 <NEWLINE> min = 400 <NEWLINE> while True : <NEWLINE> <INDENT> if min <= x <= max : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max += 200 <NEWLINE> min += 200 <NEWLINE> ans -= 1 <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> def search ( a , b ) : <NEWLINE> <INDENT> na = len ( a ) <NEWLINE> nb = len ( b ) <NEWLINE> array = [ [ 0 ] * ( nb + 1 ) for _ in range ( na + 1 ) ] <NEWLINE> for i , x in enumerate ( a , 1 ) : <NEWLINE> <INDENT> prerow = array [ i - 1 ] <NEWLINE> row = array [ i ] <NEWLINE> for j , y in enumerate ( b , 1 ) : <NEWLINE> <INDENT> if x == y : <NEWLINE> <INDENT> row [ j ] = prerow [ j - 1 ] + 1 <NEWLINE> <DEDENT> elif prerow [ j ] < row [ j - 1 ] : <NEWLINE> <INDENT> row [ j ] = row [ j - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> row [ j ] = prerow [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return array [ - 1 ] [ - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> strs = [ list ( i ) for i in sys . stdin . read ( ) . splitlines ( ) ] <NEWLINE> result = [ search ( strs [ i * 2 ] , strs [ i * 2 + 1 ] ) for i in range ( n ) ] <NEWLINE> print ( * result , sep = <STRING> ) <NEWLINE> <NL>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> from functools import reduce <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> def is_ok ( arg ) : <NEWLINE> <INDENT> return a [ i ] [ j ] + a [ arg ] [ j ] >= 0 <NEWLINE> <NL> <DEDENT> def meguru_bisect ( ng , ok ) : <NEWLINE> <INDENT> while ( abs ( ok - ng ) > 1 ) : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if is_ok ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <DEDENT> n = INT ( ) <NEWLINE> a = [ [ 0 ] * 19 for i in range ( 19 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A = int ( float ( input ( ) ) * 10 ** 9 + 0.5 ) <NEWLINE> m2 = m5 = 0 <NEWLINE> while A % 2 == 0 : <NEWLINE> <INDENT> A //= 2 <NEWLINE> m2 += 1 <NEWLINE> <DEDENT> while A % 5 == 0 : <NEWLINE> <INDENT> A //= 5 <NEWLINE> m5 += 1 <NEWLINE> <DEDENT> m2 = min ( m2 , 18 ) <NEWLINE> m5 = min ( m5 , 18 ) <NEWLINE> a [ m2 ] [ m5 ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 19 ) : <NEWLINE> <INDENT> for j in range ( 19 ) : <NEWLINE> <INDENT> for k in range ( 19 ) : <NEWLINE> <INDENT> for l in range ( 19 ) : <NEWLINE> <INDENT> if i + k >= 18 and j + l >= 18 : <NEWLINE> <INDENT> if i == k and j == l : <NEWLINE> <INDENT> ans += a [ i ] [ j ] * ( a [ k ] [ l ] - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a [ i ] [ j ] * a [ k ] [ l ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans //= 2 <NEWLINE> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> adj = defaultdict ( set ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> adj [ a - 1 ] . add ( H [ b - 1 ] ) <NEWLINE> adj [ b - 1 ] . add ( H [ a - 1 ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> adj [ i ] . add ( - 1 ) <NEWLINE> if H [ i ] > max ( adj [ i ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> good_list = [ True ] * N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> <NL> if H_list [ A ] > H_list [ B ] : <NEWLINE> <INDENT> good_list [ B ] = False <NEWLINE> <DEDENT> elif H_list [ A ] < H_list [ B ] : <NEWLINE> <INDENT> good_list [ A ] = False <NEWLINE> <DEDENT> elif H_list [ A ] == H_list [ B ] : <NEWLINE> <INDENT> good_list [ A ] = False <NEWLINE> good_list [ B ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> ans = good_list . count ( True ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> was = [ ] <NEWLINE> tf = [ False ] * N <NEWLINE> place = 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> while tf [ place - 1 ] == False : <NEWLINE> <INDENT> if cnt < K : <NEWLINE> <INDENT> tf [ place - 1 ] = True <NEWLINE> was . append ( place ) <NEWLINE> place = A [ place - 1 ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( place ) <NEWLINE> break ; <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> loop = cnt - was . index ( place ) <NEWLINE> num = ( K - cnt ) % loop + was . index ( place ) <NEWLINE> print ( was [ num ] ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if i == 0 or i == h - 1 : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> * ( w - 2 ) ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> a1 = [ ] <NEWLINE> e = [ a , b ] <NEWLINE> f = [ c , d ] <NEWLINE> for i in e : <NEWLINE> <INDENT> for j in f : <NEWLINE> <INDENT> a1 . append ( i * j ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( a1 ) ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> temp = N <NEWLINE> arr = [ ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in range ( 2 , int ( - ( - N ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> sum = 0 <NEWLINE> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> p = arr [ i ] [ 1 ] <NEWLINE> q = 1 <NEWLINE> while p > 0 : <NEWLINE> <INDENT> p -= q <NEWLINE> if p >= 0 : <NEWLINE> <INDENT> sum += 1 <NEWLINE> q += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> height , width , target_count = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> count_by_height = defaultdict ( int ) <NEWLINE> count_by_width = defaultdict ( int ) <NEWLINE> bomb_locations = set ( ) <NEWLINE> for _ in range ( target_count ) : <NEWLINE> <INDENT> h , w = [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> count_by_height [ h ] += 1 <NEWLINE> count_by_width [ w ] += 1 <NEWLINE> bomb_locations . add ( ( h , w ) ) <NEWLINE> <DEDENT> max_h = max ( v for v in count_by_height . values ( ) ) <NEWLINE> max_w = max ( v for v in count_by_width . values ( ) ) <NEWLINE> max_h_index = [ i for i , x in count_by_height . items ( ) if x == max_h ] <NEWLINE> max_w_index = [ i for i , x in count_by_width . items ( ) if x == max_w ] <NEWLINE> no_cross = any ( ( h , w ) not in bomb_locations <NEWLINE> <INDENT> for h in max_h_index for w in max_w_index ) <NEWLINE> <DEDENT> return max_h + max_w - ( not no_cross ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 1 <NEWLINE> if ( 0 in num_list ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in num_list : <NEWLINE> <INDENT> result = result * i <NEWLINE> if ( result > 10 ** 18 ) : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
T = list ( map ( str , input ( ) ) ) <NEWLINE> count = 0 <NEWLINE> ans = [ ] <NEWLINE> <NL> <NL> <NL> <NL> for i in range ( 0 , len ( T ) ) : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( T [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans_ans = <STRING> . join ( ans ) ; <NEWLINE> <NL> print ( ans_ans ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> ans = [ 0 for i in range ( len ( S ) - len ( T ) + 1 ) ] <NEWLINE> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> cnt = len ( T ) <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if S [ i + j ] == T [ j ] : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> ans [ i ] = cnt <NEWLINE> <DEDENT> print ( min ( ans ) ) <NEWLINE>
import sys <NEWLINE> a = sys . stdin <NEWLINE> i = 1 <NEWLINE> for line in a : <NEWLINE> <INDENT> if ( int ( line ) == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( i , line ) , end = <STRING> ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def comb ( n , k , mod ) : <NEWLINE> <INDENT> if k > n - k : <NEWLINE> <INDENT> k = n - k <NEWLINE> <DEDENT> c = 1 <NEWLINE> for i in range ( n - k + 1 , n + 1 ) : <NEWLINE> <INDENT> c *= i <NEWLINE> c %= mod <NEWLINE> <DEDENT> d = 1 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> d *= i <NEWLINE> d %= mod <NEWLINE> <DEDENT> return ( c * pow ( d , mod - 2 , mod ) ) % mod <NEWLINE> <NL> <DEDENT> ans = pow ( 2 , n , mod ) - 1 - comb ( n , a , mod ) - comb ( n , b , mod ) <NEWLINE> print ( ans % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nums = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> <NL> res = 1 <NEWLINE> <NL> if 0 in nums : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> res = res * nums [ i ] <NEWLINE> if res <= 10 ** 18 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( stdinput ( ) ) <NEWLINE> <NL> st = [ None ] * ( 4 ** 12 ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> cmd , value = stdinput ( ) . split ( ) <NEWLINE> if cmd == <STRING> : <NEWLINE> <INDENT> st [ get_hash ( value ) ] = 1 <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> if st [ get_hash ( value ) ] == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> CODES = { <STRING> : 1 , <STRING> : 2 , <STRING> : 3 , <STRING> : 4 } <NEWLINE> def get_hash ( s ) : <NEWLINE> <INDENT> base = 1 <NEWLINE> h = 0 <NEWLINE> for c in s : <NEWLINE> <INDENT> code = CODES [ c ] <NEWLINE> h += code * base <NEWLINE> base *= 4 <NEWLINE> <DEDENT> return h <NEWLINE> <NL> <DEDENT> def stdinput ( ) : <NEWLINE> <INDENT> from sys import stdin <NEWLINE> return stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> p = gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( p , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class Lca : <NEWLINE> <INDENT> def __init__ ( self , E , root ) : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> self . root = root <NEWLINE> self . E = E <COMMENT> <NEWLINE> self . n = len ( E ) <COMMENT> <NEWLINE> self . logn = 1 <COMMENT> <NEWLINE> while self . n >= ( 1 << self . logn ) : <NEWLINE> <INDENT> self . logn += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> self . parent = [ [ - 1 ] * self . n for _ in range ( self . logn ) ] <NEWLINE> <NL> self . depth = [ 0 ] * self . n <NEWLINE> self . dfs ( root , - 1 , 0 ) <NEWLINE> for k in range ( self . logn - 1 ) : <NEWLINE> <INDENT> for v in range ( self . n ) : <NEWLINE> <INDENT> p_ = self . parent [ k ] [ v ] <NEWLINE> if p_ >= 0 : <NEWLINE> <INDENT> self . parent [ k + 1 ] [ v ] = self . parent [ k ] [ p_ ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def dfs ( self , v , p , dep ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . parent [ 0 ] [ v ] = p <NEWLINE> self . depth [ v ] = dep <NEWLINE> for e in self . E [ v ] : <NEWLINE> <INDENT> if e != p : <NEWLINE> <INDENT> self . dfs ( e , v , dep + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def get ( self , u , v ) : <NEWLINE> <INDENT> if self . depth [ u ] > self . depth [ v ] : <NEWLINE> <INDENT> u , v = v , u <COMMENT> <NEWLINE> <DEDENT> dep_diff = self . depth [ v ] - self . depth [ u ] <NEWLINE> for k in range ( self . logn ) : <NEWLINE> <INDENT> if dep_diff >> k & 1 : <NEWLINE> <INDENT> v = self . parent [ k ] [ v ] <NEWLINE> <DEDENT> <DEDENT> if u == v : <NEWLINE> <INDENT> return u <NEWLINE> <DEDENT> for k in range ( self . logn - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if self . parent [ k ] [ u ] != self . parent [ k ] [ v ] : <NEWLINE> <INDENT> u = self . parent [ k ] [ u ] <NEWLINE> v = self . parent [ k ] [ v ] <NEWLINE> <DEDENT> <DEDENT> return self . parent [ 0 ] [ u ] <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> E = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> kc = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = kc [ 0 ] <NEWLINE> for c in kc [ 1 : ] : <NEWLINE> <INDENT> E [ i ] . append ( c ) <NEWLINE> E [ c ] . append ( i ) <NEWLINE> <DEDENT> <DEDENT> lca = Lca ( E , 0 ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( lca . get ( u , v ) ) <NEWLINE> <NL> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N % 2 == 1 : <NEWLINE> <INDENT> for i in range ( M ) : <NEWLINE> <INDENT> print ( i + 1 , N - i - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s = set ( ) <NEWLINE> t = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = i + 1 , N - i - t <NEWLINE> if ( b - a ) in s or ( a + N - b ) in s or b - a == a + N - b : <NEWLINE> <INDENT> t += 1 <NEWLINE> b = N - i - t <NEWLINE> <DEDENT> print ( a , b ) <NEWLINE> s . add ( b - a ) <NEWLINE> s . add ( N + a - b ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import queue <NEWLINE> import numpy as np <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> maze = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> dir4 = [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] <NEWLINE> <NL> <NL> def solveMaze ( s ) : <NEWLINE> <INDENT> q = queue . Queue ( ) <NEWLINE> q . put ( [ s [ 0 ] , s [ 1 ] , 0 ] ) <NEWLINE> times = [ [ 999999999 for j in range ( W ) ] for i in range ( H ) ] <NEWLINE> tmpAns = 0 <NEWLINE> times [ s [ 0 ] ] [ s [ 1 ] ] = 0 <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> now = q . get ( ) <NEWLINE> tmpAns = max ( tmpAns , now [ 2 ] ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> nextH = now [ 0 ] + int ( dir4 [ i ] [ 0 ] ) <NEWLINE> nextW = now [ 1 ] + int ( dir4 [ i ] [ 1 ] ) <NEWLINE> nextTime = now [ 2 ] + 1 <NEWLINE> <NL> if nextH < 0 or nextH >= H or nextW < 0 or nextW >= W or maze [ nextH ] [ nextW ] == <STRING> or times [ nextH ] [ nextW ] <= nextTime : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> times [ nextH ] [ nextW ] = nextTime <NEWLINE> q . put ( [ nextH , nextW , nextTime ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return tmpAns <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for sH in range ( H ) : <NEWLINE> <INDENT> for sW in range ( W ) : <NEWLINE> <INDENT> if maze [ sH ] [ sW ] == <STRING> : <NEWLINE> <INDENT> ans = max ( ans , solveMaze ( [ sH , sW ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL>
def f ( n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while n : <NEWLINE> <INDENT> buf = n <NEWLINE> pc = 0 <NEWLINE> while buf : <NEWLINE> <INDENT> pc += buf % 2 <NEWLINE> buf //= 2 <NEWLINE> <DEDENT> n = n % pc <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> v1 , v2 = 0 , 0 <NEWLINE> cnt = X . count ( <STRING> ) <NEWLINE> for i , j in enumerate ( X [ : : - 1 ] ) : <NEWLINE> <INDENT> if j == <STRING> : <NEWLINE> <INDENT> v1 += pow ( 2 , i , cnt + 1 ) <NEWLINE> v1 %= ( cnt + 1 ) <NEWLINE> <NL> if cnt > 1 : <NEWLINE> <INDENT> v2 += pow ( 2 , i , cnt - 1 ) <NEWLINE> v2 %= ( cnt - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> p = N - i - 1 <NEWLINE> buf = 0 <NEWLINE> c2 = 0 <NEWLINE> if X [ i ] == <STRING> : <NEWLINE> <INDENT> c2 = cnt + 1 <NEWLINE> buf = ( v1 + pow ( 2 , p , c2 ) ) % c2 <NEWLINE> print ( f ( buf ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c2 = cnt - 1 <NEWLINE> if c2 > 0 : <NEWLINE> <INDENT> buf = ( v2 - pow ( 2 , p , c2 ) ) % c2 <NEWLINE> print ( f ( buf ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> m = p [ 0 ] <NEWLINE> <NL> for i in p : <NEWLINE> <INDENT> m = min ( m , i ) <NEWLINE> if m == i : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( h ) : <NEWLINE> <INDENT> for i in range ( w ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> dp = dict ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a_p = a [ i ] + i + 1 <NEWLINE> a_m = i + 1 - a [ i ] <NEWLINE> if a_p in dp : <NEWLINE> <INDENT> dp [ a_p ] = dp [ a_p ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ a_p ] = 1 <NEWLINE> <DEDENT> if a_m in dp : <NEWLINE> <INDENT> ans = ans + dp [ a_m ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> dp = [ - 1 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = 1 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> dp [ a ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if dp [ i ] == - 1 : <NEWLINE> <INDENT> if i <= 2 : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + 1 <NEWLINE> <DEDENT> elif i >= 3 : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( reversed ( b ) ) <NEWLINE> bad = next ( ( x for x , y in zip ( a , b ) if x == y ) , None ) <NEWLINE> if bad is None : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , b ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l_1 = sum ( 1 for x , y in zip ( a , b ) if x < bad < y ) <NEWLINE> l_2 = sum ( 1 for x , y in zip ( a , b ) if x < y and bad in ( x , y ) ) <NEWLINE> l_3 = sum ( 1 for x , y in zip ( a , b ) if x == y ) <NEWLINE> l_4 = sum ( 1 for x , y in zip ( a , b ) if x > y and bad in ( x , y ) ) <NEWLINE> l_5 = sum ( 1 for x , y in zip ( a , b ) if x > bad > y and x != bad ) <NEWLINE> if l_3 > l_1 + l_5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> good_part = b [ : l_1 ] + b [ l_1 + l_2 + l_3 + l_4 : ] <NEWLINE> bad_part = b [ l_1 + l_2 : l_1 + l_2 + l_3 ] <NEWLINE> b [ l_1 + l_2 : l_1 + l_2 + l_3 ] = good_part [ : l_3 ] <NEWLINE> good_part [ : l_3 ] = bad_part <NEWLINE> b [ : l_1 ] = good_part [ : l_1 ] <NEWLINE> b [ l_1 + l_2 + l_3 + l_4 : ] = good_part [ l_1 : ] <NEWLINE> assert all ( x != y for x , y in zip ( a , b ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , b ) ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from itertools import combinations_with_replacement <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ _ for _ in range ( 1 , M + 1 ) ] <NEWLINE> y = list ( combinations_with_replacement ( x , N ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> ans = [ ] <NEWLINE> z = 0 <NEWLINE> for i in range ( len ( y ) ) : <NEWLINE> <INDENT> for j in range ( Q ) : <NEWLINE> <INDENT> if y [ i ] [ l [ j ] [ 1 ] - 1 ] - y [ i ] [ l [ j ] [ 0 ] - 1 ] == l [ j ] [ 2 ] : <NEWLINE> <INDENT> z += l [ j ] [ 3 ] <NEWLINE> <DEDENT> ans . append ( z ) <NEWLINE> <DEDENT> z = 0 <NEWLINE> <DEDENT> print ( max ( ans ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> r_flag = False <NEWLINE> ans = deque ( ( S ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> Qu = input ( ) . split ( ) <NEWLINE> if Qu [ 0 ] == <STRING> : <NEWLINE> <INDENT> r_flag = not r_flag <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if Qu [ 1 ] == <STRING> : <NEWLINE> <INDENT> if r_flag == True : <NEWLINE> <INDENT> ans . append ( Qu [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . appendleft ( Qu [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if r_flag == True : <NEWLINE> <INDENT> ans . appendleft ( Qu [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( Qu [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = list ( ans ) <NEWLINE> print ( <STRING> . join ( ans ) if r_flag == False else <STRING> . join ( ans [ : : - 1 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> btn = 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> btn = a [ btn - 1 ] <NEWLINE> cnt += 1 <NEWLINE> if btn == 2 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> break <NEWLINE> <DEDENT> if cnt > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> <NL> def main ( N , A ) : <NEWLINE> <INDENT> B = [ 0 ] <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> T = A [ i ] + B [ i ] <NEWLINE> <NL> B . append ( T ) <NEWLINE> <DEDENT> c = collections . Counter ( B ) <NEWLINE> <NL> for i in range ( len ( c ) ) : <NEWLINE> <INDENT> k , v = c . popitem ( ) <NEWLINE> for z in range ( v ) : <NEWLINE> <INDENT> count += z <NEWLINE> <NL> <DEDENT> <DEDENT> return print ( count ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> main ( N , A ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> class Unreachable ( Exception ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <NL> <DEDENT> class SetManager : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . data = list ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> self . data . append ( ( i , { i } ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def ref ( self , i ) : <NEWLINE> <INDENT> return self . data [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> def set ( self , i , value ) : <NEWLINE> <INDENT> self . data [ i ] = ( i , value ) <NEWLINE> <NL> <DEDENT> def find_set ( self , i ) : <NEWLINE> <INDENT> value = self . ref ( i ) <NEWLINE> if isinstance ( value , set ) : <NEWLINE> <INDENT> return self . data [ i ] <NEWLINE> <DEDENT> elif isinstance ( value , int ) : <NEWLINE> <INDENT> result = self . find_set ( value ) <NEWLINE> self . set ( i , result [ 0 ] ) <NEWLINE> return result <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Unreachable <NEWLINE> <NL> <DEDENT> <DEDENT> def run ( self , command ) : <NEWLINE> <INDENT> com , x , y = command <NEWLINE> if com == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> i , setx = self . find_set ( x ) <NEWLINE> j , sety = self . find_set ( y ) <NEWLINE> if i != j : <NEWLINE> <INDENT> new_set = setx | sety <NEWLINE> self . set ( i , new_set ) <NEWLINE> self . set ( j , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif com == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> if y in self . find_set ( x ) [ 1 ] : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> raise Unreachable <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , q = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> manager = SetManager ( n ) <NEWLINE> <NL> commands = list ( ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> com , x , y = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> commands . append ( ( com , x , y ) ) <NEWLINE> <NL> <DEDENT> for command in commands : <NEWLINE> <INDENT> manager . run ( command ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> <NL> num_R = c . count ( <STRING> ) <NEWLINE> <NL> print ( c [ : num_R ] . count ( <STRING> ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( int ( input ( ) ) for i in range ( m ) ) <NEWLINE> x = ( 10 ** 9 ) + 7 <NEWLINE> <NL> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if 1 not in a : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] += dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( dp [ - 1 ] % x ) <NEWLINE>
N , K = map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) <NEWLINE> As = list ( map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> visited = set ( ) <NEWLINE> visited_list = [ ] <NEWLINE> index = 0 <NEWLINE> visited . add ( index ) <NEWLINE> visited_list . append ( 0 ) <NEWLINE> count = 0 <NEWLINE> flag = False <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> index = As [ index ] - 1 <NEWLINE> count += 1 <NEWLINE> if index in visited : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> visited . add ( index ) <NEWLINE> visited_list . append ( index ) <NEWLINE> <NL> <DEDENT> temp_index = visited_list . index ( index ) <NEWLINE> K -= count <NEWLINE> count = count - temp_index <NEWLINE> <NL> if flag : <NEWLINE> <INDENT> K %= count <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> index = As [ index ] - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( index + 1 ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a <= k : <NEWLINE> <INDENT> k -= a <NEWLINE> a = 0 <NEWLINE> if b <= k : <NEWLINE> <INDENT> b = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b -= k <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a -= k <NEWLINE> <NL> <DEDENT> print ( a , b ) <NEWLINE>
H , W , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> A = list ( ) <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w , a in enumerate ( map ( int , input ( ) . split ( ) ) ) : <NEWLINE> <INDENT> A . append ( [ a , h , w ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> A = sorted ( A , key = lambda x : x [ 0 ] ) <NEWLINE> <NL> B = [ 0 ] * ( H * W ) <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> while i + D < W * H : <NEWLINE> <INDENT> B [ i + D ] = B [ i ] + abs ( A [ i ] [ 1 ] - A [ i + D ] [ 1 ] ) + abs ( A [ i ] [ 2 ] - A [ i + D ] [ 2 ] ) <NEWLINE> i += D <NEWLINE> <NL> <DEDENT> <DEDENT> for q in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( B [ ~ - r ] - B [ ~ - l ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> v = [ ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> v . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> n_prime = 0 <NEWLINE> for v_ in v : <NEWLINE> <INDENT> isprime = True <NEWLINE> <NL> if v_ <= 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for i in range ( 1 + int ( math . sqrt ( v_ ) ) ) : <NEWLINE> <INDENT> if i <= 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if v_ % i == 0 : <NEWLINE> <INDENT> isprime = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> n_prime = n_prime + isprime <NEWLINE> <NL> <DEDENT> print ( n_prime ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for p , n in zip ( a , a [ k : ] ) : <NEWLINE> <INDENT> if p < n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def bubbleSort ( N , A ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> count = 0 <NEWLINE> while flag != 0 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for i in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if A [ i ] < A [ i - 1 ] : <NEWLINE> <INDENT> k = A [ i ] <NEWLINE> A [ i ] = A [ i - 1 ] <NEWLINE> A [ i - 1 ] = k <NEWLINE> flag = 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bubbleSort ( n , a ) <NEWLINE>
nums = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> nums . sort ( ) <NEWLINE> res = <STRING> . join ( [ str ( n ) for n in nums ] ) <NEWLINE> print ( res ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i1 in range ( min ( k + 1 , s + 1 ) ) : <NEWLINE> <INDENT> for i2 in range ( 0 , min ( k + 1 , s - i1 + 1 ) ) : <NEWLINE> <INDENT> if s - ( i1 + i2 ) <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> B = [ A [ i ] for i in range ( N ) if i % 2 == 0 ] <NEWLINE> C = [ A [ ( N - i - 1 ) ] for i in range ( N ) if ( N - i - 1 ) % 2 == 1 ] <NEWLINE> print ( * C + B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = [ A [ i ] for i in range ( N ) if i % 2 == 1 ] <NEWLINE> C = [ A [ ( N - i - 1 ) ] for i in range ( N ) if ( N - i - 1 ) % 2 == 0 ] <NEWLINE> print ( * C + B ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> <NL> r_cnt = S . count ( <STRING> ) <NEWLINE> g_cnt = S . count ( <STRING> ) <NEWLINE> b_cnt = S . count ( <STRING> ) <NEWLINE> <NL> ans = r_cnt * g_cnt * b_cnt <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for d in range ( 1 , N ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= N : break <NEWLINE> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> s += <STRING> <NEWLINE> ans = <STRING> <NEWLINE> lst = [ ] <NEWLINE> for ss in s : <NEWLINE> <INDENT> if ss in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> ans += ss <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst . append ( len ( ans ) ) <NEWLINE> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( max ( lst ) ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> <NL> def get_gcd ( a , b , c ) : <NEWLINE> <INDENT> min_ab = min ( a , b ) <NEWLINE> max_ab = max ( a , b ) <NEWLINE> amari = max_ab % min_ab <NEWLINE> if amari == 0 : <NEWLINE> <INDENT> gcd1 = min_ab <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = min_ab <NEWLINE> y = amari <NEWLINE> while y != 0 : <NEWLINE> <INDENT> amari = x % y <NEWLINE> if amari == 0 : <NEWLINE> <INDENT> gcd1 = y <NEWLINE> break <NEWLINE> <DEDENT> x = y <NEWLINE> y = amari <NEWLINE> <DEDENT> <DEDENT> min_2 = min ( c , gcd1 ) <NEWLINE> max_2 = max ( c , gcd1 ) <NEWLINE> amari = max_2 % min_2 <NEWLINE> if amari == 0 : <NEWLINE> <INDENT> gcd2 = min_2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = min_2 <NEWLINE> y = amari <NEWLINE> while y != 0 : <NEWLINE> <INDENT> amari = x % y <NEWLINE> if amari == 0 : <NEWLINE> <INDENT> gcd2 = y <NEWLINE> break <NEWLINE> <DEDENT> x = y <NEWLINE> y = amari <NEWLINE> <NL> <DEDENT> <DEDENT> return gcd2 <NEWLINE> <NL> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , k + 1 ) : <NEWLINE> <INDENT> if b == a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for c in range ( b + 1 , k + 1 ) : <NEWLINE> <INDENT> if c == a or c == b : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += get_gcd ( a , b , c ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> b = a <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if c == a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += get_gcd ( a , b , c ) * 3 <NEWLINE> <NL> <DEDENT> <DEDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> b = a <NEWLINE> c = a <NEWLINE> ans += get_gcd ( a , b , c ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import re <NEWLINE> S = input ( ) <NEWLINE> print ( 2 * min ( S . count ( <STRING> ) , S . count ( <STRING> ) ) ) <NEWLINE>
data = { } <NEWLINE> total = 0 <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> for a in input ( ) . split ( ) : <NEWLINE> <INDENT> a = int ( a ) <NEWLINE> data [ a ] = data . get ( a , 0 ) + 1 <NEWLINE> total += a <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> diff = c - b <NEWLINE> count = data . get ( b ) <NEWLINE> if count : <NEWLINE> <INDENT> data [ c ] = data . get ( c , 0 ) + data . pop ( b ) <NEWLINE> total += diff * count <NEWLINE> <DEDENT> print ( total ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if m == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> MOD = pow ( 10 , 9 ) + 7 <NEWLINE> <NL> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def make_fact_list ( n , MOD ) : <NEWLINE> <COMMENT> <NL> <INDENT> fact = [ 0 ] * ( n + 1 ) <NEWLINE> inv = [ 0 ] * ( n + 1 ) <NEWLINE> factinv = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> fact [ 0 ] = fact [ 1 ] = 1 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> factinv [ 0 ] = factinv [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> fact [ i ] = fact [ i - 1 ] * i % MOD <NEWLINE> inv [ i ] = MOD - ( ( inv [ MOD % i ] * ( MOD // i ) ) % MOD ) <NEWLINE> factinv [ i ] = factinv [ i - 1 ] * inv [ i ] % MOD <NEWLINE> <NL> <DEDENT> return fact , factinv <NEWLINE> <NL> <DEDENT> def cbn ( n , k , MOD , fact = [ ] , factinv = [ ] ) : <NEWLINE> <INDENT> if len ( fact ) == 0 and len ( factinv ) == 0 : <NEWLINE> <INDENT> fact , factinv = make_fact_list ( n , MOD ) <NEWLINE> <DEDENT> return fact [ n ] * factinv [ n - k ] * factinv [ k ] % MOD <NEWLINE> <NL> <NL> <DEDENT> d = Counter ( prime_factorize ( m ) ) . most_common ( ) <NEWLINE> <NL> l = d [ 0 ] [ 1 ] + n <NEWLINE> <NL> fact , factinv = make_fact_list ( l , MOD ) <NEWLINE> <NL> a = 1 <NEWLINE> <NL> for k , v in d : <NEWLINE> <INDENT> a *= cbn ( v + n - 1 , v , MOD , fact = fact , factinv = factinv ) % MOD <NEWLINE> <NL> <DEDENT> print ( a % MOD ) <NEWLINE> <DEDENT>
from heapq import * <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> p2D = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> def II ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def SI ( ) : return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> for _ in range ( II ( ) ) : <NEWLINE> <INDENT> n = II ( ) <NEWLINE> ff = [ ] <NEWLINE> bb = [ ] <NEWLINE> ans = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> k , l , r = MI ( ) <NEWLINE> if l > r : ff . append ( ( k , l , r ) ) <NEWLINE> elif l < r : bb . append ( ( n - k , l , r ) ) <NEWLINE> else : ans += r <NEWLINE> <NL> <DEDENT> ff . sort ( ) <NEWLINE> hp = [ ] <NEWLINE> for i , ( k , l , r ) in enumerate ( ff ) : <NEWLINE> <INDENT> heappush ( hp , l - r ) <NEWLINE> ans += l <NEWLINE> if i + 1 < len ( ff ) and ff [ i + 1 ] [ 0 ] == k : continue <NEWLINE> while len ( hp ) > k : <NEWLINE> <INDENT> d = heappop ( hp ) <NEWLINE> ans -= d <NEWLINE> <NL> <DEDENT> <DEDENT> bb . sort ( ) <NEWLINE> hp = [ ] <NEWLINE> for i , ( k , l , r ) in enumerate ( bb ) : <NEWLINE> <INDENT> heappush ( hp , r - l ) <NEWLINE> ans += r <NEWLINE> if i + 1 < len ( bb ) and bb [ i + 1 ] [ 0 ] == k : continue <NEWLINE> while len ( hp ) > k : <NEWLINE> <INDENT> d = heappop ( hp ) <NEWLINE> ans -= d <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . unite ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for r in uf . roots ( ) : <NEWLINE> <INDENT> s = uf . size ( r ) <NEWLINE> ans = max ( ans , s ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 200000000 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> graph1 = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> graph2 = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> reached = [ 0 ] * ( n + 1 ) <NEWLINE> def main ( ) : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph1 [ a ] . append ( b ) <NEWLINE> graph2 [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ p ] += x <NEWLINE> <DEDENT> dfs ( 1 ) <NEWLINE> print ( <STRING> . join ( [ str ( i ) for i in ans [ 1 : ] ] ) ) <NEWLINE> <NL> <DEDENT> def dfs ( i ) : <NEWLINE> <INDENT> if reached [ i ] == 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> reached [ i ] = 1 <NEWLINE> for g in graph1 [ i ] , graph2 [ i ] : <NEWLINE> <INDENT> for j in g : <NEWLINE> <INDENT> if reached [ j ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ j ] += ans [ i ] <NEWLINE> dfs ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> _ = int ( input ( ) ) <NEWLINE> a = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> res ^= i <NEWLINE> <DEDENT> ans = tuple ( res ^ i for i in a ) <NEWLINE> print ( * ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> <NL> import sys <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> c = 1 <NEWLINE> if a . count ( 0 ) >= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for k in range ( n ) : <NEWLINE> <NL> <INDENT> c *= int ( a [ k ] ) <NEWLINE> <NL> if c > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> gcds = [ [ 0 for i in range ( k ) ] for i in range ( k ) ] <NEWLINE> for p in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for q in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gcds [ p - 1 ] [ q - 1 ] = math . gcd ( p , q ) <NEWLINE> for r in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( gcds [ p - 1 ] [ q - 1 ] , r ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = ( n * ( n - 1 ) ) // 2 <NEWLINE> print ( s ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> for i in range ( - 120 , 120 ) : <NEWLINE> <INDENT> for l in range ( - 120 , 120 ) : <NEWLINE> <INDENT> g = i ** 5 <NEWLINE> g -= l ** 5 <NEWLINE> if g == x : <NEWLINE> <INDENT> print ( <STRING> . format ( i , l ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def pre_cmb ( N , MOD ) : <NEWLINE> <INDENT> FACT = [ 1 , 1 ] <COMMENT> <NEWLINE> INV = [ 0 , 1 ] <COMMENT> <NEWLINE> FACTINV = [ 1 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> FACT . append ( ( FACT [ - 1 ] * i ) % MOD ) <NEWLINE> INV . append ( pow ( i , MOD - 2 , MOD ) ) <NEWLINE> FACTINV . append ( ( FACTINV [ - 1 ] * INV [ - 1 ] ) % MOD ) <NEWLINE> <DEDENT> PRELIST = FACT , FACTINV <NEWLINE> return PRELIST <NEWLINE> <NL> <NL> <DEDENT> def cmb ( N , R , MOD , PRELIST ) : <NEWLINE> <INDENT> FACT , FACTINV = PRELIST <NEWLINE> if ( R < 0 ) or ( N < R ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> R = min ( R , N - R ) <NEWLINE> return FACT [ N ] * FACTINV [ R ] * FACTINV [ N - R ] % MOD <NEWLINE> <NL> <NL> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> <NL> prelist = pre_cmb ( n , mod ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> cnt += ( m * pow ( m - 1 , n - i - 1 , mod ) * cmb ( n - 1 , i , mod , prelist ) ) % mod <NEWLINE> <NL> <DEDENT> print ( cnt % mod ) <NEWLINE>
<COMMENT> <NL> import heapq <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> item_no , discount_no = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> prices = [ int ( x ) * - 1 for x in input ( ) . split ( ) ] <NEWLINE> heapq . heapify ( prices ) <NEWLINE> <NL> for _ in range ( discount_no ) : <NEWLINE> <INDENT> current_max = heapq . heappop ( prices ) <NEWLINE> current_max = current_max * - 1 // 2 * - 1 <NEWLINE> heapq . heappush ( prices , current_max ) <NEWLINE> <NL> <DEDENT> print ( - sum ( prices ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> input ( ) <NEWLINE> S = input ( ) . split ( ) <NEWLINE> input ( ) <NEWLINE> T = input ( ) . split ( ) <NEWLINE> print ( len ( set ( S ) & set ( T ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> now = 1 <NEWLINE> arr = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , 10 ** 6 ) : <NEWLINE> <INDENT> now = a [ now - 1 ] <NEWLINE> if i == k : <NEWLINE> <INDENT> print ( now ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> if arr [ now ] != 0 : <NEWLINE> <INDENT> first = arr [ now ] <NEWLINE> break <NEWLINE> <DEDENT> arr [ now ] = i <NEWLINE> <COMMENT> <NL> <DEDENT> cycle = max ( arr ) - first + 1 <NEWLINE> <COMMENT> <NL> mod = ( k - first ) % cycle <NEWLINE> <COMMENT> <NL> ans = arr . index ( first + mod ) <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> n , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> d . sort ( ) <NEWLINE> inf = n <NEWLINE> <NL> dp = [ [ inf for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] <NEWLINE> <NL> <COMMENT> <NL> for j in range ( m + 1 ) : <NEWLINE> <INDENT> dp [ 0 ] [ j ] = 0 <NEWLINE> <NL> <DEDENT> for j in range ( m - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> for i in range ( n + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if math . floor ( i / d [ j ] ) >= 1 : <NEWLINE> <INDENT> k = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = 0 <NEWLINE> <DEDENT> r = k * d [ j ] <NEWLINE> <COMMENT> <NL> dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ j + 1 ] , dp [ i - r ] [ j ] + k ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( dp [ n ] [ 0 ] ) <NEWLINE> <NL>
while True : <NEWLINE> <INDENT> h , w = input ( ) . split ( ) <NEWLINE> h = int ( h ) <NEWLINE> w = int ( w ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( h ) : <NEWLINE> <INDENT> out = <STRING> <NEWLINE> for i in range ( w ) : <NEWLINE> <INDENT> out += <STRING> <NEWLINE> <DEDENT> print ( out ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x0 = n <NEWLINE> t = n // k + 1 <NEWLINE> print ( min ( n % k , t * k - n ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> max_value = - 10 ** 9 <NEWLINE> min_value = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> r = int ( input ( ) ) <NEWLINE> max_value = max ( max_value , r - min_value ) <NEWLINE> min_value = min ( min_value , r ) <NEWLINE> <NL> <DEDENT> print ( max_value ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = sum ( a ) <NEWLINE> score = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> b -= a [ i ] <NEWLINE> score += a [ i ] * b <NEWLINE> <NL> <DEDENT> print ( score % ( 10 ** 9 + 7 ) ) <NEWLINE>
import math <NEWLINE> X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if K * D < abs ( X ) : <NEWLINE> <INDENT> ans = abs ( X ) - K * D <NEWLINE> <DEDENT> elif ( K - math . floor ( abs ( X ) / D ) ) % 2 == 0 : <NEWLINE> <INDENT> ans = abs ( X ) - ( math . floor ( abs ( X ) / D ) ) * D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = abs ( X ) - ( math . floor ( abs ( X ) / D ) ) * D - D <NEWLINE> <NL> <DEDENT> print ( abs ( int ( ans ) ) ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> koa = 0 <NEWLINE> if A < K : <NEWLINE> <INDENT> koa = A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> koa = K <NEWLINE> <DEDENT> kob = 0 <NEWLINE> if B < K - koa : <NEWLINE> <INDENT> kob = B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kob = K - koa <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> sum = koa + 0 * kob + ( K - ( koa + kob ) ) * - 1 <NEWLINE> print ( sum ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if n >= b : <NEWLINE> <INDENT> ans = ( a * ( b - 1 ) ) // b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( a * n ) // b <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = g = b = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> x = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k < n and s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - x ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = set ( ) <NEWLINE> count = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> S . add ( s ) <NEWLINE> <DEDENT> print ( len ( S ) ) <NEWLINE>
a , b , c , k = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if a + b >= k : <NEWLINE> <INDENT> print ( min ( k , a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - k + a + b ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> m = input ( ) <NEWLINE> maxr = m . count ( <STRING> ) <NEWLINE> maxw = m . count ( <STRING> ) <NEWLINE> <NL> min_move = len ( m ) <NEWLINE> max_r = m . count ( <STRING> ) <NEWLINE> max_w = m . count ( <STRING> ) <NEWLINE> right = 0 <NEWLINE> left = 0 <NEWLINE> for i in range ( len ( m ) ) : <NEWLINE> <INDENT> if m [ i ] == <STRING> : <NEWLINE> <INDENT> left += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_r -= 1 <NEWLINE> <DEDENT> if max ( left , max_r ) < min_move : <NEWLINE> <INDENT> min_move = max ( left , max_r ) <NEWLINE> <DEDENT> <DEDENT> if maxw == 0 or maxr == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min_move ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> a = 2 <NEWLINE> b = 0 <NEWLINE> A = [ ] <NEWLINE> A . append ( 1 ** 5 - x ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if ( a + 1 ) ** 5 - a ** 5 > 10 ** 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> A . append ( a ** 5 - x ) <NEWLINE> a = a + 1 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> if b ** 5 in A : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif - b ** 5 in A : <NEWLINE> <INDENT> b = - b <NEWLINE> break <NEWLINE> <DEDENT> b = b + 1 <NEWLINE> <NL> <DEDENT> a = int ( ( x + b ** 5 ) ** 0.2 ) <NEWLINE> <NL> print ( a , b ) <NEWLINE>
s = input ( ) <NEWLINE> zero = s . count ( <STRING> ) <NEWLINE> one = s . count ( <STRING> ) <NEWLINE> print ( len ( s ) - abs ( zero - one ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
c = [ 0 ] * 3 <NEWLINE> c_max = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> c [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c_max = max ( c_max , max ( c [ i ] ) ) <NEWLINE> <DEDENT> c_max += 1 <NEWLINE> for a1 in range ( c_max ) : <NEWLINE> <INDENT> b1 = c [ 0 ] [ 0 ] - a1 <NEWLINE> b2 = c [ 0 ] [ 1 ] - a1 <NEWLINE> b3 = c [ 0 ] [ 2 ] - a1 <NEWLINE> a2 = c [ 1 ] [ 0 ] - b1 <NEWLINE> a3 = c [ 2 ] [ 0 ] - b1 <NEWLINE> if a1 + b1 == c [ 0 ] [ 0 ] and a1 + b2 == c [ 0 ] [ 1 ] and a1 + b3 == c [ 0 ] [ 2 ] and a2 + b1 == c [ 1 ] [ 0 ] and a2 + b2 == c [ 1 ] [ 1 ] and a2 + b3 == c [ 1 ] [ 2 ] and a3 + b1 == c [ 2 ] [ 0 ] and a3 + b2 == c [ 2 ] [ 1 ] and a3 + b3 == c [ 2 ] [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import math <NEWLINE> t = float ( input ( ) ) <NEWLINE> a = math . pi * t ** 2 <NEWLINE> b = 2 * t * math . pi <NEWLINE> print ( str ( <STRING> . format ( a ) ) + <STRING> + <STRING> . format ( b ) ) <NEWLINE>
<COMMENT> <NL> from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = Counter ( A ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> ans = sum ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += ( c - b ) * d [ b ] <NEWLINE> d [ c ] += d [ b ] <NEWLINE> d [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_a = [ 0 ] <NEWLINE> sum_b = [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , len ( A ) + 1 ) : <NEWLINE> <INDENT> sum_a . append ( sum_a [ i - 1 ] + A [ i - 1 ] ) <NEWLINE> <DEDENT> for i in range ( 1 , len ( B ) + 1 ) : <NEWLINE> <INDENT> sum_b . append ( sum_b [ i - 1 ] + B [ i - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> j = len ( sum_b ) - 1 <NEWLINE> for i in range ( len ( sum_a ) ) : <NEWLINE> <INDENT> if sum_a [ i ] > K : break <NEWLINE> while ( sum_b [ j ] + sum_a [ i ] > K ) : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> [ H , W , M ] = map ( int , input ( ) . split ( ) ) <NEWLINE> colsum = np . zeros ( W + 1 ) <NEWLINE> rowsum = np . zeros ( H + 1 ) <NEWLINE> bombs = [ ] <NEWLINE> rowbombs = [ set ( ) for i in range ( H + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> [ h , w ] = map ( int , input ( ) . split ( ) ) <NEWLINE> rowsum [ h ] += 1 <NEWLINE> colsum [ w ] += 1 <NEWLINE> bombs . append ( [ h , w ] ) <NEWLINE> rowbombs [ h ] . add ( w ) <NEWLINE> <NL> <DEDENT> maxcol = max ( colsum ) <NEWLINE> maxrow = max ( rowsum ) <NEWLINE> <NL> colchk = np . where ( colsum == maxcol ) <NEWLINE> rowchk = np . where ( rowsum == maxrow ) <NEWLINE> <NL> for i in range ( len ( rowchk [ 0 ] ) ) : <NEWLINE> <INDENT> for j in range ( len ( colchk [ 0 ] ) ) : <NEWLINE> <INDENT> if colchk [ 0 ] [ j ] not in rowbombs [ rowchk [ 0 ] [ i ] ] : <NEWLINE> <INDENT> print ( int ( max ( colsum ) + max ( rowsum ) ) ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( int ( max ( colsum ) + max ( rowsum ) ) - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( 0 , N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> if 2 * j - i < N : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ j ] != S [ 2 * j - i ] and S [ i ] != S [ 2 * j - i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = sum ( A ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> T = collections . Counter ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> S += T [ b ] * ( c - b ) <NEWLINE> T [ c ] += T [ b ] <NEWLINE> T [ b ] = 0 <NEWLINE> print ( S ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> o = list ( i for i in range ( 1 , n + 1 ) ) <NEWLINE> for j in o : <NEWLINE> <INDENT> if j % 5 == 0 or j % 3 == 0 : <NEWLINE> <INDENT> l . append ( j ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( o ) - sum ( l ) ) <NEWLINE>
from sys import stdin <NEWLINE> import math <NEWLINE> from operator import itemgetter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> readline = stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> xy = [ tuple ( map ( int , readline ( ) . split ( ) ) ) + ( i , ) for i in range ( int ( readline ( ) ) ) ] <NEWLINE> xy . sort ( ) <NEWLINE> root = int ( math . sqrt ( len ( xy ) ) ) <NEWLINE> <NL> low = [ x for x , y , i in xy [ : : root ] ] <NEWLINE> high = [ x for x , y , i in xy [ root - 1 : : root ] ] + [ float ( <STRING> ) ] <NEWLINE> <NL> xy = [ sorted ( xy [ i : i + root ] , key = itemgetter ( 1 ) ) for i in range ( 0 , len ( xy ) , root ) ] <NEWLINE> xy = [ ( [ y for x , y , i in xyi ] , xyi ) for xyi in xy ] <NEWLINE> for sx , tx , sy , ty in ( map ( int , readline ( ) . split ( ) ) for _ in range ( int ( readline ( ) ) ) ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> for i in range ( bisect_left ( high , sx ) , bisect_right ( low , tx ) ) : <NEWLINE> <INDENT> k , v = xy [ i ] <NEWLINE> for i in range ( bisect_left ( k , sy ) , bisect_right ( k , ty ) ) : <NEWLINE> <INDENT> if sx <= v [ i ] [ 0 ] <= tx : <NEWLINE> <INDENT> ret . append ( v [ i ] [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ret : <NEWLINE> <INDENT> ret . sort ( ) <NEWLINE> print ( <STRING> . join ( map ( str , ret ) ) ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] * n <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> l [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for k in range ( n ) : <NEWLINE> <INDENT> print ( l [ k ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( * l [ : : - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 1 <NEWLINE> minp = P [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if minp >= P [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> minp = min ( minp , P [ i ] ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= k : <NEWLINE> <INDENT> print ( a - k , b ) <NEWLINE> <DEDENT> elif a + b >= k : <NEWLINE> <INDENT> print ( 0 , a + b - k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT>
N , Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> M = max ( C ) + 1 <NEWLINE> t1 = [ 0 ] * ( M ) <NEWLINE> for v in C : <NEWLINE> <INDENT> t1 [ v ] = 1 <NEWLINE> <NL> <DEDENT> t2 = [ 0 ] * ( M ) <NEWLINE> v = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if t1 [ i ] : <NEWLINE> <INDENT> v = i <NEWLINE> <DEDENT> t2 [ i ] = v <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> n_v = M - 1 <NEWLINE> m = 0 <NEWLINE> while n_v != 0 : <NEWLINE> <INDENT> amr = n_v % t <NEWLINE> m = max ( m , amr ) <NEWLINE> tmp = n_v - m - 1 <NEWLINE> if tmp <= 0 : break <NEWLINE> n_v = t2 [ tmp ] <NEWLINE> <NL> <DEDENT> print ( m ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if np . gcd . reduce ( a ) != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> m = max ( a ) <NEWLINE> cnt = [ 0 ] * ( m + 1 ) <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> cnt [ a [ i ] ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( 2 , m + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if sum ( cnt [ i : : i ] ) > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = [ 0 ] * 1000001 <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> if cnt [ i ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if cnt [ i ] == 2 : <NEWLINE> <INDENT> cnt [ i ] = 1 <NEWLINE> continue <NEWLINE> <DEDENT> cnt [ i ] = 2 <NEWLINE> for j in range ( ( i + i ) , 1000001 , i ) : <NEWLINE> <INDENT> cnt [ j ] = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1000001 ) : <NEWLINE> <INDENT> if cnt [ i ] == 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> strs = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) . split ( ) <NEWLINE> if ( s [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> if ( s [ 1 ] not in strs ) : <NEWLINE> <INDENT> strs [ s [ 1 ] ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( s [ 1 ] in strs ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> V = [ ] <NEWLINE> a = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> V . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> w = V [ i ] [ 2 : ] <NEWLINE> w . sort ( ) <NEWLINE> V [ i ] = V [ i ] [ : 2 ] + w <NEWLINE> a . append ( 0 ) <NEWLINE> <DEDENT> V = sorted ( V , key = lambda x : x [ 0 ] ) <NEWLINE> c = 1 <NEWLINE> t = 1 <NEWLINE> i = 0 <NEWLINE> r = [ 1 ] <NEWLINE> a [ 1 ] = 1 <NEWLINE> p = [ [ 1 , t ] ] <NEWLINE> q = [ ] <NEWLINE> while t < N * 2 : <NEWLINE> <INDENT> j = 2 <NEWLINE> while t < N * 2 and j - 2 < V [ i ] [ 1 ] and V [ i ] [ 1 ] > 0 and a [ V [ i ] [ j ] ] == 1 : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> t += 1 <NEWLINE> if j - 2 < V [ i ] [ 1 ] : <NEWLINE> <INDENT> a [ V [ i ] [ j ] ] = 1 <NEWLINE> c += 1 <NEWLINE> r . append ( V [ i ] [ j ] ) <NEWLINE> p . append ( [ V [ i ] [ j ] , t ] ) <NEWLINE> i = V [ i ] [ j ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . append ( p [ - 1 ] + [ t ] ) <NEWLINE> r . pop ( - 1 ) <NEWLINE> p . pop ( - 1 ) <NEWLINE> if len ( r ) > 0 : <NEWLINE> <INDENT> i = r [ - 1 ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = 1 <NEWLINE> while j < N and a [ j ] == 1 : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> if j < N : <NEWLINE> <INDENT> t += 1 <NEWLINE> i = j - 1 <NEWLINE> r . append ( j ) <NEWLINE> p . append ( [ j , t ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> q = sorted ( q , key = lambda x : x [ 0 ] ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> q [ i ] [ j ] = str ( q [ i ] [ j ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( q [ i ] ) ) <NEWLINE> <DEDENT>
class UnionFind ( object ) : <NEWLINE> <INDENT> def __init__ ( self , n = 1 ) : <NEWLINE> <INDENT> self . par = [ i for i in range ( n ) ] <NEWLINE> self . rank = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x != y : <NEWLINE> <INDENT> if self . rank [ x ] < self . rank [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ x ] += 1 <NEWLINE> <DEDENT> self . par [ y ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> def is_same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf1 = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf1 . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : uf1 . find ( i ) <NEWLINE> X = uf1 . par <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ X [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> print ( max ( ans ) ) <NEWLINE>
r = float ( input ( ) ) <NEWLINE> pi = 3.1415926535897932384626433 <NEWLINE> v = r * r * pi <NEWLINE> w = 2 * r * pi <NEWLINE> print ( <STRING> . format ( v , w ) ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> K = int ( readline ( ) ) <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> seven = 7 <NEWLINE> amari = set ( [ 7 ] ) <NEWLINE> ans = 1 <NEWLINE> while True : <NEWLINE> <INDENT> seven = seven % K <NEWLINE> if seven == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> seven = seven * 10 + 7 <NEWLINE> if seven in amari : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> ans += 1 <NEWLINE> amari . add ( seven ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> ans = ( s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n - 2 * i ) : <NEWLINE> <INDENT> if { s [ j ] , s [ j + i ] , s [ j + 2 * i ] } == { <STRING> , <STRING> , <STRING> } : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lst = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> visited = { } <NEWLINE> <NL> for d in lst : <NEWLINE> <INDENT> if d in visited . keys ( ) : <NEWLINE> <INDENT> visited [ d ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited [ d ] = 1 <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> for d in visited . keys ( ) : <NEWLINE> <INDENT> count += int ( visited [ d ] * ( visited [ d ] - 1 ) / 2 ) <NEWLINE> <DEDENT> for d in lst : <NEWLINE> <INDENT> v = visited [ d ] - 1 <NEWLINE> ans = count - v <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sumA , sumB = [ 0 ] , [ 0 ] <NEWLINE> sa , sb = 0 , 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> sa += a <NEWLINE> sumA . append ( sa ) <NEWLINE> <DEDENT> for b in B : <NEWLINE> <INDENT> sb += b <NEWLINE> sumB . append ( sb ) <NEWLINE> <NL> <NL> <DEDENT> n_max = 0 <NEWLINE> nb_max = M <NEWLINE> for na in range ( 0 , N + 1 ) : <NEWLINE> <INDENT> for nb in range ( nb_max , - 1 , - 1 ) : <NEWLINE> <INDENT> k = sumA [ na ] + sumB [ nb ] <NEWLINE> if k <= K : <NEWLINE> <INDENT> n = na + nb <NEWLINE> n_max = max ( n_max , n ) <NEWLINE> nb_max = nb <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( n_max ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> WHITE = 0 <NEWLINE> GRAY = 1 <NEWLINE> BLACK = 2 <NEWLINE> <NL> <NL> def dbg_record ( records ) : <NEWLINE> <INDENT> for index , record in enumerate ( records ) : <NEWLINE> <INDENT> print ( <STRING> % index ) <NEWLINE> if isinstance ( record , dict ) : <NEWLINE> <INDENT> print ( <STRING> % record . get ( <STRING> , - 1 ) ) <NEWLINE> print ( <STRING> % record . get ( <STRING> , - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def dfs ( matrix ) : <NEWLINE> <INDENT> def internal_dfs ( node_id , current_time ) : <NEWLINE> <INDENT> if state [ node_id ] == WHITE : <NEWLINE> <COMMENT> <NL> <INDENT> state [ node_id ] = GRAY <NEWLINE> stack . append ( node_id ) <NEWLINE> records [ node_id ] = { <STRING> : current_time } <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> next_id = None <NEWLINE> for index in range ( len ( matrix ) ) : <NEWLINE> <INDENT> if matrix [ node_id ] [ index ] == 1 and state [ index ] == WHITE : <NEWLINE> <INDENT> next_id = index <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if next_id is not None : <NEWLINE> <INDENT> return internal_dfs ( next_id , current_time + 1 ) <NEWLINE> <DEDENT> elif 0 < len ( stack ) : <NEWLINE> <COMMENT> <NL> <INDENT> return internal_dfs ( stack . pop ( ) , current_time + 1 ) <NEWLINE> <DEDENT> <DEDENT> elif state [ node_id ] == GRAY : <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <INDENT> next_id = None <NEWLINE> for index in range ( len ( matrix ) ) : <NEWLINE> <INDENT> if matrix [ node_id ] [ index ] == 1 and state [ index ] == WHITE : <NEWLINE> <INDENT> next_id = index <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if next_id is not None : <NEWLINE> <INDENT> stack . append ( node_id ) <NEWLINE> return internal_dfs ( next_id , current_time ) <NEWLINE> <DEDENT> elif 0 < len ( stack ) : <NEWLINE> <COMMENT> <NL> <INDENT> state [ node_id ] = BLACK <NEWLINE> records [ node_id ] [ <STRING> ] = current_time <COMMENT> <NEWLINE> return internal_dfs ( stack . pop ( ) , current_time + 1 ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> state [ node_id ] = BLACK <NEWLINE> records [ node_id ] [ <STRING> ] = current_time <NEWLINE> return current_time <NEWLINE> <DEDENT> <DEDENT> elif state [ node_id ] == BLACK : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> state = [ WHITE ] * len ( matrix ) <COMMENT> <NEWLINE> records = [ None ] * len ( matrix ) <COMMENT> <NEWLINE> stack = [ ] <NEWLINE> current_time = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> node_id = None <NEWLINE> for index , record in enumerate ( records ) : <NEWLINE> <INDENT> if record is None : <NEWLINE> <INDENT> node_id = index <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if node_id is None : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> current_time = internal_dfs ( node_id , current_time + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> return records <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> lines = sys . stdin . readlines ( ) <NEWLINE> <NL> <COMMENT> <NL> dimension = int ( lines [ 0 ] ) <NEWLINE> matrix = [ ] <NEWLINE> for x in range ( dimension ) : <NEWLINE> <INDENT> matrix . append ( [ 0 ] * dimension ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for index , line in enumerate ( lines [ 1 : ] ) : <NEWLINE> <INDENT> for edge in [ int ( x ) for x in line . strip ( ) . split ( <STRING> ) [ 2 : ] ] : <NEWLINE> <INDENT> matrix [ index ] [ edge - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> records = dfs ( matrix ) <NEWLINE> for index , line in enumerate ( records ) : <NEWLINE> <INDENT> if line is not None : <NEWLINE> <INDENT> print ( <STRING> % ( index + 1 , line . get ( <STRING> , - 1 ) , line . get ( <STRING> , - 1 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % ( index + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( <STRING> ) ) <NEWLINE> s = { } <NEWLINE> for a in range ( n ) : <NEWLINE> <INDENT> t = input ( <STRING> ) <NEWLINE> if t in s : <NEWLINE> <INDENT> p = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ t ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( s ) ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> def calk1 ( n ) : <NEWLINE> <INDENT> if n == 0 : return 0 <NEWLINE> m = int ( math . log10 ( n ) ) <NEWLINE> num = m * 9 <NEWLINE> num += n // ( 10 ** m ) <NEWLINE> return num <NEWLINE> <NL> <DEDENT> def calk2 ( n ) : <NEWLINE> <INDENT> m = int ( math . log10 ( n ) ) <NEWLINE> num = m * ( m - 1 ) // 2 * 9 ** 2 <NEWLINE> num += ( n // ( 10 ** m ) - 1 ) * m * 9 <NEWLINE> num += calk1 ( n - ( n // ( 10 ** m ) * 10 ** m ) ) <NEWLINE> return num <NEWLINE> <NL> <DEDENT> def calk3 ( n ) : <NEWLINE> <INDENT> m = int ( math . log10 ( n ) ) <NEWLINE> num = m * ( m - 1 ) * ( m - 2 ) // 6 * 9 ** 3 <NEWLINE> num += ( n // ( 10 ** m ) - 1 ) * ( m * ( m - 1 ) // 2 * 9 ** 2 ) <NEWLINE> num += calk2 ( n - ( n // ( 10 ** m ) * 10 ** m ) ) <NEWLINE> return num <NEWLINE> <DEDENT> if n < 10 ** ( K - 1 ) : print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> if K == 1 : print ( calk1 ( n ) ) <NEWLINE> elif K == 2 : print ( calk2 ( n ) ) <NEWLINE> else : print ( calk3 ( n ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d . sort ( ) <NEWLINE> t . sort ( ) <NEWLINE> j = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if d [ i ] == t [ j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> if j == m : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if j == m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> adic = dict ( ) <NEWLINE> <NL> for ai in a : <NEWLINE> <INDENT> if ai in adic : <NEWLINE> <INDENT> adic [ ai ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> adic [ ai ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> b = [ 0 ] * ( q ) <NEWLINE> c = [ 0 ] * ( q ) <NEWLINE> bc = [ [ 0 ] * 2 for i in range ( q ) ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> bc [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> asum = 0 <NEWLINE> for i , ad in adic . items ( ) : <NEWLINE> <INDENT> asum += i * ad <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for bi , ci in bc : <NEWLINE> <INDENT> if bi in adic and ci in adic : <NEWLINE> <INDENT> asum -= bi * adic [ bi ] <NEWLINE> adic [ ci ] = adic [ ci ] + adic [ bi ] <NEWLINE> asum += ci * adic [ bi ] <NEWLINE> del adic [ bi ] <NEWLINE> <DEDENT> elif bi in adic and ( not ci in adic ) : <NEWLINE> <INDENT> asum -= bi * adic [ bi ] <NEWLINE> adic [ ci ] = adic [ bi ] <NEWLINE> asum += ci * adic [ bi ] <NEWLINE> del adic [ bi ] <NEWLINE> <COMMENT> <NL> <DEDENT> print ( asum ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> target = 1 <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in List : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( len ( List ) ) : <NEWLINE> <INDENT> target *= List [ i ] <NEWLINE> if target > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( target ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> Graph = [ [ ] for i in range ( n ) ] <NEWLINE> seen = [ False ] * n <NEWLINE> point = [ 0 ] * n <NEWLINE> <NL> <NL> def dfs ( g , v , p ) : <NEWLINE> <COMMENT> <NL> <INDENT> seen [ v ] = True <NEWLINE> if p != - 1 : point [ v ] += point [ p ] <NEWLINE> <NL> <COMMENT> <NL> for next_v in g [ v ] : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> if seen [ next_v ] : continue <NEWLINE> <NL> <COMMENT> <NL> dfs ( g , next_v , v ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> <NL> <COMMENT> <NL> Graph [ a ] . append ( b ) <NEWLINE> Graph [ b ] . append ( a ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> x , p = map ( int , input ( ) . split ( ) ) <NEWLINE> point [ x - 1 ] += p <NEWLINE> <NL> <NL> <DEDENT> dfs ( Graph , 0 , - 1 ) <NEWLINE> <NL> <NL> print ( * point ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> m = ( x + y + z ) ** 2 - ( x * y + y * z + z * x ) <NEWLINE> if m <= N : <NEWLINE> <INDENT> ans [ m - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <COMMENT> <NEWLINE> to_index = lambda x : int ( x ) - 1 <COMMENT> <NEWLINE> print_list_in_2D = lambda x : print ( * x , sep = <STRING> ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> def input_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def map_int_input ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) ) <NEWLINE> <NL> <DEDENT> MII = map_int_input <NEWLINE> <NL> def MII_split ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def MII_to_index ( ) : <NEWLINE> <INDENT> return map ( to_index , input ( ) ) <NEWLINE> <NL> <DEDENT> def MII_split_to_index ( ) : <NEWLINE> <INDENT> return map ( to_index , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def list_int_inputs ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) ) ) <NEWLINE> <NL> <DEDENT> LII = list_int_inputs <NEWLINE> <NL> def LII_split ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def LII_2D ( rows_number ) : <NEWLINE> <INDENT> return [ LII ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> <DEDENT> def LII_split_2D ( rows_number ) : <NEWLINE> <INDENT> return [ LII_split ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> <DEDENT> X = input_int ( ) <NEWLINE> <NL> for a in range ( 2000 ) : <NEWLINE> <INDENT> A = a - 1000 <NEWLINE> <NL> for b in range ( 2000 ) : <NEWLINE> <INDENT> B = b - 1000 <NEWLINE> if A ** 5 - B ** 5 == X : <NEWLINE> <INDENT> print ( <STRING> . format ( A , B ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> counts = [ ] <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> or S [ i ] == <STRING> or S [ i ] == <STRING> or S [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counts . append ( count ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> <DEDENT> counts . append ( count ) <NEWLINE> if len ( S ) == 1 : <NEWLINE> <INDENT> print ( counts [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( counts ) ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> a = int ( stdin . readline ( ) ) <NEWLINE> A = stdin . readline ( ) . split ( ) <NEWLINE> sum = 0 <NEWLINE> for k in range ( 0 , a + 1 ) : <NEWLINE> <INDENT> sum += int ( A [ k ] ) <NEWLINE> <NL> <DEDENT> sum -= int ( A [ a ] ) <NEWLINE> ver = 1 <NEWLINE> lay = 1 <NEWLINE> K = 0 <NEWLINE> T = 0 <NEWLINE> <NL> if a == 0 : <NEWLINE> <INDENT> if A [ 0 ] != <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> K = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> K = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for l in range ( 0 , a ) : <NEWLINE> <INDENT> if lay - int ( A [ l ] ) <= 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> K = 1 <NEWLINE> break <NEWLINE> <DEDENT> if ( lay - int ( A [ l ] ) ) * 2 < int ( A [ a ] ) and l == ( a - 1 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> K = 1 <NEWLINE> break <NEWLINE> <DEDENT> if ( lay - int ( A [ l ] ) ) * 2 - sum + int ( A [ l ] ) <= int ( A [ a ] ) : <NEWLINE> <INDENT> lay = ( lay - int ( A [ l ] ) ) * 2 <NEWLINE> ver += lay <NEWLINE> sum -= int ( A [ l ] ) <NEWLINE> T = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lay -= int ( A [ l ] ) <NEWLINE> sum -= int ( A [ l ] ) <NEWLINE> x = lay - sum - int ( A [ a ] ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> ver += lay <NEWLINE> <DEDENT> elif x > 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> K = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lay = sum + int ( A [ a ] ) <NEWLINE> ver += lay <NEWLINE> <DEDENT> T = l <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if K == 0 : <NEWLINE> <INDENT> for u in range ( T + 1 , a ) : <NEWLINE> <INDENT> lay -= int ( A [ u ] ) <NEWLINE> sum -= int ( A [ u ] ) <NEWLINE> ver += lay <NEWLINE> <NL> <DEDENT> <DEDENT> if K == 0 : <NEWLINE> <INDENT> print ( ver ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans_y = None <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if x == p [ 0 ] : <NEWLINE> <INDENT> print ( x - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> m = float ( <STRING> ) <NEWLINE> if x < p [ 0 ] or p [ n - 1 ] < x : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for y in [ y for y in range ( p [ 0 ] - 1 , p [ n - 1 ] + 2 ) if not y in p ] : <NEWLINE> <INDENT> if abs ( x - y ) < m : <NEWLINE> <INDENT> m = abs ( x - y ) <NEWLINE> ans_y = y <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans_y != None : <NEWLINE> <INDENT> print ( ans_y ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * ( n - 1 ) <NEWLINE> a [ : ] = map ( int , input ( ) . split ( ) ) <NEWLINE> b = [ 0 ] * ( n ) <NEWLINE> <STRING> <NEWLINE> for ii in range ( n - 1 ) : <NEWLINE> <INDENT> b [ a [ ii ] - 1 ] += 1 <NEWLINE> <DEDENT> for ii in range ( n ) : <NEWLINE> <INDENT> print ( b [ ii ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> b = [ 0 ] * 3 <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= b . count ( i ) <NEWLINE> ans %= m <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> if b [ j ] == i : <NEWLINE> <INDENT> b [ j ] += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans % m ) <NEWLINE>
from scipy . sparse import csr_matrix <NEWLINE> from scipy . sparse . csgraph import connected_components <NEWLINE> <NL> <NL> class People : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . frends = 0 <NEWLINE> self . blocks = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> data = [ 1 ] * m <NEWLINE> row = [ ] <NEWLINE> col = [ ] <NEWLINE> peoples = [ People ( ) for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> one , two = [ int ( j ) for j in input ( ) . split ( ) ] <NEWLINE> new_one = min ( one , two ) <NEWLINE> new_two = max ( one , two ) <NEWLINE> row . append ( one ) <NEWLINE> col . append ( two ) <NEWLINE> peoples [ one ] . frends += 1 <NEWLINE> peoples [ two ] . frends += 1 <NEWLINE> <NL> <DEDENT> frends = csr_matrix ( ( data , ( row , col ) ) , shape = ( n + 1 , n + 1 ) ) <NEWLINE> <NL> <NL> num , labels = connected_components ( frends ) <NEWLINE> labels = list ( labels ) <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> one , two = [ int ( j ) for j in input ( ) . split ( ) ] <NEWLINE> if labels [ one ] == labels [ two ] : <NEWLINE> <INDENT> peoples [ one ] . blocks += 1 <NEWLINE> peoples [ two ] . blocks += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> renketu_num = [ 0 ] * num <NEWLINE> for i in labels : <NEWLINE> <INDENT> renketu_num [ i ] += 1 <NEWLINE> <NL> <NL> <DEDENT> def get_renketu_num ( i ) : <NEWLINE> <INDENT> return renketu_num [ labels [ i ] ] - 1 <NEWLINE> <NL> <NL> <DEDENT> def get_friend_num ( i ) : <NEWLINE> <INDENT> return peoples [ i ] . frends <NEWLINE> <NL> <NL> <DEDENT> def get_block_num ( i ) : <NEWLINE> <INDENT> return peoples [ i ] . blocks <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( get_renketu_num ( i ) - get_friend_num ( i ) - get_block_num ( i ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> x = int ( N ** 0.5 ) + 1 <NEWLINE> ans_1 = N <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> if N % x == 0 : <NEWLINE> <INDENT> ans_1 = x <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans_2 = N // ans_1 <NEWLINE> print ( ans_1 + ans_2 - 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def mod10_9_7 ( num ) : <NEWLINE> <INDENT> return num % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <NL> <DEDENT> seki = A [ - 1 ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * seki <NEWLINE> seki += A [ i ] <NEWLINE> <DEDENT> print ( mod10_9_7 ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ None for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] = str ( i + 1 ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if r - l >= 2019 : print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> MIN = 10000 <NEWLINE> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> p = i * j % 2019 <NEWLINE> if p < MIN : MIN = p <NEWLINE> <DEDENT> <DEDENT> print ( MIN ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N = 3 <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> M = np . zeros ( K + 1 , dtype = int ) <NEWLINE> <NL> for i in range ( K , 0 , - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> M [ i ] += pow ( K // i , N ) <NEWLINE> <NL> for j in range ( 2 , K // i + 1 ) : <NEWLINE> <INDENT> j *= i <NEWLINE> M [ i ] -= M [ j ] <NEWLINE> <NL> <DEDENT> ans += M [ i ] * i <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
r = float ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> m = 3.141592653589 * r * r <NEWLINE> l = 3.141592653589 * r * 2 <NEWLINE> <NL> print ( <STRING> . format ( m ) , <STRING> . format ( l ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> j = 2 <NEWLINE> <COMMENT> <NL> k = 1 <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> l = j + k <NEWLINE> j = k <NEWLINE> k = l <NEWLINE> <NL> <DEDENT> print ( l ) <NEWLINE>
import random <NEWLINE> <NL> <NL> def _calc_today_max_v3 ( today , D , Ci , Sdi , last_day ) : <NEWLINE> <INDENT> bad_1st_values = [ Ci [ contest ] * ( today + 1 - last_day [ contest ] ) for contest in range ( 26 ) ] <NEWLINE> total_bad_1st_value = sum ( bad_1st_values ) <NEWLINE> bad_2nd_values = [ Ci [ contest ] * ( today + 2 - last_day [ contest ] ) for contest in range ( 26 ) ] <NEWLINE> total_bad_2nd_value = sum ( bad_2nd_values ) <NEWLINE> bad_3rd_values = [ Ci [ contest ] * ( today + 3 - last_day [ contest ] ) for contest in range ( 26 ) ] <NEWLINE> total_bad_3rd_value = sum ( bad_2nd_values ) <NEWLINE> <NL> contests_2nd = list ( range ( 26 ) ) <NEWLINE> contests_3rd = list ( range ( 26 ) ) <NEWLINE> random . shuffle ( contests_2nd ) <NEWLINE> random . shuffle ( contests_3rd ) <NEWLINE> <NL> max_value = - 99999999999999999 <NEWLINE> max_context = 0 <NEWLINE> for contest_1st in range ( 26 ) : <NEWLINE> <INDENT> contest_1st_value = Sdi [ today ] [ contest_1st ] <NEWLINE> bad_1st_value = total_bad_1st_value - bad_1st_values [ contest_1st ] <NEWLINE> if today == D - 1 : <NEWLINE> <INDENT> today_value = contest_1st_value - bad_1st_value <NEWLINE> if max_value < today_value : <NEWLINE> <INDENT> max_value = today_value <NEWLINE> max_context = contest_1st <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for contest_2nd in contests_2nd [ 0 : 10 ] : <NEWLINE> <INDENT> contest_2nd_value = Sdi [ today + 1 ] [ contest_2nd ] <NEWLINE> bad_2nd_value = total_bad_2nd_value - bad_1st_values [ contest_1st ] - bad_2nd_values [ contest_2nd ] + Ci [ contest_1st ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if today == D - 2 : <NEWLINE> <INDENT> today_value = contest_1st_value + contest_2nd_value - bad_1st_value - bad_2nd_value <NEWLINE> if max_value < today_value : <NEWLINE> <INDENT> max_value = today_value <NEWLINE> max_context = contest_1st <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for contest_3rd in contests_3rd [ 0 : 10 ] : <NEWLINE> <INDENT> contest_3rd_value = Sdi [ today + 2 ] [ contest_3rd ] <NEWLINE> bad_3rd_value = total_bad_3rd_value - bad_1st_values [ contest_1st ] + 2 * Ci [ contest_1st ] <NEWLINE> - bad_2nd_values [ contest_2nd ] + Ci [ contest_2nd ] - bad_3rd_values [ contest_3rd ] <NEWLINE> today_value = contest_1st_value + contest_2nd_value + contest_3rd_value - bad_1st_value - bad_2nd_value - bad_3rd_value <NEWLINE> if max_value < today_value : <NEWLINE> <INDENT> max_value = today_value <NEWLINE> max_context = contest_1st <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return max_context <NEWLINE> <NL> <NL> <DEDENT> def _calc_today_max_v2 ( today , D , Ci , Sdi , last_day ) : <NEWLINE> <INDENT> today_bad_values = [ Ci [ contest ] * ( today + 1 - last_day [ contest ] ) for contest in range ( 26 ) ] <NEWLINE> today_total_bad_value = sum ( today_bad_values ) <NEWLINE> bad_2nd_values = [ Ci [ contest ] * ( today + 2 - last_day [ contest ] ) for contest in range ( 26 ) ] <NEWLINE> total_bad_2nd_value = sum ( bad_2nd_values ) <NEWLINE> <NL> max_value = - 99999999999999999 <NEWLINE> max_context = 0 <NEWLINE> for contest_1st in range ( 26 ) : <NEWLINE> <INDENT> contest_1st_value = Sdi [ today ] [ contest_1st ] <NEWLINE> bad_1st_value = today_total_bad_value - today_bad_values [ contest_1st ] <NEWLINE> if today == D - 1 : <NEWLINE> <INDENT> today_value = contest_1st_value - bad_1st_value <NEWLINE> if max_value < today_value : <NEWLINE> <INDENT> max_value = today_value <NEWLINE> max_context = contest_1st <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for contest_2nd in range ( 26 ) : <NEWLINE> <INDENT> contest_2nd_value = Sdi [ today + 1 ] [ contest_2nd ] <NEWLINE> bad_2nd_value = total_bad_2nd_value - today_bad_values [ contest_1st ] - bad_2nd_values [ contest_2nd ] <NEWLINE> today_value = contest_1st_value + contest_2nd_value - bad_1st_value - bad_2nd_value <NEWLINE> if max_value < today_value : <NEWLINE> <INDENT> max_value = today_value <NEWLINE> max_context = contest_1st <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return max_context <NEWLINE> <NL> <NL> <DEDENT> def _calc_today_max ( today , D , Ci , Sdi , last_day ) : <NEWLINE> <INDENT> today_bad_values = [ Ci [ contest ] * ( today + 1 - last_day [ contest ] ) for contest in range ( 26 ) ] <NEWLINE> today_total_bad_value = sum ( today_bad_values ) <NEWLINE> <NL> max_value = - 99999999999999999 <NEWLINE> max_context = 0 <NEWLINE> for contest in range ( 26 ) : <NEWLINE> <INDENT> today_contest_value = Sdi [ today ] [ contest ] <NEWLINE> today_bad_value = today_total_bad_value - today_bad_values [ contest ] <NEWLINE> today_value = today_contest_value - today_bad_value <NEWLINE> if max_value < today_value : <NEWLINE> <INDENT> max_value = today_value <NEWLINE> max_context = contest <NEWLINE> <NL> <DEDENT> <DEDENT> return max_context <NEWLINE> <NL> <NL> <DEDENT> def _main ( D , Ci , Sdi ) : <NEWLINE> <INDENT> last_day = [ 0 ] * 26 <NEWLINE> for today in range ( D ) : <NEWLINE> <INDENT> max_contest = _calc_today_max_v3 ( today , D , Ci , Sdi , last_day ) <NEWLINE> print ( max_contest + 1 ) <NEWLINE> last_day [ max_contest ] = today + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def _execute ( ) : <NEWLINE> <INDENT> D = int ( input ( ) ) <NEWLINE> Ci = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Sdi = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> Sdi . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> _main ( D , Ci , Sdi ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _execute ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : break <NEWLINE> for y in range ( 0 , H ) : <NEWLINE> <INDENT> for x in range ( 0 , W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> T = str ( input ( ) ) <NEWLINE> <NL> if M > N : <NEWLINE> <INDENT> M , N = N , M <NEWLINE> S , T = T , S <NEWLINE> <NL> <DEDENT> import math <NEWLINE> G = N * M // math . gcd ( N , M ) <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> <NL> C = N // math . gcd ( N , M ) <NEWLINE> D = M // math . gcd ( N , M ) <NEWLINE> <NL> for i in range ( 0 , math . gcd ( N , M ) ) : <NEWLINE> <INDENT> if S [ i * C ] != T [ i * D ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( G ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> paths = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b , z = map ( int , input ( ) . split ( ) ) <NEWLINE> paths [ a - 1 ] . append ( b - 1 ) <NEWLINE> paths [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> visited = [ False ] * N <NEWLINE> <NL> def dfs ( node , prev ) : <NEWLINE> <INDENT> if visited [ node ] : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> visited [ node ] = True <NEWLINE> for n in paths [ node ] : <NEWLINE> <INDENT> if n != prev : <NEWLINE> <INDENT> dfs ( n , node ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if visited [ i ] == False : <NEWLINE> <INDENT> count += 1 <NEWLINE> dfs ( i , - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n <= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> l = sorted ( l , reverse = True ) <NEWLINE> hissatu = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> hissatu += l [ i ] <NEWLINE> <DEDENT> total = 0 <NEWLINE> for j in l : <NEWLINE> <INDENT> total += j <NEWLINE> <DEDENT> print ( total - hissatu ) <NEWLINE>
<COMMENT> <NL> <NL> s = str ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> str_list = set ( ) <NEWLINE> for i in range ( len ( s ) + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , i + K + 1 ) : <NEWLINE> <INDENT> if j > len ( s ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> str_list . add ( s [ i : j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> str_list = list ( str_list ) <NEWLINE> str_list . sort ( ) <NEWLINE> print ( str_list [ K - 1 ] ) <NEWLINE> <NL>
import math <NEWLINE> import numpy as np <NEWLINE> x = int ( input ( ) ) <NEWLINE> height = list ( map ( lambda x : int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> cands = [ 0 for i in range ( len ( height ) ) ] <NEWLINE> <NL> <NL> count = 0 <NEWLINE> <NL> for i in range ( len ( height ) ) : <NEWLINE> <INDENT> if i - height [ i ] >= 0 : <NEWLINE> <INDENT> count += cands [ i - height [ i ] ] <NEWLINE> <NL> <DEDENT> if i + height [ i ] < len ( height ) : <NEWLINE> <INDENT> cands [ i + height [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> friend = [ [ ] for _ in range ( n ) ] <NEWLINE> block = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> friend [ a ] . append ( b ) <NEWLINE> friend [ b ] . append ( a ) <NEWLINE> <DEDENT> for _ in range ( k ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> c -= 1 <NEWLINE> d -= 1 <NEWLINE> block [ c ] . append ( d ) <NEWLINE> block [ d ] . append ( c ) <NEWLINE> <DEDENT> seen = [ - 1 ] * n <NEWLINE> def dfs ( graph , v , top ) : <NEWLINE> <INDENT> seen [ v ] = top <NEWLINE> top_count [ top ] += 1 <NEWLINE> for nv in graph [ v ] : <NEWLINE> <INDENT> if seen [ nv ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( graph , nv , top ) <NEWLINE> <DEDENT> <DEDENT> top = 0 <NEWLINE> top_count = [ 0 ] <NEWLINE> for v in range ( n ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> if seen [ v ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( friend , v , top ) <NEWLINE> top_count . append ( 0 ) <NEWLINE> top += 1 <NEWLINE> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = top_count [ seen [ i ] ] - len ( friend [ i ] ) - 1 <NEWLINE> cnt = 0 <NEWLINE> for v in block [ i ] : <NEWLINE> <INDENT> if seen [ v ] == seen [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ans -= cnt <NEWLINE> print ( ans , end = <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> class segment_tree : <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> def __init__ ( self , dat , query , default = 0 ) : <NEWLINE> <INDENT> self . offset = 2 ** math . ceil ( math . log ( len ( dat ) , 2 ) ) <NEWLINE> self . table = [ default ] * self . offset + dat + [ default ] * ( self . offset - len ( dat ) ) <NEWLINE> self . query = query <NEWLINE> for i in reversed ( range ( 1 , self . offset ) ) : <NEWLINE> <INDENT> self . table [ i ] = self . query ( self . table [ 2 * i ] , self . table [ 2 * i + 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def find ( self , l , r ) : <NEWLINE> <INDENT> return self . query ( self . __range ( l , r ) ) <NEWLINE> <NL> <DEDENT> def __range ( self , l , r ) : <NEWLINE> <INDENT> l += self . offset <NEWLINE> r += self . offset <NEWLINE> while l <= r : <NEWLINE> <INDENT> if l & 1 : <NEWLINE> <INDENT> yield self . table [ l ] <NEWLINE> l += 1 <NEWLINE> <DEDENT> l >>= 1 <NEWLINE> if r & 1 == 0 : <NEWLINE> <INDENT> yield self . table [ r ] <NEWLINE> r -= 1 <NEWLINE> <DEDENT> r >>= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def update ( self , i , x ) : <NEWLINE> <INDENT> i += self . offset <NEWLINE> self . table [ i ] = x <NEWLINE> while 1 < i : <NEWLINE> <INDENT> i >>= 1 <NEWLINE> self . table [ i ] = self . query ( self . table [ 2 * i ] , self . table [ 2 * i + 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> n , q = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> <NL> rmq = segment_tree ( [ ( 1 << 31 ) - 1 ] * n , min , float ( <STRING> ) ) <NEWLINE> <NL> function = ( rmq . update , lambda x , y : print ( rmq . find ( x , y ) ) ) <NEWLINE> for com , x , y in ( map ( int , f . readline ( ) . split ( ) ) for _ in range ( q ) ) : <NEWLINE> <INDENT> function [ com ] ( x , y ) <NEWLINE> <DEDENT>
from bisect import bisect_right <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> answer = 0 <NEWLINE> is_changed = False <NEWLINE> if a [ 0 ] <= k or b [ 0 ] <= k : <NEWLINE> <INDENT> answer = 1 <NEWLINE> <DEDENT> elif a [ 0 ] + b [ 0 ] <= k : <NEWLINE> <INDENT> answer = 2 <NEWLINE> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a [ i ] += a [ i - 1 ] <NEWLINE> if k < a [ i ] and not is_changed : <NEWLINE> <INDENT> answer = i <NEWLINE> is_changed = True <NEWLINE> <DEDENT> <DEDENT> if a [ - 1 ] <= k : <NEWLINE> <INDENT> answer = n <NEWLINE> <DEDENT> is_changed = False <NEWLINE> for i in range ( 1 , m ) : <NEWLINE> <INDENT> b [ i ] += b [ i - 1 ] <NEWLINE> if k < b [ i ] and not is_changed : <NEWLINE> <INDENT> answer = max ( answer , i ) <NEWLINE> is_changed = True <NEWLINE> <DEDENT> <DEDENT> if b [ - 1 ] <= k : <NEWLINE> <INDENT> answer = max ( answer , m ) <NEWLINE> <DEDENT> if a [ - 1 ] + b [ - 1 ] <= k : <NEWLINE> <INDENT> answer = n + m <NEWLINE> <DEDENT> elif all ( k < x for x in [ a [ 0 ] , b [ 0 ] , a [ 0 ] + b [ 0 ] ] ) : <NEWLINE> <INDENT> answer = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> l = bisect_right ( b , k - a [ i ] ) <NEWLINE> if l == 0 or ( l == m and b [ l - 1 ] + a [ i ] > k ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> answer = max ( answer , i + 1 + l ) <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> height , width = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> if height == 0 and width == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for h in range ( height ) : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> * width ) ) <NEWLINE> <NL> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * [ i for i in range ( 1 , 1 + n ) if i % 3 == 0 or <STRING> in str ( i ) ] ) <NEWLINE>
def call ( n ) : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> <NL> for i , x in enumerate ( range ( 1 , n + 1 ) , 1 ) : <NEWLINE> <INDENT> if x % 3 == 0 : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> while x : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> break <NEWLINE> <DEDENT> x //= 10 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> from sys import stdin <NEWLINE> <NL> n = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> call ( n ) <NEWLINE> <NL> <DEDENT>
from collections import defaultdict <NEWLINE> dic = defaultdict ( int ) <COMMENT> <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> X = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> X . append ( [ x , y ] ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> p = X [ i ] [ 0 ] - X [ j ] [ 0 ] <NEWLINE> q = X [ i ] [ 1 ] - X [ j ] [ 1 ] <NEWLINE> if p < 0 : <NEWLINE> <INDENT> p = - p ; q = - q <NEWLINE> <DEDENT> if p == 0 and q < 0 : <NEWLINE> <INDENT> q = - q <NEWLINE> <DEDENT> dic [ ( p , q ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> path = max ( dic . values ( ) ) <NEWLINE> ans = N - path <NEWLINE> <COMMENT> <NL> print ( ans ) <NEWLINE>
<STRING> <NEWLINE> from heapq import heappush , heappop <NEWLINE> def main ( ) : <NEWLINE> <INDENT> INF = 10 ** 20 <NEWLINE> while True : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> lines = [ ] <NEWLINE> acc = 1 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = lst [ 0 ] <NEWLINE> line = [ ( acc + i , lst [ i * 2 + 1 ] , lst [ i * 2 + 2 ] ) for i in range ( k ) ] <NEWLINE> acc += k <NEWLINE> lines . append ( line ) <NEWLINE> <NL> <DEDENT> num = acc - 1 <NEWLINE> edges = [ [ ] for _ in range ( num * ( m + 1 ) + 2 ) ] <NEWLINE> for line1 , line2 in zip ( lines , lines [ 1 : ] ) : <NEWLINE> <INDENT> for acc1 , x1 , d1 in line1 : <NEWLINE> <INDENT> for acc2 , x2 , d2 in line2 : <NEWLINE> <INDENT> cost = ( d1 + d2 ) * abs ( x1 - x2 ) <NEWLINE> n1 = acc1 <NEWLINE> n2 = acc2 <NEWLINE> for j in range ( m + 1 ) : <NEWLINE> <INDENT> edges [ n1 ] . append ( ( n2 , cost ) ) <NEWLINE> n1 += num <NEWLINE> n2 += num <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for line1 , line2 in zip ( lines , lines [ 2 : ] ) : <NEWLINE> <INDENT> for acc1 , x1 , d1 in line1 : <NEWLINE> <INDENT> for acc2 , x2 , d2 in line2 : <NEWLINE> <INDENT> cost = ( d1 + d2 ) * abs ( x1 - x2 ) <NEWLINE> n1 = acc1 <NEWLINE> n2 = acc2 + num <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> edges [ n1 ] . append ( ( n2 , cost ) ) <NEWLINE> n1 += num <NEWLINE> n2 += num <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for acc , _ , _ in lines [ 0 ] : <NEWLINE> <INDENT> edges [ 0 ] . append ( ( acc , 0 ) ) <NEWLINE> <DEDENT> if m >= 1 : <NEWLINE> <INDENT> for acc , _ , _ in lines [ 1 ] : <NEWLINE> <INDENT> edges [ 0 ] . append ( ( acc + num , 0 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> end = num * ( m + 1 ) + 1 <NEWLINE> for acc , _ , _ in lines [ - 1 ] : <NEWLINE> <INDENT> b = acc <NEWLINE> for j in range ( m + 1 ) : <NEWLINE> <INDENT> edges [ b ] . append ( ( end , 0 ) ) <NEWLINE> b += num <NEWLINE> <DEDENT> <DEDENT> for acc , _ , _ in lines [ - 2 ] : <NEWLINE> <INDENT> b = acc <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> edges [ b ] . append ( ( end , 0 ) ) <NEWLINE> b += num <NEWLINE> <NL> <DEDENT> <DEDENT> def search ( ) : <NEWLINE> <INDENT> que = [ ] <NEWLINE> heappush ( que , ( 0 , 0 ) ) <NEWLINE> costs = [ INF ] * ( num * ( m + 1 ) + 2 ) <NEWLINE> costs [ 0 ] = 0 <NEWLINE> while que : <NEWLINE> <INDENT> total , node = heappop ( que ) <NEWLINE> for to , cost in edges [ node ] : <NEWLINE> <INDENT> new_total = total + cost <NEWLINE> if to == end : <NEWLINE> <INDENT> print ( new_total ) <NEWLINE> return <NEWLINE> <DEDENT> if costs [ to ] > new_total : <NEWLINE> <INDENT> costs [ to ] = new_total <NEWLINE> heappush ( que , ( new_total , to ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> search ( ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> count = a . count ( 0 ) <NEWLINE> if count > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ab = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( ab , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> alist = [ 0 ] * 2019 <NEWLINE> num1 = 0 <NEWLINE> num2 = 1 / 10 <NEWLINE> lens = len ( s ) <NEWLINE> for i in range ( lens ) : <NEWLINE> <INDENT> num2 = int ( ( ( num2 ) * 10 ) % 2019 ) <NEWLINE> num1 = ( num1 + int ( s [ i ] ) * ( num2 ) ) % 2019 <NEWLINE> alist [ num1 ] += 1 <NEWLINE> <DEDENT> alist [ 0 ] += 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> ans += alist [ i ] * ( alist [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if ans != 0 : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) % 10 <NEWLINE> <NL> if n == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == 0 or n == 1 or n == 6 or n == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> t = input ( ) <NEWLINE> <NL> a = [ ] <NEWLINE> j = 0 <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> a . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( t [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( a ) ) <NEWLINE> <COMMENT> <NL>
n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> c = [ char for char in c ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( c . count ( <STRING> ) ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> gate = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( m ) ] <NEWLINE> <NL> minv = gate [ 0 ] [ 0 ] <NEWLINE> maxv = gate [ 0 ] [ 1 ] <NEWLINE> <NL> for x in gate : <NEWLINE> <INDENT> minv = max ( minv , x [ 0 ] ) <NEWLINE> maxv = min ( maxv , x [ 1 ] ) <NEWLINE> <NL> <DEDENT> print ( maxv - minv + 1 if maxv - minv + 1 >= 1 else 0 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> money = 1000 <NEWLINE> stock = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> stock = money // A [ i ] <NEWLINE> money -= stock * A [ i ] <NEWLINE> money += stock * A [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( money ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> vis = set ( ) <NEWLINE> vis . add ( 1 ) <NEWLINE> cnt = 0 <NEWLINE> cnt2town = { } <NEWLINE> town2cnt = { } <NEWLINE> cnt2town [ 0 ] = 1 <NEWLINE> town2cnt [ 1 ] = 0 <NEWLINE> <NL> cnt = 1 <NEWLINE> prev = 1 <NEWLINE> while cnt <= K : <NEWLINE> <INDENT> a = A [ prev - 1 ] <NEWLINE> <NL> if a in vis : <NEWLINE> <INDENT> c = town2cnt [ a ] <NEWLINE> <NL> rem = K - cnt <NEWLINE> num_loop = cnt - c <NEWLINE> <NL> r = rem % num_loop <NEWLINE> print ( cnt2town [ c + r ] ) <NEWLINE> <NL> exit ( ) <NEWLINE> <NL> <DEDENT> cnt2town [ cnt ] = a <NEWLINE> town2cnt [ a ] = cnt <NEWLINE> vis . add ( a ) <NEWLINE> <NL> prev = a <NEWLINE> cnt += 1 <NEWLINE> <NL> <NL> <DEDENT> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = dict ( collections . Counter ( A ) ) <NEWLINE> A = sorted ( A . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if len ( A ) > K : <NEWLINE> <INDENT> cnt += A [ - 1 ] [ 1 ] <NEWLINE> A . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , ( input ( ) . split ( ) ) ) ) <NEWLINE> list_a = [ 0 ] * 2 * 100001 <NEWLINE> for i in a : <NEWLINE> <INDENT> list_a [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( list_a [ i ] ) <NEWLINE> <DEDENT>
<NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> return math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> <NL> <NL> <DEDENT> print ( f ( min ( B - 1 , N ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ma = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if li [ i ] > ma : <NEWLINE> <INDENT> ma = li [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ma - li [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> <NL> mi = 0 <NEWLINE> ma = n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> mi = max ( mi , lr [ i ] [ 0 ] ) <NEWLINE> ma = min ( ma , lr [ i ] [ 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if ma - mi >= 0 : <NEWLINE> <INDENT> print ( ma - mi + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = input ( ) <NEWLINE> <DEDENT> a = sorted ( a ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] != a [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> to = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> to [ a ] . append ( b ) <NEWLINE> <NL> <DEDENT> S , T = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> from collections import deque <NEWLINE> <NL> q = deque ( [ ( S , 0 ) ] ) <NEWLINE> v = [ [ - 1 ] * 3 for i in range ( N + 1 ) ] <NEWLINE> <NL> while q : <NEWLINE> <INDENT> a , t = q . popleft ( ) <NEWLINE> b = t % 3 <NEWLINE> if v [ a ] [ b ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v [ a ] [ b ] = t <NEWLINE> t += 1 <NEWLINE> for x in to [ a ] : <NEWLINE> <INDENT> q . append ( ( x , t ) ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> if v [ T ] [ 0 ] == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( v [ T ] [ 0 ] // 3 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p , S = input ( ) . split ( ) <NEWLINE> s [ int ( p ) - 1 ] += [ S ] <NEWLINE> <DEDENT> print ( sum ( <STRING> in si for si in s ) , end = <STRING> ) <NEWLINE> print ( sum ( si [ : si . index ( <STRING> ) ] . count ( <STRING> ) if <STRING> in si else 0 for si in s ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> print ( <STRING> if a [ i ] < a [ i + k ] else <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> connect = [ set ( ) for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> connect [ a - 1 ] . add ( b - 1 ) <NEWLINE> connect [ b - 1 ] . add ( a - 1 ) <NEWLINE> <NL> <DEDENT> counter = [ 0 ] * n <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> counter [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> <NL> def dfs ( count , v , parent ) : <NEWLINE> <INDENT> count += counter [ v ] <NEWLINE> ans [ v ] = count <NEWLINE> for child in connect [ v ] : <NEWLINE> <INDENT> if child != parent : <NEWLINE> <INDENT> dfs ( count , child , v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , 0 , - 1 ) <NEWLINE> <NL> print ( * ans ) <NEWLINE>
import string <NEWLINE> import sys <NEWLINE> <NL> a = string . ascii_lowercase <NEWLINE> key = str . maketrans ( a , a [ 1 : ] + a [ : 1 ] ) <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <INDENT> for i in range ( 1 , 27 ) : <NEWLINE> <INDENT> s = s . translate ( key ) <NEWLINE> if <STRING> in s or <STRING> in s or <STRING> in s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( s , end = <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ( i < j < k ) : <NEWLINE> <INDENT> if i + j + k == x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
from heapq import heapify , heappush , heappop <NEWLINE> from heapq import _heapify_max , _heappop_max <NEWLINE> <NL> def _heappush_max ( heap , item ) : <NEWLINE> <INDENT> heap . append ( item ) <NEWLINE> heapq . _siftdown_max ( heap , 0 , len ( heap ) - 1 ) <NEWLINE> <NL> <DEDENT> <STRING> <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m , s = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ ] for i in range ( n ) ] <NEWLINE> cl , dl = [ None ] * n , [ None ] * n <NEWLINE> sa = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> u , v , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> edge [ u ] . append ( ( v , b , a ) ) <NEWLINE> edge [ v ] . append ( ( u , b , a ) ) <NEWLINE> sa += a <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> cl [ i ] = c <NEWLINE> dl [ i ] = d <NEWLINE> <DEDENT> dijkstra ( n , s , edge , cl , dl ) <NEWLINE> <NL> <NL> <NL> <DEDENT> def dijkstra ( n , coin , edges , cl , dl ) : <NEWLINE> <INDENT> coin_max = 5000 <NEWLINE> start = 0 <NEWLINE> coin = min ( coin , coin_max ) <NEWLINE> d = [ [ 10 ** 15 ] * ( coin_max + 1 ) for _ in range ( n ) ] <NEWLINE> d [ start ] [ coin ] = 0 <NEWLINE> priority_queue = [ ] <NEWLINE> heappush ( priority_queue , ( 0 , start , coin ) ) <NEWLINE> while priority_queue : <NEWLINE> <INDENT> cost_i , i , coin_i = heappop ( priority_queue ) <NEWLINE> if d [ i ] [ coin_i ] < cost_i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> supplied_coin = coin_i + cl [ i ] <NEWLINE> if supplied_coin <= coin_max and cost_i + dl [ i ] < d [ i ] [ supplied_coin ] : <NEWLINE> <INDENT> d [ i ] [ supplied_coin ] = cost_i + dl [ i ] <NEWLINE> heappush ( priority_queue , ( cost_i + dl [ i ] , i , supplied_coin ) ) <NEWLINE> <DEDENT> for _to , _cost , _coin in edges [ i ] : <NEWLINE> <INDENT> ci = coin_i - _coin <NEWLINE> if coin_i >= _coin and d [ _to ] [ ci ] > cost_i + _cost : <NEWLINE> <INDENT> d [ _to ] [ ci ] = cost_i + _cost <NEWLINE> heappush ( priority_queue , ( cost_i + _cost , _to , ci ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in d [ 1 : ] : <NEWLINE> <INDENT> print ( min ( i ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif ( A <= K ) & ( K <= A + B ) : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - B - A ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if ( N % 2 == 0 ) : <NEWLINE> <INDENT> N = int ( N / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N = int ( N / 2 ) + 1 <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if ( a [ ( 2 * i - 1 ) - 1 ] % 2 == 1 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> <NL> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 2 * x / ( a * b ) <NEWLINE> <NL> if c <= a : <NEWLINE> <INDENT> ans = 90 - math . degrees ( math . atan ( c / b ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> d = 2 * ( a ** 2 * b - x ) / a ** 2 <NEWLINE> <NL> if d == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 90 - math . degrees ( math . atan ( a / d ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def solve ( N , A , S ) : <NEWLINE> <INDENT> dp = [ ] <NEWLINE> for i in reversed ( range ( N ) ) : <NEWLINE> <INDENT> x = A [ i ] <NEWLINE> for v in dp : <NEWLINE> <INDENT> x = min ( x , v ^ x ) <NEWLINE> <DEDENT> if x > 0 : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> dp . append ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> T = int ( input ( ) ) <NEWLINE> ans = [ None ] * T <NEWLINE> for i in range ( T ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = input ( ) <NEWLINE> ans [ i ] = solve ( N , A , S ) <NEWLINE> <DEDENT> for v in ans : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def insertionSort ( nums , n , g ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> i = g <NEWLINE> while i < n : <NEWLINE> <INDENT> v = nums [ i ] <NEWLINE> j = i - g <NEWLINE> while 0 <= j and v < nums [ j ] : <NEWLINE> <INDENT> nums [ j + g ] = nums [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> nums [ j + g ] = v <NEWLINE> i += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def shellSort ( nums , n ) : <NEWLINE> <INDENT> g = [ ] <NEWLINE> val = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> val = 3 * val + 1 <NEWLINE> if n < val : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> g . append ( val ) <NEWLINE> <NL> <DEDENT> g . reverse ( ) <NEWLINE> m = len ( g ) <NEWLINE> print ( m ) <NEWLINE> print ( <STRING> . join ( map ( str , g ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> cnt += insertionSort ( nums , n , g [ i ] ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> n = int ( sys . stdin . readline ( ) ) <NEWLINE> nums = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> nums . append ( int ( sys . stdin . readline ( ) ) ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> shellSort ( nums , n ) <NEWLINE> print ( <STRING> . join ( map ( str , nums ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + [ int ( j ) for j in input ( ) . split ( ) ] <NEWLINE> l = [ - 1 ] * ( n + 1 ) <NEWLINE> ll = [ ] <NEWLINE> i = 1 <NEWLINE> idx = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if l [ i ] == - 1 : <NEWLINE> <INDENT> l [ i ] = idx <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ll . append ( i ) <NEWLINE> break <NEWLINE> <DEDENT> ll . append ( i ) <NEWLINE> i = a [ i ] <NEWLINE> idx += 1 <NEWLINE> <NL> <DEDENT> p = ll [ - 1 ] <NEWLINE> nl = ll [ l [ p ] : - 1 ] <NEWLINE> ml = ll [ : l [ p ] ] <NEWLINE> n , m = len ( nl ) , len ( ml ) <NEWLINE> if k < m : <NEWLINE> <INDENT> print ( ml [ k ] ) <NEWLINE> <DEDENT> elif nl == [ ] : <NEWLINE> <INDENT> print ( p ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( nl [ ( k - m ) % n ] ) <NEWLINE> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> a = list ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> lst = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> lst [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( lst [ i ] ) <NEWLINE> <DEDENT>
<NL> <NL> <NL> <NL> def lsc ( str1 , str2 ) : <NEWLINE> <INDENT> table1 = [ 0 ] * ( len ( str2 ) + 1 ) <NEWLINE> for i in range ( len ( str1 ) ) : <NEWLINE> <INDENT> table2 = table1 [ : ] <NEWLINE> for j in range ( len ( str2 ) ) : <NEWLINE> <INDENT> if ( str1 [ i ] == str2 [ j ] ) : <NEWLINE> <INDENT> table1 [ j + 1 ] = table2 [ j ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( table1 [ j + 1 ] < table1 [ j ] ) : <NEWLINE> <INDENT> table1 [ j + 1 ] = table1 [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return table1 [ - 1 ] <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> for loop in range ( n ) : <NEWLINE> <INDENT> str1 = input ( ) <NEWLINE> str2 = input ( ) <NEWLINE> print ( lsc ( str1 , str2 ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> if arr [ 0 ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> acum = [ arr [ 0 ] ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> acum . append ( acum [ - 1 ] + arr [ i ] ) <NEWLINE> <DEDENT> b = [ 0 ] * n <NEWLINE> b [ 0 ] = 1 - arr [ 0 ] <NEWLINE> b [ 0 ] = min ( b [ 0 ] , acum [ n ] - acum [ 0 ] ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> b [ i ] = 2 * b [ i - 1 ] - arr [ i ] <NEWLINE> b [ i ] = min ( b [ i ] , acum [ n ] - acum [ i ] ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if b [ i ] <= 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if b [ i ] <= 30 and arr [ i + 1 ] > 2 ** b [ i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> ans = sum ( arr ) + sum ( b ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> R = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> G = [ 0 ] * ( N + 1 ) <NEWLINE> Z = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> def grp ( R , grpid , i , G , Z ) : <NEWLINE> <INDENT> stack = [ i ] <NEWLINE> while len ( stack ) > 0 : <NEWLINE> <INDENT> k = stack . pop ( ) <NEWLINE> if G [ k ] > 0 : continue <NEWLINE> G [ k ] = grpid <NEWLINE> Z [ grpid ] += 1 <NEWLINE> for l in range ( len ( R [ k ] ) ) : <NEWLINE> <INDENT> stack . append ( R [ k ] [ l ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> R [ a ] . append ( b ) <NEWLINE> R [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> grpid = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if G [ i ] > 0 : continue <NEWLINE> grpid += 1 <NEWLINE> grp ( R , grpid , i , G , Z ) <NEWLINE> <NL> <DEDENT> Z . sort ( reverse = True ) <NEWLINE> print ( Z [ 0 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_a = 0 <NEWLINE> sum_i = sum ( a ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> sum_i -= a [ i ] <NEWLINE> sum_a += ( a [ i ] * sum_i ) <NEWLINE> <NL> <DEDENT> print ( sum_a % ( ( 10 ** 9 ) + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ 0 ] * n <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> b [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in b : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = set ( ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s in L : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L . add ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( L ) ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> <NL> print ( <STRING> . format ( r ** 2 * math . pi , 2 * r * math . pi ) ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> flag = True <NEWLINE> for j in range ( 2 , int ( math . sqrt ( num ) ) + 1 ) : <NEWLINE> <INDENT> if num % j == 0 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def execute ( X , K , D ) : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> if X > 0 : <NEWLINE> <INDENT> X -= D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X += D <NEWLINE> <NL> <DEDENT> <DEDENT> return abs ( X ) <NEWLINE> <NL> <DEDENT> def execute2 ( X , K , D ) : <NEWLINE> <INDENT> T = int ( abs ( X ) / D ) <NEWLINE> if X > 0 : <NEWLINE> <INDENT> if K < T : <NEWLINE> <INDENT> return X - K * D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Y = X - T * D <NEWLINE> if ( K - T ) % 2 == 0 : <NEWLINE> <INDENT> return Y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return D - Y <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if K < T : <NEWLINE> <INDENT> return ( X + K * D ) * - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Y = X + T * D <NEWLINE> if ( K - T ) % 2 == 0 : <NEWLINE> <INDENT> return - 1 * Y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return D + Y <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( execute2 ( X , K , D ) ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . root = [ - 1 ] * ( n + 1 ) <NEWLINE> self . rank = [ 0 ] * ( n + 1 ) <NEWLINE> <DEDENT> def FindRoot ( self , x ) : <NEWLINE> <INDENT> if self . root [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . root [ x ] = self . FindRoot ( self . root [ x ] ) <NEWLINE> return self . root [ x ] <NEWLINE> <DEDENT> <DEDENT> def Unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . FindRoot ( x ) <NEWLINE> y = self . FindRoot ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . rank [ x ] > self . rank [ y ] : <NEWLINE> <INDENT> self . root [ x ] += self . root [ y ] <NEWLINE> self . root [ y ] = x <NEWLINE> <DEDENT> elif self . rank [ x ] <= self . rank [ y ] : <NEWLINE> <INDENT> self . root [ y ] += self . root [ x ] <NEWLINE> self . root [ x ] = y <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ y ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def isSameGroup ( self , x , y ) : <NEWLINE> <INDENT> return self . FindRoot ( x ) == self . FindRoot ( y ) <NEWLINE> <DEDENT> def Count ( self , x ) : <NEWLINE> <INDENT> return - self . root [ self . FindRoot ( x ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> cost = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if n == 2 : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> print ( cost [ 0 ] + cost [ 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if m == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> edges = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for a , b in edges : <NEWLINE> <INDENT> uf . Unite ( a , b ) <NEWLINE> <DEDENT> isolates = set ( ) <NEWLINE> isolates_cnt = 0 <NEWLINE> groups = set ( ) <NEWLINE> groups_cnt = 2 <NEWLINE> roots = [ ] <NEWLINE> qs = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> root = uf . FindRoot ( i ) <NEWLINE> cnt = uf . Count ( i ) <NEWLINE> if cnt == 1 : <NEWLINE> <INDENT> isolates_cnt += 1 <NEWLINE> isolates . add ( root ) <NEWLINE> heapq . heappush ( qs [ root ] , ( cost [ i ] , i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if root not in groups : <NEWLINE> <INDENT> groups_cnt += cnt - 2 <NEWLINE> roots . append ( ( root , cnt ) ) <NEWLINE> <DEDENT> groups . add ( root ) <NEWLINE> heapq . heappush ( qs [ root ] , ( cost [ i ] , i ) ) <NEWLINE> <DEDENT> <DEDENT> if groups_cnt < isolates_cnt : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> roots = sorted ( roots , reverse = True , key = lambda x : x [ 1 ] ) <NEWLINE> root = roots [ 0 ] [ 0 ] <NEWLINE> for tmp_root , _ in roots [ 1 : ] : <NEWLINE> <INDENT> cv , v = heapq . heappop ( qs [ root ] ) <NEWLINE> cu , u = heapq . heappop ( qs [ tmp_root ] ) <NEWLINE> ans += ( cv + cu ) <NEWLINE> while len ( qs [ tmp_root ] ) != 0 : <NEWLINE> <INDENT> tc , tv = heapq . heappop ( qs [ tmp_root ] ) <NEWLINE> heapq . heappush ( qs [ root ] , ( tc , tv ) ) <NEWLINE> <DEDENT> <DEDENT> for tmp_root in isolates : <NEWLINE> <INDENT> cv , v = heapq . heappop ( qs [ root ] ) <NEWLINE> cu , u = heapq . heappop ( qs [ tmp_root ] ) <NEWLINE> ans += ( cv + cu ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> def yn ( b ) : <NEWLINE> <INDENT> print ( <STRING> if b == 1 else <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> readline = sys . stdin . readline <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> n = int ( readline ( ) ) <NEWLINE> ss = readline ( ) . rstrip ( ) <NEWLINE> j = len ( ss ) <NEWLINE> ans = 0 <NEWLINE> if j == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> for i in range ( len ( ss ) ) : <NEWLINE> <INDENT> if ss [ i ] == <STRING> : <NEWLINE> <INDENT> j -= 1 <NEWLINE> if j >= 0 : <NEWLINE> <INDENT> while ss [ j ] != <STRING> : <NEWLINE> <INDENT> j -= 1 <NEWLINE> if j < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if j > i : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> return <NEWLINE> <NL> <DEDENT> if <STRING> not in globals ( ) : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> count = 0 <NEWLINE> min_price = 0 <NEWLINE> while count < k : <NEWLINE> <COMMENT> <NL> <INDENT> total = min_price <NEWLINE> for i in range ( len ( lst ) ) : <NEWLINE> <INDENT> total += lst [ i ] <NEWLINE> <COMMENT> <NL> if i == 0 : <NEWLINE> <INDENT> min_price = total <NEWLINE> min_index = i <NEWLINE> <DEDENT> elif total < min_price : <NEWLINE> <INDENT> min_price = total <NEWLINE> min_index = i <NEWLINE> <DEDENT> total -= lst [ i ] <NEWLINE> <DEDENT> lst . pop ( min_index ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( min_price ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in list ( range ( 1 , H + 1 , 1 ) ) : <NEWLINE> <INDENT> for i in list ( range ( 1 , W + 1 , 1 ) ) : <NEWLINE> <INDENT> if i == W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import numpy <NEWLINE> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> A = numpy . array ( [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( N ) ] ) <NEWLINE> ans = 10 ** 8 <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> i = format ( i , <STRING> ) . zfill ( N ) <NEWLINE> check = numpy . array ( [ 0 ] * ( M + 1 ) ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if i [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> check += A [ j ] [ 0 : ] <NEWLINE> <DEDENT> if all ( check [ m ] >= X for m in range ( 1 , M + 1 ) ) : <NEWLINE> <INDENT> ans = min ( ans , check [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == 10 ** 8 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> t = 0 <NEWLINE> <COMMENT> <NL> for x in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> t += x <NEWLINE> <COMMENT> <NL> <DEDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , k + 1 ) : <NEWLINE> <INDENT> t += 6 * math . gcd ( a , b ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b + 1 , k + 1 ) : <NEWLINE> <INDENT> d = math . gcd ( a , b ) <NEWLINE> t += 6 * math . gcd ( d , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
from itertools import combinations_with_replacement as combr <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b , c , d = [ 0 ] * Q , [ 0 ] * Q , [ 0 ] * Q , [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for pair in combr ( range ( 1 , M + 1 ) , N ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> pair = list ( pair ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> if ( pair [ b [ i ] - 1 ] - pair [ a [ i ] - 1 ] ) == c [ i ] : <NEWLINE> <INDENT> tmp += d [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , tmp ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> tree = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> createHeap ( n ) <NEWLINE> print ( <STRING> , <STRING> . join ( map ( str , tree ) ) ) <NEWLINE> <NL> <DEDENT> def createHeap ( x ) : <NEWLINE> <INDENT> for i in range ( ( x - 1 ) // 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> maxHeap ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> def maxHeap ( i ) : <NEWLINE> <INDENT> if i * 2 + 1 >= n : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> tmp = i * 2 + 1 <NEWLINE> <NL> if i * 2 + 2 < n : <NEWLINE> <INDENT> if tree [ i * 2 + 1 ] < tree [ i * 2 + 2 ] : <NEWLINE> <INDENT> tmp = i * 2 + 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if tree [ i ] < tree [ tmp ] : <NEWLINE> <INDENT> tree [ i ] , tree [ tmp ] = tree [ tmp ] , tree [ i ] <NEWLINE> maxHeap ( tmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> nb = n // b <NEWLINE> <NL> <COMMENT> <NL> if n < b : <NEWLINE> <INDENT> xmax = a * n // b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xmax = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> xb = nb - 1 <NEWLINE> xv = ( a * xb * b + a * ( b - 1 ) ) // b - a * xb <NEWLINE> xmax = max ( xmax , xv ) <NEWLINE> xb = nb <NEWLINE> xv = ( a * xb * b + a * n % b ) // b - a * xb <NEWLINE> xmax = max ( xmax , xv ) <NEWLINE> <NL> <DEDENT> print ( xmax ) <NEWLINE>
import heapq <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> I = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> t , d = map ( int , input ( ) . split ( ) ) <NEWLINE> I . append ( ( d , t ) ) <NEWLINE> <NL> <DEDENT> I . sort ( reverse = True ) <NEWLINE> <NL> <COMMENT> <NL> h_d = [ ] <NEWLINE> <COMMENT> <NL> h_a = [ ] <NEWLINE> <NL> wk = 0 <NEWLINE> kind = 0 <NEWLINE> <COMMENT> <NL> ap = set ( ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d , t = I [ i ] <NEWLINE> wk += d <NEWLINE> if t not in ap : <NEWLINE> <INDENT> ap . add ( t ) <NEWLINE> kind += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> heapq . heappush ( h_d , ( d , t ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( K , N ) : <NEWLINE> <INDENT> d , t = I [ i ] <NEWLINE> if t not in ap : <NEWLINE> <INDENT> ap . add ( t ) <NEWLINE> <COMMENT> <NL> heapq . heappush ( h_a , ( ( - 1 ) * d , t ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = wk + kind ** 2 <NEWLINE> while len ( h_d ) > 0 and len ( h_a ) > 0 : <NEWLINE> <INDENT> d1 , t1 = heapq . heappop ( h_d ) <NEWLINE> d2 , t2 = heapq . heappop ( h_a ) <NEWLINE> d2 = ( - 1 ) * d2 <NEWLINE> wk = wk - d1 + d2 <NEWLINE> kind += 1 <NEWLINE> ans = max ( ans , wk + kind ** 2 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > ( 10 ** 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> S . append ( x ) <NEWLINE> <NL> <DEDENT> print ( len ( collections . Counter ( S ) ) ) <NEWLINE>
from sys import stdin , maxsize <NEWLINE> <NL> <NL> def stdinput ( ) : <NEWLINE> <INDENT> return stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( stdinput ( ) ) <NEWLINE> * A , = map ( int , stdinput ( ) . split ( <STRING> ) ) <NEWLINE> o = mergeSort ( A , 0 , n ) <NEWLINE> <NL> print ( * A ) <NEWLINE> print ( o ) <NEWLINE> <NL> <DEDENT> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> L = A [ left : mid ] <NEWLINE> R = A [ mid : right ] <NEWLINE> <NL> cap = maxsize <NEWLINE> L . append ( cap ) <NEWLINE> R . append ( cap ) <NEWLINE> <NL> i = j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> return i + j <NEWLINE> <NL> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> o = 0 <NEWLINE> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> o += mergeSort ( A , left , mid ) <NEWLINE> o += mergeSort ( A , mid , right ) <NEWLINE> o += merge ( A , left , mid , right ) <NEWLINE> <DEDENT> return o <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
import math <NEWLINE> <NL> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b . replace ( <STRING> , <STRING> ) ) <NEWLINE> ans = str ( a * b ) <NEWLINE> <NL> if len ( ans ) > 2 : <NEWLINE> <INDENT> print ( int ( ans [ : - 2 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( ( i , j ) for i , j in enumerate ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> dictL = { } <NEWLINE> dictR = { } <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l , r = A [ i ] [ 1 ] + A [ i ] [ 0 ] , A [ i ] [ 0 ] - A [ i ] [ 1 ] <NEWLINE> if l not in dictL : <NEWLINE> <INDENT> dictL [ l ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dictL [ l ] += 1 <NEWLINE> <DEDENT> if r not in dictR : <NEWLINE> <INDENT> dictR [ r ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dictR [ r ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in dictL . keys ( ) : <NEWLINE> <INDENT> if i in dictR . keys ( ) : <NEWLINE> <INDENT> ans += dictL [ i ] * dictR [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> oper = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> dic = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] in dic : <NEWLINE> <INDENT> dic [ a [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ a [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> res = sum ( a ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = oper [ i ] <NEWLINE> if b in dic : <NEWLINE> <INDENT> bCount = dic [ b ] <NEWLINE> del ( dic [ b ] ) <NEWLINE> if c in dic : <NEWLINE> <INDENT> dic [ c ] += bCount <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ c ] = bCount <NEWLINE> <NL> <DEDENT> dif = c - b <NEWLINE> <NL> res += dif * bCount <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> ma = np . zeros ( ( 19 , 19 ) , dtype = np . int ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> aa = input ( ) . split ( <STRING> ) <NEWLINE> a2 , a5 = 0 , 0 <NEWLINE> if len ( aa ) == 1 : <NEWLINE> <INDENT> aaa = int ( aa [ 0 ] ) <NEWLINE> a2 , a5 = 9 , 9 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> aaa = int ( aa [ 0 ] ) * 10 ** 9 <NEWLINE> aaa += int ( aa [ 1 ] ) * 10 ** ( 9 - len ( aa [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> while aaa % 2 == 0 : <NEWLINE> <INDENT> a2 += 1 <NEWLINE> aaa = aaa // 2 <NEWLINE> <DEDENT> while aaa % 5 == 0 : <NEWLINE> <INDENT> a5 += 1 <NEWLINE> aaa = aaa // 5 <NEWLINE> <NL> <DEDENT> a2 , a5 = min ( a2 , 18 ) , min ( a5 , 18 ) <NEWLINE> <NL> oa2 , oa5 = 18 - a2 , 18 - a5 <NEWLINE> ans += ma [ oa2 , oa5 ] <NEWLINE> <NL> ma [ : a2 + 1 , : a5 + 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
num = input ( ) . split ( ) <NEWLINE> print ( <STRING> . join ( map ( str , sorted ( num ) ) ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a_count = 0 <NEWLINE> d , r = divmod ( n , a + b ) <NEWLINE> a_count += a * d <NEWLINE> if r > a : <NEWLINE> <INDENT> a_count += a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_count += r <NEWLINE> <DEDENT> print ( a_count ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N = int ( input ( ) . rstrip ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> l = max ( a ) + 1 <NEWLINE> cnt = [ 0 ] * l <NEWLINE> for i in a : <NEWLINE> <INDENT> for j in range ( i , l , i ) : cnt [ j ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if cnt [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> def sum_dict ( d ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> for k , v in d . items ( ) : <NEWLINE> <INDENT> num += k * v <NEWLINE> <DEDENT> return num <NEWLINE> <NL> <NL> <DEDENT> def create_dict ( A ) : <NEWLINE> <INDENT> d = { } <NEWLINE> for a in A : <NEWLINE> <INDENT> if d . get ( a ) is None : <NEWLINE> <INDENT> d [ a ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ a ] += 1 <NEWLINE> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> BC . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> d = create_dict ( A ) <NEWLINE> <NL> ans = sum_dict ( d ) <NEWLINE> for b , c in BC : <NEWLINE> <INDENT> db = d . get ( b ) <NEWLINE> if db is None : <NEWLINE> <INDENT> db = 0 <NEWLINE> <DEDENT> if d . get ( c ) is None : <NEWLINE> <INDENT> d [ c ] = 0 <NEWLINE> <DEDENT> d [ c ] += db <NEWLINE> d [ b ] = 0 <NEWLINE> <NL> ans += ( c - b ) * db <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 10 ) : <NEWLINE> <INDENT> a = S . find ( str ( i ) ) <NEWLINE> if a == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> b = S . find ( str ( j ) , a + 1 ) <NEWLINE> if b == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> c = S . find ( str ( k ) , b + 1 ) <NEWLINE> if c != - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from functools import reduce <NEWLINE> from itertools import starmap <NEWLINE> from operator import xor , mul <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) ) ) <NEWLINE> <NL> A = [ abs ( x - y ) for x , y in zip ( A , A [ 1 : ] ) ] <NEWLINE> n = len ( A ) <NEWLINE> <COMMENT> <NL> coef = [ ( ( n - 1 ) & k ) == k for k in range ( n ) ] <NEWLINE> if 1 in A : <NEWLINE> <INDENT> B = [ x % 2 for x in A ] <NEWLINE> ans = reduce ( xor , starmap ( mul , zip ( B , coef ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = [ x // 2 for x in A ] <NEWLINE> ans = reduce ( xor , starmap ( mul , zip ( B , coef ) ) ) * 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , m , s = map ( int , input ( ) . split ( ) ) <NEWLINE> uvab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> cd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for u , v , a , b in uvab : <NEWLINE> <INDENT> g [ u - 1 ] . append ( ( v - 1 , a , b ) ) <NEWLINE> g [ v - 1 ] . append ( ( u - 1 , a , b ) ) <NEWLINE> <DEDENT> import heapq <NEWLINE> inf = pow ( 10 , 21 ) <NEWLINE> max_s = 50 * 50 <NEWLINE> dp = [ [ inf ] * ( max_s + 1 ) for _ in range ( n ) ] <NEWLINE> kakutei = [ [ 0 ] * ( max_s + 1 ) for _ in range ( n ) ] <NEWLINE> dp [ 0 ] [ min ( s , max_s ) ] = 0 <NEWLINE> todo = [ [ 0 , 0 , min ( s , max_s ) ] ] <COMMENT> <NEWLINE> heapq . heapify ( todo ) <NEWLINE> flgs = [ 0 ] * n <NEWLINE> flg = 0 <NEWLINE> ans = [ inf ] * n <NEWLINE> while flg < n : <NEWLINE> <INDENT> _ , v , i = heapq . heappop ( todo ) <NEWLINE> if kakutei [ v ] [ i ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> kakutei [ v ] [ i ] = 1 <NEWLINE> if flgs [ v ] == 0 : <NEWLINE> <INDENT> flg += 1 <NEWLINE> flgs [ v ] = 1 <NEWLINE> <DEDENT> c , d = cd [ v ] <NEWLINE> ans [ v ] = min ( ans [ v ] , _ ) <NEWLINE> <COMMENT> <NL> j = min ( max_s , i + c ) <NEWLINE> if kakutei [ v ] [ j ] == 0 : <NEWLINE> <INDENT> dp [ v ] [ j ] = min ( dp [ v ] [ j ] , dp [ v ] [ i ] + d ) <NEWLINE> heapq . heappush ( todo , [ dp [ v ] [ j ] , v , j ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> l = g [ v ] <NEWLINE> for u , a , b in l : <NEWLINE> <INDENT> if i - a >= 0 and kakutei [ u ] [ i - a ] == 0 : <NEWLINE> <INDENT> dp [ u ] [ i - a ] = min ( dp [ u ] [ i - a ] , dp [ v ] [ i ] + b ) <NEWLINE> heapq . heappush ( todo , [ dp [ u ] [ i - a ] , u , i - a ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * ans [ 1 : ] , sep = <STRING> ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = [ 0 ] * 9 <NEWLINE> for i in a : <NEWLINE> <INDENT> x = min ( i // 400 , 8 ) <NEWLINE> if x >= 8 : <NEWLINE> <INDENT> cnt [ 8 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ x ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if sum ( cnt [ : 8 ] ) == 0 : <NEWLINE> <INDENT> l = 1 <NEWLINE> r = cnt [ 8 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = sum ( cnt [ : 8 ] ) <NEWLINE> r = l + cnt [ 8 ] <NEWLINE> <DEDENT> print ( l , r ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def solve ( * args : str ) -> str : <NEWLINE> <INDENT> n = int ( args [ 0 ] ) <NEWLINE> A = list ( map ( int , args [ 1 ] . split ( ) ) ) <NEWLINE> <NL> if 0 < A [ 0 ] : <NEWLINE> <INDENT> return <STRING> if n == 0 and A [ 0 ] == 1 else <STRING> <NEWLINE> <NL> <DEDENT> R = [ 0 ] * ( n + 1 ) <NEWLINE> R [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> R [ i ] = 2 * ( R [ i - 1 ] - A [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> prev = 0 <NEWLINE> ret = 0 <NEWLINE> for i in range ( n , - 1 , - 1 ) : <NEWLINE> <INDENT> if R [ i ] < A [ i ] : <NEWLINE> <INDENT> ret = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> prev = min ( R [ i ] , A [ i ] + prev ) <NEWLINE> ret += prev <NEWLINE> <NL> <DEDENT> return str ( ret ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( solve ( * ( open ( 0 ) . read ( ) . splitlines ( ) ) ) ) <NEWLINE> <DEDENT>
def merge ( a , left , mid , right ) : <NEWLINE> <INDENT> INF = int ( 1e+11 ) <NEWLINE> l = a [ left : mid ] <NEWLINE> r = a [ mid : right ] <NEWLINE> l . append ( INF ) <NEWLINE> r . append ( INF ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for k in range ( left , right ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if l [ i ] <= r [ j ] : <NEWLINE> <INDENT> a [ k ] = l [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ k ] = r [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def merge_sort ( a , left , right ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> ans += merge_sort ( a , left , mid ) <NEWLINE> ans += merge_sort ( a , mid , right ) <NEWLINE> ans += merge ( a , left , mid , right ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def print_list_split_whitespace ( s ) : <NEWLINE> <INDENT> for x in s [ : - 1 ] : <NEWLINE> <INDENT> print ( x , end = <STRING> ) <NEWLINE> <DEDENT> print ( s [ - 1 ] ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> s = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ans = merge_sort ( s , 0 , len ( s ) ) <NEWLINE> <NL> print_list_split_whitespace ( s ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> heights = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> roads = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> max_heights = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> build_1 = roads [ i ] [ 0 ] - 1 <NEWLINE> build_2 = roads [ i ] [ 1 ] - 1 <NEWLINE> if heights [ build_2 ] > max_heights [ build_1 ] : <NEWLINE> <INDENT> max_heights [ build_1 ] = heights [ build_2 ] <NEWLINE> <DEDENT> if heights [ build_1 ] > max_heights [ build_2 ] : <NEWLINE> <INDENT> max_heights [ build_2 ] = heights [ build_1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if heights [ i ] > max_heights [ i ] : <NEWLINE> <INDENT> sum += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> <COMMENT> <NL> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> r *= i <NEWLINE> if r > 1e18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( - 1 if r > 1e18 else r ) <NEWLINE> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> box = [ ] <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gap = math . gcd ( i , j ) <NEWLINE> if gap == 1 : <NEWLINE> <INDENT> box . append ( 1 * k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gap2 = math . gcd ( gap , l ) <NEWLINE> box . append ( gap2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ( box ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> import os <NEWLINE> import itertools <NEWLINE> import string <NEWLINE> import heapq <NEWLINE> import _collections <NEWLINE> from collections import Counter <NEWLINE> from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from functools import lru_cache <NEWLINE> import bisect <NEWLINE> import re <NEWLINE> import queue <NEWLINE> import decimal <NEWLINE> <NL> <NL> class Scanner ( ) : <NEWLINE> <INDENT> @ staticmethod <NEWLINE> def int ( ) : <NEWLINE> <INDENT> return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def string ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def map_int ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in Scanner . string ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def string_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . string ( ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def int_list_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . map_int ( ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def int_cols_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . int ( ) for i in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> H , W , K = Scanner . map_int ( ) <NEWLINE> S = Scanner . string_list ( H ) <NEWLINE> ans = int ( 1e15 ) <NEWLINE> for i in range ( 1 << ( H - 1 ) ) : <NEWLINE> <INDENT> cut = 0 <NEWLINE> pc = 1 <NEWLINE> whites = [ [ 0 for _ in range ( W ) ] for _ in range ( H ) ] <NEWLINE> for j in range ( H - 1 ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> whites [ cut ] [ w ] += S [ j ] [ w ] == <STRING> <NEWLINE> <DEDENT> if i >> j & 1 : <NEWLINE> <INDENT> cut += 1 <NEWLINE> pc += 1 <NEWLINE> <DEDENT> <DEDENT> for w in range ( W ) : <NEWLINE> <INDENT> whites [ cut ] [ w ] += S [ - 1 ] [ w ] == <STRING> <NEWLINE> <DEDENT> flag = True <NEWLINE> for line in whites : <NEWLINE> <INDENT> for cnt in line : <NEWLINE> <INDENT> if cnt > K : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if not flag : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt = [ 0 for _ in range ( pc ) ] <NEWLINE> for w in range ( W ) : <NEWLINE> <INDENT> flag = True <NEWLINE> for j in range ( pc ) : <NEWLINE> <INDENT> if cnt [ j ] + whites [ j ] [ w ] > K : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if not flag : <NEWLINE> <INDENT> cnt = [ 0 for _ in range ( pc ) ] <NEWLINE> cut += 1 <NEWLINE> <DEDENT> for j in range ( pc ) : <NEWLINE> <INDENT> cnt [ j ] += whites [ j ] [ w ] <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , cut ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> solve ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> if As [ 0 ] == 1 : print ( 1 ) <NEWLINE> else : print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> As_r = As [ : : - 1 ] <NEWLINE> p = As_r [ 0 ] <NEWLINE> <COMMENT> <NL> a_pre = p <NEWLINE> qs = [ p ] <NEWLINE> <COMMENT> <NL> mn = As_r [ 0 ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i , a in enumerate ( As_r [ 1 : ] ) : <NEWLINE> <INDENT> d = min ( n - i - 1 , 50 ) <NEWLINE> p = min ( 2 ** d , p + a ) <NEWLINE> mn = ( mn + 1 ) // 2 + a <NEWLINE> a_pre = a <NEWLINE> qs . append ( p ) <NEWLINE> <NL> <DEDENT> if mn != 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> qs . reverse ( ) <NEWLINE> <COMMENT> <NL> ans = qs [ 0 ] <NEWLINE> cnt = qs [ 0 ] <NEWLINE> <COMMENT> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> qs [ i ] = min ( qs [ i - 1 ] * 2 , 2 * ( qs [ i - 1 ] - As [ i - 1 ] ) , qs [ i ] ) <NEWLINE> <DEDENT> print ( sum ( qs ) ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> H = np . array ( list ( map ( int , readline ( ) . split ( ) ) ) , dtype = int ) <NEWLINE> <NL> dp = np . zeros ( N , dtype = int ) <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ i ] = ( dp [ max ( 0 , i - K ) : i ] + abs ( H [ max ( 0 , i - K ) : i ] - H [ i ] ) ) . min ( ) <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> if k == 1 or len ( s ) == 1 : <NEWLINE> <INDENT> ans = list ( s ) [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = None <NEWLINE> for i , j in enumerate ( list ( s ) ) : <NEWLINE> <INDENT> if i < k - 1 : <NEWLINE> <INDENT> if j != <STRING> : <NEWLINE> <INDENT> ans = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> elif i == k - 1 : <NEWLINE> <INDENT> ans = j <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if n - k > k : <NEWLINE> <INDENT> n_k = ( n - k ) // k <NEWLINE> minv = n - k * n_k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minv = n <NEWLINE> <NL> <DEDENT> def min_x ( x ) : <NEWLINE> <INDENT> minv = x <NEWLINE> for _ in range ( 3 ) : <NEWLINE> <INDENT> if abs ( minv - k ) < abs ( minv ) : <NEWLINE> <INDENT> minv = abs ( minv - k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( minv ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( minv ) <NEWLINE> <NL> <DEDENT> min_x ( minv ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if v [ i ] - c [ i ] >= 1 : <NEWLINE> <INDENT> ans += v [ i ] - c [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> min_value = P [ 0 ] <NEWLINE> cnt = 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if P [ i ] < min_value : <NEWLINE> <INDENT> min_value = P [ i ] <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> n = [ 0 ] * ( n + 1 ) <NEWLINE> maxv = winner = 0 <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> n [ a ] += v <NEWLINE> if v < 0 and a == winner : <NEWLINE> <INDENT> maxv = max ( n ) <NEWLINE> winner = n . index ( maxv ) <NEWLINE> <DEDENT> elif n [ a ] > maxv : <NEWLINE> <INDENT> maxv , winner = n [ a ] , a <NEWLINE> <DEDENT> elif n [ a ] == maxv : <NEWLINE> <INDENT> winner = min ( winner , a ) <NEWLINE> <DEDENT> print ( winner , maxv ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> l = list ( range ( 1 , k + 1 ) ) <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for v in itertools . combinations_with_replacement ( l , 3 ) : <NEWLINE> <INDENT> if v [ 0 ] == v [ 1 ] == v [ 2 ] : <NEWLINE> <INDENT> ans += gcd ( * v ) <NEWLINE> <DEDENT> elif v [ 0 ] == v [ 1 ] : <NEWLINE> <INDENT> ans += gcd ( * v ) * 3 <NEWLINE> <DEDENT> elif v [ 1 ] == v [ 2 ] : <NEWLINE> <INDENT> ans += gcd ( * v ) * 3 <NEWLINE> <DEDENT> elif v [ 0 ] == v [ 2 ] : <NEWLINE> <INDENT> ans += gcd ( * v ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd ( * v ) * 6 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> checker = [ None for i in range ( n ) ] <NEWLINE> checker [ 0 ] = 0 <NEWLINE> num = 0 <NEWLINE> count = 0 <NEWLINE> <NL> flag = 0 <NEWLINE> while flag == 0 and count != k : <NEWLINE> <INDENT> if checker [ lst [ num ] - 1 ] == None : <NEWLINE> <INDENT> checker [ lst [ num ] - 1 ] = count + 1 <NEWLINE> count += 1 <NEWLINE> num = lst [ num ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = 1 <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> remaining = ( k - checker [ lst [ num ] - 1 ] ) % ( count - checker [ lst [ num ] - 1 ] ) <NEWLINE> num = lst [ num ] - 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( remaining ) : <NEWLINE> <INDENT> num = lst [ num ] - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num + 1 ) <NEWLINE>
cards_remain = [ ] <NEWLINE> suit = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> cards_set = [ ] <NEWLINE> output = [ ] <NEWLINE> <NL> count_card = input ( ) <NEWLINE> <NL> for l in range ( int ( count_card ) ) : <NEWLINE> <INDENT> cards_remain . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> for m in suit : <NEWLINE> <INDENT> for n in range ( 13 ) : <NEWLINE> <INDENT> cards_set . append ( m + <STRING> + str ( n + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for p in cards_set : <NEWLINE> <INDENT> if p not in cards_remain : <NEWLINE> <INDENT> output . append ( p ) <NEWLINE> <NL> <DEDENT> <DEDENT> for x in output : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> iteration = len ( S ) - len ( T ) + 1 <NEWLINE> <NL> if T in S : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minimum = len ( T ) <NEWLINE> for i in range ( iteration ) : <NEWLINE> <COMMENT> <NL> <INDENT> s = S [ i : len ( T ) + i ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> count = 0 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if s [ j ] != T [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> minimum = min ( minimum , count ) <NEWLINE> <DEDENT> ans = minimum <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> if l [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= l [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
for i in range ( 10000 ) : <NEWLINE> <INDENT> x = input ( ) . split ( ) <NEWLINE> h = int ( x [ 0 ] ) <NEWLINE> w = int ( x [ 1 ] ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if h % 2 == 0 : <NEWLINE> <NL> <INDENT> if w % 2 == 0 : <NEWLINE> <INDENT> for i in range ( h // 2 ) : <NEWLINE> <INDENT> for i in range ( w // 2 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> for i in range ( w // 2 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> elif w % 2 == 1 : <NEWLINE> <INDENT> for i in range ( h // 2 ) : <NEWLINE> <INDENT> for i in range ( ( w - 1 ) // 2 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( ) <NEWLINE> for i in range ( ( w - 1 ) // 2 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> elif h % 2 == 1 : <NEWLINE> <NL> <INDENT> if w % 2 == 0 : <NEWLINE> <INDENT> for i in range ( ( h - 1 ) // 2 ) : <NEWLINE> <INDENT> for i in range ( w // 2 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> for i in range ( w // 2 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> for i in range ( w // 2 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> print ( ) <NEWLINE> <NL> <DEDENT> elif w % 2 == 1 : <NEWLINE> <INDENT> for i in range ( ( h - 1 ) // 2 ) : <NEWLINE> <INDENT> for i in range ( ( w - 1 ) // 2 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( ) <NEWLINE> for i in range ( ( w - 1 ) // 2 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> for i in range ( ( w - 1 ) // 2 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( ) <NEWLINE> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> value = [ 0 ] <NEWLINE> weight = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> value . append ( v ) <NEWLINE> weight . append ( w ) <NEWLINE> <NL> <DEDENT> dp = [ [ 0 ] * ( W + 3 ) for _ in range ( N + 3 ) ] <NEWLINE> for w in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if weight [ k ] > w : <NEWLINE> <INDENT> dp [ k ] [ w ] = dp [ k - 1 ] [ w ] <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ k ] [ w ] = max ( dp [ k - 1 ] [ w ] , value [ k ] + dp [ k - 1 ] [ w - weight [ k ] ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ N ] [ W ] ) <NEWLINE> <NL>
<COMMENT> <NL> <NL> import io <NEWLINE> import sys <NEWLINE> import math <NEWLINE> <NL> def solve ( ac_lst , l , r ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if l == 1 : <NEWLINE> <INDENT> return ac_lst [ r - 2 ] <NEWLINE> <DEDENT> return ac_lst [ r - 2 ] - ac_lst [ l - 2 ] <NEWLINE> <NL> <NL> <DEDENT> def make_ac_lst ( s ) : <NEWLINE> <INDENT> ac_lst = [ 0 ] * len ( s ) <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> ac_lst [ i ] += ac_lst [ i - 1 ] <NEWLINE> <DEDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ac_lst [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> ac_lst [ - 1 ] = ac_lst [ - 2 ] <NEWLINE> <NL> if _DEB : logd ( <STRING> ) <NEWLINE> return ac_lst <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> <COMMENT> <NL> ans = <STRING> <NEWLINE> ac_lst = make_ac_lst ( s ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += str ( solve ( ac_lst , l , r ) ) + <STRING> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> _DEB = 0 <COMMENT> <NEWLINE> <NL> _INPUT = <STRING> <NEWLINE> _EXPECTED = <STRING> <NEWLINE> <NL> def logd ( str ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if _DEB : print ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> if _DEB : <NEWLINE> <INDENT> sys . stdin = io . StringIO ( _INPUT ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> ans = main ( ) <NEWLINE> <NL> if _DEB : <NEWLINE> <INDENT> print ( ) <NEWLINE> if _EXPECTED . strip ( ) == ans . strip ( ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class Converter : <NEWLINE> <INDENT> d = { <NEWLINE> <INDENT> 1 : { 2 : 3 , 3 : 5 , 4 : 2 , 5 : 4 , } , <NEWLINE> 2 : { 1 : 4 , 3 : 1 , 4 : 6 , 6 : 3 , } , <NEWLINE> 3 : { 1 : 2 , 2 : 6 , 5 : 1 , 6 : 5 , } , <NEWLINE> 4 : { 1 : 5 , 2 : 1 , 5 : 6 , 6 : 2 , } , <NEWLINE> 5 : { 1 : 3 , 3 : 6 , 4 : 1 , 6 : 4 , } , <NEWLINE> 6 : { 2 : 4 , 3 : 2 , 4 : 5 , 5 : 3 , } <NEWLINE> } <NEWLINE> <NL> <DEDENT> def __init__ ( self , s ) : <NEWLINE> <INDENT> l = s . split ( ) <NEWLINE> self . tbl = dict ( zip ( l , range ( 1 , 7 ) ) ) <NEWLINE> self . pip = dict ( zip ( range ( 1 , 7 ) , l ) ) <NEWLINE> <NL> <DEDENT> def __call__ ( self , s ) : <NEWLINE> <INDENT> l , r = s . split ( ) <NEWLINE> print ( self . pip [ self . d [ self . tbl [ l ] ] [ self . tbl [ r ] ] ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> cv = Converter ( input ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> cv ( input ( ) ) <NEWLINE> <DEDENT>
import collections <NEWLINE> from decimal import Decimal <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ Decimal ( input ( ) ) for _ in range ( n ) ] <NEWLINE> a = [ int ( i * 10 ** 9 ) for i in a ] <NEWLINE> MAX = 19 <NEWLINE> p_dict = collections . defaultdict ( int ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> b_cnt = 0 <NEWLINE> while i % 2 == 0 and b_cnt < 18 : <NEWLINE> <INDENT> i //= 2 <NEWLINE> b_cnt += 1 <NEWLINE> <DEDENT> f_cnt = 0 <NEWLINE> while i % 5 == 0 and f_cnt < 18 : <NEWLINE> <INDENT> i //= 5 <NEWLINE> f_cnt += 1 <NEWLINE> <DEDENT> p_dict [ ( b_cnt , f_cnt ) ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for b1 , f1 in p_dict : <NEWLINE> <INDENT> for b2 , f2 in p_dict : <NEWLINE> <INDENT> if b1 + b2 >= 18 and f1 + f2 >= 18 : <NEWLINE> <INDENT> if b1 == b2 and f1 == f2 : <NEWLINE> <INDENT> ans += p_dict [ ( b1 , f1 ) ] * ( p_dict [ ( b2 , f2 ) ] - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += p_dict [ ( b1 , f1 ) ] * p_dict [ ( b2 , f2 ) ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> high = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> af = A [ i ] <NEWLINE> bf = A [ i - 1 ] <NEWLINE> if bf > high : <NEWLINE> <INDENT> high = bf <NEWLINE> <DEDENT> if high > af : <NEWLINE> <INDENT> ans += high - af <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> x = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x ^= a [ i ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( x ^ a [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> li = np . zeros ( n , dtype = np . int ) <NEWLINE> ans = 0 <NEWLINE> i = 1 <NEWLINE> while i < n : <NEWLINE> <INDENT> ans += ( n - 1 ) // i <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ls [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> ans = ans * ls [ i ] <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
t = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> while t : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> ans . append ( s ) <NEWLINE> t = t - 1 <NEWLINE> <DEDENT> ans = set ( ans ) <NEWLINE> print ( len ( ans ) ) <NEWLINE>
from itertools import accumulate <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> B = list ( accumulate ( A ) ) <NEWLINE> <NL> d = 10 ** 9 + 7 <NEWLINE> s = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s += ( A [ i ] * ( B [ - 1 ] - B [ i ] ) ) % d <NEWLINE> <NL> <DEDENT> print ( s % d ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> def cal ( c ) : <NEWLINE> <INDENT> d = [ ] <NEWLINE> while c % 2 == 0 : <NEWLINE> <INDENT> d . append ( 2 ) <NEWLINE> c //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f ** 2 <= c : <NEWLINE> <INDENT> if c % f == 0 : <NEWLINE> <INDENT> d . append ( f ) <NEWLINE> c //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if c != 1 : <NEWLINE> <INDENT> d . append ( c ) <NEWLINE> <DEDENT> return d <NEWLINE> <NL> <DEDENT> c = gcd ( a , b ) <NEWLINE> d = cal ( c ) <NEWLINE> print ( len ( set ( d ) ) + 1 ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> assert N == len ( p ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> abs_list = [ ] <NEWLINE> abs_list2 = list ( range ( - 100 , 100 ) ) <NEWLINE> abs_list2 . sort ( ) <NEWLINE> abs_list2 = sorted ( abs_list2 , key = abs ) <NEWLINE> for i in p : <NEWLINE> <INDENT> abs_list . append ( i - X ) <NEWLINE> <DEDENT> abs_list . sort ( ) <NEWLINE> abs_list = sorted ( abs_list , key = abs ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if abs_list [ i ] != abs_list2 [ i ] : <NEWLINE> <INDENT> print ( X + abs_list2 [ i ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( X + abs_list2 [ N ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans %= ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> tmp = [ 0 for _ in range ( N ) ] <NEWLINE> <COMMENT> <NL> <NL> spot = 1 <NEWLINE> road = [ 1 ] <NEWLINE> tmp [ 0 ] = 1 <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> n_s = A [ spot - 1 ] <NEWLINE> if not tmp [ n_s - 1 ] == 1 : <NEWLINE> <INDENT> road . append ( n_s ) <NEWLINE> tmp [ n_s - 1 ] = 1 <NEWLINE> spot = n_s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> spot = n_s <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> till_loop = road . index ( spot ) <NEWLINE> <COMMENT> <NL> loop = road [ till_loop : ] <NEWLINE> <COMMENT> <NL> cycle_len = len ( road ) - road . index ( spot ) <NEWLINE> <COMMENT> <NL> answer = loop [ ( K - till_loop ) % cycle_len ] <NEWLINE> <NL> print ( answer ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans , saidai , saisyo = 0 , 0 , 0 <NEWLINE> for i in range ( 1 , N + 2 ) : <NEWLINE> <INDENT> saisyo += i - 1 <NEWLINE> saidai += N - i + 1 <NEWLINE> if i >= K : <NEWLINE> <INDENT> ans += ( saidai - saisyo + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> R , G , B = 0 , 0 , 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> G += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = R * G * B <NEWLINE> <NL> for i in range ( 1 , 2000 ) : <NEWLINE> <INDENT> for j in range ( 1 , N - 2 * i + 1 ) : <NEWLINE> <INDENT> if S [ j - 1 ] != S [ j + i - 1 ] : <NEWLINE> <INDENT> if S [ j + 2 * i - 1 ] != S [ j + i - 1 ] : <NEWLINE> <INDENT> if S [ j - 1 ] != S [ j + 2 * i - 1 ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( max ( ans , 0 ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> ans . append ( s ) <NEWLINE> <DEDENT> answer = set ( ans ) <NEWLINE> print ( len ( answer ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a - 1 ] . append ( b - 1 ) <NEWLINE> g [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> c = [ 0 ] * n <NEWLINE> <NL> for j in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> c [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> used = [ 0 ] * n <NEWLINE> used [ 0 ] = 1 <NEWLINE> <NL> def dfs ( x ) : <NEWLINE> <INDENT> cost = c [ x ] <NEWLINE> for nx in g [ x ] : <NEWLINE> <INDENT> if used [ nx ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> used [ nx ] = 1 <NEWLINE> c [ nx ] += cost <NEWLINE> dfs ( nx ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * c ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> if S [ 2 ] == S [ 3 ] and S [ 4 ] == S [ 5 ] : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> st , sp = map ( int , input ( ) . split ( ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> N_List = [ st , sp ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if st > N_List [ 0 ] : <NEWLINE> <INDENT> N_List [ 0 ] = st <NEWLINE> <DEDENT> if sp < N_List [ 1 ] : <NEWLINE> <INDENT> N_List [ 1 ] = sp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( list ( range ( N_List [ 0 ] , N_List [ 1 ] + 1 ) ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> INF = 10 ** 18 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> A . sort ( reverse = True ) <NEWLINE> ans = A [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if A [ i ] > INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if A [ i ] == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = ans * A [ i ] <NEWLINE> if ans > INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> days = [ [ ] for _ in range ( 31 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> hima = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for d in hima [ 1 : ] : <NEWLINE> <INDENT> days [ d ] . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> tos = [ { i } for i in range ( n ) ] <NEWLINE> end = { i for i in range ( n ) } <NEWLINE> for i in range ( 31 ) : <NEWLINE> <INDENT> gather = set ( ) <NEWLINE> for to in days [ i ] : <NEWLINE> <INDENT> gather = gather | tos [ to ] <NEWLINE> <DEDENT> if gather == end : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> for to in days [ i ] : <NEWLINE> <INDENT> tos [ to ] = gather <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> import math <NEWLINE> from collections import defaultdict <NEWLINE> <NL> res = 0 <NEWLINE> value = defaultdict ( int ) <NEWLINE> def isprime ( n ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> m = int ( math . sqrt ( n ) ) + 1 <NEWLINE> for i in range ( 2 , m ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> return 1 <NEWLINE> <DEDENT> if isprime ( x ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> def bprime ( n ) : <NEWLINE> <INDENT> cnt = 2 <NEWLINE> m = int ( math . sqrt ( n ) ) + 1 <NEWLINE> while n != 1 and cnt < m : <NEWLINE> <INDENT> while n % cnt == 0 : <NEWLINE> <INDENT> n //= cnt <NEWLINE> value [ cnt ] += 1 <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> if cnt == m and n != 1 : <NEWLINE> <INDENT> value [ n ] += 1 <NEWLINE> <DEDENT> <DEDENT> def cal ( n ) : <NEWLINE> <INDENT> if n <= 2 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> j = 1 <NEWLINE> cnt = 0 <NEWLINE> while n >= j : <NEWLINE> <INDENT> n -= j <NEWLINE> j += 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <DEDENT> bprime ( x ) <NEWLINE> for key in value . keys ( ) : <NEWLINE> <INDENT> res += cal ( value [ key ] ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
import collections <NEWLINE> p = 2019 <NEWLINE> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> arr = [ int ( s [ i ] ) for i in range ( len ( s ) ) ] <COMMENT> <NEWLINE> if p == 2 or p == 5 : <COMMENT> <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if arr [ i ] % p == 0 : <NEWLINE> <INDENT> ans += i + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> dic = collections . defaultdict ( int ) <NEWLINE> tmp = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <COMMENT> <NEWLINE> <INDENT> tmp += arr [ i ] * pow ( 10 , n - 1 - i , p ) <NEWLINE> tmp %= p <NEWLINE> dic [ tmp ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> rem = 0 <COMMENT> <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> ans += dic [ rem ] <NEWLINE> rem += arr [ i ] * pow ( 10 , n - 1 - i , p ) <COMMENT> <NEWLINE> rem %= p <NEWLINE> dic [ rem ] -= 1 <COMMENT> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> bc = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> bc . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> bc . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> for i in bc : <NEWLINE> <INDENT> if a [ 0 ] < i [ 1 ] : <NEWLINE> <INDENT> for j in range ( i [ 0 ] ) : <NEWLINE> <INDENT> if a [ 0 ] < i [ 1 ] : <NEWLINE> <INDENT> a . append ( i [ 1 ] ) <NEWLINE> del a [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> s = [ str ( sorted ( input ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> cnt = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if s [ i ] in cnt : <NEWLINE> <INDENT> ans += cnt [ s [ i ] ] <NEWLINE> cnt [ s [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ s [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> N = 0 <NEWLINE> k = K * K <NEWLINE> d1 = [ 0 ] * int ( k ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> for b in range ( K ) : <NEWLINE> <INDENT> for c in range ( K ) : <NEWLINE> <INDENT> d1 [ i ] = math . gcd ( ( c + 1 ) , ( b + 1 ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> for a in range ( K ) : <NEWLINE> <INDENT> for x in d1 : <NEWLINE> <INDENT> N += math . gcd ( x , ( a + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> print ( N ) <NEWLINE>
from math import gcd <NEWLINE> from functools import reduce <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> g = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> g += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( g ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
def gcd ( x , y ) : <NEWLINE> <INDENT> while ( x % y != 0 and y % x != 0 ) : <NEWLINE> <INDENT> if ( x > y ) : <NEWLINE> <INDENT> x = x % y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = y % x <NEWLINE> <DEDENT> <DEDENT> if ( x > y ) : <NEWLINE> <INDENT> return y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <DEDENT> <DEDENT> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if ( i == j and j == k ) : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> elif ( i == j or j == k ) : <NEWLINE> <INDENT> ans += gcd ( i , k ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd ( i , gcd ( j , k ) ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 ; <NEWLINE> h = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> h . sort ( reverse = True ) <NEWLINE> h = h [ k : ] <NEWLINE> <NL> if len ( h ) > 0 : <NEWLINE> <INDENT> ans += sum ( h ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> a = [ int ( s ) for s in a ] <NEWLINE> a . sort ( reverse = True ) <NEWLINE> <NL> if a [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> sum *= i <NEWLINE> if sum > 10 ** 18 : <NEWLINE> <INDENT> sum = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> t = sum ( A ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> t -= A [ i ] <NEWLINE> ans += A [ i ] * t % mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> S = input ( ) <NEWLINE> from collections import defaultdict <NEWLINE> amari = defaultdict ( int ) <NEWLINE> cur = 0 <COMMENT> <NEWLINE> keta = 1 <COMMENT> <NEWLINE> for i in range ( len ( S ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> cur += int ( S [ i ] ) * keta <NEWLINE> cur %= 2019 <NEWLINE> keta *= 10 <NEWLINE> keta %= 2019 <NEWLINE> amari [ cur ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> if 0 in amari : <NEWLINE> <INDENT> ans += amari [ 0 ] <NEWLINE> <DEDENT> for n in amari . values ( ) : <NEWLINE> <INDENT> ans += ( n * ( n - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> d = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( c , d ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> if 360 % x == 0 : <NEWLINE> <INDENT> print ( 360 // x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> import math <NEWLINE> gcd = math . gcd ( x , 360 ) <NEWLINE> lcm = ( x * 360 ) // gcd <NEWLINE> print ( lcm // x ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 or x % 10 == 3 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> sys . stdout . write ( str ( i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while x != 0 : <NEWLINE> <INDENT> x = int ( x / 10 ) <NEWLINE> if x % 10 == 3 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> sys . stdout . write ( str ( i ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <NL>
def actual ( X , N , P ) : <NEWLINE> <INDENT> for i in range ( X , - 1 - 1 , - 1 ) : <NEWLINE> <INDENT> if i not in P : <NEWLINE> <INDENT> left = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( X , 101 + 1 ) : <NEWLINE> <INDENT> if i not in P : <NEWLINE> <INDENT> right = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if abs ( left - X ) <= abs ( right - X ) : <NEWLINE> <INDENT> answer = left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = right <NEWLINE> <NL> <DEDENT> return answer <NEWLINE> <NL> <NL> <DEDENT> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> P = [ ] <NEWLINE> print ( actual ( X , N , P ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( actual ( X , N , P ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> s_set = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> order = input ( ) . split ( ) <NEWLINE> if order [ 0 ] == <STRING> : <NEWLINE> <INDENT> s_set . add ( order [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if order [ 1 ] in s_set : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> F = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> d = [ - 1 ] * N <NEWLINE> <NL> <NL> def find ( x ) : <NEWLINE> <INDENT> if d [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> d [ x ] = find ( d [ x ] ) <NEWLINE> return d [ x ] <NEWLINE> <NL> <NL> <DEDENT> def union ( x , y ) : <NEWLINE> <INDENT> x , y = find ( x ) , find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if ( d [ x ] > d [ y ] ) : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> d [ x ] += d [ y ] <NEWLINE> d [ y ] = x <NEWLINE> <NL> <NL> <DEDENT> for f in F : <NEWLINE> <INDENT> union ( f [ 0 ] - 1 , f [ 1 ] - 1 ) <NEWLINE> <DEDENT> print ( - min ( d ) ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> def check ( ) : <NEWLINE> <INDENT> for i in range ( 1000 ) : <NEWLINE> <INDENT> for j in range ( 1000 ) : <NEWLINE> <INDENT> if i ** 5 + j ** 5 == X : <NEWLINE> <INDENT> print ( i , - j ) <NEWLINE> return <NEWLINE> <DEDENT> elif i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> check ( ) <NEWLINE>
NK = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = NK [ 0 ] <NEWLINE> K = NK [ 1 ] <NEWLINE> sumOfAll = 0 <NEWLINE> for howManyWeChoose in range ( K , N + 2 ) : <NEWLINE> <INDENT> until = int ( N * ( N + 1 ) / 2 - ( N - howManyWeChoose ) * ( N - howManyWeChoose + 1 ) / 2 ) <NEWLINE> start = int ( howManyWeChoose * ( howManyWeChoose - 1 ) / 2 ) <NEWLINE> sumOfAll += until - start + 1 <NEWLINE> <DEDENT> print ( sumOfAll % ( 7 + 10 ** 9 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> S = sum ( A ) <NEWLINE> X = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> X += A [ i ] * ( S - A [ i ] ) <NEWLINE> S -= A [ i ] <NEWLINE> if X > 10 ** 9 + 7 : <NEWLINE> <INDENT> X = X % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> <DEDENT> print ( X ) <NEWLINE>
<COMMENT> <NL> <NL> from collections import defaultdict <NEWLINE> <COMMENT> <NL> <NL> V , E = map ( int , input ( ) . split ( ) ) <NEWLINE> D = 0 <NEWLINE> tree = [ ] <NEWLINE> vertices = defaultdict ( set ) <NEWLINE> for i in range ( V ) : <NEWLINE> <INDENT> tree . append ( i ) <COMMENT> <NEWLINE> vertices [ i ] . add ( i ) <NEWLINE> <NL> <DEDENT> edges = [ ] <NEWLINE> for i in range ( E ) : <NEWLINE> <INDENT> s , t , d = map ( int , input ( ) . split ( ) ) <NEWLINE> edges . append ( ( s , t , d ) ) <NEWLINE> <NL> <DEDENT> edges . sort ( key = lambda x : x [ 2 ] ) <NEWLINE> while edges : <NEWLINE> <INDENT> if V == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s , t , d = edges . pop ( 0 ) <NEWLINE> if tree [ s ] != tree [ t ] : <NEWLINE> <INDENT> new = min ( tree [ s ] , tree [ t ] ) <NEWLINE> old = max ( tree [ s ] , tree [ t ] ) <NEWLINE> vertices [ new ] = vertices [ new ] | vertices [ old ] <NEWLINE> for vertex in vertices [ old ] : <NEWLINE> <INDENT> tree [ vertex ] = new <NEWLINE> <NL> <DEDENT> D += d <NEWLINE> V -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( D ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> H , W , K = LI ( ) <NEWLINE> s = [ SS ( ) for _ in range ( H ) ] <NEWLINE> <NL> ans = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> <NL> <COMMENT> <NL> cnt = 1 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> is_first = True <NEWLINE> if s [ i ] . count ( <STRING> ) >= 1 : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> if is_first : <NEWLINE> <INDENT> is_first = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ans [ i ] [ j ] = cnt <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> first_strawberry_row = - 1 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> if s [ i ] . count ( <STRING> ) >= 1 : <NEWLINE> <INDENT> first_strawberry_row = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( first_strawberry_row , H ) : <NEWLINE> <INDENT> if s [ i ] . count ( <STRING> ) == 0 : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> ans [ i ] [ j ] = ans [ i - 1 ] [ j ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( first_strawberry_row ) : <NEWLINE> <INDENT> r = first_strawberry_row - 1 - i <NEWLINE> if s [ r ] . count ( <STRING> ) == 0 : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> ans [ r ] [ j ] = ans [ r + 1 ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( * i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> dct = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if not s in dct : <NEWLINE> <INDENT> dct [ s ] = 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> dct [ s ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> m = max ( dct . values ( ) ) <NEWLINE> for s in sorted ( k for k in dct if dct [ k ] == m ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S [ 1 - 1 ] == <STRING> : <NEWLINE> <INDENT> if S [ 2 - 1 ] == <STRING> : <NEWLINE> <INDENT> if S [ 3 - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> elif S [ 2 - 1 ] == <STRING> : <NEWLINE> <INDENT> if S [ 3 - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> elif S [ 3 - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( K + 1 ) : <NEWLINE> <INDENT> if S - i > 2 * K : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif S - i < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif 0 <= S - i <= K : <NEWLINE> <INDENT> ans += S - i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 2 * K + i - S + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <COMMENT> <NEWLINE> K = 2 * ( 10 ** 5 ) <NEWLINE> g1 = [ 1 , 1 ] <COMMENT> <NEWLINE> g2 = [ 1 , 1 ] <COMMENT> <NEWLINE> inverse = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , K + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( n ) <NEWLINE> nCk = n <NEWLINE> R = list ( ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( L ) <NEWLINE> nikai = c . most_common ( ) [ 0 ] [ 0 ] <COMMENT> <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if L [ i ] == nikai : <NEWLINE> <INDENT> R . append ( i ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> k = n - R [ 1 ] + R [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> nCk = cmb ( n + 1 , i + 1 , mod ) <NEWLINE> a = cmb ( k , i , mod ) <NEWLINE> print ( ( nCk - a ) % mod ) <NEWLINE> <DEDENT> print ( 1 ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N >= B : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> ans = ( ( A * x ) // B ) - ( A * ( x // B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = N <NEWLINE> ans = ( ( A * x ) // B ) - ( A * ( x // B ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> field = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> dist = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> dx = [ 1 , 0 , - 1 , 0 ] <NEWLINE> dy = [ 0 , 1 , 0 , - 1 ] <NEWLINE> mx = 0 <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if field [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> dist [ h ] [ w ] = 0 <NEWLINE> que = deque ( [ ] ) <NEWLINE> que . append ( [ h , w ] ) <NEWLINE> while que != deque ( [ ] ) : <NEWLINE> <INDENT> u , v = que . popleft ( ) <NEWLINE> for dir in range ( 4 ) : <NEWLINE> <INDENT> nu = u + dx [ dir ] <NEWLINE> nv = v + dy [ dir ] <NEWLINE> <NL> if ( nu < 0 ) or ( nu >= H ) or ( nv < 0 ) or ( nv >= W ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if field [ nu ] [ nv ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if dist [ nu ] [ nv ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> que . append ( [ nu , nv ] ) <NEWLINE> dist [ nu ] [ nv ] = dist [ u ] [ v ] + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if mx < dist [ i ] [ j ] : <NEWLINE> <INDENT> mx = dist [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( mx ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = i - l [ i ] <NEWLINE> if a in dic . keys ( ) : <NEWLINE> <INDENT> dic [ a ] . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ a ] = [ i ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a = i + l [ i ] <NEWLINE> if a in dic . keys ( ) : <NEWLINE> <INDENT> s = dic [ a ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> k = bisect . bisect_right ( s , i ) <NEWLINE> ans += ( len ( s ) - k ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , a = int ( input ( ) ) , list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( a ) <NEWLINE> d = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> d [ c ] += d [ b ] <NEWLINE> s += ( c - b ) * d [ b ] <NEWLINE> print ( s ) <NEWLINE> d [ b ] = 0 <NEWLINE> <DEDENT>
from copy import deepcopy <NEWLINE> def main ( ) : <NEWLINE> <INDENT> global flags , edges <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> flags = { e : [ n + 1 , n + 1 ] for e in range ( 1 , n + 1 ) } <NEWLINE> flags [ 1 ] [ 1 ] = 0 <NEWLINE> edges = { e : set ( ) for e in range ( 1 , n + 1 ) } <NEWLINE> edge_list = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a ] . add ( b ) <NEWLINE> edges [ b ] . add ( a ) <NEWLINE> edge_list . append ( ( a , b ) ) <NEWLINE> <NL> <DEDENT> distance = 1 <NEWLINE> node_next = list ( edges [ 1 ] ) <NEWLINE> node_next_next = [ ] <NEWLINE> while node_next : <NEWLINE> <INDENT> for next in node_next : <NEWLINE> <INDENT> if flags [ next ] [ 1 ] > distance : <NEWLINE> <INDENT> flags [ next ] [ 1 ] = distance <NEWLINE> node_next_next += edges [ next ] <NEWLINE> <DEDENT> <DEDENT> node_next = deepcopy ( node_next_next ) <NEWLINE> node_next_next = [ ] <NEWLINE> distance += 1 <NEWLINE> <DEDENT> for edge in edge_list : <NEWLINE> <INDENT> e1 = edge [ 0 ] <NEWLINE> e2 = edge [ 1 ] <NEWLINE> if flags [ e1 ] [ 1 ] == flags [ e2 ] [ 1 ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif flags [ e1 ] [ 1 ] > flags [ e2 ] [ 1 ] : <NEWLINE> <INDENT> flags [ e1 ] [ 0 ] = min ( flags [ e1 ] [ 0 ] , e2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flags [ e2 ] [ 0 ] = min ( flags [ e2 ] [ 0 ] , e1 ) <NEWLINE> <DEDENT> <DEDENT> result = [ flags [ f ] [ 1 ] < ( n + 1 ) for f in flags if f > 1 ] <NEWLINE> if not all ( result ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i1 in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( flags [ i1 ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> white = s . count ( <STRING> ) <NEWLINE> ans , black = white , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> white -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> black += 1 <NEWLINE> <DEDENT> tmp = black + white <NEWLINE> if tmp < ans : <NEWLINE> <INDENT> ans = tmp <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> MAX = 10 ** 18 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = 1 <NEWLINE> for a in reversed ( sorted ( A ) ) : <NEWLINE> <INDENT> if a == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> res *= a <NEWLINE> if res > MAX : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
def swap ( A , i , j ) : <NEWLINE> <INDENT> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> return A <NEWLINE> <NL> <DEDENT> def partition ( A , p = 0 , r = None ) : <NEWLINE> <INDENT> if r is None : <NEWLINE> <INDENT> r = len ( A ) - 1 <NEWLINE> <DEDENT> x = A [ r ] <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if A [ j ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> swap ( A , i , j ) <NEWLINE> <DEDENT> <DEDENT> swap ( A , i + 1 , r ) <NEWLINE> return i + 1 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> input ( ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> k = partition ( A ) <NEWLINE> B = list ( map ( str , A ) ) <NEWLINE> B [ k ] = <STRING> . format ( B [ k ] ) <NEWLINE> print ( <STRING> . join ( B ) ) <NEWLINE> <DEDENT>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mn = min ( n , m ) <NEWLINE> P = [ ] <COMMENT> <NEWLINE> sum_p = 0 <COMMENT> <NEWLINE> X = [ False ] * m <NEWLINE> <NL> for i in range ( mn ) : <NEWLINE> <INDENT> if X [ x ] : break <NEWLINE> X [ x ] = True <NEWLINE> P . append ( x ) <NEWLINE> sum_p += x <NEWLINE> x = x * x % m <NEWLINE> <NL> <DEDENT> if len ( P ) >= mn : <NEWLINE> <INDENT> print ( sum_p ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> pre_len = P . index ( x ) <NEWLINE> cyc_len = len ( P ) - pre_len <NEWLINE> nxt_len = ( n - pre_len ) % cyc_len <NEWLINE> <NL> cyc_num = ( n - pre_len ) // cyc_len <NEWLINE> <NL> pre = sum ( P [ : pre_len ] ) <NEWLINE> cyc = sum_p - pre <NEWLINE> nxt = sum ( P [ pre_len : pre_len + nxt_len ] ) <NEWLINE> <NL> print ( pre + cyc * cyc_num + nxt ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ i - 1 for i in a ] <NEWLINE> g = [ - 1 ] * n <NEWLINE> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> while g [ j ] == - 1 : <NEWLINE> <INDENT> if i == k : <NEWLINE> <INDENT> print ( j + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> g [ j ] = i <NEWLINE> i += 1 <NEWLINE> j = a [ j ] <NEWLINE> <NL> <DEDENT> for i in range ( ( k - g [ j ] ) % ( i - g [ j ] ) ) : <NEWLINE> <INDENT> j = a [ j ] <NEWLINE> <DEDENT> print ( j + 1 ) <NEWLINE>
import math <NEWLINE> <NL> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def choshin_angle ( m ) : <NEWLINE> <INDENT> return 6 * m <NEWLINE> <NL> <DEDENT> def tanshin_angle ( h , m ) : <NEWLINE> <INDENT> return 0.5 * ( 60 * h + m ) <NEWLINE> <NL> <DEDENT> theta = abs ( tanshin_angle ( h , m ) - choshin_angle ( m ) ) <NEWLINE> <NL> if ( theta >= 180. ) : <NEWLINE> <INDENT> theta = 360 - theta <NEWLINE> <NL> <DEDENT> theta = math . radians ( theta ) <NEWLINE> <NL> x2 = a ** 2 + b ** 2 - 2 * a * b * math . cos ( theta ) <NEWLINE> <NL> x = math . sqrt ( x2 ) <NEWLINE> <NL> print ( x ) <NEWLINE> <NL>
N , K = input ( ) . split ( ) <NEWLINE> N = int ( N ) <NEWLINE> K = int ( K ) <NEWLINE> <NL> have = [ ] <NEWLINE> result = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> have . append ( [ 1 ] * K ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> <NL> A = input ( ) . split ( ) <NEWLINE> A = map ( int , A ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> have [ a - 1 ] [ i - 1 ] = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for j in have : <NEWLINE> <INDENT> if j == [ 1 ] * K : <NEWLINE> <INDENT> result += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
a = input ( ) <NEWLINE> s = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> s += int ( i ) <NEWLINE> <DEDENT> if s % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def fl ( i ) : <NEWLINE> <INDENT> return ( ( A * i ) // B ) - ( A * ( i // B ) ) <NEWLINE> <NL> <DEDENT> if B <= N : <NEWLINE> <INDENT> print ( int ( fl ( B - 1 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( fl ( N ) ) ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> h = int ( S // 3600 ) <NEWLINE> m = int ( ( S - ( h * 3600 ) ) / 60 ) <NEWLINE> s = int ( S - ( h * 3600 + m * 60 ) ) <NEWLINE> print ( h , <STRING> , m , <STRING> , s , sep = <STRING> ) <NEWLINE>
def printcase ( ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> n = int ( input ( ) ) <NEWLINE> while n != 0 : <NEWLINE> <INDENT> print ( <STRING> % ( i , n ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> ret = printcase ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lis = [ 0 ] * n <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> lis [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( * lis , sep = <STRING> ) <NEWLINE>
import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> n = math . ceil ( ( math . sqrt ( 1 + 8 * X ) - 1 ) / 2 ) <NEWLINE> ans = n <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> <NL> s2nn = lambda s : [ int ( c ) for c in s . split ( <STRING> ) ] <NEWLINE> ss2nn = lambda ss : [ int ( s ) for s in list ( ss ) ] <NEWLINE> ss2nnn = lambda ss : [ s2nn ( s ) for s in list ( ss ) ] <NEWLINE> i2s = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> i2n = lambda : int ( i2s ( ) ) <NEWLINE> i2nn = lambda : s2nn ( i2s ( ) ) <NEWLINE> ii2ss = lambda n : [ i2s ( ) for _ in range ( n ) ] <NEWLINE> ii2nn = lambda n : ss2nn ( ii2ss ( n ) ) <NEWLINE> ii2nnn = lambda n : ss2nnn ( ii2ss ( n ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> K = i2n ( ) <NEWLINE> a = 0 <NEWLINE> if K % 7 : <NEWLINE> <INDENT> L = 9 * K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = 9 * K // 7 <NEWLINE> <DEDENT> a = 1 <NEWLINE> for i in range ( 1 , K + 10 ) : <NEWLINE> <INDENT> a = ( a * 10 ) % L <NEWLINE> if a == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( b // k ) * k >= a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> times_count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d1 , d2 = map ( int , input ( ) . split ( ) ) <NEWLINE> if d1 == d2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> if count == 3 : <NEWLINE> <INDENT> times_count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if times_count == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> * H , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dmax = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> <NL> for j in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> dmax [ a - 1 ] = max ( dmax [ a - 1 ] , H [ b - 1 ] ) <NEWLINE> dmax [ b - 1 ] = max ( dmax [ b - 1 ] , H [ a - 1 ] ) <NEWLINE> <NL> <DEDENT> goodv = [ 1 for i in range ( N ) if dmax [ i ] < H [ i ] ] <NEWLINE> print ( len ( goodv ) ) <NEWLINE> <NL>
import itertools <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> num = [ 0 , 1 ] <NEWLINE> pattern = list ( itertools . product ( num , repeat = n ) ) <NEWLINE> lists = [ ] <NEWLINE> switches = [ 1 ] * n <NEWLINE> onoff = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> lists . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> key_value = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for l in pattern : <NEWLINE> <INDENT> switches = list ( l ) <NEWLINE> onoff = [ 0 ] * m <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for k in lists [ j ] [ 1 : ] : <NEWLINE> <INDENT> if switches [ k - 1 ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count % 2 == key_value [ j ] : <NEWLINE> <INDENT> onoff [ j ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if not 0 in onoff : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def yn ( b ) : <NEWLINE> <INDENT> print ( <STRING> if b == 1 else <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> readline = sys . stdin . readline <NEWLINE> mod = 998244353 <NEWLINE> dp = [ 0 ] * ( 2 * ( 10 ** 5 ) + 10 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> n , k = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ll = [ 0 ] * ( 2 * ( 10 ** 5 ) + 10 ) <NEWLINE> rr = [ 0 ] * ( 2 * ( 10 ** 5 ) + 10 ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ll [ i ] , rr [ i ] = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> dp [ i ] += dp [ i - 1 ] <NEWLINE> <NL> <DEDENT> if dp [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for j in range ( k ) : <NEWLINE> <INDENT> if i + ll [ j ] <= n : <NEWLINE> <INDENT> dp [ i + ll [ j ] ] += dp [ i ] <NEWLINE> dp [ i + ll [ j ] ] %= mod <NEWLINE> <DEDENT> if i + rr [ j ] + 1 <= n : <NEWLINE> <INDENT> dp [ i + rr [ j ] + 1 ] -= dp [ i ] <NEWLINE> dp [ i + rr [ j ] + 1 ] %= mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> return <NEWLINE> <NL> <DEDENT> if <STRING> not in globals ( ) : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
<COMMENT> <NL> K = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> from functools import reduce <NEWLINE> import math <COMMENT> <NEWLINE> def lcm_base ( x , y ) : <NEWLINE> <INDENT> return math . gcd ( x , y ) <COMMENT> <NEWLINE> <DEDENT> def lcm_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( lcm_base , numbers ) <NEWLINE> <DEDENT> def lcm_fukusu ( * numbers ) : <NEWLINE> <INDENT> return reduce ( lcm_base , numbers ) <NEWLINE> <NL> <NL> <DEDENT> saisyou_koyakusu = [ ] <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if i == j and j == k : <NEWLINE> <INDENT> saisyou_koyakusu . append ( lcm_fukusu ( i , j , k ) ) <NEWLINE> <DEDENT> elif i == j or j == k : <NEWLINE> <INDENT> saisyou_koyakusu . append ( ( lcm_fukusu ( i , j , k ) ) * 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> saisyou_koyakusu . append ( ( lcm_fukusu ( i , j , k ) ) * 6 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ( saisyou_koyakusu ) ) <NEWLINE>
