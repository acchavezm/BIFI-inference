import sys , os , math , bisect , itertools , collections , heapq , queue <NEWLINE> <COMMENT> <NL> from decimal import Decimal <NEWLINE> from collections import defaultdict , deque <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> A , B , K = il ( ) <NEWLINE> st = set ( ) <NEWLINE> for a in range ( A , A + K ) : <NEWLINE> <INDENT> if a > B : break <NEWLINE> st . add ( a ) <NEWLINE> <DEDENT> for b in reversed ( range ( B - K + 1 , B + 1 ) ) : <NEWLINE> <INDENT> if b < A : break <NEWLINE> st . add ( b ) <NEWLINE> <DEDENT> print ( * sorted ( st ) , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> ruto = math . ceil ( math . sqrt ( 2 * X ) ) + 1 <NEWLINE> kari = ruto ** 2 + ruto <NEWLINE> ans = 1 <NEWLINE> for i in range ( ruto - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if i ** 2 + i < 2 * X : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> kari = i ** 2 + i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , D , E , F = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> water = set ( ) <NEWLINE> for a in range ( 0 , F , 100 * A ) : <NEWLINE> <INDENT> for b in range ( 0 , F , 100 * B ) : <NEWLINE> <INDENT> if a + b <= F : <NEWLINE> <INDENT> water . add ( a + b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> sugars = set ( ) <NEWLINE> for c in range ( 0 , F , C ) : <NEWLINE> <INDENT> for d in range ( 0 , F , D ) : <NEWLINE> <INDENT> if c + d <= F : <NEWLINE> <INDENT> sugars . add ( c + d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> density = 0 <NEWLINE> sugar = 0 <NEWLINE> content = 100 * A <NEWLINE> for x in water : <NEWLINE> <INDENT> for y in sugars : <NEWLINE> <INDENT> if x + y != 0 and x + y <= F and E * x >= 100 * y and density < y / ( x + y ) : <NEWLINE> <INDENT> density = y / ( x + y ) <NEWLINE> sugar = y <NEWLINE> content = x + y <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( content , sugar ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> pair = [ i for i in range ( n ) ] <NEWLINE> a = [ 0 ] * m <NEWLINE> b = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ai , bi = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ i ] = ai - 1 <NEWLINE> b [ i ] = bi - 1 <NEWLINE> <NL> <DEDENT> def root ( x ) : <NEWLINE> <INDENT> if x == pair [ x ] : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = root ( pair [ x ] ) <NEWLINE> pair [ x ] = tmp <NEWLINE> return tmp <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = root ( x ) <NEWLINE> y = root ( y ) <NEWLINE> if x == y : return <NEWLINE> pair [ x ] = y <NEWLINE> <NL> <DEDENT> icnt = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> pair = [ i for i in range ( n ) ] <NEWLINE> for ii in range ( m ) : <NEWLINE> <INDENT> if ii == i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> unite ( a [ ii ] , b [ ii ] ) <NEWLINE> <NL> <DEDENT> l = [ root ( ii ) for ii in range ( n ) ] <NEWLINE> <COMMENT> <NL> lenpair = len ( set ( l ) ) <NEWLINE> if lenpair != 1 : <NEWLINE> <INDENT> icnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( icnt ) <NEWLINE>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ma = A [ - 1 ] <NEWLINE> half = ma / 2 <NEWLINE> index = bisect . bisect_left ( A , half ) <NEWLINE> <NL> if index != 0 : <NEWLINE> <INDENT> ans = A [ index - 1 ] if half - A [ index - 1 ] <= A [ index ] - half else A [ index ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A [ 0 ] <NEWLINE> <NL> <DEDENT> print ( ma , ans ) <NEWLINE>
from math import sqrt <NEWLINE> n = int ( input ( ) ) <NEWLINE> sn = int ( sqrt ( n ) // 1 ) <NEWLINE> <NL> for i in range ( sn , 0 , - 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> s = n // i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( str ( s ) ) ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += cnt <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] + A <NEWLINE> B = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> k = N - i <NEWLINE> c = 0 <NEWLINE> for j in range ( k , N + 1 , k ) : <NEWLINE> <INDENT> c += B [ j ] <NEWLINE> c %= 2 <NEWLINE> <DEDENT> if A [ k ] != c : <NEWLINE> <INDENT> B [ k ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( B ) ) <NEWLINE> for i in range ( len ( B ) ) : <NEWLINE> <INDENT> if B [ i ] == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> from collections import Counter <NEWLINE> n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> point = k - q <NEWLINE> participant = [ point ] * n <NEWLINE> answer = [ int ( input ( ) ) for _ in range ( q ) ] <NEWLINE> count_a = Counter ( answer ) <NEWLINE> <NL> <NL> for key , value in count_a . items ( ) : <NEWLINE> <INDENT> participant [ key - 1 ] += value <NEWLINE> <NL> <DEDENT> for i in participant : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s = str ( input ( ) ) <NEWLINE> <NL> ans , cnt , i = 0 , 0 , 0 <NEWLINE> while i < len ( s ) - 1 : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> ans += cnt <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> knap = [ ] <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> knap . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> dp = np . zeros ( ( N + 1 , W + 1 ) , dtype = np . int64 ) <NEWLINE> <NL> for i , ( w , v ) in enumerate ( knap ) : <NEWLINE> <INDENT> dp [ i + 1 ] = np . maximum ( dp [ i + 1 ] , dp [ i ] ) <NEWLINE> dp [ i + 1 ] [ w : ] = np . maximum ( dp [ i ] [ w : ] , dp [ i ] [ : - w ] + v ) <NEWLINE> <NL> <DEDENT> print ( dp [ N ] [ - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> sum_W = [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> sum_W . append ( sum_W [ i - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum_W . append ( sum_W [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> sum_E = [ S [ 1 : ] . count ( <STRING> ) ] <NEWLINE> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> sum_E . append ( sum_E [ i ] - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum_E . append ( sum_E [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> counts = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> counts . append ( sum_W [ i ] + sum_E [ i ] ) <NEWLINE> <NL> <DEDENT> print ( min ( counts ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == M : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> <NL> t2 = a [ 0 ] <NEWLINE> x = a [ 0 ] // 2 <NEWLINE> ans = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> t = abs ( x - a [ i ] ) <NEWLINE> if t < t2 : <NEWLINE> <INDENT> t2 = t <NEWLINE> ans = i <NEWLINE> <DEDENT> <DEDENT> print ( a [ 0 ] , a [ ans ] ) <NEWLINE>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , bisect <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heappush , heappop <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> stdin = sys . stdin <NEWLINE> <NL> ni = lambda : int ( ns ( ) ) <NEWLINE> nf = lambda : float ( ns ( ) ) <NEWLINE> na = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> nb = lambda : list ( map ( float , stdin . readline ( ) . split ( ) ) ) <NEWLINE> ns = lambda : stdin . readline ( ) . rstrip ( ) <COMMENT> <NEWLINE> <NL> <NL> def dijkstra ( s , n ) : <COMMENT> <NEWLINE> <INDENT> dist = [ inf ] * n <NEWLINE> hq = [ ( 0 , s ) ] <COMMENT> <NEWLINE> dist [ s ] = 0 <NEWLINE> seen = [ False ] * n <COMMENT> <NEWLINE> while hq : <NEWLINE> <INDENT> v = heappop ( hq ) [ 1 ] <COMMENT> <NEWLINE> seen [ v ] = True <NEWLINE> for to , cost in adj [ v ] : <COMMENT> <NEWLINE> <INDENT> if seen [ to ] == False and dist [ v ] + cost < dist [ to ] : <NEWLINE> <INDENT> dist [ to ] = dist [ v ] + cost <NEWLINE> heappush ( hq , ( dist [ to ] , to ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dist <NEWLINE> <NL> <DEDENT> N = ni ( ) <NEWLINE> adj = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = na ( ) <NEWLINE> adj [ a - 1 ] . append ( ( b - 1 , c ) ) <NEWLINE> adj [ b - 1 ] . append ( ( a - 1 , c ) ) <NEWLINE> <NL> <DEDENT> Q , K = na ( ) <NEWLINE> ans = [ ] <NEWLINE> d = dijkstra ( K - 1 , N ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> x , y = na ( ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> ans . append ( d [ x ] + d [ y ] ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> lcm = lcm ( C , D ) <NEWLINE> <NL> u_b_ans = ( B // C + B // D ) - B // lcm <NEWLINE> u_a_ans = ( ( A - 1 ) // C + ( A - 1 ) // D ) - ( A - 1 ) // lcm <NEWLINE> <NL> print ( B - A + 1 - u_b_ans + u_a_ans ) <NEWLINE>
def delete_head_zeros ( n ) : <NEWLINE> <INDENT> n = str ( n ) <NEWLINE> l = len ( n ) <NEWLINE> if <STRING> in n : <NEWLINE> <INDENT> l = n . find ( <STRING> ) <NEWLINE> <DEDENT> head_zeros = 0 <NEWLINE> for i in range ( l - 1 ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : <NEWLINE> <INDENT> head_zeros += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return n [ head_zeros : ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def bigint_compare ( a , b ) : <NEWLINE> <INDENT> a = delete_head_zeros ( a ) <NEWLINE> b = delete_head_zeros ( b ) <NEWLINE> if len ( a ) > len ( b ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif len ( a ) < len ( b ) : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def bigint_plus ( a , b ) : <NEWLINE> <INDENT> a = str ( a ) <NEWLINE> b = str ( b ) <NEWLINE> <NL> d = max ( [ len ( a ) , len ( b ) ] ) <NEWLINE> a = <STRING> * ( d - len ( a ) ) + a <NEWLINE> b = <STRING> * ( d - len ( b ) ) + b <NEWLINE> <NL> ans = <STRING> <NEWLINE> carry = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s = int ( a [ - i - 1 ] ) + int ( b [ - i - 1 ] ) + carry <NEWLINE> carry = s // 10 <NEWLINE> ans = str ( s % 10 ) + ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if carry : <NEWLINE> <INDENT> ans = str ( carry ) + ans <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def bigint_minus ( a , b ) : <NEWLINE> <INDENT> a = str ( a ) <NEWLINE> b = str ( b ) <NEWLINE> M = [ ] <NEWLINE> m = [ ] <NEWLINE> sign = <STRING> <NEWLINE> <NL> if len ( a ) > len ( b ) or ( len ( a ) == len ( b ) and a >= b ) : <NEWLINE> <INDENT> [ M , m ] = [ a , b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> [ M , m ] = [ b , a ] <NEWLINE> sign = <STRING> <NEWLINE> <DEDENT> m = <STRING> * ( len ( M ) - len ( m ) ) + m <NEWLINE> <NL> ans = <STRING> <NEWLINE> borrow = 0 <NEWLINE> for i in range ( len ( M ) ) : <NEWLINE> <INDENT> s = int ( M [ - i - 1 ] ) - int ( m [ - i - 1 ] ) - borrow <NEWLINE> if s < 0 : <NEWLINE> <INDENT> borrow = 1 <NEWLINE> s += 10 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> borrow = 0 <NEWLINE> <DEDENT> ans = str ( s ) + ans <NEWLINE> <NL> <DEDENT> return sign + delete_head_zeros ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def bigint_multiply ( a , b ) : <NEWLINE> <INDENT> a = str ( a ) <NEWLINE> b = str ( b ) <NEWLINE> <NL> md = [ ] <NEWLINE> carry = 0 <NEWLINE> for j in range ( len ( b ) ) : <NEWLINE> <INDENT> mj = <STRING> <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> m = int ( a [ - i - 1 ] ) * int ( b [ - j - 1 ] ) + carry <NEWLINE> carry = m // 10 <NEWLINE> mj = str ( m % 10 ) + mj <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if carry : <NEWLINE> <INDENT> mj = str ( carry ) + mj <NEWLINE> <DEDENT> <DEDENT> md . append ( mj ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for k in range ( len ( md ) ) : <NEWLINE> <INDENT> ans = bigint_plus ( md [ k ] + <STRING> * k , ans ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def bigint_divide ( a , b , d = 0 ) : <NEWLINE> <INDENT> a = str ( a ) <NEWLINE> b = str ( b ) <NEWLINE> d = int ( d ) <NEWLINE> if d < 0 : <NEWLINE> <INDENT> d = 0 <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> r = <STRING> <NEWLINE> for i in range ( len ( a ) + d ) : <NEWLINE> <INDENT> q = 0 <NEWLINE> if i < len ( a ) : <NEWLINE> <INDENT> r += a [ i ] <NEWLINE> <DEDENT> elif i == len ( a ) : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> r += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r += <STRING> <NEWLINE> <NL> <DEDENT> if bigint_compare ( r , b ) == - 1 : <NEWLINE> <INDENT> ans += str ( q ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while bigint_compare ( r , b ) >= 0 : <NEWLINE> <INDENT> r = bigint_minus ( r , b ) <NEWLINE> q += 1 <NEWLINE> <DEDENT> ans += str ( q ) <NEWLINE> <NL> <DEDENT> <DEDENT> return delete_head_zeros ( ans ) <NEWLINE> <NL> <NL> <DEDENT> a , b , x = [ n for n in input ( ) . split ( <STRING> ) ] <NEWLINE> c1 = bigint_divide ( b , x ) <NEWLINE> <NL> if int ( a ) == 0 : <NEWLINE> <INDENT> c2 = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c2 = bigint_divide ( bigint_minus ( a , 1 ) , x ) <NEWLINE> <NL> <DEDENT> if int ( a ) == 0 : <NEWLINE> <INDENT> print ( bigint_plus ( bigint_minus ( c1 , c2 ) , 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( bigint_minus ( c1 , c2 ) ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if len ( b ) <= a [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a [ 1 ] == 0 : <NEWLINE> <INDENT> print ( sum ( b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . sort ( reverse = True ) <NEWLINE> print ( sum ( b [ a [ 1 ] : ] ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> <NL> def check ( x ) : <NEWLINE> <INDENT> dp = np . zeros ( k , np . bool ) <NEWLINE> dp [ 0 ] = True <NEWLINE> for e in a [ : x ] + a [ x + 1 : ] : <NEWLINE> <INDENT> dp [ e : ] |= dp [ : - e ] <NEWLINE> <NL> <DEDENT> return dp [ - a [ x ] : ] . any ( ) <NEWLINE> <NL> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> lb = - 1 <NEWLINE> ub = n <NEWLINE> while ub - lb > 1 : <NEWLINE> <INDENT> m = ( lb + ub ) // 2 <NEWLINE> if check ( m ) : <NEWLINE> <INDENT> ub = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lb = m <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ub ) <NEWLINE>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 2020 <NEWLINE> <NL> for i in range ( L , min ( L + 2019 , R ) ) : <NEWLINE> <INDENT> for j in range ( L + 1 , min ( L + 2019 , R ) + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , i * j % 2019 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> C = { } <NEWLINE> for a in A : <NEWLINE> <INDENT> if a in C . keys ( ) : <NEWLINE> <INDENT> C [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C [ a ] = 1 <NEWLINE> <DEDENT> <DEDENT> B = list ( C . items ( ) ) <NEWLINE> B . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( len ( B ) ) : <NEWLINE> <INDENT> count = B [ i ] [ 1 ] <NEWLINE> if i + 1 < len ( B ) and B [ i + 1 ] [ 0 ] == B [ i ] [ 0 ] + 1 : <NEWLINE> <INDENT> count += B [ i + 1 ] [ 1 ] <NEWLINE> if i + 2 < len ( B ) and B [ i + 2 ] [ 0 ] == B [ i ] [ 0 ] + 2 : <NEWLINE> <INDENT> count += B [ i + 2 ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , count ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( a <= 0 and b >= 0 ) or ( a == 0 ) or ( b == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a > 0 ) or ( b < 0 and ( b - a ) % 2 == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( b < 0 and ( b - a ) % 2 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> <NL> <NL> def LI ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> n = 10 ** 5 <NEWLINE> sosu = set ( range ( 2 , n + 1 ) ) <NEWLINE> for i in range ( 2 , int ( n ** 0.5 + 1 ) ) : <NEWLINE> <INDENT> sosu . difference_update ( range ( i * 2 , n + 1 , i ) ) <NEWLINE> <DEDENT> xlist = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( 1 , 10 ** 5 + 1 , 2 ) : <NEWLINE> <INDENT> if i in sosu : <NEWLINE> <INDENT> if ( i + 1 ) // 2 in sosu : <NEWLINE> <INDENT> xlist [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> Xsum = list ( accumulate ( xlist ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> L , R = LI ( ) <NEWLINE> ans = Xsum [ R ] - Xsum [ L - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> Authority = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> cards = list ( range ( 1 , n + 2 ) ) <NEWLINE> l_list = [ ] <NEWLINE> r_list = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l_list . append ( Authority [ i ] [ 0 ] ) <NEWLINE> r_list . append ( Authority [ i ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> print ( len ( cards [ max ( l_list ) : min ( r_list ) + 1 ] ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> H = [ int ( s ) for s in str ( input ( ) ) . split ( ) ] <NEWLINE> dp = np . full ( 10 ** 5 + 10 , np . inf ) <NEWLINE> <NL> def rec ( i ) : <NEWLINE> <INDENT> if dp [ i ] < np . inf : <NEWLINE> <INDENT> return dp [ i ] <NEWLINE> <NL> <DEDENT> if i == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> res = np . inf <NEWLINE> res = rec ( i - 1 ) + abs ( H [ i ] - H [ i - 1 ] ) <NEWLINE> if i > 1 : <NEWLINE> <INDENT> res = min ( res , rec ( i - 2 ) + abs ( H [ i ] - H [ i - 2 ] ) ) <NEWLINE> <NL> <DEDENT> dp [ i ] = res <NEWLINE> return dp [ i ] <NEWLINE> <NL> <DEDENT> def main3 ( ) : <NEWLINE> <INDENT> print ( int ( rec ( N - 1 ) ) ) <NEWLINE> <NL> <DEDENT> def main1 ( ) : <NEWLINE> <INDENT> dp = np . full ( 10 ** 5 + 10 , np . inf ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + abs ( H [ i ] - H [ i - 1 ] ) ) <NEWLINE> if i > 1 : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i ] , dp [ i - 2 ] + abs ( H [ i ] - H [ i - 2 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( dp [ N - 1 ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main1 ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> ls = len ( S ) <NEWLINE> t1 = [ ] <NEWLINE> <NL> t = 1 <NEWLINE> for i in range ( 1 , ls ) : <NEWLINE> <INDENT> if S [ i - 1 ] == S [ i ] : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t > 1 : <NEWLINE> <INDENT> t1 . append ( t ) <NEWLINE> <DEDENT> t = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if t > 1 or t == ls : <NEWLINE> <INDENT> t1 . append ( t ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for t in t1 : <NEWLINE> <INDENT> ans += t // 2 <NEWLINE> <NL> <DEDENT> if len ( t1 ) == 1 : <NEWLINE> <INDENT> if t1 [ 0 ] == ls : <NEWLINE> <INDENT> print ( ls * K // 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if S [ 0 ] != S [ - 1 ] : <NEWLINE> <INDENT> print ( ans * K ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ta = t1 [ 0 ] <NEWLINE> tb = t1 [ - 1 ] <NEWLINE> print ( ans * K - ( ta // 2 + tb // 2 - ( ta + tb ) // 2 ) * ( K - 1 ) ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> aminus = [ ] <NEWLINE> aplus = [ ] <NEWLINE> p = 0 <NEWLINE> q = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i >= 0 : <NEWLINE> <INDENT> aplus . append ( i ) <NEWLINE> p += 1 <NEWLINE> <DEDENT> elif i < 0 : <NEWLINE> <INDENT> aminus . append ( i ) <NEWLINE> q += 1 <NEWLINE> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> cou = 0 <NEWLINE> if aplus and aminus : <NEWLINE> <INDENT> now = aminus [ 0 ] <NEWLINE> for i in range ( p - 1 ) : <NEWLINE> <INDENT> ans . append ( ( now , aplus [ i ] ) ) <NEWLINE> now = now - aplus [ i ] <NEWLINE> <DEDENT> aminus [ 0 ] = now <NEWLINE> now = aplus [ p - 1 ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> ans . append ( ( now , aminus [ i ] ) ) <NEWLINE> now = now - aminus [ i ] <NEWLINE> <DEDENT> cou = now <NEWLINE> <DEDENT> elif aplus : <NEWLINE> <INDENT> now = aplus [ 0 ] <NEWLINE> for i in range ( 1 , p - 1 ) : <NEWLINE> <INDENT> ans . append ( ( now , aplus [ i ] ) ) <NEWLINE> now = now - aplus [ i ] <NEWLINE> <DEDENT> ans . append ( ( aplus [ p - 1 ] , now ) ) <NEWLINE> cou = aplus [ p - 1 ] - now <NEWLINE> <DEDENT> elif aminus : <NEWLINE> <INDENT> now = aminus [ q - 1 ] <NEWLINE> for i in range ( q - 1 ) : <NEWLINE> <INDENT> ans . append ( ( now , aminus [ i ] ) ) <NEWLINE> now = now - aminus [ i ] <NEWLINE> <DEDENT> cou = now <NEWLINE> <NL> <DEDENT> print ( cou ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( * ans [ i ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> if s . count ( <STRING> ) == 0 or s . count ( <STRING> ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> clen , flen = 0 , 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if clen == 0 : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> clen = i <NEWLINE> <DEDENT> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> flen = i <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if flen > clen else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A = input ( ) <NEWLINE> A = A [ : : - 1 ] <NEWLINE> divide = [ i [ : : - 1 ] for i in [ <STRING> , <STRING> , <STRING> , <STRING> ] ] <NEWLINE> <NL> flag = 1 <NEWLINE> while flag and A : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for word in divide : <NEWLINE> <INDENT> if A . startswith ( word ) : <NEWLINE> <INDENT> A = A [ len ( word ) : ] <NEWLINE> flag = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if len ( A ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> to = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> to [ x - 1 ] . append ( y - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> dp = [ 0 ] * N <NEWLINE> seen = [ 0 ] * N <NEWLINE> <NL> def dfs ( v ) : <NEWLINE> <INDENT> if seen [ v ] : <NEWLINE> <INDENT> return dp [ v ] <NEWLINE> <DEDENT> seen [ v ] = 1 <NEWLINE> res = 0 <NEWLINE> for nv in to [ v ] : <NEWLINE> <INDENT> res = max ( res , dfs ( nv ) + 1 ) <NEWLINE> <DEDENT> dp [ v ] = res <NEWLINE> return res <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , dfs ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> def cal ( c ) : <NEWLINE> <INDENT> d = [ ] <NEWLINE> while c % 2 == 0 : <NEWLINE> <INDENT> d . append ( 2 ) <NEWLINE> c //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f ** 2 <= c : <NEWLINE> <INDENT> if c % f == 0 : <NEWLINE> <INDENT> d . append ( f ) <NEWLINE> c //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if c != 1 : <NEWLINE> <INDENT> d . append ( c ) <NEWLINE> <DEDENT> return d <NEWLINE> <NL> <DEDENT> c = gcd ( a , b ) <NEWLINE> d = cal ( c ) <NEWLINE> print ( len ( set ( d ) ) + 1 ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> L = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> tmp = bisect_left ( L , L [ i ] + L [ j ] ) <NEWLINE> cnt += tmp - j - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . par = [ i for i in range ( n + 1 ) ] <NEWLINE> self . rank = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if self . rank [ x ] < self . rank [ y ] : <NEWLINE> <INDENT> self . par [ x ] = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ y ] = x <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ x ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def same_check ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> import copy <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ i ] = [ i , a , b ] <NEWLINE> <NL> <DEDENT> B = copy . deepcopy ( A ) <NEWLINE> A = sorted ( A , key = lambda x : x [ 1 ] ) <NEWLINE> B = sorted ( B , key = lambda x : x [ 2 ] ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> A2 = [ 0 ] * ( N - 1 ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> l = abs ( A [ i ] [ 1 ] - A [ i - 1 ] [ 1 ] ) <NEWLINE> A2 [ i - 1 ] = [ A [ i ] [ 0 ] , A [ i - 1 ] [ 0 ] , l ] <NEWLINE> <NL> <DEDENT> B2 = [ 0 ] * ( N - 1 ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> l = abs ( B [ i ] [ 2 ] - B [ i - 1 ] [ 2 ] ) <NEWLINE> B2 [ i - 1 ] = [ B [ i ] [ 0 ] , B [ i - 1 ] [ 0 ] , l ] <NEWLINE> <DEDENT> Len = A2 + B2 <NEWLINE> Len = sorted ( Len , key = lambda x : x [ 2 ] ) <NEWLINE> <COMMENT> <NL> <NL> data = UnionFind ( N + 1 ) <NEWLINE> cost = 0 <NEWLINE> for i in range ( len ( Len ) ) : <NEWLINE> <INDENT> if not data . same_check ( Len [ i ] [ 0 ] , Len [ i ] [ 1 ] ) : <NEWLINE> <INDENT> data . union ( Len [ i ] [ 0 ] , Len [ i ] [ 1 ] ) <NEWLINE> cost += Len [ i ] [ 2 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( cost ) <NEWLINE> <NL> <NL> <NL>
<COMMENT> <NL> from collections import Counter <NEWLINE> s = input ( ) <NEWLINE> alphabet = <STRING> <NEWLINE> <NL> result = [ ] <NEWLINE> if len ( set ( s ) ) == 1 : <NEWLINE> <INDENT> result . append ( 0 ) <NEWLINE> <DEDENT> for i in alphabet : <NEWLINE> <INDENT> s_tmp = s <NEWLINE> cnt = 0 <NEWLINE> for k in range ( len ( s_tmp ) ) : <NEWLINE> <INDENT> s_new = <STRING> <NEWLINE> for j in range ( len ( s_tmp ) - 1 ) : <NEWLINE> <INDENT> if s_tmp [ j ] == i or s_tmp [ j + 1 ] == i : <NEWLINE> <INDENT> s_new += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s_new += s_tmp [ j ] <NEWLINE> <DEDENT> <DEDENT> cnt += 1 <NEWLINE> if len ( set ( s_new ) ) == 1 : <NEWLINE> <INDENT> result . append ( cnt ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> s_tmp = s_new <NEWLINE> <NL> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( min ( result ) ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> r = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( L ) <NEWLINE> r . append ( R ) <NEWLINE> <NL> <DEDENT> ans = min ( r ) - max ( l ) + 1 <NEWLINE> <NL> print ( max ( ans , 0 ) ) <NEWLINE>
import collections <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans_list = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> A [ i - 1 ] %= m <NEWLINE> ans_list [ i ] = ( ans_list [ i - 1 ] + A [ i - 1 ] ) % m <NEWLINE> <DEDENT> ans_list . pop ( ans_list [ 0 ] ) <NEWLINE> ans_list = dict ( collections . Counter ( ans_list ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> count = 0 <NEWLINE> if 0 in ans_list : <NEWLINE> <INDENT> count = ans_list [ 0 ] <NEWLINE> <COMMENT> <NL> <DEDENT> for v in ans_list . values ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> if v != 1 : <NEWLINE> <INDENT> count += v * ( v - 1 ) / 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( count ) ) <NEWLINE> <NL> <NL>
<COMMENT> <NL> <NL> x = int ( input ( ) ) <NEWLINE> <NL> n = x // 100 <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> tmp = x <NEWLINE> tmp -= i * 100 <NEWLINE> if 5 * i >= tmp : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE>
import sys , os , math , bisect , itertools , collections , heapq , queue , copy , array <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N , M = il ( ) <NEWLINE> <NL> ret = 0 <NEWLINE> if N * 2 <= M : <NEWLINE> <INDENT> ret += N <NEWLINE> ret += ( M - N * 2 ) // 4 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret += M // 2 <NEWLINE> <DEDENT> print ( ret ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 1 <NEWLINE> cnt = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> while i % 2 == 0 : <NEWLINE> <INDENT> i //= 2 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import statistics <NEWLINE> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = statistics . median ( x ) <NEWLINE> xs = sorted ( x ) <NEWLINE> for i in x : <NEWLINE> <INDENT> if i < y : <NEWLINE> <INDENT> print ( xs [ n // 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( xs [ n // 2 - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> from math import sqrt <NEWLINE> from collections import deque <NEWLINE> from collections import Counter <NEWLINE> from collections import defaultdict <NEWLINE> <COMMENT> <NL> from collections import OrderedDict <NEWLINE> <COMMENT> <NL> from math import ceil <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> sys . setrecursionlimit ( 11451419 ) <NEWLINE> from decimal import Decimal <COMMENT> <NEWLINE> from functools import lru_cache <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> k = int ( input ( ) ) <NEWLINE> print ( 50 ) ; n = 50 <NEWLINE> if k == 0 : <NEWLINE> <INDENT> print ( <STRING> . join ( [ <STRING> ] * 50 ) ) ; exit ( ) <NEWLINE> <NL> <DEDENT> a = k // n <NEWLINE> b = k % n <NEWLINE> A = [ a + i for i in range ( 50 ) ] <NEWLINE> for i in range ( b ) : <NEWLINE> <INDENT> A = [ A [ j ] - 1 if i != j else A [ j ] + n for j in range ( 50 ) ] <NEWLINE> <DEDENT> print ( * A ) <NEWLINE>
def min_disc ( points ) : <NEWLINE> <INDENT> from random import sample <NEWLINE> N = len ( points ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> return points [ 0 ] , 0 <NEWLINE> <DEDENT> points = sample ( points , N ) <NEWLINE> def cross ( a , b ) : <NEWLINE> <INDENT> return a . real * b . imag - a . imag * b . real <NEWLINE> <DEDENT> def norm2 ( a ) : <NEWLINE> <INDENT> return a . real * a . real + a . imag * a . imag <NEWLINE> <DEDENT> def make_circle_3 ( a , b , c ) : <NEWLINE> <INDENT> A , B , C = norm2 ( b - c ) , norm2 ( c - a ) , norm2 ( a - b ) <NEWLINE> S = cross ( b - a , c - a ) <NEWLINE> p = ( A * ( B + C - A ) * a + B * ( C + A - B ) * b + C * ( A + B - C ) * c ) / ( 4 * S * S ) <NEWLINE> radius = abs ( p - a ) <NEWLINE> return p , radius <NEWLINE> <DEDENT> def make_circle_2 ( a , b ) : <NEWLINE> <INDENT> c = ( a + b ) / 2 <NEWLINE> radius = abs ( a - c ) <NEWLINE> return c , radius <NEWLINE> <DEDENT> def in_circle ( point , circle ) : <NEWLINE> <INDENT> return abs ( point - circle [ 0 ] ) <= circle [ 1 ] + 1e-7 <NEWLINE> <DEDENT> p0 = points [ 0 ] <NEWLINE> circle = make_circle_2 ( p0 , points [ 1 ] ) <NEWLINE> for i , p_i in enumerate ( points [ 2 : ] , 2 ) : <NEWLINE> <INDENT> if not in_circle ( p_i , circle ) : <NEWLINE> <INDENT> circle = make_circle_2 ( p0 , p_i ) <NEWLINE> for j , p_j in enumerate ( points [ 1 : i ] , 1 ) : <NEWLINE> <INDENT> if not in_circle ( p_j , circle ) : <NEWLINE> <INDENT> circle = make_circle_2 ( p_i , p_j ) <NEWLINE> for p_k in points [ : j ] : <NEWLINE> <INDENT> if not in_circle ( p_k , circle ) : <NEWLINE> <INDENT> circle = make_circle_3 ( p_i , p_j , p_k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return circle <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> XY = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> XY . append ( x + y * 1j ) <NEWLINE> <DEDENT> center , rad = min_disc ( XY ) <NEWLINE> print ( rad ) <NEWLINE>
from collections import deque <NEWLINE> X = input ( ) <NEWLINE> que = deque ( ) <NEWLINE> for x in X : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> que . append ( <STRING> ) <NEWLINE> <DEDENT> elif x == <STRING> and ( not que or que [ - 1 ] == <STRING> ) : <NEWLINE> <INDENT> que . append ( <STRING> ) <NEWLINE> <DEDENT> elif x == <STRING> and que [ - 1 ] == <STRING> : <NEWLINE> <INDENT> _ = que . pop ( ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( que ) ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> flag = 0 <NEWLINE> <NL> words = ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> count = 0 <NEWLINE> <NL> while len ( S ) >= 5 : <NEWLINE> <NL> <INDENT> for i in words : <NEWLINE> <INDENT> N = len ( i ) <NEWLINE> if S [ - N : ] in words : <NEWLINE> <INDENT> n = len ( S ) - N <NEWLINE> S = S [ : n ] <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = 0 <NEWLINE> continue <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if len ( S ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from itertools import combinations <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> class UnionFind : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . N = N <NEWLINE> self . __make_set ( ) <NEWLINE> <NL> <DEDENT> def __make_set ( self ) : <NEWLINE> <INDENT> self . _parent = list ( range ( self . N + 1 ) ) <NEWLINE> self . _rank = [ 0 ] * ( self . N + 1 ) <NEWLINE> self . _size = [ 1 ] * ( self . N + 1 ) <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . _parent [ x ] != x : <NEWLINE> <INDENT> self . _parent [ x ] = self . find ( self . _parent [ x ] ) <NEWLINE> <DEDENT> return self . _parent [ x ] <NEWLINE> <NL> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x_root = self . find ( x ) <NEWLINE> y_root = self . find ( y ) <NEWLINE> <NL> if x_root == y_root : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> x_rank = self . _rank [ x_root ] <NEWLINE> y_rank = self . _rank [ y_root ] <NEWLINE> if x_rank > y_rank : <NEWLINE> <INDENT> self . _parent [ y_root ] = x_root <NEWLINE> self . _size [ x_root ] += self . _size [ y_root ] <NEWLINE> <DEDENT> elif x_rank < y_rank : <NEWLINE> <INDENT> self . _parent [ x_root ] = y_root <NEWLINE> self . _size [ y_root ] += self . _size [ x_root ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . _parent [ y_root ] = x_root <NEWLINE> self . _rank [ x_root ] += 1 <NEWLINE> self . _size [ x_root ] += self . _size [ y_root ] <NEWLINE> <NL> <DEDENT> <DEDENT> def same_set ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return self . _size [ self . find ( x ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] * M <NEWLINE> B = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> uf = UnionFind ( N ) <NEWLINE> ans = [ 0 ] * M <NEWLINE> ans [ - 1 ] = N * ( N - 1 ) // 2 <NEWLINE> for i in reversed ( range ( M - 1 ) ) : <NEWLINE> <INDENT> a , b = A [ i + 1 ] , B [ i + 1 ] <NEWLINE> if uf . same_set ( a , b ) : <NEWLINE> <INDENT> ans [ i ] = ans [ i + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = ans [ i + 1 ] - uf . size ( a ) * uf . size ( b ) <NEWLINE> <DEDENT> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> for i in range ( 1 , int ( N ** ( 1 / 2 ) ) + 2 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> a = max ( a , i ) <NEWLINE> <DEDENT> <DEDENT> print ( a + N // a - 2 ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> k = S - i - j <NEWLINE> if 0 <= k <= K : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * ( W + 1 ) <NEWLINE> def dp_opt ( n , w ) : <NEWLINE> <INDENT> for _ in range ( N ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( W , w - 1 , - 1 ) : <NEWLINE> <INDENT> tmp = dp [ j - w ] + v <NEWLINE> if tmp > dp [ j ] : <NEWLINE> <INDENT> dp [ j ] = tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <DEDENT> dp_opt ( N , W ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lis = sorted ( x ) <NEWLINE> key1 = lis [ n // 2 - 1 ] <NEWLINE> key2 = lis [ n // 2 ] <NEWLINE> for i in x : <NEWLINE> <INDENT> if i > key1 : <NEWLINE> <INDENT> print ( key1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( key2 ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> def digit ( b , n ) : <NEWLINE> <INDENT> if n < b : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return digit ( b , math . floor ( n / b ) ) + n % b <NEWLINE> <NL> <DEDENT> <DEDENT> n , s = int ( input ( ) ) , int ( input ( ) ) <NEWLINE> <NL> if n == s : <NEWLINE> <INDENT> print ( n + 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if n < s : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 2 , int ( math . sqrt ( n ) ) + 2 ) : <NEWLINE> <INDENT> if digit ( i , n ) == s : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for p in range ( 1 , int ( math . sqrt ( n ) ) ) [ : : - 1 ] : <NEWLINE> <INDENT> q = s - p <NEWLINE> b = ( n - s ) // p + 1 <NEWLINE> if 1 <= p < b and 0 <= q < b and ( n - s ) % p == 0 : <NEWLINE> <INDENT> if digit ( b , n ) == s : <NEWLINE> <INDENT> print ( b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> if s - i - j <= k and s - i - j >= 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import bisect <NEWLINE> def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( n ) : <NEWLINE> <INDENT> for b in range ( a + 1 , n ) : <NEWLINE> <INDENT> c = bisect . bisect_left ( l , l [ a ] + l [ b ] ) <NEWLINE> if c > b : <NEWLINE> <INDENT> ans += c - b - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
from math import atan , degrees <NEWLINE> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if pow ( a , 2 ) * b == x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif b * pow ( a , 2 ) / 2 <= x : <NEWLINE> <INDENT> print ( 90 - degrees ( atan ( ( a / 2 ) / ( b - x / pow ( a , 2 ) ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 90 - degrees ( atan ( ( 2 * x / ( a * b ) ) / b ) ) ) <NEWLINE> <DEDENT>
import bisect as bi <NEWLINE> <NL> N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( Q ) ] <NEWLINE> B = [ K ] * N <NEWLINE> p = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> A . append ( i + 1 ) <NEWLINE> <DEDENT> C = sorted ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B [ i ] += bi . bisect_left ( C , i + 2 ) - p - 1 <NEWLINE> p = bi . bisect_left ( C , i + 2 ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if ( B [ i ] > Q ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( an ) for an in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> set_a = set ( a ) <NEWLINE> num_of_types = len ( set_a ) <NEWLINE> if num_of_types > k : <NEWLINE> <INDENT> cnt = Counter ( a ) <NEWLINE> ans = sum ( sorted ( cnt . values ( ) ) [ : num_of_types - k ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> color = [ - 1 ] * N <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> def steps ( v , col = 0 ) : <NEWLINE> <INDENT> color [ v ] = col <NEWLINE> for nv in graph [ v ] : <NEWLINE> <INDENT> if color [ nv ] != - 1 : <NEWLINE> <INDENT> if color [ nv ] == col : return False <NEWLINE> continue <NEWLINE> <DEDENT> if not steps ( nv , 1 - col ) : return False <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> flag = True <NEWLINE> for v in range ( N ) : <NEWLINE> <INDENT> if color [ v ] != - 1 : continue <NEWLINE> if not steps ( v ) : flag = False <NEWLINE> <NL> <DEDENT> if flag : <NEWLINE> <INDENT> tmp = color . count ( 0 ) <NEWLINE> print ( tmp * ( N - tmp ) - M ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N * ( N - 1 ) // 2 - M ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a % 3 == 0 or b % 3 == 0 or ( a + b ) % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flag = 0 <NEWLINE> A = a . sort ( ) <NEWLINE> num = [ ] <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( 1 , n , 2 ) : <NEWLINE> <INDENT> num . append ( i ) <NEWLINE> num . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if n % 2 == 1 : <NEWLINE> <INDENT> num = [ 0 ] <NEWLINE> for i in range ( 2 , n , 2 ) : <NEWLINE> <INDENT> num . append ( i ) <NEWLINE> num . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if num == a : <NEWLINE> <INDENT> print ( 2 ** ( n // 2 ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> ini = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> inm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> inl = lambda : list ( inm ( ) ) <NEWLINE> ins = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> debug = lambda * a , ** kw : print ( <STRING> , * a , <STRING> , ** dict ( file = sys . stderr , ** kw ) ) <NEWLINE> <NL> N = ini ( ) <NEWLINE> A = inl ( ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> big = A [ - 1 ] <NEWLINE> small = A [ 0 ] <NEWLINE> res = [ ] <NEWLINE> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> if A [ i ] > 0 : <NEWLINE> <INDENT> res . append ( ( small , A [ i ] ) ) <NEWLINE> small -= A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res . append ( ( big , A [ i ] ) ) <NEWLINE> big -= A [ i ] <NEWLINE> <DEDENT> <DEDENT> res . append ( ( big , small ) ) <NEWLINE> print ( big - small ) <NEWLINE> for x , y in res : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> newP = P [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> newP = ( min ( newP , P [ i ] ) ) <NEWLINE> if newP == P [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> from functools import reduce <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> k , s = rm ( ) <NEWLINE> cnt = 0 <NEWLINE> for x in range ( k , - 1 , - 1 ) : <NEWLINE> <INDENT> for y in range ( k , - 1 , - 1 ) : <NEWLINE> <INDENT> if 0 <= s - x - y <= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> dp = [ - 1 ] * N <NEWLINE> dp [ N - 1 ] = A [ 0 ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> target_index = bisect . bisect_left ( dp , A [ i ] ) <NEWLINE> dp [ target_index - 1 ] = A [ i ] <NEWLINE> <NL> <DEDENT> print ( N - dp . count ( - 1 ) ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if B - A + 1 >= 2 * K : <COMMENT> <NEWLINE> <INDENT> res_list = [ i for i in range ( A , A + K ) ] + [ i for i in range ( B - K + 1 , B + 1 ) ] <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> res_list = [ i for i in range ( A , B + 1 ) ] <NEWLINE> <DEDENT> for i in res_list : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> TD = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> TD . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> <NL> import heapq <NEWLINE> hq = [ ] <NEWLINE> heapq . heapify ( hq ) <NEWLINE> selected = set ( ) <NEWLINE> ans = 0 <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> t , d = TD . pop ( ) <NEWLINE> if t in selected : <NEWLINE> <INDENT> heapq . heappush ( hq , d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> selected . add ( t ) <NEWLINE> <DEDENT> ans += d <NEWLINE> <DEDENT> ans += len ( selected ) ** 2 <NEWLINE> <NL> tmp = ans <NEWLINE> while TD : <NEWLINE> <INDENT> t , d = TD . pop ( ) <NEWLINE> if t in selected : continue <NEWLINE> selected . add ( t ) <NEWLINE> if len ( hq ) == 0 : break <NEWLINE> tmp -= heapq . heappop ( hq ) <NEWLINE> tmp += d <NEWLINE> tmp += len ( selected ) * 2 - 1 <NEWLINE> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lower_a = list ( map ( lambda x : x - 1 , a ) ) <NEWLINE> upper_a = list ( map ( lambda x : x + 1 , a ) ) <NEWLINE> extended_a = collections . Counter ( a + lower_a + upper_a ) <NEWLINE> <NL> print ( extended_a . most_common ( ) [ 0 ] [ 1 ] ) <NEWLINE>
import sys <NEWLINE> import heapq , math <NEWLINE> from itertools import zip_longest , permutations , combinations , combinations_with_replacement <NEWLINE> from itertools import accumulate , dropwhile , takewhile , groupby <NEWLINE> from functools import lru_cache <NEWLINE> from copy import deepcopy <NEWLINE> <NL> N , S = [ int ( input ( ) ) , int ( input ( ) ) ] <NEWLINE> <NL> <NL> def solve1 ( ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> while i * i <= N : <NEWLINE> <INDENT> if ok ( i , N , S ) : <NEWLINE> <INDENT> return i <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> return 1 << 60 <NEWLINE> <NL> <NL> <DEDENT> def solve2 ( ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> ret = 1 << 60 <NEWLINE> while i * i <= N : <NEWLINE> <INDENT> b = ( N - S ) // i + 1 <NEWLINE> if ok ( b , N , S ) : <NEWLINE> <INDENT> ret = min ( ret , b ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def ok ( b , N , S ) : <NEWLINE> <INDENT> if b <= 1 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> s , n = 0 , N <NEWLINE> while n > 0 : <NEWLINE> <INDENT> s += n % b <NEWLINE> n //= b <NEWLINE> <NL> <DEDENT> return s == S <NEWLINE> <NL> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> if S == N : <NEWLINE> <INDENT> return N + 1 <NEWLINE> <DEDENT> ret = min ( solve1 ( ) , solve2 ( ) ) <NEWLINE> return ret if ret != 1 << 60 else - 1 <NEWLINE> <NL> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> edge = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ x - 1 ] . append ( [ y - 1 , z ] ) <NEWLINE> edge [ y - 1 ] . append ( [ x - 1 , z ] ) <NEWLINE> <DEDENT> q , k = map ( int , input ( ) . split ( ) ) <NEWLINE> dist = [ - 1 ] * n <NEWLINE> def dfs ( node , d ) : <NEWLINE> <INDENT> dist [ node ] = d <NEWLINE> for i in edge [ node ] : <NEWLINE> <INDENT> if dist [ i [ 0 ] ] == - 1 : <NEWLINE> <INDENT> dfs ( i [ 0 ] , d + i [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( k - 1 , 0 ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( dist [ x - 1 ] + dist [ y - 1 ] ) <NEWLINE> <DEDENT>
l = [ ] <NEWLINE> m = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> i = int ( input ( ) ) <NEWLINE> k = 10 - ( i % 10 ) <NEWLINE> l . append ( i ) <NEWLINE> if k != 10 : <NEWLINE> <INDENT> m . append ( k ) <NEWLINE> <DEDENT> <DEDENT> m . sort ( ) <NEWLINE> if len ( m ) == 0 : <NEWLINE> <INDENT> print ( sum ( l ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = sum ( m ) - m [ - 1 ] <NEWLINE> print ( sum ( l ) + s ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> a = [ 0 ] * len ( s ) <NEWLINE> r , l = 0 , 0 <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> r += 1 <NEWLINE> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i - 1 ] += r // 2 <NEWLINE> a [ i ] += ( r + 1 ) // 2 <NEWLINE> r = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( len ( s ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> l += 1 <NEWLINE> if s [ j ] == <STRING> : <NEWLINE> <INDENT> a [ j + 1 ] += l // 2 <NEWLINE> a [ j ] += ( l + 1 ) // 2 <NEWLINE> l = 0 <NEWLINE> <DEDENT> a [ j ] -= 1 <NEWLINE> <NL> <DEDENT> print ( * a ) <NEWLINE> <NL>
s = list ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> num = len ( s ) <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <INDENT> a = 122 - ord ( s [ i ] ) + 1 <NEWLINE> if a <= k and s [ i ] != <STRING> : <NEWLINE> <INDENT> k -= a <NEWLINE> s [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if k > 0 : <NEWLINE> <INDENT> s [ - 1 ] = chr ( ord ( s [ - 1 ] ) + k % 26 ) <NEWLINE> <DEDENT> print ( * s , sep = <STRING> ) <NEWLINE> <NL>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> start = [ K - Q ] * N <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> start [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if start [ i ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> i = 0 <NEWLINE> <NL> while i < n : <NEWLINE> <INDENT> ko = 1 <NEWLINE> while ( i + ko ) < n and a [ i ] == a [ i + ko ] : <NEWLINE> <INDENT> ko += 1 <NEWLINE> <DEDENT> if ko % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> i += ko <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> p [ int ( input ( ) ) ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( <STRING> if k - ( q - p [ i ] ) > 0 else <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 1 <NEWLINE> minp = P [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if minp >= P [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> minp = min ( minp , P [ i ] ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> low = 0 <NEWLINE> high = 100001 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> l , m = map ( int , input ( ) . split ( ) ) <NEWLINE> low = max ( low , l ) <NEWLINE> high = min ( high , m ) <NEWLINE> <DEDENT> if high - low + 1 < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( high - low + 1 , n ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( lambda x : x - 1 , map ( int , input ( ) . split ( ) ) ) <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> def dfs ( v , pre = - 1 ) : <NEWLINE> <INDENT> for nx in G [ v ] : <NEWLINE> <INDENT> if nx == pre : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ nx ] += ans [ v ] <NEWLINE> dfs ( nx , v ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ ( a [ i ] - i - 1 ) for i in range ( n ) ] <NEWLINE> b = sorted ( b ) <NEWLINE> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> res = b [ ( n - 1 ) // 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = ( b [ n // 2 - 1 ] + b [ n // 2 ] ) // 2 <NEWLINE> <NL> <DEDENT> print ( sum ( map ( abs , [ b [ i ] - res for i in range ( n ) ] ) ) ) <NEWLINE>
a , b , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = [ int ( input ( ) ) for i in range ( a ) ] <NEWLINE> t = [ int ( input ( ) ) for i in range ( b ) ] <NEWLINE> <NL> import bisect <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> s2 = 10 ** 12 <NEWLINE> t2 = 10 ** 12 <NEWLINE> qq = int ( input ( ) ) <NEWLINE> sp = bisect . bisect ( s , qq ) <NEWLINE> tp = bisect . bisect ( t , qq ) <NEWLINE> s1 = s [ sp - 1 ] <NEWLINE> if sp < a : <NEWLINE> <INDENT> s2 = s [ sp ] <NEWLINE> <NL> <DEDENT> t1 = t [ tp - 1 ] <NEWLINE> if tp < b : <NEWLINE> <INDENT> t2 = t [ tp ] <NEWLINE> <DEDENT> print ( min ( abs ( qq - s1 ) + abs ( s1 - t1 ) , abs ( qq - s1 ) + abs ( s1 - t2 ) , <NEWLINE> <INDENT> abs ( qq - s2 ) + abs ( s2 - t1 ) , abs ( qq - s2 ) + abs ( s2 - t2 ) , <NEWLINE> abs ( qq - t1 ) + abs ( t1 - s1 ) , abs ( qq - t1 ) + abs ( t1 - s2 ) , <NEWLINE> abs ( qq - t2 ) + abs ( t2 - s1 ) , abs ( qq - t2 ) + abs ( t2 - s2 ) ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = n * ( n - 1 ) // 2 <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = dict ( ) <NEWLINE> <COMMENT> <NL> for a in A : <NEWLINE> <INDENT> cnt [ a ] = cnt . setdefault ( a , 0 ) + 1 <NEWLINE> cnt [ a - 1 ] = cnt . setdefault ( a - 1 , 0 ) + 1 <NEWLINE> cnt [ a + 1 ] = cnt . setdefault ( a + 1 , 0 ) + 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> cnt_sort = sorted ( cnt . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> cnt_sort . reverse ( ) <NEWLINE> <NL> print ( cnt_sort [ 0 ] [ 1 ] ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> finput = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> class Unionfind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = [ - 1 ] * n <NEWLINE> self . ranks = [ 0 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . ranks [ x ] < self . ranks [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> if self . ranks [ x ] == self . ranks [ y ] : <NEWLINE> <INDENT> self . ranks [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def issametree ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( finput ( ) ) <NEWLINE> coor = [ list ( map ( int , finput ( ) . split ( ) ) ) + [ i ] for i in range ( n ) ] <NEWLINE> coor . sort ( key = lambda e : e [ 0 ] ) <NEWLINE> cost = lambda e , f : min ( abs ( e [ 0 ] - f [ 0 ] ) , abs ( e [ 1 ] - f [ 1 ] ) ) <NEWLINE> ew = dict ( ( ( coor [ i ] [ 2 ] , coor [ i + 1 ] [ 2 ] ) , cost ( coor [ i ] [ : 2 ] , coor [ i + 1 ] [ : 2 ] ) ) for i in range ( n - 1 ) ) <NEWLINE> coor . sort ( key = lambda e : e [ 1 ] ) <NEWLINE> ew . update ( dict ( ( ( coor [ i ] [ 2 ] , coor [ i + 1 ] [ 2 ] ) , cost ( coor [ i ] [ : 2 ] , coor [ i + 1 ] [ : 2 ] ) ) for i in range ( n - 1 ) ) ) <NEWLINE> edges = sorted ( list ( iter ( ew ) ) , key = lambda e : ew [ e ] ) <NEWLINE> v = Unionfind ( n ) <NEWLINE> totcost = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for edge in edges : <NEWLINE> <INDENT> if not v . issametree ( edge [ 0 ] , edge [ 1 ] ) : <NEWLINE> <INDENT> v . union ( edge [ 0 ] , edge [ 1 ] ) <NEWLINE> totcost += ew [ edge ] <NEWLINE> <DEDENT> <DEDENT> print ( totcost ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from copy import deepcopy <NEWLINE> import itertools <NEWLINE> <NL> A , B , C , D , E , F = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> qA = [ i // 100 for i in range ( 0 , F + 1 , A * 100 ) ] <NEWLINE> qB = [ i // 100 for i in range ( 0 , F + 1 , B * 100 ) ] <NEWLINE> qC = [ i for i in range ( 0 , F + 1 , C ) ] <NEWLINE> qD = [ i for i in range ( 0 , F + 1 , D ) ] <NEWLINE> <NL> W = set ( qA + qB ) <NEWLINE> for i in range ( F // min ( A , B ) ) : <NEWLINE> <INDENT> nW = deepcopy ( W ) <NEWLINE> for w in W : <NEWLINE> <INDENT> if ( w + A ) * 100 <= F : <NEWLINE> <INDENT> nW . add ( w + A ) <NEWLINE> <DEDENT> if ( w + B ) * 100 <= F : <NEWLINE> <INDENT> nW . add ( w + B ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( W ) == len ( nW ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> W = deepcopy ( nW ) <NEWLINE> <NL> <DEDENT> W = nW <NEWLINE> <NL> S = set ( qC + qD ) <NEWLINE> for i in range ( F // min ( C , D ) ) : <NEWLINE> <INDENT> nS = deepcopy ( S ) <NEWLINE> for s in S : <NEWLINE> <INDENT> if ( s + C ) <= F : <NEWLINE> <INDENT> nS . add ( s + C ) <NEWLINE> <DEDENT> if ( s + D ) <= F : <NEWLINE> <INDENT> nS . add ( s + D ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( S ) == len ( nS ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> S = deepcopy ( nS ) <NEWLINE> <DEDENT> S = nS <NEWLINE> <NL> M = 0 <NEWLINE> Ms = 0 <NEWLINE> Mw = A <NEWLINE> for w , s in itertools . product ( W , S ) : <NEWLINE> <INDENT> if w != 0 and s <= w * E and s + 100 * w <= F : <NEWLINE> <INDENT> if M < s / ( w * 100 + s ) : <NEWLINE> <INDENT> M = s / ( w * 100 + s ) <NEWLINE> Ms = s <NEWLINE> Mw = w <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( Ms + Mw * 100 ) <NEWLINE> print ( Ms ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for i in range ( m ) ] ) <NEWLINE> broken = [ False ] * ( n + 1 ) <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> broken [ i ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> MOD = 1000000007 <NEWLINE> <NL> <NL> dp = [ 0 for i in range ( n + 1 ) ] <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if 1 in a : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if broken [ i - 1 ] and broken [ i - 2 ] : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> elif broken [ i - 1 ] : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 2 ] % MOD <NEWLINE> <DEDENT> elif broken [ i - 2 ] : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] % MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans_A = [ ] <NEWLINE> ans_B = [ ] <NEWLINE> for i in range ( a , min ( b , a + k ) ) : <NEWLINE> <INDENT> ans_A . append ( i ) <NEWLINE> <DEDENT> for i in range ( max ( a , b - k + 1 ) , b + 1 ) : <NEWLINE> <INDENT> ans_B . append ( i ) <NEWLINE> <DEDENT> ans = sorted ( list ( set ( ans_A ) | set ( ans_B ) ) ) <NEWLINE> <NL> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> ab . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> t = 0 <NEWLINE> for x in ab : <NEWLINE> <INDENT> if t + x [ 0 ] <= x [ 1 ] : <NEWLINE> <INDENT> t += x [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> black = 0 <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += i - black <NEWLINE> black += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , read ( ) . split ( ) ) <NEWLINE> a = { int ( read ( ) ) - 1 for _ in range ( m ) } <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> dp = [ 0 ] * n <NEWLINE> if 0 not in a : <NEWLINE> <INDENT> dp [ 0 ] = 1 <NEWLINE> <DEDENT> if 1 not in a : <NEWLINE> <INDENT> dp [ 1 ] = 1 + dp [ 0 ] <NEWLINE> <DEDENT> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % mod <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b , c = N + 1 , N + 1 , N + 1 <NEWLINE> dama = 0 <NEWLINE> count = 0 <NEWLINE> <NL> if Y // N == 10000 : <NEWLINE> <INDENT> print ( N , 0 , 0 ) <NEWLINE> <DEDENT> elif Y // N == 5000 : <NEWLINE> <INDENT> print ( 0 , N , 0 ) <NEWLINE> <DEDENT> elif Y // N == 1000 : <NEWLINE> <INDENT> print ( 0 , 0 , N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stop = False <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if stop : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b -= i <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> if stop : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c -= i + j <NEWLINE> if i + j + c != N : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dama = 10000 * i + 5000 * j + 1000 * c <NEWLINE> if dama == Y : <NEWLINE> <INDENT> print ( i , j , c ) <NEWLINE> count += 1 <NEWLINE> stop = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> c = N <NEWLINE> <DEDENT> b = N + 1 <NEWLINE> <DEDENT> if count == 0 : <NEWLINE> <INDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( n * ( n - 1 ) // 2 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> score = [ ] <NEWLINE> <NL> j = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> j = next_j <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if j >= n - 1 or h [ j ] < h [ j + 1 ] : <NEWLINE> <INDENT> score . append ( cnt ) <NEWLINE> next_j = j + 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h [ j ] >= h [ j + 1 ] <NEWLINE> cnt += 1 <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( score ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a + b ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lr = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> l = 1 <NEWLINE> r = n <NEWLINE> for i , j in lr : <NEWLINE> <INDENT> l = max ( i , l ) <NEWLINE> r = min ( j , r ) <NEWLINE> <DEDENT> print ( max ( r - l + 1 , 0 ) ) <NEWLINE>
import numpy as np <NEWLINE> N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A + B > N + 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if A == 1 : <NEWLINE> <INDENT> if B == N : <NEWLINE> <INDENT> ans = [ i + 1 for i in reversed ( range ( N ) ) ] <NEWLINE> print ( * ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if B == 1 : <NEWLINE> <INDENT> if A == N : <NEWLINE> <INDENT> ans = [ i + 1 for i in range ( N ) ] <NEWLINE> print ( * ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if A >= B : <NEWLINE> <INDENT> Flag = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Flag = False <NEWLINE> A , B = B , A <NEWLINE> <COMMENT> <NL> <DEDENT> if A * B < N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = [ 1 for _ in range ( B ) ] <NEWLINE> nokori = N - B <NEWLINE> for i in range ( B ) : <NEWLINE> <INDENT> if A - L [ i ] > 0 : <NEWLINE> <INDENT> temp = min ( A - L [ i ] , nokori ) <NEWLINE> L [ i ] += temp <NEWLINE> nokori -= temp <NEWLINE> <DEDENT> if nokori == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> now = 0 <NEWLINE> P = [ [ ] for _ in range ( B ) ] <NEWLINE> for i , num in enumerate ( L ) : <NEWLINE> <INDENT> for j in range ( num ) : <NEWLINE> <INDENT> now += 1 <NEWLINE> P [ - i - 1 ] . append ( now ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = P <NEWLINE> output = [ ] <NEWLINE> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> for j in ans [ i ] : <NEWLINE> <INDENT> output . append ( j ) <NEWLINE> <DEDENT> <DEDENT> if Flag : <NEWLINE> <INDENT> print ( * output ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> output = output [ : : - 1 ] <NEWLINE> print ( * output ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for k , v in Counter ( a ) . items ( ) : <NEWLINE> <INDENT> if k > v : <NEWLINE> <INDENT> cnt += v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += ( v - k ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> n , m , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> dp = [ 1 ] + [ - 1 ] * n <NEWLINE> dp [ 1 ] = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <NL> <DEDENT> def count ( n ) : <NEWLINE> <INDENT> if dp [ n ] != - 1 : <NEWLINE> <INDENT> return dp [ n ] <NEWLINE> <DEDENT> dp [ n ] = ( count ( n - 1 ) + count ( n - 2 ) ) % ( 10 ** 9 + 7 ) <NEWLINE> return dp [ n ] <NEWLINE> <NL> <NL> <DEDENT> print ( count ( n ) ) <NEWLINE>
<COMMENT> <NL> s = input ( ) <NEWLINE> <COMMENT> <NL> if len ( s ) <= 2 : <NEWLINE> <INDENT> print ( s [ 0 ] ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> N = len ( s ) // 2 <NEWLINE> q = 0 <NEWLINE> if N % 2 == 1 : <NEWLINE> <INDENT> q = 1 <NEWLINE> <DEDENT> Odd = [ ] <NEWLINE> for i in range ( N + q ) : <NEWLINE> <INDENT> Odd . append ( s [ 2 * i ] ) <NEWLINE> <DEDENT> Odd = <STRING> . join ( Odd ) <NEWLINE> print ( Odd ) <NEWLINE> <DEDENT>
h = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 10 ** 12 ) : <NEWLINE> <INDENT> if 2 ** i <= h < 2 ** ( i + 1 ) : <NEWLINE> <INDENT> ans = 2 ** ( i + 1 ) - 1 <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for n in range ( N ) ] <NEWLINE> a1 = sorted ( A ) [ - 1 ] <NEWLINE> a2 = sorted ( A ) [ - 2 ] <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a == a1 : <NEWLINE> <INDENT> print ( a2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a1 ) <NEWLINE> <DEDENT> <DEDENT>
import re <NEWLINE> S = input ( ) <NEWLINE> print ( 2 * min ( S . count ( <STRING> ) , S . count ( <STRING> ) ) ) <NEWLINE>
def readinput ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> return n , l <NEWLINE> <NL> <DEDENT> def main ( n , a ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> hist = [ 0 ] * 61 <NEWLINE> bs = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> s = bin ( a [ i ] ) [ 2 : ] <NEWLINE> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> hist [ len ( s ) - j - 1 ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> sum = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> b = 1 <NEWLINE> for j in range ( 61 ) : <NEWLINE> <INDENT> sum = ( sum + ( hist [ j ] * ( n - hist [ j ] ) * b ) % MOD ) % MOD <NEWLINE> b *= 2 <NEWLINE> <NL> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , l = readinput ( ) <NEWLINE> ans = main ( n , l ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( a , a + k ) : <NEWLINE> <INDENT> if i <= b : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> if i >= a + k : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> while j + i <= N : <NEWLINE> <INDENT> A . append ( S [ j : j + i ] ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> A = list ( set ( A ) ) <NEWLINE> A . sort ( ) <NEWLINE> print ( A [ K - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> * H , = map ( int , input ( ) . split ( ) ) <NEWLINE> L = len ( H ) <NEWLINE> <NL> cnt = 0 <NEWLINE> prv = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if prv < H [ i ] : <NEWLINE> <INDENT> cnt += H [ i ] - prv <NEWLINE> <DEDENT> prv = H [ i ] <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> <NL> N , K = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> S = sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> l = x = ans = 0 <NEWLINE> for r in range ( N ) : <NEWLINE> <INDENT> if S [ r ] == <STRING> : <NEWLINE> <INDENT> if r == 0 or S [ r - 1 ] == <STRING> : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> if x > K : <NEWLINE> <INDENT> while S [ l ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> while S [ l ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> x -= 1 <NEWLINE> <DEDENT> ans = max ( ans , r - l + 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = x * ( i + 1 ) <NEWLINE> x = x % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
n , a_start , b_start , a_goal , b_goal = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> no_rock_double = True <NEWLINE> for i in range ( a_start , max ( b_goal , a_goal ) ) : <NEWLINE> <INDENT> if i + 1 < n : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> no_rock_double = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> can_switch = False <NEWLINE> if a_goal > b_goal : <NEWLINE> <INDENT> for i in range ( b_start - 1 , b_goal ) : <NEWLINE> <INDENT> if s [ i - 1 : i + 2 ] == <STRING> : <NEWLINE> <INDENT> can_switch = True <NEWLINE> <DEDENT> <DEDENT> if no_rock_double and can_switch : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if no_rock_double : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
from bisect import bisect_left <NEWLINE> <NL> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> pos = bisect_left ( x , 0 ) <NEWLINE> if pos < len ( x ) and x [ pos ] == 0 : <NEWLINE> <INDENT> k -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x . insert ( pos , 0 ) <NEWLINE> <NL> <DEDENT> l = pos <NEWLINE> r = pos + k <NEWLINE> <NL> if r >= len ( x ) : <NEWLINE> <INDENT> diff = r - len ( x ) + 1 <NEWLINE> l -= diff <NEWLINE> r -= diff <NEWLINE> <NL> <DEDENT> ans = min ( abs ( x [ l ] ) , x [ r ] ) * 2 + max ( abs ( x [ l ] ) , x [ r ] ) <NEWLINE> <NL> while r >= pos : <NEWLINE> <INDENT> if l < 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> dist = min ( abs ( x [ l ] ) , x [ r ] ) * 2 + max ( abs ( x [ l ] ) , x [ r ] ) <NEWLINE> if dist < ans : <NEWLINE> <INDENT> ans = dist <NEWLINE> <NL> <DEDENT> l -= 1 <NEWLINE> r -= 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numba as nb <NEWLINE> @ nb . njit <NEWLINE> def solve ( n , k , a ) : <NEWLINE> <INDENT> dp = [ 0 ] * n <NEWLINE> dp [ 1 ] = abs ( a [ 1 ] - a [ 0 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> mi = 10 ** 9 <NEWLINE> temp = 1 <NEWLINE> for j in range ( i - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if temp > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> if abs ( a [ i ] - a [ j ] ) + dp [ j ] < mi : <NEWLINE> <INDENT> mi = abs ( a [ i ] - a [ j ] ) + dp [ j ] <NEWLINE> <DEDENT> <DEDENT> dp [ i ] = mi <NEWLINE> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> solve ( n , k , a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ A [ i ] - 1 ] == i + 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( count / 2 ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> field = [ input ( ) for i in range ( H ) ] <NEWLINE> route_count_memory = [ [ - 1 ] * W for i in range ( H ) ] <NEWLINE> route_count_memory [ 0 ] [ 0 ] = 1 <NEWLINE> <NL> def get_route_count ( i , j ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> if route_count_memory [ i ] [ j ] != - 1 : <NEWLINE> <INDENT> return route_count_memory [ i ] [ j ] <NEWLINE> <DEDENT> if 0 <= i - 1 < H and field [ i - 1 ] [ j ] != <STRING> : <NEWLINE> <INDENT> result += get_route_count ( i - 1 , j ) <NEWLINE> <DEDENT> if 0 <= j - 1 < W and field [ i ] [ j - 1 ] != <STRING> : <NEWLINE> <INDENT> result += get_route_count ( i , j - 1 ) <NEWLINE> <DEDENT> route_count_memory [ i ] [ j ] = result <NEWLINE> return result <NEWLINE> <NL> <DEDENT> print ( get_route_count ( H - 1 , W - 1 ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
import math <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <DEDENT> l = ( lcm ( n , m ) ) <NEWLINE> <NL> sdict = { } <NEWLINE> s_num = [ ] <NEWLINE> for i , moji in enumerate ( list ( s ) ) : <NEWLINE> <INDENT> num = i * l // n + 1 <NEWLINE> sdict [ num - 1 ] = moji <NEWLINE> s_num . append ( num - 1 ) <NEWLINE> <NL> <DEDENT> tdct = { } <NEWLINE> t_num = [ ] <NEWLINE> for i , moji in enumerate ( list ( t ) ) : <NEWLINE> <INDENT> num = i * l // m + 1 <NEWLINE> tdct [ num - 1 ] = moji <NEWLINE> t_num . append ( num - 1 ) <NEWLINE> <NL> <DEDENT> stlst = list ( set ( s_num ) & set ( t_num ) ) <NEWLINE> <NL> for i in stlst : <NEWLINE> <INDENT> if sdict [ i ] != tdct [ i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 for i in range ( N + 1 ) ] <NEWLINE> true = [ True for i in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> true [ a ] = False <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> ans [ 0 ] = 1 <NEWLINE> ans [ 1 ] = 1 <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( i - 2 , i ) : <NEWLINE> <INDENT> if true [ j ] : <NEWLINE> <INDENT> ans [ i ] += ans [ j ] % mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans [ N ] % mod ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = set ( ) <NEWLINE> r = len ( s ) <NEWLINE> <NL> if r == 1 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( r ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> ans . add ( s [ i : i + j + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( sorted ( list ( ans ) ) [ k - 1 ] ) <NEWLINE> <DEDENT>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) - 1 for i in range ( q ) ] <NEWLINE> point = [ k - q for i in range ( n ) ] <NEWLINE> for i in a : <NEWLINE> <INDENT> point [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in point : <NEWLINE> <INDENT> print ( <STRING> if i > 0 else <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> import collections <NEWLINE> <NL> c = collections . Counter ( a ) <NEWLINE> c2 = sorted ( c . values ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( len ( c ) - K ) : <NEWLINE> <INDENT> sum += c2 [ i ] <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = Counter ( A ) <NEWLINE> ans = 0 <NEWLINE> start , end = min ( A ) , max ( A ) + 1 <NEWLINE> for v in range ( start , end ) : <NEWLINE> <INDENT> ans = max ( C [ v - 1 ] + C [ v ] + C [ v + 1 ] , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> xyh = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> xyh . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> xyh_sorted = sorted ( xyh , key = lambda x : x [ 2 ] , reverse = True ) <NEWLINE> <NL> answer = [ 0 , 0 , 0 ] <NEWLINE> for cy in range ( 0 , 101 ) : <NEWLINE> <INDENT> for cx in range ( 0 , 101 ) : <NEWLINE> <INDENT> H = xyh_sorted [ 0 ] [ 2 ] + abs ( xyh_sorted [ 0 ] [ 0 ] - cx ) + abs ( xyh_sorted [ 0 ] [ 1 ] - cy ) <NEWLINE> flag = True <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> h2 = max ( H - abs ( xyh_sorted [ i ] [ 0 ] - cx ) - abs ( xyh_sorted [ i ] [ 1 ] - cy ) , 0 ) <NEWLINE> if h2 != xyh_sorted [ i ] [ 2 ] : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> answer = [ cx , cy , H ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> answerString = str ( answer [ 0 ] ) + <STRING> + str ( answer [ 1 ] ) + <STRING> + str ( answer [ 2 ] ) <NEWLINE> print ( answerString ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> sum_a = sum ( a ) <NEWLINE> <NL> ans = n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> sum_a -= a [ i - 1 ] <NEWLINE> if a [ i - 1 ] <= 2 * sum_a : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( 2 , int ( p ** 0.5 ) + 2 ) : <NEWLINE> <INDENT> if p % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while p % i == 0 : <NEWLINE> <INDENT> p /= i <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> l . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if p != 1 : <NEWLINE> <INDENT> l . append ( [ p , 1 ] ) <NEWLINE> <NL> <DEDENT> for i , j in l : <NEWLINE> <INDENT> while j >= n : <NEWLINE> <INDENT> ans *= i <NEWLINE> j -= n <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
from heapq import ( <NEWLINE> <INDENT> heapify , <COMMENT> <NEWLINE> heappop , <NEWLINE> heappush , <NEWLINE> heappushpop , <NEWLINE> heapreplace <NEWLINE> ) <NEWLINE> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> A = [ - i for i in map ( int , input ( ) . split ( ) ) ] <NEWLINE> heapify ( A ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> s = - heappop ( A ) <NEWLINE> s //= 2 <NEWLINE> heappush ( A , - s ) <NEWLINE> <NL> <DEDENT> print ( - sum ( A ) ) <NEWLINE>
from math import * <NEWLINE> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> f = ( c * d ) // gcd ( c , d ) <NEWLINE> r = f <NEWLINE> rock = 2 <NEWLINE> compteur = ( b // f ) - ( a // f ) <NEWLINE> if a % f == 0 : <NEWLINE> <INDENT> compteur += 1 <NEWLINE> <DEDENT> div1 = ( ( b // c ) - ( a // c ) ) <NEWLINE> div2 = ( ( b // d ) - ( a // d ) ) <NEWLINE> if a % c == 0 : <NEWLINE> <INDENT> div1 += 1 <NEWLINE> <DEDENT> if a % d == 0 : <NEWLINE> <INDENT> div2 += 1 <NEWLINE> <DEDENT> roger = ( div1 + div2 ) - compteur <NEWLINE> mm = ( b - a ) + 1 <NEWLINE> print ( mm - roger ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> code = list ( set ( list ( S ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in code : <NEWLINE> <INDENT> for j in code : <NEWLINE> <INDENT> for k in code : <NEWLINE> <INDENT> count = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if count == 0 : <NEWLINE> <INDENT> if s == i : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> elif count == 1 : <NEWLINE> <INDENT> if s == j : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> elif count == 2 : <NEWLINE> <INDENT> if s == k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count == 3 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ float ( <STRING> ) ] * n <NEWLINE> <NL> dp [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ j ] + abs ( h [ i ] - h [ j ] ) for j in range ( max ( 0 , i - k ) , i ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
import sys <NEWLINE> from functools import reduce <NEWLINE> from collections import defaultdict <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def prime ( x ) : <NEWLINE> <INDENT> pf = defaultdict ( int ) <NEWLINE> for i in range ( 2 , int ( x ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> while x % i == 0 : <NEWLINE> <INDENT> pf [ i ] += 1 <NEWLINE> x //= i <NEWLINE> <DEDENT> <DEDENT> if x > 1 : <NEWLINE> <INDENT> pf [ x ] = 1 <NEWLINE> <DEDENT> return pf <NEWLINE> <NL> <NL> <DEDENT> def lcm ( x , y ) : <NEWLINE> <INDENT> xx = x . copy ( ) <NEWLINE> yy = y . copy ( ) <NEWLINE> for k , v in yy . items ( ) : <NEWLINE> <INDENT> xx [ k ] = max ( xx [ k ] , v ) <NEWLINE> <DEDENT> return xx <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a2 = list ( map ( prime , a ) ) <NEWLINE> lcms = reduce ( lcm , a2 ) <NEWLINE> lcmss = 1 <NEWLINE> for k , v in lcms . items ( ) : <NEWLINE> <INDENT> lcmss = ( lcmss * ( k ** v ) ) % mod <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for aa in a : <NEWLINE> <INDENT> ans += lcmss * pow ( aa , - 1 , mod ) <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> fac = [ 1 for _ in range ( n + 1 ) ] <NEWLINE> inv = [ 1 for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i <NEWLINE> fac [ i ] %= mod <NEWLINE> inv [ i ] = inv [ i - 1 ] * pow ( i , - 1 , mod ) <NEWLINE> inv [ i ] %= mod <NEWLINE> <NL> <DEDENT> def comb ( a , b , mod ) : <NEWLINE> <INDENT> return ( fac [ a ] * inv [ b ] * inv [ a - b ] ) % mod <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( k - 1 , n ) : <NEWLINE> <INDENT> nck = comb ( i , k - 1 , mod ) <NEWLINE> ans += nck * a [ i ] <NEWLINE> ans -= nck * a [ n - i - 1 ] <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> sort_a = sorted ( a , reverse = True ) <NEWLINE> amax = sort_a [ 0 ] <NEWLINE> asecond = sort_a [ 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = a [ i ] <NEWLINE> if tmp == amax : <NEWLINE> <INDENT> print ( asecond ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( amax ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> def f ( n , p , a ) : <NEWLINE> <INDENT> odd = sum ( i % 2 for i in a ) <NEWLINE> if odd == 0 : <NEWLINE> <INDENT> if p == 0 : <NEWLINE> <INDENT> return 2 ** n <NEWLINE> <DEDENT> elif p == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return 2 ** ( n - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( f ( n , p , a ) ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> F = [ ] <NEWLINE> for ch in S : <NEWLINE> <INDENT> if ch == <STRING> : <NEWLINE> <INDENT> if len ( F ) > 0 : <NEWLINE> <INDENT> F . pop ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> F . append ( ch ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( F ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans_list = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans_list [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , ans_list ) ) ) <NEWLINE>
import sys , math , collections , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> color1 = - 1 <NEWLINE> color2 = - 1 <NEWLINE> color3 = - 1 <NEWLINE> <NL> m = 10 ** 9 + 7 <NEWLINE> patern = 1 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if color1 == a - 1 and color2 == a - 1 and color3 == a - 1 : <NEWLINE> <INDENT> patern = ( patern * 3 ) % m <NEWLINE> color1 = a <NEWLINE> <NL> <DEDENT> elif ( color1 != a - 1 and color2 == a - 1 and color3 == a - 1 ) : <NEWLINE> <INDENT> patern = ( patern * 2 ) % m <NEWLINE> color2 = a <NEWLINE> <NL> <DEDENT> elif ( color1 == a - 1 and color2 == a - 1 and color3 != a - 1 ) : <NEWLINE> <INDENT> patern = ( patern * 2 ) % m <NEWLINE> color1 = a <NEWLINE> <DEDENT> elif ( color1 == a - 1 and color2 != a - 1 and color3 != a - 1 ) : <NEWLINE> <INDENT> color1 = a <NEWLINE> <NL> <DEDENT> elif ( color1 != a - 1 and color2 == a - 1 and color3 != a - 1 ) : <NEWLINE> <INDENT> color2 = a <NEWLINE> <NL> <DEDENT> elif ( color1 != a - 1 and color2 != a - 1 and color3 == a - 1 ) : <NEWLINE> <INDENT> color3 = a <NEWLINE> <NL> <DEDENT> elif ( color1 != a - 1 and color2 != a - 1 and color3 != a - 1 ) : <NEWLINE> <INDENT> patern = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( patern ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( h ) ] <NEWLINE> b = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( h ) ] <NEWLINE> <NL> ab = [ [ 0 ] * w for i in range ( h ) ] <NEWLINE> for ch in range ( h ) : <NEWLINE> <INDENT> for cw in range ( w ) : <NEWLINE> <INDENT> ab [ ch ] [ cw ] = abs ( a [ ch ] [ cw ] - b [ ch ] [ cw ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ab0 = ab [ 0 ] [ 0 ] <NEWLINE> size = 80 * ( h + w ) <NEWLINE> dp = [ [ 0 ] * w for hh in range ( h ) ] <NEWLINE> dp [ 0 ] [ 0 ] |= 2 ** ( size + ab0 ) <NEWLINE> dp [ 0 ] [ 0 ] |= 2 ** ( size - ab0 ) <NEWLINE> for ch in range ( h ) : <NEWLINE> <INDENT> for cw in range ( w ) : <NEWLINE> <INDENT> if ch < h - 1 : <NEWLINE> <INDENT> dp [ ch + 1 ] [ cw ] |= dp [ ch ] [ cw ] << ab [ ch + 1 ] [ cw ] <NEWLINE> dp [ ch + 1 ] [ cw ] |= dp [ ch ] [ cw ] >> ab [ ch + 1 ] [ cw ] <NEWLINE> <DEDENT> if cw < w - 1 : <NEWLINE> <INDENT> dp [ ch ] [ cw + 1 ] |= dp [ ch ] [ cw ] << ab [ ch ] [ cw + 1 ] <NEWLINE> dp [ ch ] [ cw + 1 ] |= dp [ ch ] [ cw ] >> ab [ ch ] [ cw + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> a = dp [ h - 1 ] [ w - 1 ] >> size <NEWLINE> m = a & ( - a ) <NEWLINE> print ( m . bit_length ( ) - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif N == 2 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( N * ( N - 1 ) ) // 2 ) <NEWLINE> <DEDENT>
H , W , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> C = H - A <NEWLINE> D = W - B <NEWLINE> p = 1000000007 <NEWLINE> <NL> def power ( a , b ) : <COMMENT> <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif b % 2 == 0 : <NEWLINE> <INDENT> return power ( a , b // 2 ) ** 2 % p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return power ( a , b // 2 ) ** 2 * a % p <NEWLINE> <NL> <DEDENT> <DEDENT> f = [ 1 ] <COMMENT> <NEWLINE> for i in range ( H + W ) : <NEWLINE> <INDENT> f . append ( f [ i ] * ( i + 1 ) % p ) <NEWLINE> <NL> <DEDENT> I_f = [ 0 ] * ( H + W + 1 ) <COMMENT> <NEWLINE> I_f [ H + W ] = power ( f [ H + W ] , p - 2 ) <NEWLINE> for i in reversed ( range ( H + W ) ) : <NEWLINE> <INDENT> I_f [ i ] = I_f [ i + 1 ] * ( i + 1 ) % p <NEWLINE> <NL> <DEDENT> def combi ( a , b ) : <COMMENT> <NEWLINE> <INDENT> return f [ a + b ] * I_f [ a ] * I_f [ b ] % p <NEWLINE> <NL> <DEDENT> x = 0 <NEWLINE> for i in range ( C ) : <NEWLINE> <INDENT> x = ( x + combi ( i , B - 1 ) * combi ( D - 1 , H - i - 1 ) ) % p <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> readline = sys . stdin . readline <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> n = int ( readline ( ) ) <NEWLINE> arr = list ( map ( int , readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> x = 1 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if arr [ j ] & x != 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> ans += ( c * ( n - c ) ) * x <NEWLINE> ans %= mod <NEWLINE> x = x * 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if <STRING> not in globals ( ) : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
N , D , A = map ( int , input ( ) . split ( ) ) <NEWLINE> X = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , h = map ( int , input ( ) . split ( ) ) <NEWLINE> X [ i ] = ( x , h ) <NEWLINE> <DEDENT> X = sorted ( X ) <NEWLINE> <NL> from collections import deque <NEWLINE> <NL> q = deque ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> total = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , h = X [ i ] <NEWLINE> while ( len ( q ) > 0 and q [ 0 ] [ 0 ] < x ) : <NEWLINE> <INDENT> total -= q [ 0 ] [ 1 ] <NEWLINE> q . popleft ( ) <NEWLINE> <DEDENT> h -= total <NEWLINE> if h > 0 : <NEWLINE> <INDENT> num = ( h + A - 1 ) // A <NEWLINE> ans += num <NEWLINE> damage = num * A <NEWLINE> total += damage <NEWLINE> q . append ( ( x + 2 * D , damage ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , c , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> t = sorted ( [ int ( input ( ) ) for i in range ( n ) ] ) <NEWLINE> total = 0 <NEWLINE> count = 0 <NEWLINE> while ( count != n ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> <COMMENT> <NL> for i in range ( c ) : <NEWLINE> <INDENT> if count + i >= n : <NEWLINE> <COMMENT> <NL> <INDENT> if t [ - 1 ] - t [ count ] <= k : <NEWLINE> <COMMENT> <NL> <INDENT> count = n <NEWLINE> total += 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = 0 <NEWLINE> while ( count != n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if t [ count + temp ] - t [ count ] <= k : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += temp + 1 <NEWLINE> total += 1 <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> if t [ count + i ] - t [ count ] > k : <NEWLINE> <COMMENT> <NL> <INDENT> count += i <NEWLINE> total += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> count += c <NEWLINE> total += 1 <NEWLINE> if count == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> lr . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <COMMENT> <NL> r0 = 0 <NEWLINE> tmpr = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> l0 = 0 <NEWLINE> tmpl = 0 <NEWLINE> for i , x in enumerate ( lr ) : <NEWLINE> <INDENT> l , r = x <NEWLINE> if tmpl < l : <NEWLINE> <INDENT> l0 = i <NEWLINE> tmpl = l <NEWLINE> <DEDENT> if tmpr > r : <NEWLINE> <INDENT> r0 = i <NEWLINE> tmpr = r <NEWLINE> <DEDENT> <DEDENT> if l0 == r0 : <NEWLINE> <INDENT> ans = lr [ r0 ] [ 1 ] - lr [ l0 ] [ 0 ] + 1 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == l0 : continue <NEWLINE> l , r = lr [ i ] <NEWLINE> tmp = max ( tmp , r - l + 1 ) <NEWLINE> <DEDENT> ans += tmp <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans0 = max ( 0 , lr [ r0 ] [ 1 ] - lr [ l0 ] [ 0 ] + 1 ) <NEWLINE> tmp = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == l0 or i == r0 : continue <NEWLINE> l , r = lr [ i ] <NEWLINE> tmp = max ( tmp , r - l + 1 ) <NEWLINE> <DEDENT> ans0 += tmp <NEWLINE> <NL> <NL> import heapq <NEWLINE> class pqheap : <NEWLINE> <INDENT> def __init__ ( self , key = None ) : <NEWLINE> <INDENT> self . p = list ( ) <NEWLINE> self . q = list ( ) <NEWLINE> <DEDENT> def insert ( self , x ) : <NEWLINE> <INDENT> heapq . heappush ( self . p , x ) <NEWLINE> return <NEWLINE> <DEDENT> def erase ( self , x ) : <NEWLINE> <INDENT> heapq . heappush ( self . q , x ) <NEWLINE> return <NEWLINE> <DEDENT> def minimum ( self ) : <NEWLINE> <INDENT> while self . q and self . p [ 0 ] == self . q [ 0 ] : <NEWLINE> <INDENT> heapq . heappop ( self . p ) <NEWLINE> heapq . heappop ( self . q ) <NEWLINE> <DEDENT> return self . p [ 0 ] if len ( self . p ) > 0 else None <NEWLINE> <DEDENT> <DEDENT> pq = pqheap ( ) <NEWLINE> <NL> [ pq . insert ( x [ 1 ] ) for i , x in enumerate ( lr ) if i != l0 and i != r0 ] <NEWLINE> l1 , r1 = lr [ r0 ] <NEWLINE> l2 , r2 = lr [ l0 ] <NEWLINE> if pq . minimum ( ) : r2 = min ( r2 , pq . minimum ( ) ) <NEWLINE> ans1 = max ( r1 - l1 + 1 , 0 ) <NEWLINE> ans1 += max ( r2 - l2 + 1 , 0 ) <NEWLINE> for i , [ l , r ] in enumerate ( lr ) : <NEWLINE> <INDENT> if i == l0 or i == r0 : continue <NEWLINE> tmp = 0 <NEWLINE> l1 = max ( l1 , l ) <NEWLINE> pq . erase ( r ) <NEWLINE> tmp = max ( r1 - l1 + 1 , 0 ) <NEWLINE> if pq . minimum ( ) : <NEWLINE> <INDENT> r2 = min ( lr [ l0 ] [ 1 ] , pq . minimum ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l2 , r2 = lr [ l0 ] <NEWLINE> <DEDENT> tmp += max ( r2 - l2 + 1 , 0 ) <NEWLINE> ans1 = max ( ans1 , tmp ) <NEWLINE> <DEDENT> print ( max ( ans1 , ans0 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> r = [ ] <NEWLINE> bi = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> bi . append ( b ) <NEWLINE> if a % b == 0 : <NEWLINE> <INDENT> r . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r . append ( b - a % b ) <NEWLINE> <DEDENT> <DEDENT> push = 0 <NEWLINE> bi = bi [ : : - 1 ] <NEWLINE> r = r [ : : - 1 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> push = r [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> push += ( r [ i ] - push ) % bi [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( push ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> temp = As [ i ] <NEWLINE> if temp % 2 == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % 2 == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= 2 <NEWLINE> <DEDENT> ans += cnt <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections as c <NEWLINE> print ( sum ( [ 1 for i in c . Counter ( [ int ( input ( ) ) for _ in range ( int ( input ( ) ) ) ] ) . values ( ) if i % 2 != 0 ] ) ) <NEWLINE>
from bisect import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = - int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def loopa ( ) : <NEWLINE> <NL> <INDENT> n = len ( a ) <NEWLINE> dp = [ 10 ** 10 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = - 10 ** 10 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> idx = bisect ( dp , a [ i ] ) <NEWLINE> dp [ idx ] = min ( a [ i ] , dp [ idx ] ) <NEWLINE> <NL> <DEDENT> return dp <NEWLINE> <NL> <DEDENT> dp = loopa ( ) <NEWLINE> <NL> print ( bisect ( dp , 10 ** 10 - 1 ) - 1 ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> print ( ( N - 1 ) * N // 2 ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> input = sys . stdin . readline <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = ( np . array ( [ list ( input ( ) . strip ( ) ) for _ in range ( h ) ] ) == <STRING> ) . astype ( np . int ) <NEWLINE> l , r , u , d = s . copy ( ) , s . copy ( ) , s . copy ( ) , s . copy ( ) <NEWLINE> for i in range ( 1 , w ) : <NEWLINE> <INDENT> l [ : , i ] *= l [ : , i - 1 ] + 1 <NEWLINE> r [ : , w - i - 1 ] *= r [ : , w - i ] + 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , h ) : <NEWLINE> <INDENT> u [ i ] *= u [ i - 1 ] + 1 <NEWLINE> d [ h - i - 1 ] *= d [ h - i ] + 1 <NEWLINE> <DEDENT> print ( max ( [ max ( i ) for i in l + r + u + d - 3 ] ) ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> from collections import deque <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , Q = map ( int , readline ( ) . split ( ) ) <NEWLINE> AB = list ( list ( map ( int , readline ( ) . split ( ) ) ) for _ in range ( N - 1 ) ) <NEWLINE> PX = list ( list ( map ( int , readline ( ) . split ( ) ) ) for _ in range ( Q ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> value = [ 0 ] * N <NEWLINE> for p , x in PX : <NEWLINE> <INDENT> value [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> que = deque ( [ 0 ] ) <NEWLINE> visited = [ False ] * N <NEWLINE> while que : <NEWLINE> <INDENT> x = que . popleft ( ) <NEWLINE> visited [ x ] = True <NEWLINE> for y in graph [ x ] : <NEWLINE> <INDENT> if visited [ y ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> value [ y ] += value [ x ] <NEWLINE> que . append ( y ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , value ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N <= K : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H . sort ( ) <NEWLINE> H . reverse ( ) <NEWLINE> <NL> c = 0 <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> c += H [ i ] <NEWLINE> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
MM = input ( ) . split ( ) <NEWLINE> A = int ( MM [ 0 ] ) <NEWLINE> B = int ( MM [ 1 ] ) <NEWLINE> total = 1 <NEWLINE> count = 0 <NEWLINE> while total < B : <NEWLINE> <INDENT> total += A - 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> lst = [ 0 ] * N <NEWLINE> Re = S . count ( <STRING> ) <NEWLINE> Lw = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> Re -= 1 <NEWLINE> lst [ i ] = Re + Lw <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Lw += 1 <NEWLINE> lst [ i ] = Re + Lw - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = min ( lst ) <NEWLINE> print ( ans ) <NEWLINE>
o = input ( ) <NEWLINE> e = input ( ) <NEWLINE> pw = <STRING> <NEWLINE> for i in range ( len ( o ) + len ( e ) ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> pw = pw + o [ i // 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pw = pw + e [ i // 2 ] <NEWLINE> <DEDENT> <DEDENT> print ( pw ) <NEWLINE>
s = input ( ) <NEWLINE> i = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> if i == len ( s ) + 1 : <NEWLINE> <INDENT> print ( 1 ) ; exit ( ) <NEWLINE> <DEDENT> if s [ i - 1 ] != <STRING> : <NEWLINE> <INDENT> t = i <NEWLINE> ans = int ( s [ i - 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if int ( input ( ) ) < t : <NEWLINE> <INDENT> print ( 1 ) ; exit ( ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> kk = 1 <NEWLINE> for x in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans_ = 0 <NEWLINE> k = x <NEWLINE> for y in range ( 999 ) : <NEWLINE> <INDENT> if x % 2 == 0 : <NEWLINE> <INDENT> x /= 2 <NEWLINE> ans_ += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans_ > ans : <NEWLINE> <INDENT> ans = ans_ <NEWLINE> kk = k <NEWLINE> <DEDENT> <DEDENT> print ( kk ) <NEWLINE>
D , N = map ( int , input ( ) . split ( ) ) <NEWLINE> ls = [ 0 ] * 2000000 <NEWLINE> for i in range ( 1 , 2 * 10 ** 6 ) : <NEWLINE> <INDENT> if i % 100 == 0 : <NEWLINE> <INDENT> ls [ i ] = 1 <NEWLINE> <DEDENT> if i % 10000 == 0 : <NEWLINE> <INDENT> ls [ i ] = 2 <NEWLINE> <DEDENT> if i % 1000000 == 0 : <NEWLINE> <INDENT> ls [ i ] = 3 <NEWLINE> <DEDENT> <DEDENT> ii = 0 <NEWLINE> for i in range ( 1 , 2 * 10 ** 6 ) : <NEWLINE> <INDENT> if ls [ i ] == D : <NEWLINE> <INDENT> ii += 1 <NEWLINE> <DEDENT> if ii == N : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 1 <NEWLINE> total = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> total += L [ i ] <NEWLINE> if total <= X : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> blank = 2 <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) + [ 0 ] * blank <NEWLINE> INF = 10 ** 9 + 1 <NEWLINE> dp = [ INF ] * ( N + blank ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> dp [ i + 1 ] = min ( dp [ i ] + abs ( h [ i + 1 ] - h [ i ] ) , dp [ i + 1 ] ) <NEWLINE> dp [ i + 2 ] = min ( dp [ i ] + abs ( h [ i + 2 ] - h [ i ] ) , dp [ i + 2 ] ) <NEWLINE> <NL> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
n , a = int ( input ( ) ) , 0 <NEWLINE> V = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans = V [ i ] - C [ i ] <NEWLINE> if ans > 0 : <NEWLINE> <INDENT> a += ans <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( lambda x : int ( x ) + 1 , input ( ) . split ( ) ) ) <NEWLINE> ans = sum ( p [ 0 : K ] ) <NEWLINE> s = ans <NEWLINE> for i in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> s += p [ i + K - 1 ] - p [ i - 1 ] <NEWLINE> ans = max ( ans , s ) <NEWLINE> <DEDENT> print ( ans / 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from collections import Counter <NEWLINE> a = Counter ( a ) <NEWLINE> lis = [ ] <NEWLINE> <NL> for i , j in a . items ( ) : <NEWLINE> <INDENT> lis += [ i ] * ( j // 2 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> lis . sort ( reverse = True ) <NEWLINE> if len ( lis ) <= 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = lis [ 0 ] * lis [ 1 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys , math , collections , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( H ) ] <NEWLINE> operation = [ ] <NEWLINE> <NL> <COMMENT> <NL> cnt = 0 <NEWLINE> for ih in range ( H ) : <NEWLINE> <INDENT> for iw in range ( W - 1 ) : <NEWLINE> <INDENT> if a [ ih ] [ iw ] % 2 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ ih ] [ iw ] -= 1 <NEWLINE> a [ ih ] [ iw + 1 ] += 1 <NEWLINE> cnt += 1 <NEWLINE> operation . append ( [ ih + 1 , iw + 1 , ih + 1 , iw + 2 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for ih in range ( H - 1 ) : <NEWLINE> <INDENT> if a [ ih ] [ W - 1 ] % 2 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ ih ] [ W - 1 ] -= 1 <NEWLINE> a [ ih + 1 ] [ W - 1 ] += 1 <NEWLINE> cnt += 1 <NEWLINE> operation . append ( [ ih + 1 , W , ih + 2 , W ] ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> for ope in operation : <NEWLINE> <INDENT> print ( * ope ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> List = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> res = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if S == List [ i ] : <NEWLINE> <INDENT> res = i + 1 <NEWLINE> <DEDENT> <DEDENT> if res == 3 : <NEWLINE> <INDENT> res = 0 <NEWLINE> <DEDENT> print ( List [ res ] ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> N , K = MAP ( ) <NEWLINE> S = [ int ( s ) for s in input ( ) ] + [ 1 ] <NEWLINE> <NL> r = - 1 <NEWLINE> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> used = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for l in range ( N ) : <NEWLINE> <INDENT> if S [ l ] + S [ l - 1 ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> while r < N and used [ r ] - used [ l - 1 ] <= K : <NEWLINE> <INDENT> r += 1 <NEWLINE> if S [ r - 1 ] == 1 and S [ r ] == 0 : <NEWLINE> <INDENT> used [ r ] = used [ r - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> used [ r ] = used [ r - 1 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , r - l ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N , u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N - 1 ) ] <NEWLINE> E = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for a , b in edges : <NEWLINE> <INDENT> E [ a ] . append ( b ) <NEWLINE> E [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> depth = [ [ - 1 , - 1 ] for _ in range ( N + 1 ) ] <NEWLINE> depth [ v ] [ 0 ] = 0 <NEWLINE> depth [ u ] [ 1 ] = 0 <NEWLINE> <NL> def dfs1 ( E , v ) : <NEWLINE> <INDENT> vv = E [ v ] <NEWLINE> for vvv in vv : <NEWLINE> <INDENT> if depth [ vvv ] [ 0 ] == - 1 : <NEWLINE> <INDENT> depth [ vvv ] [ 0 ] = depth [ v ] [ 0 ] + 1 <NEWLINE> dfs1 ( E , vvv ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def dfs2 ( E , v ) : <NEWLINE> <INDENT> vv = E [ v ] <NEWLINE> for vvv in vv : <NEWLINE> <INDENT> if depth [ vvv ] [ 1 ] == - 1 : <NEWLINE> <INDENT> depth [ vvv ] [ 1 ] = depth [ v ] [ 1 ] + 1 <NEWLINE> dfs2 ( E , vvv ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs1 ( E , v ) <NEWLINE> dfs2 ( E , u ) <NEWLINE> depth = sorted ( depth , reverse = True ) <NEWLINE> idx = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if depth [ idx ] [ 0 ] - depth [ idx ] [ 1 ] >= 1 : <NEWLINE> <INDENT> print ( depth [ idx ] [ 0 ] - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx += 1 <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> index = s . find ( s [ 0 ] , 1 ) <NEWLINE> if index >= 1 : <NEWLINE> <INDENT> s = s . replace ( s [ 0 ] , <STRING> ) <NEWLINE> if ( len ( s ) == 2 ) : <NEWLINE> <INDENT> if ( s [ 0 ] == s [ 1 ] ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> col = [ 0 ] * 9 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> j = min ( 8 , a [ i ] // 400 ) <NEWLINE> col [ j ] += 1 <NEWLINE> <DEDENT> zero = 0 <NEWLINE> cnt = 0 <NEWLINE> for c in range ( len ( col ) - 1 ) : <NEWLINE> <INDENT> if col [ c ] == 0 : <NEWLINE> <INDENT> zero += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> m = max ( cnt , 1 ) <NEWLINE> M = cnt + col [ - 1 ] <NEWLINE> print ( m , M ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = ( ( n + 1 ) * n ) // 2 - n <NEWLINE> <NL> print ( int ( ans ) ) <NEWLINE>
import queue <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> v = [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> s = [ input ( ) for i in range ( h ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> que = queue . Queue ( ) <NEWLINE> for i in range ( h * w ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> d = [ [ h * w ] * w for i in range ( h ) ] <NEWLINE> p = ( i // w , i % w ) <NEWLINE> if s [ p [ 0 ] ] [ p [ 1 ] ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> d [ p [ 0 ] ] [ p [ 1 ] ] = 0 <NEWLINE> que . put ( p ) <NEWLINE> while not que . empty ( ) : <NEWLINE> <INDENT> y , x = que . get ( ) <NEWLINE> c = d [ y ] [ x ] <NEWLINE> for dy , dx in v : <NEWLINE> <INDENT> yy = y + dy <NEWLINE> xx = x + dx <NEWLINE> if yy < 0 or xx < 0 or h <= yy or w <= xx : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ yy ] [ xx ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if d [ yy ] [ xx ] < h * w : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> que . put ( ( yy , xx ) ) <NEWLINE> d [ yy ] [ xx ] = c + 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , c ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from itertools import product <NEWLINE> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xyz = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> <NL> dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> for a , b , c in product ( [ 1 , - 1 ] , repeat = 3 ) : <NEWLINE> <INDENT> total = [ ] <NEWLINE> for x , y , z in xyz : <NEWLINE> <INDENT> s = x * a + y * b + z * c <NEWLINE> total . append ( s ) <NEWLINE> <DEDENT> total . sort ( reverse = True ) <NEWLINE> ans = max ( ans , sum ( total [ : m ] ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import resource <NEWLINE> <NL> sys . setrecursionlimit ( 20000 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> edges = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n - 1 ) ] <NEWLINE> e = [ [ ] for i in range ( n ) ] <NEWLINE> for a , b in edges : <NEWLINE> <INDENT> a -= 1 ; b -= 1 <NEWLINE> e [ a ] . append ( b ) ; e [ b ] . append ( a ) <NEWLINE> <DEDENT> c = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( sum ( c [ : - 1 ] ) ) <NEWLINE> visited = [ False for i in range ( n ) ] <NEWLINE> node = [ 0 ] * n <NEWLINE> cnt = 0 <NEWLINE> def dfs ( pos ) : <NEWLINE> <INDENT> global cnt , node , c <NEWLINE> if visited [ pos ] : return <NEWLINE> visited [ pos ] = True <NEWLINE> for p in e [ pos ] : <NEWLINE> <INDENT> dfs ( p ) <NEWLINE> <DEDENT> node [ pos ] = c [ cnt ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> dfs ( 0 ) <NEWLINE> print ( <STRING> . join ( map ( str , node ) ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> res = 0 <NEWLINE> flag = True <NEWLINE> <COMMENT> <NL> INF = 100000000000 <NEWLINE> stepList = [ INF ] * ( N + 1 ) <NEWLINE> stepList [ 0 ] = 1 <NEWLINE> stepList [ 1 ] = 1 <NEWLINE> def stepF ( K ) : <NEWLINE> <INDENT> if K == 0 : <NEWLINE> <INDENT> return stepList [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if stepList [ i ] == INF : <NEWLINE> <INDENT> stepList [ i ] = stepList [ i - 2 ] + stepList [ i - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return stepList [ K ] <NEWLINE> <NL> <DEDENT> <DEDENT> if M == 0 : <NEWLINE> <INDENT> res = stepF ( N ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> List = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> List . append ( int ( input ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> res = stepF ( List [ i ] - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if List [ i ] - List [ i - 1 ] == 1 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> res = res * stepF ( List [ i ] - List [ i - 1 ] - 2 ) <NEWLINE> <DEDENT> <DEDENT> res = res * stepF ( N - List [ M - 1 ] - 1 ) <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> print ( res % 1000000007 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> con = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if s [ s [ i ] - 1 ] == i + 1 : <NEWLINE> <INDENT> con += 1 <NEWLINE> <DEDENT> <DEDENT> print ( con // 2 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> pot_starts = [ ] <NEWLINE> pot_ends = [ ] <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i [ 0 ] == 1 : <NEWLINE> <INDENT> pot_starts . append ( i [ 1 ] ) <NEWLINE> <DEDENT> elif i [ 1 ] == n : <NEWLINE> <INDENT> pot_ends . append ( i [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if set ( pot_starts ) . intersection ( pot_ends ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dpt = [ 0 ] * ( W + 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( W , w - 1 , - 1 ) : <NEWLINE> <INDENT> a = dpt [ j ] <NEWLINE> b = dpt [ j - w ] + v <NEWLINE> if a > b : <NEWLINE> <INDENT> dpt [ j ] = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dpt [ j ] = b <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dpt [ W ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> <NL> <NL> stdin = sys . stdin <NEWLINE> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def nm ( ) : return map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> def nl ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , q = nm ( ) <NEWLINE> S = input ( ) <NEWLINE> ans = [ ] <NEWLINE> A_pos = [ ] <NEWLINE> C_pos = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> A_pos += [ i + 1 ] <NEWLINE> C_pos += [ i + 2 ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = nm ( ) <NEWLINE> ans += [ bisect_right ( C_pos , r ) - bisect_left ( A_pos , l ) ] <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> i = 0 <NEWLINE> per = True <NEWLINE> while per == True : <NEWLINE> <INDENT> for index in range ( n ) : <NEWLINE> <INDENT> num = a [ index ] <NEWLINE> ans = divmod ( num , 2 ) <NEWLINE> if num == 0 or ans [ 1 ] != 0 : <NEWLINE> <INDENT> per = False <NEWLINE> break <NEWLINE> <DEDENT> a [ index ] = ans [ 0 ] <NEWLINE> <DEDENT> if per == True : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> c = math . ceil ( ( B - A ) / ( A - 1 ) ) <NEWLINE> print ( c + 1 ) <NEWLINE>
from functools import reduce <NEWLINE> <NL> x , y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> if ( 2 * y - x ) % 3 != 0 or ( 2 * x - y ) % 3 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> a , b = ( 2 * y - x ) // 3 , ( 2 * x - y ) // 3 <NEWLINE> <NL> r = min ( a , b ) <NEWLINE> <NL> if r == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif r < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> numerator = reduce ( lambda x , y : x * y % mod , range ( a + b - r + 1 , a + b + 1 ) ) <NEWLINE> denominator = reduce ( lambda x , y : x * y % mod , range ( 1 , r + 1 ) ) <NEWLINE> print ( numerator * pow ( denominator , mod - 2 , mod ) % mod ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) - 1 ) <NEWLINE> <NL> <DEDENT> visited = set ( ) <NEWLINE> <NL> cur = 0 <NEWLINE> visited . add ( 0 ) <NEWLINE> ans = 0 <NEWLINE> while cur != 1 : <NEWLINE> <INDENT> if a [ cur ] not in visited : <NEWLINE> <INDENT> visited . add ( a [ cur ] ) <NEWLINE> cur = a [ cur ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> min_num = p [ 0 ] <NEWLINE> for i in p : <NEWLINE> <INDENT> if i <= min_num : <NEWLINE> <INDENT> min_num = i <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> mod = 10 ** 9 + 7 ; inf = float ( <STRING> ) <NEWLINE> from math import sqrt , ceil <NEWLINE> from collections import deque , Counter , defaultdict <COMMENT> <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> sys . setrecursionlimit ( 11451419 ) <NEWLINE> from decimal import ROUND_HALF_UP , Decimal <COMMENT> <NEWLINE> <COMMENT> <NL> from functools import lru_cache <NEWLINE> from bisect import bisect_left as bileft , bisect_right as biright <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( m ) ] <NEWLINE> NG = [ 0 ] * ( 10 ** 5 + 10 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> NG [ i ] = 1 <NEWLINE> <NL> <NL> <DEDENT> @ lru_cache ( maxsize = 10 ** 10 ) <NEWLINE> def qwe ( x ) : <NEWLINE> <INDENT> if x == n : return 1 <NEWLINE> if x > n : return 0 <NEWLINE> if NG [ x + 1 ] and NG [ x + 2 ] : print ( 0 ) ; exit ( ) <NEWLINE> if NG [ x + 1 ] : return qwe ( x + 2 ) % mod <NEWLINE> if NG [ x + 2 ] : return qwe ( x + 1 ) % mod <NEWLINE> return ( qwe ( x + 2 ) + qwe ( x + 1 ) ) % mod <NEWLINE> <DEDENT> print ( qwe ( 0 ) ) <NEWLINE> <NL>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> S = list ( S ) <NEWLINE> <NL> for j in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ j ] == <STRING> : <NEWLINE> <INDENT> if j == K - 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> x = [ i for i in S if i != <STRING> ] <NEWLINE> ans = x [ 0 ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> data = [ ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> data . append ( list ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> next_data = [ ] <NEWLINE> <COMMENT> <NL> for d in data : <NEWLINE> <INDENT> if <STRING> in d : <NEWLINE> <INDENT> next_data . append ( d ) <NEWLINE> <NL> <DEDENT> <DEDENT> next_next_data = [ ] <NEWLINE> origin_v_data = [ ] <NEWLINE> <COMMENT> <NL> for i in range ( len ( next_data [ 0 ] ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> v_data = [ ] <NEWLINE> for j in range ( len ( next_data ) ) : <NEWLINE> <INDENT> v_data . append ( next_data [ j ] [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if <STRING> in v_data : <NEWLINE> <INDENT> origin_v_data . append ( v_data ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans_data = [ ] <NEWLINE> for i in range ( len ( origin_v_data [ 0 ] ) ) : <NEWLINE> <INDENT> join_data = [ ] <NEWLINE> for j in range ( len ( origin_v_data ) ) : <NEWLINE> <INDENT> join_data . append ( origin_v_data [ j ] [ i ] ) <NEWLINE> <DEDENT> ans_data . append ( join_data ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for a in ans_data : <NEWLINE> <INDENT> print ( <STRING> . join ( a ) ) <NEWLINE> <DEDENT>
def tenka17_c ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> ans = None <NEWLINE> for x in range ( 1 , 3501 ) : <NEWLINE> <INDENT> for y in range ( 1 , 3501 ) : <NEWLINE> <INDENT> a = N * x * y <NEWLINE> b = 4 * x * y - N * y - N * x <NEWLINE> if b < 1 : continue <NEWLINE> if a % b == 0 : <NEWLINE> <INDENT> ans = ( x , y , a // b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans : break <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> tenka17_c ( ) <NEWLINE>
import heapq <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> jobs = [ [ ] for _ in range ( M ) ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A > M : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> jobs [ A - 1 ] . append ( - B ) <NEWLINE> <NL> <DEDENT> total = 0 <NEWLINE> heap = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> for job in jobs [ i ] : <NEWLINE> <INDENT> heapq . heappush ( heap , job ) <NEWLINE> <NL> <DEDENT> if len ( heap ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total += - heapq . heappop ( heap ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> input = sys . stdin . readline <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> dp = np . zeros ( n , dtype = int ) <NEWLINE> <COMMENT> <NL> h = np . array ( h ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> start = max ( 0 , i - k ) <NEWLINE> <COMMENT> <NL> dp [ i ] = min ( dp [ start : i ] + np . abs ( h [ i ] - h [ start : i ] ) ) <NEWLINE> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if m == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> MOD = pow ( 10 , 9 ) + 7 <NEWLINE> <NL> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def make_fact_list ( n , MOD ) : <NEWLINE> <COMMENT> <NL> <INDENT> fact = [ 0 ] * ( n + 1 ) <NEWLINE> inv = [ 0 ] * ( n + 1 ) <NEWLINE> factinv = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> fact [ 0 ] = fact [ 1 ] = 1 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> factinv [ 0 ] = factinv [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> fact [ i ] = fact [ i - 1 ] * i % MOD <NEWLINE> inv [ i ] = MOD - ( ( inv [ MOD % i ] * ( MOD // i ) ) % MOD ) <NEWLINE> factinv [ i ] = factinv [ i - 1 ] * inv [ i ] % MOD <NEWLINE> <NL> <DEDENT> return fact , factinv <NEWLINE> <NL> <DEDENT> def cbn ( n , k , MOD , fact = [ ] , factinv = [ ] ) : <NEWLINE> <INDENT> if len ( fact ) == 0 and len ( factinv ) == 0 : <NEWLINE> <INDENT> fact , factinv = make_fact_list ( n , MOD ) <NEWLINE> <DEDENT> return fact [ n ] * factinv [ n - k ] * factinv [ k ] % MOD <NEWLINE> <NL> <NL> <DEDENT> d = Counter ( prime_factorize ( m ) ) . most_common ( ) <NEWLINE> <NL> l = d [ 0 ] [ 1 ] + n <NEWLINE> <NL> fact , factinv = make_fact_list ( l , MOD ) <NEWLINE> <NL> a = 1 <NEWLINE> <NL> for k , v in d : <NEWLINE> <INDENT> a *= cbn ( v + n - 1 , v , MOD , fact = fact , factinv = factinv ) % MOD <NEWLINE> <NL> <DEDENT> print ( a % MOD ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> dp1 = [ 0 ] * ( K + 1 ) <NEWLINE> dp2 = [ 0 ] * ( K + 1 ) <NEWLINE> dp1 [ 0 ] = 1 <NEWLINE> <NL> for x in map ( int , str ( N ) ) : <NEWLINE> <INDENT> for j in range ( K , - 1 , - 1 ) : <NEWLINE> <INDENT> if j > 0 : <NEWLINE> <INDENT> dp2 [ j ] += dp2 [ j - 1 ] * 9 <NEWLINE> if x != 0 : <NEWLINE> <INDENT> dp2 [ j ] += dp1 [ j - 1 ] * ( x - 1 ) + dp1 [ j ] <NEWLINE> dp1 [ j ] = dp1 [ j - 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp1 [ j ] = 0 <NEWLINE> dp2 [ j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp1 [ K ] + dp2 [ K ] ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
O , E = input ( ) , input ( ) <NEWLINE> ans = <STRING> <NEWLINE> <NL> if ( len ( O ) + len ( E ) ) % 2 == 0 : <NEWLINE> <INDENT> for i in range ( len ( E ) ) : <NEWLINE> <INDENT> ans += O [ i ] + E [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( E ) ) : <NEWLINE> <INDENT> ans += O [ i ] + E [ i ] <NEWLINE> <DEDENT> ans += O [ - 1 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
alphabet = list ( <STRING> ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> for i in S : <NEWLINE> <INDENT> print ( alphabet [ ( alphabet . index ( i ) + N ) % 26 ] , end = <STRING> ) <NEWLINE> <DEDENT>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if R - L >= 2019 : <NEWLINE> <INDENT> res = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = float ( <STRING> ) <NEWLINE> L = L % 2019 <NEWLINE> R = R % 2019 <NEWLINE> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> res = min ( res , ( i * j ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> b = collections . Counter ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in b . keys ( ) : <NEWLINE> <INDENT> if b [ i ] % 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> inint = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> inintm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> inintl = lambda : list ( inintm ( ) ) <NEWLINE> instrm = lambda : map ( str , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> instrl = lambda : list ( instrm ( ) ) <NEWLINE> <NL> h , w = inintm ( ) <NEWLINE> grid = [ ] <NEWLINE> now = [ 0 , 0 ] <NEWLINE> fw = 0 <NEWLINE> fh = 0 <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> grid . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> while now != [ h - 1 , w - 1 ] : <NEWLINE> <INDENT> if now [ 0 ] == h - 1 : <NEWLINE> <INDENT> if fh == 0 and now [ 1 ] != 0 : <NEWLINE> <INDENT> if grid [ h - 1 ] [ now [ 1 ] + 1 ] == <STRING> and grid [ h - 1 ] [ now [ 1 ] - 1 ] == <STRING> : <NEWLINE> <INDENT> now = [ h - 1 , now [ 1 ] + 1 ] <NEWLINE> fh = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if grid [ h - 1 ] [ now [ 1 ] + 1 ] == <STRING> : <NEWLINE> <INDENT> now = [ h - 1 , now [ 1 ] + 1 ] <NEWLINE> fh = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif now [ 1 ] == w - 1 : <NEWLINE> <INDENT> if fw == 0 and now [ 0 ] != 0 : <NEWLINE> <INDENT> if grid [ now [ 0 ] + 1 ] [ w - 1 ] == <STRING> and grid [ now [ 0 ] - 1 ] [ w - 1 ] == <STRING> : <NEWLINE> <INDENT> now = [ now [ 0 ] + 1 , w - 1 ] <NEWLINE> fw = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if grid [ now [ 0 ] + 1 ] [ w - 1 ] == <STRING> : <NEWLINE> <INDENT> now = [ now [ 0 ] + 1 , w - 1 ] <NEWLINE> fw = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if grid [ now [ 0 ] + 1 ] [ now [ 1 ] ] == <STRING> and grid [ now [ 0 ] ] [ now [ 1 ] + 1 ] == <STRING> : <NEWLINE> <INDENT> now = [ now [ 0 ] + 1 , now [ 1 ] ] <NEWLINE> <DEDENT> elif grid [ now [ 0 ] + 1 ] [ now [ 1 ] ] == <STRING> and grid [ now [ 0 ] ] [ now [ 1 ] + 1 ] == <STRING> : <NEWLINE> <INDENT> now = [ now [ 0 ] , now [ 1 ] + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if fh == 0 and grid [ h - 1 ] [ w - 2 ] == <STRING> and ( h >= 2 and w >= 2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
from collections import Counter <NEWLINE> A = input ( ) <NEWLINE> n = len ( A ) <NEWLINE> c = Counter ( A ) <NEWLINE> <NL> ans = 1 <NEWLINE> ans += n * ( n - 1 ) // 2 <NEWLINE> for v in c . values ( ) : <NEWLINE> <INDENT> ans -= v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> lww = 0 <NEWLINE> lee = s [ 1 : ] . count ( <STRING> ) <NEWLINE> ans = lww + lee <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> lee -= 1 <NEWLINE> <DEDENT> if s [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> lww += 1 <NEWLINE> <NL> <DEDENT> ans = min ( ans , lee + lww ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> p = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = np . zeros ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> dp [ 1 : ] = dp [ : - 1 ] * p [ i - 1 ] + dp [ 1 : ] * ( 1 - p [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( dp [ ( n + 1 ) // 2 ] ) <NEWLINE>
import itertools <NEWLINE> <NL> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> e = int ( input ( ) ) <NEWLINE> <NL> num_list = [ a , b , c , d , e ] <NEWLINE> factorial = list ( itertools . permutations ( num_list , 5 ) ) <NEWLINE> ans_list = [ ] <NEWLINE> for list in factorial : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for i in list : <NEWLINE> <INDENT> if tmp % 10 == 0 : <NEWLINE> <INDENT> tmp += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp += 10 - tmp % 10 <NEWLINE> tmp += i <NEWLINE> <DEDENT> <DEDENT> ans_list . append ( tmp ) <NEWLINE> <NL> <DEDENT> ans_list . sort ( ) <NEWLINE> ans = ans_list [ 0 ] <NEWLINE> <NL> print ( ans ) <NEWLINE>
import sys <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> route = [ [ ] for i in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> route [ a - 1 ] . append ( b ) <NEWLINE> <NL> <DEDENT> for i in route [ 0 ] : <NEWLINE> <INDENT> if len ( route ) != 1 : <NEWLINE> <INDENT> for j in route [ i - 1 ] : <NEWLINE> <INDENT> if j == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> V = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if V [ i ] > C [ i ] : <NEWLINE> <INDENT> ans += V [ i ] - C [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n % 2 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> m = 10 <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> while m <= n : <NEWLINE> <INDENT> a . append ( n // m ) <NEWLINE> m *= 5 <NEWLINE> if len ( a ) > 1 : <NEWLINE> <INDENT> b . append ( a [ - 2 ] - a [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if a : <NEWLINE> <INDENT> b . append ( a [ - 1 ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> ans += ( i + 1 ) * b [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 200002 ) <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> graph = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> graph [ l - 1 ] . append ( [ r - 1 , d ] ) <NEWLINE> graph [ r - 1 ] . append ( [ l - 1 , - d ] ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> def dfs ( s ) : <NEWLINE> <INDENT> for t , d in graph [ s ] : <NEWLINE> <INDENT> if x [ t ] is None : <NEWLINE> <INDENT> x [ t ] = x [ s ] + d <NEWLINE> if not dfs ( t ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if x [ t ] - x [ s ] != d : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> x = [ None ] * n <NEWLINE> ans = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] is None : <NEWLINE> <INDENT> x [ i ] = 0 <NEWLINE> if not dfs ( i ) : <NEWLINE> <INDENT> ans = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ( <STRING> , <STRING> ) [ ans ] ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i + 1 == a [ a [ i ] - 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> res = 0 <NEWLINE> <NL> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - ( x + y ) <NEWLINE> if z <= k and z >= 0 : <NEWLINE> <INDENT> res += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> printn = lambda x : print ( x , end = <STRING> ) <NEWLINE> inn = lambda : int ( input ( ) ) <NEWLINE> inl = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> inm = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> ins = lambda : input ( ) . strip ( ) <NEWLINE> DBG = True <COMMENT> <NEWLINE> BIG = 10 ** 18 <NEWLINE> R = 10 ** 9 + 7 <NEWLINE> <NL> def ddprint ( x ) : <NEWLINE> <INDENT> if DBG : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = inn ( ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> dst = [ { } for i in range ( n + 1 ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> u , v = inm ( ) <NEWLINE> dst [ u ] [ v ] = dst [ v ] [ u ] = 1 <NEWLINE> <DEDENT> s = 1 <NEWLINE> d1 = [ - 1 ] * ( n + 1 ) <NEWLINE> d1 [ s ] = 0 <NEWLINE> q = deque ( [ s ] ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> x = q . popleft ( ) <NEWLINE> d = d1 [ x ] <NEWLINE> for u in dst [ x ] : <NEWLINE> <INDENT> if d1 [ u ] < 0 : <NEWLINE> <INDENT> d1 [ u ] = d + 1 <NEWLINE> q . append ( u ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> mx = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if d1 [ i ] > mx : <NEWLINE> <INDENT> mx = d1 [ i ] <NEWLINE> mxi = i <NEWLINE> <NL> <DEDENT> <DEDENT> s = mxi <NEWLINE> d1 = [ - 1 ] * ( n + 1 ) <NEWLINE> d1 [ s ] = 0 <NEWLINE> q = deque ( [ s ] ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> x = q . popleft ( ) <NEWLINE> d = d1 [ x ] <NEWLINE> for u in dst [ x ] : <NEWLINE> <INDENT> if d1 [ u ] < 0 : <NEWLINE> <INDENT> d1 [ u ] = d + 1 <NEWLINE> q . append ( u ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if max ( d1 ) % 3 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from scipy . special import comb <NEWLINE> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> red = N - K <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = comb ( N - K + 1 , i , exact = True ) * comb ( K - 1 , i - 1 , exact = True ) % mod <NEWLINE> print ( tmp ) <NEWLINE> <DEDENT>
import heapq as hq <NEWLINE> from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> edges [ a ] . append ( ( b , 1 ) ) <NEWLINE> edges [ b ] . append ( ( a , 1 ) ) <NEWLINE> <DEDENT> INF = float ( <STRING> ) <NEWLINE> d = [ INF ] * N <NEWLINE> d [ 0 ] = 0 <NEWLINE> prev = [ None ] * N <NEWLINE> q = [ ( 0 , 0 ) ] <NEWLINE> while q : <NEWLINE> <INDENT> dist , i = hq . heappop ( q ) <NEWLINE> if d [ i ] < dist : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j , w in edges [ i ] : <NEWLINE> <INDENT> if d [ j ] > d [ i ] + w : <NEWLINE> <INDENT> d [ j ] = d [ i ] + w <NEWLINE> prev [ j ] = i <NEWLINE> hq . heappush ( q , ( d [ j ] , j ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> path = deque ( ) <NEWLINE> i = N - 1 <NEWLINE> while prev [ i ] != 0 : <NEWLINE> <INDENT> path . append ( prev [ i ] ) <NEWLINE> i = prev [ i ] <NEWLINE> <DEDENT> fncq = deque ( [ 0 ] ) <NEWLINE> snkq = deque ( [ N - 1 ] ) <NEWLINE> fnc = 1 <NEWLINE> snk = 1 <NEWLINE> visited = [ False ] * N <NEWLINE> visited [ 0 ] = True <NEWLINE> visited [ N - 1 ] = True <NEWLINE> while path : <NEWLINE> <INDENT> v = path . pop ( ) <NEWLINE> fncq . append ( v ) <NEWLINE> visited [ v ] = True <NEWLINE> fnc += 1 <NEWLINE> if path : <NEWLINE> <INDENT> v = path . popleft ( ) <NEWLINE> snkq . append ( v ) <NEWLINE> visited [ v ] = True <NEWLINE> snk += 1 <NEWLINE> <DEDENT> <DEDENT> po = [ fncq , snkq ] <NEWLINE> while fncq or snkq : <NEWLINE> <INDENT> for i in range ( 2 ) : <NEWLINE> <INDENT> q = po [ i ] <NEWLINE> if q : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for w , _ in edges [ v ] : <NEWLINE> <INDENT> if not visited [ w ] : <NEWLINE> <INDENT> visited [ w ] = True <NEWLINE> q . append ( w ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> fnc += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> snk += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> if fnc > snk else <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ input ( ) for _ in range ( h ) ] <NEWLINE> <NL> y = [ False ] * h <NEWLINE> x = [ False ] * w <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if a [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> y [ i ] = True <NEWLINE> x [ j ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if y [ i ] : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if x [ j ] : <NEWLINE> <INDENT> print ( a [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( set ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> a . sort ( ) <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> ans += a [ i ] - a [ i - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> a = np . array ( a ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 61 ) : <NEWLINE> <INDENT> b = np . count_nonzero ( a >> i & 1 ) <NEWLINE> ans += b * ( n - b ) * 1 << i <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans_list = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans_list [ a_list [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * ans_list ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> alice = 0 <NEWLINE> bob = 0 <NEWLINE> <NL> A_rev = sorted ( A , reverse = True ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if len ( A_rev ) != 0 : <NEWLINE> <INDENT> alice += A_rev . pop ( 0 ) <NEWLINE> <NL> <DEDENT> if len ( A_rev ) != 0 : <NEWLINE> <INDENT> bob += A_rev . pop ( 0 ) <NEWLINE> <NL> <DEDENT> if len ( A_rev ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( alice - bob ) <NEWLINE>
<COMMENT> <NL> import copy <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> am = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> pcnt = 0 <NEWLINE> mcnt = 0 <NEWLINE> <NL> f = 0 <COMMENT> <NEWLINE> wa = 0 <NEWLINE> <NL> <COMMENT> <NL> a = copy . copy ( am ) <NEWLINE> f = 2 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> wa += a [ i ] <NEWLINE> <NL> if f == 1 : <COMMENT> <NEWLINE> <INDENT> if wa > - 1 : <NEWLINE> <INDENT> pcnt += wa + 1 <NEWLINE> wa = - 1 <NEWLINE> <NL> <DEDENT> f = 2 <NEWLINE> <NL> <DEDENT> elif f == 2 : <COMMENT> <NEWLINE> <NL> <INDENT> if wa < 1 : <NEWLINE> <INDENT> pcnt += - wa + 1 <NEWLINE> wa = 1 <NEWLINE> <NL> <DEDENT> f = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> a = copy . copy ( am ) <NEWLINE> wa = 0 <NEWLINE> f = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> wa += a [ i ] <NEWLINE> <NL> if f == 1 : <COMMENT> <NEWLINE> <INDENT> if wa > - 1 : <NEWLINE> <INDENT> mcnt += wa + 1 <NEWLINE> wa = - 1 <NEWLINE> <NL> <DEDENT> f = 2 <NEWLINE> <NL> <DEDENT> elif f == 2 : <COMMENT> <NEWLINE> <NL> <INDENT> if wa < 1 : <NEWLINE> <INDENT> mcnt += - wa + 1 <NEWLINE> wa = 1 <NEWLINE> <NL> <DEDENT> f = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( pcnt , mcnt ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> EP = [ 0 ] * ( N + 1 ) <NEWLINE> WP = [ 0 ] * ( N + 1 ) <NEWLINE> CP = [ 0 ] * N <NEWLINE> for T in range ( 0 , N ) : <NEWLINE> <INDENT> EP [ N - T - 1 ] = EP [ N - T ] + ( S [ N - 1 - T ] == <STRING> ) <NEWLINE> WP [ T + 1 ] = WP [ T ] + ( S [ T ] == <STRING> ) <NEWLINE> <DEDENT> for T in range ( 0 , N ) : <NEWLINE> <INDENT> CP [ T ] = EP [ T + 1 ] + WP [ T ] <NEWLINE> <DEDENT> print ( min ( CP ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> h , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ ] <NEWLINE> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> l = map ( int , input ( ) . split ( ) ) <NEWLINE> for j , k in enumerate ( l , 1 ) : <NEWLINE> <INDENT> p . append ( ( k , ( i , j ) ) ) <NEWLINE> <DEDENT> <DEDENT> p . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> <NL> dist = [ 0 ] * ( w * h + 1 ) <NEWLINE> <NL> def Q ( i , c , x , y ) : <NEWLINE> <INDENT> if i + d > w * h : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> _ , ( nx , ny ) = p [ i + d - 1 ] <NEWLINE> nc = c + abs ( nx - x ) + abs ( ny - y ) <NEWLINE> dist [ i + d ] = nc <NEWLINE> Q ( i + d , nc , nx , ny ) <NEWLINE> <NL> <DEDENT> for i in range ( d ) : <NEWLINE> <INDENT> n , ( x , y ) = p [ i ] <NEWLINE> Q ( n , 0 , x , y ) <NEWLINE> <NL> <DEDENT> res = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> res . append ( dist [ r ] - dist [ l ] ) <NEWLINE> <NL> <DEDENT> ans = <STRING> . join ( map ( str , res ) ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from itertools import combinations <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> name_count = { <STRING> : 0 , <NEWLINE> <INDENT> <STRING> : 0 , <NEWLINE> <STRING> : 0 , <NEWLINE> <STRING> : 0 , <NEWLINE> <STRING> : 0 , } <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> name = input ( ) <NEWLINE> <NL> if name [ 0 ] in name_count : <NEWLINE> <INDENT> name_count [ name [ 0 ] ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def comb ( n , r ) : <NEWLINE> <INDENT> up = 1 <NEWLINE> down = 1 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> up *= n - i <NEWLINE> down *= i + 1 <NEWLINE> <DEDENT> return up // down <NEWLINE> <NL> <NL> <DEDENT> all_sum = sum ( name_count . values ( ) ) <NEWLINE> total = comb ( all_sum , 3 ) <NEWLINE> <NL> for i in name_count . values ( ) : <NEWLINE> <INDENT> if i >= 2 : <NEWLINE> <INDENT> total -= comb ( i , 2 ) * ( all_sum - i ) <NEWLINE> <NL> <DEDENT> if i >= 3 : <NEWLINE> <INDENT> total -= comb ( i , 3 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
s = input ( ) + chr ( ord ( <STRING> ) - 1 ) <NEWLINE> ans = - 1 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> t = s [ : ~ i ] <NEWLINE> dif = set ( map ( chr , range ( ord ( s [ ~ i ] ) + 1 , 123 ) ) ) - set ( t ) <NEWLINE> if dif : <NEWLINE> <INDENT> ans = t + min ( dif ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> * x , = map ( int , input ( ) . split ( ) ) <NEWLINE> y = sorted ( x ) <NEWLINE> for i in x : <NEWLINE> <INDENT> if i < y [ n // 2 ] : <NEWLINE> <INDENT> print ( y [ n // 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y [ n // 2 - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> b = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 != n % 2 : <NEWLINE> <INDENT> b . appendleft ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( * b ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = [ 2 , 1 ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( l [ 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> l . append ( l [ i - 2 ] + l [ i - 1 ] ) <NEWLINE> <DEDENT> print ( l [ - 1 ] ) <NEWLINE>
def dfs ( h ) : <NEWLINE> <INDENT> if h == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return dfs ( h // 2 ) * 2 + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> H = int ( input ( ) ) <NEWLINE> <NL> print ( dfs ( H ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> p = s . count ( <STRING> ) <NEWLINE> q = s . count ( <STRING> ) <NEWLINE> print ( 2 * min ( p , q ) ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> K , S = LI ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x , y in itertools . product ( range ( K + 1 ) , repeat = 2 ) : <NEWLINE> <INDENT> if 0 <= S - ( x + y ) <= K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> def div ( n ) : <NEWLINE> <INDENT> low , high = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> low . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> high . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return low + high [ : : - 1 ] <NEWLINE> <DEDENT> S = div ( N ) <NEWLINE> ans = 0 <NEWLINE> S = S [ 1 : ] <NEWLINE> for i in S : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if N % ( i - 1 ) == N // ( i - 1 ) : <NEWLINE> <INDENT> ans += i - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , Ma , Mb = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> <DEDENT> sa = sum ( A ) <NEWLINE> sb = sum ( B ) <NEWLINE> <NL> dp = [ [ [ 10000 ] * ( sb + 1 ) for _ in range ( sa + 1 ) ] for _ in range ( N + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] [ 0 ] = 0 <NEWLINE> <NL> ta = 0 <NEWLINE> tb = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> b = B [ i ] <NEWLINE> for j in range ( sa ) : <NEWLINE> <INDENT> for k in range ( sb ) : <NEWLINE> <INDENT> if j - a >= 0 and k - b >= 0 : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] [ k ] = min ( dp [ i ] [ j - a ] [ k - b ] + C [ i ] , dp [ i ] [ j ] [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] [ k ] = min ( dp [ i + 1 ] [ j ] [ k ] , dp [ i ] [ j ] [ k ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = 10000 <NEWLINE> for i in range ( 1 , sa + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , sb + 1 ) : <NEWLINE> <INDENT> if Ma * j == Mb * i : <NEWLINE> <INDENT> ans = min ( ans , dp [ N ] [ i ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans == 10000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> lst = [ 0 ] * N <NEWLINE> ans = N <NEWLINE> <NL> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> lst [ 0 ] = 1 <NEWLINE> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> lst [ i ] = lst [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst [ i ] = lst [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> left = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = i - lst [ i - 1 ] <NEWLINE> <DEDENT> right = lst [ N - 1 ] - lst [ i ] <NEWLINE> <NL> if left + right < ans : <NEWLINE> <INDENT> ans = left + right <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> memo = [ - 1 ] * ( n + 1 ) <NEWLINE> memo [ 0 ] = 1 <NEWLINE> memo [ 1 ] = 1 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> memo [ int ( input ( ) ) ] = 0 <NEWLINE> <NL> <DEDENT> def fib ( x ) : <NEWLINE> <INDENT> if memo [ x ] == - 1 : <NEWLINE> <INDENT> memo [ x ] = fib ( x - 1 ) + fib ( x - 2 ) <NEWLINE> <DEDENT> return memo [ x ] <NEWLINE> <NL> <DEDENT> def fib2 ( x ) : <NEWLINE> <INDENT> if x <= 1 : <NEWLINE> <INDENT> return memo [ x ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( x - 1 ) : <NEWLINE> <INDENT> if memo [ i + 2 ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> memo [ i + 2 ] = memo [ i ] + memo [ i + 1 ] <NEWLINE> <DEDENT> return memo [ x ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( fib2 ( n ) % 1000000007 ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> <NL> a = list ( <STRING> ) <NEWLINE> b = list ( <STRING> ) <NEWLINE> c = list ( <STRING> ) <NEWLINE> d = list ( <STRING> ) <NEWLINE> flag = 0 <NEWLINE> <NL> while ( flag == 0 ) : <NEWLINE> <INDENT> if s [ - 7 : ] == b : <NEWLINE> <INDENT> del s [ - 7 : ] <NEWLINE> <DEDENT> elif s [ - 6 : ] == d : <NEWLINE> <INDENT> del s [ - 6 : ] <NEWLINE> <DEDENT> elif s [ - 5 : ] == a or s [ - 5 : ] == c : <NEWLINE> <INDENT> del s [ - 5 : ] <NEWLINE> <DEDENT> elif s == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = 1 <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = [ 0 ] <NEWLINE> arr += list ( itertools . accumulate ( a ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> c = Counter ( arr ) <NEWLINE> for v in c . values ( ) : <NEWLINE> <INDENT> if v > 1 : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> def dfs ( now_p , visited , comb_p , p_num ) : <NEWLINE> <COMMENT> <NL> <INDENT> if len ( visited ) == p_num : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> for tmp_p in comb_p : <NEWLINE> <INDENT> if tmp_p [ 0 ] == now_p and tmp_p [ 1 ] not in visited : <NEWLINE> <COMMENT> <NL> <INDENT> tmp_visited = visited [ : ] <NEWLINE> tmp_visited . append ( tmp_p [ 1 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> next_p = tmp_p [ 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> tmp_comb = comb_p [ : ] <NEWLINE> tmp_comb . remove ( tmp_p ) <NEWLINE> <COMMENT> <NL> tmp_p_r = [ tmp_p [ 1 ] , tmp_p [ 0 ] ] <NEWLINE> tmp_comb . remove ( tmp_p_r ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans += dfs ( next_p , tmp_visited , tmp_comb , p_num ) <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a_b = [ ] <NEWLINE> tmp = [ ] <NEWLINE> tmp_r = [ ] <NEWLINE> <NL> <COMMENT> <NL> for i in range ( M ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmp_r = [ tmp [ 1 ] , tmp [ 0 ] ] <NEWLINE> a_b . append ( tmp ) <NEWLINE> a_b . append ( tmp_r ) <NEWLINE> <NL> <DEDENT> visited = [ 1 ] <NEWLINE> <NL> <COMMENT> <NL> pass_num = dfs ( 1 , visited , a_b , N ) <NEWLINE> print ( pass_num ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( sum ( ans ) - n ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = { } <NEWLINE> for i in d : <NEWLINE> <INDENT> if i not in cnt : <NEWLINE> <INDENT> cnt [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> m = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flag = True <NEWLINE> for i in t : <NEWLINE> <INDENT> if i in cnt : <NEWLINE> <INDENT> if cnt [ i ] > 0 : <NEWLINE> <INDENT> cnt [ i ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> temp = sorted ( a ) <NEWLINE> m1 = temp [ - 1 ] <NEWLINE> m2 = temp [ - 2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == m1 : <NEWLINE> <INDENT> print ( m2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m1 ) <NEWLINE> <DEDENT> <DEDENT>
N , P = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> def main ( n , p ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return P <NEWLINE> <DEDENT> global ans <NEWLINE> for i in range ( 2 , int ( p ** ( 2 / n ) ) ) : <NEWLINE> <INDENT> t = i ** n <NEWLINE> if p % t == 0 : <NEWLINE> <INDENT> ans *= i <NEWLINE> return main ( n , p // t ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> print ( main ( N , P ) ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( q ) ] <NEWLINE> ans = [ ] <NEWLINE> def calc ( n ) : <NEWLINE> <INDENT> return n - q <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( k ) <NEWLINE> <DEDENT> ans = list ( map ( calc , ans ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ans [ i ] <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = 10 ** 9 <NEWLINE> for i in range ( 2 , S ) : <NEWLINE> <INDENT> if S % i != 0 : <NEWLINE> <INDENT> x = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> res = [ S ] * K + [ x ] * ( N - K ) <NEWLINE> print ( <STRING> . join ( map ( str , res ) ) ) <NEWLINE>
from bisect import bisect_left , bisect_right <NEWLINE> <NL> def readinput ( ) : <NEWLINE> <INDENT> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> bb , cc = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b . append ( bb ) <NEWLINE> c . append ( cc ) <NEWLINE> <DEDENT> return n , m , a , b , c <NEWLINE> <NL> <DEDENT> def main ( n , m , a , b , c ) : <NEWLINE> <INDENT> a . sort ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <COMMENT> <NL> <INDENT> bi = b [ i ] <NEWLINE> ci = c [ i ] <NEWLINE> j = bisect_left ( a , ci ) - 1 <NEWLINE> if j < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if j > bi - 1 : <NEWLINE> <INDENT> save = a [ bi : j + 1 ] <NEWLINE> l = j - bi + 1 <NEWLINE> r = j <NEWLINE> a [ l : r + 1 ] = [ ci ] * ( r - l + 1 ) <NEWLINE> a [ 0 : l ] = save <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = 0 <NEWLINE> r = j <NEWLINE> a [ l : r + 1 ] = [ ci ] * ( r - l + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum += a [ i ] <NEWLINE> <NL> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> def main2 ( n , m , a , b , c ) : <NEWLINE> <INDENT> all = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> all . append ( ( a [ i ] , 1 ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> all . append ( ( c [ i ] , b [ i ] ) ) <NEWLINE> <DEDENT> all . sort ( reverse = True , key = lambda x : x [ 0 ] ) <NEWLINE> <COMMENT> <NL> count = n <NEWLINE> sum = 0 <NEWLINE> i = 0 <NEWLINE> while ( count > 0 ) : <NEWLINE> <INDENT> ni = all [ i ] [ 1 ] <NEWLINE> if ni <= count : <NEWLINE> <INDENT> sum += all [ i ] [ 0 ] * ni <NEWLINE> count -= ni <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += all [ i ] [ 0 ] * count <NEWLINE> count = 0 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m , a , b , c = readinput ( ) <NEWLINE> ans = main2 ( n , m , a , b , c ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> x , y , z = 0 , 0 , 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> elif i == 2 : <NEWLINE> <INDENT> y += 1 <NEWLINE> <DEDENT> elif i == 3 : <NEWLINE> <INDENT> z += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dp = np . full ( ( N + 1 , N + 1 , N + 1 ) , - 1 , dtype = np . float64 ) <NEWLINE> <NL> dp [ 0 ] [ 0 ] [ 0 ] = 0 <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def calc ( h , i , j , N , dp ) : <NEWLINE> <INDENT> if h + i + j == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if dp [ h ] [ i ] [ j ] >= 0 : <NEWLINE> <INDENT> return dp [ h ] [ i ] [ j ] <NEWLINE> <DEDENT> A = 1 <NEWLINE> if h >= 1 : <NEWLINE> <INDENT> A += calc ( h - 1 , i , j , N , dp ) * h / N <NEWLINE> <DEDENT> if i >= 1 : <NEWLINE> <INDENT> A += calc ( h + 1 , i - 1 , j , N , dp ) * i / N <NEWLINE> <DEDENT> if j >= 1 : <NEWLINE> <INDENT> A += calc ( h , i + 1 , j - 1 , N , dp ) * j / N <NEWLINE> <DEDENT> A = A * N / ( h + i + j ) <NEWLINE> dp [ h ] [ i ] [ j ] = A <NEWLINE> return A <NEWLINE> <NL> <DEDENT> a = calc ( x , y , z , N , dp ) <NEWLINE> <NL> print ( dp [ x ] [ y ] [ z ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> alist = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> alist . sort ( key = lambda x : x [ 2 ] , reverse = True ) <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> h = abs ( alist [ 0 ] [ 0 ] - i ) + abs ( alist [ 0 ] [ 1 ] - j ) + alist [ 0 ] [ 2 ] <NEWLINE> ans = True <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> if max ( ( h - abs ( alist [ k ] [ 0 ] - i ) - abs ( alist [ k ] [ 1 ] - j ) ) , 0 ) != alist [ k ] [ 2 ] : <NEWLINE> <INDENT> ans = False <NEWLINE> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> ansx = i <NEWLINE> ansy = j <NEWLINE> ansh = h <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ansx , ansy , ansh ) <NEWLINE>
n = int ( input ( ) ) - 1 <NEWLINE> ans = ( 1 + n ) * n // 2 <NEWLINE> <NL> print ( ans ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = collections . Counter ( [ <STRING> . join ( sorted ( input ( ) ) ) for i in range ( N ) ] ) <NEWLINE> print ( sum ( map ( lambda x : x * ( x - 1 ) // 2 , S . values ( ) ) ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in [ 0 ] * N ] <NEWLINE> <NL> for _ in [ 0 ] * M : <NEWLINE> <INDENT> a , b , d = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> G [ a ] . append ( ( b , d ) ) <NEWLINE> G [ b ] . append ( ( a , - d ) ) <NEWLINE> <NL> <DEDENT> X = [ None ] * N <NEWLINE> <NL> def dfs ( i , x = 0 ) : <NEWLINE> <INDENT> for j , d in G [ i ] : <NEWLINE> <INDENT> if X [ j ] is None : <NEWLINE> <INDENT> X [ j ] = x + d <NEWLINE> dfs ( j , x + d ) <NEWLINE> <DEDENT> elif X [ j ] != x + d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] is not None : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> X [ i ] = 0 <NEWLINE> dfs ( i ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <COMMENT> <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> E = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> visited = [ False for _ in range ( N + 1 ) ] <NEWLINE> Node_len = [ 1 for _ in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> E [ a ] . append ( b ) <NEWLINE> E [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> AS = [ 0 for i in range ( N + 1 ) ] <NEWLINE> def dfs ( node , parent = - 1 ) : <NEWLINE> <INDENT> for child in E [ node ] : <NEWLINE> <INDENT> if child == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> AS [ child ] += AS [ node ] <NEWLINE> dfs ( child , node ) <NEWLINE> <NL> <DEDENT> <DEDENT> for q in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> AS [ p ] += x <NEWLINE> <NL> <DEDENT> dfs ( 1 ) <NEWLINE> print ( * AS [ 1 : ] ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> <NL> ans = ( n * ( n - 1 ) // 2 ) <NEWLINE> <NL> print ( int ( ans ) ) <NEWLINE>
import sys <NEWLINE> from collections import Counter <NEWLINE> from functools import reduce <NEWLINE> from operator import mul , ior <NEWLINE> <NL> from typing import Callable , ClassVar , Sequence , Type , TypeVar <NEWLINE> <NL> <NL> T = TypeVar ( <STRING> , bound = <STRING> ) <NEWLINE> <NL> <NL> class ModIntBase : <NEWLINE> <INDENT> value : int <NEWLINE> mod : ClassVar [ int ] <NEWLINE> fac : ClassVar [ Sequence [ int ] ] = ( ) <NEWLINE> inv : ClassVar [ Sequence [ int ] ] = ( ) <NEWLINE> finv : ClassVar [ Sequence [ int ] ] = ( ) <NEWLINE> <NL> def __init__ ( self , value : int ) -> None : <NEWLINE> <INDENT> self . value = value % self . mod <NEWLINE> <NL> <DEDENT> def __hash__ ( self ) -> int : <NEWLINE> <INDENT> return hash ( ( self . value , self . mod ) ) <NEWLINE> <NL> <DEDENT> def __eq__ ( self , other ) -> bool : <NEWLINE> <INDENT> if isinstance ( other , self . __class__ ) : <NEWLINE> <INDENT> return self . value == other . value <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <NL> <DEDENT> <DEDENT> def __ne__ ( self , other ) -> bool : <NEWLINE> <INDENT> if isinstance ( other , self . __class__ ) : <NEWLINE> <INDENT> return self . value != other . value <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def __add__ ( self , other ) : <NEWLINE> <INDENT> if isinstance ( other , self . __class__ ) : <NEWLINE> <INDENT> return self . __class__ ( ( self . value + other . value ) % self . mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <NL> <DEDENT> <DEDENT> def __sub__ ( self , other ) : <NEWLINE> <INDENT> if isinstance ( other , self . __class__ ) : <NEWLINE> <INDENT> return self . __class__ ( ( self . value - other . value ) % self . mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <NL> <DEDENT> <DEDENT> def __mul__ ( self , other ) : <NEWLINE> <INDENT> if isinstance ( other , self . __class__ ) : <NEWLINE> <INDENT> return self . __class__ ( self . value * other . value % self . mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <NL> <DEDENT> <DEDENT> def __truediv__ ( self , other ) : <NEWLINE> <INDENT> if isinstance ( other , self . __class__ ) : <NEWLINE> <INDENT> a = other . value <NEWLINE> b = self . mod <NEWLINE> u = 1 <NEWLINE> v = 0 <NEWLINE> while b : <NEWLINE> <INDENT> t = a // b <NEWLINE> a , b = b , a - t * b <NEWLINE> u , v = v , u - t * v <NEWLINE> <DEDENT> return self . __class__ ( self . value * u % self . mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <NL> <DEDENT> <DEDENT> def __pow__ ( self , other ) : <NEWLINE> <INDENT> if isinstance ( other , self . __class__ ) : <NEWLINE> <INDENT> v = 1 <NEWLINE> a = self . value <NEWLINE> b = other . value <NEWLINE> mod = self . mod <NEWLINE> while b > 0 : <NEWLINE> <INDENT> if b & 1 : <NEWLINE> <INDENT> v = v * a % mod <NEWLINE> <DEDENT> a = a * a % mod <NEWLINE> b >>= 1 <NEWLINE> <DEDENT> return self . __class__ ( v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <NL> <DEDENT> <DEDENT> @ classmethod <NEWLINE> def comb ( cls , n : int , k : int ) : <NEWLINE> <INDENT> if n < k : <NEWLINE> <INDENT> return cls ( 0 ) <NEWLINE> <DEDENT> if n < 0 or k < 0 : <NEWLINE> <INDENT> return cls ( 0 ) <NEWLINE> <NL> <DEDENT> if n < len ( cls . fac ) : <NEWLINE> <INDENT> return cls ( cls . fac [ n ] * ( cls . finv [ k ] * cls . finv [ n - k ] % cls . mod ) % cls . mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = min ( k , n - k ) <NEWLINE> a = reduce ( mul , map ( cls , range ( n - k + 1 , n + 1 ) ) , cls ( 1 ) ) <NEWLINE> b = reduce ( mul , map ( cls , range ( 1 , k + 1 ) ) , cls ( 1 ) ) <NEWLINE> return a / b <NEWLINE> <NL> <DEDENT> <DEDENT> def __repr__ ( self ) -> str : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> def __str__ ( self ) -> str : <NEWLINE> <INDENT> return str ( self . value ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class ModInt ( ModIntBase ) : <NEWLINE> <INDENT> mod = 1000000007 <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> def prime_factor ( a , temp ) : <NEWLINE> <INDENT> while a > 1 : <NEWLINE> <INDENT> yield temp [ a ] <NEWLINE> a //= temp [ a ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( in_ ) : <NEWLINE> <INDENT> N = int ( next ( in_ ) ) <NEWLINE> A = tuple ( map ( int , next ( in_ ) . split ( ) ) ) <NEWLINE> <NL> max_a = max ( A ) <NEWLINE> temp = [ 0 ] * ( max_a + 1 ) <NEWLINE> temp [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , max_a + 1 ) : <NEWLINE> <INDENT> if temp [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for j in range ( i , max_a + 1 , i ) : <NEWLINE> <INDENT> temp [ j ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> ap_list = ( Counter ( prime_factor ( a , temp ) ) for a in A ) <NEWLINE> lcm = reduce ( ior , ap_list , Counter ( ) ) <NEWLINE> lcm_i = ModInt ( 1 ) <NEWLINE> for v in lcm . elements ( ) : <NEWLINE> <INDENT> lcm_i *= ModInt ( v ) <NEWLINE> <NL> <NL> <DEDENT> ans = ModInt ( 0 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> ans += lcm_i / ModInt ( a ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> answer = resolve ( sys . stdin . buffer ) <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> mem = [ [ 0 for _ in range ( N ) ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> mem [ L - 1 ] [ R - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for L in range ( N ) : <NEWLINE> <INDENT> for R in range ( 1 , N ) : <NEWLINE> <INDENT> mem [ L ] [ R ] += mem [ L ] [ R - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for R in range ( N ) : <NEWLINE> <INDENT> for L in range ( 1 , N ) : <NEWLINE> <INDENT> mem [ L ] [ R ] += mem [ L - 1 ] [ R ] <NEWLINE> <NL> <DEDENT> <DEDENT> res = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> QL , QR = map ( int , input ( ) . split ( ) ) <NEWLINE> if QL == 1 : <NEWLINE> <INDENT> r = mem [ QR - 1 ] [ QR - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = mem [ QR - 1 ] [ QR - 1 ] - mem [ QL - 2 ] [ QR - 1 ] <NEWLINE> <DEDENT> res . append ( r ) <NEWLINE> <NL> <DEDENT> for r in res : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 2 * 10 ** 5 + 5 ) <NEWLINE> <NL> <NL> def dfs ( _v , _u ) : <NEWLINE> <INDENT> for u in v [ _v ] : <NEWLINE> <INDENT> if u == _u : continue ; <NEWLINE> ans [ u ] += ans [ _v ] <NEWLINE> dfs ( u , _v ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> v [ a ] . append ( b ) <NEWLINE> v [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> ans [ p ] += x + 1 <NEWLINE> <NL> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> <NL> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> v = [ [ ] * n for i in range ( n ) ] <NEWLINE> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> def bfs ( goal , graph , seen , next_v ) : <NEWLINE> <INDENT> for x in graph [ next_v [ 0 ] [ 0 ] ] : <NEWLINE> <INDENT> if x == goal : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if x in seen : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> next_v . append ( ( x , next_v [ 0 ] [ 1 ] + 1 ) ) <NEWLINE> seen . add ( x ) <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> next_v = [ ( 0 , 0 ) ] <NEWLINE> seen = { 0 } <NEWLINE> <COMMENT> <NL> while True : <NEWLINE> <INDENT> if len ( next_v ) == 0 or next_v [ 0 ] [ 1 ] == 2 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> if bfs ( N - 1 , graph , seen , next_v ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> next_v . pop ( 0 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def i ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> S = s ( ) <NEWLINE> N = len ( S ) <NEWLINE> num = 1 <NEWLINE> num2 = 1 <NEWLINE> ans = 0 <NEWLINE> Flag = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == S [ i + 1 ] : <NEWLINE> <INDENT> ans += num <NEWLINE> num += 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += max ( num , num2 ) <NEWLINE> num = 1 <NEWLINE> Flag = 0 <NEWLINE> <DEDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> num2 = num <NEWLINE> num = 1 <NEWLINE> Flag = 1 <NEWLINE> <DEDENT> <DEDENT> if Flag : <NEWLINE> <INDENT> ans += max ( num2 , num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += num <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> INF = 10 ** 9 <NEWLINE> dp = [ INF ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> i_j = i + j <NEWLINE> if i_j < n : <NEWLINE> <INDENT> x = dp [ i ] + abs ( h [ i ] - h [ i_j ] ) <NEWLINE> if dp [ i_j ] > x : <NEWLINE> <INDENT> dp [ i_j ] = x <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> b = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += b <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 , 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( i - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> x = L [ i ] - L [ j ] <NEWLINE> maxindex = bisect . bisect_right ( L , x ) <NEWLINE> if j > maxindex : <NEWLINE> <INDENT> ans += j - maxindex <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for n in range ( 1 , int ( N / 2 ) + 1 ) : <NEWLINE> <INDENT> if 2 * n + 1 > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 1 , int ( N ** ( 1 / 2 ) / 2 ) + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , int ( N ** ( 1 / 2 ) / 2 ) + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , int ( N ** ( 1 / 2 ) / 2 ) + 1 ) : <NEWLINE> <INDENT> if 2 * n + 1 == ( 2 * i + 1 ) * ( 2 * j + 1 ) * ( 2 * k + 1 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> L = input ( ) + <STRING> <NEWLINE> S = input ( ) <NEWLINE> T = [ ] <NEWLINE> i = 0 <NEWLINE> <NL> <NL> while n - 1 >= i : <NEWLINE> <INDENT> if L [ i ] == L [ i + 1 ] : <NEWLINE> <INDENT> T . append ( 0 ) <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T . append ( 1 ) <NEWLINE> i += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def f ( x , y ) : <NEWLINE> <INDENT> if x == 0 and y == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if x == 0 and y == 0 : <NEWLINE> <INDENT> return 3 <NEWLINE> <DEDENT> if x == 1 and y == 1 : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> if x == 1 and y == 0 : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> <DEDENT> if T [ 0 ] == 0 : <NEWLINE> <INDENT> ans = 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 3 <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( len ( T ) - 1 ) : <NEWLINE> <INDENT> ans = ans * f ( T [ i ] , T [ i + 1 ] ) <NEWLINE> ans = ans % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
import bisect <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> l_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l_lst . sort ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <NL> <INDENT> a = l_lst [ i ] <NEWLINE> b = l_lst [ j ] <NEWLINE> tmp = bisect . bisect_left ( l_lst , a + b ) <NEWLINE> tmp -= j + 1 <NEWLINE> tmp = max ( 0 , tmp ) <NEWLINE> count += tmp <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> value_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cost_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = value_list [ i ] - cost_list [ i ] <NEWLINE> if ans > 0 : <NEWLINE> <INDENT> total += ans <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> st_n = a [ 0 ] <NEWLINE> st_r = a [ 1 ] <NEWLINE> m = st_r * ( st_n - st_r ) <NEWLINE> for r in range ( 2 , N ) : <NEWLINE> <INDENT> cn = a [ r ] * ( st_n - a [ r ] ) <NEWLINE> if m < cn : <NEWLINE> <INDENT> st_r = a [ r ] <NEWLINE> m = cn <NEWLINE> <DEDENT> <DEDENT> print ( st_n , st_r ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( b // x ) - ( ( a - 1 ) // x ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> counter_list = [ 0 ] * N <NEWLINE> for i in a_list : <NEWLINE> <INDENT> counter_list [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> counter_list . sort ( reverse = True ) <NEWLINE> <NL> ans = N - sum ( counter_list [ : K ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n == 2 : <NEWLINE> <INDENT> print ( max ( A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> r = max ( gcd ( A [ 0 ] , A [ 1 ] ) , gcd ( A [ 1 ] , A [ 2 ] ) , gcd ( A [ 2 ] , A [ 0 ] ) ) <NEWLINE> <COMMENT> <NL> a = gcd ( A [ 0 ] , gcd ( A [ 1 ] , A [ 2 ] ) ) <NEWLINE> <NL> for i in range ( 3 , n ) : <NEWLINE> <INDENT> r = max ( gcd ( A [ i ] , r ) , a ) <NEWLINE> a = gcd ( A [ i ] , a ) <NEWLINE> <NL> <DEDENT> print ( r ) <NEWLINE> <DEDENT>
import math <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> for i in range ( 1 , int ( math . sqrt ( M ) ) + 1 ) : <NEWLINE> <INDENT> if M % i == 0 : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> if i != M // i : <NEWLINE> <INDENT> l . append ( M // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> l . sort ( reverse = True ) <NEWLINE> for n in l : <NEWLINE> <INDENT> if n * N <= M : <NEWLINE> <INDENT> ans = n <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = np . int32 ) <NEWLINE> A = np . sort ( A ) <NEWLINE> <NL> EXC = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> exc = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> EXC . append ( exc ) <NEWLINE> <DEDENT> excArry = np . array ( EXC , dtype = np . int32 ) <NEWLINE> <NL> col_num = 1 <NEWLINE> Arr = excArry [ np . argsort ( excArry [ : , col_num ] ) [ : : - 1 ] ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> point = 0 <NEWLINE> <NL> <NL> for j in range ( M ) : <NEWLINE> <INDENT> change_Num = Arr [ j ] [ 1 ] <NEWLINE> count = np . count_nonzero ( A < change_Num ) <NEWLINE> if count > 0 : <NEWLINE> <INDENT> m = min ( count , Arr [ j ] [ 0 ] ) <NEWLINE> A [ point : point + m ] = change_Num <NEWLINE> point += m <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( np . sum ( A ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> from collections import deque <NEWLINE> <NL> N , C = map ( int , input ( ) . split ( ) ) <NEWLINE> Mx = 10 ** 5 + 1 <NEWLINE> sch = [ [ 0 ] * Mx for _ in range ( C ) ] <NEWLINE> scht = [ 0 ] * Mx <NEWLINE> plist = [ [ ] for _ in range ( C ) ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> s , t , c = map ( int , input ( ) . split ( ) ) <NEWLINE> plist [ c - 1 ] . append ( ( s , t ) ) <NEWLINE> <DEDENT> for c , p in enumerate ( plist ) : <NEWLINE> <INDENT> p . sort ( ) <NEWLINE> prevt = 0 <NEWLINE> for s , t in p : <NEWLINE> <INDENT> if prevt == s : <NEWLINE> <INDENT> sch [ c ] [ prevt ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sch [ c ] [ s ] = 1 <NEWLINE> <DEDENT> sch [ c ] [ t ] = - 1 <NEWLINE> prevt = t <NEWLINE> <DEDENT> for i in range ( 1 , Mx ) : <NEWLINE> <INDENT> if sch [ c ] [ i ] == 1 : <NEWLINE> <INDENT> scht [ i - 1 ] += 1 <NEWLINE> <DEDENT> if sch [ c ] [ i ] == - 1 : <NEWLINE> <INDENT> scht [ i ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , Mx ) : <NEWLINE> <INDENT> scht [ i ] += scht [ i - 1 ] <NEWLINE> <NL> <DEDENT> print ( max ( scht ) ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> Num , Count = zip ( * sorted ( collections . Counter ( int ( T ) for T in input ( ) . split ( ) ) . most_common ( ) ) ) <NEWLINE> DisN = ( ( min ( Num ) - 1 ) , ) + Num + ( ( max ( Num ) + 1 ) , ) <NEWLINE> DisC = ( 0 , ) + Count + ( 0 , ) <NEWLINE> MAX = 0 <NEWLINE> for T in range ( 1 , len ( Num ) + 1 ) : <NEWLINE> <INDENT> Dis = DisC [ T ] <NEWLINE> if DisN [ T - 1 ] == DisN [ T ] - 1 : <NEWLINE> <INDENT> Dis += DisC [ T - 1 ] <NEWLINE> <DEDENT> if DisN [ T + 1 ] == DisN [ T ] + 1 : <NEWLINE> <INDENT> Dis += DisC [ T + 1 ] <NEWLINE> <DEDENT> if MAX < Dis : <NEWLINE> <INDENT> MAX = Dis <NEWLINE> <DEDENT> <DEDENT> print ( MAX ) <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> if len ( S ) >= K and S [ : K ] == <STRING> * K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> print ( S [ 0 ] ) <NEWLINE> <DEDENT>
import sys ; from decimal import Decimal <NEWLINE> import math ; from itertools import combinations , product <NEWLINE> import bisect ; from collections import Counter , deque , defaultdict <NEWLINE> <NL> <COMMENT> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = 10 ** 9 <NEWLINE> PI = 3.14159265358979323846 <NEWLINE> <NL> def read_str ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def read_int ( ) : return int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> def read_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_str_list ( ) : return list ( sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_int_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> def lcm ( a : int , b : int ) -> int : return ( a * b ) // math . gcd ( a , b ) <NEWLINE> <NL> import numpy as np <NEWLINE> from numba import i8 , njit <NEWLINE> <NL> <COMMENT> <NL> @ njit ( i8 ( i8 , i8 [ : ] ) , cache = True ) <NEWLINE> def binary_search ( n , a ) : <NEWLINE> <INDENT> right = np . max ( a ) + 10 ** 9 <NEWLINE> left = np . min ( a ) - 10 ** 9 <NEWLINE> <NL> def calc ( b ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> score += abs ( a [ i ] - ( b + i + 1 ) ) <NEWLINE> <DEDENT> return score <NEWLINE> <NL> <DEDENT> while right - left > 1 : <NEWLINE> <INDENT> middle = ( right + left ) // 2 <NEWLINE> if calc ( middle ) < calc ( middle + 1 ) : <NEWLINE> <INDENT> right = middle <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = middle <NEWLINE> <NL> <DEDENT> <DEDENT> return calc ( right ) <NEWLINE> <NL> <DEDENT> def Main ( ) : <NEWLINE> <INDENT> n = read_int ( ) <NEWLINE> a = np . array ( read_int_list ( ) , dtype = np . int64 ) <NEWLINE> <NL> print ( binary_search ( n , a ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> count = 0 <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if min ( L [ i - 1 ] , L [ i + 1 ] ) < L [ i ] < max ( L [ i - 1 ] , L [ i + 1 ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def prime_factorize ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> n //= 2 <NEWLINE> <DEDENT> arr . append ( [ 2 , cnt ] ) <NEWLINE> <NL> <DEDENT> p = 3 <NEWLINE> while p * p <= n : <NEWLINE> <INDENT> if n % p == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while n % p == 0 : <NEWLINE> <INDENT> n //= p <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> arr . append ( [ p , cnt ] ) <NEWLINE> p += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p += 2 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <NL> <NL> <DEDENT> n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if p == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> pr_list = prime_factorize ( p ) <NEWLINE> <NL> for a , b in pr_list : <NEWLINE> <INDENT> if b >= n : <NEWLINE> <INDENT> ans *= a ** ( b // n ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ input ( ) for _ in range ( n ) ] <NEWLINE> b = [ input ( ) for _ in range ( m ) ] <NEWLINE> <NL> d = n - m + 1 <NEWLINE> flg = False <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> for j in range ( d ) : <NEWLINE> <INDENT> if a [ i ] [ j : j + m ] == b [ 0 ] : <NEWLINE> <INDENT> for k in range ( 1 , m ) : <NEWLINE> <INDENT> if a [ i + k ] [ j : j + m ] != b [ k ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flg = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> ans1 = - y - ( - x ) + 2 <NEWLINE> <COMMENT> <NL> ans2 = y - ( - x ) + 1 <NEWLINE> <COMMENT> <NL> ans3 = - y - x + 1 <NEWLINE> <COMMENT> <NL> ans4 = y - x <NEWLINE> <NL> ans = [ ans1 , ans2 , ans3 , ans4 ] <NEWLINE> ans = [ a for a in ans if a > 0 ] <NEWLINE> ans = min ( ans ) <NEWLINE> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = Counter ( v [ : : 2 ] ) . most_common ( ) <NEWLINE> b = Counter ( v [ 1 : : 2 ] ) . most_common ( ) <NEWLINE> a . append ( [ 0 , 0 ] ) <NEWLINE> b . append ( [ 0 , 0 ] ) <NEWLINE> <NL> if a [ 0 ] [ 0 ] != b [ 0 ] [ 0 ] : <NEWLINE> <INDENT> print ( n - a [ 0 ] [ 1 ] - b [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( n - a [ 1 ] [ 1 ] - b [ 0 ] [ 1 ] , n - a [ 0 ] [ 1 ] - b [ 1 ] [ 1 ] ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> def sum_of ( num ) : <NEWLINE> <INDENT> list_b = [ ] <NEWLINE> k = 0 <NEWLINE> while num > 0 : <NEWLINE> <INDENT> list_b . append ( num % 10 ) <NEWLINE> num //= 10 <NEWLINE> <DEDENT> for i in range ( len ( list_b ) ) : <NEWLINE> <INDENT> k += list_b [ i ] <NEWLINE> <DEDENT> return k <NEWLINE> <NL> <DEDENT> list_a = [ ] <NEWLINE> if N == 2 : <NEWLINE> <INDENT> print ( str ( 2 ) ) <NEWLINE> <DEDENT> if N == 3 : <NEWLINE> <INDENT> print ( str ( 3 ) ) <NEWLINE> <DEDENT> if N >= 4 : <NEWLINE> <INDENT> for i in range ( 2 , N - 1 ) : <NEWLINE> <INDENT> A = i <NEWLINE> B = N - i <NEWLINE> list_a . append ( sum_of ( A ) + sum_of ( B ) ) <NEWLINE> <DEDENT> print ( min ( list_a ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 1 : <NEWLINE> <INDENT> if W == 1 : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt = [ 0 for _ in range ( W ) ] <NEWLINE> s = list ( input ( ) ) <NEWLINE> for w in range ( W ) : <NEWLINE> <INDENT> if w == 0 : <NEWLINE> <INDENT> cnt [ w ] += s [ w + 1 ] == <STRING> <NEWLINE> <DEDENT> elif w == W - 1 : <NEWLINE> <INDENT> cnt [ w ] += s [ w - 1 ] == <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ w ] += s [ w + 1 ] == <STRING> <NEWLINE> cnt [ w ] += s [ w - 1 ] == <STRING> <NEWLINE> <DEDENT> <DEDENT> for w in range ( W ) : <NEWLINE> <INDENT> if s [ w ] == <STRING> : <NEWLINE> <INDENT> cnt [ w ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> ans = map ( str , cnt ) <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE> <DEDENT> sys . exit ( 0 ) <NEWLINE> <DEDENT> if W == 1 : <NEWLINE> <INDENT> cnt = [ 0 for _ in range ( H ) ] <NEWLINE> s = [ ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> if h == 0 : <NEWLINE> <INDENT> cnt [ h ] += s [ h + 1 ] == <STRING> <NEWLINE> <DEDENT> elif h == H - 1 : <NEWLINE> <INDENT> cnt [ h ] += s [ h - 1 ] == <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ h ] += s [ h - 1 ] == <STRING> <NEWLINE> cnt [ h ] += s [ h + 1 ] == <STRING> <NEWLINE> <DEDENT> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> if s [ h ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cnt [ h ] ) <NEWLINE> <DEDENT> <DEDENT> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> S = [ ] <NEWLINE> cnt = [ [ 0 for _ in range ( W ) ] for _ in range ( H ) ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> for w in range ( W ) : <NEWLINE> <INDENT> if w == 0 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += s [ w + 1 ] == <STRING> <NEWLINE> <DEDENT> elif w == W - 1 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += s [ w - 1 ] == <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ h ] [ w ] += s [ w + 1 ] == <STRING> <NEWLINE> cnt [ h ] [ w ] += s [ w - 1 ] == <STRING> <NEWLINE> <DEDENT> <DEDENT> S . append ( s ) <NEWLINE> <NL> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if h == 0 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h + 1 ] [ w ] == <STRING> <NEWLINE> if w == 0 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h + 1 ] [ w + 1 ] == <STRING> <NEWLINE> <DEDENT> elif w == W - 1 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h + 1 ] [ w - 1 ] == <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h + 1 ] [ w - 1 ] == <STRING> <NEWLINE> cnt [ h ] [ w ] += S [ h + 1 ] [ w + 1 ] == <STRING> <NEWLINE> <DEDENT> <DEDENT> elif h == H - 1 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h - 1 ] [ w ] == <STRING> <NEWLINE> if w == 0 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h - 1 ] [ w + 1 ] == <STRING> <NEWLINE> <DEDENT> elif w == W - 1 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h - 1 ] [ w - 1 ] == <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h - 1 ] [ w - 1 ] == <STRING> <NEWLINE> cnt [ h ] [ w ] += S [ h - 1 ] [ w + 1 ] == <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h + 1 ] [ w ] == <STRING> <NEWLINE> if w == 0 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h + 1 ] [ w + 1 ] == <STRING> <NEWLINE> <DEDENT> elif w == W - 1 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h + 1 ] [ w - 1 ] == <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h + 1 ] [ w - 1 ] == <STRING> <NEWLINE> cnt [ h ] [ w ] += S [ h + 1 ] [ w + 1 ] == <STRING> <NEWLINE> <DEDENT> cnt [ h ] [ w ] += S [ h - 1 ] [ w ] == <STRING> <NEWLINE> if w == 0 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h - 1 ] [ w + 1 ] == <STRING> <NEWLINE> <DEDENT> elif w == W - 1 : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h - 1 ] [ w - 1 ] == <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ h ] [ w ] += S [ h - 1 ] [ w - 1 ] == <STRING> <NEWLINE> cnt [ h ] [ w ] += S [ h - 1 ] [ w + 1 ] == <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> s = S [ h ] <NEWLINE> for w in range ( W ) : <NEWLINE> <INDENT> if s [ w ] == <STRING> : <NEWLINE> <INDENT> cnt [ h ] [ w ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> ans = map ( str , cnt [ h ] ) <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> ll = [ int ( w ) for w in input ( ) . split ( ) ] <NEWLINE> ll . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> ans += bisect . bisect_left ( ll , ll [ i ] + ll [ j ] ) - ( j + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> listn = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> min1 = listn [ 0 ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if ( listn [ i ] > min1 ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min1 = listn [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> aaa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bbb = [ format ( a , <STRING> ) for a in aaa ] <NEWLINE> <NL> zero = [ 0 ] * 61 <NEWLINE> one = [ 0 ] * 61 <NEWLINE> for i in range ( 61 ) : <NEWLINE> <INDENT> s = <STRING> . join ( list ( b [ - ( i + 1 ) ] for b in bbb ) ) <NEWLINE> zero [ i ] = s . count ( <STRING> ) <NEWLINE> one [ i ] = s . count ( <STRING> ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> MOD = 1_000_000_007 <NEWLINE> for i , o , l in zip ( range ( 61 ) , zero , one ) : <NEWLINE> <INDENT> ans += 2 ** i * o * l <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sumList = [ 0 ] * 8 <NEWLINE> mid = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if 1 <= List [ i ] <= 399 : <NEWLINE> <INDENT> sumList [ 0 ] += 1 <NEWLINE> <DEDENT> elif 400 <= List [ i ] <= 799 : <NEWLINE> <INDENT> sumList [ 1 ] += 1 <NEWLINE> <DEDENT> elif 800 <= List [ i ] <= 1199 : <NEWLINE> <INDENT> sumList [ 2 ] += 1 <NEWLINE> <DEDENT> elif 1200 <= List [ i ] <= 1599 : <NEWLINE> <INDENT> sumList [ 3 ] += 1 <NEWLINE> <DEDENT> elif 1600 <= List [ i ] <= 1999 : <NEWLINE> <INDENT> sumList [ 4 ] += 1 <NEWLINE> <DEDENT> elif 2000 <= List [ i ] <= 2399 : <NEWLINE> <INDENT> sumList [ 5 ] += 1 <NEWLINE> <DEDENT> elif 2400 <= List [ i ] <= 2799 : <NEWLINE> <INDENT> sumList [ 6 ] += 1 <NEWLINE> <DEDENT> elif 2800 <= List [ i ] <= 3199 : <NEWLINE> <INDENT> sumList [ 7 ] += 1 <NEWLINE> <DEDENT> elif 3200 <= List [ i ] : <NEWLINE> <INDENT> mid += 1 <NEWLINE> <DEDENT> <DEDENT> res1 = 8 - sumList . count ( 0 ) <NEWLINE> res2 = res1 + mid <NEWLINE> if res1 == 0 and mid > 0 : <NEWLINE> <INDENT> res1 = 1 <NEWLINE> <DEDENT> print ( res1 , res2 ) <NEWLINE>
p = 10 ** 9 + 7 <NEWLINE> <NL> def modpow ( a , n , p ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> ans = a % p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n % 2 == 0 : <NEWLINE> <INDENT> ans = ( modpow ( a , n // 2 , p ) ** 2 ) % p <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> ans = ( a * ( modpow ( a , n // 2 , p ) ** 2 ) ) % p <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> Fact = [ [ 1 , 1 ] for _ in range ( 10 ** 5 + 1 ) ] <NEWLINE> for i in range ( 1 , 10 ** 5 + 1 ) : <NEWLINE> <INDENT> Fact [ i ] [ 0 ] = ( Fact [ i - 1 ] [ 0 ] * i ) % p <NEWLINE> Fact [ i ] [ 1 ] = modpow ( Fact [ i ] [ 0 ] , p - 2 , p ) <NEWLINE> <NL> <DEDENT> def C ( a , b , p , Fact ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = Fact [ a ] [ 0 ] * Fact [ b ] [ 1 ] * Fact [ a - b ] [ 1 ] % p <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> <DEDENT> N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> maxS = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> maxS = ( maxS + A [ i ] * C ( i , K - 1 , p , Fact ) ) % p <NEWLINE> <NL> <DEDENT> minS = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> minS = ( minS + A [ i ] * C ( N - i - 1 , K - 1 , p , Fact ) ) % p <NEWLINE> <NL> <DEDENT> ans = ( maxS - minS ) % p <NEWLINE> <NL> print ( ans ) <NEWLINE>
from itertools import accumulate <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> l = [ 1 if s [ i ] == <STRING> else 0 for i in range ( n ) ] <NEWLINE> l = list ( accumulate ( l ) ) <NEWLINE> ans = l [ - 1 ] - l [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = min ( ans , i - l [ i - 1 ] + l [ - 1 ] - l [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> print ( A - K , B ) <NEWLINE> <DEDENT> elif K > A and B >= K - A : <NEWLINE> <INDENT> print ( 0 , B - ( K - A ) ) <NEWLINE> <DEDENT> elif K > A and B < ( K - A ) : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import statistics <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xmd = statistics . median ( x ) <NEWLINE> xs = sorted ( x ) <NEWLINE> for i in x : <NEWLINE> <INDENT> if i < xmd : <NEWLINE> <INDENT> print ( xs [ n // 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( xs [ n // 2 - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> rev = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> rev [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * rev ) <NEWLINE>
import numpy as np <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> dp = np . array ( [ np . inf ] * n ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if i - k > 0 : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - k : i ] + abs ( h [ i ] - h [ i - k : i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ 0 : i ] + abs ( h [ i ] - h [ 0 : i ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( int ( dp [ n - 1 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> print ( ( 1 + N ) * ( N // 2 ) - N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( 1 + N - 1 ) * ( N // 2 ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( n - m ) > 1 : print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> mod = 10 ** 9 + 7 <NEWLINE> def fact ( n ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= ( i + 1 ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> ans = ( fact ( n ) * fact ( m ) ) % mod <NEWLINE> if n == m : print ( ( 2 * ans ) % mod ) <NEWLINE> else : print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> m = N // i - 1 <NEWLINE> q , r = divmod ( N , m ) <NEWLINE> if q == r : <NEWLINE> <INDENT> ans += m <NEWLINE> <DEDENT> if m < N ** .5 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> S = input ( ) <NEWLINE> col_S = collections . Counter ( S ) <NEWLINE> print ( min ( col_S [ <STRING> ] , col_S [ <STRING> ] ) * 2 ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> bp = 1 <NEWLINE> for b in range ( 1 , X ) : <NEWLINE> <INDENT> for p in range ( 2 , X ) : <NEWLINE> <INDENT> if b ** p <= X : <NEWLINE> <INDENT> bp = max ( bp , b ** p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( bp ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> X , A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( 10 if A <= X else 0 ) <NEWLINE>
import math <NEWLINE> ans = 0 <NEWLINE> A = [ int ( input ( ) ) for i in range ( 5 ) ] <NEWLINE> a = 10 <NEWLINE> p = 0 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if a > ( A [ i ] % 10 ) and A [ i ] % 10 != 0 : <NEWLINE> <INDENT> p = i <NEWLINE> a = A [ i ] % 10 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 5 ) : <NEWLINE> <INDENT> if i == p : <NEWLINE> <INDENT> ans += A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 10 * ( math . ceil ( A [ i ] / 10 ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> class Unionfind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = [ - 1 ] * n <NEWLINE> self . dist = [ 0 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x , self . dist [ x ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = self . find ( self . parents [ x ] ) <NEWLINE> self . parents [ x ] = tmp [ 0 ] <NEWLINE> self . dist [ x ] += tmp [ 1 ] <NEWLINE> return self . parents [ x ] , self . dist [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y , d ) : <NEWLINE> <INDENT> rx , _ = self . find ( x ) <NEWLINE> ry , _ = self . find ( y ) <NEWLINE> diff = self . dist [ y ] - self . dist [ x ] - d <NEWLINE> if rx == ry : <NEWLINE> <INDENT> if diff != 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> if diff < 0 : <NEWLINE> <INDENT> rx , ry = ry , rx <NEWLINE> diff = - diff <NEWLINE> <DEDENT> self . parents [ ry ] = min ( self . parents [ ry ] , self . parents [ rx ] - diff ) <NEWLINE> self . parents [ rx ] = ry <NEWLINE> self . dist [ rx ] = diff <NEWLINE> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m , * lrd = map ( int , read ( ) . split ( ) ) <NEWLINE> v = Unionfind ( n ) <NEWLINE> for l , r , d in zip ( * [ iter ( lrd ) ] * 3 ) : <NEWLINE> <INDENT> if v . union ( l - 1 , r - 1 , d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> G = [ [ ] for i in range ( N ) ] <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ x - 1 ] . append ( y - 1 ) <NEWLINE> G [ y - 1 ] . append ( x - 1 ) <NEWLINE> <NL> <DEDENT> dp_black = [ - 1 ] * N <NEWLINE> dp_white = [ - 1 ] * N <NEWLINE> <NL> <COMMENT> <NL> def search ( v , parent ) : <NEWLINE> <INDENT> if dp_black [ v ] != - 1 : <NEWLINE> <INDENT> return ( dp_black [ v ] , dp_white [ v ] ) <NEWLINE> <DEDENT> black = 1 <NEWLINE> white = 1 <NEWLINE> for child in G [ v ] : <NEWLINE> <INDENT> if child == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> b , w = search ( child , v ) <NEWLINE> black *= w <NEWLINE> black %= MOD <NEWLINE> white *= ( b + w ) <NEWLINE> white %= MOD <NEWLINE> <DEDENT> dp_black [ v ] = black <NEWLINE> dp_white [ v ] = white <NEWLINE> return ( black , white ) <NEWLINE> <NL> <DEDENT> print ( sum ( search ( 0 , - 1 ) ) % MOD ) <NEWLINE>
<NL> import sys <NEWLINE> from bisect import bisect_left , bisect , bisect_right <NEWLINE> <NL> icase = 0 <NEWLINE> if icase == 0 : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = [ ] <NEWLINE> cb = [ [ 0 ] * 2 for i in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> bi , ci = map ( int , input ( ) . split ( ) ) <NEWLINE> cb [ i ] = [ ci , bi ] <NEWLINE> <DEDENT> <DEDENT> elif icase == 2 : <NEWLINE> <INDENT> n , m = 10 , 3 <NEWLINE> a = [ 1 , 4 , 5 , 5 , 7 , 8 , 13 , 33 , 52 , 100 ] <NEWLINE> cb = [ [ 30 , 4 ] , [ 10 , 3 ] , [ 4 , 1 ] ] <NEWLINE> <NL> <DEDENT> a . sort ( ) <NEWLINE> cb . sort ( reverse = True ) <NEWLINE> <NL> asum = 0 <NEWLINE> isum = 0 <NEWLINE> isumm = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> isum += cb [ i ] [ 1 ] <NEWLINE> if isum > n : <NEWLINE> <INDENT> if a [ n - 1 ] <= cb [ i ] [ 0 ] : <NEWLINE> <INDENT> asum += cb [ i ] [ 0 ] * ( n - isumm ) <NEWLINE> print ( asum ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ii = bisect_right ( a , cb [ i ] [ 0 ] ) <NEWLINE> asum += cb [ i ] [ 0 ] * ( ii - isumm ) <NEWLINE> asum += sum ( a [ ii : ] ) <NEWLINE> print ( asum ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> if a [ isum - 1 ] <= cb [ i ] [ 0 ] : <NEWLINE> <INDENT> asum += cb [ i ] [ 0 ] * cb [ i ] [ 1 ] <NEWLINE> isumm = isum <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ii = bisect_right ( a , cb [ i ] [ 0 ] ) <NEWLINE> asum += cb [ i ] [ 0 ] * ( ii - isumm ) <NEWLINE> asum += sum ( a [ ii : ] ) <NEWLINE> print ( asum ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> asum += sum ( a [ isum : ] ) <NEWLINE> <NL> print ( asum ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> d = 0 <NEWLINE> for i in b : <NEWLINE> <INDENT> d += i <NEWLINE> if d <= a [ 1 ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> left = 0 <NEWLINE> right = float ( <STRING> ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> left = max ( left , l ) <NEWLINE> right = min ( right , r ) <NEWLINE> <NL> <DEDENT> print ( max ( 0 , right - left + 1 ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , K = ( int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ) <NEWLINE> vs = [ int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ] <NEWLINE> g = [ vs [ 0 ] , vs [ - 1 ] ] <NEWLINE> rest = K <NEWLINE> for k in [ K - 1 , K ] : <NEWLINE> <INDENT> for b in range ( K // 2 ) : <NEWLINE> <INDENT> t = k - b <NEWLINE> if t > N : <NEWLINE> <INDENT> t = N <NEWLINE> <DEDENT> for i in range ( t + 1 ) : <NEWLINE> <INDENT> v = [ ] <NEWLINE> if i < t : <NEWLINE> <INDENT> v . extend ( vs [ : i ] ) <NEWLINE> v . extend ( vs [ - ( t - i ) : ] ) <NEWLINE> for _ in range ( b ) : <NEWLINE> <INDENT> if min ( v ) < 0 : <NEWLINE> <INDENT> v . remove ( min ( v ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> v . extend ( vs [ : t ] ) <NEWLINE> for _ in range ( b ) : <NEWLINE> <INDENT> if min ( v ) < 0 : <NEWLINE> <INDENT> v . remove ( min ( v ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> g . append ( sum ( v ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if max ( g ) < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( g ) ) <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> i = min ( A , B ) + 1 <NEWLINE> while count < K : <NEWLINE> <INDENT> i -= 1 <NEWLINE> if A % i == 0 and B % i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> l = s [ k - 1 ] <NEWLINE> if l == <STRING> : <NEWLINE> <INDENT> x = s [ : ( k - 1 ) ] + <STRING> + s [ k : ] <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> x = s [ : ( k - 1 ) ] + <STRING> + s [ k : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = s [ : ( k - 1 ) ] + <STRING> + s [ k : ] <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> <NL> for j in range ( k ) : <NEWLINE> <INDENT> ans [ 0 ] += ( 1 + p [ j ] ) / 2 <NEWLINE> <DEDENT> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> ans [ i ] = ans [ i - 1 ] - ( 1 + p [ i - 1 ] ) / 2 + ( 1 + p [ i + k - 1 ] ) / 2 <NEWLINE> <NL> <DEDENT> print ( max ( ans ) ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> <NL> m = map ( int , read ( ) . split ( ) ) <NEWLINE> A , B = zip ( * zip ( m , m ) ) <NEWLINE> A = np . array ( A [ : : - 1 ] ) <NEWLINE> B = np . array ( B [ : : - 1 ] ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> acc = B [ i ] - A [ i ] % B [ i ] if A [ i ] % B [ i ] != 0 else 0 <NEWLINE> A [ i : ] += acc <NEWLINE> cnt += acc <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
def Fib ( n ) : <NEWLINE> <INDENT> a , b = 1 , 1 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 2 ) : <NEWLINE> <INDENT> a , b = b , a + b <NEWLINE> <DEDENT> return b <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> <NL> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> if a [ i + 1 ] == a [ i ] + 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> x = [ ] <NEWLINE> temp = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x . append ( a [ i ] - temp - 1 ) <NEWLINE> temp = a [ i ] + 1 <NEWLINE> <DEDENT> x . append ( n - temp ) <NEWLINE> <NL> temp = 1 <NEWLINE> div = 1000000007 <NEWLINE> <NL> for i in x : <NEWLINE> <INDENT> temp = ( temp * Fib ( i + 1 ) ) % div <NEWLINE> <NL> <DEDENT> print ( temp ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , * H = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> c = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if H [ i ] >= H [ i + 1 ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( c ) <NEWLINE> c = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ans . append ( c ) <NEWLINE> <NL> print ( max ( ans ) ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for j in range ( N + 1 - i ) : <NEWLINE> <INDENT> if 10000 * i + 5000 * j + 1000 * ( N - i - j ) == Y : <NEWLINE> <INDENT> print ( str ( i ) + <STRING> + str ( j ) + <STRING> + str ( N - i - j ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> from itertools import accumulate <NEWLINE> <NL> import heapq <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> import copy <NEWLINE> import math <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def zz ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def z ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> <NL> def S ( ) : return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <NL> def C ( line ) : return [ sys . stdin . readline ( ) for _ in range ( line ) ] <NEWLINE> <NL> <NL> def get_sieve_of_eratosthenes ( n ) : <NEWLINE> <INDENT> if not isinstance ( n , int ) : <NEWLINE> <INDENT> raise TypeError ( <STRING> ) <NEWLINE> <DEDENT> if n < 2 : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> prime = [ 2 ] <NEWLINE> limit = int ( n ** 0.5 ) <NEWLINE> data = [ i + 1 for i in range ( 2 , n , 2 ) ] <NEWLINE> while True : <NEWLINE> <INDENT> p = data [ 0 ] <NEWLINE> if limit <= p : <NEWLINE> <INDENT> return prime + data <NEWLINE> <DEDENT> prime . append ( p ) <NEWLINE> data = [ e for e in data if e % p != 0 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> max_ = pow ( 10 , 5 ) + 2 <NEWLINE> primes = get_sieve_of_eratosthenes ( max_ ) <NEWLINE> num_lile2017 = [ 0 ] * max_ <NEWLINE> primes2 = [ ] <NEWLINE> for prime in primes : <NEWLINE> <INDENT> primes2 . append ( 2 * prime - 1 ) <NEWLINE> <DEDENT> like2017 = sorted ( list ( set ( primes2 ) & set ( primes ) ) ) <NEWLINE> for i in range ( 3 , max_ , 2 ) : <NEWLINE> <INDENT> if ( i in like2017 ) : <NEWLINE> <INDENT> num_lile2017 [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> num_lile2017 = list ( accumulate ( num_lile2017 ) ) <NEWLINE> <COMMENT> <NL> <NL> Q = z ( ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = zz ( ) <NEWLINE> print ( num_lile2017 [ r ] - num_lile2017 [ l - 1 ] ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> if i == 0 : <NEWLINE> <INDENT> if s [ : 5 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 5 : ] <NEWLINE> i = 1 <NEWLINE> <DEDENT> elif s [ : 5 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 5 : ] <NEWLINE> i = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> if s [ : 5 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 5 : ] <NEWLINE> i = 1 <NEWLINE> <DEDENT> elif s [ : 2 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 2 : ] <NEWLINE> i = 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> elif i == 2 : <NEWLINE> <INDENT> if s [ : 5 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 5 : ] <NEWLINE> i = 1 <NEWLINE> <DEDENT> elif s [ : 5 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 5 : ] <NEWLINE> i = 2 <NEWLINE> <DEDENT> elif s [ : 1 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 1 : ] <NEWLINE> i = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> elif i == 3 : <NEWLINE> <INDENT> if s [ : 5 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 5 : ] <NEWLINE> i = 1 <NEWLINE> <DEDENT> elif s [ : 3 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 3 : ] <NEWLINE> i = 2 <NEWLINE> <DEDENT> elif s [ : 5 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 5 : ] <NEWLINE> i = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from itertools import accumulate <NEWLINE> from operator import add , mul <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( [ 0 ] * ( n ) ) <NEWLINE> b . append ( [ 0 ] * ( n ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <STRING> <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> a [ l - 1 ] [ r - 1 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = list ( accumulate ( a [ i ] ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n - i - 1 ) : <NEWLINE> <INDENT> a [ n - i - j - 2 ] [ n - i - 1 ] += a [ n - i - j - 1 ] [ n - i - 1 ] <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( q ) : <NEWLINE> <INDENT> P , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a [ ( P - 1 ) ] [ ( Q - 1 ) ] ) <NEWLINE> <DEDENT> <STRING> <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> <NL> max_l = 0 <NEWLINE> min_r = f_inf <NEWLINE> for l , r in LR : <NEWLINE> <INDENT> max_l = max ( max_l , l ) <NEWLINE> min_r = min ( min_r , r ) <NEWLINE> <NL> <DEDENT> if min_r >= max_l : <NEWLINE> <INDENT> print ( min_r - max_l + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Y = sorted ( X ) <NEWLINE> a = Y [ N // 2 - 1 ] <NEWLINE> b = Y [ N // 2 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] <= a : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * ( N + 2 ) <NEWLINE> pass_list = [ 0 ] * ( N + 2 ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> a [ b ] = 1 <NEWLINE> <DEDENT> if ( a [ 1 ] != 1 ) : <NEWLINE> <INDENT> pass_list [ 1 ] = 1 <NEWLINE> <DEDENT> if ( a [ 2 ] != 1 ) : <NEWLINE> <INDENT> pass_list [ 2 ] = 1 <NEWLINE> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if ( a [ i ] != 1 ) : <NEWLINE> <INDENT> pass_list [ i ] += pass_list [ i - 1 ] + pass_list [ i - 2 ] <NEWLINE> <DEDENT> <DEDENT> print ( pass_list [ N ] % 1000000007 ) <NEWLINE>
import copy <NEWLINE> import math <NEWLINE> import time <NEWLINE> import statistics <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> import sys <NEWLINE> from decimal import * <NEWLINE> <NL> <COMMENT> <NL> def get_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_string ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_int_list ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> <DEDENT> def get_string_list ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_int_multi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_string_char_list ( ) : <NEWLINE> <INDENT> return list ( str ( input ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <STRING> <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> start = time . time ( ) <NEWLINE> <NL> n , q = get_int_multi ( ) <NEWLINE> <NL> a = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> s , e = get_int_multi ( ) <NEWLINE> a [ s ] . append ( e ) <NEWLINE> a [ e ] . append ( s ) <NEWLINE> <NL> <DEDENT> point = [ 0 ] * ( n + 1 ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = get_int_multi ( ) <NEWLINE> point [ p ] += x <NEWLINE> <NL> <DEDENT> def tasu ( now , prev ) : <NEWLINE> <INDENT> for next in a [ now ] : <NEWLINE> <INDENT> if next == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> point [ next ] += point [ now ] <NEWLINE> tasu ( next , now ) <NEWLINE> <NL> <DEDENT> <DEDENT> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> tasu ( 1 , - 1 ) <NEWLINE> point = point [ 1 : ] <COMMENT> <NEWLINE> print ( * point ) <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <DEDENT>
from sys import stdin <NEWLINE> <NL> <NL> n = int ( stdin . readline ( ) . strip ( ) ) <NEWLINE> a_lst = [ int ( x ) for x in stdin . readline ( ) . strip ( ) . split ( ) ] <NEWLINE> <NL> pos = len ( a_lst ) // 2 <NEWLINE> min_diff = 10000000000000000000 <NEWLINE> <NL> while ( True ) : <NEWLINE> <INDENT> left = sum ( a_lst [ : pos ] ) <NEWLINE> right = sum ( a_lst [ pos : ] ) <NEWLINE> diff = right - left <NEWLINE> <NL> if min_diff > abs ( diff ) : min_diff = abs ( diff ) <NEWLINE> else : break <NEWLINE> <NL> if diff > 0 : pos += 1 <NEWLINE> elif diff < 0 : pos -= 1 <NEWLINE> <NL> <DEDENT> print ( min_diff ) <NEWLINE>
<STRING> <NEWLINE> def main ( ) : <NEWLINE> <INDENT> import copy <NEWLINE> import sys <NEWLINE> pin = sys . stdin . readline <NEWLINE> pout = sys . stdout . write <NEWLINE> perr = sys . stderr . write <NEWLINE> <NL> N = int ( pin ( ) ) <NEWLINE> X = list ( map ( int , pin ( ) . split ( ) ) ) <NEWLINE> t = ( N + 1 ) // 2 <NEWLINE> Y = sorted ( X ) <NEWLINE> ans1 = Y [ t - 1 ] <NEWLINE> ans2 = Y [ t ] <NEWLINE> median = ans1 + ans2 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = X [ i ] <NEWLINE> if s == ans1 : <NEWLINE> <INDENT> print ( ans2 ) <NEWLINE> <DEDENT> elif s == ans2 : <NEWLINE> <INDENT> print ( ans1 ) <NEWLINE> <DEDENT> elif 2 * s < median : <NEWLINE> <INDENT> print ( ans2 ) <NEWLINE> <DEDENT> elif 2 * s > median : <NEWLINE> <INDENT> print ( ans1 ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> k -= 1 <NEWLINE> s = input ( ) <NEWLINE> print ( s [ : k ] + s [ k ] . lower ( ) + s [ k + 1 : ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ [ ] for _ in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> B [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> B . sort ( key = lambda x : - x [ 1 ] ) <NEWLINE> <NL> _A = [ ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> _A . extend ( [ B [ i ] [ 1 ] ] * B [ i ] [ 0 ] ) <NEWLINE> cnt += B [ i ] [ 0 ] <NEWLINE> if cnt > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> A += _A <NEWLINE> A . sort ( reverse = True ) <NEWLINE> print ( sum ( A [ : n ] ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> C = [ int ( input ( ) ) - 1 for _ in range ( N ) ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> latest_indices = [ - 1 ] * ( 2 * ( 10 ** 5 ) ) <NEWLINE> next_indices = [ - 1 ] * N <NEWLINE> for cur_index , c in enumerate ( C ) : <NEWLINE> <INDENT> latest_index = latest_indices [ c ] <NEWLINE> if latest_index >= 0 : <NEWLINE> <INDENT> next_indices [ latest_index ] = cur_index <NEWLINE> <DEDENT> latest_indices [ c ] = cur_index <NEWLINE> <DEDENT> dp = [ 0 ] * N <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for cur_index in range ( N - 1 ) : <NEWLINE> <INDENT> next_index = next_indices [ cur_index ] <NEWLINE> if next_index > cur_index + 1 : <NEWLINE> <INDENT> dp [ next_index ] += dp [ cur_index ] <NEWLINE> dp [ next_index ] %= MOD <NEWLINE> <DEDENT> dp [ cur_index + 1 ] += dp [ cur_index ] <NEWLINE> dp [ cur_index + 1 ] %= MOD <NEWLINE> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 200000 ) <NEWLINE> <NL> def dp_func ( n , dp , h ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> return dp [ 1 ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if dp [ n - 1 ] == - 1 : <NEWLINE> <INDENT> dp [ n - 1 ] = dp_func ( n - 1 , dp , h ) <NEWLINE> <NL> <DEDENT> c1 = dp [ n - 1 ] + abs ( h [ n ] - h [ n - 1 ] ) <NEWLINE> <NL> if dp [ n - 2 ] == - 1 : <NEWLINE> <INDENT> dp [ n - 2 ] = dp_func ( n - 2 , dp , h ) <NEWLINE> <NL> <DEDENT> c2 = dp [ n - 2 ] + abs ( h [ n ] - h [ n - 2 ] ) <NEWLINE> <NL> dp [ n ] = min ( c1 , c2 ) <NEWLINE> return dp [ n ] <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> dp = [ - 1 for n in range ( N ) ] <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> <NL> return dp_func ( N - 1 , dp , h ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import numpy as np <NEWLINE> <NL> f_inf = float ( <STRING> ) <NEWLINE> dp = [ f_inf ] * N <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <COMMENT> <NL> h = np . array ( h ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 1 , N ) : <NEWLINE> <COMMENT> <NL> <INDENT> start = max ( 0 , i - K ) <NEWLINE> <COMMENT> <NL> dp [ i ] = min ( dp [ start : i ] + np . abs ( h [ i ] - h [ start : i ] ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> count = 1 <NEWLINE> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> for n in range ( 2 , 10 ) : <NEWLINE> <INDENT> if i ** n <= x : <NEWLINE> <INDENT> count = max ( i ** n , count ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( A ) <NEWLINE> res = list ( np . cumsum ( a ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> idx = 1 <NEWLINE> for i in range ( len ( res ) ) : <NEWLINE> <INDENT> num = res [ i ] <NEWLINE> if ( idx <= i ) : <NEWLINE> <INDENT> idx = i + 1 <NEWLINE> <DEDENT> while ( num * 2 >= a [ idx ] ) : <NEWLINE> <INDENT> num += a [ idx ] <NEWLINE> idx += 1 <NEWLINE> <NL> if ( idx >= len ( res ) - 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( idx >= len ( res ) - 1 ) : <NEWLINE> <INDENT> print ( N - i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> res = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> res = res * i <NEWLINE> res = res % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> name = [ 0 ] * 5 <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> st = input ( ) <NEWLINE> if st [ 0 ] == <STRING> : <NEWLINE> <INDENT> name [ 0 ] += 1 <NEWLINE> <DEDENT> elif st [ 0 ] == <STRING> : <NEWLINE> <INDENT> name [ 1 ] += 1 <NEWLINE> <DEDENT> elif st [ 0 ] == <STRING> : <NEWLINE> <INDENT> name [ 2 ] += 1 <NEWLINE> <DEDENT> elif st [ 0 ] == <STRING> : <NEWLINE> <INDENT> name [ 3 ] += 1 <NEWLINE> <DEDENT> elif st [ 0 ] == <STRING> : <NEWLINE> <INDENT> name [ 4 ] += 1 <NEWLINE> <DEDENT> s . append ( st ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for v in itertools . combinations ( name , 3 ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += v [ 0 ] * v [ 1 ] * v [ 2 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = 1 <NEWLINE> if a [ 0 ] != <STRING> : <NEWLINE> <INDENT> print ( a [ 0 ] ) <NEWLINE> <DEDENT> if a [ 0 ] == <STRING> : <NEWLINE> <INDENT> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> if a [ i ] == <STRING> and a [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if c >= b : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ c ] ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> bc = sorted ( [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> i = 0 <NEWLINE> for b , c in bc : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> if i < n and a [ i ] < c : <NEWLINE> <INDENT> a [ i ] = c <NEWLINE> b -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> def ii ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def mi ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def li2 ( N ) : return [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> def dp2 ( ini , i , j ) : return [ [ ini ] * i for _ in range ( j ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N , M = mi ( ) <NEWLINE> Q = li2 ( M ) <NEWLINE> <COMMENT> <NL> <NL> l = [ N ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> ind = max ( 0 , Q [ i ] [ 0 ] - 1 ) <NEWLINE> l [ ind ] = min ( Q [ i ] [ 1 ] - 1 , l [ ind ] ) <NEWLINE> <NL> <DEDENT> for i in reversed ( range ( N - 1 ) ) : <NEWLINE> <INDENT> l [ i ] = min ( l [ i ] , l [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> i = 0 <NEWLINE> <COMMENT> <NL> while True : <NEWLINE> <INDENT> i = l [ i ] <NEWLINE> cnt += 1 <NEWLINE> if l [ i ] == N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cost = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if a [ i ] < x : <NEWLINE> <INDENT> cost += 1 <NEWLINE> <DEDENT> <DEDENT> print ( min ( cost , m - cost ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( len ( [ i for i in range ( n ) if h [ i ] >= k ] ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * ( N ) <NEWLINE> dp [ 1 ] = abs ( h [ 0 ] - h [ 1 ] ) <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ j ] + abs ( h [ j ] - h [ i ] ) for j in range ( max ( 0 , i - K ) , i ) ) <NEWLINE> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = [ 0 ] * 26 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> cnt [ ord ( a [ j ] ) - ord ( <STRING> ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> if h % 2 == 1 and w % 2 == 1 : <NEWLINE> <INDENT> f = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> if cnt [ i ] % 2 == 1 : <NEWLINE> <INDENT> cnt [ i ] -= 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> four = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> if cnt [ i ] >= 4 : <NEWLINE> <INDENT> four += cnt [ i ] // 4 * 4 <NEWLINE> <DEDENT> elif cnt [ i ] % 2 == 1 : <NEWLINE> <INDENT> f = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if four >= h * w - ( h // 2 + w // 2 ) * 2 - 1 and f == 0 : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = 0 <NEWLINE> <DEDENT> <DEDENT> elif h % 2 == 0 and w % 2 == 0 : <NEWLINE> <INDENT> f = 1 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> if cnt [ i ] % 4 != 0 : <NEWLINE> <INDENT> f = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if h % 2 == 0 : <NEWLINE> <INDENT> h , w = w , h <NEWLINE> <DEDENT> two = 0 ; f = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> if cnt [ i ] % 4 == 2 : <NEWLINE> <INDENT> two += 2 <NEWLINE> <DEDENT> elif cnt [ i ] % 2 == 1 : <NEWLINE> <INDENT> f = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if two <= w and f == 0 : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = 0 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if f else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> lis = [ ] <NEWLINE> def cnt ( n ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ret += i <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> lis . append ( sorted ( list ( input ( ) ) ) ) <NEWLINE> <DEDENT> co = 1 <NEWLINE> lis . sort ( ) <NEWLINE> bef = lis [ 0 ] <NEWLINE> <NL> for i in lis [ 1 : ] : <NEWLINE> <INDENT> if bef != i : <NEWLINE> <INDENT> ans += cnt ( co ) <NEWLINE> co = 1 <NEWLINE> bef = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> co += 1 <NEWLINE> <DEDENT> <DEDENT> ans += cnt ( co ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> num = max ( l ) <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> num = min ( num , i ) <NEWLINE> if num == i : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = [ 0 ] * 100002 <NEWLINE> for x in A : <NEWLINE> <INDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> C [ x + i ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( max ( C ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> la = [ int ( w ) for w in input ( ) . split ( ) ] <NEWLINE> <NL> cnt = [ 0 ] * 9 <NEWLINE> for a in la : <NEWLINE> <INDENT> if a > 3200 : <NEWLINE> <INDENT> a = 3200 <NEWLINE> <DEDENT> cnt [ a // 400 ] += 1 <NEWLINE> <NL> <DEDENT> mi = len ( [ _ for _ in cnt [ : 8 ] if _ > 0 ] ) <NEWLINE> ma = mi + cnt [ 8 ] <NEWLINE> <NL> if mi == 0 : <NEWLINE> <INDENT> mi = 1 <NEWLINE> <NL> <DEDENT> print ( mi , ma ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> <NL> dist1 = a [ 2 ] - a [ 0 ] <NEWLINE> dist2 = a [ 2 ] - a [ 1 ] <NEWLINE> <NL> if ( dist1 % 2 ) == 0 and ( dist2 % 2 ) == 0 : <NEWLINE> <INDENT> ans = ( dist1 + dist2 ) // 2 <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> elif ( dist1 % 2 ) == 1 and ( dist2 % 2 ) == 1 : <NEWLINE> <INDENT> ans = ( dist1 + dist2 ) // 2 <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> elif ( dist1 % 2 ) == 0 and ( dist2 % 2 ) == 1 : <NEWLINE> <INDENT> ans = ( dist1 // 2 ) + ( dist2 + 1 ) // 2 <NEWLINE> print ( ans + 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = ( dist2 // 2 ) + ( dist1 + 1 ) // 2 <NEWLINE> print ( ans + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( enumerate ( a ) ) <NEWLINE> c = sorted ( b , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> <NL> print ( * [ c [ i ] [ 0 ] + 1 for i in range ( n ) ] ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> from heapq import heappop , heappush <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> EPS = 1e-8 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def run ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> dic = set ( ) <NEWLINE> pos = defaultdict ( lambda : [ ] ) <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> heappush ( pos [ s ] , S [ i : ] ) <NEWLINE> <DEDENT> base = <STRING> <NEWLINE> <NL> for l in base : <NEWLINE> <INDENT> while pos [ l ] : <NEWLINE> <INDENT> sub = heappop ( pos [ l ] ) <NEWLINE> for i in range ( 1 , len ( sub ) + 1 ) : <NEWLINE> <INDENT> dic . add ( sub [ : i ] ) <NEWLINE> <NL> <DEDENT> if len ( dic ) >= K : <NEWLINE> <INDENT> dic = sorted ( list ( dic ) ) <NEWLINE> print ( dic [ K - 1 ] ) <NEWLINE> return <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> Q = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> Q . append ( [ b , c ] ) <NEWLINE> <NL> <DEDENT> Q = sorted ( Q , key = lambda x : x [ 1 ] , reverse = 1 ) <NEWLINE> kae = 0 <NEWLINE> <NL> d = [ - 1 ] * ( n ) <NEWLINE> now = 0 <NEWLINE> for l in Q : <NEWLINE> <INDENT> b , c = l <NEWLINE> if n - now < b : <NEWLINE> <INDENT> d [ now : ] = [ c ] * ( n - now ) <NEWLINE> break <NEWLINE> <DEDENT> d [ now : now + b ] = [ c ] * b <NEWLINE> now += b <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = sum ( A ) <NEWLINE> now = ans <NEWLINE> for kae in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> now += d [ kae - 1 ] <NEWLINE> now -= A [ kae - 1 ] <NEWLINE> ans = max ( ans , now ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = <STRING> + input ( ) + <STRING> <NEWLINE> td = [ input ( ) . split ( ) for _ in [ 0 ] * q ] <NEWLINE> def test ( x ) : <NEWLINE> <INDENT> for t , d in td : <NEWLINE> <INDENT> if s [ x ] == t : x += 1 if d == <STRING> else - 1 <NEWLINE> <DEDENT> return x <NEWLINE> <DEDENT> def bs ( b , g , t ) : <NEWLINE> <INDENT> while abs ( b - g ) > 1 : <NEWLINE> <INDENT> k = ( b + g ) // 2 <NEWLINE> if test ( k ) == t : g = k <NEWLINE> else : b = k <NEWLINE> <DEDENT> return g <NEWLINE> <DEDENT> l = bs ( n + 1 , 0 , 0 ) <NEWLINE> r = bs ( 0 , n + 1 , n + 1 ) <NEWLINE> print ( r - l - 1 ) <NEWLINE>
from collections import Counter <NEWLINE> from functools import lru_cache <NEWLINE> from math import gcd <NEWLINE> <NL> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def get_dividers ( n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> dividers = { i for i in range ( 1 , int ( n ** 0.5 ) + 1 ) if n % i == 0 } <NEWLINE> return dividers | { n // d for d in dividers } <NEWLINE> <NL> <NL> <DEDENT> @ lru_cache ( maxsize = None ) <NEWLINE> def lcm ( a , b ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> return a * b // gcd ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> counter = Counter ( ) <NEWLINE> for a in A : <NEWLINE> <INDENT> counter . update ( get_dividers ( a ) ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> candidates = [ ] <NEWLINE> for key , value in counter . items ( ) : <NEWLINE> <INDENT> if value == N : <NEWLINE> <INDENT> ans = lcm ( ans , key ) <NEWLINE> <DEDENT> elif value == N - 1 : <NEWLINE> <INDENT> candidates . append ( key ) <NEWLINE> <NL> <DEDENT> <DEDENT> if candidates : <NEWLINE> <INDENT> ans = max ( [ lcm ( ans , c ) for c in candidates ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<STRING> <NEWLINE> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> pin = sys . stdin . readline <NEWLINE> pout = sys . stdout . write <NEWLINE> perr = sys . stderr . write <NEWLINE> <NL> N = int ( pin ( ) ) <NEWLINE> P = list ( map ( int , pin ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> m = P [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if m >= P [ i ] : <NEWLINE> <INDENT> m = P [ i ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> from bisect import bisect_right <NEWLINE> <NL> n , * L = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> L . sort ( ) <NEWLINE> ans = 0 <NEWLINE> c = [ 0 ] * ( 2 * 10 ** 3 + 1 ) <NEWLINE> for i in range ( 2 * 10 ** 3 + 1 ) : <NEWLINE> <INDENT> c [ i ] = bisect_right ( L , i ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> ans += c [ L [ i ] + L [ j ] - 1 ] - c [ L [ j ] - L [ i ] ] - 1 - ( L [ j ] - L [ i ] * 2 < 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans // 3 ) <NEWLINE>
from bisect import bisect_left <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <COMMENT> <NL> k = [ [ ] for i in range ( n ) ] <NEWLINE> for j , h in l : <NEWLINE> <INDENT> k [ j - 1 ] . append ( h ) <NEWLINE> <DEDENT> k_so = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = k [ i ] <NEWLINE> k_so [ i ] = sorted ( a ) <NEWLINE> <COMMENT> <NL> <DEDENT> for j , h in l : <NEWLINE> <INDENT> first = <STRING> . format ( j ) <NEWLINE> t = bisect_left ( k_so [ j - 1 ] , h ) <NEWLINE> second = <STRING> . format ( t + 1 ) <NEWLINE> print ( first + second ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> x = int ( N ** 0.5 ) + 1 <NEWLINE> ans_1 = N <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> if N % x == 0 : <NEWLINE> <INDENT> ans_1 = x <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans_2 = N // ans_1 <NEWLINE> print ( ans_1 + ans_2 - 2 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> pp = [ 0 ] * n <NEWLINE> res = 0 <NEWLINE> <NL> qq = [ True ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> i , j = input ( ) . split ( ) <NEWLINE> i = int ( i ) <NEWLINE> i -= 1 <NEWLINE> if j == <STRING> : <NEWLINE> <INDENT> if qq [ i ] : <NEWLINE> <INDENT> qq [ i ] = False <NEWLINE> res += pp [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pp [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( qq . count ( False ) , res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] -= i + 1 <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> total = sum ( A ) <NEWLINE> mean1 = total // N <NEWLINE> mean2 = total // N + 1 <NEWLINE> med1 = A [ N // 2 ] <NEWLINE> <COMMENT> <NL> ans1 = 0 <NEWLINE> ans2 = 0 <NEWLINE> ans3 = 0 <NEWLINE> ans4 = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans1 += abs ( a - mean1 ) <NEWLINE> ans2 += abs ( a - mean2 ) <NEWLINE> ans3 += abs ( a - med1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( min ( [ ans1 , ans2 , ans3 ] ) ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if X [ i ] >= 0 : <NEWLINE> <INDENT> ori = i <NEWLINE> X . insert ( ori , 0 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ori = n <NEWLINE> X . insert ( ori , 0 ) <NEWLINE> <NL> <DEDENT> res = f_inf <NEWLINE> start = max ( 0 , ori - k ) <NEWLINE> end = min ( n - k + 1 , ori + 1 ) <NEWLINE> for j in range ( start , end ) : <NEWLINE> <INDENT> left = abs ( X [ j ] ) * 2 + abs ( X [ j + k ] ) <NEWLINE> right = abs ( X [ j ] ) + abs ( X [ j + k ] ) * 2 <NEWLINE> res = min ( res , min ( left , right ) ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> S = list ( input ( ) ) <NEWLINE> n = len ( S ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> right_flag = False <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if s == <STRING> and right_flag is False : <NEWLINE> <INDENT> right_index = i <NEWLINE> right_flag = True <NEWLINE> <DEDENT> elif s == <STRING> and right_flag : <NEWLINE> <INDENT> right_flag = False <NEWLINE> cnt = i - right_index <NEWLINE> odd = cnt // 2 <NEWLINE> even = cnt - odd <NEWLINE> ans [ i - 1 ] += even <NEWLINE> ans [ i ] += odd <NEWLINE> <DEDENT> <DEDENT> left_flag = False <NEWLINE> for i , s in enumerate ( S [ : : - 1 ] , 1 ) : <NEWLINE> <INDENT> if s == <STRING> and left_flag is False : <NEWLINE> <INDENT> left_index = i <NEWLINE> left_flag = True <NEWLINE> <DEDENT> elif s == <STRING> and left_flag : <NEWLINE> <INDENT> left_flag = False <NEWLINE> cnt = i - left_index <NEWLINE> odd = cnt // 2 <NEWLINE> even = cnt - odd <NEWLINE> ans [ - i + 1 ] += even <NEWLINE> ans [ - i ] += odd <NEWLINE> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif ord ( <STRING> ) - ord ( s ) + 1 <= K : <NEWLINE> <INDENT> S [ i ] = <STRING> <NEWLINE> K -= ord ( <STRING> ) - ord ( s ) + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> K %= 26 <NEWLINE> S [ - 1 ] = chr ( ( ord ( S [ - 1 ] ) - ord ( <STRING> ) + K ) % 26 + ord ( <STRING> ) ) <NEWLINE> <NL> print ( <STRING> . join ( S ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> a = s . find ( str ( i ) ) <NEWLINE> if a == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> b = s . find ( str ( j ) , a + 1 ) <NEWLINE> if b == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> if s . find ( str ( k ) , b + 1 ) != - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : return a <NEWLINE> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> T = [ ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( input ( ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> T . append ( t ) <NEWLINE> if i == 0 : continue <NEWLINE> elif i == 1 : <NEWLINE> <INDENT> lcm = T [ - 2 ] * T [ - 1 ] // gcd ( T [ - 2 ] , T [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lcm = lcm * T [ - 1 ] // gcd ( lcm , T [ - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( lcm ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> l = a + b <NEWLINE> r = c + d <NEWLINE> if l > r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif l < r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x , y = 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dif = b [ i ] - a [ i ] <NEWLINE> if dif > 0 : <NEWLINE> <INDENT> x += dif // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y += - dif <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> if x >= y else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = n * ( n - 1 ) // 2 <NEWLINE> <NL> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> m = len ( n ) <NEWLINE> n = int ( n ) <NEWLINE> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if m == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> ans_plus = n // ( 2 * 5 ** i ) <NEWLINE> if ans_plus == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += ans_plus <NEWLINE> <NL> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
n , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> times = [ 0 ] * ( n + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> times [ i ] += 1 <NEWLINE> <DEDENT> times . sort ( ) <NEWLINE> <NL> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if times [ i ] != 0 : <NEWLINE> <INDENT> j = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> if len ( times ) > k - j : <NEWLINE> <INDENT> for i in range ( j , len ( times ) - k ) : <NEWLINE> <INDENT> ans += times [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] == i + 1 : <NEWLINE> <INDENT> A [ i ] , A [ i + 1 ] = A [ i + 1 ] , A [ i ] <NEWLINE> cnt += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> if A [ N - 1 ] == N : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
def check ( l , r ) : <NEWLINE> <INDENT> th = 1 + ( r - l + 1 ) // 2 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> if cnt [ i ] >= th : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> si = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> si [ i ] = ord ( s [ i ] ) - 97 <NEWLINE> <NL> <DEDENT> l , r = 0 , 1 <NEWLINE> cnt = [ 0 ] * 26 <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> cnt [ si [ i ] ] += 1 <NEWLINE> <DEDENT> while l < n - 1 and r < n : <NEWLINE> <INDENT> if check ( l , r ) : <NEWLINE> <INDENT> print ( l + 1 , r + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif max ( cnt ) == 1 + ( r - l + 1 ) // 2 or r - l == 1 : <NEWLINE> <INDENT> r += 1 <NEWLINE> if r < n : <NEWLINE> <INDENT> cnt [ si [ r ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt [ si [ l ] ] -= 1 <NEWLINE> l += 1 <NEWLINE> <DEDENT> <DEDENT> print ( - 1 , - 1 ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> def DFS ( h , w , black , white , m ) : <NEWLINE> <INDENT> black , white = BorW ( h , w , black , white ) <NEWLINE> step = [ [ 0 , 1 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ - 1 , 0 ] ] <NEWLINE> seen [ h ] [ w ] = 1 <NEWLINE> for dh , dw in step : <NEWLINE> <INDENT> nh = h + dh <NEWLINE> nw = w + dw <NEWLINE> if 0 <= nh < H and 0 <= nw < W : <NEWLINE> <INDENT> if seen [ nh ] [ nw ] == 0 and m != S [ nh ] [ nw ] : <NEWLINE> <INDENT> seen [ nh ] [ nw ] = 1 <NEWLINE> black , white = DFS ( nh , nw , black , white , S [ nh ] [ nw ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return black , white <NEWLINE> <NL> <NL> <DEDENT> def BorW ( h , w , black , white ) : <NEWLINE> <INDENT> if S [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> black += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> white += 1 <NEWLINE> <DEDENT> return black , white <NEWLINE> <NL> <NL> <DEDENT> seen = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> <NL> L = [ ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> black = 0 <NEWLINE> white = 0 <NEWLINE> if seen [ h ] [ w ] == 0 : <NEWLINE> <INDENT> black , white = DFS ( h , w , black , white , S [ h ] [ w ] ) <NEWLINE> L . append ( [ black , white ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for b , w in L : <NEWLINE> <INDENT> ans += b * w <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Y = sorted ( X ) <NEWLINE> Y1 = Y [ : N // 2 ] <NEWLINE> Y2 = Y [ N // 2 : ] <NEWLINE> ans1 = Y1 [ - 1 ] <NEWLINE> ans2 = Y2 [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] <= ans1 : <NEWLINE> <INDENT> print ( ans2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans1 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> numOfEdges = [ 0 for _ in range ( N ) ] <NEWLINE> visited = [ 0 for _ in range ( N ) ] <NEWLINE> edges = defaultdict ( int ) <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 ; <NEWLINE> numOfEdges [ a ] += 1 <NEWLINE> numOfEdges [ b ] += 1 <NEWLINE> edges [ ( a , b ) ] = 0 <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> def dfs ( prev , now , col ) : <NEWLINE> <INDENT> if visited [ now ] : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> visited [ now ] = 1 <NEWLINE> i = 1 <NEWLINE> for adj in graph [ now ] : <NEWLINE> <INDENT> if adj == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if now < adj : <NEWLINE> <INDENT> edges [ ( now , adj ) ] = col + i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> edges [ ( adj , now ) ] = col + i <NEWLINE> <DEDENT> dfs ( now , adj , col + i ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( - 1 , 0 , 1 ) <NEWLINE> maxColor = max ( numOfEdges ) <NEWLINE> print ( maxColor ) <NEWLINE> <NL> for k , i in edges . items ( ) : <NEWLINE> <INDENT> e = i % maxColor <NEWLINE> if e : <NEWLINE> <INDENT> print ( e ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( maxColor ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> L = b * a ** 2 <NEWLINE> if L == x : <NEWLINE> <INDENT> alfa = 0 <NEWLINE> <DEDENT> elif x >= L / 2 : <NEWLINE> <INDENT> h = x / ( a ** 2 ) <NEWLINE> beta = math . atan ( ( a / 2 ) / ( b - h ) ) <NEWLINE> alfa = ( math . pi ) / 2 - beta <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> alfa = math . atan ( b / ( 2 * x / ( a * b ) ) ) <NEWLINE> <DEDENT> print ( math . degrees ( alfa ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] <NEWLINE> tmp = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> tmp += i <NEWLINE> B . append ( tmp ) <NEWLINE> <NL> <DEDENT> d = { } <NEWLINE> for i in B : <NEWLINE> <INDENT> i %= M <NEWLINE> if i not in d : <NEWLINE> <INDENT> d [ i ] = 0 <NEWLINE> <DEDENT> d [ i ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in d . values ( ) : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = A [ i ] <NEWLINE> ans += ( tmp // 2 ) <NEWLINE> if i < N - 1 and tmp % 2 and A [ i + 1 ] > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> A [ i + 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> seat = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> seat [ l - 1 ] += 1 <NEWLINE> seat [ r ] -= 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 10 ** 5 ) : <NEWLINE> <INDENT> seat [ i ] += seat [ i - 1 ] <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for i in range ( 10 ** 5 ) : <NEWLINE> <INDENT> if seat [ i ] == 1 : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> data1 = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> data2 = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> ans = [ ] <NEWLINE> trans = - 1 <NEWLINE> for i in range ( 2 ** 10 ) : <NEWLINE> <INDENT> S = [ 0 ] * n <NEWLINE> l = 0 <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> for k in range ( n ) : <NEWLINE> <INDENT> S [ k ] += data1 [ k ] [ j ] * ( ( i >> j ) & 1 ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> l += data2 [ j ] [ S [ j ] ] <NEWLINE> <DEDENT> ans . append ( l ) <NEWLINE> if not i : <NEWLINE> <INDENT> trans = l <NEWLINE> <DEDENT> <DEDENT> ans . sort ( ) <NEWLINE> print ( ans [ - 1 ] if ans [ - 1 ] != trans else ans [ - 2 ] ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> b_now = 1 <NEWLINE> loop = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> b_now = a [ b_now - 1 ] <NEWLINE> ans += 1 <NEWLINE> if b_now == 2 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
s = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> seq = set ( ) <NEWLINE> l = len ( s ) <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> seq . add ( s [ i : i + j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> seq = list ( seq ) <NEWLINE> seq . sort ( ) <NEWLINE> print ( seq [ K - 1 ] ) <NEWLINE>
def calc ( n ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 2 ** ( n - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def normailze ( s , n ) : <NEWLINE> <INDENT> return ( n - len ( s ) ) * <STRING> + s <NEWLINE> <NL> <NL> <DEDENT> def solution ( s ) : <NEWLINE> <INDENT> a = calc ( len ( s ) ) <NEWLINE> cnt = 0 <NEWLINE> n = len ( s ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> return int ( s ) <NEWLINE> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> binary = normailze ( bin ( i ) [ 2 : ] , n - 1 ) <NEWLINE> b = s [ 0 ] <NEWLINE> f = 1 <NEWLINE> for j in binary : <NEWLINE> <INDENT> if int ( j ) == 1 : <NEWLINE> <INDENT> cnt += int ( b ) <NEWLINE> b = s [ f ] <NEWLINE> f += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += s [ f ] <NEWLINE> f += 1 <NEWLINE> <DEDENT> <DEDENT> cnt += int ( b ) <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> print ( solution ( input ( ) ) ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> if x + y <= S : <NEWLINE> <INDENT> if K >= S - x - y : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( lines [ 0 ] ) <NEWLINE> values = list ( map ( int , lines [ 1 ] . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> result = get_cnt ( values ) <NEWLINE> <NL> return [ result ] <NEWLINE> <NL> <NL> <DEDENT> def get_cnt ( values ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ret = 0 <NEWLINE> mi = min ( values ) <NEWLINE> <COMMENT> <NL> ret += mi <NEWLINE> values = [ value - mi for value in values ] <NEWLINE> <COMMENT> <NL> lst = None <NEWLINE> for value in values : <NEWLINE> <COMMENT> <NL> <INDENT> if value != 0 : <NEWLINE> <INDENT> if lst is None : <NEWLINE> <INDENT> lst = [ value ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst . append ( value ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if lst is None : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret += get_cnt ( lst ) <NEWLINE> lst = None <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if lst is not None : <NEWLINE> <INDENT> ret += get_cnt ( lst ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def func_f ( n ) : <NEWLINE> <INDENT> if n % 2 == 0 : <NEWLINE> <INDENT> return int ( n / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 3 * n + 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> ] <NEWLINE> lines_export = [ 2 ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> ] <NEWLINE> lines_export = [ 5 ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> ] <NEWLINE> lines_export = [ 221 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if a [ a [ i ] - 1 ] - 1 == i : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c // 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> B = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> B . append ( 0 ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> taosukazu1 = min ( A [ i ] , B [ i ] ) <NEWLINE> B [ i ] -= taosukazu1 <NEWLINE> A [ i ] -= taosukazu1 <NEWLINE> ans += taosukazu1 <NEWLINE> if B [ i ] > 0 : <NEWLINE> <INDENT> taosukazu2 = min ( A [ i + 1 ] , B [ i ] ) <NEWLINE> B [ i ] -= taosukazu2 <NEWLINE> A [ i + 1 ] -= taosukazu2 <NEWLINE> ans += taosukazu2 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> import itertools <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> c . sort ( ) <NEWLINE> bc = [ ] <NEWLINE> ans = 0 <NEWLINE> count = 0 <NEWLINE> <NL> <NL> for i in b : <NEWLINE> <INDENT> indc = bisect . bisect_right ( c , i ) <NEWLINE> bc . append ( ( n - indc ) ) <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> BC = [ 0 ] + list ( itertools . accumulate ( bc ) ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> indb = bisect . bisect_right ( b , i ) <NEWLINE> ans += BC [ - 1 ] - BC [ indb ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = max ( a ) <NEWLINE> m = x / 2 <NEWLINE> a . remove ( x ) <NEWLINE> a . sort ( ) <NEWLINE> ans = x <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> y = abs ( i - m ) <NEWLINE> if ans >= y : <NEWLINE> <INDENT> ans = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> z = i <NEWLINE> <NL> <DEDENT> print ( x , z ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> sum_a = sum ( a ) <NEWLINE> ans = 10 ** 11 <NEWLINE> x = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x += a [ i ] <NEWLINE> diff = abs ( sum_a - 2 * x ) <NEWLINE> if diff < ans : <NEWLINE> <INDENT> ans = diff <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , M = ( int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ) <NEWLINE> As = [ int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ] <NEWLINE> As = sorted ( As , reverse = True ) <NEWLINE> rest = M <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> if rest == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> d = As [ 0 ] <NEWLINE> b = d // 2 - d // 4 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = As [ i ] <NEWLINE> check = 0 <NEWLINE> if a - a // 2 < b : <NEWLINE> <INDENT> if rest > i : <NEWLINE> <INDENT> ad = [ x // 2 for x in As [ : i ] ] <NEWLINE> As = As [ i : ] <NEWLINE> As . extend ( ad ) <NEWLINE> rest -= i <NEWLINE> check += 1 <NEWLINE> As = sorted ( As , reverse = True ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ad = [ x // 2 for x in As [ : rest ] ] <NEWLINE> As = As [ rest : ] <NEWLINE> As . extend ( ad ) <NEWLINE> check += 1 <NEWLINE> rest = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if i == N - 1 : <NEWLINE> <INDENT> if check == 0 : <NEWLINE> <INDENT> if rest > N : <NEWLINE> <INDENT> As = [ x // 2 for x in As ] <NEWLINE> rest -= N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ad = [ x // 2 for x in As [ : rest ] ] <NEWLINE> As = As [ rest : ] <NEWLINE> As . extend ( ad ) <NEWLINE> rest = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ( As ) ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> c = L [ i ] + L [ j ] <NEWLINE> <COMMENT> <NL> idx = bisect_left ( L , c ) <NEWLINE> ans += max ( 0 , idx - ( j + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> x = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> d = [ ] <NEWLINE> if n >= m or m == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif n < m : <NEWLINE> <INDENT> for i in range ( m - 1 ) : <NEWLINE> <INDENT> d . append ( x [ i + 1 ] - x [ i ] ) <NEWLINE> <DEDENT> print ( sum ( sorted ( d ) [ : m - n ] ) ) <NEWLINE> <DEDENT>
<NL> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A >= K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( A + B ) >= K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = [ 0 ] * 8 <NEWLINE> c = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a <= 399 : <NEWLINE> <INDENT> cnt [ 0 ] += 1 <NEWLINE> <DEDENT> elif a >= 400 and a <= 799 : <NEWLINE> <INDENT> cnt [ 1 ] += 1 <NEWLINE> <DEDENT> elif a >= 800 and a <= 1199 : <NEWLINE> <INDENT> cnt [ 2 ] += 1 <NEWLINE> <DEDENT> elif a >= 1200 and a <= 1599 : <NEWLINE> <INDENT> cnt [ 3 ] += 1 <NEWLINE> <DEDENT> elif a >= 1600 and a <= 1999 : <NEWLINE> <INDENT> cnt [ 4 ] += 1 <NEWLINE> <DEDENT> elif a >= 2000 and a <= 2399 : <NEWLINE> <INDENT> cnt [ 5 ] += 1 <NEWLINE> <DEDENT> elif a >= 2400 and a <= 2799 : <NEWLINE> <INDENT> cnt [ 6 ] += 1 <NEWLINE> <DEDENT> elif a >= 2800 and a <= 3199 : <NEWLINE> <INDENT> cnt [ 7 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> Min = len ( [ i for i in cnt if i != 0 ] ) <NEWLINE> if c == 0 : <NEWLINE> <INDENT> print ( Min , Min ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Max = Min + c <NEWLINE> if Min == 0 : <NEWLINE> <INDENT> print ( 1 , Max ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Min , Max ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> num = 0 <NEWLINE> result = [ 0 ] <NEWLINE> <NL> <NL> for c in S : <NEWLINE> <INDENT> if c == <STRING> or c == <STRING> or c == <STRING> or c == <STRING> : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( num ) <NEWLINE> num = 0 <NEWLINE> <DEDENT> <DEDENT> result . append ( num ) <NEWLINE> <NL> <COMMENT> <NL> print ( max ( result ) ) <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> def solve ( A , N ) : <NEWLINE> <INDENT> mod = 10 ** 9 + 7 <NEWLINE> C = [ 0 ] * 60 <NEWLINE> for a in A : <NEWLINE> <INDENT> for i in range ( 60 ) : <NEWLINE> <INDENT> if a >> i & 1 : <NEWLINE> <INDENT> C [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i , c in enumerate ( C ) : <NEWLINE> <INDENT> ans += ( 1 << i ) % mod * c % mod * ( N - c ) % mod <NEWLINE> <DEDENT> return ans % mod <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> numba_config = [ <NEWLINE> <INDENT> [ solve , <STRING> ] , <NEWLINE> <DEDENT> ] <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba import njit <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> vars ( ) [ func . __name__ ] = njit ( signature ) ( func ) <NEWLINE> cc . export ( func . __name__ , signature ) ( func ) <NEWLINE> <DEDENT> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif os . name == <STRING> : <NEWLINE> <INDENT> exec ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> vars ( ) [ func . __name__ ] = njit ( signature , cache = True ) ( func ) <NEWLINE> <DEDENT> print ( <STRING> , file = sys . stderr ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> print ( solve ( A , N ) ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , numpy , string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> sl = list ( S ) <NEWLINE> setS = set ( S ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> if str ( i ) not in setS : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i100_ind = sl . index ( str ( i ) ) <NEWLINE> S10 = sl [ i100_ind + 1 : - 1 ] <NEWLINE> S10set = set ( S10 ) <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> if str ( j ) not in S10set : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i10_ind = S10 . index ( str ( j ) ) <NEWLINE> S1 = S10 [ i10_ind + 1 : ] <NEWLINE> S1 . append ( sl [ - 1 ] ) <NEWLINE> ans += len ( set ( S1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ 0 ] * N <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> l [ a - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> for x in l : <NEWLINE> <INDENT> print ( x , end = <STRING> ) <NEWLINE> <DEDENT>
H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> magic = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> dp = [ 0 for _ in range ( 10 ** 5 ) ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + b for a , b in magic ) <NEWLINE> <NL> <DEDENT> print ( dp [ H - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> power = 1 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> power = power * i % mod <NEWLINE> <NL> <DEDENT> print ( power ) <NEWLINE>
def have_ABC_string ( n , str ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if str [ i ] == <STRING> and str [ i + 1 ] == <STRING> and str [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> result = have_ABC_string ( N , S ) <NEWLINE> print ( result ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> prime_list = [ ] <NEWLINE> <COMMENT> <NL> search_list = list ( range ( 2 , n + 1 ) ) <NEWLINE> while True : <NEWLINE> <COMMENT> <NL> <INDENT> if search_list [ 0 ] > math . sqrt ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> prime_list . extend ( search_list ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> head_num = search_list [ 0 ] <NEWLINE> prime_list . append ( head_num ) <NEWLINE> <COMMENT> <NL> search_list . pop ( 0 ) <NEWLINE> <COMMENT> <NL> search_list = [ num for num in search_list if num % head_num != 0 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for x in prime_list : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> nl = 1 <NEWLINE> while ( x ** nl <= n ) : <NEWLINE> <INDENT> tmp += n // ( x ** nl ) <NEWLINE> nl += 1 <NEWLINE> <DEDENT> ans *= tmp + 1 <NEWLINE> <DEDENT> if ans >= 10 ** 9 + 7 : <NEWLINE> <INDENT> ans %= ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> res = 1 <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> j = i <NEWLINE> if j % 2 == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> while j % 2 == 0 : <NEWLINE> <INDENT> j //= 2 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if ans < cnt : <NEWLINE> <INDENT> res = i <NEWLINE> ans = cnt <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( a ) <NEWLINE> ans = 0 <NEWLINE> <NL> for k , v in c . items ( ) : <NEWLINE> <INDENT> if k > v : <NEWLINE> <INDENT> ans += v <NEWLINE> <DEDENT> if k < v : <NEWLINE> <INDENT> ans += v - k <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> Li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Li . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> a = Li [ i ] + Li [ j ] <NEWLINE> t = bisect . bisect_left ( Li , a ) <NEWLINE> ans += t - ( j + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> dp = [ [ 0 ] * 2 for _ in range ( n ) ] <NEWLINE> dp [ 0 ] = [ 1 , 0 ] <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i + 1 < n : <NEWLINE> <INDENT> dp [ i + 1 ] [ 0 ] = max ( dp [ i + 1 ] [ 1 ] , dp [ i ] [ 1 ] + 1 ) <NEWLINE> if s [ i ] != s [ i + 1 ] : <NEWLINE> <INDENT> dp [ i + 1 ] [ 0 ] = max ( dp [ i + 1 ] [ 0 ] , dp [ i ] [ 0 ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> if i + 2 < n : <NEWLINE> <INDENT> dp [ i + 2 ] [ 1 ] = max ( dp [ i + 2 ] [ 0 ] , dp [ i ] [ 0 ] + 1 ) <NEWLINE> if s [ i - 1 : i + 1 ] != s [ i + 1 : i + 3 ] : <NEWLINE> <INDENT> dp [ i + 2 ] [ 1 ] = max ( dp [ i + 2 ] [ 1 ] , dp [ i ] [ 1 ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( dp [ - 1 ] ) ) <NEWLINE>
def remain ( pos , length ) : <NEWLINE> <INDENT> p = pos <NEWLINE> for c , d in moves : <NEWLINE> <INDENT> if s [ p ] == c : <NEWLINE> <INDENT> if d == <STRING> : <NEWLINE> <INDENT> p -= 1 <NEWLINE> <DEDENT> if d == <STRING> : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> if p < 0 or p >= length : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> moves = [ list ( map ( str , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> l = - 1 <NEWLINE> r = n <NEWLINE> while r - l != 1 : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> if remain ( mid , n ) == True : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> <DEDENT> remain_left = r <NEWLINE> if remain_left == n : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> l = remain_left <NEWLINE> r = n <NEWLINE> while r - l != 1 : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> if remain ( mid , n ) == True : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> <DEDENT> remain_right = l <NEWLINE> print ( remain_right - remain_left + 1 ) <NEWLINE>
k , s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> m = s - i - j <NEWLINE> if ( 0 <= m <= k ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> <NL> graph = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> ans = [ 0 ] * ( n - 1 ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> graph [ ab [ i ] [ 0 ] ] . append ( ( ab [ i ] [ 1 ] , i ) ) <NEWLINE> graph [ ab [ i ] [ 1 ] ] . append ( ( ab [ i ] [ 0 ] , i ) ) <NEWLINE> <NL> <DEDENT> visit = [ False ] * ( n + 1 ) <NEWLINE> def dfs ( p , c ) : <NEWLINE> <INDENT> color = 1 <NEWLINE> visit [ p ] = True <NEWLINE> for n , i in graph [ p ] : <NEWLINE> <INDENT> if visit [ n ] == False : <NEWLINE> <INDENT> if color == c : <NEWLINE> <INDENT> color += 1 <NEWLINE> <DEDENT> ans [ i ] = color <NEWLINE> dfs ( n , color ) <NEWLINE> color += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 1 , 0 ) <NEWLINE> print ( max ( ans ) ) <NEWLINE> for t in ans : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = a [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = math . gcd ( a [ i ] , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from functools import reduce <NEWLINE> <NL> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def cmb ( n , r , m ) : <NEWLINE> <INDENT> def mul ( a , b ) : <NEWLINE> <INDENT> return a * b % m <NEWLINE> <NL> <DEDENT> r = min ( n - r , r ) <NEWLINE> if r == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> over = reduce ( mul , range ( n , n - r , - 1 ) ) <NEWLINE> under = reduce ( mul , range ( 1 , r + 1 ) ) <NEWLINE> return ( over * pow ( under , m - 2 , m ) ) % m <NEWLINE> <NL> <NL> <DEDENT> r = abs ( x - y ) <NEWLINE> l = ( min ( x , y ) - r ) // 3 <NEWLINE> r += l <NEWLINE> if l * 2 + r * 1 in ( x , y ) and l >= 0 : <NEWLINE> <INDENT> print ( cmb ( r + l , l , mod ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> s = list ( s ) <NEWLINE> import collections <NEWLINE> c = collections . Counter ( s ) <NEWLINE> values , counts = zip ( * c . most_common ( ) ) <NEWLINE> temp = list ( counts ) <NEWLINE> l = len ( temp ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> ans = ans * ( temp [ i ] + 1 ) <NEWLINE> <DEDENT> print ( ( ans - 1 ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
S = input ( ) <NEWLINE> x = len ( S ) <NEWLINE> c = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( x ) : <NEWLINE> <NL> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <NL> <INDENT> c += 1 <NEWLINE> <NL> ans += i + 1 - c <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> tmp = 0 <NEWLINE> asm = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp += A [ i ] <NEWLINE> asm += [ tmp ] <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if asm [ - i ] * 2 >= A [ - i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL>
li = [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 1 ] <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if li . index ( a ) == li . index ( b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif li . index ( a ) > li . index ( b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> l = [ ] <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> i = n - 1 <NEWLINE> while i >= 0 : <NEWLINE> <INDENT> l . append ( a [ i ] ) <NEWLINE> i -= 2 <NEWLINE> <NL> <DEDENT> j = 1 <NEWLINE> while j < n : <NEWLINE> <INDENT> l . append ( a [ j ] ) <NEWLINE> j += 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i = n - 1 <NEWLINE> while i >= 0 : <NEWLINE> <INDENT> l . append ( a [ i ] ) <NEWLINE> i -= 2 <NEWLINE> <NL> <DEDENT> j = 0 <NEWLINE> while j < n : <NEWLINE> <INDENT> l . append ( a [ j ] ) <NEWLINE> j += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , l ) ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( M ) ] <NEWLINE> n = 0 <NEWLINE> if M != 0 : <NEWLINE> <INDENT> a = b = A [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = b = - 2 <NEWLINE> <DEDENT> c = 0 <NEWLINE> ans = [ 0 , 1 ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i == a : <NEWLINE> <INDENT> c = 0 <NEWLINE> n += 1 <NEWLINE> b = a <NEWLINE> if n <= M - 1 : <NEWLINE> <INDENT> a = A [ n ] <NEWLINE> <DEDENT> <DEDENT> elif i - 2 == b : <NEWLINE> <INDENT> c = ans [ - 1 ] <NEWLINE> <DEDENT> elif i - 1 == b : <NEWLINE> <INDENT> c = ans [ - 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = ans [ - 1 ] + ans [ - 2 ] <NEWLINE> <DEDENT> c %= 10 ** 9 + 7 <NEWLINE> ans . append ( c ) <NEWLINE> <DEDENT> print ( ans [ - 1 ] ) <NEWLINE>
import sys <NEWLINE> def solve ( stns , idx , mem ) : <NEWLINE> <NL> <INDENT> if idx >= len ( stns ) - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> if idx in mem : <NEWLINE> <INDENT> return mem [ idx ] <NEWLINE> <NL> <DEDENT> if idx == len ( stns ) - 2 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> final_step = abs ( stns [ idx ] - stns [ idx + 1 ] ) <NEWLINE> mem [ idx ] = final_step <NEWLINE> return final_step <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> step1 = solve ( stns , idx + 1 , mem ) + abs ( stns [ idx ] - stns [ idx + 1 ] ) <NEWLINE> <COMMENT> <NL> step2 = solve ( stns , idx + 2 , mem ) + abs ( stns [ idx ] - stns [ idx + 2 ] ) <NEWLINE> <NL> min_cost = min ( step1 , step2 ) <NEWLINE> mem [ idx ] = min_cost <NEWLINE> <NL> return min_cost <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def take_input ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <INDENT> reader = ( s . rstrip ( ) for s in sys . stdin ) <NEWLINE> input = reader . __next__ <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> stns = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> mem = { } <NEWLINE> res = solve ( stns , 0 , mem ) <NEWLINE> print ( res ) <NEWLINE> <NL> <DEDENT> take_input ( ) <NEWLINE>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> lr = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> lr . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> a = [ [ 0 ] * n for i in range ( n ) ] <NEWLINE> for l , r in lr : <NEWLINE> <INDENT> a [ l - 1 ] [ r - 1 ] += 1 <NEWLINE> <NL> <DEDENT> cnt = [ [ 0 ] * n for i in range ( n ) ] <NEWLINE> for y in range ( n ) : <NEWLINE> <INDENT> v = 0 <NEWLINE> for x in range ( y , - 1 , - 1 ) : <NEWLINE> <INDENT> v += a [ x ] [ y ] <NEWLINE> cnt [ x ] [ y ] = cnt [ x ] [ y - 1 ] + v <NEWLINE> <NL> <DEDENT> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( cnt [ p - 1 ] [ q - 1 ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> E = [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> if i not in D : <NEWLINE> <INDENT> E . append ( i ) <NEWLINE> <DEDENT> <DEDENT> E = sorted ( E ) <NEWLINE> N = str ( N ) <NEWLINE> ind = len ( N ) <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> if int ( N [ i ] ) not in E : <NEWLINE> <INDENT> ind = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ind == len ( N ) : <NEWLINE> <INDENT> print ( N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = 0 <NEWLINE> x = <STRING> <NEWLINE> for i in range ( ind , - 1 , - 1 ) : <NEWLINE> <INDENT> n = int ( N [ i ] ) <NEWLINE> for e in E : <NEWLINE> <INDENT> if e > n : <NEWLINE> <INDENT> x = N [ : i ] + str ( e ) + str ( E [ 0 ] ) * ( len ( N ) - i - 1 ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : break <NEWLINE> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> if E [ 0 ] > 0 : <NEWLINE> <INDENT> a = E [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = E [ 1 ] <NEWLINE> <DEDENT> x = str ( a ) + str ( E [ 0 ] ) * len ( N ) <NEWLINE> <DEDENT> print ( x ) <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> c = A - K <NEWLINE> d = B <NEWLINE> <DEDENT> elif A == 0 and B >= K : <NEWLINE> <INDENT> c = 0 <NEWLINE> d = B - K <NEWLINE> <DEDENT> elif A + B <= K : <NEWLINE> <INDENT> c = 0 <NEWLINE> d = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = B - ( K - A ) <NEWLINE> c = 0 <NEWLINE> <DEDENT> print ( str ( c ) + <STRING> + str ( d ) ) <NEWLINE>
H , W , D = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( H ) ] <NEWLINE> <NL> x = [ 0 ] * ( H * W + 1 ) <NEWLINE> p = [ [ ] for _ in range ( H * W + 1 ) ] <NEWLINE> <NL> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> p [ A [ h ] [ w ] ] = [ h , w ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( D + 1 , H * W + 1 ) : <NEWLINE> <INDENT> x [ i ] = x [ i - D ] + abs ( p [ i ] [ 0 ] - p [ i - D ] [ 0 ] ) + abs ( p [ i ] [ 1 ] - p [ i - D ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( x [ r ] - x [ l ] ) <NEWLINE> <DEDENT>
_ = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> num0 , num1 , val = a [ - 1 ] , 0 , float ( <STRING> ) <NEWLINE> <NL> for i in a [ : - 1 ] : <NEWLINE> <INDENT> val0 = abs ( i - num0 / 2 ) <NEWLINE> if val0 < val : <NEWLINE> <INDENT> num1 = i <NEWLINE> val = val0 <NEWLINE> <DEDENT> <DEDENT> print ( num0 , num1 ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> x = S . count ( <STRING> ) <NEWLINE> y = S . count ( <STRING> ) <NEWLINE> print ( 2 * min ( x , y ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 10 ** 20 <NEWLINE> con = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if c > P [ i ] : <NEWLINE> <INDENT> con += 1 <NEWLINE> c = P [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( con ) <NEWLINE> <NL>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> d = defaultdict ( list ) <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> d [ s ] . append ( i ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( 1000 ) : <NEWLINE> <INDENT> T = <STRING> % i <NEWLINE> j = - 1 <NEWLINE> for t in T : <NEWLINE> <INDENT> flag = True <NEWLINE> for k in d [ t ] : <NEWLINE> <INDENT> if k > j : <NEWLINE> <INDENT> flag = False <NEWLINE> j = k <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if not ( flag ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_dic = dict ( ) <NEWLINE> a_set = set ( ) <NEWLINE> for num in a : <NEWLINE> <INDENT> if num in a_dic : <NEWLINE> <INDENT> a_dic [ num ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_dic [ num ] = 1 <NEWLINE> <DEDENT> a_set . add ( num ) <NEWLINE> <DEDENT> k = len ( a_dic ) <NEWLINE> a_set = list ( a_set ) <NEWLINE> if k == 1 : <NEWLINE> <INDENT> if 0 in a_dic : <NEWLINE> <INDENT> if a_dic [ 0 ] == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif k == 2 : <NEWLINE> <INDENT> if a_dic [ 0 ] == n / 3 and a_dic [ a_set [ 1 ] ] == 2 * n / 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> elif k == 3 : <NEWLINE> <INDENT> if a_set [ 0 ] ^ a_set [ 1 ] ^ a_set [ 2 ] == 0 : <NEWLINE> <INDENT> if a_dic [ a_set [ 0 ] ] == a_dic [ a_set [ 1 ] ] == a_dic [ a_set [ 2 ] ] == n / 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ 0 ] * n <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> c = n // 2 - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = n // 2 <NEWLINE> <NL> <DEDENT> b [ c ] = a [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> b [ c + i ] = a [ i ] <NEWLINE> c += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b [ c - i ] = a [ i ] <NEWLINE> c -= i <NEWLINE> <NL> <DEDENT> <DEDENT> if c != 0 : <NEWLINE> <INDENT> b . reverse ( ) <NEWLINE> print ( * b , sep = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( * b , sep = <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def get_count ( S , H , W , i , j ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> start_i = start_j = - 1 <NEWLINE> end_i = end_j = 2 <NEWLINE> if W == 1 : <NEWLINE> <INDENT> start_i = 0 <NEWLINE> end_i = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> start_i = 0 <NEWLINE> <DEDENT> elif i == W - 1 : <NEWLINE> <INDENT> end_i = 1 <NEWLINE> <DEDENT> <DEDENT> if H == 1 : <NEWLINE> <INDENT> start_j = 0 <NEWLINE> end_j = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> start_j = 0 <NEWLINE> <DEDENT> elif j == H - 1 : <NEWLINE> <INDENT> end_j = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for y in range ( start_j , end_j , 1 ) : <NEWLINE> <INDENT> for x in range ( start_i , end_i , 1 ) : <NEWLINE> <INDENT> if S [ j + y ] [ i + x ] == <STRING> : <NEWLINE> <INDENT> num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return num <NEWLINE> <NL> <NL> <DEDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> S . append ( list ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> for y in range ( H ) : <NEWLINE> <INDENT> for x in range ( W ) : <NEWLINE> <INDENT> if S [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> num = get_count ( S , H , W , x , y ) <NEWLINE> S [ y ] [ x ] = str ( num ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for y in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> . join ( S [ y ] ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> i = 1 <NEWLINE> n = 1 <NEWLINE> cnt = 0 <NEWLINE> while 2 * i <= 2 * N : <NEWLINE> <INDENT> cnt += A [ n ] <NEWLINE> i += 1 <NEWLINE> n += 2 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
from math import gcd <NEWLINE> from copy import copy <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def div ( x ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> for i in range ( 1 , int ( x ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> ret . append ( i ) <NEWLINE> ret . append ( x // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def judge_prime ( x ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( 1 , int ( x ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if cnt >= 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> div_a = div ( a ) <NEWLINE> div_b = div ( b ) <NEWLINE> <NL> data = list ( set ( div_a ) & set ( div_b ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in data : <NEWLINE> <INDENT> if judge_prime ( x ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> mem = [ 0 , 0 , 0 ] <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= mem . count ( A [ i ] ) <NEWLINE> ans %= mod <NEWLINE> if ans == 0 : break <NEWLINE> idx = mem . index ( A [ i ] ) <NEWLINE> mem [ idx ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = 0 <NEWLINE> a = [ 0 ] + a + [ 0 ] <NEWLINE> for j in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> d += abs ( a [ j ] - a [ j + 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , len ( a ) - 1 ) : <NEWLINE> <INDENT> if a [ i - 1 ] <= a [ i ] <= a [ i + 1 ] or a [ i - 1 ] >= a [ i ] >= a [ i + 1 ] : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d - abs ( a [ i - 1 ] - a [ i ] ) - abs ( a [ i + 1 ] - a [ i ] ) + abs ( a [ i - 1 ] - a [ i + 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> max_a = 0 <NEWLINE> next_a = 0 <NEWLINE> max_loc = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ai = int ( input ( ) ) <NEWLINE> if ai > max_a : <NEWLINE> <INDENT> max_a = ai <NEWLINE> max_loc = i <NEWLINE> <DEDENT> elif ai > next_a : <NEWLINE> <INDENT> next_a = ai <NEWLINE> <DEDENT> <DEDENT> if next_a == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( max_a ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( max_loc ) : <NEWLINE> <INDENT> print ( max_a ) <NEWLINE> <DEDENT> print ( next_a ) <NEWLINE> for i in range ( n - max_loc - 1 ) : <NEWLINE> <INDENT> print ( max_a ) <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> p = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in itertools . permutations ( [ i + 1 for i in range ( n ) ] , n ) : <NEWLINE> <INDENT> if i == p : <NEWLINE> <INDENT> a = count <NEWLINE> <DEDENT> if i == q : <NEWLINE> <INDENT> b = count <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> print ( abs ( a - b ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from itertools import accumulate <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> S = set ( ) <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> S . add ( i ) <NEWLINE> S . add ( n // i ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> L = [ 0 ] + sorted ( S ) <NEWLINE> l = len ( L ) - 1 <NEWLINE> num = [ 0 ] * l <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> num [ i ] = L [ i + 1 ] - L [ i ] <NEWLINE> <DEDENT> dp = [ 0 ] * l <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> A = list ( accumulate ( dp ) ) <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> dp [ i ] = A [ l - 1 - i ] * num [ i ] <NEWLINE> dp [ i ] %= MOD <NEWLINE> <DEDENT> <DEDENT> ans = sum ( dp ) % MOD <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = sorted ( input ( ) ) <NEWLINE> A . append ( str ( s ) ) <NEWLINE> <DEDENT> B = collections . Counter ( A ) <NEWLINE> print ( sum ( i * ( i - 1 ) // 2 for i in B . values ( ) ) ) <NEWLINE>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> list1 = [ ] <NEWLINE> for l in range ( N ) : <NEWLINE> <INDENT> list1 . append ( str ( input ( ) ) ) <NEWLINE> <DEDENT> list1 . sort ( ) <NEWLINE> print ( <STRING> . join ( list1 ) ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = list ( set ( a ) ) <NEWLINE> m = collections . Counter ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> if m [ l [ i ] ] < l [ i ] : <NEWLINE> <INDENT> ans += m [ l [ i ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += m [ l [ i ] ] - l [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> paths = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b , z = map ( int , input ( ) . split ( ) ) <NEWLINE> paths [ a - 1 ] . append ( b - 1 ) <NEWLINE> paths [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> visited = [ False ] * N <NEWLINE> <NL> def dfs ( node , prev ) : <NEWLINE> <INDENT> if visited [ node ] : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> visited [ node ] = True <NEWLINE> for n in paths [ node ] : <NEWLINE> <INDENT> if n != prev : <NEWLINE> <INDENT> dfs ( n , node ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if visited [ i ] == False : <NEWLINE> <INDENT> count += 1 <NEWLINE> dfs ( i , - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = [ 0 for i in range ( n ) ] <NEWLINE> y = [ ] <NEWLINE> s = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] : <NEWLINE> <INDENT> y . append ( x [ i ] ) <NEWLINE> <DEDENT> <DEDENT> y . sort ( ) <NEWLINE> z = len ( y ) <NEWLINE> i = 0 <NEWLINE> while ( z > k ) : <NEWLINE> <INDENT> s += y [ i ] <NEWLINE> z -= 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
def readinput ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> return n , p <NEWLINE> <NL> <DEDENT> def main ( n , p ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> pmin = p [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> pmin = min ( p [ i ] , pmin ) <NEWLINE> if pmin >= p [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , p = readinput ( ) <NEWLINE> ans = main ( n , p ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> drinks = list ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> drinks . append ( ( a , b ) ) <NEWLINE> <NL> <DEDENT> drinks . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> while M > 0 : <NEWLINE> <INDENT> a , b = drinks . pop ( 0 ) <NEWLINE> if M <= b : <NEWLINE> <INDENT> ans += a * M <NEWLINE> M = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a * b <NEWLINE> M -= b <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> ans = collections . Counter ( a ) <NEWLINE> c = list ( ans . values ( ) ) <NEWLINE> c = np . array ( c ) <NEWLINE> print ( sum ( c % 2 ) ) <NEWLINE>
import sys <NEWLINE> N , P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = int ( P ** ( 1 / N ) + 1.0E-7 ) <NEWLINE> for i in range ( M , 0 , - 1 ) : <NEWLINE> <INDENT> if P % ( i ** N ) == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> s = list ( s ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> word = s [ k - 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] != word : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> m , m2 = - 1 , - 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> a . append ( b ) <NEWLINE> m2 = max ( m2 , min ( m , b ) ) <NEWLINE> m = max ( m , b ) <NEWLINE> <NL> <DEDENT> if m == m2 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> l = [ m ] * n <NEWLINE> l [ a . index ( m ) ] = m2 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
import sys , os , math , bisect , itertools , collections , heapq , queue <NEWLINE> <COMMENT> <NL> from decimal import Decimal <NEWLINE> from collections import defaultdict , deque <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N = ii ( ) <NEWLINE> L = [ 0 ] * ( N + 3 ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> L [ 0 ] = 2 <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> L [ 1 ] = 1 <NEWLINE> for n in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> L [ n ] = L [ n - 1 ] + L [ n - 2 ] <NEWLINE> <DEDENT> print ( L [ n ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def solve ( n , a ) : <NEWLINE> <INDENT> res , total = 0 , 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> res += total // 2 <NEWLINE> total = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total += x <NEWLINE> <DEDENT> <DEDENT> return res + total // 2 <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> print ( solve ( n , a ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> def solve ( a ) : <NEWLINE> <INDENT> ans = deque ( ) <NEWLINE> <NL> for i , aa in enumerate ( a ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> ans . append ( str ( aa ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . appendleft ( str ( aa ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( a ) % 2 == 1 : <NEWLINE> <INDENT> ans . reverse ( ) <NEWLINE> <NL> <DEDENT> return list ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> . join ( solve ( a ) ) ) <NEWLINE> <DEDENT>
k_num , s_num = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for x in range ( k_num + 1 ) : <NEWLINE> <INDENT> l = s_num - x <NEWLINE> for y in range ( k_num + 1 ) : <NEWLINE> <INDENT> z = l - y <NEWLINE> if 0 <= z <= k_num : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> index = 0 <NEWLINE> s = input ( ) . rstrip ( <STRING> ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> ans = s [ i ] <NEWLINE> index = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans == <STRING> or k < index + 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K % 2 == 0 : <NEWLINE> <INDENT> m = A - B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = B - A <NEWLINE> <NL> <DEDENT> print ( m ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> numcnt = { i : 0 for i in range ( 100001 ) } <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> numcnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> for x in range ( 1 , 100000 ) : <NEWLINE> <INDENT> subans = numcnt [ x - 1 ] + numcnt [ x ] + numcnt [ x + 1 ] <NEWLINE> <NL> ans = max ( ans , subans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = [ 0 , 0 , 0 ] <NEWLINE> Ans = 1 <NEWLINE> MOD = 1000000007 <NEWLINE> for a in A : <NEWLINE> <INDENT> ask = C . count ( a ) <NEWLINE> if ask == 0 : <NEWLINE> <INDENT> Ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> ind = C . index ( a ) <NEWLINE> C [ ind ] += 1 <NEWLINE> Ans = ( Ans * ask ) % MOD <NEWLINE> <DEDENT> print ( Ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = deque ( list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> q = deque ( [ ] ) <NEWLINE> tmp = set ( ) <NEWLINE> for idx , i in enumerate ( a ) : <NEWLINE> <INDENT> x = idx <NEWLINE> y = i [ 0 ] <NEWLINE> if x == a [ y ] [ 0 ] : <NEWLINE> <INDENT> tmp . add ( x ) <NEWLINE> tmp . add ( y ) <NEWLINE> <DEDENT> <DEDENT> q = deque ( tmp ) <NEWLINE> for i in tmp : <NEWLINE> <INDENT> a [ i ] . popleft ( ) <NEWLINE> <NL> <NL> <DEDENT> day = 0 <NEWLINE> while True : <NEWLINE> <INDENT> day += 1 <NEWLINE> t = q . copy ( ) <NEWLINE> q = deque ( ) <NEWLINE> tmp = set ( ) <NEWLINE> while t : <NEWLINE> <INDENT> x = t . popleft ( ) <NEWLINE> if len ( a [ x ] ) == 0 : continue ; <NEWLINE> y = a [ x ] [ 0 ] <NEWLINE> if x == a [ y ] [ 0 ] : <NEWLINE> <INDENT> tmp . add ( x ) <NEWLINE> tmp . add ( y ) <NEWLINE> <DEDENT> <DEDENT> q = deque ( tmp ) <NEWLINE> for i in tmp : <NEWLINE> <INDENT> a [ i ] . popleft ( ) <NEWLINE> <DEDENT> if len ( q ) == 0 : break ; <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if len ( a [ i ] ) != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( day ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> C = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> C . sort ( ) <NEWLINE> <NL> i = 0 <NEWLINE> <NL> while i < N : <NEWLINE> <INDENT> print ( C [ i ] , end = <STRING> ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> sys . setrecursionlimit ( 300000 ) <NEWLINE> <NL> to = [ [ ] for _ in range ( 200005 ) ] <NEWLINE> ans : list <NEWLINE> <NL> <NL> def dfs ( v , p = - 1 ) : <NEWLINE> <INDENT> global ans <NEWLINE> for u in to [ v ] : <NEWLINE> <INDENT> if u == p : continue <NEWLINE> ans [ u ] += ans [ v ] <NEWLINE> dfs ( u , v ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> to [ a - 1 ] . append ( b - 1 ) <NEWLINE> to [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> global ans <NEWLINE> ans = [ 0 ] * N <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ p - 1 ] += x <NEWLINE> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import math <NEWLINE> <NL> A , B = ( int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ) <NEWLINE> c = math . gcd ( A , B ) <NEWLINE> if c == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ps = [ ] <NEWLINE> d = math . floor ( math . sqrt ( c ) ) <NEWLINE> for i in range ( 2 , d + 2 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> if all ( i % x != 0 for x in ps ) : <NEWLINE> <INDENT> ps . append ( i ) <NEWLINE> while c % i == 0 : <NEWLINE> <INDENT> c = c // i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if c > 1 : <NEWLINE> <INDENT> ps . append ( 0 ) <NEWLINE> <DEDENT> print ( len ( ps ) + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> read = sys . stdin . read <NEWLINE> <NL> n , m , * pqc = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> g = { } <NEWLINE> M = iter ( pqc ) <NEWLINE> <NL> for p , q , c in zip ( M , M , M ) : <NEWLINE> <INDENT> pc = ( ( p - 1 ) << 20 ) + c <NEWLINE> qc = ( ( q - 1 ) << 20 ) + c <NEWLINE> pp = ( p - 1 ) << 20 <NEWLINE> qq = ( q - 1 ) << 20 <NEWLINE> <NL> if pc not in g : g [ pc ] = [ ] <NEWLINE> if qc not in g : g [ qc ] = [ ] <NEWLINE> if pp not in g : g [ pp ] = [ ] <NEWLINE> if qq not in g : g [ qq ] = [ ] <NEWLINE> <NL> g [ pc ] . append ( qc ) <NEWLINE> g [ pc ] . append ( pp ) <NEWLINE> <NL> g [ qc ] . append ( pc ) <NEWLINE> g [ qc ] . append ( qq ) <NEWLINE> <NL> g [ pp ] . append ( pc ) <NEWLINE> g [ qq ] . append ( qc ) <NEWLINE> <NL> <DEDENT> if 0 not in g : g [ 0 ] = [ ] <NEWLINE> <NL> from collections import deque <NEWLINE> q = deque ( [ ( 0 , 0 ) ] ) <NEWLINE> res = { 0 : 0 } <NEWLINE> <NL> mask = ( 1 << 20 ) - 1 <NEWLINE> while q : <NEWLINE> <INDENT> vl , dv = q . popleft ( ) <NEWLINE> if res [ vl ] < dv : continue <NEWLINE> if ( vl >> 20 ) == n - 1 : <NEWLINE> <INDENT> res [ ( n - 1 ) << 20 ] = dv + 1 <NEWLINE> break <NEWLINE> <DEDENT> for tl in g [ vl ] : <NEWLINE> <INDENT> ndv = dv + ( vl & mask == 0 or tl & mask == 0 ) <NEWLINE> if tl not in res or res [ tl ] > ndv : <NEWLINE> <INDENT> res [ tl ] = ndv <NEWLINE> if vl & mask == 0 or tl & mask == 0 : <NEWLINE> <INDENT> q . append ( ( tl , ndv ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . appendleft ( ( tl , ndv ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ( n - 1 ) << 20 in res : <NEWLINE> <INDENT> print ( res [ ( n - 1 ) << 20 ] // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
N = input ( ) <NEWLINE> n = len ( N ) <NEWLINE> ans = 0 <NEWLINE> if n < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if n > 3 : <NEWLINE> <INDENT> for i in range ( 3 , n ) : <NEWLINE> <INDENT> ans += 3 ** i - 3 * ( 2 ** i ) + 3 <NEWLINE> <DEDENT> <DEDENT> a = int ( N [ 0 ] ) <NEWLINE> if a > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 1 ) - 2 * ( 2 ** ( n - 1 ) ) + 1 <NEWLINE> <DEDENT> if a > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 1 ) - 2 * ( 2 ** ( n - 1 ) ) + 1 <NEWLINE> <DEDENT> if a > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 1 ) - 2 * ( 2 ** ( n - 1 ) ) + 1 <NEWLINE> <DEDENT> b = int ( N [ 1 ] ) <NEWLINE> c = int ( N [ 2 ] ) <NEWLINE> if a == 3 : <NEWLINE> <INDENT> if b > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 2 ) - 2 * ( 2 ** ( n - 2 ) ) + 1 <NEWLINE> <DEDENT> if b > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 2 ) - ( 2 ** ( n - 2 ) ) <NEWLINE> <DEDENT> if b > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 2 ) - ( 2 ** ( n - 2 ) ) <NEWLINE> <DEDENT> if b == 3 : <NEWLINE> <INDENT> if c > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - 2 * ( 2 ** ( n - 3 ) ) + 1 <NEWLINE> <DEDENT> if c > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> <DEDENT> if b == 5 : <NEWLINE> <INDENT> if c > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) <NEWLINE> <DEDENT> <DEDENT> if b == 7 : <NEWLINE> <INDENT> if c > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) <NEWLINE> <DEDENT> if c > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif a == 5 : <NEWLINE> <INDENT> if b > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 2 ) - ( 2 ** ( n - 2 ) ) <NEWLINE> <DEDENT> if b > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 2 ) - 2 * ( 2 ** ( n - 2 ) ) + 1 <NEWLINE> <DEDENT> if b > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 2 ) - ( 2 ** ( n - 2 ) ) <NEWLINE> <DEDENT> if b == 3 : <NEWLINE> <INDENT> if c > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) <NEWLINE> <DEDENT> <DEDENT> if b == 5 : <NEWLINE> <INDENT> if c > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - 2 * ( 2 ** ( n - 3 ) ) + 1 <NEWLINE> <DEDENT> if c > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> <DEDENT> if b == 7 : <NEWLINE> <INDENT> if c > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) <NEWLINE> <DEDENT> if c > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif a == 7 : <NEWLINE> <INDENT> if b > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 2 ) - ( 2 ** ( n - 2 ) ) <NEWLINE> <DEDENT> if b > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 2 ) - ( 2 ** ( n - 2 ) ) <NEWLINE> <DEDENT> if b > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 2 ) - 2 * ( 2 ** ( n - 2 ) ) + 1 <NEWLINE> <DEDENT> if b == 3 : <NEWLINE> <INDENT> if c > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) <NEWLINE> <DEDENT> if c > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> <DEDENT> if b == 5 : <NEWLINE> <INDENT> if c > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) <NEWLINE> <DEDENT> if c > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> <DEDENT> if b == 7 : <NEWLINE> <INDENT> if c > 3 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 5 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - ( 2 ** ( n - 3 ) ) <NEWLINE> <DEDENT> if c > 7 : <NEWLINE> <INDENT> ans += 3 ** ( n - 3 ) - 2 * ( 2 ** ( n - 3 ) ) + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( a == 3 or a == 5 or a == 7 ) and ( b == 3 or b == 5 or b == 7 ) and ( c == 3 or c == 5 or c == 7 ) : <NEWLINE> <INDENT> d = ( a * 100 + b * 10 + c ) * 10 ** ( n - 3 ) <NEWLINE> e = int ( N ) + 1 <NEWLINE> t = { <STRING> , <STRING> , <STRING> } <NEWLINE> for i in range ( d , e ) : <NEWLINE> <INDENT> u = set ( str ( i ) ) <NEWLINE> if u == t : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
kingaku , n = input ( ) . split ( ) <NEWLINE> no_num = input ( ) . split ( ) <NEWLINE> result = [ ] <NEWLINE> ok_num = [ ] <NEWLINE> kuriage_num = [ - 1 , 0 ] <NEWLINE> <NL> def kuriage ( l ) : <NEWLINE> <INDENT> for i in ok_num : <NEWLINE> <INDENT> if result [ l ] < i : <NEWLINE> <INDENT> kuriage_num = [ l , i ] <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> if l <= 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> return kuriage ( l - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( 10 ) : <NEWLINE> <INDENT> if not str ( i ) in no_num : <NEWLINE> <INDENT> ok_num . append ( str ( i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> set_flg = False <NEWLINE> for i in kingaku : <NEWLINE> <INDENT> set_flg = True <NEWLINE> for j in ok_num : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> set_flg = False <NEWLINE> result . append ( j ) <NEWLINE> break <NEWLINE> <DEDENT> elif i < j : <NEWLINE> <INDENT> result . append ( j ) <NEWLINE> print ( <STRING> . join ( result ) . ljust ( len ( kingaku ) , ok_num [ 0 ] ) ) <NEWLINE> exit ( ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if set_flg : <NEWLINE> <INDENT> n = 0 <NEWLINE> if ok_num [ 0 ] == <STRING> : <NEWLINE> <INDENT> n = 1 <NEWLINE> <DEDENT> print ( ok_num [ n ] . ljust ( len ( kingaku ) + 1 , ok_num [ 0 ] ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( result ) ) <NEWLINE>
N = str ( int ( input ( ) ) ) <NEWLINE> total = 0 <NEWLINE> l = len ( N ) - 1 <NEWLINE> if l == 0 : <NEWLINE> <INDENT> print ( N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 2 ** l ) : <NEWLINE> <INDENT> b = format ( i , <STRING> + str ( l ) + <STRING> ) <NEWLINE> subtotal = 0 <NEWLINE> s = N [ 0 ] <NEWLINE> for j in range ( len ( b ) ) : <NEWLINE> <INDENT> if int ( b [ j ] ) : <NEWLINE> <INDENT> subtotal += int ( s ) <NEWLINE> s = N [ j + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += N [ j + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> subtotal += int ( s ) <NEWLINE> total += subtotal <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> map_lis = [ input ( ) for i in range ( H ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> def prob ( x , y , h , w ) : <NEWLINE> <INDENT> if 0 <= x < h and 0 <= y < w : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def count ( x , y , lis ) : <NEWLINE> <INDENT> if not lis [ x ] [ y ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def maze ( x , y , lis ) : <NEWLINE> <INDENT> if lis [ x ] [ y ] == <STRING> : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> k = 0 <NEWLINE> count_lis = np . zeros ( ( H , W ) ) <NEWLINE> num_lis = [ [ ] for i in range ( 1000 ) ] <NEWLINE> if maze ( i , j , map_lis ) : <NEWLINE> <INDENT> count_lis [ i ] [ j ] = 1 <NEWLINE> num_lis [ 0 ] . append ( [ i , j ] ) <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> for l in num_lis [ k ] : <NEWLINE> <INDENT> if prob ( l [ 0 ] - 1 , l [ 1 ] , H , W ) and count ( l [ 0 ] - 1 , l [ 1 ] , count_lis ) and maze ( l [ 0 ] - 1 , l [ 1 ] , map_lis ) : <NEWLINE> <INDENT> num_lis [ k + 1 ] . append ( [ l [ 0 ] - 1 , l [ 1 ] ] ) <NEWLINE> count_lis [ l [ 0 ] - 1 ] [ l [ 1 ] ] = 1 <NEWLINE> <DEDENT> if prob ( l [ 0 ] , l [ 1 ] - 1 , H , W ) and count ( l [ 0 ] , l [ 1 ] - 1 , count_lis ) and maze ( l [ 0 ] , l [ 1 ] - 1 , map_lis ) : <NEWLINE> <INDENT> num_lis [ k + 1 ] . append ( [ l [ 0 ] , l [ 1 ] - 1 ] ) <NEWLINE> count_lis [ l [ 0 ] ] [ l [ 1 ] - 1 ] = 1 <NEWLINE> <DEDENT> if prob ( l [ 0 ] + 1 , l [ 1 ] , H , W ) and count ( l [ 0 ] + 1 , l [ 1 ] , count_lis ) and maze ( l [ 0 ] + 1 , l [ 1 ] , map_lis ) : <NEWLINE> <INDENT> num_lis [ k + 1 ] . append ( [ l [ 0 ] + 1 , l [ 1 ] ] ) <NEWLINE> count_lis [ l [ 0 ] + 1 ] [ l [ 1 ] ] = 1 <NEWLINE> <DEDENT> if prob ( l [ 0 ] , l [ 1 ] + 1 , H , W ) and count ( l [ 0 ] , l [ 1 ] + 1 , count_lis ) and maze ( l [ 0 ] , l [ 1 ] + 1 , map_lis ) : <NEWLINE> <INDENT> num_lis [ k + 1 ] . append ( [ l [ 0 ] , l [ 1 ] + 1 ] ) <NEWLINE> count_lis [ l [ 0 ] ] [ l [ 1 ] + 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> new_ans = 0 <NEWLINE> for m in num_lis [ 1 : ] : <NEWLINE> <INDENT> if m != [ ] : <NEWLINE> <INDENT> new_ans += 1 <NEWLINE> <DEDENT> if m == [ ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , new_ans ) <NEWLINE> k += 1 <NEWLINE> if num_lis [ k ] == [ ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( input ( ) . split ( ) ) <NEWLINE> A = [ int ( a [ i ] ) for i in range ( N ) ] <NEWLINE> frag = [ 0 for i in range ( 60 ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 60 ) : <NEWLINE> <INDENT> j = 1 << i <NEWLINE> cnt = sum ( ( k & j ) >> i for k in A ) <NEWLINE> ans += ( cnt * ( N - cnt ) ) << i <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> resultA = N * 100 // 108 <NEWLINE> resultB = resultA + 1 <NEWLINE> valueA = resultA * 108 // 100 <NEWLINE> valueB = resultB * 108 // 100 <NEWLINE> <NL> if N == valueA : <NEWLINE> <INDENT> print ( resultA ) <NEWLINE> <DEDENT> elif N == valueB : <NEWLINE> <INDENT> print ( resultB ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> tree = [ [ ] for i in range ( N ) ] <NEWLINE> <NL> key_order = [ 0 ] * ( N - 1 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> in1 , in2 = map ( int , input ( ) . split ( ) ) <NEWLINE> in1 -= 1 <NEWLINE> in2 -= 1 <NEWLINE> tree [ in1 ] . append ( in2 ) <NEWLINE> tree [ in2 ] . append ( in1 ) <NEWLINE> <NL> key_order [ i ] = ( in1 , in2 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> def bfs ( tree , p ) : <NEWLINE> <INDENT> seen = [ False ] * len ( tree ) <NEWLINE> queue = deque ( ( p , ) ) <NEWLINE> <NL> edge_colors = dict ( ) <NEWLINE> node_colors = [ 0 ] * len ( tree ) <NEWLINE> while len ( queue ) > 0 : <NEWLINE> <INDENT> q = queue . popleft ( ) <NEWLINE> seen [ q ] = True <NEWLINE> <NL> parent_color = node_colors [ q ] <NEWLINE> <NL> cnt = 1 <NEWLINE> for v in tree [ q ] : <NEWLINE> <INDENT> if not seen [ v ] : <NEWLINE> <INDENT> if cnt == parent_color : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> edge_colors [ ( q , v ) ] = cnt <NEWLINE> node_colors [ v ] = cnt <NEWLINE> queue . append ( v ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <STRING> <NEWLINE> <NL> return edge_colors <NEWLINE> <NL> <NL> <DEDENT> edge_colors = bfs ( tree , 0 ) <NEWLINE> <NL> print ( max ( [ c for key , c in edge_colors . items ( ) ] ) ) <NEWLINE> [ print ( edge_colors [ t ] ) for t in key_order ] <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL>
import itertools <NEWLINE> n , k = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> P = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> probs = list ( itertools . accumulate ( [ ( 1 + p ) / 2 for p in P ] ) ) <NEWLINE> probs . insert ( 0 , 0 ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , - probs [ i ] + probs [ i + k ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from itertools import groupby <NEWLINE> from math import ceil <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> block = [ sum ( 1 for _ in it ) for k , it in groupby ( s ) ] <NEWLINE> if s [ 0 ] != <STRING> : <NEWLINE> <INDENT> block . insert ( 0 , 0 ) <NEWLINE> <NL> <DEDENT> m = len ( block ) <NEWLINE> left , right = 0 , 2 * k <NEWLINE> res = val = sum ( block [ left : right - 1 ] ) <NEWLINE> while right <= m : <NEWLINE> <INDENT> val += block [ right - 1 ] if right == m else block [ right - 1 ] + block [ right ] <NEWLINE> res = max ( res , val ) <NEWLINE> val -= block [ left ] + block [ left + 1 ] <NEWLINE> left += 2 <NEWLINE> right += 2 <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 1 ] <NEWLINE> p = [ 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( 2 * a [ i ] + 3 ) <NEWLINE> p . append ( 2 * p [ i ] + 1 ) <NEWLINE> <DEDENT> def f ( n , x ) : <NEWLINE> <INDENT> if x == 1 : <NEWLINE> <INDENT> return int ( n <= 0 ) <NEWLINE> <DEDENT> elif 1 < x <= a [ n - 1 ] + 1 : <NEWLINE> <INDENT> return f ( n - 1 , x - 1 ) <NEWLINE> <DEDENT> elif x == 2 + a [ n - 1 ] : <NEWLINE> <INDENT> return 1 + p [ n - 1 ] <NEWLINE> <DEDENT> elif 2 + a [ n - 1 ] < x <= 2 + 2 * a [ n - 1 ] : <NEWLINE> <INDENT> return p [ n - 1 ] + 1 + f ( n - 1 , x - 2 - a [ n - 1 ] ) <NEWLINE> <DEDENT> elif x == 2 * a [ n - 1 ] + 3 : <NEWLINE> <INDENT> return 2 * p [ n - 1 ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( f ( n , x ) ) <NEWLINE>
na = 0 <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> b . append ( a [ na ] ) <NEWLINE> if a [ na ] == 2 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> na = a [ na ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ [ ] for i in range ( 10 ** 5 + 1 ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> AB [ A ] . append ( - B ) <NEWLINE> <NL> <DEDENT> hq = [ ] <NEWLINE> heapq . heapify ( hq ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> for b in AB [ i ] : <NEWLINE> <INDENT> heapq . heappush ( hq , b ) <NEWLINE> <NL> <DEDENT> if len ( hq ) > 0 : <NEWLINE> <INDENT> ans += - heapq . heappop ( hq ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> A , B , C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = <STRING> <NEWLINE> if A % 2 == 0 or B % 2 == 0 or C % 2 == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( B * C , C * A , A * B ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> resolve ( ) <NEWLINE>
import bisect <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> start_to_middle = [ ] <NEWLINE> middle_to_end = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> start_to_middle . append ( b ) <NEWLINE> <DEDENT> elif b == N : <NEWLINE> <INDENT> middle_to_end . append ( a ) <NEWLINE> <DEDENT> <DEDENT> if not len ( start_to_middle ) or not len ( middle_to_end ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> middle_to_end . sort ( ) <NEWLINE> for middle in start_to_middle : <NEWLINE> <INDENT> idx = bisect . bisect_left ( middle_to_end , middle ) <NEWLINE> if idx < len ( middle_to_end ) and middle_to_end [ idx ] == middle : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> inf = pow ( 10 , 10 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ inf ] * n <NEWLINE> <NL> edge = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> l , r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> l -= 1 ; r -= 1 <NEWLINE> edge [ l ] . append ( ( r , d ) ) <NEWLINE> edge [ r ] . append ( ( l , - d ) ) <NEWLINE> <NL> <DEDENT> flag = True <NEWLINE> dist = [ inf ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not flag : break <NEWLINE> if dist [ i ] == inf : <NEWLINE> <INDENT> dist [ i ] = 0 <NEWLINE> dq = deque ( [ i ] ) <NEWLINE> while dq : <NEWLINE> <INDENT> now = dq . popleft ( ) <NEWLINE> for e in edge [ now ] : <NEWLINE> <INDENT> nnode , d = e <NEWLINE> if dist [ nnode ] == inf : <NEWLINE> <INDENT> dist [ nnode ] = dist [ now ] + d <NEWLINE> dq . append ( nnode ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if dist [ nnode ] != dist [ now ] + d : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A > B : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> if N == 1 : <NEWLINE> <INDENT> if A == B : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> x = B * ( N - 1 ) + A <NEWLINE> n = A * ( N - 1 ) + B <NEWLINE> print ( x - n + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list1 = alist [ 1 : : 2 ] <NEWLINE> list2 = alist [ 0 : : 2 ] <NEWLINE> from collections import Counter <NEWLINE> dic1 = Counter ( list1 ) . most_common ( ) <NEWLINE> dic2 = Counter ( list2 ) . most_common ( ) <NEWLINE> dic1 . append ( [ 0 , 0 ] ) <NEWLINE> dic2 . append ( [ 0 , 0 ] ) <NEWLINE> if dic1 [ 0 ] [ 0 ] != dic2 [ 0 ] [ 0 ] : <NEWLINE> <INDENT> print ( n - dic1 [ 0 ] [ 1 ] - dic2 [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( n - dic1 [ 0 ] [ 1 ] - dic2 [ 1 ] [ 1 ] , n - dic1 [ 1 ] [ 1 ] - dic2 [ 0 ] [ 1 ] ) ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in x : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( ans ) == 0 or ans [ - 1 ] == <STRING> : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . pop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 100000000000000000000000000000000000000 <NEWLINE> for c in range ( 0 , 100001 ) : <NEWLINE> <INDENT> price = A * max ( 0 , X - c ) + B * max ( 0 , Y - c ) + C * 2 * c <NEWLINE> if price < ans : <NEWLINE> <INDENT> ans = price <NEWLINE> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> num = input ( ) <NEWLINE> <NL> password_list = [ ] <NEWLINE> initial_list = [ ] <NEWLINE> initial_list2 = [ ] <NEWLINE> initial_list3 = [ ] <NEWLINE> <NL> for i in range ( len ( num ) - 2 ) : <NEWLINE> <INDENT> initial_list2 = [ ] <NEWLINE> if num [ i ] in initial_list : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif len ( initial_list ) == 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> initial_list . append ( num [ i ] ) <NEWLINE> for j in range ( i + 1 , len ( num ) - 1 ) : <NEWLINE> <INDENT> initial_list3 = [ ] <NEWLINE> if num [ j ] in initial_list2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif len ( initial_list2 ) == 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> initial_list2 . append ( num [ j ] ) <NEWLINE> for k in range ( j + 1 , len ( num ) ) : <NEWLINE> <INDENT> if num [ k ] in initial_list3 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif len ( initial_list3 ) == 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> initial_list3 . append ( num [ k ] ) <NEWLINE> target = num [ i ] + num [ j ] + num [ k ] <NEWLINE> if target not in password_list : <NEWLINE> <INDENT> password_list . append ( target ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( password_list ) ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from sys import stdin <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N , Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> G = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> PX = defaultdict ( int ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> PX [ p ] += x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = [ 0 ] * ( N + 1 ) <NEWLINE> visited = set ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def dfs ( now , sum_ ) : <NEWLINE> <INDENT> visited . add ( now ) <NEWLINE> for next_ in G [ now ] : <NEWLINE> <INDENT> if next_ not in visited : <NEWLINE> <INDENT> sum_ += PX [ next_ ] <NEWLINE> sum_ = dfs ( next_ , sum_ ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans [ now ] = sum_ <NEWLINE> sum_ -= PX [ now ] <NEWLINE> return sum_ <NEWLINE> <NL> <DEDENT> dfs ( 1 , PX [ 1 ] ) <NEWLINE> <NL> print ( * ans [ 1 : ] , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if ( __name__ == <STRING> ) : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> N , Q = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> tree_list = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = [ int ( n ) - 1 for n in input ( ) . split ( ) ] <NEWLINE> tree_list [ a ] . append ( b ) <NEWLINE> tree_list [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> score_list = [ 0 ] * N <NEWLINE> for j in range ( Q ) : <NEWLINE> <INDENT> p , x = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> score_list [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> reached = [ False ] * N <NEWLINE> def dfs ( v ) : <NEWLINE> <INDENT> reached [ v ] = True <NEWLINE> for next_v in tree_list [ v ] : <NEWLINE> <INDENT> if reached [ next_v ] == True : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> score_list [ next_v ] += score_list [ v ] <NEWLINE> dfs ( next_v ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * score_list ) <NEWLINE>
<COMMENT> <NL> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <NL> <DEDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> aa = prime_factorize ( a ) <NEWLINE> bb = prime_factorize ( b ) <NEWLINE> ab = list ( set ( aa ) & set ( bb ) ) <NEWLINE> ab . sort ( ) <NEWLINE> print ( len ( ab ) + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> xx = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> yy = sorted ( xx ) <NEWLINE> <NL> a = yy [ n // 2 - 1 ] <NEWLINE> b = yy [ n // 2 ] <NEWLINE> <NL> for x in xx : <NEWLINE> <INDENT> if x <= a : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif x >= b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
memo = [ 1 ] * ( 10 ** 5 + 1 ) <NEWLINE> memo [ 0 ] = 0 <NEWLINE> memo [ 1 ] = 0 <NEWLINE> for i in range ( 2 , len ( memo ) ) : <NEWLINE> <INDENT> if memo [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( i * 2 , len ( memo ) , i ) : <NEWLINE> <INDENT> memo [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> memo_like2017 = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( 3 , len ( memo ) , 2 ) : <NEWLINE> <INDENT> if memo [ i ] == 1 and memo [ ( i + 1 ) // 2 ] == 1 : <NEWLINE> <INDENT> memo_like2017 [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> sum_memo = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( 1 , len ( memo ) ) : <NEWLINE> <INDENT> sum_memo [ i ] = sum_memo [ i - 1 ] + memo_like2017 [ i ] <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( sum_memo [ r ] - sum_memo [ l - 1 ] ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> if ( a == 1 and b == 2 ) or ( a == 2 and b == 1 ) : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif ( a == 2 and b == 3 ) or ( a == 3 and b == 2 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif ( a == 1 and b == 3 ) or ( a == 3 and b == 1 ) : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> hs = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> a = np . zeros ( N , int ) <NEWLINE> a [ 0 ] = 0 <NEWLINE> a [ 1 ] = abs ( hs [ 1 ] - hs [ 0 ] ) <NEWLINE> <NL> if N == 2 : <NEWLINE> <INDENT> print ( a [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 2 , N ) : <NEWLINE> <INDENT> b = a [ max ( i - K , 0 ) : i ] + np . abs ( hs [ i ] - hs [ max ( i - K , 0 ) : i ] ) <NEWLINE> a [ i ] = np . min ( b ) <NEWLINE> <DEDENT> print ( a [ - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 + 10 ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = set ( [ int ( input ( ) ) for _ in range ( M ) ] ) <NEWLINE> MOD = 1000000007 <NEWLINE> memo = { } <NEWLINE> def Fib ( n , MOD ) : <NEWLINE> <INDENT> if n in A : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif n in memo : <NEWLINE> <INDENT> return memo [ n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memo [ n ] = ( Fib ( n - 1 , MOD ) + Fib ( n - 2 , MOD ) ) % MOD <NEWLINE> return memo [ n ] <NEWLINE> <DEDENT> <DEDENT> print ( Fib ( N , MOD ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l1 = 2 <NEWLINE> l2 = 1 <NEWLINE> l3 = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> l3 = l1 <NEWLINE> l1 = l2 <NEWLINE> l2 += l3 <NEWLINE> <DEDENT> print ( l2 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> Scc = min ( n , m // 2 ) <NEWLINE> cccc = ( m - Scc * 2 ) // 4 <NEWLINE> print ( Scc + cccc ) <NEWLINE>
import math <NEWLINE> ans = math . inf <NEWLINE> n = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> acm = [ 0 ] * ( n + 1 ) <NEWLINE> for i , v in enumerate ( c , 1 ) : <NEWLINE> <INDENT> acm [ i ] += acm [ i - 1 ] + v <NEWLINE> <NL> <DEDENT> s , a = 0 , acm [ n ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> s = acm [ i ] <NEWLINE> ans = min ( ans , abs ( ( a - s ) - s ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = set ( ) <NEWLINE> for c in <STRING> : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == c : <NEWLINE> <INDENT> for j in range ( i + 1 , i + K + 1 ) : <NEWLINE> <INDENT> ans . add ( S [ i : j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( ans ) >= K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( sorted ( list ( ans ) ) [ K - 1 ] ) <NEWLINE>
import numpy as np <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( h ) ] <NEWLINE> <NL> t = np . zeros ( ( h , w ) , dtype = np . int32 ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> t [ i ] [ j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> l = np . zeros ( ( h , w ) , dtype = np . int32 ) <NEWLINE> r = np . zeros ( ( h , w ) , dtype = np . int32 ) <NEWLINE> u = np . zeros ( ( h , w ) , dtype = np . int32 ) <NEWLINE> d = np . zeros ( ( h , w ) , dtype = np . int32 ) <NEWLINE> <NL> for i in range ( w ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> l [ : , i ] = t [ : , i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ : , i ] = ( l [ : , i - 1 ] + 1 ) * t [ : , i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( w - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if i == w - 1 : <NEWLINE> <INDENT> r [ : , i ] = t [ : , i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r [ : , i ] = ( r [ : , i + 1 ] + 1 ) * t [ : , i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> u [ i ] = t [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> u [ i ] = ( u [ i - 1 ] + 1 ) * t [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( h - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if i == h - 1 : <NEWLINE> <INDENT> d [ i ] = t [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] = ( d [ i + 1 ] + 1 ) * t [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> lrud = l + r + u + d - 3 <NEWLINE> print ( np . max ( lrud ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> result = [ 0 ] * N <NEWLINE> x = 0 <NEWLINE> for key , i in enumerate ( A ) : <NEWLINE> <INDENT> if key % 2 == 0 : <NEWLINE> <INDENT> x += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x -= i <NEWLINE> <NL> <DEDENT> <DEDENT> result [ 0 ] = x <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> result [ i ] = 2 * A [ i - 1 ] - result [ i - 1 ] <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( [ str ( x ) for x in result ] ) ) <NEWLINE>
import sys <NEWLINE> import string <NEWLINE> <NL> alphabets = list ( string . ascii_lowercase ) <NEWLINE> <NL> s = input ( ) <NEWLINE> <NL> l = len ( s ) <NEWLINE> <NL> hm = lambda a , string : sum ( [ x == a for x in string ] ) <NEWLINE> <NL> for x in range ( l - 1 ) : <NEWLINE> <INDENT> if s [ x ] == s [ x + 1 ] : <NEWLINE> <INDENT> print ( <STRING> . format ( x + 1 , x + 2 ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for n in range ( l - 3 ) : <NEWLINE> <INDENT> for a in alphabets : <NEWLINE> <INDENT> if hm ( a , s [ n : n + 3 ] ) > 1 : <NEWLINE> <INDENT> print ( <STRING> . format ( n + 1 , n + 3 ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> ans += t <NEWLINE> s . append ( t ) <NEWLINE> <DEDENT> s . sort ( ) <NEWLINE> <NL> if ans % 10 == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] % 10 != 0 : <NEWLINE> <INDENT> ans -= s [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans % 10 == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> temp = 0 <NEWLINE> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> temp = temp + i <NEWLINE> if temp >= x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
def cal ( N ) : <NEWLINE> <INDENT> num = ( N ** 0.5 ) // 1 <NEWLINE> num = int ( num ) <NEWLINE> for i in range ( num , 0 , - 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> k = int ( N / i ) <NEWLINE> x = len ( str ( k ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return x <NEWLINE> <NL> <DEDENT> print ( cal ( int ( input ( ) ) ) ) <NEWLINE>
N , P = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> d = P <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = 1 <NEWLINE> i = 2 <NEWLINE> while i <= round ( pow ( P , 1 / N ) ) : <NEWLINE> <INDENT> if P % i ** N == 0 : <NEWLINE> <INDENT> P //= i ** N <NEWLINE> d *= i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> pwr = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> pwr *= 1 * ( i + 1 ) <NEWLINE> pwr = pwr % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( pwr ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] [ : : - 1 ] <NEWLINE> dp = [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> if bisect . bisect_right ( dp , i ) == len ( dp ) : <NEWLINE> <INDENT> dp . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ bisect . bisect_right ( dp , i ) ] = i <NEWLINE> <DEDENT> <DEDENT> print ( len ( dp ) ) <NEWLINE>
import math <NEWLINE> from math import gcd , pi , sqrt <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import itertools <NEWLINE> from collections import Counter , deque <NEWLINE> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> import string <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = i_input ( ) <NEWLINE> a = i_list ( ) <NEWLINE> even = [ ] <NEWLINE> odd = [ ] <NEWLINE> for i , k in enumerate ( a ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> even . append ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> odd . append ( k ) <NEWLINE> <NL> <DEDENT> <DEDENT> even . reverse ( ) <NEWLINE> even . extend ( odd ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> even . reverse ( ) <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , even ) ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> sq = [ list ( input ( ) ) for i in range ( H ) ] <NEWLINE> <NL> pos = [ [ 0 , 0 , 0 ] ] <NEWLINE> g = True <NEWLINE> <NL> while pos != [ ] : <NEWLINE> <INDENT> y , x , depth = pos . pop ( 0 ) <NEWLINE> <NL> if y == H - 1 and x == W - 1 : <NEWLINE> <INDENT> g = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> if x - 1 >= 0 : <NEWLINE> <INDENT> if sq [ y ] [ x - 1 ] == <STRING> : <NEWLINE> <INDENT> pos . append ( [ y , x - 1 , depth + 1 ] ) <NEWLINE> sq [ y ] [ x - 1 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if x + 1 <= W - 1 : <NEWLINE> <INDENT> if sq [ y ] [ x + 1 ] == <STRING> : <NEWLINE> <INDENT> pos . append ( [ y , x + 1 , depth + 1 ] ) <NEWLINE> sq [ y ] [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if y - 1 >= 0 : <NEWLINE> <INDENT> if sq [ y - 1 ] [ x ] == <STRING> : <NEWLINE> <INDENT> pos . append ( [ y - 1 , x , depth + 1 ] ) <NEWLINE> sq [ y - 1 ] [ x ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if y + 1 <= H - 1 : <NEWLINE> <INDENT> if sq [ y + 1 ] [ x ] == <STRING> : <NEWLINE> <INDENT> pos . append ( [ y + 1 , x , depth + 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if g == True : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = 0 <NEWLINE> for k in range ( H ) : <NEWLINE> <INDENT> for m in range ( W ) : <NEWLINE> <INDENT> if sq [ k ] [ m ] == <STRING> : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( H * W - temp - depth - 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> d = { } <NEWLINE> PY = [ ] <NEWLINE> import bisect <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> p , y = map ( int , input ( ) . split ( ) ) <NEWLINE> PY . append ( ( p , y ) ) <NEWLINE> t = d . get ( p , [ 0 ] ) <NEWLINE> i = bisect . bisect_left ( t , y ) <NEWLINE> t . insert ( i , y ) <NEWLINE> d [ p ] = t <NEWLINE> <NL> <DEDENT> dx = { } <NEWLINE> for k , v in d . items ( ) : <NEWLINE> <INDENT> for i in range ( len ( v ) ) : <NEWLINE> <INDENT> dx [ ( k , v [ i ] ) ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> for p , y in PY : <NEWLINE> <INDENT> print ( str ( p ) . zfill ( 6 ) + str ( dx [ ( p , y ) ] ) . zfill ( 6 ) ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> def main ( ) : <NEWLINE> <INDENT> S = input ( ) + <STRING> <NEWLINE> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> moveX , moveY = [ ] , [ ] <NEWLINE> if S [ 0 ] == <STRING> : moveX . append ( 0 ) <NEWLINE> move = { 0 : moveX , 1 : moveY } <NEWLINE> direct = 0 <NEWLINE> step = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> if step > 0 : <NEWLINE> <INDENT> move [ direct ] . append ( step ) <NEWLINE> step = 0 <NEWLINE> <DEDENT> direct ^= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> step += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if possible ( x , moveX [ 1 : ] , moveX [ 0 ] ) and possible ( y , moveY ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def possible ( target , move , offset = 0 ) : <NEWLINE> <INDENT> l = len ( move ) <NEWLINE> dp = [ defaultdict ( lambda : False ) for _ in range ( l + 1 ) ] <NEWLINE> <COMMENT> <NL> dp [ 0 ] [ 0 ] = True <NEWLINE> for i , m in enumerate ( move ) : <NEWLINE> <INDENT> for key in dp [ i ] : <NEWLINE> <INDENT> dp [ i + 1 ] [ key + m ] = True <NEWLINE> dp [ i + 1 ] [ key - m ] = True <NEWLINE> <DEDENT> <DEDENT> return dp [ l ] [ target - offset ] <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = { 0 : 0 , 1 : 300000 , 2 : 200000 , 3 : 100000 } <NEWLINE> if a > 3 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = a <NEWLINE> <DEDENT> if b > 3 : <NEWLINE> <INDENT> y = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = b <NEWLINE> <DEDENT> if x == 1 and y == 1 : <NEWLINE> <INDENT> ans = 1000000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = lst [ x ] + lst [ y ] <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> B = sorted ( A ) <NEWLINE> C = max ( A ) <NEWLINE> for i in A : <NEWLINE> <INDENT> if C == i : <NEWLINE> <INDENT> print ( B [ - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( C ) <NEWLINE> <DEDENT> <DEDENT>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> x = 2018 <NEWLINE> <NL> if r - l >= 2019 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> if ( i * j ) % 2019 < x : <NEWLINE> <INDENT> x = ( i * j ) % 2019 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> query = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> x , y = 1 , 1 <NEWLINE> for t , a in query : <NEWLINE> <INDENT> if t >= x and a >= y : <NEWLINE> <INDENT> x = t <NEWLINE> y = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t < x and a < y : <NEWLINE> <INDENT> x = t * max ( ( x + t - 1 ) // t , ( y + a - 1 ) // a ) <NEWLINE> y = a * max ( ( x + t - 1 ) // t , ( y + a - 1 ) // a ) <NEWLINE> <DEDENT> elif t < x : <NEWLINE> <INDENT> x = t * ( ( x + t - 1 ) // t ) <NEWLINE> y = a * ( ( x + t - 1 ) // t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = t * ( ( y + a - 1 ) // a ) <NEWLINE> y = a * ( ( y + a - 1 ) // a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( x + y ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import copy <NEWLINE> from collections import deque <NEWLINE> from functools import reduce <NEWLINE> from itertools import product <NEWLINE> from itertools import combinations <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> An = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Bn = [ ] <NEWLINE> Bn . append ( 0 ) <NEWLINE> for i , A in enumerate ( An ) : <NEWLINE> <INDENT> Bn . append ( A + Bn [ i ] ) <NEWLINE> <DEDENT> Cn = collections . Counter ( Bn ) <NEWLINE> ans = 0 <NEWLINE> for c in Cn . values ( ) : <NEWLINE> <INDENT> if c < 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += c * ( c - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> d = dict ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> if s [ 0 ] == <STRING> or s [ 0 ] == <STRING> or s [ 0 ] == <STRING> or s [ 0 ] == <STRING> or s [ 0 ] == <STRING> : <NEWLINE> <INDENT> if s [ 0 ] not in d : <NEWLINE> <INDENT> d [ s [ 0 ] ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s [ 0 ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> count = 0 <NEWLINE> d = list ( d . values ( ) ) <NEWLINE> if len ( d ) == 3 : <NEWLINE> <INDENT> count += d [ 0 ] * d [ 1 ] * d [ 2 ] <NEWLINE> <DEDENT> elif len ( d ) == 4 : <NEWLINE> <INDENT> count += d [ 0 ] * d [ 1 ] * d [ 2 ] <NEWLINE> count += d [ 3 ] * d [ 1 ] * d [ 2 ] <NEWLINE> count += d [ 0 ] * d [ 1 ] * d [ 3 ] <NEWLINE> count += d [ 0 ] * d [ 3 ] * d [ 2 ] <NEWLINE> <DEDENT> elif len ( d ) == 5 : <NEWLINE> <INDENT> count += d [ 0 ] * d [ 1 ] * d [ 2 ] <NEWLINE> count += d [ 3 ] * d [ 1 ] * d [ 2 ] <NEWLINE> count += d [ 0 ] * d [ 1 ] * d [ 3 ] <NEWLINE> count += d [ 0 ] * d [ 3 ] * d [ 2 ] <NEWLINE> <NL> <COMMENT> <NL> count += d [ 4 ] * d [ 1 ] * d [ 2 ] <NEWLINE> count += d [ 0 ] * d [ 1 ] * d [ 4 ] <NEWLINE> count += d [ 0 ] * d [ 4 ] * d [ 2 ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> count += d [ 4 ] * d [ 1 ] * d [ 3 ] <NEWLINE> count += d [ 4 ] * d [ 3 ] * d [ 2 ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> count += d [ 0 ] * d [ 4 ] * d [ 3 ] <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> p = 1 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> s = sum ( 1 for b in a if b & p ) <NEWLINE> ans += s * ( n - s ) * p <NEWLINE> ans %= mod <NEWLINE> p <<= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> L = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> L . sort ( ) <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( N - 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> p = i + 2 <NEWLINE> <COMMENT> <NL> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> while p < N and L [ p ] < L [ i ] + L [ j ] : <NEWLINE> <INDENT> p += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans += max ( 0 , p - j - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ - 1 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> dp [ a - 1 ] = 0 <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if dp [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % mod <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> s1 = set ( s [ : i ] ) <NEWLINE> s2 = set ( s [ i : ] ) <NEWLINE> a . append ( len ( s1 & s2 ) ) <NEWLINE> <DEDENT> print ( max ( a ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> i = 1 <NEWLINE> while N >= 2 ** i : <NEWLINE> <INDENT> ans += 2 ** i <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from sys import stdin , stdout <NEWLINE> <NL> import bisect <NEWLINE> <NL> import math <NEWLINE> <NL> def st ( ) : <NEWLINE> <INDENT> return list ( stdin . readline ( ) . strip ( ) ) <NEWLINE> <NL> <DEDENT> def inp ( ) : <NEWLINE> <INDENT> return int ( stdin . readline ( ) ) <NEWLINE> <NL> <DEDENT> def li ( ) : <NEWLINE> <INDENT> return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def mp ( ) : <NEWLINE> <INDENT> return map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def pr ( n ) : <NEWLINE> <INDENT> stdout . write ( str ( n ) + <STRING> ) <NEWLINE> <NL> <DEDENT> def soe ( limit ) : <NEWLINE> <INDENT> l = [ 1 ] * ( limit + 1 ) <NEWLINE> prime = [ ] <NEWLINE> for i in range ( 2 , limit + 1 ) : <NEWLINE> <INDENT> if l [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , limit + 1 , i ) : <NEWLINE> <INDENT> l [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 2 , limit + 1 ) : <NEWLINE> <INDENT> if l [ i ] : <NEWLINE> <INDENT> prime . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return prime <NEWLINE> <NL> <DEDENT> def segsoe ( low , high ) : <NEWLINE> <INDENT> limit = int ( high ** 0.5 ) + 1 <NEWLINE> prime = soe ( limit ) <NEWLINE> n = high - low + 1 <NEWLINE> l = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( len ( prime ) ) : <NEWLINE> <INDENT> lowlimit = ( low // prime [ i ] ) * prime [ i ] <NEWLINE> if lowlimit < low : <NEWLINE> <INDENT> lowlimit += prime [ i ] <NEWLINE> <DEDENT> if lowlimit == prime [ i ] : <NEWLINE> <INDENT> lowlimit += prime [ i ] <NEWLINE> <DEDENT> for j in range ( lowlimit , high + 1 , prime [ i ] ) : <NEWLINE> <INDENT> l [ j - low ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( low , high + 1 ) : <NEWLINE> <INDENT> if not l [ i - low ] : <NEWLINE> <INDENT> if i != 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def power ( a , n ) : <NEWLINE> <INDENT> r = 1 <NEWLINE> while n : <NEWLINE> <INDENT> if n & 1 : <NEWLINE> <INDENT> r = ( r * a ) <NEWLINE> <DEDENT> a *= a <NEWLINE> n = n >> 1 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> l = soe ( 10 ** 6 + 100 ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n = inp ( ) <NEWLINE> a = bisect . bisect_left ( l , n ) <NEWLINE> <NL> print ( l [ a ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> for _ in range ( 1 ) : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <NL> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = [ 0 ] * n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a [ i ] += a [ i - 1 ] <NEWLINE> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a [ r - 1 ] - a [ l - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> dishes = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> points = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bonuses = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> score = 0 <NEWLINE> prev = 0 <NEWLINE> for i in dishes : <NEWLINE> <INDENT> score += points [ i - 1 ] <NEWLINE> if prev > 0 : <NEWLINE> <INDENT> if i == prev + 1 : score += bonuses [ i - 2 ] <NEWLINE> <DEDENT> prev = i <NEWLINE> <NL> <DEDENT> print ( score ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> def get_sieved_list ( x ) : <NEWLINE> <INDENT> dp = [ 1 if item % 2 == 0 else 0 for item in range ( x + 1 ) ] <NEWLINE> dp [ : 3 ] = [ 2 , 1 , 1 ] <NEWLINE> <NL> for prim_candi in range ( 3 , x + 1 ) : <NEWLINE> <INDENT> temp_num = prim_candi <NEWLINE> while temp_num <= x : <NEWLINE> <INDENT> dp [ temp_num ] += 1 <NEWLINE> temp_num += prim_candi <NEWLINE> <DEDENT> if prim_candi >= x : <NEWLINE> <INDENT> return [ i for i in range ( x + 1 ) if dp [ i ] == 1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if N > 2 : <NEWLINE> <INDENT> factor_filter = set ( get_sieved_list ( N ) ) <NEWLINE> prime_list = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> for i in factor_filter : <NEWLINE> <INDENT> if i > 1 : <NEWLINE> <INDENT> for j in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> while j >= 1 and j % i == 0 : <NEWLINE> <INDENT> j //= i <NEWLINE> prime_list [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> res = 1 <NEWLINE> for item in prime_list : <NEWLINE> <INDENT> res *= ( item + 1 ) <NEWLINE> res %= ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res = N <NEWLINE> <NL> <DEDENT> print ( res % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N , K = ( int ( a ) for a in input ( ) . split ( ) ) <NEWLINE> p = list ( ( int ( a ) + 1 ) / 2 for a in input ( ) . split ( ) ) <NEWLINE> s = [ sum ( p [ : K ] ) ] <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> s . append ( s [ - 1 ] - p [ i ] + p [ i + K ] ) <NEWLINE> <DEDENT> print ( max ( s ) ) <NEWLINE>
from subprocess import * <NEWLINE> call ( ( <STRING> , <STRING> , <STRING> ) ) <NEWLINE> <STRING> <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 17 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> val = [ 0 ] * n <NEWLINE> <NL> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> val [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> seen = [ False ] * n <NEWLINE> def dfs ( v ) : <NEWLINE> <INDENT> seen [ v ] = True <NEWLINE> for nv in g [ v ] : <NEWLINE> <INDENT> if seen [ nv ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> val [ nv ] += val [ v ] <NEWLINE> dfs ( nv ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * val ) <NEWLINE>
import numpy as np <NEWLINE> from collections import defaultdict <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> As = np . array ( [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> mods = As % K <NEWLINE> csum_mods = np . cumsum ( mods ) <NEWLINE> magic_array = ( csum_mods - np . arange ( 0 , N + 1 ) ) % K <NEWLINE> <NL> indices = defaultdict ( list ) <NEWLINE> for i , m in enumerate ( magic_array . tolist ( ) ) : <NEWLINE> <INDENT> indices [ m ] . append ( i ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for ls in indices . values ( ) : <NEWLINE> <INDENT> j = 1 <NEWLINE> for i in range ( len ( ls ) ) : <NEWLINE> <INDENT> while j < len ( ls ) : <NEWLINE> <INDENT> if ls [ j ] - ls [ i ] < K : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans += j - i - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from bisect import bisect_left <NEWLINE> from string import ascii_lowercase <NEWLINE> <NL> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> dict_s = { c : [ ] for c in ascii_lowercase } <NEWLINE> for i , c in enumerate ( s * 2 ) : <NEWLINE> <INDENT> dict_s [ c ] . append ( i ) <NEWLINE> <NL> <DEDENT> for c in ascii_lowercase : <NEWLINE> <INDENT> if not dict_s [ c ] : <NEWLINE> <INDENT> del dict_s [ c ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dict_next_i = { <NEWLINE> <INDENT> c : [ dict_s [ c ] [ bisect_left ( dict_s [ c ] , i + 1 ) ] for i in range ( n ) ] <NEWLINE> for c in dict_s . keys ( ) <NEWLINE> <DEDENT> } <NEWLINE> <NL> <NL> def next_i ( i , c ) : <NEWLINE> <INDENT> return n * ( i // n ) + dict_next_i [ c ] [ i % n ] <NEWLINE> <NL> <NL> <DEDENT> def answer ( ) : <NEWLINE> <INDENT> if not all ( c in s for c in t ) : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> i = - 1 <NEWLINE> for c in t : <NEWLINE> <INDENT> i = next_i ( i , c ) <NEWLINE> <DEDENT> return i + 1 <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> print ( answer ( ) ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> a , b , c , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> min_sum = 100000 * 5000 + 100000 * 5000 + 200000 * 5000 <NEWLINE> <NL> if a == c and b == c : <NEWLINE> <INDENT> min_sum = a * x + b * y <NEWLINE> <DEDENT> elif a < c and b < c or a == c and b < c or a < c and b == c : <NEWLINE> <INDENT> min_sum = a * x + b * y <NEWLINE> <DEDENT> elif a > c and b > c or a == c and b > c or a > c and b == c : <NEWLINE> <INDENT> if x >= y : <NEWLINE> <INDENT> min_sum = y * 2 * c <NEWLINE> if a > c * 2 : <NEWLINE> <INDENT> min_sum = min_sum + ( x - y ) * c * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_sum = min_sum + ( x - y ) * a <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> min_sum = x * 2 * c <NEWLINE> if b > c * 2 : <NEWLINE> <INDENT> min_sum = min_sum + ( y - x ) * c * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_sum = min_sum + ( y - x ) * b <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif a < c and b > c : <NEWLINE> <INDENT> if c - a > b - c : <COMMENT> <NEWLINE> <INDENT> min_sum = a * x + b * y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x >= y : <NEWLINE> <INDENT> min_sum = ( x - y ) * a + y * c * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_sum = ( y - x ) * b + x * c * 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif a > c and b < c : <NEWLINE> <INDENT> if c - b > a - c : <COMMENT> <NEWLINE> <INDENT> min_sum = a * x + b * y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x >= y : <NEWLINE> <INDENT> min_sum = ( x - y ) * a + y * c * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_sum = ( y - x ) * b + x * c * 2 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , x + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , y + 1 ) : <NEWLINE> <INDENT> if min_sum > a * i + b * j + max ( x - i , y - j ) * c * 2 : <NEWLINE> <INDENT> min_sum = a * i + b * j + max ( x - i , y - j ) * c * 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( min_sum ) <NEWLINE> <DEDENT> main ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> am = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> hole = [ False ] * ( n + 1 ) <NEWLINE> <NL> for i in am : <NEWLINE> <INDENT> hole [ i ] = True <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , min ( n , i + 2 ) + 1 ) : <NEWLINE> <INDENT> if not hole [ j ] : <NEWLINE> <INDENT> dp [ j ] += dp [ i ] <NEWLINE> dp [ j ] %= 1000000007 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> L_1 = set ( [ i for i in range ( A , min ( A + K , B + 1 ) ) ] ) <NEWLINE> L_2 = set ( [ i for i in range ( max ( A , B - K + 1 ) , B + 1 ) ] ) <NEWLINE> L = sorted ( L_1 | L_2 ) <NEWLINE> for l in L : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> a = x % 11 <NEWLINE> b = x // 11 <NEWLINE> <NL> if a == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> <DEDENT> elif a <= 6 : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = 2 <NEWLINE> <NL> <DEDENT> print ( b * 2 + c ) <NEWLINE>
import itertools <NEWLINE> <NL> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> if R - L + 1 >= 2019 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> LL = L % 2019 <NEWLINE> RR = R % 2019 <NEWLINE> if LL < RR : <NEWLINE> <INDENT> Amari_List = list ( range ( LL , RR + 1 ) ) <NEWLINE> ans = 2019 <NEWLINE> for v1 , v2 in itertools . combinations ( Amari_List , 2 ) : <NEWLINE> <INDENT> ca = ( v1 * v2 ) % 2019 <NEWLINE> if ca < ans : <NEWLINE> <INDENT> ans = ca <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL>
import collections <NEWLINE> import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if len ( set ( a ) ) == 1 : <NEWLINE> <INDENT> print ( n // 2 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> a1 = [ a [ x ] for x in range ( 0 , n , 2 ) ] <NEWLINE> l_a1 = len ( a1 ) <NEWLINE> a2 = [ a [ y ] for y in range ( 1 , n , 2 ) ] <NEWLINE> l_a2 = len ( a2 ) <NEWLINE> c1 = collections . Counter ( a1 ) <NEWLINE> c2 = collections . Counter ( a2 ) <NEWLINE> K_a1 = c1 . most_common ( ) [ 0 ] [ 0 ] <NEWLINE> K_a2 = c2 . most_common ( ) [ 0 ] [ 0 ] <NEWLINE> F_a1 = c1 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> F_a2 = c2 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> if K_a1 == K_a2 : <NEWLINE> <INDENT> if F_a1 > F_a2 : <NEWLINE> <INDENT> F_a2 = c2 . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <DEDENT> elif F_a1 == F_a2 : <NEWLINE> <INDENT> if c1 . most_common ( ) [ 1 ] [ 1 ] > c2 . most_common ( ) [ 1 ] [ 1 ] : <NEWLINE> <INDENT> F_a1 = c1 . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> F_a2 = c2 . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> F_a1 = c1 . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ( l_a1 - F_a1 ) + ( l_a2 - F_a2 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> l , r = [ ] , [ ] <NEWLINE> ans = min ( s . count ( <STRING> ) , s . count ( <STRING> ) ) <NEWLINE> k = s . count ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= 1 <NEWLINE> <DEDENT> ans = min ( ans , k ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> args = input ( ) . split ( ) <NEWLINE> N = int ( args [ 0 ] ) <NEWLINE> Y = int ( args [ 1 ] ) <NEWLINE> <NL> for num10000 in range ( 0 , N + 1 ) : <NEWLINE> <INDENT> for num5000 in range ( 0 , N + 1 - num10000 ) : <NEWLINE> <INDENT> num1000 = N - num10000 - num5000 <NEWLINE> value = 10000 * num10000 + 5000 * num5000 + 1000 * num1000 <NEWLINE> if value == Y : <NEWLINE> <INDENT> print ( num10000 , num5000 , num1000 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
K , S = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for x in range ( max ( 0 , S - 2 * K ) , min ( K , S ) + 1 ) : <NEWLINE> <INDENT> ans += min ( K , S - x ) - max ( 0 , S - x - K ) + 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> s = list ( input ( ) ) <NEWLINE> if list ( set ( s ) ) == [ <STRING> ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> t = [ i for i in s if i != <STRING> ] <NEWLINE> n = len ( t ) <NEWLINE> if <STRING> . join ( t ) != <STRING> . join ( t [ : : - 1 ] ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic = { } <NEWLINE> cnt = 0 <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ j ] != <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt == n // 2 : <NEWLINE> <INDENT> a = s [ : j + 1 ] <NEWLINE> a = a [ : : - 1 ] <NEWLINE> <DEDENT> if cnt == n // 2 + 1 : <NEWLINE> <INDENT> b = s [ j : ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> c = 0 <NEWLINE> fa = [ ] <NEWLINE> fb = [ ] <NEWLINE> for k in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ k ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fa . append ( c ) <NEWLINE> c = 0 <NEWLINE> <DEDENT> <DEDENT> fa . append ( c ) <NEWLINE> c = 0 <NEWLINE> for p in range ( len ( b ) ) : <NEWLINE> <INDENT> if b [ p ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fb . append ( c ) <NEWLINE> c = 0 <NEWLINE> <DEDENT> <DEDENT> fb . append ( c ) <NEWLINE> ans = 0 <NEWLINE> for q in range ( len ( fa ) ) : <NEWLINE> <INDENT> ans += max ( fa [ q ] , fb [ q ] ) - min ( fa [ q ] , fb [ q ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ j ] != <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt == int ( n / 2 ) + 1 : <NEWLINE> <INDENT> a = s [ : j + 1 ] <NEWLINE> a = a [ : : - 1 ] <NEWLINE> b = s [ j : ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> c = 0 <NEWLINE> fa = [ ] <NEWLINE> fb = [ ] <NEWLINE> for k in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ k ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fa . append ( c ) <NEWLINE> c = 0 <NEWLINE> <DEDENT> <DEDENT> fa . append ( c ) <NEWLINE> c = 0 <NEWLINE> for p in range ( len ( b ) ) : <NEWLINE> <INDENT> if b [ p ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fb . append ( c ) <NEWLINE> c = 0 <NEWLINE> <DEDENT> <DEDENT> fb . append ( c ) <NEWLINE> ans = 0 <NEWLINE> for q in range ( len ( fa ) ) : <NEWLINE> <INDENT> ans += max ( fa [ q ] , fb [ q ] ) - min ( fa [ q ] , fb [ q ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> point_l = [ k - q ] * n <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> ans = int ( input ( ) ) <NEWLINE> point_l [ ans - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> if point_l [ i ] > 0 else <STRING> ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> l = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 , 101 , 103 , 107 , 109 , 113 , 127 , 131 , 137 , 139 , 149 , 151 , 157 , 163 , 167 , 173 , 179 , 181 , 191 , 193 , 197 , 199 , 211 , 223 , 227 , 229 , 233 , 239 , 241 , 251 , 257 , 263 , 269 , 271 , 277 , 281 , 283 , 293 , 307 , 311 , 313 , 317 , 331 , 337 , 347 , 349 , 353 , 359 , 367 , 373 , 379 , 383 , 389 , 397 , 401 , 409 , 419 , 421 , 431 , 433 , 439 , 443 , 449 , 457 , 461 , 463 , 467 , 479 , 487 , 491 , 499 , 503 , 509 , 521 , 523 , 541 , 547 , 557 , 563 , 569 , 571 , 577 , 587 , 593 , 599 , 601 , 607 , 613 , 617 , 619 , 631 , 641 , 643 , 647 , 653 , 659 , 661 , 673 , 677 , 683 , 691 , 701 , 709 , 719 , 727 , 733 , 739 , 743 , 751 , 757 , 761 , 769 , 773 , 787 , 797 , 809 , 811 , 821 , 823 , 827 , 829 , 839 , 853 , 857 , 859 , 863 , 877 , 881 , 883 , 887 , 907 , 911 , 919 , 929 , 937 , 941 , 947 , 953 , 967 , 971 , 977 , 983 , 991 , 997 , 1009 , 1013 , 1019 , 1021 , 1031 , 1033 , 1039 , 1049 , 1051 , 1061 , 1063 , 1069 , 1087 , 1091 , 1093 , 1097 , 1103 , 1109 , 1117 , 1123 , 1129 , 1151 , 1153 , 1163 , 1171 , 1181 , 1187 , 1193 , 1201 , 1213 , 1217 , 1223 , 1229 , 1231 , 1237 , 1249 , 1259 , 1277 , 1279 , 1283 , 1289 , 1291 , 1297 , 1301 , 1303 , 1307 , 1319 , 1321 , 1327 , 1361 , 1367 , 1373 , 1381 , 1399 , 1409 , 1423 , 1427 , 1429 , 1433 , 1439 , 1447 , 1451 , 1453 , 1459 , 1471 , 1481 , 1483 , 1487 , 1489 , 1493 , 1499 , 1511 , 1523 , 1531 , 1543 , 1549 , 1553 , 1559 , 1567 , 1571 , 1579 , 1583 , 1597 , 1601 , 1607 , 1609 , 1613 , 1619 , 1621 , 1627 , 1637 , 1657 , 1663 , 1667 , 1669 , 1693 , 1697 , 1699 , 1709 , 1721 , 1723 , 1733 , 1741 , 1747 , 1753 , 1759 , 1777 , 1783 , 1787 , 1789 , 1801 , 1811 , 1823 , 1831 , 1847 , 1861 , 1867 , 1871 , 1873 , 1877 , 1879 , 1889 , 1901 , 1907 , 1913 , 1931 , 1933 , 1949 , 1951 , 1973 , 1979 , 1987 , 1993 , 1997 , 1999 , 2003 , 2011 , 2017 , 2027 , 2029 , 2039 , 2053 , 2063 , 2069 , 2081 , 2083 , 2087 , 2089 , 2099 , 2111 , 2113 , 2129 , 2131 , 2137 , 2141 , 2143 , 2153 , 2161 , 2179 , 2203 , 2207 , 2213 , 2221 , 2237 , 2239 , 2243 , 2251 , 2267 , 2269 , 2273 , 2281 , 2287 , 2293 , 2297 , 2309 , 2311 , 2333 , 2339 , 2341 , 2347 , 2351 , 2357 , 2371 , 2377 , 2381 , 2383 , 2389 , 2393 , 2399 , 2411 , 2417 , 2423 , 2437 , 2441 , 2447 , 2459 , 2467 , 2473 , 2477 , 2503 , 2521 , 2531 , 2539 , 2543 , 2549 , 2551 , 2557 , 2579 , 2591 , 2593 , 2609 , 2617 , 2621 , 2633 , 2647 , 2657 , 2659 , 2663 , 2671 , 2677 , 2683 , 2687 , 2689 , 2693 , 2699 , 2707 , 2711 , 2713 , 2719 , 2729 , 2731 , 2741 , 2749 , 2753 , 2767 , 2777 , 2789 , 2791 , 2797 , 2801 , 2803 , 2819 , 2833 , 2837 , 2843 , 2851 , 2857 , 2861 , 2879 , 2887 , 2897 , 2903 , 2909 , 2917 , 2927 , 2939 , 2953 , 2957 , 2963 , 2969 , 2971 , 2999 , 3001 , 3011 , 3019 , 3023 , 3037 , 3041 , 3049 , 3061 , 3067 , 3079 , 3083 , 3089 , 3109 , 3119 , 3121 , 3137 , 3163 , 3167 , 3169 , 3181 , 3187 , 3191 , 3203 , 3209 , 3217 , 3221 , 3229 , 3251 , 3253 , 3257 , 3259 , 3271 , 3299 , 3301 , 3307 , 3313 , 3319 , 3323 , 3329 , 3331 , 3343 , 3347 , 3359 , 3361 , 3371 , 3373 , 3389 , 3391 , 3407 , 3413 , 3433 , 3449 , 3457 , 3461 , 3463 , 3467 , 3469 , 3491 , 3499 , 3511 , 3517 , 3527 , 3529 , 3533 , 3539 , 3541 , 3547 , 3557 , 3559 , 3571 , 3581 , 3583 , 3593 , 3607 , 3613 , 3617 , 3623 , 3631 , 3637 , 3643 , 3659 , 3671 , 3673 , 3677 , 3691 , 3697 , 3701 , 3709 , 3719 , 3727 , 3733 , 3739 , 3761 , 3767 , 3769 , 3779 , 3793 , 3797 , 3803 , 3821 , 3823 , 3833 , 3847 , 3851 , 3853 , 3863 , 3877 , 3881 , 3889 , 3907 , 3911 , 3917 , 3919 , 3923 , 3929 , 3931 , 3943 , 3947 , 3967 , 3989 , 4001 , 4003 , 4007 , 4013 , 4019 , 4021 , 4027 , 4049 , 4051 , 4057 , 4073 , 4079 , 4091 , 4093 , 4099 , 4111 , 4127 , 4129 , 4133 , 4139 , 4153 , 4157 , 4159 , 4177 , 4201 , 4211 , 4217 , 4219 , 4229 , 4231 , 4241 , 4243 , 4253 , 4259 , 4261 , 4271 , 4273 , 4283 , 4289 , 4297 , 4327 , 4337 , 4339 , 4349 , 4357 , 4363 , 4373 , 4391 , 4397 , 4409 , 4421 , 4423 , 4441 , 4447 , 4451 , 4457 , 4463 , 4481 , 4483 , 4493 , 4507 , 4513 , 4517 , 4519 , 4523 , 4547 , 4549 , 4561 , 4567 , 4583 , 4591 , 4597 , 4603 , 4621 , 4637 , 4639 , 4643 , 4649 , 4651 , 4657 , 4663 , 4673 , 4679 , 4691 , 4703 , 4721 , 4723 , 4729 , 4733 , 4751 , 4759 , 4783 , 4787 , 4789 , 4793 , 4799 , 4801 , 4813 , 4817 , 4831 , 4861 , 4871 , 4877 , 4889 , 4903 , 4909 , 4919 , 4931 , 4933 , 4937 , 4943 , 4951 , 4957 , 4967 , 4969 , 4973 , 4987 , 4993 , 4999 , 5003 , 5009 , 5011 , 5021 , 5023 , 5039 , 5051 , 5059 , 5077 , 5081 , 5087 , 5099 , 5101 , 5107 , 5113 , 5119 , 5147 , 5153 , 5167 , 5171 , 5179 , 5189 , 5197 , 5209 , 5227 , 5231 , 5233 , 5237 , 5261 , 5273 , 5279 , 5281 , 5297 , 5303 , 5309 , 5323 , 5333 , 5347 , 5351 , 5381 , 5387 , 5393 , 5399 , 5407 , 5413 , 5417 , 5419 , 5431 , 5437 , 5441 , 5443 , 5449 , 5471 , 5477 , 5479 , 5483 , 5501 , 5503 , 5507 , 5519 , 5521 , 5527 , 5531 , 5557 , 5563 , 5569 , 5573 , 5581 , 5591 , 5623 , 5639 , 5641 , 5647 , 5651 , 5653 , 5657 , 5659 , 5669 , 5683 , 5689 , 5693 , 5701 , 5711 , 5717 , 5737 , 5741 , 5743 , 5749 , 5779 , 5783 , 5791 , 5801 , 5807 , 5813 , 5821 , 5827 , 5839 , 5843 , 5849 , 5851 , 5857 , 5861 , 5867 , 5869 , 5879 , 5881 , 5897 , 5903 , 5923 , 5927 , 5939 , 5953 , 5981 , 5987 , 6007 , 6011 , 6029 , 6037 , 6043 , 6047 , 6053 , 6067 , 6073 , 6079 , 6089 , 6091 , 6101 , 6113 , 6121 , 6131 , 6133 , 6143 , 6151 , 6163 , 6173 , 6197 , 6199 , 6203 , 6211 , 6217 , 6221 , 6229 , 6247 , 6257 , 6263 , 6269 , 6271 , 6277 , 6287 , 6299 , 6301 , 6311 , 6317 , 6323 , 6329 , 6337 , 6343 , 6353 , 6359 , 6361 , 6367 , 6373 , 6379 , 6389 , 6397 , 6421 , 6427 , 6449 , 6451 , 6469 , 6473 , 6481 , 6491 , 6521 , 6529 , 6547 , 6551 , 6553 , 6563 , 6569 , 6571 , 6577 , 6581 , 6599 , 6607 , 6619 , 6637 , 6653 , 6659 , 6661 , 6673 , 6679 , 6689 , 6691 , 6701 , 6703 , 6709 , 6719 , 6733 , 6737 , 6761 , 6763 , 6779 , 6781 , 6791 , 6793 , 6803 , 6823 , 6827 , 6829 , 6833 , 6841 , 6857 , 6863 , 6869 , 6871 , 6883 , 6899 , 6907 , 6911 , 6917 , 6947 , 6949 , 6959 , 6961 , 6967 , 6971 , 6977 , 6983 , 6991 , 6997 , 7001 , 7013 , 7019 , 7027 , 7039 , 7043 , 7057 , 7069 , 7079 , 7103 , 7109 , 7121 , 7127 , 7129 , 7151 , 7159 , 7177 , 7187 , 7193 , 7207 , 7211 , 7213 , 7219 , 7229 , 7237 , 7243 , 7247 , 7253 , 7283 , 7297 , 7307 , 7309 , 7321 , 7331 , 7333 , 7349 , 7351 , 7369 , 7393 , 7411 , 7417 , 7433 , 7451 , 7457 , 7459 , 7477 , 7481 , 7487 , 7489 , 7499 , 7507 , 7517 , 7523 , 7529 , 7537 , 7541 , 7547 , 7549 , 7559 , 7561 , 7573 , 7577 , 7583 , 7589 , 7591 , 7603 , 7607 , 7621 , 7639 , 7643 , 7649 , 7669 , 7673 , 7681 , 7687 , 7691 , 7699 , 7703 , 7717 , 7723 , 7727 , 7741 , 7753 , 7757 , 7759 , 7789 , 7793 , 7817 , 7823 , 7829 , 7841 , 7853 , 7867 , 7873 , 7877 , 7879 , 7883 , 7901 , 7907 , 7919 , 7927 , 7933 , 7937 , 7949 , 7951 , 7963 , 7993 , 8009 , 8011 , 8017 , 8039 , 8053 , 8059 , 8069 , 8081 , 8087 , 8089 , 8093 , 8101 , 8111 , 8117 , 8123 , 8147 , 8161 , 8167 , 8171 , 8179 , 8191 , 8209 , 8219 , 8221 , 8231 , 8233 , 8237 , 8243 , 8263 , 8269 , 8273 , 8287 , 8291 , 8293 , 8297 , 8311 , 8317 , 8329 , 8353 , 8363 , 8369 , 8377 , 8387 , 8389 , 8419 , 8423 , 8429 , 8431 , 8443 , 8447 , 8461 , 8467 , 8501 , 8513 , 8521 , 8527 , 8537 , 8539 , 8543 , 8563 , 8573 , 8581 , 8597 , 8599 , 8609 , 8623 , 8627 , 8629 , 8641 , 8647 , 8663 , 8669 , 8677 , 8681 , 8689 , 8693 , 8699 , 8707 , 8713 , 8719 , 8731 , 8737 , 8741 , 8747 , 8753 , 8761 , 8779 , 8783 , 8803 , 8807 , 8819 , 8821 , 8831 , 8837 , 8839 , 8849 , 8861 , 8863 , 8867 , 8887 , 8893 , 8923 , 8929 , 8933 , 8941 , 8951 , 8963 , 8969 , 8971 , 8999 , 9001 , 9007 , 9011 , 9013 , 9029 , 9041 , 9043 , 9049 , 9059 , 9067 , 9091 , 9103 , 9109 , 9127 , 9133 , 9137 , 9151 , 9157 , 9161 , 9173 , 9181 , 9187 , 9199 , 9203 , 9209 , 9221 , 9227 , 9239 , 9241 , 9257 , 9277 , 9281 , 9283 , 9293 , 9311 , 9319 , 9323 , 9337 , 9341 , 9343 , 9349 , 9371 , 9377 , 9391 , 9397 , 9403 , 9413 , 9419 , 9421 , 9431 , 9433 , 9437 , 9439 , 9461 , 9463 , 9467 , 9473 , 9479 , 9491 , 9497 , 9511 , 9521 , 9533 , 9539 , 9547 , 9551 , 9587 , 9601 , 9613 , 9619 , 9623 , 9629 , 9631 , 9643 , 9649 , 9661 , 9677 , 9679 , 9689 , 9697 , 9719 , 9721 , 9733 , 9739 , 9743 , 9749 , 9767 , 9769 , 9781 , 9787 , 9791 , 9803 , 9811 , 9817 , 9829 , 9833 , 9839 , 9851 , 9857 , 9859 , 9871 , 9883 , 9887 , 9901 , 9907 , 9923 , 9929 , 9931 , 9941 , 9949 , 9967 , 9973 , 10007 , 10009 , 10037 , 10039 , 10061 , 10067 , 10069 , 10079 , 10091 , 10093 , 10099 , 10103 , 10111 , 10133 , 10139 , 10141 , 10151 , 10159 , 10163 , 10169 , 10177 , 10181 , 10193 , 10211 , 10223 , 10243 , 10247 , 10253 , 10259 , 10267 , 10271 , 10273 , 10289 , 10301 , 10303 , 10313 , 10321 , 10331 , 10333 , 10337 , 10343 , 10357 , 10369 , 10391 , 10399 , 10427 , 10429 , 10433 , 10453 , 10457 , 10459 , 10463 , 10477 , 10487 , 10499 , 10501 , 10513 , 10529 , 10531 , 10559 , 10567 , 10589 , 10597 , 10601 , 10607 , 10613 , 10627 , 10631 , 10639 , 10651 , 10657 , 10663 , 10667 , 10687 , 10691 , 10709 , 10711 , 10723 , 10729 , 10733 , 10739 , 10753 , 10771 , 10781 , 10789 , 10799 , 10831 , 10837 , 10847 , 10853 , 10859 , 10861 , 10867 , 10883 , 10889 , 10891 , 10903 , 10909 , 10937 , 10939 , 10949 , 10957 , 10973 , 10979 , 10987 , 10993 , 11003 , 11027 , 11047 , 11057 , 11059 , 11069 , 11071 , 11083 , 11087 , 11093 , 11113 , 11117 , 11119 , 11131 , 11149 , 11159 , 11161 , 11171 , 11173 , 11177 , 11197 , 11213 , 11239 , 11243 , 11251 , 11257 , 11261 , 11273 , 11279 , 11287 , 11299 , 11311 , 11317 , 11321 , 11329 , 11351 , 11353 , 11369 , 11383 , 11393 , 11399 , 11411 , 11423 , 11437 , 11443 , 11447 , 11467 , 11471 , 11483 , 11489 , 11491 , 11497 , 11503 , 11519 , 11527 , 11549 , 11551 , 11579 , 11587 , 11593 , 11597 , 11617 , 11621 , 11633 , 11657 , 11677 , 11681 , 11689 , 11699 , 11701 , 11717 , 11719 , 11731 , 11743 , 11777 , 11779 , 11783 , 11789 , 11801 , 11807 , 11813 , 11821 , 11827 , 11831 , 11833 , 11839 , 11863 , 11867 , 11887 , 11897 , 11903 , 11909 , 11923 , 11927 , 11933 , 11939 , 11941 , 11953 , 11959 , 11969 , 11971 , 11981 , 11987 , 12007 , 12011 , 12037 , 12041 , 12043 , 12049 , 12071 , 12073 , 12097 , 12101 , 12107 , 12109 , 12113 , 12119 , 12143 , 12149 , 12157 , 12161 , 12163 , 12197 , 12203 , 12211 , 12227 , 12239 , 12241 , 12251 , 12253 , 12263 , 12269 , 12277 , 12281 , 12289 , 12301 , 12323 , 12329 , 12343 , 12347 , 12373 , 12377 , 12379 , 12391 , 12401 , 12409 , 12413 , 12421 , 12433 , 12437 , 12451 , 12457 , 12473 , 12479 , 12487 , 12491 , 12497 , 12503 , 12511 , 12517 , 12527 , 12539 , 12541 , 12547 , 12553 , 12569 , 12577 , 12583 , 12589 , 12601 , 12611 , 12613 , 12619 , 12637 , 12641 , 12647 , 12653 , 12659 , 12671 , 12689 , 12697 , 12703 , 12713 , 12721 , 12739 , 12743 , 12757 , 12763 , 12781 , 12791 , 12799 , 12809 , 12821 , 12823 , 12829 , 12841 , 12853 , 12889 , 12893 , 12899 , 12907 , 12911 , 12917 , 12919 , 12923 , 12941 , 12953 , 12959 , 12967 , 12973 , 12979 , 12983 , 13001 , 13003 , 13007 , 13009 , 13033 , 13037 , 13043 , 13049 , 13063 , 13093 , 13099 , 13103 , 13109 , 13121 , 13127 , 13147 , 13151 , 13159 , 13163 , 13171 , 13177 , 13183 , 13187 , 13217 , 13219 , 13229 , 13241 , 13249 , 13259 , 13267 , 13291 , 13297 , 13309 , 13313 , 13327 , 13331 , 13337 , 13339 , 13367 , 13381 , 13397 , 13399 , 13411 , 13417 , 13421 , 13441 , 13451 , 13457 , 13463 , 13469 , 13477 , 13487 , 13499 , 13513 , 13523 , 13537 , 13553 , 13567 , 13577 , 13591 , 13597 , 13613 , 13619 , 13627 , 13633 , 13649 , 13669 , 13679 , 13681 , 13687 , 13691 , 13693 , 13697 , 13709 , 13711 , 13721 , 13723 , 13729 , 13751 , 13757 , 13759 , 13763 , 13781 , 13789 , 13799 , 13807 , 13829 , 13831 , 13841 , 13859 , 13873 , 13877 , 13879 , 13883 , 13901 , 13903 , 13907 , 13913 , 13921 , 13931 , 13933 , 13963 , 13967 , 13997 , 13999 , 14009 , 14011 , 14029 , 14033 , 14051 , 14057 , 14071 , 14081 , 14083 , 14087 , 14107 , 14143 , 14149 , 14153 , 14159 , 14173 , 14177 , 14197 , 14207 , 14221 , 14243 , 14249 , 14251 , 14281 , 14293 , 14303 , 14321 , 14323 , 14327 , 14341 , 14347 , 14369 , 14387 , 14389 , 14401 , 14407 , 14411 , 14419 , 14423 , 14431 , 14437 , 14447 , 14449 , 14461 , 14479 , 14489 , 14503 , 14519 , 14533 , 14537 , 14543 , 14549 , 14551 , 14557 , 14561 , 14563 , 14591 , 14593 , 14621 , 14627 , 14629 , 14633 , 14639 , 14653 , 14657 , 14669 , 14683 , 14699 , 14713 , 14717 , 14723 , 14731 , 14737 , 14741 , 14747 , 14753 , 14759 , 14767 , 14771 , 14779 , 14783 , 14797 , 14813 , 14821 , 14827 , 14831 , 14843 , 14851 , 14867 , 14869 , 14879 , 14887 , 14891 , 14897 , 14923 , 14929 , 14939 , 14947 , 14951 , 14957 , 14969 , 14983 , 15013 , 15017 , 15031 , 15053 , 15061 , 15073 , 15077 , 15083 , 15091 , 15101 , 15107 , 15121 , 15131 , 15137 , 15139 , 15149 , 15161 , 15173 , 15187 , 15193 , 15199 , 15217 , 15227 , 15233 , 15241 , 15259 , 15263 , 15269 , 15271 , 15277 , 15287 , 15289 , 15299 , 15307 , 15313 , 15319 , 15329 , 15331 , 15349 , 15359 , 15361 , 15373 , 15377 , 15383 , 15391 , 15401 , 15413 , 15427 , 15439 , 15443 , 15451 , 15461 , 15467 , 15473 , 15493 , 15497 , 15511 , 15527 , 15541 , 15551 , 15559 , 15569 , 15581 , 15583 , 15601 , 15607 , 15619 , 15629 , 15641 , 15643 , 15647 , 15649 , 15661 , 15667 , 15671 , 15679 , 15683 , 15727 , 15731 , 15733 , 15737 , 15739 , 15749 , 15761 , 15767 , 15773 , 15787 , 15791 , 15797 , 15803 , 15809 , 15817 , 15823 , 15859 , 15877 , 15881 , 15887 , 15889 , 15901 , 15907 , 15913 , 15919 , 15923 , 15937 , 15959 , 15971 , 15973 , 15991 , 16001 , 16007 , 16033 , 16057 , 16061 , 16063 , 16067 , 16069 , 16073 , 16087 , 16091 , 16097 , 16103 , 16111 , 16127 , 16139 , 16141 , 16183 , 16187 , 16189 , 16193 , 16217 , 16223 , 16229 , 16231 , 16249 , 16253 , 16267 , 16273 , 16301 , 16319 , 16333 , 16339 , 16349 , 16361 , 16363 , 16369 , 16381 , 16411 , 16417 , 16421 , 16427 , 16433 , 16447 , 16451 , 16453 , 16477 , 16481 , 16487 , 16493 , 16519 , 16529 , 16547 , 16553 , 16561 , 16567 , 16573 , 16603 , 16607 , 16619 , 16631 , 16633 , 16649 , 16651 , 16657 , 16661 , 16673 , 16691 , 16693 , 16699 , 16703 , 16729 , 16741 , 16747 , 16759 , 16763 , 16787 , 16811 , 16823 , 16829 , 16831 , 16843 , 16871 , 16879 , 16883 , 16889 , 16901 , 16903 , 16921 , 16927 , 16931 , 16937 , 16943 , 16963 , 16979 , 16981 , 16987 , 16993 , 17011 , 17021 , 17027 , 17029 , 17033 , 17041 , 17047 , 17053 , 17077 , 17093 , 17099 , 17107 , 17117 , 17123 , 17137 , 17159 , 17167 , 17183 , 17189 , 17191 , 17203 , 17207 , 17209 , 17231 , 17239 , 17257 , 17291 , 17293 , 17299 , 17317 , 17321 , 17327 , 17333 , 17341 , 17351 , 17359 , 17377 , 17383 , 17387 , 17389 , 17393 , 17401 , 17417 , 17419 , 17431 , 17443 , 17449 , 17467 , 17471 , 17477 , 17483 , 17489 , 17491 , 17497 , 17509 , 17519 , 17539 , 17551 , 17569 , 17573 , 17579 , 17581 , 17597 , 17599 , 17609 , 17623 , 17627 , 17657 , 17659 , 17669 , 17681 , 17683 , 17707 , 17713 , 17729 , 17737 , 17747 , 17749 , 17761 , 17783 , 17789 , 17791 , 17807 , 17827 , 17837 , 17839 , 17851 , 17863 , 17881 , 17891 , 17903 , 17909 , 17911 , 17921 , 17923 , 17929 , 17939 , 17957 , 17959 , 17971 , 17977 , 17981 , 17987 , 17989 , 18013 , 18041 , 18043 , 18047 , 18049 , 18059 , 18061 , 18077 , 18089 , 18097 , 18119 , 18121 , 18127 , 18131 , 18133 , 18143 , 18149 , 18169 , 18181 , 18191 , 18199 , 18211 , 18217 , 18223 , 18229 , 18233 , 18251 , 18253 , 18257 , 18269 , 18287 , 18289 , 18301 , 18307 , 18311 , 18313 , 18329 , 18341 , 18353 , 18367 , 18371 , 18379 , 18397 , 18401 , 18413 , 18427 , 18433 , 18439 , 18443 , 18451 , 18457 , 18461 , 18481 , 18493 , 18503 , 18517 , 18521 , 18523 , 18539 , 18541 , 18553 , 18583 , 18587 , 18593 , 18617 , 18637 , 18661 , 18671 , 18679 , 18691 , 18701 , 18713 , 18719 , 18731 , 18743 , 18749 , 18757 , 18773 , 18787 , 18793 , 18797 , 18803 , 18839 , 18859 , 18869 , 18899 , 18911 , 18913 , 18917 , 18919 , 18947 , 18959 , 18973 , 18979 , 19001 , 19009 , 19013 , 19031 , 19037 , 19051 , 19069 , 19073 , 19079 , 19081 , 19087 , 19121 , 19139 , 19141 , 19157 , 19163 , 19181 , 19183 , 19207 , 19211 , 19213 , 19219 , 19231 , 19237 , 19249 , 19259 , 19267 , 19273 , 19289 , 19301 , 19309 , 19319 , 19333 , 19373 , 19379 , 19381 , 19387 , 19391 , 19403 , 19417 , 19421 , 19423 , 19427 , 19429 , 19433 , 19441 , 19447 , 19457 , 19463 , 19469 , 19471 , 19477 , 19483 , 19489 , 19501 , 19507 , 19531 , 19541 , 19543 , 19553 , 19559 , 19571 , 19577 , 19583 , 19597 , 19603 , 19609 , 19661 , 19681 , 19687 , 19697 , 19699 , 19709 , 19717 , 19727 , 19739 , 19751 , 19753 , 19759 , 19763 , 19777 , 19793 , 19801 , 19813 , 19819 , 19841 , 19843 , 19853 , 19861 , 19867 , 19889 , 19891 , 19913 , 19919 , 19927 , 19937 , 19949 , 19961 , 19963 , 19973 , 19979 , 19991 , 19993 , 19997 , 20011 , 20021 , 20023 , 20029 , 20047 , 20051 , 20063 , 20071 , 20089 , 20101 , 20107 , 20113 , 20117 , 20123 , 20129 , 20143 , 20147 , 20149 , 20161 , 20173 , 20177 , 20183 , 20201 , 20219 , 20231 , 20233 , 20249 , 20261 , 20269 , 20287 , 20297 , 20323 , 20327 , 20333 , 20341 , 20347 , 20353 , 20357 , 20359 , 20369 , 20389 , 20393 , 20399 , 20407 , 20411 , 20431 , 20441 , 20443 , 20477 , 20479 , 20483 , 20507 , 20509 , 20521 , 20533 , 20543 , 20549 , 20551 , 20563 , 20593 , 20599 , 20611 , 20627 , 20639 , 20641 , 20663 , 20681 , 20693 , 20707 , 20717 , 20719 , 20731 , 20743 , 20747 , 20749 , 20753 , 20759 , 20771 , 20773 , 20789 , 20807 , 20809 , 20849 , 20857 , 20873 , 20879 , 20887 , 20897 , 20899 , 20903 , 20921 , 20929 , 20939 , 20947 , 20959 , 20963 , 20981 , 20983 , 21001 , 21011 , 21013 , 21017 , 21019 , 21023 , 21031 , 21059 , 21061 , 21067 , 21089 , 21101 , 21107 , 21121 , 21139 , 21143 , 21149 , 21157 , 21163 , 21169 , 21179 , 21187 , 21191 , 21193 , 21211 , 21221 , 21227 , 21247 , 21269 , 21277 , 21283 , 21313 , 21317 , 21319 , 21323 , 21341 , 21347 , 21377 , 21379 , 21383 , 21391 , 21397 , 21401 , 21407 , 21419 , 21433 , 21467 , 21481 , 21487 , 21491 , 21493 , 21499 , 21503 , 21517 , 21521 , 21523 , 21529 , 21557 , 21559 , 21563 , 21569 , 21577 , 21587 , 21589 , 21599 , 21601 , 21611 , 21613 , 21617 , 21647 , 21649 , 21661 , 21673 , 21683 , 21701 , 21713 , 21727 , 21737 , 21739 , 21751 , 21757 , 21767 , 21773 , 21787 , 21799 , 21803 , 21817 , 21821 , 21839 , 21841 , 21851 , 21859 , 21863 , 21871 , 21881 , 21893 , 21911 , 21929 , 21937 , 21943 , 21961 , 21977 , 21991 , 21997 , 22003 , 22013 , 22027 , 22031 , 22037 , 22039 , 22051 , 22063 , 22067 , 22073 , 22079 , 22091 , 22093 , 22109 , 22111 , 22123 , 22129 , 22133 , 22147 , 22153 , 22157 , 22159 , 22171 , 22189 , 22193 , 22229 , 22247 , 22259 , 22271 , 22273 , 22277 , 22279 , 22283 , 22291 , 22303 , 22307 , 22343 , 22349 , 22367 , 22369 , 22381 , 22391 , 22397 , 22409 , 22433 , 22441 , 22447 , 22453 , 22469 , 22481 , 22483 , 22501 , 22511 , 22531 , 22541 , 22543 , 22549 , 22567 , 22571 , 22573 , 22613 , 22619 , 22621 , 22637 , 22639 , 22643 , 22651 , 22669 , 22679 , 22691 , 22697 , 22699 , 22709 , 22717 , 22721 , 22727 , 22739 , 22741 , 22751 , 22769 , 22777 , 22783 , 22787 , 22807 , 22811 , 22817 , 22853 , 22859 , 22861 , 22871 , 22877 , 22901 , 22907 , 22921 , 22937 , 22943 , 22961 , 22963 , 22973 , 22993 , 23003 , 23011 , 23017 , 23021 , 23027 , 23029 , 23039 , 23041 , 23053 , 23057 , 23059 , 23063 , 23071 , 23081 , 23087 , 23099 , 23117 , 23131 , 23143 , 23159 , 23167 , 23173 , 23189 , 23197 , 23201 , 23203 , 23209 , 23227 , 23251 , 23269 , 23279 , 23291 , 23293 , 23297 , 23311 , 23321 , 23327 , 23333 , 23339 , 23357 , 23369 , 23371 , 23399 , 23417 , 23431 , 23447 , 23459 , 23473 , 23497 , 23509 , 23531 , 23537 , 23539 , 23549 , 23557 , 23561 , 23563 , 23567 , 23581 , 23593 , 23599 , 23603 , 23609 , 23623 , 23627 , 23629 , 23633 , 23663 , 23669 , 23671 , 23677 , 23687 , 23689 , 23719 , 23741 , 23743 , 23747 , 23753 , 23761 , 23767 , 23773 , 23789 , 23801 , 23813 , 23819 , 23827 , 23831 , 23833 , 23857 , 23869 , 23873 , 23879 , 23887 , 23893 , 23899 , 23909 , 23911 , 23917 , 23929 , 23957 , 23971 , 23977 , 23981 , 23993 , 24001 , 24007 , 24019 , 24023 , 24029 , 24043 , 24049 , 24061 , 24071 , 24077 , 24083 , 24091 , 24097 , 24103 , 24107 , 24109 , 24113 , 24121 , 24133 , 24137 , 24151 , 24169 , 24179 , 24181 , 24197 , 24203 , 24223 , 24229 , 24239 , 24247 , 24251 , 24281 , 24317 , 24329 , 24337 , 24359 , 24371 , 24373 , 24379 , 24391 , 24407 , 24413 , 24419 , 24421 , 24439 , 24443 , 24469 , 24473 , 24481 , 24499 , 24509 , 24517 , 24527 , 24533 , 24547 , 24551 , 24571 , 24593 , 24611 , 24623 , 24631 , 24659 , 24671 , 24677 , 24683 , 24691 , 24697 , 24709 , 24733 , 24749 , 24763 , 24767 , 24781 , 24793 , 24799 , 24809 , 24821 , 24841 , 24847 , 24851 , 24859 , 24877 , 24889 , 24907 , 24917 , 24919 , 24923 , 24943 , 24953 , 24967 , 24971 , 24977 , 24979 , 24989 , 25013 , 25031 , 25033 , 25037 , 25057 , 25073 , 25087 , 25097 , 25111 , 25117 , 25121 , 25127 , 25147 , 25153 , 25163 , 25169 , 25171 , 25183 , 25189 , 25219 , 25229 , 25237 , 25243 , 25247 , 25253 , 25261 , 25301 , 25303 , 25307 , 25309 , 25321 , 25339 , 25343 , 25349 , 25357 , 25367 , 25373 , 25391 , 25409 , 25411 , 25423 , 25439 , 25447 , 25453 , 25457 , 25463 , 25469 , 25471 , 25523 , 25537 , 25541 , 25561 , 25577 , 25579 , 25583 , 25589 , 25601 , 25603 , 25609 , 25621 , 25633 , 25639 , 25643 , 25657 , 25667 , 25673 , 25679 , 25693 , 25703 , 25717 , 25733 , 25741 , 25747 , 25759 , 25763 , 25771 , 25793 , 25799 , 25801 , 25819 , 25841 , 25847 , 25849 , 25867 , 25873 , 25889 , 25903 , 25913 , 25919 , 25931 , 25933 , 25939 , 25943 , 25951 , 25969 , 25981 , 25997 , 25999 , 26003 , 26017 , 26021 , 26029 , 26041 , 26053 , 26083 , 26099 , 26107 , 26111 , 26113 , 26119 , 26141 , 26153 , 26161 , 26171 , 26177 , 26183 , 26189 , 26203 , 26209 , 26227 , 26237 , 26249 , 26251 , 26261 , 26263 , 26267 , 26293 , 26297 , 26309 , 26317 , 26321 , 26339 , 26347 , 26357 , 26371 , 26387 , 26393 , 26399 , 26407 , 26417 , 26423 , 26431 , 26437 , 26449 , 26459 , 26479 , 26489 , 26497 , 26501 , 26513 , 26539 , 26557 , 26561 , 26573 , 26591 , 26597 , 26627 , 26633 , 26641 , 26647 , 26669 , 26681 , 26683 , 26687 , 26693 , 26699 , 26701 , 26711 , 26713 , 26717 , 26723 , 26729 , 26731 , 26737 , 26759 , 26777 , 26783 , 26801 , 26813 , 26821 , 26833 , 26839 , 26849 , 26861 , 26863 , 26879 , 26881 , 26891 , 26893 , 26903 , 26921 , 26927 , 26947 , 26951 , 26953 , 26959 , 26981 , 26987 , 26993 , 27011 , 27017 , 27031 , 27043 , 27059 , 27061 , 27067 , 27073 , 27077 , 27091 , 27103 , 27107 , 27109 , 27127 , 27143 , 27179 , 27191 , 27197 , 27211 , 27239 , 27241 , 27253 , 27259 , 27271 , 27277 , 27281 , 27283 , 27299 , 27329 , 27337 , 27361 , 27367 , 27397 , 27407 , 27409 , 27427 , 27431 , 27437 , 27449 , 27457 , 27479 , 27481 , 27487 , 27509 , 27527 , 27529 , 27539 , 27541 , 27551 , 27581 , 27583 , 27611 , 27617 , 27631 , 27647 , 27653 , 27673 , 27689 , 27691 , 27697 , 27701 , 27733 , 27737 , 27739 , 27743 , 27749 , 27751 , 27763 , 27767 , 27773 , 27779 , 27791 , 27793 , 27799 , 27803 , 27809 , 27817 , 27823 , 27827 , 27847 , 27851 , 27883 , 27893 , 27901 , 27917 , 27919 , 27941 , 27943 , 27947 , 27953 , 27961 , 27967 , 27983 , 27997 , 28001 , 28019 , 28027 , 28031 , 28051 , 28057 , 28069 , 28081 , 28087 , 28097 , 28099 , 28109 , 28111 , 28123 , 28151 , 28163 , 28181 , 28183 , 28201 , 28211 , 28219 , 28229 , 28277 , 28279 , 28283 , 28289 , 28297 , 28307 , 28309 , 28319 , 28349 , 28351 , 28387 , 28393 , 28403 , 28409 , 28411 , 28429 , 28433 , 28439 , 28447 , 28463 , 28477 , 28493 , 28499 , 28513 , 28517 , 28537 , 28541 , 28547 , 28549 , 28559 , 28571 , 28573 , 28579 , 28591 , 28597 , 28603 , 28607 , 28619 , 28621 , 28627 , 28631 , 28643 , 28649 , 28657 , 28661 , 28663 , 28669 , 28687 , 28697 , 28703 , 28711 , 28723 , 28729 , 28751 , 28753 , 28759 , 28771 , 28789 , 28793 , 28807 , 28813 , 28817 , 28837 , 28843 , 28859 , 28867 , 28871 , 28879 , 28901 , 28909 , 28921 , 28927 , 28933 , 28949 , 28961 , 28979 , 29009 , 29017 , 29021 , 29023 , 29027 , 29033 , 29059 , 29063 , 29077 , 29101 , 29123 , 29129 , 29131 , 29137 , 29147 , 29153 , 29167 , 29173 , 29179 , 29191 , 29201 , 29207 , 29209 , 29221 , 29231 , 29243 , 29251 , 29269 , 29287 , 29297 , 29303 , 29311 , 29327 , 29333 , 29339 , 29347 , 29363 , 29383 , 29387 , 29389 , 29399 , 29401 , 29411 , 29423 , 29429 , 29437 , 29443 , 29453 , 29473 , 29483 , 29501 , 29527 , 29531 , 29537 , 29567 , 29569 , 29573 , 29581 , 29587 , 29599 , 29611 , 29629 , 29633 , 29641 , 29663 , 29669 , 29671 , 29683 , 29717 , 29723 , 29741 , 29753 , 29759 , 29761 , 29789 , 29803 , 29819 , 29833 , 29837 , 29851 , 29863 , 29867 , 29873 , 29879 , 29881 , 29917 , 29921 , 29927 , 29947 , 29959 , 29983 , 29989 , 30011 , 30013 , 30029 , 30047 , 30059 , 30071 , 30089 , 30091 , 30097 , 30103 , 30109 , 30113 , 30119 , 30133 , 30137 , 30139 , 30161 , 30169 , 30181 , 30187 , 30197 , 30203 , 30211 , 30223 , 30241 , 30253 , 30259 , 30269 , 30271 , 30293 , 30307 , 30313 , 30319 , 30323 , 30341 , 30347 , 30367 , 30389 , 30391 , 30403 , 30427 , 30431 , 30449 , 30467 , 30469 , 30491 , 30493 , 30497 , 30509 , 30517 , 30529 , 30539 , 30553 , 30557 , 30559 , 30577 , 30593 , 30631 , 30637 , 30643 , 30649 , 30661 , 30671 , 30677 , 30689 , 30697 , 30703 , 30707 , 30713 , 30727 , 30757 , 30763 , 30773 , 30781 , 30803 , 30809 , 30817 , 30829 , 30839 , 30841 , 30851 , 30853 , 30859 , 30869 , 30871 , 30881 , 30893 , 30911 , 30931 , 30937 , 30941 , 30949 , 30971 , 30977 , 30983 , 31013 , 31019 , 31033 , 31039 , 31051 , 31063 , 31069 , 31079 , 31081 , 31091 , 31121 , 31123 , 31139 , 31147 , 31151 , 31153 , 31159 , 31177 , 31181 , 31183 , 31189 , 31193 , 31219 , 31223 , 31231 , 31237 , 31247 , 31249 , 31253 , 31259 , 31267 , 31271 , 31277 , 31307 , 31319 , 31321 , 31327 , 31333 , 31337 , 31357 , 31379 , 31387 , 31391 , 31393 , 31397 , 31469 , 31477 , 31481 , 31489 , 31511 , 31513 , 31517 , 31531 , 31541 , 31543 , 31547 , 31567 , 31573 , 31583 , 31601 , 31607 , 31627 , 31643 , 31649 , 31657 , 31663 , 31667 , 31687 , 31699 , 31721 , 31723 , 31727 , 31729 , 31741 , 31751 , 31769 , 31771 , 31793 , 31799 , 31817 , 31847 , 31849 , 31859 , 31873 , 31883 , 31891 , 31907 , 31957 , 31963 , 31973 , 31981 , 31991 , 32003 , 32009 , 32027 , 32029 , 32051 , 32057 , 32059 , 32063 , 32069 , 32077 , 32083 , 32089 , 32099 , 32117 , 32119 , 32141 , 32143 , 32159 , 32173 , 32183 , 32189 , 32191 , 32203 , 32213 , 32233 , 32237 , 32251 , 32257 , 32261 , 32297 , 32299 , 32303 , 32309 , 32321 , 32323 , 32327 , 32341 , 32353 , 32359 , 32363 , 32369 , 32371 , 32377 , 32381 , 32401 , 32411 , 32413 , 32423 , 32429 , 32441 , 32443 , 32467 , 32479 , 32491 , 32497 , 32503 , 32507 , 32531 , 32533 , 32537 , 32561 , 32563 , 32569 , 32573 , 32579 , 32587 , 32603 , 32609 , 32611 , 32621 , 32633 , 32647 , 32653 , 32687 , 32693 , 32707 , 32713 , 32717 , 32719 , 32749 , 32771 , 32779 , 32783 , 32789 , 32797 , 32801 , 32803 , 32831 , 32833 , 32839 , 32843 , 32869 , 32887 , 32909 , 32911 , 32917 , 32933 , 32939 , 32941 , 32957 , 32969 , 32971 , 32983 , 32987 , 32993 , 32999 , 33013 , 33023 , 33029 , 33037 , 33049 , 33053 , 33071 , 33073 , 33083 , 33091 , 33107 , 33113 , 33119 , 33149 , 33151 , 33161 , 33179 , 33181 , 33191 , 33199 , 33203 , 33211 , 33223 , 33247 , 33287 , 33289 , 33301 , 33311 , 33317 , 33329 , 33331 , 33343 , 33347 , 33349 , 33353 , 33359 , 33377 , 33391 , 33403 , 33409 , 33413 , 33427 , 33457 , 33461 , 33469 , 33479 , 33487 , 33493 , 33503 , 33521 , 33529 , 33533 , 33547 , 33563 , 33569 , 33577 , 33581 , 33587 , 33589 , 33599 , 33601 , 33613 , 33617 , 33619 , 33623 , 33629 , 33637 , 33641 , 33647 , 33679 , 33703 , 33713 , 33721 , 33739 , 33749 , 33751 , 33757 , 33767 , 33769 , 33773 , 33791 , 33797 , 33809 , 33811 , 33827 , 33829 , 33851 , 33857 , 33863 , 33871 , 33889 , 33893 , 33911 , 33923 , 33931 , 33937 , 33941 , 33961 , 33967 , 33997 , 34019 , 34031 , 34033 , 34039 , 34057 , 34061 , 34123 , 34127 , 34129 , 34141 , 34147 , 34157 , 34159 , 34171 , 34183 , 34211 , 34213 , 34217 , 34231 , 34253 , 34259 , 34261 , 34267 , 34273 , 34283 , 34297 , 34301 , 34303 , 34313 , 34319 , 34327 , 34337 , 34351 , 34361 , 34367 , 34369 , 34381 , 34403 , 34421 , 34429 , 34439 , 34457 , 34469 , 34471 , 34483 , 34487 , 34499 , 34501 , 34511 , 34513 , 34519 , 34537 , 34543 , 34549 , 34583 , 34589 , 34591 , 34603 , 34607 , 34613 , 34631 , 34649 , 34651 , 34667 , 34673 , 34679 , 34687 , 34693 , 34703 , 34721 , 34729 , 34739 , 34747 , 34757 , 34759 , 34763 , 34781 , 34807 , 34819 , 34841 , 34843 , 34847 , 34849 , 34871 , 34877 , 34883 , 34897 , 34913 , 34919 , 34939 , 34949 , 34961 , 34963 , 34981 , 35023 , 35027 , 35051 , 35053 , 35059 , 35069 , 35081 , 35083 , 35089 , 35099 , 35107 , 35111 , 35117 , 35129 , 35141 , 35149 , 35153 , 35159 , 35171 , 35201 , 35221 , 35227 , 35251 , 35257 , 35267 , 35279 , 35281 , 35291 , 35311 , 35317 , 35323 , 35327 , 35339 , 35353 , 35363 , 35381 , 35393 , 35401 , 35407 , 35419 , 35423 , 35437 , 35447 , 35449 , 35461 , 35491 , 35507 , 35509 , 35521 , 35527 , 35531 , 35533 , 35537 , 35543 , 35569 , 35573 , 35591 , 35593 , 35597 , 35603 , 35617 , 35671 , 35677 , 35729 , 35731 , 35747 , 35753 , 35759 , 35771 , 35797 , 35801 , 35803 , 35809 , 35831 , 35837 , 35839 , 35851 , 35863 , 35869 , 35879 , 35897 , 35899 , 35911 , 35923 , 35933 , 35951 , 35963 , 35969 , 35977 , 35983 , 35993 , 35999 , 36007 , 36011 , 36013 , 36017 , 36037 , 36061 , 36067 , 36073 , 36083 , 36097 , 36107 , 36109 , 36131 , 36137 , 36151 , 36161 , 36187 , 36191 , 36209 , 36217 , 36229 , 36241 , 36251 , 36263 , 36269 , 36277 , 36293 , 36299 , 36307 , 36313 , 36319 , 36341 , 36343 , 36353 , 36373 , 36383 , 36389 , 36433 , 36451 , 36457 , 36467 , 36469 , 36473 , 36479 , 36493 , 36497 , 36523 , 36527 , 36529 , 36541 , 36551 , 36559 , 36563 , 36571 , 36583 , 36587 , 36599 , 36607 , 36629 , 36637 , 36643 , 36653 , 36671 , 36677 , 36683 , 36691 , 36697 , 36709 , 36713 , 36721 , 36739 , 36749 , 36761 , 36767 , 36779 , 36781 , 36787 , 36791 , 36793 , 36809 , 36821 , 36833 , 36847 , 36857 , 36871 , 36877 , 36887 , 36899 , 36901 , 36913 , 36919 , 36923 , 36929 , 36931 , 36943 , 36947 , 36973 , 36979 , 36997 , 37003 , 37013 , 37019 , 37021 , 37039 , 37049 , 37057 , 37061 , 37087 , 37097 , 37117 , 37123 , 37139 , 37159 , 37171 , 37181 , 37189 , 37199 , 37201 , 37217 , 37223 , 37243 , 37253 , 37273 , 37277 , 37307 , 37309 , 37313 , 37321 , 37337 , 37339 , 37357 , 37361 , 37363 , 37369 , 37379 , 37397 , 37409 , 37423 , 37441 , 37447 , 37463 , 37483 , 37489 , 37493 , 37501 , 37507 , 37511 , 37517 , 37529 , 37537 , 37547 , 37549 , 37561 , 37567 , 37571 , 37573 , 37579 , 37589 , 37591 , 37607 , 37619 , 37633 , 37643 , 37649 , 37657 , 37663 , 37691 , 37693 , 37699 , 37717 , 37747 , 37781 , 37783 , 37799 , 37811 , 37813 , 37831 , 37847 , 37853 , 37861 , 37871 , 37879 , 37889 , 37897 , 37907 , 37951 , 37957 , 37963 , 37967 , 37987 , 37991 , 37993 , 37997 , 38011 , 38039 , 38047 , 38053 , 38069 , 38083 , 38113 , 38119 , 38149 , 38153 , 38167 , 38177 , 38183 , 38189 , 38197 , 38201 , 38219 , 38231 , 38237 , 38239 , 38261 , 38273 , 38281 , 38287 , 38299 , 38303 , 38317 , 38321 , 38327 , 38329 , 38333 , 38351 , 38371 , 38377 , 38393 , 38431 , 38447 , 38449 , 38453 , 38459 , 38461 , 38501 , 38543 , 38557 , 38561 , 38567 , 38569 , 38593 , 38603 , 38609 , 38611 , 38629 , 38639 , 38651 , 38653 , 38669 , 38671 , 38677 , 38693 , 38699 , 38707 , 38711 , 38713 , 38723 , 38729 , 38737 , 38747 , 38749 , 38767 , 38783 , 38791 , 38803 , 38821 , 38833 , 38839 , 38851 , 38861 , 38867 , 38873 , 38891 , 38903 , 38917 , 38921 , 38923 , 38933 , 38953 , 38959 , 38971 , 38977 , 38993 , 39019 , 39023 , 39041 , 39043 , 39047 , 39079 , 39089 , 39097 , 39103 , 39107 , 39113 , 39119 , 39133 , 39139 , 39157 , 39161 , 39163 , 39181 , 39191 , 39199 , 39209 , 39217 , 39227 , 39229 , 39233 , 39239 , 39241 , 39251 , 39293 , 39301 , 39313 , 39317 , 39323 , 39341 , 39343 , 39359 , 39367 , 39371 , 39373 , 39383 , 39397 , 39409 , 39419 , 39439 , 39443 , 39451 , 39461 , 39499 , 39503 , 39509 , 39511 , 39521 , 39541 , 39551 , 39563 , 39569 , 39581 , 39607 , 39619 , 39623 , 39631 , 39659 , 39667 , 39671 , 39679 , 39703 , 39709 , 39719 , 39727 , 39733 , 39749 , 39761 , 39769 , 39779 , 39791 , 39799 , 39821 , 39827 , 39829 , 39839 , 39841 , 39847 , 39857 , 39863 , 39869 , 39877 , 39883 , 39887 , 39901 , 39929 , 39937 , 39953 , 39971 , 39979 , 39983 , 39989 , 40009 , 40013 , 40031 , 40037 , 40039 , 40063 , 40087 , 40093 , 40099 , 40111 , 40123 , 40127 , 40129 , 40151 , 40153 , 40163 , 40169 , 40177 , 40189 , 40193 , 40213 , 40231 , 40237 , 40241 , 40253 , 40277 , 40283 , 40289 , 40343 , 40351 , 40357 , 40361 , 40387 , 40423 , 40427 , 40429 , 40433 , 40459 , 40471 , 40483 , 40487 , 40493 , 40499 , 40507 , 40519 , 40529 , 40531 , 40543 , 40559 , 40577 , 40583 , 40591 , 40597 , 40609 , 40627 , 40637 , 40639 , 40693 , 40697 , 40699 , 40709 , 40739 , 40751 , 40759 , 40763 , 40771 , 40787 , 40801 , 40813 , 40819 , 40823 , 40829 , 40841 , 40847 , 40849 , 40853 , 40867 , 40879 , 40883 , 40897 , 40903 , 40927 , 40933 , 40939 , 40949 , 40961 , 40973 , 40993 , 41011 , 41017 , 41023 , 41039 , 41047 , 41051 , 41057 , 41077 , 41081 , 41113 , 41117 , 41131 , 41141 , 41143 , 41149 , 41161 , 41177 , 41179 , 41183 , 41189 , 41201 , 41203 , 41213 , 41221 , 41227 , 41231 , 41233 , 41243 , 41257 , 41263 , 41269 , 41281 , 41299 , 41333 , 41341 , 41351 , 41357 , 41381 , 41387 , 41389 , 41399 , 41411 , 41413 , 41443 , 41453 , 41467 , 41479 , 41491 , 41507 , 41513 , 41519 , 41521 , 41539 , 41543 , 41549 , 41579 , 41593 , 41597 , 41603 , 41609 , 41611 , 41617 , 41621 , 41627 , 41641 , 41647 , 41651 , 41659 , 41669 , 41681 , 41687 , 41719 , 41729 , 41737 , 41759 , 41761 , 41771 , 41777 , 41801 , 41809 , 41813 , 41843 , 41849 , 41851 , 41863 , 41879 , 41887 , 41893 , 41897 , 41903 , 41911 , 41927 , 41941 , 41947 , 41953 , 41957 , 41959 , 41969 , 41981 , 41983 , 41999 , 42013 , 42017 , 42019 , 42023 , 42043 , 42061 , 42071 , 42073 , 42083 , 42089 , 42101 , 42131 , 42139 , 42157 , 42169 , 42179 , 42181 , 42187 , 42193 , 42197 , 42209 , 42221 , 42223 , 42227 , 42239 , 42257 , 42281 , 42283 , 42293 , 42299 , 42307 , 42323 , 42331 , 42337 , 42349 , 42359 , 42373 , 42379 , 42391 , 42397 , 42403 , 42407 , 42409 , 42433 , 42437 , 42443 , 42451 , 42457 , 42461 , 42463 , 42467 , 42473 , 42487 , 42491 , 42499 , 42509 , 42533 , 42557 , 42569 , 42571 , 42577 , 42589 , 42611 , 42641 , 42643 , 42649 , 42667 , 42677 , 42683 , 42689 , 42697 , 42701 , 42703 , 42709 , 42719 , 42727 , 42737 , 42743 , 42751 , 42767 , 42773 , 42787 , 42793 , 42797 , 42821 , 42829 , 42839 , 42841 , 42853 , 42859 , 42863 , 42899 , 42901 , 42923 , 42929 , 42937 , 42943 , 42953 , 42961 , 42967 , 42979 , 42989 , 43003 , 43013 , 43019 , 43037 , 43049 , 43051 , 43063 , 43067 , 43093 , 43103 , 43117 , 43133 , 43151 , 43159 , 43177 , 43189 , 43201 , 43207 , 43223 , 43237 , 43261 , 43271 , 43283 , 43291 , 43313 , 43319 , 43321 , 43331 , 43391 , 43397 , 43399 , 43403 , 43411 , 43427 , 43441 , 43451 , 43457 , 43481 , 43487 , 43499 , 43517 , 43541 , 43543 , 43573 , 43577 , 43579 , 43591 , 43597 , 43607 , 43609 , 43613 , 43627 , 43633 , 43649 , 43651 , 43661 , 43669 , 43691 , 43711 , 43717 , 43721 , 43753 , 43759 , 43777 , 43781 , 43783 , 43787 , 43789 , 43793 , 43801 , 43853 , 43867 , 43889 , 43891 , 43913 , 43933 , 43943 , 43951 , 43961 , 43963 , 43969 , 43973 , 43987 , 43991 , 43997 , 44017 , 44021 , 44027 , 44029 , 44041 , 44053 , 44059 , 44071 , 44087 , 44089 , 44101 , 44111 , 44119 , 44123 , 44129 , 44131 , 44159 , 44171 , 44179 , 44189 , 44201 , 44203 , 44207 , 44221 , 44249 , 44257 , 44263 , 44267 , 44269 , 44273 , 44279 , 44281 , 44293 , 44351 , 44357 , 44371 , 44381 , 44383 , 44389 , 44417 , 44449 , 44453 , 44483 , 44491 , 44497 , 44501 , 44507 , 44519 , 44531 , 44533 , 44537 , 44543 , 44549 , 44563 , 44579 , 44587 , 44617 , 44621 , 44623 , 44633 , 44641 , 44647 , 44651 , 44657 , 44683 , 44687 , 44699 , 44701 , 44711 , 44729 , 44741 , 44753 , 44771 , 44773 , 44777 , 44789 , 44797 , 44809 , 44819 , 44839 , 44843 , 44851 , 44867 , 44879 , 44887 , 44893 , 44909 , 44917 , 44927 , 44939 , 44953 , 44959 , 44963 , 44971 , 44983 , 44987 , 45007 , 45013 , 45053 , 45061 , 45077 , 45083 , 45119 , 45121 , 45127 , 45131 , 45137 , 45139 , 45161 , 45179 , 45181 , 45191 , 45197 , 45233 , 45247 , 45259 , 45263 , 45281 , 45289 , 45293 , 45307 , 45317 , 45319 , 45329 , 45337 , 45341 , 45343 , 45361 , 45377 , 45389 , 45403 , 45413 , 45427 , 45433 , 45439 , 45481 , 45491 , 45497 , 45503 , 45523 , 45533 , 45541 , 45553 , 45557 , 45569 , 45587 , 45589 , 45599 , 45613 , 45631 , 45641 , 45659 , 45667 , 45673 , 45677 , 45691 , 45697 , 45707 , 45737 , 45751 , 45757 , 45763 , 45767 , 45779 , 45817 , 45821 , 45823 , 45827 , 45833 , 45841 , 45853 , 45863 , 45869 , 45887 , 45893 , 45943 , 45949 , 45953 , 45959 , 45971 , 45979 , 45989 , 46021 , 46027 , 46049 , 46051 , 46061 , 46073 , 46091 , 46093 , 46099 , 46103 , 46133 , 46141 , 46147 , 46153 , 46171 , 46181 , 46183 , 46187 , 46199 , 46219 , 46229 , 46237 , 46261 , 46271 , 46273 , 46279 , 46301 , 46307 , 46309 , 46327 , 46337 , 46349 , 46351 , 46381 , 46399 , 46411 , 46439 , 46441 , 46447 , 46451 , 46457 , 46471 , 46477 , 46489 , 46499 , 46507 , 46511 , 46523 , 46549 , 46559 , 46567 , 46573 , 46589 , 46591 , 46601 , 46619 , 46633 , 46639 , 46643 , 46649 , 46663 , 46679 , 46681 , 46687 , 46691 , 46703 , 46723 , 46727 , 46747 , 46751 , 46757 , 46769 , 46771 , 46807 , 46811 , 46817 , 46819 , 46829 , 46831 , 46853 , 46861 , 46867 , 46877 , 46889 , 46901 , 46919 , 46933 , 46957 , 46993 , 46997 , 47017 , 47041 , 47051 , 47057 , 47059 , 47087 , 47093 , 47111 , 47119 , 47123 , 47129 , 47137 , 47143 , 47147 , 47149 , 47161 , 47189 , 47207 , 47221 , 47237 , 47251 , 47269 , 47279 , 47287 , 47293 , 47297 , 47303 , 47309 , 47317 , 47339 , 47351 , 47353 , 47363 , 47381 , 47387 , 47389 , 47407 , 47417 , 47419 , 47431 , 47441 , 47459 , 47491 , 47497 , 47501 , 47507 , 47513 , 47521 , 47527 , 47533 , 47543 , 47563 , 47569 , 47581 , 47591 , 47599 , 47609 , 47623 , 47629 , 47639 , 47653 , 47657 , 47659 , 47681 , 47699 , 47701 , 47711 , 47713 , 47717 , 47737 , 47741 , 47743 , 47777 , 47779 , 47791 , 47797 , 47807 , 47809 , 47819 , 47837 , 47843 , 47857 , 47869 , 47881 , 47903 , 47911 , 47917 , 47933 , 47939 , 47947 , 47951 , 47963 , 47969 , 47977 , 47981 , 48017 , 48023 , 48029 , 48049 , 48073 , 48079 , 48091 , 48109 , 48119 , 48121 , 48131 , 48157 , 48163 , 48179 , 48187 , 48193 , 48197 , 48221 , 48239 , 48247 , 48259 , 48271 , 48281 , 48299 , 48311 , 48313 , 48337 , 48341 , 48353 , 48371 , 48383 , 48397 , 48407 , 48409 , 48413 , 48437 , 48449 , 48463 , 48473 , 48479 , 48481 , 48487 , 48491 , 48497 , 48523 , 48527 , 48533 , 48539 , 48541 , 48563 , 48571 , 48589 , 48593 , 48611 , 48619 , 48623 , 48647 , 48649 , 48661 , 48673 , 48677 , 48679 , 48731 , 48733 , 48751 , 48757 , 48761 , 48767 , 48779 , 48781 , 48787 , 48799 , 48809 , 48817 , 48821 , 48823 , 48847 , 48857 , 48859 , 48869 , 48871 , 48883 , 48889 , 48907 , 48947 , 48953 , 48973 , 48989 , 48991 , 49003 , 49009 , 49019 , 49031 , 49033 , 49037 , 49043 , 49057 , 49069 , 49081 , 49103 , 49109 , 49117 , 49121 , 49123 , 49139 , 49157 , 49169 , 49171 , 49177 , 49193 , 49199 , 49201 , 49207 , 49211 , 49223 , 49253 , 49261 , 49277 , 49279 , 49297 , 49307 , 49331 , 49333 , 49339 , 49363 , 49367 , 49369 , 49391 , 49393 , 49409 , 49411 , 49417 , 49429 , 49433 , 49451 , 49459 , 49463 , 49477 , 49481 , 49499 , 49523 , 49529 , 49531 , 49537 , 49547 , 49549 , 49559 , 49597 , 49603 , 49613 , 49627 , 49633 , 49639 , 49663 , 49667 , 49669 , 49681 , 49697 , 49711 , 49727 , 49739 , 49741 , 49747 , 49757 , 49783 , 49787 , 49789 , 49801 , 49807 , 49811 , 49823 , 49831 , 49843 , 49853 , 49871 , 49877 , 49891 , 49919 , 49921 , 49927 , 49937 , 49939 , 49943 , 49957 , 49991 , 49993 , 49999 , 50021 , 50023 , 50033 , 50047 , 50051 , 50053 , 50069 , 50077 , 50087 , 50093 , 50101 , 50111 , 50119 , 50123 , 50129 , 50131 , 50147 , 50153 , 50159 , 50177 , 50207 , 50221 , 50227 , 50231 , 50261 , 50263 , 50273 , 50287 , 50291 , 50311 , 50321 , 50329 , 50333 , 50341 , 50359 , 50363 , 50377 , 50383 , 50387 , 50411 , 50417 , 50423 , 50441 , 50459 , 50461 , 50497 , 50503 , 50513 , 50527 , 50539 , 50543 , 50549 , 50551 , 50581 , 50587 , 50591 , 50593 , 50599 , 50627 , 50647 , 50651 , 50671 , 50683 , 50707 , 50723 , 50741 , 50753 , 50767 , 50773 , 50777 , 50789 , 50821 , 50833 , 50839 , 50849 , 50857 , 50867 , 50873 , 50891 , 50893 , 50909 , 50923 , 50929 , 50951 , 50957 , 50969 , 50971 , 50989 , 50993 , 51001 , 51031 , 51043 , 51047 , 51059 , 51061 , 51071 , 51109 , 51131 , 51133 , 51137 , 51151 , 51157 , 51169 , 51193 , 51197 , 51199 , 51203 , 51217 , 51229 , 51239 , 51241 , 51257 , 51263 , 51283 , 51287 , 51307 , 51329 , 51341 , 51343 , 51347 , 51349 , 51361 , 51383 , 51407 , 51413 , 51419 , 51421 , 51427 , 51431 , 51437 , 51439 , 51449 , 51461 , 51473 , 51479 , 51481 , 51487 , 51503 , 51511 , 51517 , 51521 , 51539 , 51551 , 51563 , 51577 , 51581 , 51593 , 51599 , 51607 , 51613 , 51631 , 51637 , 51647 , 51659 , 51673 , 51679 , 51683 , 51691 , 51713 , 51719 , 51721 , 51749 , 51767 , 51769 , 51787 , 51797 , 51803 , 51817 , 51827 , 51829 , 51839 , 51853 , 51859 , 51869 , 51871 , 51893 , 51899 , 51907 , 51913 , 51929 , 51941 , 51949 , 51971 , 51973 , 51977 , 51991 , 52009 , 52021 , 52027 , 52051 , 52057 , 52067 , 52069 , 52081 , 52103 , 52121 , 52127 , 52147 , 52153 , 52163 , 52177 , 52181 , 52183 , 52189 , 52201 , 52223 , 52237 , 52249 , 52253 , 52259 , 52267 , 52289 , 52291 , 52301 , 52313 , 52321 , 52361 , 52363 , 52369 , 52379 , 52387 , 52391 , 52433 , 52453 , 52457 , 52489 , 52501 , 52511 , 52517 , 52529 , 52541 , 52543 , 52553 , 52561 , 52567 , 52571 , 52579 , 52583 , 52609 , 52627 , 52631 , 52639 , 52667 , 52673 , 52691 , 52697 , 52709 , 52711 , 52721 , 52727 , 52733 , 52747 , 52757 , 52769 , 52783 , 52807 , 52813 , 52817 , 52837 , 52859 , 52861 , 52879 , 52883 , 52889 , 52901 , 52903 , 52919 , 52937 , 52951 , 52957 , 52963 , 52967 , 52973 , 52981 , 52999 , 53003 , 53017 , 53047 , 53051 , 53069 , 53077 , 53087 , 53089 , 53093 , 53101 , 53113 , 53117 , 53129 , 53147 , 53149 , 53161 , 53171 , 53173 , 53189 , 53197 , 53201 , 53231 , 53233 , 53239 , 53267 , 53269 , 53279 , 53281 , 53299 , 53309 , 53323 , 53327 , 53353 , 53359 , 53377 , 53381 , 53401 , 53407 , 53411 , 53419 , 53437 , 53441 , 53453 , 53479 , 53503 , 53507 , 53527 , 53549 , 53551 , 53569 , 53591 , 53593 , 53597 , 53609 , 53611 , 53617 , 53623 , 53629 , 53633 , 53639 , 53653 , 53657 , 53681 , 53693 , 53699 , 53717 , 53719 , 53731 , 53759 , 53773 , 53777 , 53783 , 53791 , 53813 , 53819 , 53831 , 53849 , 53857 , 53861 , 53881 , 53887 , 53891 , 53897 , 53899 , 53917 , 53923 , 53927 , 53939 , 53951 , 53959 , 53987 , 53993 , 54001 , 54011 , 54013 , 54037 , 54049 , 54059 , 54083 , 54091 , 54101 , 54121 , 54133 , 54139 , 54151 , 54163 , 54167 , 54181 , 54193 , 54217 , 54251 , 54269 , 54277 , 54287 , 54293 , 54311 , 54319 , 54323 , 54331 , 54347 , 54361 , 54367 , 54371 , 54377 , 54401 , 54403 , 54409 , 54413 , 54419 , 54421 , 54437 , 54443 , 54449 , 54469 , 54493 , 54497 , 54499 , 54503 , 54517 , 54521 , 54539 , 54541 , 54547 , 54559 , 54563 , 54577 , 54581 , 54583 , 54601 , 54617 , 54623 , 54629 , 54631 , 54647 , 54667 , 54673 , 54679 , 54709 , 54713 , 54721 , 54727 , 54751 , 54767 , 54773 , 54779 , 54787 , 54799 , 54829 , 54833 , 54851 , 54869 , 54877 , 54881 , 54907 , 54917 , 54919 , 54941 , 54949 , 54959 , 54973 , 54979 , 54983 , 55001 , 55009 , 55021 , 55049 , 55051 , 55057 , 55061 , 55073 , 55079 , 55103 , 55109 , 55117 , 55127 , 55147 , 55163 , 55171 , 55201 , 55207 , 55213 , 55217 , 55219 , 55229 , 55243 , 55249 , 55259 , 55291 , 55313 , 55331 , 55333 , 55337 , 55339 , 55343 , 55351 , 55373 , 55381 , 55399 , 55411 , 55439 , 55441 , 55457 , 55469 , 55487 , 55501 , 55511 , 55529 , 55541 , 55547 , 55579 , 55589 , 55603 , 55609 , 55619 , 55621 , 55631 , 55633 , 55639 , 55661 , 55663 , 55667 , 55673 , 55681 , 55691 , 55697 , 55711 , 55717 , 55721 , 55733 , 55763 , 55787 , 55793 , 55799 , 55807 , 55813 , 55817 , 55819 , 55823 , 55829 , 55837 , 55843 , 55849 , 55871 , 55889 , 55897 , 55901 , 55903 , 55921 , 55927 , 55931 , 55933 , 55949 , 55967 , 55987 , 55997 , 56003 , 56009 , 56039 , 56041 , 56053 , 56081 , 56087 , 56093 , 56099 , 56101 , 56113 , 56123 , 56131 , 56149 , 56167 , 56171 , 56179 , 56197 , 56207 , 56209 , 56237 , 56239 , 56249 , 56263 , 56267 , 56269 , 56299 , 56311 , 56333 , 56359 , 56369 , 56377 , 56383 , 56393 , 56401 , 56417 , 56431 , 56437 , 56443 , 56453 , 56467 , 56473 , 56477 , 56479 , 56489 , 56501 , 56503 , 56509 , 56519 , 56527 , 56531 , 56533 , 56543 , 56569 , 56591 , 56597 , 56599 , 56611 , 56629 , 56633 , 56659 , 56663 , 56671 , 56681 , 56687 , 56701 , 56711 , 56713 , 56731 , 56737 , 56747 , 56767 , 56773 , 56779 , 56783 , 56807 , 56809 , 56813 , 56821 , 56827 , 56843 , 56857 , 56873 , 56891 , 56893 , 56897 , 56909 , 56911 , 56921 , 56923 , 56929 , 56941 , 56951 , 56957 , 56963 , 56983 , 56989 , 56993 , 56999 , 57037 , 57041 , 57047 , 57059 , 57073 , 57077 , 57089 , 57097 , 57107 , 57119 , 57131 , 57139 , 57143 , 57149 , 57163 , 57173 , 57179 , 57191 , 57193 , 57203 , 57221 , 57223 , 57241 , 57251 , 57259 , 57269 , 57271 , 57283 , 57287 , 57301 , 57329 , 57331 , 57347 , 57349 , 57367 , 57373 , 57383 , 57389 , 57397 , 57413 , 57427 , 57457 , 57467 , 57487 , 57493 , 57503 , 57527 , 57529 , 57557 , 57559 , 57571 , 57587 , 57593 , 57601 , 57637 , 57641 , 57649 , 57653 , 57667 , 57679 , 57689 , 57697 , 57709 , 57713 , 57719 , 57727 , 57731 , 57737 , 57751 , 57773 , 57781 , 57787 , 57791 , 57793 , 57803 , 57809 , 57829 , 57839 , 57847 , 57853 , 57859 , 57881 , 57899 , 57901 , 57917 , 57923 , 57943 , 57947 , 57973 , 57977 , 57991 , 58013 , 58027 , 58031 , 58043 , 58049 , 58057 , 58061 , 58067 , 58073 , 58099 , 58109 , 58111 , 58129 , 58147 , 58151 , 58153 , 58169 , 58171 , 58189 , 58193 , 58199 , 58207 , 58211 , 58217 , 58229 , 58231 , 58237 , 58243 , 58271 , 58309 , 58313 , 58321 , 58337 , 58363 , 58367 , 58369 , 58379 , 58391 , 58393 , 58403 , 58411 , 58417 , 58427 , 58439 , 58441 , 58451 , 58453 , 58477 , 58481 , 58511 , 58537 , 58543 , 58549 , 58567 , 58573 , 58579 , 58601 , 58603 , 58613 , 58631 , 58657 , 58661 , 58679 , 58687 , 58693 , 58699 , 58711 , 58727 , 58733 , 58741 , 58757 , 58763 , 58771 , 58787 , 58789 , 58831 , 58889 , 58897 , 58901 , 58907 , 58909 , 58913 , 58921 , 58937 , 58943 , 58963 , 58967 , 58979 , 58991 , 58997 , 59009 , 59011 , 59021 , 59023 , 59029 , 59051 , 59053 , 59063 , 59069 , 59077 , 59083 , 59093 , 59107 , 59113 , 59119 , 59123 , 59141 , 59149 , 59159 , 59167 , 59183 , 59197 , 59207 , 59209 , 59219 , 59221 , 59233 , 59239 , 59243 , 59263 , 59273 , 59281 , 59333 , 59341 , 59351 , 59357 , 59359 , 59369 , 59377 , 59387 , 59393 , 59399 , 59407 , 59417 , 59419 , 59441 , 59443 , 59447 , 59453 , 59467 , 59471 , 59473 , 59497 , 59509 , 59513 , 59539 , 59557 , 59561 , 59567 , 59581 , 59611 , 59617 , 59621 , 59627 , 59629 , 59651 , 59659 , 59663 , 59669 , 59671 , 59693 , 59699 , 59707 , 59723 , 59729 , 59743 , 59747 , 59753 , 59771 , 59779 , 59791 , 59797 , 59809 , 59833 , 59863 , 59879 , 59887 , 59921 , 59929 , 59951 , 59957 , 59971 , 59981 , 59999 , 60013 , 60017 , 60029 , 60037 , 60041 , 60077 , 60083 , 60089 , 60091 , 60101 , 60103 , 60107 , 60127 , 60133 , 60139 , 60149 , 60161 , 60167 , 60169 , 60209 , 60217 , 60223 , 60251 , 60257 , 60259 , 60271 , 60289 , 60293 , 60317 , 60331 , 60337 , 60343 , 60353 , 60373 , 60383 , 60397 , 60413 , 60427 , 60443 , 60449 , 60457 , 60493 , 60497 , 60509 , 60521 , 60527 , 60539 , 60589 , 60601 , 60607 , 60611 , 60617 , 60623 , 60631 , 60637 , 60647 , 60649 , 60659 , 60661 , 60679 , 60689 , 60703 , 60719 , 60727 , 60733 , 60737 , 60757 , 60761 , 60763 , 60773 , 60779 , 60793 , 60811 , 60821 , 60859 , 60869 , 60887 , 60889 , 60899 , 60901 , 60913 , 60917 , 60919 , 60923 , 60937 , 60943 , 60953 , 60961 , 61001 , 61007 , 61027 , 61031 , 61043 , 61051 , 61057 , 61091 , 61099 , 61121 , 61129 , 61141 , 61151 , 61153 , 61169 , 61211 , 61223 , 61231 , 61253 , 61261 , 61283 , 61291 , 61297 , 61331 , 61333 , 61339 , 61343 , 61357 , 61363 , 61379 , 61381 , 61403 , 61409 , 61417 , 61441 , 61463 , 61469 , 61471 , 61483 , 61487 , 61493 , 61507 , 61511 , 61519 , 61543 , 61547 , 61553 , 61559 , 61561 , 61583 , 61603 , 61609 , 61613 , 61627 , 61631 , 61637 , 61643 , 61651 , 61657 , 61667 , 61673 , 61681 , 61687 , 61703 , 61717 , 61723 , 61729 , 61751 , 61757 , 61781 , 61813 , 61819 , 61837 , 61843 , 61861 , 61871 , 61879 , 61909 , 61927 , 61933 , 61949 , 61961 , 61967 , 61979 , 61981 , 61987 , 61991 , 62003 , 62011 , 62017 , 62039 , 62047 , 62053 , 62057 , 62071 , 62081 , 62099 , 62119 , 62129 , 62131 , 62137 , 62141 , 62143 , 62171 , 62189 , 62191 , 62201 , 62207 , 62213 , 62219 , 62233 , 62273 , 62297 , 62299 , 62303 , 62311 , 62323 , 62327 , 62347 , 62351 , 62383 , 62401 , 62417 , 62423 , 62459 , 62467 , 62473 , 62477 , 62483 , 62497 , 62501 , 62507 , 62533 , 62539 , 62549 , 62563 , 62581 , 62591 , 62597 , 62603 , 62617 , 62627 , 62633 , 62639 , 62653 , 62659 , 62683 , 62687 , 62701 , 62723 , 62731 , 62743 , 62753 , 62761 , 62773 , 62791 , 62801 , 62819 , 62827 , 62851 , 62861 , 62869 , 62873 , 62897 , 62903 , 62921 , 62927 , 62929 , 62939 , 62969 , 62971 , 62981 , 62983 , 62987 , 62989 , 63029 , 63031 , 63059 , 63067 , 63073 , 63079 , 63097 , 63103 , 63113 , 63127 , 63131 , 63149 , 63179 , 63197 , 63199 , 63211 , 63241 , 63247 , 63277 , 63281 , 63299 , 63311 , 63313 , 63317 , 63331 , 63337 , 63347 , 63353 , 63361 , 63367 , 63377 , 63389 , 63391 , 63397 , 63409 , 63419 , 63421 , 63439 , 63443 , 63463 , 63467 , 63473 , 63487 , 63493 , 63499 , 63521 , 63527 , 63533 , 63541 , 63559 , 63577 , 63587 , 63589 , 63599 , 63601 , 63607 , 63611 , 63617 , 63629 , 63647 , 63649 , 63659 , 63667 , 63671 , 63689 , 63691 , 63697 , 63703 , 63709 , 63719 , 63727 , 63737 , 63743 , 63761 , 63773 , 63781 , 63793 , 63799 , 63803 , 63809 , 63823 , 63839 , 63841 , 63853 , 63857 , 63863 , 63901 , 63907 , 63913 , 63929 , 63949 , 63977 , 63997 , 64007 , 64013 , 64019 , 64033 , 64037 , 64063 , 64067 , 64081 , 64091 , 64109 , 64123 , 64151 , 64153 , 64157 , 64171 , 64187 , 64189 , 64217 , 64223 , 64231 , 64237 , 64271 , 64279 , 64283 , 64301 , 64303 , 64319 , 64327 , 64333 , 64373 , 64381 , 64399 , 64403 , 64433 , 64439 , 64451 , 64453 , 64483 , 64489 , 64499 , 64513 , 64553 , 64567 , 64577 , 64579 , 64591 , 64601 , 64609 , 64613 , 64621 , 64627 , 64633 , 64661 , 64663 , 64667 , 64679 , 64693 , 64709 , 64717 , 64747 , 64763 , 64781 , 64783 , 64793 , 64811 , 64817 , 64849 , 64853 , 64871 , 64877 , 64879 , 64891 , 64901 , 64919 , 64921 , 64927 , 64937 , 64951 , 64969 , 64997 , 65003 , 65011 , 65027 , 65029 , 65033 , 65053 , 65063 , 65071 , 65089 , 65099 , 65101 , 65111 , 65119 , 65123 , 65129 , 65141 , 65147 , 65167 , 65171 , 65173 , 65179 , 65183 , 65203 , 65213 , 65239 , 65257 , 65267 , 65269 , 65287 , 65293 , 65309 , 65323 , 65327 , 65353 , 65357 , 65371 , 65381 , 65393 , 65407 , 65413 , 65419 , 65423 , 65437 , 65447 , 65449 , 65479 , 65497 , 65519 , 65521 , 65537 , 65539 , 65543 , 65551 , 65557 , 65563 , 65579 , 65581 , 65587 , 65599 , 65609 , 65617 , 65629 , 65633 , 65647 , 65651 , 65657 , 65677 , 65687 , 65699 , 65701 , 65707 , 65713 , 65717 , 65719 , 65729 , 65731 , 65761 , 65777 , 65789 , 65809 , 65827 , 65831 , 65837 , 65839 , 65843 , 65851 , 65867 , 65881 , 65899 , 65921 , 65927 , 65929 , 65951 , 65957 , 65963 , 65981 , 65983 , 65993 , 66029 , 66037 , 66041 , 66047 , 66067 , 66071 , 66083 , 66089 , 66103 , 66107 , 66109 , 66137 , 66161 , 66169 , 66173 , 66179 , 66191 , 66221 , 66239 , 66271 , 66293 , 66301 , 66337 , 66343 , 66347 , 66359 , 66361 , 66373 , 66377 , 66383 , 66403 , 66413 , 66431 , 66449 , 66457 , 66463 , 66467 , 66491 , 66499 , 66509 , 66523 , 66529 , 66533 , 66541 , 66553 , 66569 , 66571 , 66587 , 66593 , 66601 , 66617 , 66629 , 66643 , 66653 , 66683 , 66697 , 66701 , 66713 , 66721 , 66733 , 66739 , 66749 , 66751 , 66763 , 66791 , 66797 , 66809 , 66821 , 66841 , 66851 , 66853 , 66863 , 66877 , 66883 , 66889 , 66919 , 66923 , 66931 , 66943 , 66947 , 66949 , 66959 , 66973 , 66977 , 67003 , 67021 , 67033 , 67043 , 67049 , 67057 , 67061 , 67073 , 67079 , 67103 , 67121 , 67129 , 67139 , 67141 , 67153 , 67157 , 67169 , 67181 , 67187 , 67189 , 67211 , 67213 , 67217 , 67219 , 67231 , 67247 , 67261 , 67271 , 67273 , 67289 , 67307 , 67339 , 67343 , 67349 , 67369 , 67391 , 67399 , 67409 , 67411 , 67421 , 67427 , 67429 , 67433 , 67447 , 67453 , 67477 , 67481 , 67489 , 67493 , 67499 , 67511 , 67523 , 67531 , 67537 , 67547 , 67559 , 67567 , 67577 , 67579 , 67589 , 67601 , 67607 , 67619 , 67631 , 67651 , 67679 , 67699 , 67709 , 67723 , 67733 , 67741 , 67751 , 67757 , 67759 , 67763 , 67777 , 67783 , 67789 , 67801 , 67807 , 67819 , 67829 , 67843 , 67853 , 67867 , 67883 , 67891 , 67901 , 67927 , 67931 , 67933 , 67939 , 67943 , 67957 , 67961 , 67967 , 67979 , 67987 , 67993 , 68023 , 68041 , 68053 , 68059 , 68071 , 68087 , 68099 , 68111 , 68113 , 68141 , 68147 , 68161 , 68171 , 68207 , 68209 , 68213 , 68219 , 68227 , 68239 , 68261 , 68279 , 68281 , 68311 , 68329 , 68351 , 68371 , 68389 , 68399 , 68437 , 68443 , 68447 , 68449 , 68473 , 68477 , 68483 , 68489 , 68491 , 68501 , 68507 , 68521 , 68531 , 68539 , 68543 , 68567 , 68581 , 68597 , 68611 , 68633 , 68639 , 68659 , 68669 , 68683 , 68687 , 68699 , 68711 , 68713 , 68729 , 68737 , 68743 , 68749 , 68767 , 68771 , 68777 , 68791 , 68813 , 68819 , 68821 , 68863 , 68879 , 68881 , 68891 , 68897 , 68899 , 68903 , 68909 , 68917 , 68927 , 68947 , 68963 , 68993 , 69001 , 69011 , 69019 , 69029 , 69031 , 69061 , 69067 , 69073 , 69109 , 69119 , 69127 , 69143 , 69149 , 69151 , 69163 , 69191 , 69193 , 69197 , 69203 , 69221 , 69233 , 69239 , 69247 , 69257 , 69259 , 69263 , 69313 , 69317 , 69337 , 69341 , 69371 , 69379 , 69383 , 69389 , 69401 , 69403 , 69427 , 69431 , 69439 , 69457 , 69463 , 69467 , 69473 , 69481 , 69491 , 69493 , 69497 , 69499 , 69539 , 69557 , 69593 , 69623 , 69653 , 69661 , 69677 , 69691 , 69697 , 69709 , 69737 , 69739 , 69761 , 69763 , 69767 , 69779 , 69809 , 69821 , 69827 , 69829 , 69833 , 69847 , 69857 , 69859 , 69877 , 69899 , 69911 , 69929 , 69931 , 69941 , 69959 , 69991 , 69997 , 70001 , 70003 , 70009 , 70019 , 70039 , 70051 , 70061 , 70067 , 70079 , 70099 , 70111 , 70117 , 70121 , 70123 , 70139 , 70141 , 70157 , 70163 , 70177 , 70181 , 70183 , 70199 , 70201 , 70207 , 70223 , 70229 , 70237 , 70241 , 70249 , 70271 , 70289 , 70297 , 70309 , 70313 , 70321 , 70327 , 70351 , 70373 , 70379 , 70381 , 70393 , 70423 , 70429 , 70439 , 70451 , 70457 , 70459 , 70481 , 70487 , 70489 , 70501 , 70507 , 70529 , 70537 , 70549 , 70571 , 70573 , 70583 , 70589 , 70607 , 70619 , 70621 , 70627 , 70639 , 70657 , 70663 , 70667 , 70687 , 70709 , 70717 , 70729 , 70753 , 70769 , 70783 , 70793 , 70823 , 70841 , 70843 , 70849 , 70853 , 70867 , 70877 , 70879 , 70891 , 70901 , 70913 , 70919 , 70921 , 70937 , 70949 , 70951 , 70957 , 70969 , 70979 , 70981 , 70991 , 70997 , 70999 , 71011 , 71023 , 71039 , 71059 , 71069 , 71081 , 71089 , 71119 , 71129 , 71143 , 71147 , 71153 , 71161 , 71167 , 71171 , 71191 , 71209 , 71233 , 71237 , 71249 , 71257 , 71261 , 71263 , 71287 , 71293 , 71317 , 71327 , 71329 , 71333 , 71339 , 71341 , 71347 , 71353 , 71359 , 71363 , 71387 , 71389 , 71399 , 71411 , 71413 , 71419 , 71429 , 71437 , 71443 , 71453 , 71471 , 71473 , 71479 , 71483 , 71503 , 71527 , 71537 , 71549 , 71551 , 71563 , 71569 , 71593 , 71597 , 71633 , 71647 , 71663 , 71671 , 71693 , 71699 , 71707 , 71711 , 71713 , 71719 , 71741 , 71761 , 71777 , 71789 , 71807 , 71809 , 71821 , 71837 , 71843 , 71849 , 71861 , 71867 , 71879 , 71881 , 71887 , 71899 , 71909 , 71917 , 71933 , 71941 , 71947 , 71963 , 71971 , 71983 , 71987 , 71993 , 71999 , 72019 , 72031 , 72043 , 72047 , 72053 , 72073 , 72077 , 72089 , 72091 , 72101 , 72103 , 72109 , 72139 , 72161 , 72167 , 72169 , 72173 , 72211 , 72221 , 72223 , 72227 , 72229 , 72251 , 72253 , 72269 , 72271 , 72277 , 72287 , 72307 , 72313 , 72337 , 72341 , 72353 , 72367 , 72379 , 72383 , 72421 , 72431 , 72461 , 72467 , 72469 , 72481 , 72493 , 72497 , 72503 , 72533 , 72547 , 72551 , 72559 , 72577 , 72613 , 72617 , 72623 , 72643 , 72647 , 72649 , 72661 , 72671 , 72673 , 72679 , 72689 , 72701 , 72707 , 72719 , 72727 , 72733 , 72739 , 72763 , 72767 , 72797 , 72817 , 72823 , 72859 , 72869 , 72871 , 72883 , 72889 , 72893 , 72901 , 72907 , 72911 , 72923 , 72931 , 72937 , 72949 , 72953 , 72959 , 72973 , 72977 , 72997 , 73009 , 73013 , 73019 , 73037 , 73039 , 73043 , 73061 , 73063 , 73079 , 73091 , 73121 , 73127 , 73133 , 73141 , 73181 , 73189 , 73237 , 73243 , 73259 , 73277 , 73291 , 73303 , 73309 , 73327 , 73331 , 73351 , 73361 , 73363 , 73369 , 73379 , 73387 , 73417 , 73421 , 73433 , 73453 , 73459 , 73471 , 73477 , 73483 , 73517 , 73523 , 73529 , 73547 , 73553 , 73561 , 73571 , 73583 , 73589 , 73597 , 73607 , 73609 , 73613 , 73637 , 73643 , 73651 , 73673 , 73679 , 73681 , 73693 , 73699 , 73709 , 73721 , 73727 , 73751 , 73757 , 73771 , 73783 , 73819 , 73823 , 73847 , 73849 , 73859 , 73867 , 73877 , 73883 , 73897 , 73907 , 73939 , 73943 , 73951 , 73961 , 73973 , 73999 , 74017 , 74021 , 74027 , 74047 , 74051 , 74071 , 74077 , 74093 , 74099 , 74101 , 74131 , 74143 , 74149 , 74159 , 74161 , 74167 , 74177 , 74189 , 74197 , 74201 , 74203 , 74209 , 74219 , 74231 , 74257 , 74279 , 74287 , 74293 , 74297 , 74311 , 74317 , 74323 , 74353 , 74357 , 74363 , 74377 , 74381 , 74383 , 74411 , 74413 , 74419 , 74441 , 74449 , 74453 , 74471 , 74489 , 74507 , 74509 , 74521 , 74527 , 74531 , 74551 , 74561 , 74567 , 74573 , 74587 , 74597 , 74609 , 74611 , 74623 , 74653 , 74687 , 74699 , 74707 , 74713 , 74717 , 74719 , 74729 , 74731 , 74747 , 74759 , 74761 , 74771 , 74779 , 74797 , 74821 , 74827 , 74831 , 74843 , 74857 , 74861 , 74869 , 74873 , 74887 , 74891 , 74897 , 74903 , 74923 , 74929 , 74933 , 74941 , 74959 , 75011 , 75013 , 75017 , 75029 , 75037 , 75041 , 75079 , 75083 , 75109 , 75133 , 75149 , 75161 , 75167 , 75169 , 75181 , 75193 , 75209 , 75211 , 75217 , 75223 , 75227 , 75239 , 75253 , 75269 , 75277 , 75289 , 75307 , 75323 , 75329 , 75337 , 75347 , 75353 , 75367 , 75377 , 75389 , 75391 , 75401 , 75403 , 75407 , 75431 , 75437 , 75479 , 75503 , 75511 , 75521 , 75527 , 75533 , 75539 , 75541 , 75553 , 75557 , 75571 , 75577 , 75583 , 75611 , 75617 , 75619 , 75629 , 75641 , 75653 , 75659 , 75679 , 75683 , 75689 , 75703 , 75707 , 75709 , 75721 , 75731 , 75743 , 75767 , 75773 , 75781 , 75787 , 75793 , 75797 , 75821 , 75833 , 75853 , 75869 , 75883 , 75913 , 75931 , 75937 , 75941 , 75967 , 75979 , 75983 , 75989 , 75991 , 75997 , 76001 , 76003 , 76031 , 76039 , 76079 , 76081 , 76091 , 76099 , 76103 , 76123 , 76129 , 76147 , 76157 , 76159 , 76163 , 76207 , 76213 , 76231 , 76243 , 76249 , 76253 , 76259 , 76261 , 76283 , 76289 , 76303 , 76333 , 76343 , 76367 , 76369 , 76379 , 76387 , 76403 , 76421 , 76423 , 76441 , 76463 , 76471 , 76481 , 76487 , 76493 , 76507 , 76511 , 76519 , 76537 , 76541 , 76543 , 76561 , 76579 , 76597 , 76603 , 76607 , 76631 , 76649 , 76651 , 76667 , 76673 , 76679 , 76697 , 76717 , 76733 , 76753 , 76757 , 76771 , 76777 , 76781 , 76801 , 76819 , 76829 , 76831 , 76837 , 76847 , 76871 , 76873 , 76883 , 76907 , 76913 , 76919 , 76943 , 76949 , 76961 , 76963 , 76991 , 77003 , 77017 , 77023 , 77029 , 77041 , 77047 , 77069 , 77081 , 77093 , 77101 , 77137 , 77141 , 77153 , 77167 , 77171 , 77191 , 77201 , 77213 , 77237 , 77239 , 77243 , 77249 , 77261 , 77263 , 77267 , 77269 , 77279 , 77291 , 77317 , 77323 , 77339 , 77347 , 77351 , 77359 , 77369 , 77377 , 77383 , 77417 , 77419 , 77431 , 77447 , 77471 , 77477 , 77479 , 77489 , 77491 , 77509 , 77513 , 77521 , 77527 , 77543 , 77549 , 77551 , 77557 , 77563 , 77569 , 77573 , 77587 , 77591 , 77611 , 77617 , 77621 , 77641 , 77647 , 77659 , 77681 , 77687 , 77689 , 77699 , 77711 , 77713 , 77719 , 77723 , 77731 , 77743 , 77747 , 77761 , 77773 , 77783 , 77797 , 77801 , 77813 , 77839 , 77849 , 77863 , 77867 , 77893 , 77899 , 77929 , 77933 , 77951 , 77969 , 77977 , 77983 , 77999 , 78007 , 78017 , 78031 , 78041 , 78049 , 78059 , 78079 , 78101 , 78121 , 78137 , 78139 , 78157 , 78163 , 78167 , 78173 , 78179 , 78191 , 78193 , 78203 , 78229 , 78233 , 78241 , 78259 , 78277 , 78283 , 78301 , 78307 , 78311 , 78317 , 78341 , 78347 , 78367 , 78401 , 78427 , 78437 , 78439 , 78467 , 78479 , 78487 , 78497 , 78509 , 78511 , 78517 , 78539 , 78541 , 78553 , 78569 , 78571 , 78577 , 78583 , 78593 , 78607 , 78623 , 78643 , 78649 , 78653 , 78691 , 78697 , 78707 , 78713 , 78721 , 78737 , 78779 , 78781 , 78787 , 78791 , 78797 , 78803 , 78809 , 78823 , 78839 , 78853 , 78857 , 78877 , 78887 , 78889 , 78893 , 78901 , 78919 , 78929 , 78941 , 78977 , 78979 , 78989 , 79031 , 79039 , 79043 , 79063 , 79087 , 79103 , 79111 , 79133 , 79139 , 79147 , 79151 , 79153 , 79159 , 79181 , 79187 , 79193 , 79201 , 79229 , 79231 , 79241 , 79259 , 79273 , 79279 , 79283 , 79301 , 79309 , 79319 , 79333 , 79337 , 79349 , 79357 , 79367 , 79379 , 79393 , 79397 , 79399 , 79411 , 79423 , 79427 , 79433 , 79451 , 79481 , 79493 , 79531 , 79537 , 79549 , 79559 , 79561 , 79579 , 79589 , 79601 , 79609 , 79613 , 79621 , 79627 , 79631 , 79633 , 79657 , 79669 , 79687 , 79691 , 79693 , 79697 , 79699 , 79757 , 79769 , 79777 , 79801 , 79811 , 79813 , 79817 , 79823 , 79829 , 79841 , 79843 , 79847 , 79861 , 79867 , 79873 , 79889 , 79901 , 79903 , 79907 , 79939 , 79943 , 79967 , 79973 , 79979 , 79987 , 79997 , 79999 , 80021 , 80039 , 80051 , 80071 , 80077 , 80107 , 80111 , 80141 , 80147 , 80149 , 80153 , 80167 , 80173 , 80177 , 80191 , 80207 , 80209 , 80221 , 80231 , 80233 , 80239 , 80251 , 80263 , 80273 , 80279 , 80287 , 80309 , 80317 , 80329 , 80341 , 80347 , 80363 , 80369 , 80387 , 80407 , 80429 , 80447 , 80449 , 80471 , 80473 , 80489 , 80491 , 80513 , 80527 , 80537 , 80557 , 80567 , 80599 , 80603 , 80611 , 80621 , 80627 , 80629 , 80651 , 80657 , 80669 , 80671 , 80677 , 80681 , 80683 , 80687 , 80701 , 80713 , 80737 , 80747 , 80749 , 80761 , 80777 , 80779 , 80783 , 80789 , 80803 , 80809 , 80819 , 80831 , 80833 , 80849 , 80863 , 80897 , 80909 , 80911 , 80917 , 80923 , 80929 , 80933 , 80953 , 80963 , 80989 , 81001 , 81013 , 81017 , 81019 , 81023 , 81031 , 81041 , 81043 , 81047 , 81049 , 81071 , 81077 , 81083 , 81097 , 81101 , 81119 , 81131 , 81157 , 81163 , 81173 , 81181 , 81197 , 81199 , 81203 , 81223 , 81233 , 81239 , 81281 , 81283 , 81293 , 81299 , 81307 , 81331 , 81343 , 81349 , 81353 , 81359 , 81371 , 81373 , 81401 , 81409 , 81421 , 81439 , 81457 , 81463 , 81509 , 81517 , 81527 , 81533 , 81547 , 81551 , 81553 , 81559 , 81563 , 81569 , 81611 , 81619 , 81629 , 81637 , 81647 , 81649 , 81667 , 81671 , 81677 , 81689 , 81701 , 81703 , 81707 , 81727 , 81737 , 81749 , 81761 , 81769 , 81773 , 81799 , 81817 , 81839 , 81847 , 81853 , 81869 , 81883 , 81899 , 81901 , 81919 , 81929 , 81931 , 81937 , 81943 , 81953 , 81967 , 81971 , 81973 , 82003 , 82007 , 82009 , 82013 , 82021 , 82031 , 82037 , 82039 , 82051 , 82067 , 82073 , 82129 , 82139 , 82141 , 82153 , 82163 , 82171 , 82183 , 82189 , 82193 , 82207 , 82217 , 82219 , 82223 , 82231 , 82237 , 82241 , 82261 , 82267 , 82279 , 82301 , 82307 , 82339 , 82349 , 82351 , 82361 , 82373 , 82387 , 82393 , 82421 , 82457 , 82463 , 82469 , 82471 , 82483 , 82487 , 82493 , 82499 , 82507 , 82529 , 82531 , 82549 , 82559 , 82561 , 82567 , 82571 , 82591 , 82601 , 82609 , 82613 , 82619 , 82633 , 82651 , 82657 , 82699 , 82721 , 82723 , 82727 , 82729 , 82757 , 82759 , 82763 , 82781 , 82787 , 82793 , 82799 , 82811 , 82813 , 82837 , 82847 , 82883 , 82889 , 82891 , 82903 , 82913 , 82939 , 82963 , 82981 , 82997 , 83003 , 83009 , 83023 , 83047 , 83059 , 83063 , 83071 , 83077 , 83089 , 83093 , 83101 , 83117 , 83137 , 83177 , 83203 , 83207 , 83219 , 83221 , 83227 , 83231 , 83233 , 83243 , 83257 , 83267 , 83269 , 83273 , 83299 , 83311 , 83339 , 83341 , 83357 , 83383 , 83389 , 83399 , 83401 , 83407 , 83417 , 83423 , 83431 , 83437 , 83443 , 83449 , 83459 , 83471 , 83477 , 83497 , 83537 , 83557 , 83561 , 83563 , 83579 , 83591 , 83597 , 83609 , 83617 , 83621 , 83639 , 83641 , 83653 , 83663 , 83689 , 83701 , 83717 , 83719 , 83737 , 83761 , 83773 , 83777 , 83791 , 83813 , 83833 , 83843 , 83857 , 83869 , 83873 , 83891 , 83903 , 83911 , 83921 , 83933 , 83939 , 83969 , 83983 , 83987 , 84011 , 84017 , 84047 , 84053 , 84059 , 84061 , 84067 , 84089 , 84121 , 84127 , 84131 , 84137 , 84143 , 84163 , 84179 , 84181 , 84191 , 84199 , 84211 , 84221 , 84223 , 84229 , 84239 , 84247 , 84263 , 84299 , 84307 , 84313 , 84317 , 84319 , 84347 , 84349 , 84377 , 84389 , 84391 , 84401 , 84407 , 84421 , 84431 , 84437 , 84443 , 84449 , 84457 , 84463 , 84467 , 84481 , 84499 , 84503 , 84509 , 84521 , 84523 , 84533 , 84551 , 84559 , 84589 , 84629 , 84631 , 84649 , 84653 , 84659 , 84673 , 84691 , 84697 , 84701 , 84713 , 84719 , 84731 , 84737 , 84751 , 84761 , 84787 , 84793 , 84809 , 84811 , 84827 , 84857 , 84859 , 84869 , 84871 , 84913 , 84919 , 84947 , 84961 , 84967 , 84977 , 84979 , 84991 , 85009 , 85021 , 85027 , 85037 , 85049 , 85061 , 85081 , 85087 , 85091 , 85093 , 85103 , 85109 , 85121 , 85133 , 85147 , 85159 , 85193 , 85199 , 85201 , 85213 , 85223 , 85229 , 85237 , 85243 , 85247 , 85259 , 85297 , 85303 , 85313 , 85331 , 85333 , 85361 , 85363 , 85369 , 85381 , 85411 , 85427 , 85429 , 85439 , 85447 , 85451 , 85453 , 85469 , 85487 , 85513 , 85517 , 85523 , 85531 , 85549 , 85571 , 85577 , 85597 , 85601 , 85607 , 85619 , 85621 , 85627 , 85639 , 85643 , 85661 , 85667 , 85669 , 85691 , 85703 , 85711 , 85717 , 85733 , 85751 , 85781 , 85793 , 85817 , 85819 , 85829 , 85831 , 85837 , 85843 , 85847 , 85853 , 85889 , 85903 , 85909 , 85931 , 85933 , 85991 , 85999 , 86011 , 86017 , 86027 , 86029 , 86069 , 86077 , 86083 , 86111 , 86113 , 86117 , 86131 , 86137 , 86143 , 86161 , 86171 , 86179 , 86183 , 86197 , 86201 , 86209 , 86239 , 86243 , 86249 , 86257 , 86263 , 86269 , 86287 , 86291 , 86293 , 86297 , 86311 , 86323 , 86341 , 86351 , 86353 , 86357 , 86369 , 86371 , 86381 , 86389 , 86399 , 86413 , 86423 , 86441 , 86453 , 86461 , 86467 , 86477 , 86491 , 86501 , 86509 , 86531 , 86533 , 86539 , 86561 , 86573 , 86579 , 86587 , 86599 , 86627 , 86629 , 86677 , 86689 , 86693 , 86711 , 86719 , 86729 , 86743 , 86753 , 86767 , 86771 , 86783 , 86813 , 86837 , 86843 , 86851 , 86857 , 86861 , 86869 , 86923 , 86927 , 86929 , 86939 , 86951 , 86959 , 86969 , 86981 , 86993 , 87011 , 87013 , 87037 , 87041 , 87049 , 87071 , 87083 , 87103 , 87107 , 87119 , 87121 , 87133 , 87149 , 87151 , 87179 , 87181 , 87187 , 87211 , 87221 , 87223 , 87251 , 87253 , 87257 , 87277 , 87281 , 87293 , 87299 , 87313 , 87317 , 87323 , 87337 , 87359 , 87383 , 87403 , 87407 , 87421 , 87427 , 87433 , 87443 , 87473 , 87481 , 87491 , 87509 , 87511 , 87517 , 87523 , 87539 , 87541 , 87547 , 87553 , 87557 , 87559 , 87583 , 87587 , 87589 , 87613 , 87623 , 87629 , 87631 , 87641 , 87643 , 87649 , 87671 , 87679 , 87683 , 87691 , 87697 , 87701 , 87719 , 87721 , 87739 , 87743 , 87751 , 87767 , 87793 , 87797 , 87803 , 87811 , 87833 , 87853 , 87869 , 87877 , 87881 , 87887 , 87911 , 87917 , 87931 , 87943 , 87959 , 87961 , 87973 , 87977 , 87991 , 88001 , 88003 , 88007 , 88019 , 88037 , 88069 , 88079 , 88093 , 88117 , 88129 , 88169 , 88177 , 88211 , 88223 , 88237 , 88241 , 88259 , 88261 , 88289 , 88301 , 88321 , 88327 , 88337 , 88339 , 88379 , 88397 , 88411 , 88423 , 88427 , 88463 , 88469 , 88471 , 88493 , 88499 , 88513 , 88523 , 88547 , 88589 , 88591 , 88607 , 88609 , 88643 , 88651 , 88657 , 88661 , 88663 , 88667 , 88681 , 88721 , 88729 , 88741 , 88747 , 88771 , 88789 , 88793 , 88799 , 88801 , 88807 , 88811 , 88813 , 88817 , 88819 , 88843 , 88853 , 88861 , 88867 , 88873 , 88883 , 88897 , 88903 , 88919 , 88937 , 88951 , 88969 , 88993 , 88997 , 89003 , 89009 , 89017 , 89021 , 89041 , 89051 , 89057 , 89069 , 89071 , 89083 , 89087 , 89101 , 89107 , 89113 , 89119 , 89123 , 89137 , 89153 , 89189 , 89203 , 89209 , 89213 , 89227 , 89231 , 89237 , 89261 , 89269 , 89273 , 89293 , 89303 , 89317 , 89329 , 89363 , 89371 , 89381 , 89387 , 89393 , 89399 , 89413 , 89417 , 89431 , 89443 , 89449 , 89459 , 89477 , 89491 , 89501 , 89513 , 89519 , 89521 , 89527 , 89533 , 89561 , 89563 , 89567 , 89591 , 89597 , 89599 , 89603 , 89611 , 89627 , 89633 , 89653 , 89657 , 89659 , 89669 , 89671 , 89681 , 89689 , 89753 , 89759 , 89767 , 89779 , 89783 , 89797 , 89809 , 89819 , 89821 , 89833 , 89839 , 89849 , 89867 , 89891 , 89897 , 89899 , 89909 , 89917 , 89923 , 89939 , 89959 , 89963 , 89977 , 89983 , 89989 , 90001 , 90007 , 90011 , 90017 , 90019 , 90023 , 90031 , 90053 , 90059 , 90067 , 90071 , 90073 , 90089 , 90107 , 90121 , 90127 , 90149 , 90163 , 90173 , 90187 , 90191 , 90197 , 90199 , 90203 , 90217 , 90227 , 90239 , 90247 , 90263 , 90271 , 90281 , 90289 , 90313 , 90353 , 90359 , 90371 , 90373 , 90379 , 90397 , 90401 , 90403 , 90407 , 90437 , 90439 , 90469 , 90473 , 90481 , 90499 , 90511 , 90523 , 90527 , 90529 , 90533 , 90547 , 90583 , 90599 , 90617 , 90619 , 90631 , 90641 , 90647 , 90659 , 90677 , 90679 , 90697 , 90703 , 90709 , 90731 , 90749 , 90787 , 90793 , 90803 , 90821 , 90823 , 90833 , 90841 , 90847 , 90863 , 90887 , 90901 , 90907 , 90911 , 90917 , 90931 , 90947 , 90971 , 90977 , 90989 , 90997 , 91009 , 91019 , 91033 , 91079 , 91081 , 91097 , 91099 , 91121 , 91127 , 91129 , 91139 , 91141 , 91151 , 91153 , 91159 , 91163 , 91183 , 91193 , 91199 , 91229 , 91237 , 91243 , 91249 , 91253 , 91283 , 91291 , 91297 , 91303 , 91309 , 91331 , 91367 , 91369 , 91373 , 91381 , 91387 , 91393 , 91397 , 91411 , 91423 , 91433 , 91453 , 91457 , 91459 , 91463 , 91493 , 91499 , 91513 , 91529 , 91541 , 91571 , 91573 , 91577 , 91583 , 91591 , 91621 , 91631 , 91639 , 91673 , 91691 , 91703 , 91711 , 91733 , 91753 , 91757 , 91771 , 91781 , 91801 , 91807 , 91811 , 91813 , 91823 , 91837 , 91841 , 91867 , 91873 , 91909 , 91921 , 91939 , 91943 , 91951 , 91957 , 91961 , 91967 , 91969 , 91997 , 92003 , 92009 , 92033 , 92041 , 92051 , 92077 , 92083 , 92107 , 92111 , 92119 , 92143 , 92153 , 92173 , 92177 , 92179 , 92189 , 92203 , 92219 , 92221 , 92227 , 92233 , 92237 , 92243 , 92251 , 92269 , 92297 , 92311 , 92317 , 92333 , 92347 , 92353 , 92357 , 92363 , 92369 , 92377 , 92381 , 92383 , 92387 , 92399 , 92401 , 92413 , 92419 , 92431 , 92459 , 92461 , 92467 , 92479 , 92489 , 92503 , 92507 , 92551 , 92557 , 92567 , 92569 , 92581 , 92593 , 92623 , 92627 , 92639 , 92641 , 92647 , 92657 , 92669 , 92671 , 92681 , 92683 , 92693 , 92699 , 92707 , 92717 , 92723 , 92737 , 92753 , 92761 , 92767 , 92779 , 92789 , 92791 , 92801 , 92809 , 92821 , 92831 , 92849 , 92857 , 92861 , 92863 , 92867 , 92893 , 92899 , 92921 , 92927 , 92941 , 92951 , 92957 , 92959 , 92987 , 92993 , 93001 , 93047 , 93053 , 93059 , 93077 , 93083 , 93089 , 93097 , 93103 , 93113 , 93131 , 93133 , 93139 , 93151 , 93169 , 93179 , 93187 , 93199 , 93229 , 93239 , 93241 , 93251 , 93253 , 93257 , 93263 , 93281 , 93283 , 93287 , 93307 , 93319 , 93323 , 93329 , 93337 , 93371 , 93377 , 93383 , 93407 , 93419 , 93427 , 93463 , 93479 , 93481 , 93487 , 93491 , 93493 , 93497 , 93503 , 93523 , 93529 , 93553 , 93557 , 93559 , 93563 , 93581 , 93601 , 93607 , 93629 , 93637 , 93683 , 93701 , 93703 , 93719 , 93739 , 93761 , 93763 , 93787 , 93809 , 93811 , 93827 , 93851 , 93871 , 93887 , 93889 , 93893 , 93901 , 93911 , 93913 , 93923 , 93937 , 93941 , 93949 , 93967 , 93971 , 93979 , 93983 , 93997 , 94007 , 94009 , 94033 , 94049 , 94057 , 94063 , 94079 , 94099 , 94109 , 94111 , 94117 , 94121 , 94151 , 94153 , 94169 , 94201 , 94207 , 94219 , 94229 , 94253 , 94261 , 94273 , 94291 , 94307 , 94309 , 94321 , 94327 , 94331 , 94343 , 94349 , 94351 , 94379 , 94397 , 94399 , 94421 , 94427 , 94433 , 94439 , 94441 , 94447 , 94463 , 94477 , 94483 , 94513 , 94529 , 94531 , 94541 , 94543 , 94547 , 94559 , 94561 , 94573 , 94583 , 94597 , 94603 , 94613 , 94621 , 94649 , 94651 , 94687 , 94693 , 94709 , 94723 , 94727 , 94747 , 94771 , 94777 , 94781 , 94789 , 94793 , 94811 , 94819 , 94823 , 94837 , 94841 , 94847 , 94849 , 94873 , 94889 , 94903 , 94907 , 94933 , 94949 , 94951 , 94961 , 94993 , 94999 , 95003 , 95009 , 95021 , 95027 , 95063 , 95071 , 95083 , 95087 , 95089 , 95093 , 95101 , 95107 , 95111 , 95131 , 95143 , 95153 , 95177 , 95189 , 95191 , 95203 , 95213 , 95219 , 95231 , 95233 , 95239 , 95257 , 95261 , 95267 , 95273 , 95279 , 95287 , 95311 , 95317 , 95327 , 95339 , 95369 , 95383 , 95393 , 95401 , 95413 , 95419 , 95429 , 95441 , 95443 , 95461 , 95467 , 95471 , 95479 , 95483 , 95507 , 95527 , 95531 , 95539 , 95549 , 95561 , 95569 , 95581 , 95597 , 95603 , 95617 , 95621 , 95629 , 95633 , 95651 , 95701 , 95707 , 95713 , 95717 , 95723 , 95731 , 95737 , 95747 , 95773 , 95783 , 95789 , 95791 , 95801 , 95803 , 95813 , 95819 , 95857 , 95869 , 95873 , 95881 , 95891 , 95911 , 95917 , 95923 , 95929 , 95947 , 95957 , 95959 , 95971 , 95987 , 95989 , 96001 , 96013 , 96017 , 96043 , 96053 , 96059 , 96079 , 96097 , 96137 , 96149 , 96157 , 96167 , 96179 , 96181 , 96199 , 96211 , 96221 , 96223 , 96233 , 96259 , 96263 , 96269 , 96281 , 96289 , 96293 , 96323 , 96329 , 96331 , 96337 , 96353 , 96377 , 96401 , 96419 , 96431 , 96443 , 96451 , 96457 , 96461 , 96469 , 96479 , 96487 , 96493 , 96497 , 96517 , 96527 , 96553 , 96557 , 96581 , 96587 , 96589 , 96601 , 96643 , 96661 , 96667 , 96671 , 96697 , 96703 , 96731 , 96737 , 96739 , 96749 , 96757 , 96763 , 96769 , 96779 , 96787 , 96797 , 96799 , 96821 , 96823 , 96827 , 96847 , 96851 , 96857 , 96893 , 96907 , 96911 , 96931 , 96953 , 96959 , 96973 , 96979 , 96989 , 96997 , 97001 , 97003 , 97007 , 97021 , 97039 , 97073 , 97081 , 97103 , 97117 , 97127 , 97151 , 97157 , 97159 , 97169 , 97171 , 97177 , 97187 , 97213 , 97231 , 97241 , 97259 , 97283 , 97301 , 97303 , 97327 , 97367 , 97369 , 97373 , 97379 , 97381 , 97387 , 97397 , 97423 , 97429 , 97441 , 97453 , 97459 , 97463 , 97499 , 97501 , 97511 , 97523 , 97547 , 97549 , 97553 , 97561 , 97571 , 97577 , 97579 , 97583 , 97607 , 97609 , 97613 , 97649 , 97651 , 97673 , 97687 , 97711 , 97729 , 97771 , 97777 , 97787 , 97789 , 97813 , 97829 , 97841 , 97843 , 97847 , 97849 , 97859 , 97861 , 97871 , 97879 , 97883 , 97919 , 97927 , 97931 , 97943 , 97961 , 97967 , 97973 , 97987 , 98009 , 98011 , 98017 , 98041 , 98047 , 98057 , 98081 , 98101 , 98123 , 98129 , 98143 , 98179 , 98207 , 98213 , 98221 , 98227 , 98251 , 98257 , 98269 , 98297 , 98299 , 98317 , 98321 , 98323 , 98327 , 98347 , 98369 , 98377 , 98387 , 98389 , 98407 , 98411 , 98419 , 98429 , 98443 , 98453 , 98459 , 98467 , 98473 , 98479 , 98491 , 98507 , 98519 , 98533 , 98543 , 98561 , 98563 , 98573 , 98597 , 98621 , 98627 , 98639 , 98641 , 98663 , 98669 , 98689 , 98711 , 98713 , 98717 , 98729 , 98731 , 98737 , 98773 , 98779 , 98801 , 98807 , 98809 , 98837 , 98849 , 98867 , 98869 , 98873 , 98887 , 98893 , 98897 , 98899 , 98909 , 98911 , 98927 , 98929 , 98939 , 98947 , 98953 , 98963 , 98981 , 98993 , 98999 , 99013 , 99017 , 99023 , 99041 , 99053 , 99079 , 99083 , 99089 , 99103 , 99109 , 99119 , 99131 , 99133 , 99137 , 99139 , 99149 , 99173 , 99181 , 99191 , 99223 , 99233 , 99241 , 99251 , 99257 , 99259 , 99277 , 99289 , 99317 , 99347 , 99349 , 99367 , 99371 , 99377 , 99391 , 99397 , 99401 , 99409 , 99431 , 99439 , 99469 , 99487 , 99497 , 99523 , 99527 , 99529 , 99551 , 99559 , 99563 , 99571 , 99577 , 99581 , 99607 , 99611 , 99623 , 99643 , 99661 , 99667 , 99679 , 99689 , 99707 , 99709 , 99713 , 99719 , 99721 , 99733 , 99761 , 99767 , 99787 , 99793 , 99809 , 99817 , 99823 , 99829 , 99833 , 99839 , 99859 , 99871 , 99877 , 99881 , 99901 , 99907 , 99923 , 99929 , 99961 , 99971 , 99989 , 99991 , 100003 ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> index = bisect . bisect_left ( l , n ) <NEWLINE> ans = l [ index ] <NEWLINE> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> pn = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ex_list = [ ( pn [ i ] + 1 ) / 2 for i in range ( len ( pn ) ) ] <NEWLINE> ex_wa_list = [ ] <NEWLINE> wa = 0 <NEWLINE> for i in range ( len ( ex_list ) ) : <NEWLINE> <INDENT> wa += ex_list [ i ] <NEWLINE> ex_wa_list . append ( wa ) <NEWLINE> <DEDENT> Ans_list = [ ] <NEWLINE> wa2 = 0 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> wa2 = ex_wa_list [ k - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wa2 = ex_wa_list [ k - 1 + i ] - ex_wa_list [ i - 1 ] <NEWLINE> <DEDENT> Ans_list . append ( wa2 ) <NEWLINE> <DEDENT> print ( max ( Ans_list ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> Ans = <STRING> <NEWLINE> List = [ ] <NEWLINE> before_n = 0 <NEWLINE> for e in A : <NEWLINE> <INDENT> if e == before_n : <NEWLINE> <INDENT> Ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> before_n = e <NEWLINE> <DEDENT> <DEDENT> print ( Ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = ( <STRING> ) <NEWLINE> f1tob = [ ] <NEWLINE> fbtoN = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> f1tob . append ( b ) <NEWLINE> <DEDENT> elif b == N : <NEWLINE> <INDENT> fbtoN . append ( a ) <NEWLINE> <DEDENT> <DEDENT> f1toba = set ( f1tob ) <NEWLINE> fbtoNa = set ( fbtoN ) <NEWLINE> if bool ( fbtoNa & f1toba ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> suml = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> delta = abs ( K - x [ i ] ) <NEWLINE> if x [ i ] < delta : <NEWLINE> <INDENT> suml [ i ] = suml [ i ] + x [ i ] * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> suml [ i ] = suml [ i ] + delta * 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( suml ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> a . append ( float ( <STRING> ) ) <NEWLINE> a = a [ : : - 1 ] <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if a [ - 1 ] != 1 : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . pop ( ) <NEWLINE> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i == a [ - 1 ] : <NEWLINE> <INDENT> a . pop ( ) <NEWLINE> continue <NEWLINE> <DEDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> dp [ i ] %= mod <NEWLINE> <DEDENT> print ( dp [ n ] ) <NEWLINE>
import bisect <NEWLINE> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> L = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> a = L [ n - 1 - i ] <NEWLINE> b = L [ n - 1 - j ] <NEWLINE> <NL> if a - b < b : <NEWLINE> <INDENT> ans += ( n - 1 - j ) - bisect . bisect_left ( L , a - b + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter , defaultdict , deque <NEWLINE> from heapq import heappop , heappush <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> import sys , math , itertools , fractions , pprint <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def inp ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n , m = inpl ( ) <NEWLINE> a = inpl ( ) <NEWLINE> a . sort ( ) <NEWLINE> bc = [ inpl ( ) for _ in range ( m ) ] <NEWLINE> bc . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> ind = - 1 <NEWLINE> now = - 1 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if cnt == 0 : <NEWLINE> <INDENT> ind += 1 <NEWLINE> if ind >= m : break <NEWLINE> cnt , now = bc [ ind ] <NEWLINE> <DEDENT> if a [ i ] >= now : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a [ i ] = now <NEWLINE> cnt -= 1 <NEWLINE> <DEDENT> print ( sum ( a ) ) <NEWLINE>
L , R = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if R - L > 2019 * 2 : <NEWLINE> <INDENT> R -= ( ( R - L ) // 2019 - 1 ) * 2019 <NEWLINE> <DEDENT> ans = 2019 <NEWLINE> for i in range ( L , R ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , ( i * j ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
dxdy = ( ( 0 , 1 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( - 1 , 0 ) ) <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> <NL> S . append ( <STRING> * ( W + 2 ) ) <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> S . append ( <STRING> + s + <STRING> ) <NEWLINE> <DEDENT> S . append ( <STRING> * ( W + 2 ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> for h in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for w in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if S [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ok = False <NEWLINE> for dx , dy in dxdy : <NEWLINE> <INDENT> if S [ h + dx ] [ w + dy ] == <STRING> : <NEWLINE> <INDENT> ok = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ok == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from functools import lru_cache <NEWLINE> import bisect <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> if set ( S ) & set ( T ) != set ( T ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lt = len ( T ) <NEWLINE> ls = len ( S ) <NEWLINE> st = set ( T ) <NEWLINE> D = dict ( ) <NEWLINE> for t in st : <NEWLINE> <INDENT> D [ t ] = list ( ) <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if t == s : <NEWLINE> <INDENT> D [ t ] . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> pre = - 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def judge ( pre , t ) : <NEWLINE> <INDENT> X = D [ t ] <NEWLINE> index = bisect . bisect ( X , pre ) <NEWLINE> if len ( X ) == index : <NEWLINE> <INDENT> return ( X [ 0 ] , True ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( X [ index ] , False ) <NEWLINE> <NL> <DEDENT> <DEDENT> for t in T : <NEWLINE> <INDENT> J = judge ( pre , t ) <NEWLINE> pre = J [ 0 ] <NEWLINE> if J [ 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt * len ( S ) + pre + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> rl = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , rl ( ) . strip ( ) . split ( ) ) <NEWLINE> eaw = [ list ( map ( int , rl ( ) . strip ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> d = dict ( ( ( x [ 0 ] - 1 , x [ 1 ] - 1 ) , - x [ 2 ] ) for x in eaw ) <NEWLINE> inf = 10 ** 14 <NEWLINE> mdl = [ inf ] * n <NEWLINE> mdl [ 0 ] = 0 <NEWLINE> def blrelax ( dl , k ) : <NEWLINE> <INDENT> for _ in range ( k ) : <NEWLINE> <INDENT> for e in iter ( d ) : <NEWLINE> <INDENT> if dl [ e [ 0 ] ] + d [ e ] < dl [ e [ 1 ] ] : <NEWLINE> <INDENT> dl [ e [ 1 ] ] = dl [ e [ 0 ] ] + d [ e ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> blrelax ( mdl , n - 1 ) <NEWLINE> a1 = mdl [ n - 1 ] <NEWLINE> blrelax ( mdl , n ) <NEWLINE> a2 = mdl [ n - 1 ] <NEWLINE> if a1 > a2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - a1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> newA = sorted ( A ) <NEWLINE> ma = newA [ N - 1 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == ma : <NEWLINE> <INDENT> print ( newA [ N - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ma ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = [ 0 ] * 101 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> inp = int ( input ( ) ) <NEWLINE> d [ inp ] += 1 <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in d : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> N , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> P = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> prev_K_sum = max_K_sum = sum ( P [ : K ] ) <NEWLINE> start = 0 <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> cur_K_sum = prev_K_sum - P [ i ] + P [ i + K ] <NEWLINE> if cur_K_sum > max_K_sum : <NEWLINE> <INDENT> start = i + 1 <NEWLINE> max_K_sum = cur_K_sum <NEWLINE> <DEDENT> prev_K_sum = cur_K_sum <NEWLINE> <DEDENT> target = P [ start : start + K ] <NEWLINE> ans = sum ( [ ( num + 1 ) / 2.0 for num in target ] ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> t = [ 0 ] * n <NEWLINE> r = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> t [ i ] = r <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ input ( ) . split ( ) for i in range ( n ) ] <NEWLINE> l2 = [ x for x in range ( n ) ] <NEWLINE> base = list ( zip ( l2 , l ) ) <NEWLINE> ans = sorted ( base , key = lambda x : int ( x [ 1 ] [ 1 ] ) , reverse = True ) <NEWLINE> ans = sorted ( ans , key = lambda x : x [ 1 ] [ 0 ] ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( 1 + ans [ i ] [ 0 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> L = lcm ( N , M ) <NEWLINE> G = math . gcd ( N , M ) <NEWLINE> for i in range ( G ) : <NEWLINE> <INDENT> if S [ N // G * i ] != T [ M // G * i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( L ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce , lru_cache <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def TUPLE ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N , K = MAP ( ) <NEWLINE> xy = [ LIST ( ) for _ in range ( N ) ] <NEWLINE> ans = INF <NEWLINE> <NL> xy . sort ( ) <NEWLINE> for l in range ( N - K + 1 ) : <COMMENT> <NEWLINE> <INDENT> for r in range ( l + K , N + 1 ) : <COMMENT> <NEWLINE> <INDENT> y = sorted ( xy [ l : r ] , key = lambda x : x [ 1 ] ) <COMMENT> <NEWLINE> for i in range ( r - l - K + 1 ) : <NEWLINE> <INDENT> sq = ( xy [ r - 1 ] [ 0 ] - xy [ l ] [ 0 ] ) * ( y [ i + K - 1 ] [ 1 ] - y [ i ] [ 1 ] ) <NEWLINE> ans = min ( ans , sq ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> med_idx = int ( n / 2 ) <NEWLINE> print ( d [ med_idx ] - d [ med_idx - 1 ] ) <NEWLINE>
<COMMENT> <NL> n , k , * P = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> p = [ ( i + 1 ) / 2 for i in P ] <NEWLINE> c = sum ( p [ : k ] ) <NEWLINE> ans = c <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> c = c + p [ i + k ] - p [ i ] <NEWLINE> ans = max ( c , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> E = int ( input ( ) ) <NEWLINE> <NL> r = [ ] <NEWLINE> <NL> if A % 10 != 0 : <NEWLINE> <INDENT> r . append ( 10 - A % 10 ) <NEWLINE> A += 10 - A % 10 <NEWLINE> <DEDENT> if B % 10 != 0 : <NEWLINE> <INDENT> r . append ( 10 - B % 10 ) <NEWLINE> B += 10 - B % 10 <NEWLINE> <DEDENT> if C % 10 != 0 : <NEWLINE> <INDENT> r . append ( 10 - C % 10 ) <NEWLINE> C += 10 - C % 10 <NEWLINE> <DEDENT> if D % 10 != 0 : <NEWLINE> <INDENT> r . append ( 10 - D % 10 ) <NEWLINE> D += 10 - D % 10 <NEWLINE> <DEDENT> if E % 10 != 0 : <NEWLINE> <INDENT> r . append ( 10 - E % 10 ) <NEWLINE> E += 10 - E % 10 <NEWLINE> <NL> <DEDENT> if r : <NEWLINE> <INDENT> print ( A + B + C + D + E - max ( r ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A + B + C + D + E ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 3000 ) <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> def comb ( n , k ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if n < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if k < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if k == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return comb ( n - 1 , k - 1 ) * n // k <NEWLINE> <DEDENT> R = N - K <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> A = K - 1 <NEWLINE> B = R - 1 <NEWLINE> if N == K : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> for i in range ( 2 , K + 1 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> x = comb ( A , i - 1 ) <NEWLINE> y = comb ( B , i - 2 ) <NEWLINE> z = comb ( B , i - 1 ) <NEWLINE> w = comb ( B , i ) <NEWLINE> ans = x * ( y + 2 * z + w ) <NEWLINE> print ( ans % MOD ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> opp = a [ a [ i - 1 ] - 1 ] <NEWLINE> if i == opp : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
import numpy as np <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> m = n ** 2 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dp = np . zeros ( ( n + 1 , n + 1 , m + 1 ) , dtype = np . int64 ) <NEWLINE> dp [ 0 , 0 , 0 ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 ) : <NEWLINE> <INDENT> dp [ i , j , 2 * j : ] = ( 2 * j + 1 ) * dp [ i - 1 , j , : m + 1 - 2 * j ] <NEWLINE> if j + 1 <= i - 1 : <NEWLINE> <INDENT> dp [ i , j , 2 * j : ] += ( j + 1 ) * ( j + 1 ) * dp [ i - 1 , j + 1 , : m + 1 - 2 * j ] <NEWLINE> <DEDENT> if j : <NEWLINE> <INDENT> dp [ i , j , 2 * j : ] += dp [ i - 1 , j - 1 , : m + 1 - 2 * j ] <NEWLINE> <DEDENT> dp [ i , j , 2 * j : ] %= mod <NEWLINE> <DEDENT> <DEDENT> ans = dp [ n , 0 , k ] <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> from bisect import bisect_left , bisect_right <NEWLINE> <NL> n , d , a = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ ] <NEWLINE> xh = dict ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> xi , hi = map ( int , input ( ) . split ( ) ) <NEWLINE> x . append ( xi ) <NEWLINE> xh [ xi ] = hi <NEWLINE> <DEDENT> x . sort ( ) <NEWLINE> <NL> l = 0 <NEWLINE> ret = 0 <NEWLINE> ai = [ 0 ] * ( n + 1 ) <NEWLINE> anow = 0 <NEWLINE> while l < n : <NEWLINE> <INDENT> xl = x [ l ] <NEWLINE> hl = xh [ xl ] <NEWLINE> anow += ai [ l ] <NEWLINE> hl -= a * anow <NEWLINE> if hl > 0 : <NEWLINE> <INDENT> r = bisect_right ( x , xl + 2 * d ) <NEWLINE> k = ( hl + ( a - 1 ) ) // a <NEWLINE> ret += k <NEWLINE> anow += k <NEWLINE> ai [ r ] -= k <NEWLINE> <DEDENT> l += 1 <NEWLINE> <DEDENT> print ( ret ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> a_copy = sorted ( a ) <NEWLINE> a_max = a_copy [ - 1 ] <NEWLINE> a_second = a_copy [ - 2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == a_max : <NEWLINE> <INDENT> print ( a_second ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a_max ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = [ <STRING> . join ( sorted ( input ( ) ) ) for _ in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> dic = { } <NEWLINE> for s in S : <NEWLINE> <INDENT> if s in dic . keys ( ) : <NEWLINE> <INDENT> cnt += dic [ s ] <NEWLINE> dic [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ s ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> first = [ 0 ] * 10 <NEWLINE> a = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if first [ S [ i ] ] == 0 : <NEWLINE> <INDENT> first [ S [ i ] ] = 1 <NEWLINE> a += 1 <NEWLINE> second = [ 0 ] * 10 <NEWLINE> b = 0 <NEWLINE> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if second [ S [ j ] ] == 0 : <NEWLINE> <INDENT> second [ S [ j ] ] = 1 <NEWLINE> b += 1 <NEWLINE> third = [ 0 ] * 10 <NEWLINE> c = 0 <NEWLINE> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> if third [ S [ k ] ] == 0 : <NEWLINE> <INDENT> third [ S [ k ] ] = 1 <NEWLINE> ans += 1 <NEWLINE> c += 1 <NEWLINE> if c == 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if b == 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if a == 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> l = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> r = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> d = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> u = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> s = np . array ( [ list ( input ( ) ) for _ in range ( H ) ] ) == <STRING> <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> u [ i ] = ( u [ i - 1 ] + 1 ) * s [ i ] <NEWLINE> d [ - i - 1 ] = ( d [ - i ] + 1 ) * s [ - i - 1 ] <NEWLINE> <DEDENT> for i in range ( W ) : <NEWLINE> <INDENT> l [ : , i ] = ( l [ : , i - 1 ] + 1 ) * s [ : , i ] <NEWLINE> r [ : , - i - 1 ] = ( r [ : , - i ] + 1 ) * s [ : , - i - 1 ] <NEWLINE> <DEDENT> print ( np . max ( u + d + l + r ) - 3 ) <NEWLINE>
<COMMENT> <NL> <NL> def get_input ( ) -> tuple : <NEWLINE> <INDENT> <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> return N , S <NEWLINE> <NL> <NL> <DEDENT> def main ( N : int , S : str ) -> None : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> S_i_list = [ ] <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> S_i = S [ i ] <NEWLINE> if S_i in S_i_list : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> S_j_list = [ ] <NEWLINE> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> S_j = S [ j ] <NEWLINE> if S_j in S_j_list : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += len ( set ( S [ j + 1 : N ] ) ) <NEWLINE> S_j_list . append ( S_j ) <NEWLINE> <DEDENT> S_i_list . append ( S_i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> N , S = get_input ( ) <NEWLINE> <NL> <COMMENT> <NL> main ( N , S ) <NEWLINE> <DEDENT>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> a = A [ 0 ] <NEWLINE> b = A [ 1 ] <NEWLINE> c = b - a <NEWLINE> <NL> if a <= 0 <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif a > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif b < 0 : <NEWLINE> <INDENT> if c % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> M = 10 ** 9 + 7 <NEWLINE> lis = [ 1 ] + [ 0 ] * n <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> lis [ i ] = - 1 <NEWLINE> <DEDENT> lis [ 1 ] += 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if lis [ i + 2 ] < 0 : <NEWLINE> <INDENT> lis [ i + 2 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis [ i + 2 ] = ( lis [ i + 1 ] + lis [ i ] ) % M <NEWLINE> <DEDENT> <DEDENT> print ( lis [ n ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b0 = [ ] <NEWLINE> b1 = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> b0 . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b1 . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if n % 2 != 0 : <NEWLINE> <INDENT> b0 = list ( reversed ( b0 ) ) <NEWLINE> b = b0 + b1 <NEWLINE> print ( <STRING> . join ( map ( str , b ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b1 = list ( reversed ( b1 ) ) <NEWLINE> b = b1 + b0 <NEWLINE> print ( <STRING> . join ( map ( str , b ) ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = [ 0 ] * ( N + 1 ) <NEWLINE> L [ 0 ] = 2 <NEWLINE> L [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> L [ i ] = L [ i - 1 ] + L [ i - 2 ] <NEWLINE> <NL> <DEDENT> print ( L [ N ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> Cost = [ 0 ] * N <NEWLINE> Cost [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> tmp = [ Cost [ k ] + abs ( h [ i ] - h [ k ] ) for k in range ( max ( 0 , i - K ) , i ) ] <NEWLINE> Cost [ i ] = min ( tmp ) <NEWLINE> <NL> <DEDENT> print ( Cost [ - 1 ] ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> import numpy as np <NEWLINE> <NL> np . set_printoptions ( linewidth = 200 ) <NEWLINE> <NL> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> v_max = 10 ** 3 * 100 * 10 <NEWLINE> w_max = 10 ** 9 * v_max <NEWLINE> <NL> <COMMENT> <NL> dp = np . full ( v_max , w_max , dtype = np . int64 ) <NEWLINE> <COMMENT> <NL> dp [ 0 ] = 0 <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> w , v = lst [ n ] <NEWLINE> dp [ v : ] = np . minimum ( dp [ v : ] , dp [ : - v ] + w ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i , w in enumerate ( dp ) : <NEWLINE> <INDENT> if w <= W : <NEWLINE> <INDENT> ans = i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> def gcd ( x , y ) : <NEWLINE> <INDENT> if y == 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> return gcd ( y , x % y ) <NEWLINE> <NL> <DEDENT> n = gcd ( a , b ) <NEWLINE> ans = 0 <NEWLINE> i = 2 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> n /= i <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if n != 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans + 1 ) <NEWLINE>
N = input ( ) <NEWLINE> print ( max ( sum ( [ int ( i ) for i in N ] ) , ( len ( N ) - 1 ) * 9 + int ( N [ 0 ] ) - 1 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> d = sorted ( list ( ( input ( ) ) for _ in range ( N ) ) ) <NEWLINE> count = 0 <NEWLINE> dum = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if d [ i ] != dum : <NEWLINE> <INDENT> dum = d [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A == B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif B == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A > B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> b = l [ : i ] <NEWLINE> c = l [ i + 1 : ] <NEWLINE> for j in b : <NEWLINE> <INDENT> ans += bisect . bisect_left ( c , l [ i ] + j ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys , re , os <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians , gcd <NEWLINE> from itertools import permutations , combinations , product , accumulate <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from functools import reduce <NEWLINE> from bisect import bisect_left , insort_left <NEWLINE> from heapq import heapify , heappush , heappop <NEWLINE> <NL> INPUT = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> INT = lambda : int ( INPUT ( ) ) <NEWLINE> MAP = lambda : map ( int , INPUT ( ) . split ( ) ) <NEWLINE> S_MAP = lambda : map ( str , INPUT ( ) . split ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , INPUT ( ) . split ( ) ) ) <NEWLINE> S_LIST = lambda : list ( map ( str , INPUT ( ) . split ( ) ) ) <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> H , W = MAP ( ) <NEWLINE> S = [ ] <NEWLINE> walls = 0 <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> line = INPUT ( ) <NEWLINE> walls += line . count ( <STRING> ) <NEWLINE> S . append ( line ) <NEWLINE> <NL> <DEDENT> dist = [ [ INF ] * W for _ in range ( H ) ] <NEWLINE> dist [ 0 ] [ 0 ] = 1 <NEWLINE> queue = deque ( [ [ 0 , 0 ] ] ) <NEWLINE> while queue : <NEWLINE> <INDENT> y , x = queue . popleft ( ) <NEWLINE> if y == H - 1 and x == W - 1 : <NEWLINE> <INDENT> print ( H * W - walls - dist [ y ] [ x ] ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> for dy , dx in [ ( y , x - 1 ) , ( y - 1 , x ) , ( y , x + 1 ) , ( y + 1 , x ) ] : <NEWLINE> <INDENT> if 0 <= dy < H and 0 <= dx < W and S [ dy ] [ dx ] == <STRING> and dist [ dy ] [ dx ] == INF : <NEWLINE> <INDENT> dist [ dy ] [ dx ] = dist [ y ] [ x ] + 1 <NEWLINE> queue . append ( [ dy , dx ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ input ( ) for _ in range ( h ) ] <NEWLINE> dx = [ 1 , - 1 , 0 , 0 ] <NEWLINE> dy = [ 0 , 0 , 1 , - 1 ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if l [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for di in range ( 4 ) : <NEWLINE> <INDENT> y = i + dx [ di ] <NEWLINE> x = j + dy [ di ] <NEWLINE> if x < 0 or y < 0 or x > w - 1 or y > h - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if l [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if cnt == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
d = { <STRING> : 7 , <STRING> : 6 , <STRING> : 5 , <STRING> : 4 , <STRING> : 3 , <STRING> : 2 , <STRING> : 1 } <NEWLINE> <NL> s = input ( ) <NEWLINE> print ( d [ s ] ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> import numpy as np <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> <NL> move = ( ( 0 , 1 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( - 1 , 0 ) ) <NEWLINE> seen = [ [ False ] * W for _ in range ( H ) ] <NEWLINE> ans = 0 <NEWLINE> for sh in range ( H ) : <NEWLINE> <INDENT> for sw in range ( W ) : <NEWLINE> <INDENT> if S [ sh ] [ sw ] == <STRING> or seen [ sh ] [ sw ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> seen [ sh ] [ sw ] = True <NEWLINE> queue = deque ( [ ( sh , sw ) ] ) <NEWLINE> <COMMENT> <NL> distance = np . full ( ( H , W ) , - 1 , dtype = np . int16 ) <NEWLINE> distance [ sh , sw ] = 0 <NEWLINE> while queue : <NEWLINE> <INDENT> h , w = queue . popleft ( ) <NEWLINE> for dh , dw in move : <NEWLINE> <INDENT> nh = h + dh <NEWLINE> nw = w + dw <NEWLINE> if ( 1 <NEWLINE> <INDENT> and 0 <= nh < H <NEWLINE> and 0 <= nw < W <NEWLINE> and S [ nh ] [ nw ] == <STRING> <NEWLINE> and distance [ nh ] [ nw ] == - 1 ) : <NEWLINE> distance [ nh ] [ nw ] = distance [ h ] [ w ] + 1 <NEWLINE> queue . append ( ( nh , nw ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = max ( ans , distance . max ( ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> minus , plus = [ ] , [ ] <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> if x < 0 : <NEWLINE> <INDENT> minus . append ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> plus . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> tmp = sum ( [ abs ( x ) for x in a ] ) <NEWLINE> <NL> if len ( minus ) % 2 == 0 : <NEWLINE> <INDENT> print ( tmp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if plus == [ ] or abs ( minus [ - 1 ] ) < plus [ 0 ] : <NEWLINE> <INDENT> print ( tmp + minus [ - 1 ] * 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( tmp - plus [ 0 ] * 2 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> a . append ( A ) <NEWLINE> <NL> <DEDENT> b = sorted ( a ) <NEWLINE> <NL> m = max ( a ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == m : <NEWLINE> <INDENT> ans . append ( b [ - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( m ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <NL> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> c = collections . Counter ( l ) <NEWLINE> L = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> M = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> <NL> for x , y in c . items ( ) : <NEWLINE> <INDENT> L [ x ] += y <NEWLINE> <NL> <DEDENT> M [ 0 ] = L [ 0 ] <NEWLINE> M [ 10 ** 5 ] = L [ 10 ** 5 ] <NEWLINE> for i in range ( 1 , 10 ** 5 ) : <NEWLINE> <INDENT> M [ i ] = L [ i - 1 ] + L [ i ] + L [ i + 1 ] <NEWLINE> <DEDENT> print ( max ( M ) ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> print ( 6 - A - B ) <NEWLINE>
n , k , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ns_points = [ k ] * n <NEWLINE> ns_corrects = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> ns_corrects [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> for j in range ( len ( ns_points ) ) : <NEWLINE> <INDENT> if ns_points [ j ] - ( q - ns_corrects [ j ] ) <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l_max = 0 <NEWLINE> r_min = 10 ** 5 + 1 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> l_max = max ( l_max , l ) <NEWLINE> r_min = min ( r_min , r ) <NEWLINE> <DEDENT> print ( max ( 0 , r_min - l_max + 1 ) ) <NEWLINE>
N , D , A = map ( int , input ( ) . split ( ) ) <NEWLINE> monster = [ ] <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> monster . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> monster . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> monster [ k ] [ 1 ] = int ( ( monster [ k ] [ 1 ] - 0.1 ) // A + 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> <NL> final = monster [ - 1 ] [ 0 ] <NEWLINE> ruiseki = 0 <NEWLINE> minuslist = [ ] <NEWLINE> j = 0 <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> while ( j < len ( minuslist ) ) : <NEWLINE> <INDENT> if monster [ k ] [ 0 ] >= minuslist [ j ] [ 0 ] : <NEWLINE> <INDENT> ruiseki -= minuslist [ j ] [ 1 ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ruiseki < monster [ k ] [ 1 ] : <NEWLINE> <INDENT> ans += monster [ k ] [ 1 ] - ruiseki <NEWLINE> if monster [ k ] [ 0 ] + 2 * D + 1 <= final : <NEWLINE> <INDENT> minuslist . append ( [ monster [ k ] [ 0 ] + 2 * D + 1 , monster [ k ] [ 1 ] - ruiseki ] ) <NEWLINE> <DEDENT> ruiseki = monster [ k ] [ 1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> f = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> f [ a - 1 ] . append ( [ b - 1 , c ] ) <NEWLINE> f [ b - 1 ] . append ( [ a - 1 , c ] ) <NEWLINE> <DEDENT> from collections import deque <NEWLINE> d = deque ( ) <NEWLINE> s = [ - 1 ] * N <NEWLINE> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> d . append ( K - 1 ) <NEWLINE> s [ K - 1 ] = 0 <NEWLINE> while len ( d ) > 0 : <NEWLINE> <INDENT> z = d . popleft ( ) <NEWLINE> for i , j in f [ z ] : <NEWLINE> <INDENT> if s [ i ] == - 1 : <NEWLINE> <INDENT> s [ i ] = j + s [ z ] <NEWLINE> d . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( s [ x - 1 ] + s [ y - 1 ] ) <NEWLINE> <DEDENT>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if r - l >= 2019 : <NEWLINE> <INDENT> minimum = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left , right = l % 2019 , r % 2019 <NEWLINE> minimum = 2018 ** 2 <NEWLINE> for i in range ( left , right + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , right + 1 ) : <NEWLINE> <INDENT> minimum = min ( minimum , i * j % 2019 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( minimum ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> R , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> S = [ 0 , 0 ] <NEWLINE> <NL> mv = [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] <NEWLINE> MAP = [ ] <NEWLINE> flg = 0 <NEWLINE> block = 0 <NEWLINE> for _ in range ( R ) : <NEWLINE> <INDENT> t = list ( input ( ) ) <NEWLINE> block += t . count ( <STRING> ) <NEWLINE> MAP . append ( t ) <NEWLINE> <DEDENT> stack = deque ( [ S ] ) <NEWLINE> MAP_c = [ [ None ] * C for _ in range ( R ) ] <NEWLINE> MAP_c [ 0 ] [ 0 ] = 1 <NEWLINE> while stack : <NEWLINE> <INDENT> v = stack . popleft ( ) <NEWLINE> for m in mv : <NEWLINE> <INDENT> u = [ v [ 0 ] + m [ 0 ] , v [ 1 ] + m [ 1 ] ] <NEWLINE> if u [ 0 ] >= 0 and u [ 0 ] < R and u [ 1 ] >= 0 and u [ 1 ] < C and MAP [ u [ 0 ] ] [ u [ 1 ] ] == <STRING> : <NEWLINE> <INDENT> MAP [ u [ 0 ] ] [ u [ 1 ] ] = <STRING> <NEWLINE> MAP_c [ u [ 0 ] ] [ u [ 1 ] ] = MAP_c [ v [ 0 ] ] [ v [ 1 ] ] + 1 <NEWLINE> stack . append ( u ) <NEWLINE> if u == [ R - 1 , C - 1 ] : <NEWLINE> <INDENT> flg = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flg == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flg == 1 : <NEWLINE> <INDENT> a = MAP_c [ R - 1 ] [ C - 1 ] <NEWLINE> print ( R * C - a - block ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n >= 3 and m >= 3 : <NEWLINE> <INDENT> a = n * m <NEWLINE> b = n * 2 + m * 2 - 4 <NEWLINE> ans = a - b <NEWLINE> <DEDENT> elif n == 1 and m == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> elif n == 1 or m == 1 : <NEWLINE> <INDENT> a = n * m <NEWLINE> b = 2 <NEWLINE> ans = a - b <NEWLINE> <DEDENT> elif n == 2 or m == 2 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( ( b - 1 , c ) ) <NEWLINE> graph [ b - 1 ] . append ( ( a - 1 , c ) ) <NEWLINE> <NL> <DEDENT> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> visited = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> def DFS ( a , b , c ) : <NEWLINE> <INDENT> for i , j in graph [ b ] : <NEWLINE> <INDENT> if ( i != a ) : <NEWLINE> <INDENT> visited [ i ] = c + j <NEWLINE> DFS ( b , i , c + j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> DFS ( - 1 , K - 1 , 0 ) <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( visited [ x - 1 ] + visited [ y - 1 ] ) <NEWLINE> <DEDENT>
N , K = input ( ) . split ( ) <NEWLINE> <NL> dislike = set ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> next_map = { } <NEWLINE> min_digit = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> for j in range ( i , 10 ) : <NEWLINE> <INDENT> if j not in dislike : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> min_digit = j <NEWLINE> <DEDENT> next_map . update ( { i : j } ) <NEWLINE> break <NEWLINE> <DEDENT> next_map . update ( { i : min_digit } ) <NEWLINE> <DEDENT> <DEDENT> max_digit = max ( next_map . values ( ) ) <NEWLINE> <NL> num = len ( list ( N ) ) <NEWLINE> count = num <NEWLINE> cand = [ ] <NEWLINE> for n in list ( N ) : <NEWLINE> <INDENT> n = int ( n ) <NEWLINE> if n in dislike : <NEWLINE> <INDENT> n_ = next_map [ n ] <NEWLINE> cand . append ( n_ ) <NEWLINE> count -= 1 <NEWLINE> cand . extend ( count * [ min_digit ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cand . append ( n ) <NEWLINE> count -= 1 <NEWLINE> <DEDENT> <DEDENT> cand = int ( <STRING> . join ( list ( map ( str , cand ) ) ) ) <NEWLINE> if int ( N ) <= cand : <NEWLINE> <INDENT> print ( cand ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if min_digit == 0 : <NEWLINE> <INDENT> next_min = next_map [ 1 ] <NEWLINE> cand = [ next_min ] + num * [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cand = ( num + 1 ) * [ min_digit ] <NEWLINE> <DEDENT> cand = int ( <STRING> . join ( list ( map ( str , cand ) ) ) ) <NEWLINE> print ( cand ) <NEWLINE> <NL> <DEDENT>
s , k = input ( ) , int ( input ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> a = ord ( <STRING> ) + 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> ans . append ( ord ( i ) ) <NEWLINE> <DEDENT> elif a - ord ( i ) <= k and i != <STRING> : <NEWLINE> <INDENT> k -= a - ord ( i ) <NEWLINE> ans . append ( ord ( <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( ord ( i ) ) <NEWLINE> <DEDENT> <DEDENT> ans [ - 1 ] += k % 26 <NEWLINE> if ans [ - 1 ] >= a : <NEWLINE> <INDENT> ans [ - 1 ] -= 26 <NEWLINE> <DEDENT> print ( * map ( chr , ans ) , sep = <STRING> ) <NEWLINE>
from collections import Counter <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = Counter ( A ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ c ] += b <NEWLINE> <NL> <DEDENT> A = sorted ( A . items ( ) , key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> <NL> ans = 0 <NEWLINE> for key , value in A : <NEWLINE> <INDENT> if N - value >= 0 : <NEWLINE> <INDENT> ans += key * value <NEWLINE> N -= value <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += N * key <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def factorial_mod ( n , mod ) : <NEWLINE> <INDENT> ret = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ret *= i <NEWLINE> ret %= mod <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT> def comb_mod ( n , r , mod ) : <NEWLINE> <INDENT> if r > n or r < 0 : <NEWLINE> <INDENT> ret = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fact_n = factorial_mod ( n , mod ) <NEWLINE> fact_r = factorial_mod ( r , mod ) <NEWLINE> fact_nr = factorial_mod ( n - r , mod ) <NEWLINE> ret = fact_n * pow ( fact_r , mod - 2 , mod ) * pow ( fact_nr , mod - 2 , mod ) % mod <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> print ( comb_mod ( n - k + 1 , i , m ) * comb_mod ( k - 1 , i - 1 , m ) % m ) <NEWLINE> <DEDENT>
from sys import setrecursionlimit <NEWLINE> setrecursionlimit ( 10 ** 6 ) <NEWLINE> MAXN = 100 <NEWLINE> <NL> n = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> dl = [ [ None ] * ( MAXN + 1 ) for _ in range ( MAXN + 1 ) ] <NEWLINE> de = [ [ None ] * ( MAXN + 1 ) for _ in range ( MAXN + 1 ) ] <NEWLINE> <NL> <NL> def n_num_e ( d , i ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if d == 0 : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> elif de [ d ] [ i ] is not None : <NEWLINE> <INDENT> return de [ d ] [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if int ( n [ d - 1 ] ) == 0 : <NEWLINE> <INDENT> result = n_num_e ( d - 1 , i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = n_num_e ( d - 1 , i - 1 ) <NEWLINE> <DEDENT> de [ d ] [ i ] = result <NEWLINE> return result <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def n_num_l ( d , i ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if d == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif dl [ d ] [ i ] is not None : <NEWLINE> <INDENT> return dl [ d ] [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if int ( n [ d - 1 ] ) == 0 : <NEWLINE> <INDENT> ne = 0 <NEWLINE> nl = 9 * n_num_l ( d - 1 , i - 1 ) + n_num_l ( d - 1 , i ) <NEWLINE> result = ne + nl <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ne = ( int ( n [ d - 1 ] ) - 1 ) * n_num_e ( d - 1 , i - 1 ) + n_num_e ( d - 1 , i ) <NEWLINE> nl = 9 * n_num_l ( d - 1 , i - 1 ) + n_num_l ( d - 1 , i ) <NEWLINE> result = ne + nl <NEWLINE> <NL> <DEDENT> dl [ d ] [ i ] = result <NEWLINE> return result <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> answer = n_num_e ( len ( n ) , k ) + n_num_l ( len ( n ) , k ) <NEWLINE> print ( answer ) <NEWLINE> <NL>
def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N , K = LI ( ) <NEWLINE> a = LI ( ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> for i in range ( 2 ** ( N - 1 ) ) : <NEWLINE> <INDENT> bit = [ i >> j & 1 for j in range ( N - 1 ) ] <NEWLINE> if K - 1 != sum ( bit ) : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> cost , kijun = 0 , a [ 0 ] <NEWLINE> for k in range ( N - 1 ) : <NEWLINE> <INDENT> if bit [ k ] == 0 : <NEWLINE> <INDENT> kijun = max ( kijun , a [ k + 1 ] ) <NEWLINE> continue <NEWLINE> <DEDENT> if a [ k + 1 ] >= kijun + 1 : <NEWLINE> <INDENT> kijun = a [ k + 1 ] <NEWLINE> continue <NEWLINE> <DEDENT> cost += ( kijun + 1 ) - a [ k + 1 ] <NEWLINE> kijun += 1 <NEWLINE> <DEDENT> ans = min ( ans , cost ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] != S [ K - 1 ] : <NEWLINE> <INDENT> S = S . replace ( S [ i ] , <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] * ( N - K + 1 ) <NEWLINE> a [ 0 ] = sum ( P [ : K ] ) <NEWLINE> for i in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> a [ i ] = a [ i - 1 ] - P [ i - 1 ] + P [ i + K - 1 ] <NEWLINE> <NL> <DEDENT> print ( ( max ( a ) + K ) / 2 ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> if len ( S ) < 4 : <NEWLINE> <INDENT> print ( int ( S [ 0 ] ) * int ( S [ - 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
from itertools import combinations <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> work = lst [ 0 ] <NEWLINE> ini = [ x - work for x in lst ] <NEWLINE> ini_seen = [ 0 ] <NEWLINE> work = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if ini [ i ] > work : <NEWLINE> <INDENT> work = ini [ i ] <NEWLINE> ini_seen . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> mn = None <NEWLINE> for x in combinations ( range ( n - len ( ini_seen ) ) , k - len ( ini_seen ) ) : <NEWLINE> <INDENT> sm = 0 <NEWLINE> work = 0 <NEWLINE> xtoken = 0 <NEWLINE> count = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if i in ini_seen : <NEWLINE> <INDENT> count += 1 <NEWLINE> if work < ini [ i ] : work = ini [ i ] <NEWLINE> else : <NEWLINE> <INDENT> work += 1 <NEWLINE> sm += work - ini [ i ] <NEWLINE> <DEDENT> <DEDENT> elif xtoken < len ( x ) and i == x [ xtoken ] + count : <NEWLINE> <INDENT> work += 1 <NEWLINE> sm += work - ini [ i ] <NEWLINE> xtoken += 1 <NEWLINE> <DEDENT> <DEDENT> if not mn : mn = sm <NEWLINE> if mn > sm : mn = sm <NEWLINE> <DEDENT> print ( mn ) <NEWLINE>
