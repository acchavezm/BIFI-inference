N , x , MOD = map ( int , input ( ) . split ( ) ) <NEWLINE> s = x <NEWLINE> flag = False <NEWLINE> sflag = False <NEWLINE> if N == 1 : <NEWLINE> <INDENT> flag = True <NEWLINE> sflag = True <NEWLINE> print ( s ) <NEWLINE> <DEDENT> for i in range ( 1 , MOD ) : <NEWLINE> <INDENT> x = ( x * x ) % MOD <NEWLINE> s += x <NEWLINE> if N == ( i + 1 ) : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> if sflag == False : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> t_s = 0 <NEWLINE> cnt = 0 <NEWLINE> init = x <NEWLINE> for i in range ( MOD ) : <NEWLINE> <INDENT> x = ( x * x ) % MOD <NEWLINE> t_s += x <NEWLINE> cnt += 1 <NEWLINE> if x == init : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> bi = ( N - MOD ) // cnt <NEWLINE> res = ( N - MOD ) % cnt <NEWLINE> s += t_s * bi <NEWLINE> for i in range ( res ) : <NEWLINE> <INDENT> x = ( x * x ) % MOD <NEWLINE> s += x <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
cards = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> cardlist = [ ] <NEWLINE> while ( i < cards ) : <NEWLINE> <INDENT> cardlist . append ( list ( map ( str , input ( ) . split ( ) ) ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> SP = [ False ] * 13 <NEWLINE> HR = [ False ] * 13 <NEWLINE> CL = [ False ] * 13 <NEWLINE> DY = [ False ] * 13 <NEWLINE> <NL> for i in cardlist : <NEWLINE> <INDENT> num = int ( i [ 1 ] ) - 1 <NEWLINE> if ( i [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> SP [ num ] = True <NEWLINE> <DEDENT> elif ( i [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> HR [ num ] = True <NEWLINE> <DEDENT> elif ( i [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> CL [ num ] = True <NEWLINE> <DEDENT> elif ( i [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> DY [ num ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> c = 0 <NEWLINE> for i in SP : <NEWLINE> <INDENT> c += 1 <NEWLINE> if i == False : <NEWLINE> <INDENT> print ( <STRING> % c ) <NEWLINE> <DEDENT> <DEDENT> c = 0 <NEWLINE> for i in HR : <NEWLINE> <INDENT> c += 1 <NEWLINE> if i == False : <NEWLINE> <INDENT> print ( <STRING> % c ) <NEWLINE> <DEDENT> <DEDENT> c = 0 <NEWLINE> for i in CL : <NEWLINE> <INDENT> c += 1 <NEWLINE> if i == False : <NEWLINE> <INDENT> print ( <STRING> % c ) <NEWLINE> <DEDENT> <DEDENT> c = 0 <NEWLINE> for i in DY : <NEWLINE> <INDENT> c += 1 <NEWLINE> if i == False : <NEWLINE> <INDENT> print ( <STRING> % c ) <NEWLINE> <DEDENT> <DEDENT>
def f ( B ) : <NEWLINE> <INDENT> if isinstance ( B , float ) : <NEWLINE> <INDENT> if abs ( B - int ( B ) ) < 10 ** - 6 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> X = int ( input ( ) ) <NEWLINE> <NL> for a in range ( 0 , 10 ** 5 ) : <NEWLINE> <INDENT> bb = X + a ** 5 <NEWLINE> B = bb ** 0.2 <NEWLINE> if f ( B ) : <NEWLINE> <INDENT> print ( int ( B ) , a ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> a *= - 1 <NEWLINE> bb = X + a ** 5 <NEWLINE> B = bb ** 0.2 <NEWLINE> if f ( B ) : <NEWLINE> <INDENT> print ( int ( B ) , a ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> all_sum = sum ( A ) ** 2 <NEWLINE> st = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> st += A [ i ] ** 2 <NEWLINE> <DEDENT> print ( int ( ( ( all_sum - st ) // 2 ) % 1000000007 ) ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
N , Q = ( int ( X ) for X in input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = [ 0 ] * ( N + 1 ) <NEWLINE> for I in range ( 0 , N ) : <NEWLINE> <INDENT> T [ I + 1 ] = T [ I ] + ( S [ I : I + 2 ] == <STRING> ) <NEWLINE> <DEDENT> for J in range ( 0 , Q ) : <NEWLINE> <INDENT> L , R = ( int ( X ) - 1 for X in input ( ) . split ( ) ) <NEWLINE> print ( T [ R ] - T [ L ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans1 = n % k <NEWLINE> ans2 = k - n % k <NEWLINE> <NL> if ans1 > ans2 : <NEWLINE> <INDENT> print ( ans2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 if x == <STRING> else 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> def pc ( x ) : <NEWLINE> <INDENT> a = bin ( x ) [ 2 : ] <NEWLINE> return a . count ( <STRING> ) <NEWLINE> <DEDENT> def func ( x ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return func ( x % pc ( x ) ) + 1 <NEWLINE> <DEDENT> <DEDENT> pcx = x . count ( <STRING> ) <NEWLINE> if pcx == 0 : <NEWLINE> <INDENT> for _ in range ( n ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> x0 , x1 = 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> if pcx != 1 : <NEWLINE> <INDENT> x0 += pow ( 2 , n - 1 - i , pcx - 1 ) <NEWLINE> x0 %= pcx - 1 <NEWLINE> <DEDENT> x1 += pow ( 2 , n - 1 - i , pcx + 1 ) <NEWLINE> x1 %= pcx + 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> if x [ i ] == <STRING> : <NEWLINE> <INDENT> if pcx == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xx = x0 - pow ( 2 , n - 1 - i , pcx - 1 ) <NEWLINE> xx %= pcx - 1 <NEWLINE> print ( func ( xx ) + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> xx = x1 + pow ( 2 , n - 1 - i , pcx + 1 ) <NEWLINE> xx %= pcx + 1 <NEWLINE> print ( func ( xx ) + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if math . gcd ( i , j ) == 1 : <NEWLINE> <INDENT> sum += K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( g , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <NL>
import heapq <NEWLINE> import sys <NEWLINE> X , Y , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> Av = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Bv = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Cv = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( Av ) <NEWLINE> heapq . heapify ( Bv ) <NEWLINE> heapq . heapify ( Cv ) <NEWLINE> for i in range ( A - X ) : <NEWLINE> <INDENT> heapq . heappop ( Av ) <NEWLINE> <DEDENT> for i in range ( B - Y ) : <NEWLINE> <INDENT> heapq . heappop ( Bv ) <NEWLINE> <DEDENT> if C > X + Y : <NEWLINE> <INDENT> for i in range ( C - ( X + Y ) ) : <NEWLINE> <INDENT> heapq . heappop ( Cv ) <NEWLINE> <DEDENT> NotTake = X + Y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> NotTake = C <NEWLINE> <DEDENT> total = X + Y <NEWLINE> C = NotTake <NEWLINE> for _ in range ( NotTake ) : <NEWLINE> <INDENT> Amin = heapq . heappop ( Av ) <NEWLINE> Bmin = heapq . heappop ( Bv ) <NEWLINE> Cmin = heapq . heappop ( Cv ) <NEWLINE> if X > 0 and Amin == min ( Amin , Bmin , Cmin ) : <NEWLINE> <INDENT> heapq . heappush ( Bv , Bmin ) <NEWLINE> heapq . heappush ( Cv , Cmin ) <NEWLINE> X -= 1 <NEWLINE> <DEDENT> elif Y > 0 and Bmin == min ( Bmin , Cmin ) : <NEWLINE> <INDENT> heapq . heappush ( Av , Amin ) <NEWLINE> heapq . heappush ( Cv , Cmin ) <NEWLINE> Y -= 1 <NEWLINE> <DEDENT> elif C > 0 : <NEWLINE> <INDENT> heapq . heappush ( Av , Amin ) <NEWLINE> heapq . heappush ( Bv , Bmin ) <NEWLINE> C -= 1 <NEWLINE> <DEDENT> if X == 0 or Y == 0 or C == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> NotTake = X + Y + C - total <NEWLINE> if X == 0 : <NEWLINE> <INDENT> Iv = Bv <NEWLINE> Jv = Cv <NEWLINE> I = Y <NEWLINE> J = C <NEWLINE> <DEDENT> elif Y == 0 : <NEWLINE> <INDENT> Iv = Av <NEWLINE> Jv = Cv <NEWLINE> I = X <NEWLINE> J = C <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( Av ) + sum ( Bv ) + sum ( Cv ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for _ in range ( NotTake ) : <NEWLINE> <INDENT> Imin = heapq . heappop ( Iv ) <NEWLINE> Jmin = heapq . heappop ( Jv ) <NEWLINE> if I > 0 and Imin == min ( Imin , Jmin ) : <NEWLINE> <INDENT> heapq . heappush ( Jv , Jmin ) <NEWLINE> I -= 1 <NEWLINE> <DEDENT> elif J > 0 : <NEWLINE> <INDENT> heapq . heappush ( Iv , Imin ) <NEWLINE> J -= 1 <NEWLINE> <DEDENT> if J == 0 or I == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( Av ) + sum ( Bv ) + sum ( Cv ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ input ( ) for _ in range ( H ) ] <NEWLINE> <NL> def BFS ( H , W , grid ) : <NEWLINE> <INDENT> visited = [ [ True for _ in range ( W + 2 ) ] for _ in range ( H + 2 ) ] <NEWLINE> que = deque ( ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> visited [ i + 1 ] [ 1 : - 1 ] = map ( lambda _ : _ == <STRING> , grid [ i ] ) <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> if ( grid [ i ] [ j ] == <STRING> ) : <NEWLINE> <INDENT> que . append ( ( i + 1 , j + 1 , 0 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dist = [ ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) , ( 1 , 0 ) ] <NEWLINE> <NL> while que : <NEWLINE> <INDENT> x , y , c = que . popleft ( ) <NEWLINE> for dx , dy in dist : <NEWLINE> <INDENT> nx = x + dx <NEWLINE> ny = y + dy <NEWLINE> <NL> if ( not visited [ nx ] [ ny ] ) : <NEWLINE> <INDENT> que . append ( ( nx , ny , c + 1 ) ) <NEWLINE> visited [ nx ] [ ny ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return c <NEWLINE> <NL> <DEDENT> print ( BFS ( H , W , grid ) ) <NEWLINE>
<COMMENT> <NL> def merge ( target_list , left_index , right_index ) : <NEWLINE> <INDENT> global count <NEWLINE> mid_index = ( left_index + right_index ) // 2 <NEWLINE> l = target_list [ left_index : mid_index ] + [ pow ( 10 , 9 ) + 1 ] <NEWLINE> r = target_list [ mid_index : right_index ] + [ pow ( 10 , 9 ) + 1 ] <NEWLINE> l_target = 0 <NEWLINE> r_target = 0 <NEWLINE> <COMMENT> <NL> for k in range ( left_index , right_index ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if l [ l_target ] < r [ r_target ] : <NEWLINE> <INDENT> target_list [ k ] = l [ l_target ] <NEWLINE> l_target += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> target_list [ k ] = r [ r_target ] <NEWLINE> r_target += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def merge_sort ( target_list , left_index , right_index ) : <NEWLINE> <INDENT> if left_index + 1 < right_index : <NEWLINE> <INDENT> mid_index = ( left_index + right_index ) // 2 <NEWLINE> <NL> merge_sort ( target_list , left_index , mid_index ) <NEWLINE> merge_sort ( target_list , mid_index , right_index ) <NEWLINE> merge ( target_list , left_index , right_index ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> l = input ( ) <NEWLINE> target_list = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> global count <NEWLINE> count = 0 <NEWLINE> merge_sort ( target_list , 0 , len ( target_list ) ) <NEWLINE> print ( <STRING> . join ( [ str ( n ) for n in target_list ] ) ) <NEWLINE> print ( count ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( ) <NEWLINE> c = list ( ) <NEWLINE> a = 0 <NEWLINE> for i in range ( 0 , M ) : <NEWLINE> <INDENT> s . append ( 0 ) <NEWLINE> c . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( 0 , M ) : <NEWLINE> <INDENT> s [ i ] , c [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> for i in range ( 0 , M ) : <NEWLINE> <INDENT> for j in range ( 0 , M ) : <NEWLINE> <INDENT> if s [ i ] == s [ j ] and c [ i ] != c [ j ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if N == 1 : <NEWLINE> <INDENT> b = [ 0 ] <NEWLINE> for i in range ( 0 , M ) : <NEWLINE> <INDENT> b [ s [ i ] - 1 ] = c [ i ] <NEWLINE> <DEDENT> print ( b [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = [ 1 ] <NEWLINE> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> b . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( 0 , M ) : <NEWLINE> <INDENT> if s [ i ] == 1 and c [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , M ) : <NEWLINE> <INDENT> b [ s [ i ] - 1 ] = c [ i ] <NEWLINE> <DEDENT> for i in range ( 0 , N ) : <NEWLINE> <INDENT> print ( b [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> A = factorization ( N ) <NEWLINE> <NL> for x in A : <NEWLINE> <INDENT> e = x [ 1 ] <NEWLINE> for y in range ( 1 , N ) : <NEWLINE> <INDENT> if e >= y : <NEWLINE> <INDENT> e -= y <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> score = [ 0 , 0 ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A == B : <NEWLINE> <INDENT> score [ 0 ] += A <NEWLINE> score [ 1 ] += B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score [ A < B ] += A + B <NEWLINE> <DEDENT> <DEDENT> print ( * score ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . nodes = [ i for i in range ( n ) ] <NEWLINE> self . sizes = [ 1 for _ in range ( n ) ] <NEWLINE> <NL> <DEDENT> def union ( self , p , q ) : <NEWLINE> <INDENT> rp = self . root ( p ) <NEWLINE> rq = self . root ( q ) <NEWLINE> if self . sizes [ rp ] > self . sizes [ rq ] : <NEWLINE> <INDENT> self . nodes [ rq ] = rp <NEWLINE> self . sizes [ rp ] += self . sizes [ rq ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . nodes [ rp ] = rq <NEWLINE> self . sizes [ rq ] += self . sizes [ rp ] <NEWLINE> <NL> <DEDENT> <DEDENT> def connected ( self , p , q ) : <NEWLINE> <INDENT> return self . root ( p ) == self . root ( q ) <NEWLINE> <NL> <DEDENT> def root ( self , p ) : <NEWLINE> <INDENT> while p != self . nodes [ p ] : <NEWLINE> <INDENT> self . nodes [ p ] = self . nodes [ self . nodes [ p ] ] <NEWLINE> p = self . nodes [ p ] <NEWLINE> <NL> <DEDENT> return p <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Edge : <NEWLINE> <INDENT> __slots__ = ( <STRING> , <STRING> ) <NEWLINE> <NL> def __init__ ( self , v , w ) : <NEWLINE> <INDENT> self . v = v <NEWLINE> self . w = w <NEWLINE> <NL> <DEDENT> def either ( self ) : <NEWLINE> <INDENT> return self . v <NEWLINE> <NL> <DEDENT> def other ( self , v ) : <NEWLINE> <INDENT> if v == self . v : <NEWLINE> <INDENT> return self . w <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . v <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class WeightedEdge ( Edge ) : <NEWLINE> <INDENT> __slots__ = ( <STRING> , <STRING> , <STRING> ) <NEWLINE> <NL> def __init__ ( self , v , w , weight ) : <NEWLINE> <INDENT> super ( ) . __init__ ( v , w ) <NEWLINE> self . weight = weight <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Graph : <NEWLINE> <INDENT> def __init__ ( self , v ) : <NEWLINE> <INDENT> self . v = v <NEWLINE> self . _edges = [ [ ] for _ in range ( v ) ] <NEWLINE> <NL> <DEDENT> def add ( self , e ) : <NEWLINE> <INDENT> self . _edges [ e . v ] . append ( e ) <NEWLINE> self . _edges [ e . w ] . append ( e ) <NEWLINE> <NL> <DEDENT> def adj ( self , v ) : <NEWLINE> <INDENT> return self . _edges [ v ] <NEWLINE> <NL> <DEDENT> def edges ( self ) : <NEWLINE> <INDENT> for es in self . _edges : <NEWLINE> <INDENT> for e in es : <NEWLINE> <INDENT> yield e <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def lca ( graph , root , queries ) : <NEWLINE> <INDENT> index = [ set ( ) for _ in range ( graph . v ) ] <NEWLINE> for v , w in queries : <NEWLINE> <INDENT> index [ v ] . add ( ( v , w ) ) <NEWLINE> <NL> <DEDENT> visited = [ False ] * graph . v <NEWLINE> stored = [ False ] * graph . v <NEWLINE> parents = [ None ] * graph . v <NEWLINE> uf = UnionFind ( graph . v ) <NEWLINE> res = { } <NEWLINE> stack = [ root ] <NEWLINE> while stack : <NEWLINE> <INDENT> v = stack . pop ( ) <NEWLINE> if not visited [ v ] : <NEWLINE> <INDENT> visited [ v ] = True <NEWLINE> stack . append ( v ) <NEWLINE> for e in graph . adj ( v ) : <NEWLINE> <INDENT> w = e . other ( v ) <NEWLINE> if not visited [ w ] : <NEWLINE> <INDENT> stack . append ( w ) <NEWLINE> parents [ w ] = v <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> stored [ v ] = True <NEWLINE> p = parents [ v ] <NEWLINE> rest = set ( ) <NEWLINE> for i , j in index [ v ] : <NEWLINE> <INDENT> if stored [ i ] and stored [ j ] : <NEWLINE> <INDENT> if uf . connected ( i , j ) and ( i , j ) not in res : <NEWLINE> <INDENT> res [ ( i , j ) ] = v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rest . add ( ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> index [ j ] . add ( ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> index [ v ] = None <NEWLINE> if p is not None : <NEWLINE> <INDENT> uf . union ( p , v ) <NEWLINE> index [ p ] . update ( rest ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> g = Graph ( n ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> k , * cs = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if k > 0 : <NEWLINE> <INDENT> for j in cs : <NEWLINE> <INDENT> g . add ( Edge ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> qs = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> v , w = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> qs . append ( ( v , w ) ) <NEWLINE> <NL> <DEDENT> res = lca ( g , 0 , qs ) <NEWLINE> for v , w in qs : <NEWLINE> <INDENT> print ( res [ ( v , w ) ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> m = int ( input ( ) ) <NEWLINE> s = input ( ) . strip ( ) <NEWLINE> ans = cnt = i = 0 <NEWLINE> while i < m : <NEWLINE> <INDENT> if i + 1 < m and s [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> elif cnt > 0 : <NEWLINE> <INDENT> if s [ i ] == <STRING> : cnt -= 1 <NEWLINE> if cnt >= n : ans += cnt - n + 1 <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
n = [ ] <NEWLINE> for i in input ( ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> if n : n . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( * n , sep = <STRING> ) <NEWLINE>
def opt ( N , W ) : <NEWLINE> <INDENT> dp = [ 0 ] * ( W + 1 ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( W , w - 1 , - 1 ) : <NEWLINE> <INDENT> tmp = dp [ i - w ] + v <NEWLINE> if tmp > dp [ i ] : <NEWLINE> <INDENT> dp [ i ] = tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ W ] ) <NEWLINE> <NL> <DEDENT> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> opt ( N , W ) <NEWLINE>
answer = 1 <NEWLINE> lens = int ( input ( ) ) <NEWLINE> arrs = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if 0 in arrs : <NEWLINE> <INDENT> answer = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in arrs : <NEWLINE> <INDENT> answer *= x <NEWLINE> if answer > int ( 10 ** 18 ) : <NEWLINE> <INDENT> answer = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
import numpy as np <NEWLINE> <NL> <NL> class mod_calc ( ) : <NEWLINE> <INDENT> def __init__ ( self , divisor , max_n ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . _divisor = divisor <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> fact = np . empty ( ( max_n + 1 , ) , dtype = int ) <NEWLINE> fact [ 1 ] = fact [ 0 ] = f = 1 <NEWLINE> for i in range ( 2 , len ( fact ) ) : <NEWLINE> <INDENT> f = ( f * i ) % divisor <NEWLINE> fact [ i ] = f <NEWLINE> <DEDENT> self . _fact = fact <NEWLINE> fact_inv = np . empty ( ( max_n + 1 , ) , dtype = int ) <NEWLINE> fact_inv [ max_n ] = fi = pow ( int ( fact [ max_n ] ) , divisor - 2 , divisor ) <NEWLINE> for i in range ( max_n , 2 , - 1 ) : <NEWLINE> <INDENT> fi = ( fi * i ) % divisor <NEWLINE> fact_inv [ i - 1 ] = fi <NEWLINE> <DEDENT> fact_inv [ 1 ] = fact_inv [ 0 ] = 1 <NEWLINE> self . _fact_inv = fact_inv <NEWLINE> <NL> <DEDENT> def comb ( self , n , k ) : <NEWLINE> <INDENT> k = min ( k , n - k ) <NEWLINE> if k == 0 or k == n : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return self . mul ( self . _fact [ n ] , self . _fact_inv [ n - k ] , self . _fact_inv [ k ] ) <NEWLINE> <NL> <DEDENT> def pow ( self , a , n ) : <NEWLINE> <INDENT> return pow ( a , n , self . _divisor ) <NEWLINE> <NL> <DEDENT> def mul ( self , * a ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> r = a [ 0 ] <NEWLINE> for m in a [ 1 : ] : <NEWLINE> <INDENT> r = ( r * m ) % self . _divisor <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> def sum ( self , * a ) : <NEWLINE> <INDENT> r = a [ 0 ] <NEWLINE> for m in a [ 1 : ] : <NEWLINE> <INDENT> r = ( r + m ) % self . _divisor <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if M == 1 : <NEWLINE> <INDENT> if K == N - 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> if N == 1 : <NEWLINE> <INDENT> return M <NEWLINE> <DEDENT> c = mod_calc ( 998244353 , N - 1 ) <NEWLINE> count = 0 <NEWLINE> for k in range ( K + 1 ) : <NEWLINE> <INDENT> count = c . sum ( c . mul ( c . comb ( N - 1 , k ) , M , c . pow ( M - 1 , N - k - 1 ) ) , count ) <NEWLINE> <DEDENT> return count <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
def abc171d_replacing ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_dict = { } <NEWLINE> for v in a : <NEWLINE> <INDENT> if a_dict . get ( v ) is None : <NEWLINE> <INDENT> a_dict [ v ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_dict [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> total = 0 <NEWLINE> for k , v in a_dict . items ( ) : <NEWLINE> <INDENT> total += k * v <NEWLINE> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b in a_dict . keys ( ) : <NEWLINE> <INDENT> total += ( c * a_dict [ b ] - b * a_dict [ b ] ) <NEWLINE> if c in a_dict . keys ( ) : <NEWLINE> <INDENT> a_dict [ c ] += a_dict [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_dict [ c ] = a_dict [ b ] <NEWLINE> <DEDENT> del a_dict [ b ] <NEWLINE> <DEDENT> s . append ( total ) <NEWLINE> <NL> <DEDENT> for v in s : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> abc171d_replacing ( ) <NEWLINE>
def power_func ( a , n , p ) : <NEWLINE> <INDENT> bi = str ( format ( n , <STRING> ) ) <COMMENT> <NEWLINE> res = 1 <NEWLINE> for i in range ( len ( bi ) ) : <NEWLINE> <INDENT> res = ( res * res ) % p <NEWLINE> if bi [ i ] == <STRING> : <NEWLINE> <INDENT> res = ( res * a ) % p <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> w = 998244353 <NEWLINE> t = 0 <NEWLINE> c = 1 <NEWLINE> b = m * ( ( m - 1 ) ** ( n - 1 ) ) % w <NEWLINE> g = power_func ( m - 1 , w - 2 , w ) <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> t += c * b <NEWLINE> t %= w <NEWLINE> if i < k : <NEWLINE> <INDENT> c *= ( n - 1 - i ) <NEWLINE> c *= power_func ( i + 1 , w - 2 , w ) <NEWLINE> c %= w <NEWLINE> b *= g <NEWLINE> b %= w <NEWLINE> <DEDENT> <DEDENT> if m == 1 and k == n - 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> aL = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> j = i + k - 1 <NEWLINE> if aL [ i - 1 ] < aL [ j ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
nums = input ( ) . split ( ) <NEWLINE> a = int ( nums [ 0 ] ) <NEWLINE> b = nums [ 1 ] <NEWLINE> <NL> res = <STRING> <NEWLINE> for ch in range ( len ( b ) ) : <NEWLINE> <INDENT> if b [ ch ] != <STRING> : <NEWLINE> <INDENT> res += b [ ch ] <NEWLINE> <NL> <DEDENT> <DEDENT> b = int ( res ) <NEWLINE> <NL> prod = ( a * b ) // 100 <NEWLINE> <NL> print ( prod ) <NEWLINE>
import sys <NEWLINE> N , P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = int ( P ** ( 1 / N ) + 1.0E-7 ) <NEWLINE> for i in range ( M , 0 , - 1 ) : <NEWLINE> <INDENT> if P % ( i ** N ) == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> visit = [ False ] * ( n + 1 ) <NEWLINE> <NL> town = [ ] <NEWLINE> <NL> next = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> next = L [ next - 1 ] <NEWLINE> if not visit [ next ] : <NEWLINE> <INDENT> town . append ( next ) <NEWLINE> visit [ next ] = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> town . append ( next ) <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if town [ i ] == town [ - 1 ] : <NEWLINE> <INDENT> mod = i <NEWLINE> index = i <NEWLINE> loop = len ( town ) - i - 1 <NEWLINE> loop_array = town [ i : - 1 ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> fin_len = ( k - mod ) % loop <NEWLINE> if k <= mod : <NEWLINE> <INDENT> print ( town [ k - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( loop_array [ fin_len - 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> prices = [ int ( input ( ) ) for x in range ( n ) ] <NEWLINE> maxv = - 2 * 10 ** 9 <NEWLINE> minv = prices [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> maxv = max ( maxv , prices [ i ] - minv ) <NEWLINE> minv = min ( minv , prices [ i ] ) <NEWLINE> <NL> <DEDENT> print ( maxv ) <NEWLINE>
from collections import deque <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n , q = input ( ) . split ( ) <NEWLINE> n , q = int ( n ) , int ( q ) <NEWLINE> S = [ deque ( [ ] ) for i in range ( n ) ] <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> query = input ( ) . split ( ) <NEWLINE> <NL> if query [ 0 ] == <STRING> : <NEWLINE> <INDENT> S [ int ( query [ 1 ] ) ] . append ( query [ 2 ] ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if len ( S [ int ( query [ 1 ] ) ] ) == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif query [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( S [ int ( query [ 1 ] ) ] [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ int ( query [ 1 ] ) ] . pop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> n , k = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> loop = [ ] <NEWLINE> visited = set ( ) <NEWLINE> s = set ( [ 1 ] ) <NEWLINE> loop_creating = False <NEWLINE> last = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if loop_creating and len ( visited ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if k == len ( s ) - 1 : <NEWLINE> <INDENT> print ( last ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> nex = a [ last - 1 ] <NEWLINE> <NL> if nex in visited : <NEWLINE> <INDENT> visited . remove ( nex ) <NEWLINE> loop . append ( nex ) <NEWLINE> loop_creating = True <NEWLINE> <DEDENT> elif nex in s : <NEWLINE> <INDENT> visited . add ( nex ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . add ( nex ) <NEWLINE> <NL> <DEDENT> last = nex <NEWLINE> <NL> <DEDENT> rem = k - len ( s ) <NEWLINE> print ( loop [ rem % len ( loop ) ] ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> import itertools <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += gcd ( i , i , i ) <NEWLINE> <NL> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( i , i , j ) * 3 <NEWLINE> <NL> <DEDENT> for j , k in itertools . product ( range ( i + 1 , K + 1 ) , range ( i + 1 , K + 1 ) ) : <NEWLINE> <INDENT> ans += gcd ( i , j , k ) * 3 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> from sys import setrecursionlimit <NEWLINE> setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> a , b , c , d = map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> if d > a + b : <NEWLINE> <INDENT> print ( a - ( d - a - b ) ) <NEWLINE> <DEDENT> elif d < a : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> MOD = 998_244_353 <NEWLINE> <NL> def main ( A , B , C , D ) : <NEWLINE> <INDENT> d = np . zeros ( ( C + 1 , D + 1 ) , np . int64 ) <NEWLINE> d [ A , B ] = 1 <NEWLINE> for i in range ( A + 1 , C + 1 ) : <NEWLINE> <INDENT> d [ i , B ] = B * d [ i - 1 , B ] % MOD <NEWLINE> <DEDENT> for j in range ( B + 1 , D + 1 ) : <NEWLINE> <INDENT> d [ A , j ] = A * d [ A , j - 1 ] % MOD <NEWLINE> <NL> <DEDENT> for i in range ( A + 1 , C + 1 ) : <NEWLINE> <INDENT> for j in range ( B + 1 , D + 1 ) : <NEWLINE> <INDENT> d [ i , j ] = ( ( ( ( j * d [ i - 1 , j ] ) % MOD + i * d [ i , j - 1 ] % MOD ) % MOD ) - ( ( i - 1 ) * ( ( j - 1 ) * d [ i - 1 , j - 1 ] % MOD ) % MOD ) % MOD ) <NEWLINE> <NL> <DEDENT> <DEDENT> return d [ C , D ] % MOD <NEWLINE> <NL> <DEDENT> <STRING> <NEWLINE> <NL> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> import numba <NEWLINE> from numba . pycc import CC <NEWLINE> i8 = numba . from_dtype ( np . int64 ) <NEWLINE> signature = ( i8 , i8 , i8 , i8 ) <NEWLINE> <NL> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , signature ) ( main ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> from my_module import main <NEWLINE> <NL> A , B , C , D = map ( int , read ( ) . split ( ) ) <NEWLINE> print ( main ( A , B , C , D ) ) <NEWLINE>
import sys <NEWLINE> <NL> a = [ ] <NEWLINE> for t in range ( 4 ) : <NEWLINE> <INDENT> a . append ( [ ] ) <NEWLINE> for f in range ( 3 ) : <NEWLINE> <INDENT> a [ t ] . append ( [ ] ) <NEWLINE> for r in range ( 10 ) : <NEWLINE> <INDENT> a [ t ] [ f ] . append ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> lines = [ line for line in sys . stdin ] <NEWLINE> <NL> n = lines [ 0 ] <NEWLINE> <NL> for l in lines [ 1 : ] : <NEWLINE> <INDENT> b , f , r , v = map ( int , l . split ( ) ) <NEWLINE> b -= 1 <NEWLINE> f -= 1 <NEWLINE> r -= 1 <NEWLINE> a [ b ] [ f ] [ r ] += v <NEWLINE> <NL> <DEDENT> for i , t in enumerate ( a ) : <NEWLINE> <INDENT> for f in t : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , f ) ) ) <NEWLINE> <DEDENT> if len ( a ) != i + 1 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> H , W = LI ( ) <NEWLINE> a = [ LI ( ) for _ in range ( H ) ] <NEWLINE> <NL> ans = [ ] <NEWLINE> <COMMENT> <NL> if W >= 2 : <NEWLINE> <INDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W - 1 ) : <NEWLINE> <INDENT> if a [ i ] [ j ] % 2 == 1 : <NEWLINE> <INDENT> a [ i ] [ j ] -= 1 <NEWLINE> a [ i ] [ j + 1 ] += 1 <NEWLINE> ans . append ( ( i + 1 , j + 1 , i + 1 , j + 2 ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if H >= 2 : <NEWLINE> <INDENT> for i in range ( H - 1 ) : <NEWLINE> <INDENT> if a [ i ] [ - 1 ] % 2 == 1 : <NEWLINE> <INDENT> a [ i ] [ - 1 ] -= 1 <NEWLINE> a [ i + 1 ] [ - 1 ] += 1 <NEWLINE> ans . append ( ( i + 1 , W , i + 2 , W ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE> if ans : <NEWLINE> <INDENT> for i in ans : <NEWLINE> <INDENT> print ( * i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
def p ( x ) : <NEWLINE> <INDENT> if 2 in [ x , pow ( 2 , x , x ) ] : <NEWLINE> <INDENT> for i in range ( 7 , int ( x ** .5 + 1 ) , 2 ) : <NEWLINE> <INDENT> if x % i == 0 : return 0 <NEWLINE> <DEDENT> else : return 1 <NEWLINE> <DEDENT> <DEDENT> def f ( ) : <NEWLINE> <INDENT> n , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if c < 0 : return ( 11 , <STRING> * n * 2 ) [ n > 1 ] <NEWLINE> for h in <STRING> : <NEWLINE> <INDENT> if n - 1 : <NEWLINE> <INDENT> for m in range ( int ( 10 ** ( n - 1 ) ) , 0 , - 1 ) : <NEWLINE> <INDENT> if ( ( int ( h ) + m - 1 ) * 2 + c ) % 3 : <NEWLINE> <INDENT> t = h + str ( m - 1 ) . zfill ( n - 1 ) <NEWLINE> a = int ( t + str ( c ) + t [ : : - 1 ] ) <NEWLINE> if p ( a ) : return a <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a = int ( h + str ( c ) + h ) <NEWLINE> if p ( a ) : return a <NEWLINE> <DEDENT> <DEDENT> return <STRING> * n + b + <STRING> * n <NEWLINE> <DEDENT> print ( f ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r , g , b = [ ] , [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> <DEDENT> lr , lg , lb = len ( r ) , len ( g ) , len ( b ) <NEWLINE> ans = lr * lg * lb <NEWLINE> <NL> for i in r : <NEWLINE> <INDENT> for j in g : <NEWLINE> <INDENT> a = 2 * j - i <NEWLINE> c = 2 * i - j <NEWLINE> if 0 <= a and a <= n - 1 and s [ a ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if 0 <= c and c <= n - 1 and s [ c ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if ( i + j ) % 2 == 0 and s [ ( i + j ) // 2 ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d1 = { } <NEWLINE> for i , e in enumerate ( As ) : <NEWLINE> <INDENT> d = i - e <NEWLINE> if d > 0 : <NEWLINE> <INDENT> if d in d1 . keys ( ) : <NEWLINE> <INDENT> d1 [ d ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d1 [ d ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i , e in enumerate ( As ) : <NEWLINE> <INDENT> if ( i + e ) in d1 . keys ( ) : <NEWLINE> <INDENT> cnt += d1 [ i + e ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def I ( ) : return int ( input ( ) ) <NEWLINE> N = I ( ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> num = str ( i ) . zfill ( 3 ) <NEWLINE> if S . find ( num [ 0 ] ) == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> S1 = S [ S . find ( num [ 0 ] ) + 1 : ] <NEWLINE> if S1 . find ( num [ 1 ] ) == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> S2 = S1 [ S1 . find ( num [ 1 ] ) + 1 : ] <NEWLINE> if S2 . find ( num [ 2 ] ) == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> def solve ( ) : <NEWLINE> <INDENT> for index in range ( int ( sys . stdin . readline ( ) ) ) : <NEWLINE> <INDENT> print ( sys . stdin . readline ( ) [ : - 1 ] . replace ( <STRING> , <STRING> ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def p ( val ) : <NEWLINE> <INDENT> print ( val ) <NEWLINE> <NL> <DEDENT> sho = 10 ** 9 + 7 <NEWLINE> a1 = sum ( a ) ** 2 <NEWLINE> b1 = list ( map ( lambda y : y ** 2 , a ) ) <NEWLINE> b2 = sum ( b1 ) <NEWLINE> result = ( ( a1 - b2 ) // 2 ) % sho <NEWLINE> p ( result ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> result = math . factorial ( n ) <NEWLINE> <NL> <NL> dividor = 10 ** 9 + 7 <NEWLINE> print ( result % dividor ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> counter = Counter ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( counter [ i + 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
original = input ( ) [ : : - 1 ] <NEWLINE> <NL> target = 2019 <NEWLINE> <NL> <COMMENT> <NL> <NL> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> <NL> num , d = 0 , 1 <NEWLINE> digit = 1 <NEWLINE> mod = 0 <NEWLINE> for c in original : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> num += int ( c ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> counts [ num ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in counts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <COMMENT> <NEWLINE>
X = int ( input ( ) ) <NEWLINE> stp = 0 <NEWLINE> for a in range ( 120 ) : <NEWLINE> <INDENT> if stp == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for b in range ( 120 ) : <NEWLINE> <INDENT> A = a ** 5 <NEWLINE> B = b ** 5 <NEWLINE> tmp1 = A - B <NEWLINE> tmp2 = - A + B <NEWLINE> tmp3 = - A - B <NEWLINE> tmp4 = A + B <NEWLINE> if tmp1 == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> stp = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif tmp2 == X : <NEWLINE> <INDENT> print ( - a , - b ) <NEWLINE> stp = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif tmp3 == X : <NEWLINE> <INDENT> print ( - a , b ) <NEWLINE> stp = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif tmp4 == X : <NEWLINE> <INDENT> print ( a , - b ) <NEWLINE> stp = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 1 <NEWLINE> D = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> D += L [ i ] <NEWLINE> if D <= X : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Al = input ( ) . split ( ) <NEWLINE> A = list ( map ( ( lambda x : int ( x ) ) , Al ) ) <NEWLINE> num = 0 <NEWLINE> ma = 10 ** 9 + 7 <NEWLINE> li = 0 <NEWLINE> <NL> for i in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> li += A [ i ] <NEWLINE> num += A [ i - 1 ] * li <NEWLINE> <NL> <DEDENT> num = num % ma <NEWLINE> print ( num ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> if A >= 13 : <NEWLINE> <INDENT> ans = B <NEWLINE> <DEDENT> elif A >= 6 : <NEWLINE> <INDENT> ans = int ( B / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL>
<COMMENT> <NL> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> result = 0 <NEWLINE> ans_list = [ 0 ] * ( N + 1 ) <NEWLINE> root_n = int ( math . sqrt ( N ) ) + 1 <NEWLINE> <NL> for i in range ( 1 , root_n ) : <NEWLINE> <INDENT> for j in range ( 1 , root_n ) : <NEWLINE> <INDENT> for k in range ( 1 , root_n ) : <NEWLINE> <INDENT> f = i ** 2 + j ** 2 + k ** 2 + i * j + i * k + j * k <NEWLINE> if f <= N : <NEWLINE> <INDENT> ans_list [ f ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans_list [ i ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> import collections <NEWLINE> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> count = [ 0 ] * N * 100 <NEWLINE> m = int ( N ** 0.5 ) <NEWLINE> for x , y , z in itertools . combinations_with_replacement ( range ( 1 , m + 1 ) , 3 ) : <NEWLINE> <INDENT> n = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> k = len ( set ( { x , y , z } ) ) <NEWLINE> if k == 1 : <NEWLINE> <INDENT> count [ n ] += 1 <NEWLINE> <DEDENT> elif k == 2 : <NEWLINE> <INDENT> count [ n ] += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count [ n ] += 6 <NEWLINE> <NL> <DEDENT> <DEDENT> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( count [ n ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> sys . setrecursionlimit ( 20000000 ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ u ] . append ( ( v , w ) ) <NEWLINE> G [ v ] . append ( ( u , w ) ) <NEWLINE> <NL> <DEDENT> color = [ - 1 ] * ( N + 1 ) <NEWLINE> color [ 1 ] = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def dfs ( now ) : <NEWLINE> <INDENT> for next_ , w in G [ now ] : <NEWLINE> <INDENT> if color [ next_ ] == - 1 : <NEWLINE> <INDENT> color [ next_ ] = ( w % 2 ) ^ color [ now ] <NEWLINE> dfs ( next_ ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( 1 ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( color [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if ( __name__ == <STRING> ) : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> args = input ( ) . split ( ) <NEWLINE> N = int ( args [ 0 ] ) <NEWLINE> Y = int ( args [ 1 ] ) <NEWLINE> <NL> for num10000 in range ( 0 , N + 1 ) : <NEWLINE> <INDENT> for num5000 in range ( 0 , N + 1 - num10000 ) : <NEWLINE> <INDENT> num1000 = N - num10000 - num5000 <NEWLINE> value = 10000 * num10000 + 5000 * num5000 + 1000 * num1000 <NEWLINE> if value == Y : <NEWLINE> <INDENT> print ( num10000 , num5000 , num1000 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) [ : : - 1 ] <COMMENT> <NEWLINE> <NL> sum_of_digits = 0 <COMMENT> <NEWLINE> cnts = [ 0 ] * 2019 <COMMENT> <NEWLINE> cnts [ 0 ] = 1 <COMMENT> <NEWLINE> d = 1 <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> for c in s : <NEWLINE> <INDENT> sum_of_digits += int ( c ) * d <NEWLINE> sum_of_digits %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <COMMENT> <NEWLINE> cnts [ sum_of_digits ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in cnts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> ans += r * g * b <NEWLINE> m = 0 <NEWLINE> if N >= 3 : <NEWLINE> <INDENT> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < N and S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> m += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans - m ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = input ( ) <NEWLINE> if not <STRING> in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> a = list ( a ) <NEWLINE> rnum = a . count ( <STRING> ) <NEWLINE> rl = 0 <NEWLINE> rr = 0 <NEWLINE> for i1 in range ( rnum ) : <NEWLINE> <INDENT> rl += a [ i1 ] == <STRING> <NEWLINE> <DEDENT> for j1 in range ( n - rnum ) : <NEWLINE> <INDENT> rr += a [ rnum + j1 ] == <STRING> <NEWLINE> <DEDENT> r = max ( rl , rr ) <NEWLINE> print ( r ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] += 1 <NEWLINE> num = 0 <NEWLINE> d = 1 <NEWLINE> for c in reversed ( s ) : <NEWLINE> <INDENT> num += int ( c ) * d <NEWLINE> counts [ num % 2019 ] += 1 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for count in counts : <NEWLINE> <INDENT> ans += count * ( count - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<NL> import heapq <NEWLINE> from collections import defaultdict <NEWLINE> from functools import lru_cache <NEWLINE> from bisect import bisect_right <NEWLINE> while True : <NEWLINE> <INDENT> N , M , C , S , G = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == M == C == S == G == 0 : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> D = [ [ [ float ( <STRING> ) ] * ( N + 1 ) for _ in range ( N + 1 ) ] for _ in range ( C + 1 ) ] <NEWLINE> CE = [ set ( ) for _ in range ( C + 1 ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> x , y , d , c = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> D [ c ] [ x ] [ y ] = min ( D [ c ] [ x ] [ y ] , d ) <NEWLINE> D [ c ] [ y ] [ x ] = min ( D [ c ] [ x ] [ y ] , d ) <NEWLINE> CE [ c ] . add ( x ) <NEWLINE> CE [ c ] . add ( y ) <NEWLINE> <NL> <DEDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> Q = [ ] <NEWLINE> R = [ ] <NEWLINE> for _ in range ( C ) : <NEWLINE> <INDENT> Q . append ( list ( map ( int , input ( ) . split ( ) ) ) + [ 1 << 30 ] ) <NEWLINE> R . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> cum_fare = [ ] <NEWLINE> for c_ in range ( C ) : <NEWLINE> <INDENT> fare_ = [ 0 ] <NEWLINE> res = 0 <NEWLINE> q_p = 0 <NEWLINE> for q , r in zip ( Q [ c_ ] [ : - 1 ] , R [ c_ ] [ : - 1 ] ) : <NEWLINE> <INDENT> res += ( q - q_p ) * r <NEWLINE> q_p = q <NEWLINE> fare_ . append ( res ) <NEWLINE> <DEDENT> cum_fare . append ( fare_ ) <NEWLINE> <NL> <DEDENT> @ lru_cache ( maxsize = None ) <NEWLINE> def fare ( d_ , c_ ) : <NEWLINE> <INDENT> if d_ == float ( <STRING> ) : <NEWLINE> <INDENT> return float ( <STRING> ) <NEWLINE> <DEDENT> c_ -= 1 <NEWLINE> idx = bisect_right ( Q [ c_ ] , d_ ) <NEWLINE> <COMMENT> <NL> return cum_fare [ c_ ] [ idx ] + ( R [ c_ ] [ 0 ] * d_ if idx == 0 else ( d_ - Q [ c_ ] [ idx - 1 ] ) * R [ c_ ] [ idx ] ) <NEWLINE> <NL> <NL> <DEDENT> DD = [ [ float ( <STRING> ) ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> for c in range ( 1 , C + 1 ) : <NEWLINE> <INDENT> D_ = D [ c ] <NEWLINE> l = list ( CE [ c ] ) <NEWLINE> for k in l : <NEWLINE> <INDENT> for i in l : <NEWLINE> <INDENT> for j in l : <NEWLINE> <INDENT> d_ = D_ [ i ] [ k ] + D_ [ k ] [ j ] <NEWLINE> if D_ [ i ] [ j ] > d_ : <NEWLINE> <INDENT> D_ [ i ] [ j ] = d_ <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in l : <NEWLINE> <INDENT> for j in l : <NEWLINE> <INDENT> DD [ i ] [ j ] = min ( DD [ i ] [ j ] , fare ( D_ [ i ] [ j ] , c ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> dist = defaultdict ( lambda : float ( <STRING> ) ) <NEWLINE> q = [ ] <NEWLINE> start = S <NEWLINE> dist [ start ] = 0 <NEWLINE> heapq . heappush ( q , ( 0 , start ) ) <NEWLINE> while len ( q ) != 0 : <NEWLINE> <INDENT> prob_cost , v = heapq . heappop ( q ) <NEWLINE> <COMMENT> <NL> if dist [ v ] < prob_cost : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if v == G : <NEWLINE> <INDENT> print ( prob_cost ) <NEWLINE> break <NEWLINE> <DEDENT> for u , c in enumerate ( DD [ v ] ) : <NEWLINE> <INDENT> if dist [ u ] > dist [ v ] + c : <NEWLINE> <INDENT> dist [ u ] = dist [ v ] + c <NEWLINE> heapq . heappush ( q , ( dist [ u ] , u ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( k < a ) : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif ( k <= a + b ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - ( a + b ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> count = 0 <NEWLINE> max = a [ 0 ] <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> if max > a [ i ] : <NEWLINE> <INDENT> if a [ i - 1 ] > max : <NEWLINE> <INDENT> max = a [ i - 1 ] <NEWLINE> <DEDENT> count += max - a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max = a [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> maxA = max ( A ) <NEWLINE> ans = 0 <NEWLINE> flag = [ 0 ] * ( maxA + 1 ) <NEWLINE> <NL> <COMMENT> <NL> for a in A : <NEWLINE> <INDENT> for ax in range ( a , maxA + 1 , a ) : <NEWLINE> <INDENT> flag [ ax ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for a in set ( A ) : <NEWLINE> <INDENT> if flag [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if a [ 0 ] < a [ 1 ] : flag = 1 <NEWLINE> elif a [ 0 ] > a [ 1 ] : flag = - 1 <NEWLINE> else : flag = 0 <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if flag == 1 and a [ i ] > a [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> flag = 0 <NEWLINE> <DEDENT> elif flag == - 1 and a [ i ] < a [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> flag = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a [ i ] > a [ i + 1 ] : flag = - 1 <NEWLINE> elif a [ i ] < a [ i + 1 ] : flag = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> a . append ( <STRING> ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a . append ( <STRING> ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> if len ( a ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> del a [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( a ) ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> import math <NEWLINE> <NL> S = input ( ) <NEWLINE> <NL> mm = [ 0 ] * ( 2019 ) <NEWLINE> mm [ 0 ] = 1 <NEWLINE> a = [ 0 ] * ( len ( S ) + 1 ) <NEWLINE> T = 0 <NEWLINE> ten = 1 <NEWLINE> ll = len ( S ) <NEWLINE> for i in range ( ll ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> ten = ( ten * 10 ) % 2019 <NEWLINE> <DEDENT> a [ i + 1 ] = ( a [ i ] + ( int ( S [ ll - 1 - i ] ) * ten ) ) % 2019 <NEWLINE> mm [ a [ i + 1 ] ] += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for m in mm : <NEWLINE> <INDENT> ans += int ( ( m * ( m - 1 ) ) / 2 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> aa = ( a - 1 ) // x <NEWLINE> bb = b // x <NEWLINE> print ( bb - aa ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = set ( A ) <NEWLINE> A . sort ( ) <NEWLINE> S = max ( A ) <NEWLINE> ans = [ 1 ] * S <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if ans [ A [ i ] - 1 ] != 0 : <NEWLINE> <INDENT> if i > 0 and A [ i ] == A [ i - 1 ] : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] = 0 <NEWLINE> <DEDENT> for j in range ( A [ i ] * 2 , S + 1 , A [ i ] ) : <NEWLINE> <INDENT> ans [ j - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> k = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if ans [ i - 1 ] == 1 : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> <DEDENT> print ( k ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> B = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> B . append ( A [ i ] - ( i + 1 ) ) <NEWLINE> <DEDENT> B . sort ( ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> m = B [ 0 ] <NEWLINE> m2 = B [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = B [ n // 2 ] <NEWLINE> m2 = B [ n // 2 + 1 ] <NEWLINE> <DEDENT> tmp1 = 0 <NEWLINE> tmp2 = 0 <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> tmp1 += abs ( A [ i ] - ( i + 1 ) - m ) <NEWLINE> tmp2 += abs ( A [ i ] - ( i + 1 ) - m2 ) <NEWLINE> <DEDENT> print ( min ( tmp1 , tmp2 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 0 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , n + 1 - i ) : <NEWLINE> <INDENT> k = max ( 0 , n - i - j ) <NEWLINE> if 10000 * i + 5000 * j + 1000 * k == y : <NEWLINE> <INDENT> print ( i , j , k ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> F = [ ] <NEWLINE> P = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> F . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> P . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> ans = - 10 ** 9 <NEWLINE> for i in range ( 1 , 1 << ( 10 ) ) : <NEWLINE> <INDENT> C = [ 0 ] * n <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> if i & 2 ** j : <NEWLINE> <INDENT> for k in range ( n ) : <NEWLINE> <INDENT> if F [ k ] [ j ] : <NEWLINE> <INDENT> C [ k ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> current = 0 <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> current += P [ k ] [ C [ k ] ] <NEWLINE> <DEDENT> ans = max ( current , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> print ( <STRING> . format ( ( r ** 2 ) * math . pi , 2 * math . pi * r ) ) <NEWLINE>
def aaaa ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> if a [ 0 ] > 0 : <NEWLINE> <INDENT> if a [ 0 ] == 1 and n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> return - 1 <NEWLINE> <DEDENT> nezen = 1 <NEWLINE> hazen = 0 <NEWLINE> line = [ ] <NEWLINE> liha = [ ] <NEWLINE> line . append ( nezen ) <NEWLINE> liha . append ( hazen ) <NEWLINE> su = 0 <NEWLINE> su = sum ( a [ x ] for x in range ( len ( a ) ) ) <NEWLINE> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if nezen <= 0 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> ha = a [ x ] <NEWLINE> su -= ha <NEWLINE> ne = min ( nezen * 2 - ha , su ) <NEWLINE> nezen = ne <NEWLINE> line . append ( ne ) <NEWLINE> liha . append ( ha ) <NEWLINE> <DEDENT> if line [ n ] < 0 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> line [ n ] = 0 <NEWLINE> for x in range ( len ( line ) ) : <NEWLINE> <INDENT> ans += line [ x ] + liha [ x ] <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> print ( aaaa ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ss = sorted ( [ sorted ( input ( ) ) for _ in range ( n ) ] ) <NEWLINE> ans = 0 <NEWLINE> cnt = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if ss [ i ] != ss [ i + 1 ] : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if a [ a [ i ] - 1 ] - 1 == i : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c // 2 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , t , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> b = 0 <NEWLINE> c = float ( <STRING> ) <NEWLINE> d = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = a [ i ] <NEWLINE> if x - c > b : <NEWLINE> <INDENT> b = x - c <NEWLINE> d = 1 <NEWLINE> <DEDENT> elif x - c == b : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> c = min ( c , x ) <NEWLINE> <NL> <DEDENT> print ( d ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ x for x in input ( ) . split ( ) ] <NEWLINE> c = collections . Counter ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( c [ <STRING> . format ( str ( i + 1 ) ) ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> tmp = list ( S ) <NEWLINE> tmp [ K - 1 ] = tmp [ K - 1 ] . lower ( ) <NEWLINE> print ( <STRING> . join ( tmp ) ) <NEWLINE>
while ( 1 ) : <NEWLINE> <INDENT> e = int ( input ( ) ) <NEWLINE> if e == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m , z = 10 ** 15 , 0 <NEWLINE> while z ** 3 <= e : <NEWLINE> <INDENT> y = int ( ( e - z ** 3 ) ** 0.5 ) <NEWLINE> x = e - z ** 3 - y ** 2 <NEWLINE> m = min ( m , x + y + z ) <NEWLINE> z += 1 <NEWLINE> <DEDENT> print ( m ) <NEWLINE> <DEDENT>
import queue <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> v = [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> s = [ input ( ) for i in range ( h ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> que = queue . Queue ( ) <NEWLINE> for i in range ( h * w ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> d = [ [ h * w ] * w for i in range ( h ) ] <NEWLINE> p = ( i // w , i % w ) <NEWLINE> if s [ p [ 0 ] ] [ p [ 1 ] ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> d [ p [ 0 ] ] [ p [ 1 ] ] = 0 <NEWLINE> que . put ( p ) <NEWLINE> while not que . empty ( ) : <NEWLINE> <INDENT> y , x = que . get ( ) <NEWLINE> c = d [ y ] [ x ] <NEWLINE> for dy , dx in v : <NEWLINE> <INDENT> yy = y + dy <NEWLINE> xx = x + dx <NEWLINE> if yy < 0 or xx < 0 or h <= yy or w <= xx : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ yy ] [ xx ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if d [ yy ] [ xx ] < h * w : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> que . put ( ( yy , xx ) ) <NEWLINE> d [ yy ] [ xx ] = c + 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , c ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> memory = [ ] <NEWLINE> counter = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> tmp = input ( ) <NEWLINE> memory . append ( tmp ) <NEWLINE> <NL> <DEDENT> c = collections . Counter ( memory ) <NEWLINE> <NL> print ( len ( c ) ) <NEWLINE>
pi = 3.141592653589 <NEWLINE> r = float ( input ( ) ) <NEWLINE> c = pi * r ** 2 <NEWLINE> s = 2 * pi * r <NEWLINE> print ( <STRING> % ( c , s ) ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> s_length = len ( s ) <NEWLINE> t_length = len ( t ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> keep = <STRING> <NEWLINE> remind = 0 <NEWLINE> checker = False <NEWLINE> for i in range ( s_length ) : <NEWLINE> <INDENT> if ( i + t_length ) <= s_length : <NEWLINE> <INDENT> check = True <NEWLINE> for j in range ( t_length ) : <NEWLINE> <INDENT> if ( s [ i + j ] != t [ j ] ) & ( s [ i + j ] != <STRING> ) : <NEWLINE> <INDENT> check = False <NEWLINE> <DEDENT> <DEDENT> if check : <NEWLINE> <INDENT> checker = True <NEWLINE> ans = keep + t <NEWLINE> remind = i + t_length <NEWLINE> <DEDENT> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> keep += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> keep += s [ i ] <NEWLINE> <DEDENT> <DEDENT> ans = ans + keep [ remind : ] <NEWLINE> <NL> if checker : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def findlcs ( x , y ) : <NEWLINE> <INDENT> dp = [ 0 ] * ( len ( y ) + 1 ) <NEWLINE> <NL> for c in x : <NEWLINE> <INDENT> tmp = dp [ : ] <NEWLINE> for j in range ( len ( y ) ) : <NEWLINE> <INDENT> if c == y [ j ] : <NEWLINE> <INDENT> dp [ j + 1 ] = tmp [ j ] + 1 <NEWLINE> <DEDENT> elif dp [ j + 1 ] < dp [ j ] : <NEWLINE> <INDENT> dp [ j + 1 ] = dp [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return dp [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> for k in range ( q ) : <NEWLINE> <INDENT> X = input ( ) <NEWLINE> Y = input ( ) <NEWLINE> print ( findlcs ( X , Y ) ) <NEWLINE> <DEDENT>
N , P = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> d = P <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = 1 <NEWLINE> i = 2 <NEWLINE> while i <= round ( pow ( P , 1 / N ) ) : <NEWLINE> <INDENT> if P % i ** N == 0 : <NEWLINE> <INDENT> P //= i ** N <NEWLINE> d *= i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
N , K = input ( ) . split ( <STRING> ) <NEWLINE> <NL> okasi_nasi = set ( ) <NEWLINE> for i in range ( int ( K ) * 2 ) : <NEWLINE> <INDENT> buf = input ( ) <NEWLINE> if i % 2 == 1 : <NEWLINE> <INDENT> if buf [ 0 ] != <STRING> : <NEWLINE> <INDENT> okasi_nasi = okasi_nasi | set ( buf . split ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( int ( N ) - len ( okasi_nasi ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_list = [ n for n in a_list if n != 1 ] <NEWLINE> <COMMENT> <NL> ans = 1 <NEWLINE> <NL> if 0 in a_list : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif len ( a_list ) > 56 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a_list : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> <DEDENT> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> val = [ ] <NEWLINE> wei = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> val . append ( a ) <NEWLINE> wei . append ( b ) <NEWLINE> <NL> <DEDENT> dp = [ [ 0 for j in range ( W + 1 ) ] for i in range ( N + 1 ) ] <NEWLINE> <NL> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for w in range ( W + 1 ) : <NEWLINE> <INDENT> if ( w >= wei [ i ] ) : <NEWLINE> <INDENT> dp [ i + 1 ] [ w ] = max ( dp [ i ] [ w - wei [ i ] ] + val [ i ] , dp [ i ] [ w ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] [ w ] = dp [ i ] [ w ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( int ( dp [ N ] [ W ] ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> S = readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> one_cnt = S . count ( <STRING> ) <NEWLINE> S_rev = S [ : : - 1 ] <NEWLINE> <COMMENT> <NL> one_mod = 0 <NEWLINE> zero_mod = 0 <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S_rev [ i ] == <STRING> and one_cnt - 1 != 0 : <NEWLINE> <INDENT> one_mod += pow ( 2 , i , one_cnt - 1 ) <NEWLINE> one_mod %= ( one_cnt - 1 ) <NEWLINE> zero_mod += pow ( 2 , i , one_cnt + 1 ) <NEWLINE> zero_mod %= ( one_cnt + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = [ 0 ] * ( one_cnt + 1 ) <NEWLINE> pop_cnt = [ 0 ] * ( one_cnt + 1 ) <NEWLINE> for i in range ( 1 , one_cnt + 1 ) : <NEWLINE> <INDENT> pop_cnt [ i ] = pop_cnt [ i // 2 ] + i % 2 <NEWLINE> j = i % pop_cnt [ i ] <NEWLINE> cnt [ i ] = 1 + cnt [ j ] <NEWLINE> <NL> <DEDENT> one_pow2 = [ 1 ] * ( N + 1 ) <NEWLINE> zero_pow2 = [ 1 ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if one_cnt - 1 != 0 : <NEWLINE> <INDENT> one_pow2 [ i + 1 ] = one_pow2 [ i ] * 2 % ( one_cnt - 1 ) <NEWLINE> <DEDENT> zero_pow2 [ i + 1 ] = zero_pow2 [ i ] * 2 % ( one_cnt + 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if one_cnt - 1 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nxt = one_mod <NEWLINE> nxt -= one_pow2 [ N - i ] <NEWLINE> nxt %= ( one_cnt - 1 ) <NEWLINE> print ( 1 + cnt [ nxt ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> nxt = zero_mod <NEWLINE> nxt += zero_pow2 [ N - i ] <NEWLINE> nxt %= ( one_cnt + 1 ) <NEWLINE> print ( 1 + cnt [ nxt ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> w = [ ] <NEWLINE> r = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : w . append ( i + 1 ) <NEWLINE> if s [ len ( s ) - i - 1 ] == <STRING> : r . append ( len ( s ) - i ) <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> <COMMENT> <NL> for i in range ( min ( len ( w ) , len ( r ) ) ) : <NEWLINE> <INDENT> if w [ i ] > r [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <STRING> <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import array <NEWLINE> import collections <NEWLINE> <NL> <NL> Edge = collections . namedtuple ( <STRING> , <STRING> ) <NEWLINE> <NL> <NL> class UnionFind ( object ) : <NEWLINE> <NL> <INDENT> def __init__ ( self , number_of_nodes ) : <COMMENT> <NEWLINE> <INDENT> self . par = array . array ( <STRING> , range ( number_of_nodes ) ) <NEWLINE> self . rank = array . array ( <STRING> , ( 0 for i in range ( number_of_nodes ) ) ) <NEWLINE> <NL> <DEDENT> def root ( self , node ) : <COMMENT> <NEWLINE> <INDENT> if self . par [ node ] == node : <NEWLINE> <INDENT> return node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = self . root ( self . par [ node ] ) <NEWLINE> self . par [ node ] = r <COMMENT> <NEWLINE> return r <NEWLINE> <NL> <DEDENT> <DEDENT> def in_the_same_set ( self , node1 , node2 ) : <COMMENT> <NEWLINE> <INDENT> return self . root ( node1 ) == self . root ( node2 ) <NEWLINE> <NL> <DEDENT> def unite ( self , node1 , node2 ) : <COMMENT> <NEWLINE> <INDENT> x = self . root ( node1 ) <NEWLINE> y = self . root ( node2 ) <NEWLINE> if x == y : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif self . rank [ x ] < self . rank [ y ] : <NEWLINE> <INDENT> self . par [ x ] = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ y ] = x <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ x ] += 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def compute_mst_kruskal ( max_v , edges ) : <NEWLINE> <INDENT> edges . sort ( key = lambda edge : edge . weight ) <NEWLINE> uf = UnionFind ( max_v ) <NEWLINE> mst = [ ] <NEWLINE> for edge in edges : <NEWLINE> <INDENT> if not uf . in_the_same_set ( edge . start , edge . end ) : <NEWLINE> <INDENT> uf . unite ( edge . start , edge . end ) <NEWLINE> mst . append ( edge ) <NEWLINE> <DEDENT> <DEDENT> return mst <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> max_v , max_e = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ Edge ( * map ( int , input ( ) . split ( ) ) ) for _ in range ( max_e ) ] <NEWLINE> mst = compute_mst_kruskal ( max_v , edges ) <NEWLINE> print ( sum ( edge . weight for edge in mst ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class Cube : <NEWLINE> <INDENT> def __init__ ( self , x , y , z , s ) : <NEWLINE> <INDENT> self . x , self . y , self . z = x , y , z <NEWLINE> self . s = s <NEWLINE> <NL> <DEDENT> def is_in_cube ( self , x , y , z ) : <NEWLINE> <INDENT> return self . x <= x <= self . x + self . s and self . y <= y <= self . y + self . s and self . z <= z <= self . z + self . s <NEWLINE> <NL> <DEDENT> def intersect ( self , C ) : <NEWLINE> <INDENT> dxyz = [ ( 0 , 0 , 0 ) , <NEWLINE> <INDENT> ( C . s , 0 , 0 ) , ( 0 , C . s , 0 ) , ( 0 , 0 , C . s ) , <NEWLINE> ( C . s , C . s , 0 ) , ( C . s , 0 , C . s ) , ( 0 , C . s , C . s ) , <NEWLINE> ( C . s , C . s , C . s ) ] <NEWLINE> <DEDENT> for dx1 , dy1 , dz1 in dxyz : <NEWLINE> <INDENT> nx1 , ny1 , nz1 = C . x + dx1 , C . y + dy1 , C . z + dz1 <NEWLINE> if self . is_in_cube ( nx1 , ny1 , nz1 ) : <NEWLINE> <INDENT> for dx2 , dy2 , dz2 in dxyz : <NEWLINE> <INDENT> nx2 , ny2 , nz2 = self . x + dx2 , self . y + dy2 , self . z + dz2 <NEWLINE> if C . is_in_cube ( nx2 , ny2 , nz2 ) : <NEWLINE> <INDENT> a , b , c = abs ( nx1 - nx2 ) , abs ( ny1 - ny2 ) , abs ( nz1 - nz2 ) <NEWLINE> if a * b * c == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> return 2 * ( a * b + b * c + c * a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> edges = list ( ) <NEWLINE> inters = dict ( ) <NEWLINE> <NL> <NL> def calc_overlap ( vs ) : <NEWLINE> <INDENT> ret = sum ( inters . get ( ( vs [ i ] , vs [ i + 1 ] ) , 0 ) for i in range ( len ( vs ) - 1 ) ) <NEWLINE> if len ( vs ) > 2 : <NEWLINE> <INDENT> ret += inters . get ( ( vs [ - 1 ] , vs [ 0 ] ) , 0 ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def dfs ( v , par , vs , res ) : <NEWLINE> <INDENT> if res == 0 : <NEWLINE> <INDENT> return calc_overlap ( vs ) <NEWLINE> <NL> <DEDENT> ret = - 1 <NEWLINE> <NL> for e in edges [ v ] : <NEWLINE> <INDENT> if e != par : <NEWLINE> <INDENT> vs . append ( e ) <NEWLINE> ret = max ( ret , dfs ( e , v , vs , res - 1 ) ) <NEWLINE> vs . pop ( ) <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> INF = 10 ** 9 <NEWLINE> while True : <NEWLINE> <INDENT> N , K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if not ( N | K | S ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cubes = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> cubes . append ( Cube ( x , y , z , S ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> edges = [ [ ] for _ in range ( N ) ] <NEWLINE> inters = dict ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> sur = cubes [ i ] . intersect ( cubes [ j ] ) <NEWLINE> if sur > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> inters [ i , j ] = inters [ j , i ] = sur <NEWLINE> edges [ i ] . append ( j ) <NEWLINE> edges [ j ] . append ( i ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> ans = - 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , dfs ( i , - 1 , [ i ] , K - 1 ) ) <NEWLINE> <NL> <DEDENT> print ( - 1 if ans == - 1 else S * S * 6 * K - ans ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> <NL> a = list ( <STRING> ) <NEWLINE> b = list ( <STRING> ) <NEWLINE> c = list ( <STRING> ) <NEWLINE> d = list ( <STRING> ) <NEWLINE> flag = 0 <NEWLINE> <NL> while ( flag == 0 ) : <NEWLINE> <INDENT> if s [ - 7 : ] == b : <NEWLINE> <INDENT> del s [ - 7 : ] <NEWLINE> <DEDENT> elif s [ - 6 : ] == d : <NEWLINE> <INDENT> del s [ - 6 : ] <NEWLINE> <DEDENT> elif s [ - 5 : ] == a or s [ - 5 : ] == c : <NEWLINE> <INDENT> del s [ - 5 : ] <NEWLINE> <DEDENT> elif s == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = 1 <NEWLINE> <DEDENT> <DEDENT>
from math import floor , sqrt <NEWLINE> <NL> <NL> def func ( x ) : <NEWLINE> <INDENT> return floor ( ( sqrt ( 1 + 8 * x ) - 1 ) / 2 ) <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> limit = floor ( sqrt ( N ) ) <NEWLINE> <NL> primes = [ 2 ] <NEWLINE> <NL> count = 0 <NEWLINE> flag = True <NEWLINE> p = 2 <NEWLINE> while 1 : <NEWLINE> <COMMENT> <NL> <INDENT> isprime = True <NEWLINE> if N == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if p > sqrt ( N ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> a = 0 <NEWLINE> while N % p == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> a += 1 <NEWLINE> N = N // p <NEWLINE> <DEDENT> count += func ( a ) <NEWLINE> if p == 2 : <NEWLINE> <INDENT> p = 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p += 2 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nums = [ ] <NEWLINE> nums . append ( a [ 0 ] ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if a [ i ] != a [ i - 1 ] : <NEWLINE> <INDENT> nums . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> val = nums [ 0 ] <NEWLINE> maxs = [ ] <NEWLINE> for j in range ( 1 , len ( nums ) ) : <NEWLINE> <INDENT> if nums [ j ] > val : <NEWLINE> <INDENT> maxs . append ( j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> val = nums [ j ] <NEWLINE> <DEDENT> pos = 0 <NEWLINE> money = 1000 <NEWLINE> for idx in maxs : <NEWLINE> <INDENT> minVal = min ( nums [ pos : idx ] ) <NEWLINE> stocks = money // minVal <NEWLINE> money = money - minVal * stocks + nums [ idx ] * stocks <NEWLINE> pos = idx <NEWLINE> <DEDENT> print ( money ) <NEWLINE>
BUFSIZE = 30 <NEWLINE> D = int ( input ( ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c0 = sum ( C ) <NEWLINE> Q = [ ( 0 , [ ] , 0 , [ 0 ] * 26 ) ] <NEWLINE> <NL> for d in range ( D ) : <NEWLINE> <INDENT> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q2 = [ ] <NEWLINE> <NL> for q in Q : <NEWLINE> <INDENT> sc , ts , c1 , lasts = q <NEWLINE> c2 = c1 + c0 <NEWLINE> <NL> for t in range ( 26 ) : <NEWLINE> <INDENT> c3 = c2 - ( d + 1 - lasts [ t ] ) * C [ t ] <NEWLINE> lasts2 = lasts [ : ] <NEWLINE> lasts2 [ t ] = d + 1 <NEWLINE> Q2 . append ( ( sc + S [ t ] - c3 , [ ts , t ] , c3 , lasts2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> sizeOfQ2 = len ( Q2 ) <NEWLINE> Q = sorted ( Q2 , reverse = True ) [ : min ( sizeOfQ2 , BUFSIZE ) ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> T = [ ] <NEWLINE> ts = Q [ 0 ] [ 1 ] <NEWLINE> <NL> for d in range ( D ) : <NEWLINE> <INDENT> T . append ( ts [ 1 ] + 1 ) <NEWLINE> ts = ts [ 0 ] <NEWLINE> <NL> <DEDENT> for t in reversed ( T ) : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> from itertools import combinations <NEWLINE> from collections import Counter <NEWLINE> ct = Counter ( ) <NEWLINE> Ass = [ ] <NEWLINE> ans = [ ] <NEWLINE> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Ass . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for z in range ( M ) : <NEWLINE> <INDENT> B = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B . append ( Ass [ i ] [ z ] ) <NEWLINE> <DEDENT> D = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in combinations ( Ass , i ) : <NEWLINE> <INDENT> flag = True <NEWLINE> d = [ 0 ] * ( M + 1 ) <NEWLINE> for k in j : <COMMENT> <NEWLINE> <INDENT> for l in range ( M + 1 ) : <NEWLINE> <INDENT> d [ l ] += k [ l ] <NEWLINE> <DEDENT> <DEDENT> for x in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if d [ x ] >= X : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> ans . append ( d [ 0 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if len ( ans ) > 0 : <NEWLINE> <INDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> P = 2019 <NEWLINE> num = [ 0 ] * P <NEWLINE> num [ 0 ] = 1 <NEWLINE> now , ans = 0 , 0 <NEWLINE> _10 = 1 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> now = ( now + int ( S [ i ] ) * _10 ) % P <NEWLINE> _10 *= 10 <NEWLINE> _10 %= P <NEWLINE> ans += num [ now ] <NEWLINE> num [ now ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> res = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> res [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> [ print ( i ) for i in res ] <NEWLINE>
n = int ( input ( ) ) <NEWLINE> rlist = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> r = int ( input ( ) ) <NEWLINE> rlist . append ( r ) <NEWLINE> <DEDENT> mlist = [ rlist [ 1 ] - rlist [ 0 ] ] <NEWLINE> mini = rlist [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if ( rlist [ i - 1 ] < mini ) : <NEWLINE> <INDENT> mini = rlist [ i - 1 ] <NEWLINE> <DEDENT> m = rlist [ i ] - mini <NEWLINE> if ( m > mlist [ - 1 ] ) : <NEWLINE> <INDENT> mlist . append ( m ) <NEWLINE> <DEDENT> <DEDENT> print ( mlist [ - 1 ] ) <NEWLINE> <NL> <NL>
s = input ( ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> A_count = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> A_count += 1 <NEWLINE> <DEDENT> elif i == <STRING> or i == <STRING> : <NEWLINE> <INDENT> A_count = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += A_count <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
import sys <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> s = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> r = [ ] <NEWLINE> b = [ ] <NEWLINE> g = [ ] <NEWLINE> for i , si in enumerate ( s ) : <NEWLINE> <INDENT> if si == <STRING> : <NEWLINE> <INDENT> r . append ( i + 1 ) <NEWLINE> <DEDENT> elif si == <STRING> : <NEWLINE> <INDENT> g . append ( i + 1 ) <NEWLINE> <DEDENT> elif si == <STRING> : <NEWLINE> <INDENT> b . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k < n and s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( r ) * len ( g ) * len ( b ) - count ) <NEWLINE>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> B = [ list ( map ( int , input ( ) . split ( ) ) ) for j in range ( m ) ] <NEWLINE> <NL> C = [ [ 0 for i in range ( l ) ] for j in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> C [ i ] [ j ] += ( A [ i ] [ k ] * B [ k ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> Cp = [ print ( <STRING> . join ( map ( str , C [ i ] ) ) ) for i in range ( n ) ] <NEWLINE>
N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sumList = [ 0 ] * 8 <NEWLINE> mid = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if 1 <= List [ i ] <= 399 : <NEWLINE> <INDENT> sumList [ 0 ] += 1 <NEWLINE> <DEDENT> elif 400 <= List [ i ] <= 799 : <NEWLINE> <INDENT> sumList [ 1 ] += 1 <NEWLINE> <DEDENT> elif 800 <= List [ i ] <= 1199 : <NEWLINE> <INDENT> sumList [ 2 ] += 1 <NEWLINE> <DEDENT> elif 1200 <= List [ i ] <= 1599 : <NEWLINE> <INDENT> sumList [ 3 ] += 1 <NEWLINE> <DEDENT> elif 1600 <= List [ i ] <= 1999 : <NEWLINE> <INDENT> sumList [ 4 ] += 1 <NEWLINE> <DEDENT> elif 2000 <= List [ i ] <= 2399 : <NEWLINE> <INDENT> sumList [ 5 ] += 1 <NEWLINE> <DEDENT> elif 2400 <= List [ i ] <= 2799 : <NEWLINE> <INDENT> sumList [ 6 ] += 1 <NEWLINE> <DEDENT> elif 2800 <= List [ i ] <= 3199 : <NEWLINE> <INDENT> sumList [ 7 ] += 1 <NEWLINE> <DEDENT> elif 3200 <= List [ i ] : <NEWLINE> <INDENT> mid += 1 <NEWLINE> <DEDENT> <DEDENT> res1 = 8 - sumList . count ( 0 ) <NEWLINE> res2 = res1 + mid <NEWLINE> if res1 == 0 and mid > 0 : <NEWLINE> <INDENT> res1 = 1 <NEWLINE> <DEDENT> print ( res1 , res2 ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . par = [ - 1 ] * n <NEWLINE> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . par [ x ] > self . par [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . par [ x ] += self . par [ y ] <NEWLINE> self . par [ y ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> N , K , L = map ( int , input ( ) . split ( ) ) <NEWLINE> Uni_1 = UnionFind ( N ) <NEWLINE> Uni_2 = UnionFind ( N ) <NEWLINE> D = { } <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> Uni_1 . union ( p - 1 , q - 1 ) <NEWLINE> <DEDENT> for _ in range ( L ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> Uni_2 . union ( p - 1 , q - 1 ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> k = ( Uni_1 . find ( i ) , Uni_2 . find ( i ) ) <NEWLINE> if k in D . keys ( ) : <NEWLINE> <INDENT> D [ k ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D [ k ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( D [ ( Uni_1 . find ( i ) , Uni_2 . find ( i ) ) ] , end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> r = [ i for i , x in enumerate ( s ) if x == <STRING> ] <NEWLINE> g = [ i for i , x in enumerate ( s ) if x == <STRING> ] <NEWLINE> b = [ i for i , x in enumerate ( s ) if x == <STRING> ] <NEWLINE> ans = len ( r ) * len ( g ) * len ( b ) <NEWLINE> <NL> for i in r : <NEWLINE> <INDENT> for j in g : <NEWLINE> <INDENT> i_ = min ( i , j ) <NEWLINE> j_ = max ( i , j ) <NEWLINE> div = ( j_ - i_ ) <NEWLINE> k_1 = i_ - div <NEWLINE> k_2 = div // 2 + i_ <NEWLINE> k_3 = div + j_ <NEWLINE> if k_1 >= 0 and s [ k_1 ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if div % 2 == 0 and s [ k_2 ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if k_3 < n and s [ k_3 ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * ( 10 ** 5 ) <NEWLINE> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> for j in range ( 1 , 101 ) : <NEWLINE> <INDENT> for k in range ( 1 , 101 ) : <NEWLINE> <INDENT> a [ i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( a [ i + 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> stdin = sys . stdin <NEWLINE> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def nm ( ) : return map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> def nl ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> S = ns ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif S == <STRING> or S == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif S == <STRING> or S == <STRING> or S == <STRING> or S == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b , c = [ ] , [ ] , [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( A ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if a [ i ] [ 1 ] == n : <NEWLINE> <INDENT> b . append ( a [ i ] [ 0 ] ) <NEWLINE> <DEDENT> elif a [ i ] [ 0 ] == 1 : <NEWLINE> <INDENT> c . append ( a [ i ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( set ( b ) & set ( c ) ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import bisect <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> CB = [ None ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> b , c = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> CB [ i ] = ( c , b ) <NEWLINE> <DEDENT> CB . sort ( reverse = True ) <NEWLINE> <NL> i = 0 <NEWLINE> ans = 0 <NEWLINE> for c , b in CB : <NEWLINE> <INDENT> x = bisect . bisect_left ( A , c , i ) <NEWLINE> count = min ( x - i , b ) <NEWLINE> ans += c * count <NEWLINE> i += count <NEWLINE> <DEDENT> for j in range ( i , N ) : <NEWLINE> <INDENT> ans += A [ j ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> X , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> sys , exit ( ) <NEWLINE> <DEDENT> pp = list ( map ( lambda x : abs ( x - X ) , p ) ) <NEWLINE> pp . sort ( ) <NEWLINE> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> tmp = X - pp [ 0 ] - i <NEWLINE> if not tmp in p : <NEWLINE> <INDENT> print ( tmp ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> tmpp = X - pp [ 0 ] + i <NEWLINE> if not tmpp in p : <NEWLINE> <INDENT> print ( tmpp ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
T = list ( input ( ) ) <NEWLINE> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> if len ( T ) == 1 : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> if T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( T ) ) <NEWLINE>
A , B , C , K = input ( ) . split ( ) <NEWLINE> A , B , C , K = int ( A ) , int ( B ) , int ( C ) , int ( K ) <NEWLINE> <NL> if K >= A : <NEWLINE> <INDENT> Anum = A <NEWLINE> N = K - A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Anum = K <NEWLINE> N = 0 <NEWLINE> <NL> <DEDENT> if N >= B : <NEWLINE> <INDENT> Bnum = B <NEWLINE> N = N - B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Bnum = N <NEWLINE> N = 0 <NEWLINE> <NL> <DEDENT> Cnum = N <NEWLINE> <NL> Total = Anum * 1 + Bnum * 0 + Cnum * ( - 1 ) <NEWLINE> <NL> print ( Total ) <NEWLINE>
def f ( x ) : <NEWLINE> <INDENT> while p [ x ] > 0 : x = p [ x ] <NEWLINE> return x <NEWLINE> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ - 1 ] * N <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( lambda x : f ( int ( x ) - 1 ) , input ( ) . split ( ) ) <NEWLINE> if A == B : continue <NEWLINE> elif A < B : A , B = B , A <NEWLINE> p [ A ] += p [ B ] <NEWLINE> p [ B ] = A <NEWLINE> <DEDENT> print ( sum ( i < 0 for i in p ) - 1 ) <NEWLINE>
from math import sqrt <NEWLINE> <NL> def prime_numbers ( n ) : <NEWLINE> <INDENT> total = 0 <NEWLINE> for x in n : <NEWLINE> <INDENT> if is_prime ( x ) : <NEWLINE> <INDENT> total += 1 <NEWLINE> <DEDENT> <DEDENT> return total <NEWLINE> <NL> <DEDENT> def is_prime ( x ) : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif x < 2 or x % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( 3 , int ( sqrt ( x ) ) + 1 , 2 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = [ ] <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> n . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> print ( prime_numbers ( n ) ) <NEWLINE> <NL> <DEDENT>
k = sum ( map ( int , str ( input ( ) ) ) ) <NEWLINE> if k % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> C = collections . Counter ( A ) <NEWLINE> <COMMENT> <NL> <NL> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> print ( C [ i + 1 ] ) <NEWLINE> <DEDENT>
for _ in [ 0 ] * int ( input ( ) ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s [ : 2 ] == <STRING> and s [ - 1 ] == <STRING> and <STRING> in s : <NEWLINE> <INDENT> s = s [ 2 : - 1 ] . split ( <STRING> ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ set ( s [ 0 ] ) == set ( s [ 1 ] ) == { <STRING> } and len ( set ( s ) ) == 1 ] ) <NEWLINE> <DEDENT> elif s [ : 2 ] == <STRING> and s [ - 2 : ] == <STRING> : <NEWLINE> <INDENT> s = s [ 2 : - 2 ] <NEWLINE> print ( [ <STRING> , <STRING> ] [ len ( s ) == 2 * s . count ( <STRING> ) and len ( s ) > 0 ] ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> <NL> <NL> def pivot_index ( change_box , i , which ) : <NEWLINE> <INDENT> if which == 0 : <NEWLINE> <INDENT> for cb in change_box : <NEWLINE> <INDENT> if cb >= i : <NEWLINE> <INDENT> return cb <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( len ( change_box ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if change_box [ j ] <= i : <NEWLINE> <INDENT> return change_box [ j ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> change_box = [ ] <NEWLINE> floor_chart = 1 <NEWLINE> i = 0 <NEWLINE> while i < len ( S ) - 1 : <NEWLINE> <INDENT> if S [ i ] != S [ i + 1 ] and floor_chart == 1 : <NEWLINE> <INDENT> floor_chart = 0 <NEWLINE> change_box . append ( i ) <NEWLINE> <DEDENT> elif S [ i ] != S [ i + 1 ] and floor_chart == 0 : <NEWLINE> <INDENT> floor_chart = 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * len ( S ) <NEWLINE> one_cool = 0 <NEWLINE> hash_one = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if hash_one == 1 : <NEWLINE> <INDENT> hash_one = 0 <NEWLINE> one_cool += 1 <NEWLINE> <DEDENT> pidx = change_box [ one_cool ] <NEWLINE> cool = pidx - i <NEWLINE> if cool % 2 == 0 : <NEWLINE> <INDENT> ans [ pidx ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ pidx + 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pidx = change_box [ one_cool ] + 1 <NEWLINE> hash_one = 1 <NEWLINE> cool = i - pidx <NEWLINE> if cool % 2 == 0 : <NEWLINE> <INDENT> ans [ pidx ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ pidx - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans [ 0 ] , end = <STRING> ) <NEWLINE> for i in range ( 1 , len ( ans ) ) : <NEWLINE> <INDENT> print ( <STRING> . format ( ans [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> a . sort ( ) <NEWLINE> b = [ 0 for _ in range ( a [ - 1 ] ) ] <NEWLINE> c = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> x = i - 1 <NEWLINE> while len ( b ) > x : <NEWLINE> <INDENT> b [ x ] += 1 <NEWLINE> x += i <NEWLINE> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> if b [ i - 1 ] == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> c = math . gcd ( a , b ) <NEWLINE> c2 = c <NEWLINE> l = [ ] <NEWLINE> i = 2 <NEWLINE> while i <= c : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> c = c // i <NEWLINE> <NL> l . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> if i * i - 1 > c : <NEWLINE> <INDENT> l . append ( c ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( set ( l ) ) + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> C = list ( input ( ) ) <NEWLINE> R_cnt = C . count ( <STRING> ) <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> cnt = 0 <NEWLINE> for i in range ( R_cnt ) : <NEWLINE> <INDENT> if C [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( R_cnt - cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> m = 0 <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> if x [ i ] != y [ i ] : <NEWLINE> <INDENT> m += 1 <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> read = sys . stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = np . fromstring ( read ( ) , dtype = np . int32 , sep = <STRING> ) <NEWLINE> b = np . fromstring ( read ( ) , dtype = np . int32 , sep = <STRING> ) [ : : - 1 ] <NEWLINE> <NL> kokan = [ ] <NEWLINE> same = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == b [ i ] : <NEWLINE> <INDENT> same = a [ i ] <NEWLINE> <DEDENT> <DEDENT> if same == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * b ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] != b [ i ] and a [ i ] != same and b [ i ] != same : <NEWLINE> <INDENT> kokan . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == b [ i ] : <NEWLINE> <INDENT> if len ( kokan ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = kokan [ - 1 ] <NEWLINE> b [ i ] , b [ j ] = b [ j ] , b [ i ] <NEWLINE> kokan . pop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * b ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if min ( A ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> ans *= A [ N - 1 ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> m = int ( n ** 0.5 ) <NEWLINE> <NL> while n % m : <NEWLINE> <INDENT> m -= 1 <NEWLINE> <NL> <DEDENT> print ( len ( str ( n // m ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> if ( S [ k - 1 ] == <STRING> ) : <NEWLINE> <INDENT> S [ k - 1 ] = <STRING> <NEWLINE> <DEDENT> elif ( S [ k - 1 ] == <STRING> ) : <NEWLINE> <INDENT> S [ k - 1 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ k - 1 ] = <STRING> <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( S [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for d in range ( 1 , ( N - i - 1 ) // 2 + 1 ) : <NEWLINE> <INDENT> if { S [ i ] , S [ i + d ] , S [ i + 2 * d ] } == { <STRING> , <STRING> , <STRING> } : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( r * r * math . pi , 2 * r * math . pi ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> <NL> if ( n - 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( ( n * ( n - 1 ) // 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n * ( n - 2 ) // 2 + n // 2 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if m == 0 : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> import sys <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> p = [ list ( input ( ) . split ( ) ) for _ in range ( m ) ] <NEWLINE> correct = set ( [ p [ i ] [ 0 ] for i in range ( m ) if p [ i ] [ 1 ] == <STRING> ] ) <NEWLINE> <NL> s = set ( ) <NEWLINE> sum_wa = 0 <NEWLINE> <NL> for i in [ p [ j ] for j in range ( m ) if p [ j ] [ 0 ] in correct ] : <NEWLINE> <INDENT> if i [ 0 ] in s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i [ 1 ] == <STRING> : <NEWLINE> <INDENT> sum_wa += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . add ( i [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( correct ) , sum_wa ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> a = [ i for i in range ( n + 1 ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> first = i * ( a [ 0 ] + a [ i - 1 ] ) / 2 <NEWLINE> last = i * ( a [ - i ] + a [ - 1 ] ) / 2 <NEWLINE> ans += last - first + 1 <NEWLINE> <DEDENT> print ( int ( ans % MOD ) ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> for i in range ( 101 ) : <NEWLINE> <INDENT> if x - i not in p : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif x + i not in p : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n , m , l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> <NL> for ni in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for mi in range ( m ) : <NEWLINE> <INDENT> B . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> C . append ( [ ] ) <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> C [ i ] . append ( 0 ) <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for ni in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( s ) for s in C [ ni ] ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import Counter , deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> c = Counter ( s ) <NEWLINE> c = list ( c . values ( ) ) <NEWLINE> if len ( c ) == 3 : <NEWLINE> <INDENT> ans = c [ 0 ] * c [ 1 ] * c [ 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <COMMENT> <NL> <DEDENT> if ans > 0 : <NEWLINE> <INDENT> for k in range ( n ) : <NEWLINE> <INDENT> for a in range ( 1 , ( n - k ) // 2 + 1 ) : <NEWLINE> <INDENT> if k + 2 * a >= n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x , y , = s [ k ] , s [ k + a ] <NEWLINE> <NL> if x != y : <NEWLINE> <INDENT> z = s [ k + 2 * a ] <NEWLINE> if y != z : <NEWLINE> <INDENT> if z != x : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import bisect as bs <NEWLINE> <NL> def binarySearch_canread ( data , target ) : <NEWLINE> <INDENT> if len ( data ) == 0 : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> if len ( data ) == 1 : <NEWLINE> <INDENT> return data [ 0 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if target > max ( data ) : <NEWLINE> <INDENT> return len ( data ) <NEWLINE> <DEDENT> elif target < min ( data ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> min_diff = float ( <STRING> ) <NEWLINE> imin = 0 <NEWLINE> imax = len ( data ) - 1 <NEWLINE> closest_num = None <NEWLINE> <NL> while imin <= imax : <NEWLINE> <INDENT> imid = imin + ( imax - imin ) // 2 <NEWLINE> <NL> if imid + 1 < len ( data ) : <NEWLINE> <INDENT> min_diff_right = abs ( data [ imid + 1 ] - target ) <NEWLINE> <DEDENT> if imid > 0 : <NEWLINE> <INDENT> min_diff_left = abs ( data [ imid - 1 ] - target ) <NEWLINE> <NL> <DEDENT> if min_diff_left < min_diff : <NEWLINE> <INDENT> min_diff = min_diff_left <NEWLINE> closest_num = data [ imid - 1 ] <NEWLINE> <DEDENT> if min_diff_right < min_diff : <NEWLINE> <INDENT> min_diff = min_diff_right <NEWLINE> closest_num = data [ imid + 1 ] <NEWLINE> <NL> <DEDENT> if data [ imid ] < target : <NEWLINE> <INDENT> imin = imid + 1 <NEWLINE> <DEDENT> elif data [ imid ] > target : <NEWLINE> <INDENT> imax = imid - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return list ( data ) . index ( data [ imid ] ) + 1 <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> differ = target - closest_num <NEWLINE> can_read = None <NEWLINE> if differ > 0 : <COMMENT> <NEWLINE> <INDENT> can_read = max ( [ i for i , x in enumerate ( data ) if x == closest_num ] ) + 1 <NEWLINE> <DEDENT> elif differ < 0 : <COMMENT> <NEWLINE> <INDENT> can_read = min ( [ i for i , x in enumerate ( data ) if x == closest_num ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> return can_read <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> N , M , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = np . array ( readline ( ) . split ( ) , np . int64 ) <NEWLINE> B = np . array ( readline ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> Acum = np . zeros ( N + 1 , np . int64 ) <NEWLINE> Acum [ 1 : ] = np . cumsum ( A ) <NEWLINE> Bcum = np . zeros ( M + 1 , np . int64 ) <NEWLINE> Bcum [ 1 : ] = np . cumsum ( B ) <NEWLINE> <NL> <COMMENT> <NL> max_read = 0 <NEWLINE> <COMMENT> <NL> for i , cumNum in enumerate ( Acum ) : <COMMENT> <NEWLINE> <INDENT> if cumNum <= K : <NEWLINE> <INDENT> limit = K - cumNum <NEWLINE> <COMMENT> <NL> can_reading = i + bs . bisect_right ( Bcum [ 1 : ] , limit ) <NEWLINE> if ( max_read < can_reading ) : <NEWLINE> <INDENT> max_read = can_reading <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max_read ) <NEWLINE> <DEDENT>
a = sum ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> b = sum ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> print ( max ( a , b ) ) <NEWLINE>
import copy <NEWLINE> import math <NEWLINE> import time <NEWLINE> <NL> <COMMENT> <NL> def get_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_string ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_int_list ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> <DEDENT> def get_string_list ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_int_multi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_string_char_list ( ) : <NEWLINE> <INDENT> return list ( str ( input ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <STRING> <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> start = time . time ( ) <NEWLINE> <NL> n = get_int ( ) <NEWLINE> s_list = get_string_char_list ( ) <NEWLINE> s_list = [ int ( x ) for x in s_list ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 0 , 1000 ) : <NEWLINE> <INDENT> a = i // 100 <NEWLINE> b = ( i % 100 ) // 10 <NEWLINE> c = i % 10 <NEWLINE> <NL> find_a = False <NEWLINE> find_b = False <NEWLINE> for ii in s_list : <NEWLINE> <NL> <INDENT> if ( find_a == False ) and ( ii == a ) : <NEWLINE> <INDENT> find_a = True <NEWLINE> <DEDENT> elif ( find_a == True ) and ( find_b == False ) and ( ii == b ) : <NEWLINE> <INDENT> find_b = True <NEWLINE> <DEDENT> elif ( find_b == True ) and ( ii == c ) : <NEWLINE> <NL> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> cnt = Counter ( S ) <NEWLINE> <NL> ans = cnt [ <STRING> ] * cnt [ <STRING> ] * cnt [ <STRING> ] <NEWLINE> <COMMENT> <NL> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> <COMMENT> <NL> if k < N : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for __ in range ( m ) ] <NEWLINE> <NL> n_list = [ x for x in range ( 1 , n + 1 ) ] <NEWLINE> ze = dict ( zip ( n_list , [ 0 for i in range ( len ( n_list ) ) ] ) ) <NEWLINE> <NL> for i in ab : <NEWLINE> <INDENT> if ( h [ i [ 0 ] - 1 ] > h [ i [ 1 ] - 1 ] ) : <NEWLINE> <INDENT> ze [ i [ 1 ] ] += 1 <NEWLINE> <DEDENT> elif ( h [ i [ 0 ] - 1 ] < h [ i [ 1 ] - 1 ] ) : <NEWLINE> <INDENT> ze [ i [ 0 ] ] += 1 <NEWLINE> <DEDENT> elif h [ i [ 0 ] - 1 ] == h [ i [ 1 ] - 1 ] : <NEWLINE> <INDENT> ze [ i [ 0 ] ] += 1 <NEWLINE> ze [ i [ 1 ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> res = 0 <NEWLINE> for k , v in ze . items ( ) : <NEWLINE> <INDENT> if v == 0 : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> time_of_A = [ A [ 0 ] ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> time_of_A . append ( time_of_A [ i - 1 ] + A [ i ] ) <NEWLINE> <DEDENT> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> time_of_B = [ B [ 0 ] ] <NEWLINE> for i in range ( 1 , M ) : <NEWLINE> <INDENT> time_of_B . append ( time_of_B [ i - 1 ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> book = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if time_of_A [ i ] <= K : <NEWLINE> <INDENT> book . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> if time_of_B [ i ] <= K : <NEWLINE> <INDENT> book . append ( i + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> start = M - 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> j = start <NEWLINE> time = 10 ** 9 + 1 <NEWLINE> while time > K and j >= 0 : <NEWLINE> <INDENT> time = time_of_A [ i ] + time_of_B [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> if time <= K : <NEWLINE> <INDENT> book . append ( i + j + 3 ) <NEWLINE> j += 1 <NEWLINE> start = j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( max ( book ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> s = <STRING> <NEWLINE> for i in range ( 12 ) : <NEWLINE> <INDENT> if 26 * ( 26 ** i - 1 ) / 25 < N and N <= 26 * ( 26 ** ( i + 1 ) - 1 ) / 25 : <NEWLINE> <INDENT> t = i <COMMENT> <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> N = int ( N - 26 * ( 26 ** t - 1 ) / 25 - 1 ) <NEWLINE> <NL> a = [ 0 ] * ( t + 1 ) <NEWLINE> <NL> for i in range ( t + 1 ) : <NEWLINE> <INDENT> a [ t - i ] = N % 26 <NEWLINE> N = N // 26 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( 0 , len ( a ) ) : <NEWLINE> <INDENT> a [ i ] = chr ( 97 + int ( a [ i ] ) ) <NEWLINE> s += a [ i ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> B . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> s = sum ( A ) <NEWLINE> from collections import Counter <NEWLINE> a = Counter ( A ) <NEWLINE> b = list ( a . keys ( ) ) <NEWLINE> c = list ( a . values ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> s -= B [ i ] [ 0 ] * a [ B [ i ] [ 0 ] ] <NEWLINE> s += B [ i ] [ 1 ] * a [ B [ i ] [ 0 ] ] <NEWLINE> a [ B [ i ] [ 1 ] ] += a [ B [ i ] [ 0 ] ] <NEWLINE> a [ B [ i ] [ 0 ] ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
from bisect import bisect_left <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> <NL> idx = bisect_left ( A , 0 ) <NEWLINE> if idx != 0 and idx != N : <NEWLINE> <INDENT> if idx % 2 == 1 : <NEWLINE> <INDENT> if abs ( A [ idx - 1 ] ) > abs ( A [ idx ] ) : <NEWLINE> <INDENT> A [ idx - 1 ] *= - 1 <NEWLINE> A [ idx ] *= - 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 0 , idx - 1 , 2 ) : <NEWLINE> <INDENT> A [ i ] *= - 1 <NEWLINE> A [ i + 1 ] *= - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if idx == N : <NEWLINE> <INDENT> if N % 2 == 0 : <NEWLINE> <INDENT> print ( - sum ( A ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - sum ( A [ : - 1 ] ) + A [ - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , copy , functools <NEWLINE> import time , random <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> mod2 = 998244353 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def LLI ( ) : return [ list ( map ( int , l . split ( ) ) ) for l in sys . stdin . readlines ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> def pe ( s ) : return print ( str ( s ) , file = sys . stderr ) <NEWLINE> def JA ( a , sep ) : return sep . join ( map ( str , a ) ) <NEWLINE> def JAA ( a , s , t ) : return s . join ( t . join ( map ( str , b ) ) for b in a ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> x = I ( ) <NEWLINE> for a in range ( 1 , 1000 ) : <NEWLINE> <INDENT> a5 = a ** 5 <NEWLINE> for b in range ( a + 1 ) : <NEWLINE> <INDENT> b5 = b ** 5 <NEWLINE> if a5 + b5 == x : <NEWLINE> <INDENT> return JA ( [ a , - b ] , <STRING> ) <NEWLINE> <DEDENT> if a5 - b5 == x : <NEWLINE> <INDENT> return JA ( [ a , b ] , <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL> <NL> <NL>
<COMMENT> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> s . append ( list ( <STRING> for i in range ( w + 2 ) ) ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s . append ( list ( <STRING> + input ( ) + <STRING> ) ) <NEWLINE> <DEDENT> s . append ( list ( <STRING> for i in range ( w + 2 ) ) ) <NEWLINE> ans = [ [ 0 for j in range ( w ) ] for i in range ( h ) ] <NEWLINE> <NL> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> if s [ i ] [ j ] != <STRING> : <NEWLINE> <INDENT> for m in range ( i - 1 , i + 2 ) : <NEWLINE> <INDENT> for n in range ( j - 1 , j + 2 ) : <NEWLINE> <INDENT> if s [ m ] [ n ] == <STRING> : <NEWLINE> <INDENT> ans [ i - 1 ] [ j - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans [ i - 1 ] [ j - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> ans [ i ] [ j ] = str ( ans [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> . join ( ans [ i ] ) ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> edges = { i : [ ] for i in range ( 1 , N + 1 ) } <NEWLINE> visited = [ False for _ in range ( N + 1 ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a ] . append ( b ) <NEWLINE> edges [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> def dfs ( n , count ) : <NEWLINE> <COMMENT> <NL> <INDENT> if count == 3 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if n == N : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> visited [ n ] = True <NEWLINE> <NL> for edge in edges [ n ] : <NEWLINE> <INDENT> if visited [ edge ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if dfs ( edge , count + 1 ) : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> print ( <STRING> if dfs ( 1 , 0 ) else <STRING> ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> <NL> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if s > 10 ** ( 18 ) : <NEWLINE> <INDENT> s = - 1 <NEWLINE> break <NEWLINE> <DEDENT> s = s * A [ i ] <NEWLINE> <NL> <DEDENT> if s > 10 ** ( 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> from collections import defaultdict <NEWLINE> <NL> ( n , ) , * p = [ [ * map ( int , i . split ( ) ) ] for i in open ( 0 ) ] <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> d [ ( p [ i ] [ 0 ] - p [ j ] [ 0 ] , p [ i ] [ 1 ] - p [ j ] [ 1 ] ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( n * ( n < 2 ) or n - max ( d . values ( ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 1 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( a [ l [ i ] - 1 ] ) <NEWLINE> <DEDENT> p = l . index ( l [ n ] ) <NEWLINE> <COMMENT> <NL> if k <= n : <NEWLINE> <INDENT> print ( l [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = ( k - n + 1 ) % ( n - p ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> x += ( n - p ) <NEWLINE> print ( l [ x - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l [ x + p - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
def i ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def i2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def s ( ) : <NEWLINE> <INDENT> return str ( input ( ) ) <NEWLINE> <DEDENT> def l ( ) : <NEWLINE> <INDENT> return list ( input ( ) ) <NEWLINE> <DEDENT> def intl ( ) : <NEWLINE> <INDENT> return list ( int ( k ) for k in input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> a = [ str ( input ( ) ) for _ in range ( 5 ) ] <NEWLINE> <NL> n = 10 <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if int ( a [ i ] [ - 1 ] ) < n and int ( a [ i ] [ - 1 ] ) != 0 : <NEWLINE> <INDENT> n = int ( a [ i ] [ - 1 ] ) <NEWLINE> cnt = i <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if i == cnt : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> <DEDENT> elif int ( a [ i ] [ - 1 ] ) == 0 : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ i ] = ( int ( a [ i ] ) // 10 + 1 ) * 10 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
import numpy as np <NEWLINE> import numba <NEWLINE> @ numba . njit ( <STRING> , cache = True ) <NEWLINE> def solve ( N , S , A ) : <NEWLINE> <INDENT> dp = np . zeros ( ( N + 1 , S + 1 ) , dtype = np . int64 ) <COMMENT> <NEWLINE> dp [ 0 ] [ 0 ] = 1 <NEWLINE> mod = 998244353 <NEWLINE> for i , a in enumerate ( A , 1 ) : <NEWLINE> <INDENT> for s in range ( S + 1 ) : <NEWLINE> <INDENT> if s - a >= 0 : <NEWLINE> <INDENT> dp [ i ] [ s ] = ( dp [ i - 1 ] [ s ] * 2 + dp [ i - 1 ] [ s - a ] ) % mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ s ] = dp [ i - 1 ] [ s ] * 2 % mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ N ] [ S ] ) <NEWLINE> <NL> <DEDENT> N , S = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> solve ( N , S , np . array ( A ) ) <NEWLINE>
n , m , l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> <NL> for ni in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for mi in range ( m ) : <NEWLINE> <INDENT> B . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> C . append ( [ ] ) <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> C [ i ] . append ( 0 ) <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for ni in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( s ) for s in C [ ni ] ] ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , m = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> if m == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> g = [ set ( ) for _ in range ( n + 1 ) ] <NEWLINE> seen = [ False ] * ( n + 1 ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> g [ a ] . add ( b ) <NEWLINE> g [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if seen [ i ] : continue <NEWLINE> stack = set ( [ i ] ) <NEWLINE> l = 0 <NEWLINE> while len ( stack ) > 0 : <NEWLINE> <INDENT> no = stack . pop ( ) <NEWLINE> seen [ no ] = True <NEWLINE> l += 1 <NEWLINE> for nn in g [ no ] : <NEWLINE> <INDENT> if not seen [ nn ] : <NEWLINE> <INDENT> stack . add ( nn ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = max ( ans , l ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
W = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> S = input ( ) <NEWLINE> print ( len ( W ) - W . index ( S ) ) <NEWLINE>
import math <NEWLINE> from numba import jit <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> <NL> @ jit <NEWLINE> def apt ( N ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> cnt += math . gcd ( k , math . gcd ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> print ( apt ( K ) ) <NEWLINE>
import sys <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , x ) : <NEWLINE> <INDENT> self . data = x <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <DEDENT> def insert ( node , x ) : <NEWLINE> <INDENT> if node == None : <NEWLINE> <INDENT> return Node ( x ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> elif x < node . data : <NEWLINE> <INDENT> node . left = Node . insert ( node . left , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . right = Node . insert ( node . right , x ) <NEWLINE> <DEDENT> return node <NEWLINE> <NL> <DEDENT> def find ( node , x ) : <NEWLINE> <INDENT> if node . data == x : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif node . left != None and node . data > x : <NEWLINE> <INDENT> return Node . find ( node . left , x ) <NEWLINE> <DEDENT> elif node . right != None and node . data < x : <NEWLINE> <INDENT> return Node . find ( node . right , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def delete ( node , x ) : <NEWLINE> <INDENT> if node . data == x : <NEWLINE> <INDENT> if ( node . left == None ) and ( node . right == None ) : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> elif node . left == None : <NEWLINE> <INDENT> return node . right <NEWLINE> <DEDENT> elif node . right == None : <NEWLINE> <INDENT> return node . left <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> node . data = Node . serch_min ( node . right ) <NEWLINE> node . right = Node . delete_min ( node . right ) <NEWLINE> return node <NEWLINE> <DEDENT> <DEDENT> elif node . data > x : <NEWLINE> <INDENT> node . left = Node . delete ( node . left , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . right = Node . delete ( node . right , x ) <NEWLINE> <DEDENT> return node <NEWLINE> <NL> <DEDENT> def serch_min ( node ) : <NEWLINE> <INDENT> if node . left != None : <NEWLINE> <INDENT> return Node . serch_min ( node . left ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return node . data <NEWLINE> <NL> <DEDENT> <DEDENT> def delete_min ( node ) : <NEWLINE> <INDENT> if node . left == None : <NEWLINE> <INDENT> return node . right <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . left = Node . delete_min ( node . left ) <NEWLINE> return node <NEWLINE> <NL> <DEDENT> <DEDENT> def inorder_print ( node ) : <NEWLINE> <INDENT> if node . left != None : <NEWLINE> <INDENT> Node . inorder_print ( node . left ) <NEWLINE> <DEDENT> print ( <STRING> , node . data , end = <STRING> ) <NEWLINE> if node . right != None : <NEWLINE> <INDENT> Node . inorder_print ( node . right ) <NEWLINE> <DEDENT> <DEDENT> def preorder_print ( node ) : <NEWLINE> <INDENT> print ( <STRING> , node . data , end = <STRING> ) <NEWLINE> if node . left != None : <NEWLINE> <INDENT> Node . preorder_print ( node . left ) <NEWLINE> <DEDENT> if node . right != None : <NEWLINE> <INDENT> Node . preorder_print ( node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> class BinaryTree : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def insert ( self , x ) : <NEWLINE> <INDENT> self . root = Node . insert ( self . root , x ) <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if Node . find ( self . root , x ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def delete ( self , x ) : <NEWLINE> <INDENT> self . root = Node . delete ( self . root , x ) <NEWLINE> <NL> <DEDENT> def print_tree ( self ) : <NEWLINE> <INDENT> Node . inorder_print ( self . root ) <NEWLINE> print ( ) <NEWLINE> Node . preorder_print ( self . root ) <NEWLINE> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> T = BinaryTree ( ) <NEWLINE> m = int ( sys . stdin . readline ( ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s = sys . stdin . readline ( ) . strip ( ) <NEWLINE> if ( s == <STRING> ) : <NEWLINE> <INDENT> T . print_tree ( ) <NEWLINE> <DEDENT> elif s . split ( ) [ 0 ] == <STRING> : <NEWLINE> <INDENT> T . find ( int ( s . split ( ) [ 1 ] ) ) <NEWLINE> <DEDENT> elif s . split ( ) [ 0 ] == <STRING> : <NEWLINE> <INDENT> T . delete ( int ( s . split ( ) [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = int ( s . split ( ) [ 1 ] ) <NEWLINE> T . insert ( z ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import collections <NEWLINE> <NL> while True : <NEWLINE> <INDENT> N , M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if N == 0 and M == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> square_count_w = collections . defaultdict ( int ) <NEWLINE> square_count_h = collections . defaultdict ( int ) <NEWLINE> heights = [ ] <NEWLINE> widths = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> height = int ( raw_input ( ) ) <NEWLINE> square_count_h [ height ] += 1 <NEWLINE> sum_h = 0 <NEWLINE> for h in heights [ : : - 1 ] : <NEWLINE> <INDENT> sum_h += h <NEWLINE> square_count_h [ height + sum_h ] += 1 <NEWLINE> <DEDENT> heights . append ( height ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> width = int ( raw_input ( ) ) <NEWLINE> square_count_w [ width ] += 1 <NEWLINE> sum_w = 0 <NEWLINE> for w in widths [ : : - 1 ] : <NEWLINE> <INDENT> sum_w += w <NEWLINE> square_count_w [ width + sum_w ] += 1 <NEWLINE> <DEDENT> widths . append ( width ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for key , value in square_count_w . items ( ) : <NEWLINE> <INDENT> ans += square_count_w [ key ] * square_count_h [ key ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
nCase = 0 <NEWLINE> while True : <NEWLINE> <INDENT> W = int ( input ( ) ) <NEWLINE> if W == 0 : break <NEWLINE> nCase += 1 <NEWLINE> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> items = [ tuple ( map ( int , input ( ) . split ( <STRING> ) ) ) for _ in range ( N ) ] <NEWLINE> bestValueFor = [ 0 ] * ( W + 1 ) <COMMENT> <NEWLINE> for item in items : <NEWLINE> <INDENT> for capa in reversed ( range ( W - item [ 1 ] + 1 ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> if bestValueFor [ capa ] + item [ 0 ] > bestValueFor [ capa + item [ 1 ] ] : <NEWLINE> <INDENT> bestValueFor [ capa + item [ 1 ] ] = bestValueFor [ capa ] + item [ 0 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> bestValue = max ( bestValueFor ) <NEWLINE> bestWeight = bestValueFor . index ( bestValue ) <NEWLINE> print ( <STRING> , str ( nCase ) , <STRING> , sep = <STRING> ) <NEWLINE> print ( bestValue ) <NEWLINE> print ( bestWeight ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 1 <NEWLINE> a . sort ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> <COMMENT> <NL> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def resultSur97 ( x ) : <NEWLINE> <INDENT> return x % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> n = int ( input ( ) ) <COMMENT> <NEWLINE> aList = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> sum = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> sum += aList [ i ] <NEWLINE> <NL> <DEDENT> pro = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> ai = aList [ i ] <NEWLINE> sum = sum - ai <NEWLINE> pro += sum * aList [ i ] <NEWLINE> <NL> <DEDENT> out = resultSur97 ( pro ) <NEWLINE> <NL> <COMMENT> <NL> print ( <STRING> . format ( out ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
while 1 : <NEWLINE> <INDENT> a = list ( input ( ) ) <NEWLINE> if a == [ <STRING> , <STRING> , <STRING> , <STRING> ] : break <NEWLINE> if a [ 0 ] == a [ 1 ] == a [ 2 ] == a [ 3 ] : print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> c = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if a == [ <STRING> , <STRING> , <STRING> , <STRING> ] : break <NEWLINE> c += 1 <NEWLINE> s = int ( <STRING> . join ( sorted ( a ) ) ) <NEWLINE> l = int ( <STRING> . join ( sorted ( a , reverse = True ) ) ) <NEWLINE> a = list ( <STRING> . format ( l - s ) ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , input ( ) . split ( ) ) <NEWLINE> if abs ( ( y1 - y2 ) * ( x4 - x3 ) - ( y4 - y3 ) * ( x1 - x2 ) ) < 1e-10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import copy <NEWLINE> import math <NEWLINE> import time <NEWLINE> import statistics <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> import sys <NEWLINE> from decimal import * <NEWLINE> <NL> <COMMENT> <NL> def get_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_string ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_int_list ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> <DEDENT> def get_string_list ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_int_multi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_string_char_list ( ) : <NEWLINE> <INDENT> return list ( str ( input ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <STRING> <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> start = time . time ( ) <NEWLINE> <NL> n , q = get_int_multi ( ) <NEWLINE> <NL> a = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> s , e = get_int_multi ( ) <NEWLINE> a [ s ] . append ( e ) <NEWLINE> a [ e ] . append ( s ) <NEWLINE> <NL> <DEDENT> point = [ 0 ] * ( n + 1 ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = get_int_multi ( ) <NEWLINE> point [ p ] += x <NEWLINE> <NL> <DEDENT> def tasu ( now , prev ) : <NEWLINE> <INDENT> for next in a [ now ] : <NEWLINE> <INDENT> if next == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> point [ next ] += point [ now ] <NEWLINE> tasu ( next , now ) <NEWLINE> <NL> <DEDENT> <DEDENT> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> tasu ( 1 , - 1 ) <NEWLINE> point = point [ 1 : ] <COMMENT> <NEWLINE> print ( * point ) <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def check_pn ( num ) : <NEWLINE> <INDENT> if ( num < 2 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif ( num == 2 ) : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> if ( num % 2 == 0 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i = 3 <NEWLINE> while ( i <= num / i ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i += 2 <NEWLINE> <NL> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> listdata = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> listdata . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> n = 0 <NEWLINE> for data in listdata : <NEWLINE> <INDENT> ch = check_pn ( data ) <NEWLINE> n += ch <NEWLINE> <NL> <DEDENT> print ( n ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> ans += s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if 123 - ord ( s ) <= K : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> K -= 123 - ord ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += s <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if K > 0 : <NEWLINE> <INDENT> ans = ans [ : - 1 ] + ( chr ( ord ( ans [ - 1 ] ) + K % 26 ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from numba import njit <NEWLINE> import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <NL> @ njit <NEWLINE> def f ( A ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> limit = 10 ** 18 <NEWLINE> if np . sum ( A == 0 ) > 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif np . sum ( np . log10 ( A ) ) > 18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> <DEDENT> return ans if ans <= limit else - 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( int ( f ( A ) ) ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> def ok ( B ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> B = abs ( B ) <NEWLINE> while i ** 5 < B : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> return i ** 5 == B <NEWLINE> <NL> <DEDENT> def get ( B ) : <NEWLINE> <INDENT> f = B / abs ( B ) <NEWLINE> i = 1 <NEWLINE> B = abs ( B ) <NEWLINE> while i ** 5 < B : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> return int ( i * f ) <NEWLINE> <NL> <NL> <NL> <DEDENT> A_cand = [ ] <NEWLINE> i = 0 <NEWLINE> while i ** 5 <= 10 ** 10 : <NEWLINE> <INDENT> A_cand . append ( i ) <NEWLINE> i += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for a in range ( 300 ) : <NEWLINE> <INDENT> B_5 = a ** 5 - X <NEWLINE> if ok ( B_5 ) : <NEWLINE> <INDENT> r = get ( B_5 ) <NEWLINE> print ( a , r ) <NEWLINE> exit ( ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for a in A_cand : <NEWLINE> <INDENT> a *= - 1 <NEWLINE> B_5 = a ** 5 - X <NEWLINE> if ok ( B_5 ) : <NEWLINE> <INDENT> r = get ( B_5 ) <NEWLINE> print ( a , r ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( 0 / 0 ) <NEWLINE>
import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> import bisect <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import queue <NEWLINE> import array <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> <NL> def ii ( ) : return int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> def il ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> def fl ( ) : return list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> def iln ( n ) : return [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> <INDENT> for _ in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> def iss ( ) : return sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> def sl ( ) : return list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> def isn ( n ) : return [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> <INDENT> for _ in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> def lcm ( x , y ) : return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> S = iss ( ) <NEWLINE> K = ii ( ) <NEWLINE> <NL> substring = set ( ) <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , i + K + 1 ) : <NEWLINE> <INDENT> substring . add ( S [ i : j ] ) <NEWLINE> <DEDENT> <DEDENT> ret = sorted ( list ( substring ) ) <NEWLINE> print ( ret [ K - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = { } <NEWLINE> for num , i in enumerate ( a ) : <NEWLINE> <INDENT> d [ num + 1 ] = i <NEWLINE> <DEDENT> t = { } <NEWLINE> t_ = { } <NEWLINE> i = 1 <NEWLINE> j = 0 <NEWLINE> while ( i not in t ) : <NEWLINE> <INDENT> t [ i ] = j <NEWLINE> t_ [ j ] = i <NEWLINE> i = d [ i ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> a = 1 <NEWLINE> b = t [ i ] <NEWLINE> if k < b + 1 : <NEWLINE> <INDENT> ans = t_ [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = ( k - b ) % ( len ( t . keys ( ) ) - b ) <NEWLINE> ans = t_ [ b + k ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ 0 ] * ( 100001 ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> L [ a ] += 1 <NEWLINE> <COMMENT> <NL> ans += a <NEWLINE> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> key = L [ B ] <NEWLINE> L [ C ] += key <NEWLINE> ans += key * ( C - B ) <NEWLINE> L [ B ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if ( a [ i ] < a [ i + k ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ 0 for _ in range ( k ) ] <NEWLINE> R = [ 0 for _ in range ( k ) ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> L [ i ] , R [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> mod = 998244353 <NEWLINE> <NL> dp = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> dp [ 1 ] = 1 <NEWLINE> cumsum = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> cumsum [ 1 ] = 1 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> li = i - R [ j ] <NEWLINE> ri = i - L [ j ] <NEWLINE> if ri < 0 : continue <NEWLINE> li = max ( li , 1 ) <NEWLINE> dp [ i ] += ( cumsum [ ri ] - cumsum [ li - 1 ] ) % mod <NEWLINE> <DEDENT> cumsum [ i ] = cumsum [ i - 1 ] + dp [ i ] <NEWLINE> <NL> <DEDENT> print ( dp [ n ] % mod ) <NEWLINE>
<COMMENT> <NL> lst = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> lst . append ( [ h , w ] ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for l in lst : <NEWLINE> <INDENT> H = l [ 0 ] <NEWLINE> W = l [ 1 ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if i == 0 or i == H - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if j == 0 or j == W - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if i == H - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = [ 0 ] * ( 10 ** 6 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i - A [ i ] >= 0 : <NEWLINE> <INDENT> L [ i - A [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tall = A [ i ] <NEWLINE> if tall + i < len ( L ) : <NEWLINE> <INDENT> ans += L [ tall + i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> import bisect <NEWLINE> <NL> def bin_search ( arr , ls , c ) : <NEWLINE> <INDENT> l = ls - 1 <NEWLINE> r = len ( arr ) <NEWLINE> while ( r - l ) > 1 : <NEWLINE> <INDENT> m = l + ( r - l ) // 2 <NEWLINE> if arr [ m ] >= c : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = m <NEWLINE> <DEDENT> <DEDENT> return l - ls + 1 <NEWLINE> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> readline = sys . stdin . readline <NEWLINE> n = int ( readline ( ) ) <NEWLINE> arr = list ( map ( int , readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> arr . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> c = arr [ i ] + arr [ j ] <NEWLINE> ans += ( bisect . bisect_left ( arr , c , j + 1 ) - j - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if <STRING> not in globals ( ) : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = m <NEWLINE> ans = 0 <NEWLINE> bit = [ - 1 for i in range ( m ) ] <NEWLINE> cycle = False <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> a = x <NEWLINE> bit [ a ] = i <NEWLINE> ans += a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = ( a ** 2 ) % mod <NEWLINE> if bit [ a ] != - 1 : <NEWLINE> <INDENT> cy_st = bit [ a ] <NEWLINE> cy_fi = i - 1 <NEWLINE> cycle = True <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bit [ a ] = i <NEWLINE> ans += a <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if cycle : <NEWLINE> <INDENT> ans2 = 0 <NEWLINE> b = - 1 <NEWLINE> for j in range ( cy_st ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> b = x <NEWLINE> ans2 += b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = ( b ** 2 ) % mod <NEWLINE> ans2 += b <NEWLINE> <DEDENT> <DEDENT> cy_num = ans - ans2 <NEWLINE> cy_repe = ( n - cy_st ) // ( cy_fi - cy_st + 1 ) <NEWLINE> ans3 = cy_num * cy_repe <NEWLINE> cy_amari = ( n - cy_st ) % ( cy_fi - cy_st + 1 ) <NEWLINE> <NL> if b == - 1 : <NEWLINE> <INDENT> for j in range ( cy_amari ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> b = x <NEWLINE> ans3 += b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = ( b ** 2 ) % mod <NEWLINE> ans3 += b <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( cy_amari ) : <NEWLINE> <INDENT> b = ( b ** 2 ) % mod <NEWLINE> ans3 += b <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans2 + ans3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
_ = input ( ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flag = True <NEWLINE> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( flag ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import re <NEWLINE> S = input ( ) <NEWLINE> string = re . findall ( <STRING> , S ) <NEWLINE> <NL> if len ( string ) != 0 : <NEWLINE> <INDENT> lenst = [ len ( x ) for x in string ] <NEWLINE> print ( max ( lenst ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
text = input ( ) <NEWLINE> string = input ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> len_string = len ( string ) <NEWLINE> common_length = [ 0 ] * len_string <NEWLINE> tmp = 0 <NEWLINE> tmp_tmp = 0 <NEWLINE> for i in range ( 1 , len_string ) : <NEWLINE> <INDENT> if ( string [ i ] == string [ tmp ] ) : <NEWLINE> <INDENT> tmp_tmp = tmp <NEWLINE> while ( string [ i ] == string [ tmp_tmp ] and tmp_tmp > 0 ) : <NEWLINE> <INDENT> tmp_tmp = common_length [ max ( [ tmp_tmp - 1 , 0 ] ) ] <NEWLINE> <DEDENT> common_length [ i - 1 ] = tmp_tmp <NEWLINE> tmp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> common_length [ i - 1 ] = tmp <NEWLINE> while ( string [ i ] != string [ tmp ] and tmp > 0 ) : <NEWLINE> <INDENT> tmp = common_length [ max ( [ tmp - 1 , 0 ] ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( string [ - 1 ] == string [ tmp - 1 ] ) : <NEWLINE> <INDENT> common_length [ - 1 ] = tmp <NEWLINE> <DEDENT> common_length [ 0 ] = 0 <NEWLINE> <NL> <NL> tmp = 0 <NEWLINE> <NL> for i in range ( len ( text ) ) : <NEWLINE> <INDENT> if ( text [ i ] != string [ tmp ] ) : <NEWLINE> <INDENT> while ( text [ i ] != string [ tmp ] and tmp > 0 ) : <NEWLINE> <INDENT> tmp = common_length [ max ( [ tmp - 1 , 0 ] ) ] <NEWLINE> <DEDENT> if ( text [ i ] == string [ tmp ] ) : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> if ( tmp == len_string ) : <NEWLINE> <INDENT> print ( i - tmp + 1 ) <NEWLINE> tmp = common_length [ - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from functools import reduce <NEWLINE> import math <NEWLINE> import sys <NEWLINE> <NL> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> <NL> n = I ( ) <NEWLINE> t = IR ( n ) <NEWLINE> <NL> <NL> def lcm_base ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // math . gcd ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> def lcm_list ( l ) : return reduce ( lcm_base , l , 1 ) <NEWLINE> <NL> <NL> ans = lcm_list ( t ) <NEWLINE> print ( ans ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> X = int ( input ( ) ) <NEWLINE> memo = { } <NEWLINE> for A in range ( 500 ) : <NEWLINE> <INDENT> for B in range ( 500 ) : <NEWLINE> <INDENT> memo [ A ** 5 - B ** 5 ] = ( A , B ) <NEWLINE> memo [ A ** 5 + B ** 5 ] = ( A , - B ) <NEWLINE> <DEDENT> <DEDENT> A , B = memo [ X ] <NEWLINE> print ( A , B ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = 1 <NEWLINE> a = 10 ** 18 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> t = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> t *= i <NEWLINE> if t > a : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if t > a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> def solve ( h , w , a ) : <NEWLINE> <INDENT> used = [ [ True ] * ( w + 2 ) for _ in range ( h + 2 ) ] <NEWLINE> que = deque ( ) <NEWLINE> for r in range ( h ) : <NEWLINE> <INDENT> used [ r + 1 ] [ 1 : - 1 ] = map ( lambda _ : _ == <STRING> , a [ r ] ) <NEWLINE> for c in range ( w ) : <NEWLINE> <INDENT> if a [ r ] [ c ] == <STRING> : <NEWLINE> <INDENT> que . append ( ( r + 1 , c + 1 , 0 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> neighbors = [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> while que : <NEWLINE> <INDENT> r , c , k = que . popleft ( ) <NEWLINE> for dr , dc in neighbors : <NEWLINE> <INDENT> nr , nc = r + dr , c + dc <NEWLINE> if not used [ nr ] [ nc ] : <NEWLINE> <INDENT> que . append ( ( nr , nc , k + 1 ) ) <NEWLINE> used [ nr ] [ nc ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return k <NEWLINE> <NL> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ input ( ) for _ in range ( h ) ] <NEWLINE> print ( solve ( h , w , a ) ) <NEWLINE>
import sys <NEWLINE> si = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( si ( ) ) <NEWLINE> l = [ int ( e ) for e in si ( ) . split ( ) ] <NEWLINE> tot = sum ( l ) <NEWLINE> mod , ans = 10 ** 9 + 7 , 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> h = l [ i ] <NEWLINE> tot -= h <NEWLINE> ans = ( ans + ( tot * h ) % mod ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from logging import * <NEWLINE> basicConfig ( level = DEBUG , format = <STRING> ) <NEWLINE> disable ( CRITICAL ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> debug ( <STRING> . format ( n ) ) <NEWLINE> debug ( <STRING> . format ( X ) ) <NEWLINE> po = X . count ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> pp = po + 1 <NEWLINE> pm = max ( 1 , po - 1 ) <NEWLINE> <NL> rp = 0 <NEWLINE> rm = 0 <NEWLINE> for x in X : <NEWLINE> <INDENT> rp = ( rp * 2 + int ( x ) ) % pp <NEWLINE> rm = ( rm * 2 + int ( x ) ) % pm <NEWLINE> <NL> <DEDENT> bp = [ 0 ] * ( n ) <COMMENT> <NEWLINE> bm = [ 0 ] * ( n ) <COMMENT> <NEWLINE> bp [ n - 1 ] = 1 % pp <NEWLINE> bm [ n - 1 ] = 1 % pm <NEWLINE> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> bp [ i - 1 ] = bp [ i ] * 2 % pp <NEWLINE> bm [ i - 1 ] = bm [ i ] * 2 % pm <NEWLINE> <NL> <DEDENT> debug ( <STRING> . format ( po ) ) <NEWLINE> debug ( <STRING> . format ( pp ) ) <NEWLINE> debug ( <STRING> . format ( pm ) ) <NEWLINE> debug ( <STRING> . format ( rp ) ) <NEWLINE> debug ( <STRING> . format ( rm ) ) <NEWLINE> debug ( <STRING> . format ( bp ) ) <NEWLINE> debug ( <STRING> . format ( bm ) ) <NEWLINE> debug ( <STRING> ) <NEWLINE> <NL> def popcount ( x ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> while x > 0 : <NEWLINE> <INDENT> if x & 1 : c += 1 <NEWLINE> x //= 2 <NEWLINE> <DEDENT> return c <NEWLINE> <NL> <DEDENT> def f ( x ) : <NEWLINE> <INDENT> if x == 0 : return 0 <NEWLINE> return f ( x % popcount ( x ) ) + 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> ri = ( rp + bp [ i ] ) % pp <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> if po - 1 != 0 : ri = ( rm - bm [ i ] ) % pm <NEWLINE> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> debug ( <STRING> . format ( i , ri ) ) <NEWLINE> c = f ( ri ) + 1 <NEWLINE> debug ( <STRING> . format ( c ) ) <NEWLINE> print ( c ) <NEWLINE> <NL> <DEDENT>
<NL> <NL> def dis_func ( x , y ) : <NEWLINE> <INDENT> dis = [ round ( 0 , 6 ) for i in range ( 4 ) ] <NEWLINE> for x , y in zip ( x , y ) : <NEWLINE> <INDENT> tmp = abs ( x - y ) <NEWLINE> dis [ 0 ] += tmp <NEWLINE> dis [ 1 ] += ( tmp ** 2 ) <NEWLINE> dis [ 2 ] += ( tmp ** 3 ) <NEWLINE> dis [ 3 ] = max ( dis [ 3 ] , tmp ) <NEWLINE> <NL> <DEDENT> dis [ 1 ] = dis [ 1 ] ** ( 1 / 2 ) <NEWLINE> dis [ 2 ] = dis [ 2 ] ** ( 1 / 3 ) <NEWLINE> print ( <STRING> . join ( list ( map ( str , dis ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dis_func ( x , y ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> i = 1 <NEWLINE> <NL> count = 0 <NEWLINE> limit = 100 <NEWLINE> <NL> nums = [ 0 ] * n <NEWLINE> <NL> for x in range ( limit ) : <NEWLINE> <INDENT> for y in range ( limit ) : <NEWLINE> <INDENT> for z in range ( limit ) : <NEWLINE> <INDENT> cal = ( x + 1 ) ** 2 + ( y + 1 ) ** 2 + ( z + 1 ) ** 2 + ( x + 1 ) * ( y + 1 ) + ( y + 1 ) * ( z + 1 ) + ( z + 1 ) * ( x + 1 ) <NEWLINE> if ( cal > n ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> nums [ cal - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for n in nums : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> return int ( ( A * ( x % B ) - ( A * x % B ) ) / B ) <NEWLINE> <DEDENT> if N >= B - 1 : <NEWLINE> <INDENT> print ( f ( B - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( f ( N ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> while 1 : <NEWLINE> <INDENT> e = int ( input ( ) . strip ( ) ) <NEWLINE> if e == 0 : break <NEWLINE> m = e <NEWLINE> z = 0 <NEWLINE> while z ** 3 <= e : <NEWLINE> <INDENT> y = int ( math . sqrt ( e - z ** 3 ) ) <NEWLINE> x = e - y ** 2 - z ** 3 <NEWLINE> if x < 0 : break <NEWLINE> if m > x + y + z : m = x + y + z <NEWLINE> z += 1 <NEWLINE> <DEDENT> print ( m ) <NEWLINE> <NL> <DEDENT>
import queue <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> adj = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> parent = [ - 1 ] * ( N + 1 ) <COMMENT> <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> adj [ a ] . append ( b ) <NEWLINE> adj [ b ] . append ( a ) <NEWLINE> <DEDENT> q = queue . Queue ( ) <COMMENT> <NEWLINE> q . put ( ( 1 , 0 ) ) <COMMENT> <NEWLINE> while ( not q . empty ( ) ) : <NEWLINE> <INDENT> x , p = q . get ( ) <NEWLINE> if parent [ x ] != - 1 : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> parent [ x ] = p <NEWLINE> for next in adj [ x ] : <NEWLINE> <INDENT> if parent [ next ] == - 1 : <COMMENT> <NEWLINE> <INDENT> q . put ( ( next , x ) ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <COMMENT> <NEWLINE> for p in parent [ 2 : ] : <COMMENT> <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = n <NEWLINE> <NL> i = 2 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> ans = ans // i * ( i - 1 ) <NEWLINE> while n % i == 0 : <NEWLINE> <INDENT> n //= i <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> if n != 1 : <NEWLINE> <INDENT> ans = ans // n * ( n - 1 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> w = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> w [ A ] . append ( B ) <NEWLINE> w [ B ] . append ( A ) <NEWLINE> <NL> <DEDENT> cnt = [ 0 ] * ( N + 1 ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> P , X = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ P ] += X <NEWLINE> <NL> <DEDENT> flag = [ False ] * ( N + 1 ) <NEWLINE> <NL> q = [ 1 ] <NEWLINE> while q : <NEWLINE> <INDENT> n = q . pop ( ) <NEWLINE> flag [ n ] = True <NEWLINE> for i in w [ n ] : <NEWLINE> <INDENT> if flag [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> flag [ i ] = True <NEWLINE> cnt [ i ] += cnt [ n ] <NEWLINE> q . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( c ) for c in cnt [ 1 : ] ] ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> def check ( s ) : <NEWLINE> <INDENT> if dict_x [ s [ 0 ] ] == 0 and dict_x [ s [ 1 ] ] == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif dict_x [ s [ 0 ] ] > 0 and dict_x [ s [ 1 ] ] == 0 : <NEWLINE> <INDENT> return s [ 1 ] <NEWLINE> <DEDENT> elif dict_x [ s [ 0 ] ] == 0 and dict_x [ s [ 1 ] ] > 0 : <NEWLINE> <INDENT> return s [ 0 ] <NEWLINE> <DEDENT> elif dict_x [ s [ 0 ] ] == 1 and dict_x [ s [ 1 ] ] == 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if dict_x [ s [ 0 ] ] > dict_x [ s [ 1 ] ] : <NEWLINE> <INDENT> return s [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return s [ 0 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> def update ( s , mozi ) : <NEWLINE> <INDENT> if s [ 1 ] == mozi : <NEWLINE> <INDENT> dict_x [ s [ 0 ] ] -= 1 <NEWLINE> dict_x [ s [ 1 ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict_x [ s [ 0 ] ] += 1 <NEWLINE> dict_x [ s [ 1 ] ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> dict_x = { <STRING> : a , <STRING> : b , <STRING> : c } <NEWLINE> s_list = [ ] <NEWLINE> ans_list = [ ] <NEWLINE> flag = 1 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> s_list . append ( s ) <NEWLINE> <DEDENT> if a + b + c == 0 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> elif a + b + c == 1 : <NEWLINE> <INDENT> for s in s_list : <NEWLINE> <INDENT> x = check ( s ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_list . append ( x ) <NEWLINE> update ( s , x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif a + b + c == 2 : <NEWLINE> <INDENT> i = 0 <NEWLINE> for s in s_list : <NEWLINE> <INDENT> x = check ( s ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> if i == len ( s_list ) - 1 : <NEWLINE> <INDENT> ans_list . append ( s [ 0 ] ) <NEWLINE> update ( s , x ) <NEWLINE> <DEDENT> elif s == s_list [ i + 1 ] : <NEWLINE> <INDENT> ans_list . append ( s [ 0 ] ) <NEWLINE> update ( s , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ 0 ] in s_list [ i + 1 ] : <NEWLINE> <INDENT> ans_list . append ( s [ 0 ] ) <NEWLINE> update ( s , s [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_list . append ( s [ 1 ] ) <NEWLINE> update ( s , s [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans_list . append ( x ) <NEWLINE> update ( s , x ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for s in s_list : <NEWLINE> <INDENT> x = check ( s ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> ans_list . append ( s [ 0 ] ) <NEWLINE> update ( s , s [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_list . append ( x ) <NEWLINE> update ( s , x ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for ans in ans_list : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> pre = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> p , y = map ( int , input ( ) . split ( ) ) <NEWLINE> pre [ p - 1 ] . append ( [ y , _ , p ] ) <NEWLINE> <DEDENT> for p in range ( n ) : <NEWLINE> <INDENT> pre [ p ] . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> for i in range ( len ( pre [ p ] ) ) : <NEWLINE> <INDENT> pre [ p ] [ i ] . append ( i ) <NEWLINE> <DEDENT> <DEDENT> lis = [ ] <NEWLINE> for i in pre : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> lis . append ( j ) <NEWLINE> <DEDENT> <DEDENT> lis . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> for i in lis : print ( <STRING> . format ( i [ 2 ] , i [ 3 ] + 1 ) ) <NEWLINE>
import sys <NEWLINE> import heapq <NEWLINE> <NL> <NL> input = sys . stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> result = n * ( n - 1 ) // 2 <NEWLINE> print ( result ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> ansma = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> if ans >= ansma : <NEWLINE> <INDENT> ansma = ans <NEWLINE> <DEDENT> <DEDENT> print ( ansma ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
nums = [ [ [ 0 for _ in range ( 10 ) ] for _ in range ( 3 ) ] for _ in range ( 4 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> nums [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> is_first = True <NEWLINE> for building in nums : <NEWLINE> <INDENT> if not is_first : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> is_first = False <NEWLINE> for floor in building : <NEWLINE> <INDENT> for room in floor : <NEWLINE> <INDENT> print ( <STRING> + str ( room ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT>
def f ( gx , gy ) : <NEWLINE> <INDENT> ans = 10 ** 9 <NEWLINE> no = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> tmp = abs ( gx - checkpoint [ i ] [ 0 ] ) + abs ( gy - checkpoint [ i ] [ 1 ] ) <NEWLINE> if tmp < ans : <NEWLINE> <INDENT> ans = tmp <NEWLINE> no = i <NEWLINE> <DEDENT> <DEDENT> return no + 1 <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> gakusei = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> gakusei . append ( [ x , y ] ) <NEWLINE> <DEDENT> checkpoint = [ ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> checkpoint . append ( [ x , y ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( f ( gakusei [ i ] [ 0 ] , gakusei [ i ] [ 1 ] ) ) <NEWLINE> <NL> <DEDENT>
from sys import stdin <NEWLINE> from sys import setrecursionlimit <NEWLINE> import numpy as np <NEWLINE> import math <NEWLINE> <NL> setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> n , k = map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> a = np . array ( a , dtype = np . int64 ) <NEWLINE> <NL> low = 0 <NEWLINE> hi = 10 ** 9 <NEWLINE> point = 0 <NEWLINE> <NL> while point <= 100 : <NEWLINE> <INDENT> ave = ( hi + low ) / 2 <NEWLINE> if np . ceil ( a // ave ) . sum ( ) <= k : <NEWLINE> <INDENT> hi = ave <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = ave <NEWLINE> <DEDENT> point += 1 <NEWLINE> <NL> <DEDENT> print ( math . ceil ( ave ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> M = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if M < ans : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> L . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( set ( L ) ) ) <NEWLINE>
a1 , b1 , a2 , b2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 2000000000 ) <NEWLINE> <NL> p = 10 ** 9 + 7 <NEWLINE> N = a2 + b2 + 2 <COMMENT> <NEWLINE> R = max ( a2 + 1 , b2 + 1 ) <NEWLINE> fact = [ 1 , 1 ] <COMMENT> <NEWLINE> factinv = [ 1 , 1 ] <COMMENT> <NEWLINE> inv = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % p ) <NEWLINE> <NL> <DEDENT> for i in range ( 2 , R + 1 ) : <NEWLINE> <INDENT> inv . append ( ( - inv [ p % i ] * ( p // i ) ) % p ) <NEWLINE> factinv . append ( ( factinv [ - 1 ] * inv [ - 1 ] ) % p ) <NEWLINE> <NL> <DEDENT> def comb ( n , r , p ) : <NEWLINE> <INDENT> if ( r < 0 ) or ( n < r ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return fact [ n ] * factinv [ r ] * factinv [ n - r ] % p <NEWLINE> <NL> <DEDENT> score = comb ( a2 + b2 + 2 , a2 + 1 , p ) - comb ( a2 + b1 + 1 , a2 + 1 , p ) - comb ( a1 + b2 + 1 , a1 , p ) + comb ( a1 + b1 , a1 , p ) <NEWLINE> print ( score % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from functools import lru_cache <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> sr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> ir = lambda : int ( sr ( ) ) <NEWLINE> lr = lambda : list ( map ( int , sr ( ) . split ( ) ) ) <NEWLINE> <NL> N = ir ( ) <NEWLINE> A = lr ( ) <NEWLINE> INF = 10 ** 17 <NEWLINE> <NL> @ lru_cache ( None ) <NEWLINE> def F ( index , n ) : <NEWLINE> <INDENT> if index >= N : <NEWLINE> <INDENT> return - INF <NEWLINE> <DEDENT> if N - index < 2 * n - 1 : <NEWLINE> <INDENT> return - INF <NEWLINE> <DEDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> return max ( A [ index : ] ) <NEWLINE> <DEDENT> ret = max ( A [ index ] + F ( index + 2 , n - 1 ) , F ( index + 1 , n ) ) <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> answer = F ( 0 , N // 2 ) <NEWLINE> print ( answer ) <NEWLINE>
n = int ( input ( ) . rstrip ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> mod = 1_000_000_007 <NEWLINE> ans = 0 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> tmp = ( tmp + a [ i ] ) % mod <NEWLINE> ans += ( tmp * a [ i - 1 ] ) % mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> R = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> import sys <NEWLINE> listH = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> listH . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> listH [ R [ i ] [ 0 ] - 1 ] += 1 <NEWLINE> <DEDENT> maxH = 0 <NEWLINE> listHmax = [ ] <NEWLINE> jH = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> if listH [ i ] > maxH : <NEWLINE> <INDENT> maxH = listH [ i ] <NEWLINE> listHmax = [ ] <NEWLINE> listHmax . append ( i ) <NEWLINE> jH = 1 <NEWLINE> <DEDENT> elif listH [ i ] == maxH : <NEWLINE> <INDENT> listHmax . append ( i ) <NEWLINE> jH += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> listW = [ ] <NEWLINE> for i in range ( W ) : <NEWLINE> <INDENT> listW . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> listW [ R [ i ] [ 1 ] - 1 ] += 1 <NEWLINE> <DEDENT> maxW = 0 <NEWLINE> listWmax = [ ] <NEWLINE> jW = 0 <NEWLINE> for i in range ( W ) : <NEWLINE> <INDENT> if listW [ i ] > maxW : <NEWLINE> <INDENT> maxW = listW [ i ] <NEWLINE> listWmax = [ ] <NEWLINE> listWmax . append ( i ) <NEWLINE> jW = 1 <NEWLINE> <DEDENT> elif listW [ i ] == maxW : <NEWLINE> <INDENT> listWmax . append ( i ) <NEWLINE> jW += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> T = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if ( listH [ R [ i ] [ 0 ] - 1 ] == maxH and listW [ R [ i ] [ 1 ] - 1 ] == maxW ) : <NEWLINE> <INDENT> T += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if T == jH * jW : <NEWLINE> <INDENT> print ( maxH + maxW - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( maxH + maxW ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> sr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> ir = lambda : int ( sr ( ) ) <NEWLINE> lr = lambda : list ( map ( int , sr ( ) . split ( ) ) ) <NEWLINE> <NL> N = ir ( ) <NEWLINE> A = np . array ( lr ( ) , dtype = np . int32 ) <NEWLINE> counter = np . bincount ( A ) <NEWLINE> case = ( counter * ( counter - 1 ) // 2 ) . sum ( ) <NEWLINE> answer = case - ( counter [ A ] - 1 ) <NEWLINE> print ( <STRING> . join ( map ( str , answer ) ) ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> a = [ 0 ] * 100001 <NEWLINE> for i in A : <NEWLINE> <INDENT> a [ i ] += i <NEWLINE> <NL> <DEDENT> ans = sum ( a ) <NEWLINE> for b , c in BC : <NEWLINE> <INDENT> if a [ b ] == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> continue <NEWLINE> <DEDENT> move = a [ b ] // b <NEWLINE> a [ b ] = 0 <NEWLINE> a [ c ] += c * move <NEWLINE> ans += ( c - b ) * move <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( 1 + math . ceil ( ( B - A ) / ( A - 1 ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> dp = [ [ 0 for j in range ( 3 ) ] for i in range ( n // 2 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = a [ 0 ] <NEWLINE> dp [ 0 ] [ 1 ] = a [ 1 ] <NEWLINE> dp [ 0 ] [ 2 ] = a [ 2 ] <NEWLINE> for i in range ( n // 2 - 1 ) : <NEWLINE> <INDENT> dp [ i + 1 ] [ 0 ] = ( dp [ i ] [ 0 ] + a [ 2 * ( i + 1 ) ] ) <NEWLINE> dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] ) + a [ 2 * ( i + 1 ) + 1 ] <NEWLINE> dp [ i + 1 ] [ 2 ] = max ( dp [ i ] ) + a [ 2 * ( i + 1 ) + 2 ] <NEWLINE> <DEDENT> print ( max ( dp [ - 1 ] ) ) <NEWLINE> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> dp = [ [ 0 for j in range ( 2 ) ] for i in range ( n // 2 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = a [ 0 ] <NEWLINE> dp [ 0 ] [ 1 ] = a [ 1 ] <NEWLINE> for i in range ( n // 2 - 1 ) : <NEWLINE> <INDENT> dp [ i + 1 ] [ 0 ] = ( dp [ i ] [ 0 ] + a [ 2 * ( i + 1 ) ] ) <NEWLINE> dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] ) + a [ 2 * ( i + 1 ) + 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> print ( max ( dp [ - 1 ] ) ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for a in range ( - int ( x ** 0.3 ) , int ( x ** 0.3 ) + 1 ) : <NEWLINE> <INDENT> for b in range ( - int ( x ** 0.3 ) , int ( x ** 0.3 ) + 1 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> <NL> S = input ( ) <NEWLINE> N , P = len ( S ) , 2019 <NEWLINE> <NL> if P == 2 or P == 5 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if int ( S [ i ] ) % P == 0 : <NEWLINE> <INDENT> ans += i + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> num = [ 0 ] * P <NEWLINE> num [ 0 ] = 1 <NEWLINE> now , ans = 0 , 0 <NEWLINE> _10 = 1 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> now = ( now + int ( S [ i ] ) * _10 ) % P <NEWLINE> _10 *= 10 <NEWLINE> _10 %= P <NEWLINE> ans += num [ now ] <NEWLINE> num [ now ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<NL> <NL> import itertools <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> lis = list ( itertools . combinations_with_replacement ( range ( 1 , K + 1 ) , 3 ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i , j , k in lis : <NEWLINE> <INDENT> if i == j and j == k and i == k : <NEWLINE> <INDENT> ans += gcd ( i , j , k ) <NEWLINE> <DEDENT> elif i != j and j != k and i != k : <NEWLINE> <INDENT> ans += 6 * gcd ( i , j , k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 3 * gcd ( i , j , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += a [ n - i // 2 - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> def f ( myList ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> if len ( myList ) % 2 == 0 : <NEWLINE> <INDENT> for i in range ( len ( myList ) ) : <NEWLINE> <INDENT> ans += str ( myList [ i ] ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( myList ) ) : <NEWLINE> <INDENT> ans += str ( myList [ - ( i + 1 ) ] ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> return ans [ : - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = collections . deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . appendleft ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( f ( b ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] * ( N + 1 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> B [ i ] += 1 <NEWLINE> <DEDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( B [ j ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> res = 0 <NEWLINE> if k - a >= 0 : <NEWLINE> <INDENT> res += a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += k <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if k - a - b > 0 : <NEWLINE> <INDENT> res += ( k - a - b ) * - 1 <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
wt = str ( input ( ) ) <NEWLINE> if wt == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif wt == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> id = wt . index ( <STRING> ) <NEWLINE> if wt . count ( <STRING> ) == 2 and wt [ id ] == wt [ id + 1 ] == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> c [ i - 1 ] += 1 <NEWLINE> <DEDENT> [ print ( i ) for i in c ] <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * ( n ) <NEWLINE> for i in a : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> for j in ans : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> u , v , w = [ 0 ] * ( N - 1 ) , [ 0 ] * ( N - 1 ) , [ 0 ] * ( N - 1 ) <NEWLINE> n = [ - 1 ] * N <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> n [ i ] = [ 0 ] * 4 <NEWLINE> n [ i ] [ 1 ] = [ ] <NEWLINE> n [ i ] [ 2 ] = [ ] <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u [ i ] , v [ i ] , w [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n [ u [ i ] - 1 ] [ 1 ] . append ( v [ i ] - 1 ) <NEWLINE> n [ v [ i ] - 1 ] [ 1 ] . append ( u [ i ] - 1 ) <NEWLINE> n [ u [ i ] - 1 ] [ 2 ] . append ( w [ i ] % 2 ) <NEWLINE> n [ v [ i ] - 1 ] [ 2 ] . append ( w [ i ] % 2 ) <NEWLINE> <NL> <DEDENT> stack = [ u [ 0 ] - 1 ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> num = stack . pop ( ) <NEWLINE> n [ num ] [ 3 ] = 1 <NEWLINE> for i in range ( len ( n [ num ] [ 1 ] ) ) : <NEWLINE> <INDENT> if n [ n [ num ] [ 1 ] [ i ] ] [ 3 ] == 0 : <NEWLINE> <INDENT> stack . append ( n [ num ] [ 1 ] [ i ] ) <NEWLINE> if n [ num ] [ 2 ] [ i ] == 0 : <NEWLINE> <INDENT> n [ n [ num ] [ 1 ] [ i ] ] [ 0 ] = n [ num ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n [ n [ num ] [ 1 ] [ i ] ] [ 0 ] = - 1 * n [ num ] [ 0 ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( stack ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in n : <NEWLINE> <INDENT> print ( i [ 0 ] ) <NEWLINE> <DEDENT>
import copy <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> U = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> U [ i ] = ( P [ i ] + 1 ) / 2 <NEWLINE> <NL> <DEDENT> ans = sum ( U [ : k ] ) <NEWLINE> t = copy . copy ( ans ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> t = t + U [ k + i ] - U [ i ] <NEWLINE> ans = max ( ans , t ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> mod_bucket = [ 0 ] * 2019 <NEWLINE> mod_bucket [ 0 ] += 1 <NEWLINE> <NL> _S = S [ : : - 1 ] <NEWLINE> mod = 0 <NEWLINE> p = 1 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> mod = ( p * int ( _S [ i ] ) + mod ) % 2019 <NEWLINE> mod_bucket [ mod ] += 1 <NEWLINE> p *= 10 <NEWLINE> p %= 2019 <NEWLINE> <NL> <DEDENT> ans = sum ( [ mod * ( mod - 1 ) / 2 for mod in mod_bucket ] ) <NEWLINE> print ( int ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> for i in a [ - 1 : : - 2 ] : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> for i in a [ ( n % 2 == 1 ) : : 2 ] : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> print ( * b ) <NEWLINE>
from math import gcd <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( set ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> a . sort ( ) ; b = a [ 0 ] <NEWLINE> for i in range ( 1 , len ( a ) ) : b = gcd ( b , a [ i ] ) <NEWLINE> if len ( a ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) if k == a [ 0 ] else print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) if k <= a [ - 1 ] and k % b == 0 else print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , K , L = map ( int , input ( ) . split ( ) ) <NEWLINE> uf_road = UnionFind ( N ) <NEWLINE> uf_train = UnionFind ( N ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> p -= 1 <NEWLINE> q -= 1 <NEWLINE> uf_road . union ( p , q ) <NEWLINE> <NL> <DEDENT> for i in range ( L ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> p -= 1 <NEWLINE> q -= 1 <NEWLINE> uf_train . union ( p , q ) <NEWLINE> <NL> <DEDENT> pair_list = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> pair_list . append ( ( uf_road . find ( i ) , uf_train . find ( i ) , i ) ) <NEWLINE> <NL> <DEDENT> pair_list . sort ( ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> <NL> pair = ( pair_list [ 0 ] [ 0 ] , pair_list [ 0 ] [ 1 ] ) <NEWLINE> countup_list = [ pair_list [ 0 ] [ 2 ] ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if pair == ( pair_list [ i ] [ 0 ] , pair_list [ i ] [ 1 ] ) : <NEWLINE> <INDENT> countup_list . append ( pair_list [ i ] [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for c in countup_list : <NEWLINE> <INDENT> ans [ c ] += len ( countup_list ) <NEWLINE> <DEDENT> pair = ( pair_list [ i ] [ 0 ] , pair_list [ i ] [ 1 ] ) <NEWLINE> countup_list = [ pair_list [ i ] [ 2 ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> for c in countup_list : <NEWLINE> <INDENT> ans [ c ] += len ( countup_list ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = a_list [ 0 ] <NEWLINE> count = a_list . count ( 0 ) <NEWLINE> <NL> if count == 0 : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans *= a_list [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if ( a [ i ] > a [ i - k ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> num = ( int ) ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> <NL> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> sub = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> total += math . gcd ( sub , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> % ( r * r * math . pi , 2 * r * math . pi ) ) <NEWLINE>
R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <STRING> <NEWLINE> <NL> count = 0 <NEWLINE> for r in range ( N // R + 1 ) : <NEWLINE> <INDENT> rest = N - r * R <NEWLINE> for g in range ( rest // G + 1 ) : <NEWLINE> <INDENT> n_b = ( rest - g * G ) <NEWLINE> if n_b % B == 0 and n_b >= 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = list ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] / A [ i - K ] > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
S = list ( input ( ) ) <NEWLINE> cntb = 0 <NEWLINE> cntw = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> cntb += 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> cntw += cntb <NEWLINE> <DEDENT> <DEDENT> print ( cntw ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if K <= 200000 : <NEWLINE> <INDENT> i = 1 <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> i = A [ i - 1 ] <NEWLINE> <DEDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> visited = { 1 } <NEWLINE> order = [ 1 ] <NEWLINE> <NL> i = 1 <NEWLINE> for count in range ( 1 , 200001 ) : <NEWLINE> <INDENT> i = A [ i - 1 ] <NEWLINE> if i in visited : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited . add ( i ) <NEWLINE> <DEDENT> order . append ( i ) <NEWLINE> <NL> <DEDENT> idx = order . index ( i ) <NEWLINE> order2 = order [ idx : ] <NEWLINE> <COMMENT> <NL> mod = ( K + 1 - idx ) % len ( order2 ) <NEWLINE> <NL> print ( order2 [ mod - 1 ] ) <NEWLINE>
from collections import Counter <NEWLINE> import math <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> li = [ ] <NEWLINE> zcnt = 0 <NEWLINE> az , bz = 0 , 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A == 0 and B == 0 : <NEWLINE> <INDENT> zcnt += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if A != 0 and B == 0 : <NEWLINE> <INDENT> bz += 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif A == 0 and B != 0 : <NEWLINE> <INDENT> az += 1 <NEWLINE> continue <NEWLINE> <DEDENT> g = math . gcd ( A , B ) <NEWLINE> if A < 0 and B < 0 : <NEWLINE> <INDENT> li . append ( ( - ( A // g ) , - ( B // g ) ) ) <NEWLINE> <DEDENT> elif A < 0 and B > 0 : <NEWLINE> <INDENT> li . append ( ( - ( A // g ) , - ( B // g ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li . append ( ( A // g , B // g ) ) <NEWLINE> <DEDENT> <DEDENT> c = Counter ( li ) <NEWLINE> dic = { } <NEWLINE> ans = ( pow ( 2 , az , MOD ) + pow ( 2 , bz , MOD ) - 1 + MOD ) % MOD <NEWLINE> for a , b in c . keys ( ) : <NEWLINE> <INDENT> if ( a , b ) in dic : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> l , r = ( - b , a ) , ( b , - a ) <NEWLINE> s = c . get ( l , 0 ) + c . get ( r , 0 ) <NEWLINE> dic [ l ] , dic [ r ] = 1 , 1 <NEWLINE> res = ( pow ( 2 , c [ ( a , b ) ] , MOD ) + pow ( 2 , s , MOD ) - 1 + MOD ) % MOD <NEWLINE> ans = ( ans * res ) % MOD <NEWLINE> <DEDENT> print ( ( ans - 1 + zcnt ) % MOD ) <NEWLINE>
import sys <NEWLINE> num = input ( ) . split ( ) <NEWLINE> num . sort ( ) <NEWLINE> for i in range ( len ( num ) - 1 ) : <NEWLINE> <INDENT> sys . stdout . write ( num [ i ] + <STRING> ) <NEWLINE> <DEDENT> print ( num [ 2 ] ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> def ii ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def mi ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def li2 ( N ) : return [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> def dp2 ( ini , i , j ) : return [ [ ini ] * i for i2 in range ( j ) ] <NEWLINE> def dp3 ( ini , i , j , k ) : return [ [ [ ini ] * i for i2 in range ( j ) ] for i3 in range ( k ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = ii ( ) <NEWLINE> A = li ( ) <NEWLINE> ans = 1 <NEWLINE> for num in A : <NEWLINE> <INDENT> ans *= num <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
myset = set ( ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> myset . add ( x ) <NEWLINE> <NL> <DEDENT> print ( len ( myset ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> count [ i - 1 ] += 1 <NEWLINE> <DEDENT> for j in count : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> d = ( 10 ** 5 + 100 ) * [ 0 ] <NEWLINE> res = sum ( A ) <NEWLINE> for x in A : <NEWLINE> <INDENT> d [ x ] += 1 <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> res += d [ b ] * ( c - b ) <NEWLINE> d [ c ] += d [ b ] <NEWLINE> d [ b ] = 0 <NEWLINE> print ( res ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> dice_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max , s = 0 , 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> s += ( dice_list [ i ] + 1 ) / 2 <NEWLINE> <NL> <DEDENT> max = s <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> s -= ( dice_list [ i ] + 1 ) / 2 <NEWLINE> s += ( dice_list [ i + K ] + 1 ) / 2 <NEWLINE> if s > max : <NEWLINE> <INDENT> max = s <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import queue <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> q = queue . Queue ( ) <NEWLINE> q . put ( 1 ) <NEWLINE> <NL> import sys <NEWLINE> s = sys . stdin . readlines ( ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for e in s : <NEWLINE> <INDENT> a , b = map ( int , e . split ( ) ) <NEWLINE> G [ a - 1 ] . append ( b ) <NEWLINE> G [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> <NL> while c != N - 1 : <NEWLINE> <INDENT> r = q . get ( ) <NEWLINE> for i in G [ r - 1 ] : <NEWLINE> <INDENT> if ans [ i - 1 ] == 0 and i != 1 : <NEWLINE> <INDENT> ans [ i - 1 ] = r <NEWLINE> q . put ( i ) <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> tower = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> road = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for i in range ( m ) ] <NEWLINE> kosuu = [ 0 for i in range ( n ) ] <NEWLINE> temp = [ 0 for i in range ( n ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> kosuu [ road [ i ] [ 0 ] - 1 ] += 1 <NEWLINE> kosuu [ road [ i ] [ 1 ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if tower [ road [ i ] [ 0 ] - 1 ] > tower [ road [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> temp [ road [ i ] [ 0 ] - 1 ] += 1 <NEWLINE> <DEDENT> elif tower [ road [ i ] [ 0 ] - 1 ] < tower [ road [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> temp [ road [ i ] [ 1 ] - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if kosuu [ i ] == temp [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> for a in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for b in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
S = list ( input ( ) ) <NEWLINE> <NL> MOD = 2019 <NEWLINE> S . reverse ( ) <NEWLINE> cnt = 1 <NEWLINE> temp = 0 <NEWLINE> ans = [ 0 ] * 2019 <NEWLINE> for i in S : <NEWLINE> <INDENT> temp += int ( i ) * cnt % MOD <NEWLINE> temp %= MOD <NEWLINE> ans [ temp ] += 1 <NEWLINE> cnt *= 10 <NEWLINE> cnt %= MOD <NEWLINE> <NL> <DEDENT> ans [ 0 ] += 1 <NEWLINE> <NL> ans2 = 0 <NEWLINE> for i in ans : <NEWLINE> <INDENT> ans2 += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans2 ) <NEWLINE>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> c = [ ] <NEWLINE> count = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> c . append ( count ) <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if l == 1 : <NEWLINE> <INDENT> print ( c [ r - 2 ] - 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c [ r - 2 ] - c [ l - 2 ] ) <NEWLINE> <DEDENT> <DEDENT>
def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> banpei = 1000000001 <NEWLINE> L = A [ left : mid ] <NEWLINE> l = len ( L ) <NEWLINE> L += [ banpei ] <NEWLINE> R = A [ mid : right ] + [ banpei ] <NEWLINE> <NL> i , j = 0 , 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> count += l - i <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <NL> <DEDENT> def merge_Sort ( A , left , right ) : <NEWLINE> <INDENT> if 1 < right - left : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_Sort ( A , left , mid ) <NEWLINE> merge_Sort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> merge_Sort ( A , 0 , n ) <NEWLINE> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> <NL> for x in range ( 1 , 100 + 1 ) : <NEWLINE> <INDENT> if x ** 2 > n - 2 * x - 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for y in range ( 1 , 100 + 1 ) : <NEWLINE> <INDENT> if x ** 2 + y ** 2 > n - x - y - x * y : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for z in range ( 1 , 100 + 1 ) : <NEWLINE> <INDENT> f = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if f > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans [ f ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
A , B , C , D , E , F = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> water = set ( ) <NEWLINE> for a in range ( 0 , F , 100 * A ) : <NEWLINE> <INDENT> for b in range ( 0 , F , 100 * B ) : <NEWLINE> <INDENT> if a + b <= F : <NEWLINE> <INDENT> water . add ( a + b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> sugars = set ( ) <NEWLINE> for c in range ( 0 , F , C ) : <NEWLINE> <INDENT> for d in range ( 0 , F , D ) : <NEWLINE> <INDENT> if c + d <= F : <NEWLINE> <INDENT> sugars . add ( c + d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> density = 0 <NEWLINE> sugar = 0 <NEWLINE> content = 100 * A <NEWLINE> for x in water : <NEWLINE> <INDENT> for y in sugars : <NEWLINE> <INDENT> if x + y != 0 and x + y <= F and E * x >= 100 * y and density < y / ( x + y ) : <NEWLINE> <INDENT> density = y / ( x + y ) <NEWLINE> sugar = y <NEWLINE> content = x + y <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( content , sugar ) <NEWLINE>
s = input ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> front = True <NEWLINE> f = <STRING> <NEWLINE> b = <STRING> <NEWLINE> <NL> for q in a : <NEWLINE> <INDENT> if q == <STRING> : front = not front ; continue <NEWLINE> l = q . split ( ) <NEWLINE> if l [ 1 ] == <STRING> : <NEWLINE> <INDENT> if front : f = l [ 2 ] + f <NEWLINE> else : b = b + l [ 2 ] <NEWLINE> <DEDENT> if l [ 1 ] == <STRING> : <NEWLINE> <INDENT> if front : b = b + l [ 2 ] <NEWLINE> else : f = l [ 2 ] + f <NEWLINE> <NL> <DEDENT> <DEDENT> print ( f + s + b if front else ( f + s + b ) [ : : - 1 ] ) <NEWLINE>
s = input ( ) <NEWLINE> p = int ( s ) <NEWLINE> <NL> x = 1 <NEWLINE> <NL> numbers = [ ] <NEWLINE> <NL> while ( x <= p ) : <NEWLINE> <INDENT> x *= 2 <NEWLINE> numbers . append ( x ) <NEWLINE> <NL> <DEDENT> if p == 1 : <NEWLINE> <INDENT> answer = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = numbers . pop ( ) <NEWLINE> answer = numbers . pop ( ) <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE> <NL> <NL>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> bomb = set ( ) <NEWLINE> row = [ 0 ] * H <NEWLINE> column = [ 0 ] * W <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> h -= 1 <NEWLINE> w -= 1 <NEWLINE> <NL> bomb . add ( ( h , w ) ) <NEWLINE> <NL> row [ h ] += 1 <NEWLINE> column [ w ] += 1 <NEWLINE> <NL> <DEDENT> row_max = max ( row ) <NEWLINE> col_max = max ( column ) <NEWLINE> <NL> r_check = [ ] <NEWLINE> c_check = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> if row [ i ] == row_max : <NEWLINE> <INDENT> r_check . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( W ) : <NEWLINE> <INDENT> if column [ i ] == col_max : <NEWLINE> <INDENT> c_check . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> num = len ( r_check ) * len ( c_check ) <NEWLINE> <NL> ans = row_max + col_max - 1 <NEWLINE> flg = False <NEWLINE> if M < num : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for r in r_check : <NEWLINE> <INDENT> if flg : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for c in c_check : <NEWLINE> <INDENT> if not ( r , c ) in bomb : <NEWLINE> <INDENT> ans += 1 <NEWLINE> flg = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 2019 <NEWLINE> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> if i % 2019 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( l , r + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , r + 1 ) : <NEWLINE> <INDENT> if c > ( j * k % 2019 ) : <NEWLINE> <INDENT> c = ( j * k % 2019 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import numpy <NEWLINE> <NL> rl = sys . stdin . readline <NEWLINE> <NL> n , m = map ( int , rl ( ) . split ( ) ) <NEWLINE> li = [ [ ] for _ in range ( m + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , rl ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> li [ a ] . append ( b ) <NEWLINE> li [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> marks = [ - 1 ] * n <NEWLINE> stack = [ 0 ] <NEWLINE> while stack : <NEWLINE> <INDENT> for next_room in li [ stack [ 0 ] ] : <NEWLINE> <INDENT> if marks [ next_room ] == - 1 : <NEWLINE> <INDENT> stack . append ( next_room ) <NEWLINE> marks [ next_room ] = stack [ 0 ] <NEWLINE> <DEDENT> <DEDENT> del stack [ 0 ] <NEWLINE> <DEDENT> if - 1 in marks : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in marks [ 1 : ] : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a . add ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if 1 not in a : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> dp [ i ] += dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> dp [ i ] = dp [ i ] % 1000000007 <NEWLINE> <DEDENT> print ( dp [ n ] ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def dfs ( v ) : <NEWLINE> <INDENT> global visited <NEWLINE> visited [ v ] = True <NEWLINE> for nv in graph [ v ] : <NEWLINE> <INDENT> if nv in graph [ v ] : <NEWLINE> <INDENT> if not visited [ nv ] : <NEWLINE> <INDENT> dfs ( nv ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> visited = [ False ] * N <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> graph [ A ] . append ( B ) <NEWLINE> graph [ B ] . append ( A ) <NEWLINE> <DEDENT> ans = - 1 <NEWLINE> for v in range ( N ) : <NEWLINE> <INDENT> if not visited [ v ] : <NEWLINE> <INDENT> dfs ( v ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
def search ( l , n ) : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = len ( l ) <NEWLINE> m = ( left + right ) // 2 <NEWLINE> <NL> <COMMENT> <NL> while left < right : <NEWLINE> <INDENT> if n == l [ m ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif n < l [ m ] : <NEWLINE> <INDENT> right = m <NEWLINE> <DEDENT> elif n > l [ m ] : <NEWLINE> <INDENT> left = m + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( ) <NEWLINE> <NL> <DEDENT> m = ( left + right ) // 2 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> s = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> t = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for ti in t : <NEWLINE> <INDENT> if search ( s , ti ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> alphabets = [ None ] + [ chr ( ord ( <STRING> ) + x ) for x in range ( 26 ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> cnt = 0 <NEWLINE> m = n <NEWLINE> while m > 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> m -= 26 ** cnt <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> num = [ ] <NEWLINE> for i in range ( cnt ) : <NEWLINE> <COMMENT> <NL> <INDENT> y = n % ( 26 ** ( i + 1 ) ) <NEWLINE> <COMMENT> <NL> if y == 0 : <NEWLINE> <INDENT> num += [ 26 ] <NEWLINE> n -= 26 ** ( i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n -= y <NEWLINE> num += [ y // ( 26 ** i ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> for s in num [ : : - 1 ] : <NEWLINE> <INDENT> ans += alphabets [ s ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = 1 <NEWLINE> buf = [ ] <NEWLINE> if n < b : <NEWLINE> <INDENT> buf . append ( int ( a * n / b ) - a * ( int ( n / b ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> buf . append ( int ( a * ( b - 1 ) / b ) - a * ( int ( ( b - 1 ) / b ) ) ) <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> if n / b > 10 ** 6 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x = cnt * b - 1 <NEWLINE> if n < x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> calc = int ( a * x / b ) - a * ( int ( x / b ) ) <NEWLINE> if calc > max ( buf ) : <NEWLINE> <INDENT> buf . append ( calc ) <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> if n / b > 10 ** 6 and n >= b : <NEWLINE> <INDENT> buf . append ( int ( a * ( b - 1 ) / b ) - a * ( int ( ( b - 1 ) / b ) ) ) <NEWLINE> <NL> <DEDENT> ans = max ( buf ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> <NL> if a [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> m = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > m : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> set_list = set ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> set_list . add ( S ) <NEWLINE> <NL> <DEDENT> print ( len ( set_list ) ) <NEWLINE>
import sys <NEWLINE> S = <STRING> . join ( sorted ( input ( ) ) ) <NEWLINE> T = <STRING> . join ( sorted ( <STRING> . join ( sorted ( input ( ) ) ) , reverse = True ) ) <NEWLINE> print ( <STRING> if S < T else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> mn = p [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if mn > p [ i ] : <NEWLINE> <INDENT> mn = p [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 + 10 ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = set ( [ int ( input ( ) ) for _ in range ( M ) ] ) <NEWLINE> MOD = 1000000007 <NEWLINE> memo = { } <NEWLINE> def Fib ( n , MOD ) : <NEWLINE> <INDENT> if n in A : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif n in memo : <NEWLINE> <INDENT> return memo [ n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memo [ n ] = ( Fib ( n - 1 , MOD ) + Fib ( n - 2 , MOD ) ) % MOD <NEWLINE> return memo [ n ] <NEWLINE> <DEDENT> <DEDENT> print ( Fib ( N , MOD ) ) <NEWLINE>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> road = [ [ ] for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> road [ a - 1 ] . append ( b ) <NEWLINE> road [ b - 1 ] . append ( a ) <NEWLINE> <DEDENT> from collections import deque <NEWLINE> q = deque ( [ 1 ] ) <NEWLINE> check = [ 0 for i in range ( n ) ] <NEWLINE> check [ 0 ] = 1 <NEWLINE> ans = [ 0 for i in range ( n ) ] <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> p = q . popleft ( ) <NEWLINE> for i in range ( len ( road [ p - 1 ] ) ) : <NEWLINE> <INDENT> if check [ road [ p - 1 ] [ i ] - 1 ] == 0 : <NEWLINE> <INDENT> q . append ( road [ p - 1 ] [ i ] ) <NEWLINE> check [ road [ p - 1 ] [ i ] - 1 ] = 1 <NEWLINE> ans [ road [ p - 1 ] [ i ] - 1 ] = p <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT>
from itertools import product <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> nums = [ 0 ] * ( n + 1 ) <NEWLINE> for i in product ( range ( 1 , int ( n ** 0.5 ) + 1 ) , repeat = 3 ) : <NEWLINE> <INDENT> t = i [ 0 ] ** 2 + i [ 1 ] ** 2 + i [ 2 ] ** 2 + i [ 0 ] * i [ 1 ] + i [ 1 ] * i [ 2 ] + i [ 0 ] * i [ 2 ] <NEWLINE> if t <= n : nums [ t ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : print ( nums [ i ] ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> ii = s . find ( str ( i ) ) <NEWLINE> if ii == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> jj = s [ ii + 1 : ] . find ( str ( j ) ) <NEWLINE> if jj == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> jj += ii + 1 <NEWLINE> kk = s [ jj + 1 : ] . find ( str ( k ) ) <NEWLINE> if kk == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
q = int ( input ( ) ) <NEWLINE> <NL> def lcss ( x , y ) : <NEWLINE> <NL> <INDENT> lcs = [ 0 ] * ( len ( x ) + 1 ) <NEWLINE> for i in range ( len ( y ) ) : <NEWLINE> <INDENT> w1 = y [ i ] <NEWLINE> lcs_2 = lcs [ : ] <NEWLINE> for j in range ( len ( x ) ) : <NEWLINE> <INDENT> if x [ j ] == w1 : <NEWLINE> <INDENT> lcs [ j + 1 ] = lcs_2 [ j ] + 1 <NEWLINE> <DEDENT> elif lcs [ j + 1 ] < lcs [ j ] : <NEWLINE> <INDENT> lcs [ j + 1 ] = lcs [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return lcs [ - 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> print ( lcss ( x , y ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> def solve ( x ) : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif x % 2 == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 3 , math . ceil ( math . sqrt ( x ) ) + 1 , 2 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> return 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if solve ( int ( input ( ) ) ) == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def func ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ( n , m ) = tuple ( [ int ( num ) for num in input ( ) . rstrip ( ) . split ( <STRING> ) ] ) <NEWLINE> matrix = [ [ int ( num ) for num in input ( ) . rstrip ( ) . split ( <STRING> ) ] for i in range ( n ) ] <NEWLINE> vector = [ int ( input ( ) . rstrip ( ) ) for i in range ( m ) ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> return inputError ( ) <NEWLINE> <NL> <DEDENT> result = [ sum ( [ matrix [ j ] [ i ] * vector [ i ] for i in range ( m ) ] ) for j in range ( n ) ] <COMMENT> <NEWLINE> <NL> for num in result : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <NL> <DEDENT> <DEDENT> def inputError ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return - 1 <NEWLINE> <NL> <DEDENT> func ( ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> debug = False <NEWLINE> <NL> def dprint ( * objects ) : <NEWLINE> <INDENT> if debug == True : <NEWLINE> <INDENT> print ( * objects ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> mat_list = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> mat_list . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> dprint ( mat_list ) <NEWLINE> <NL> <COMMENT> <NL> memo = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] <NEWLINE> <NL> def calc ( start , end ) : <NEWLINE> <INDENT> dprint ( <STRING> , start , end ) <NEWLINE> <COMMENT> <NL> if end == start : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if memo [ start ] [ end ] != 0 : <NEWLINE> <INDENT> return memo [ start ] [ end ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if end - start == 1 : <NEWLINE> <INDENT> cost = mat_list [ start ] [ 0 ] * mat_list [ start ] [ 1 ] * mat_list [ end ] [ 1 ] <NEWLINE> memo [ start ] [ end ] = cost <NEWLINE> dprint ( start , end , cost ) <NEWLINE> return cost <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> min_cost = - 1 <NEWLINE> if end - start >= 2 : <NEWLINE> <INDENT> for right_start in range ( start + 1 , end + 1 ) : <NEWLINE> <INDENT> left = calc ( start , right_start - 1 ) <NEWLINE> right = calc ( right_start , end ) <NEWLINE> cost = left + right + mat_list [ start ] [ 0 ] * mat_list [ right_start ] [ 0 ] * mat_list [ end ] [ 1 ] <NEWLINE> if min_cost == - 1 or min_cost > cost : <NEWLINE> <INDENT> min_cost = cost <NEWLINE> <DEDENT> dprint ( start , end , right_start , min_cost , cost ) <NEWLINE> <NL> <DEDENT> <DEDENT> memo [ start ] [ end ] = min_cost <NEWLINE> return min_cost <NEWLINE> <NL> <DEDENT> ans = calc ( 0 , n - 1 ) <NEWLINE> dprint ( memo ) <NEWLINE> print ( int ( ans ) ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> gcd = 0 <NEWLINE> for a in range ( K ) : <NEWLINE> <INDENT> for b in range ( K ) : <NEWLINE> <INDENT> gcd = math . gcd ( a + 1 , b + 1 ) <NEWLINE> for c in range ( K ) : <NEWLINE> <INDENT> sum += math . gcd ( gcd , c + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
def binexp ( a , b ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> while b > 0 : <NEWLINE> <INDENT> if b & 1 : <NEWLINE> <INDENT> res *= a <NEWLINE> res %= mod <NEWLINE> <DEDENT> a *= a <NEWLINE> a %= mod <NEWLINE> b >>= 1 <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> mod = 1000000007 <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = binexp ( 10 , n ) <NEWLINE> ans1 = binexp ( 9 , n ) <NEWLINE> ans2 = binexp ( 8 , n ) <NEWLINE> print ( ( ans - 2 * ans1 + ans2 ) % mod ) <NEWLINE> <DEDENT>
t = list ( input ( ) ) <NEWLINE> t = <STRING> . join ( t ) <NEWLINE> t = t . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> print ( t ) <NEWLINE>
import sys <NEWLINE> import collections <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> <NL> A_collections = collections . Counter ( A ) <NEWLINE> sum_A = sum ( A ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = B [ i ] , C [ i ] <NEWLINE> if b in A_collections . keys ( ) : <NEWLINE> <INDENT> A_collections [ c ] += A_collections [ b ] <NEWLINE> sum_A += ( c - b ) * A_collections [ b ] <NEWLINE> A_collections [ b ] = 0 <NEWLINE> <NL> <DEDENT> print ( sum_A ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> n , m , * LR = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> L = LR [ : : 2 ] <NEWLINE> R = LR [ 1 : : 2 ] <NEWLINE> l = max ( L ) <NEWLINE> r = min ( R ) <NEWLINE> print ( max ( 0 , r - l + 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> solve ( ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> visited_city = { 1 : 0 } <NEWLINE> visited_city_inv = { 0 : 1 } <NEWLINE> <NL> now = 1 <NEWLINE> num = 0 <NEWLINE> while True : <NEWLINE> <INDENT> next_city = arr [ now - 1 ] <NEWLINE> num += 1 <NEWLINE> if next_city not in visited_city : <NEWLINE> <INDENT> visited_city [ next_city ] = num <NEWLINE> visited_city_inv [ num ] = next_city <NEWLINE> now = next_city <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if k < num : <NEWLINE> <INDENT> ans = visited_city_inv [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = visited_city [ next_city ] <NEWLINE> period = num - x <NEWLINE> ans = visited_city_inv [ x + ( k - x ) % period ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( arr ) <NEWLINE> sq_s = 0 <NEWLINE> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> sq_s += arr [ i ] * arr [ i ] <NEWLINE> <DEDENT> m = 1000000007 <NEWLINE> print ( ( ( s ** 2 - sq_s ) // 2 ) % m ) <NEWLINE>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> while b != 0 : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> s = input ( ) [ : : - 1 ] <NEWLINE> cnt = [ 0 ] <NEWLINE> d = 0 <NEWLINE> mod = 2019 <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> tmp = int ( i ) * pow ( 10 , d , mod ) % mod <NEWLINE> tmp = cnt [ - 1 ] + tmp <NEWLINE> cnt . append ( tmp % mod ) <NEWLINE> d += 1 <NEWLINE> <NL> <DEDENT> cnt = Counter ( cnt ) <NEWLINE> ans = sum ( j * ( j - 1 ) // 2 for j in cnt . values ( ) ) <NEWLINE> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> a = 0 <NEWLINE> t = 1 <NEWLINE> d = [ 1 ] + [ 0 ] * 2018 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a += int ( s [ n - 1 - i ] ) * t <NEWLINE> a %= 2019 <NEWLINE> t *= 10 <NEWLINE> t %= 2019 <NEWLINE> <NL> d [ a ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in d : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from fractions import Fraction <NEWLINE> def S ( n ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> while n : <NEWLINE> <INDENT> n , r = divmod ( n , 10 ) <NEWLINE> res += r <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> k = int ( input ( ) ) <NEWLINE> n = 1 <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> print ( n ) <NEWLINE> n += 1 <NEWLINE> m = Fraction ( n , S ( n ) ) <NEWLINE> temp = n <NEWLINE> for d in range ( len ( str ( n ) ) + 1 ) : <NEWLINE> <INDENT> x = 10 ** ( d + 1 ) * ( n // ( 10 ** ( d + 1 ) ) + 1 ) - 1 <NEWLINE> if Fraction ( x , S ( x ) ) < m : <NEWLINE> <INDENT> m = Fraction ( x , S ( x ) ) <NEWLINE> temp = x <NEWLINE> <DEDENT> <DEDENT> n = temp <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A1 = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s in A1 : <NEWLINE> <INDENT> A1 [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A1 [ s ] = 1 <NEWLINE> <DEDENT> <DEDENT> sai = max ( A1 . values ( ) ) <NEWLINE> for j in sorted ( k for k in A1 if A1 [ k ] == sai ) : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <NL> <NL> <DEDENT>
<NL> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> g = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> d = math . gcd ( i , j ) <NEWLINE> for h in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> f = math . gcd ( h , d ) <NEWLINE> g = g + f <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( g ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = 0 <NEWLINE> mi = 10 ** 9 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num += abs ( a [ i ] ) <NEWLINE> if abs ( mi ) >= abs ( a [ i ] ) : <NEWLINE> <INDENT> mi = a [ i ] <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] < 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt % 2 == 1 : <NEWLINE> <INDENT> print ( num - 2 * abs ( mi ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> aaa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 1000000007 <NEWLINE> c_sum = [ 0 ] * n <NEWLINE> c_sum [ n - 1 ] = aaa [ n - 1 ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n - 2 , 0 , - 1 ) : <NEWLINE> <INDENT> c_sum [ i ] = ( c_sum [ i + 1 ] + aaa [ i ] ) % mod <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += aaa [ i ] * c_sum [ i + 1 ] % mod <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
INF = 10 ** 3 <NEWLINE> <NL> <NL> def reconstruction ( o_ary , p_ary , i_ary , l , r ) : <NEWLINE> <INDENT> if l >= r : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> ind = INF <NEWLINE> for i in i_ary [ l : r ] : <NEWLINE> <INDENT> tmp_ind = p_ary . index ( i ) <NEWLINE> if ind > tmp_ind : <NEWLINE> <INDENT> ind = tmp_ind <NEWLINE> <DEDENT> <DEDENT> c = p_ary [ ind ] <NEWLINE> m = i_ary . index ( c ) <NEWLINE> <NL> reconstruction ( o_ary , p_ary , i_ary , l , m ) <NEWLINE> reconstruction ( o_ary , p_ary , i_ary , m + 1 , r ) <NEWLINE> o_ary . append ( c ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> p_ary = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> i_ary = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> o_ary = [ ] <NEWLINE> reconstruction ( o_ary , p_ary , i_ary , 0 , n ) <NEWLINE> print ( * o_ary ) <NEWLINE> <NL>
from collections import Counter <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = Counter ( <STRING> . join ( input ( ) for _ in range ( h ) ) ) <NEWLINE> <NL> center = h * w % 2 <NEWLINE> side = ( h // 2 ) * ( w % 2 ) + ( w // 2 ) * ( h % 2 ) <NEWLINE> corner = ( h // 2 ) * ( w // 2 ) <NEWLINE> <NL> for _ in range ( center ) : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> if a [ i ] % 2 == 1 : <NEWLINE> <INDENT> a [ i ] -= 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for _ in range ( side ) : <NEWLINE> <INDENT> for j in a : <NEWLINE> <INDENT> if a [ j ] % 4 == 2 : <NEWLINE> <INDENT> a [ j ] -= 2 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> if sum ( a [ i ] % 4 for i in a ) == 0 else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import math <NEWLINE> def seki ( L ) : <NEWLINE> <INDENT> num = 1 <NEWLINE> for i in L : <NEWLINE> <INDENT> num *= i <NEWLINE> <DEDENT> return num <NEWLINE> <DEDENT> def Seki ( L ) : <NEWLINE> <INDENT> if len ( L ) <= int ( math . sqrt ( N ) ) : <NEWLINE> <INDENT> return seki ( L ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return Seki ( L [ : len ( L ) // 2 ] ) * Seki ( L [ len ( L ) // 2 : ] ) <NEWLINE> <DEDENT> <DEDENT> if Seki ( List ) <= 10 ** 18 : <NEWLINE> <INDENT> print ( Seki ( List ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> <NL> def get_result ( data ) : <NEWLINE> <COMMENT> <NL> <INDENT> S = data [ 1 ] [ 0 ] <NEWLINE> r_index = [ i for i in range ( len ( S ) ) if S [ i ] == <STRING> ] <NEWLINE> g_index = [ i for i in range ( len ( S ) ) if S [ i ] == <STRING> ] <NEWLINE> b_index = set ( [ i for i in range ( len ( S ) ) if S [ i ] == <STRING> ] ) <NEWLINE> all_case = len ( r_index ) * len ( g_index ) * len ( b_index ) <NEWLINE> invalid_case = 0 <NEWLINE> for i in r_index : <NEWLINE> <INDENT> for j in g_index : <NEWLINE> <INDENT> s_i , s_j = sorted ( [ i , j ] ) <NEWLINE> tmp_max_b = s_j + ( s_j - s_i ) <NEWLINE> if tmp_max_b in b_index : <NEWLINE> <INDENT> invalid_case += 1 <NEWLINE> <DEDENT> tmp_min_b = s_i - ( s_j - s_i ) <NEWLINE> if tmp_min_b in b_index : <NEWLINE> <INDENT> invalid_case += 1 <NEWLINE> <DEDENT> tmp_mid_b = ( s_i + s_j ) / 2 <NEWLINE> if tmp_mid_b in b_index : <NEWLINE> <INDENT> invalid_case += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return all_case - invalid_case <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> raw_data = [ val . rstrip ( ) for val in stdin . readlines ( ) ] <NEWLINE> data = [ list ( map ( str , val . split ( <STRING> ) ) ) for val in raw_data ] <NEWLINE> result = get_result ( data ) <NEWLINE> print ( result ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> for a in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> n = N // a <NEWLINE> ans = ( n * ( 2 * a + ( n - 1 ) * a ) ) // 2 + ans <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> cmd = [ s for s in input ( ) . split ( ) ] <NEWLINE> cmd [ 1 ] = int ( cmd [ 1 ] ) <NEWLINE> cmd [ 2 ] = int ( cmd [ 2 ] ) <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> c = list ( cmd [ 3 ] ) <NEWLINE> h = 0 <NEWLINE> for j in range ( cmd [ 1 ] , cmd [ 2 ] + 1 ) : <NEWLINE> <INDENT> s [ j ] = c [ h ] <NEWLINE> h += 1 <NEWLINE> <DEDENT> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> k = cmd [ 1 ] <NEWLINE> l = cmd [ 2 ] <NEWLINE> while k < l : <NEWLINE> <INDENT> t = s [ k ] <NEWLINE> s [ k ] = s [ l ] <NEWLINE> s [ l ] = t <NEWLINE> k += 1 <NEWLINE> l -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for m in range ( cmd [ 1 ] , cmd [ 2 ] + 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( s [ m ] ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if len ( s ) <= n : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( s [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> res = 1 <NEWLINE> for x in A : <NEWLINE> <INDENT> res *= x <NEWLINE> if res > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) . split ( ) <NEWLINE> A = [ [ 0 ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> j = int ( s [ i ] ) - 1 <NEWLINE> A [ j ] += [ 1 ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( len ( A [ i ] ) - 1 ) <NEWLINE> <DEDENT>
class Heap ( list ) : <NEWLINE> <INDENT> def __init__ ( self , init_list = [ ] ) : <NEWLINE> <INDENT> super ( ) . __init__ ( init_list ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def left ( i : int ) -> int : <NEWLINE> <INDENT> return 2 * i + 1 <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def right ( i : int ) -> int : <NEWLINE> <INDENT> return 2 * i + 2 <NEWLINE> <NL> <DEDENT> def max_heapify ( self , i : int ) : <NEWLINE> <INDENT> l = self . left ( i ) <NEWLINE> r = self . right ( i ) <NEWLINE> H = len ( self ) <NEWLINE> <COMMENT> <NL> if l < H and self [ l ] > self [ i ] : <NEWLINE> <INDENT> largest = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest = i <NEWLINE> <DEDENT> if r < H and self [ r ] > self [ largest ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <DEDENT> if largest != i : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> tmp = self [ i ] <NEWLINE> self [ i ] = self [ largest ] <NEWLINE> self [ largest ] = tmp <NEWLINE> self . max_heapify ( largest ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> def build_max_heap ( self ) : <NEWLINE> <INDENT> for i in range ( len ( self ) // 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> self . max_heapify ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> xs = Heap ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> xs . build_max_heap ( ) <NEWLINE> print ( <STRING> + <STRING> . join ( [ str ( i ) for i in xs ] ) ) <NEWLINE>
from sys import stdin <NEWLINE> from collections import defaultdict <NEWLINE> from math import gcd <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> MOD = 1000000007 <NEWLINE> <NL> N , * AB = map ( int , stdin . buffer . read ( ) . split ( ) ) <NEWLINE> <NL> d = defaultdict ( int ) <NEWLINE> n_zeros = 0 <NEWLINE> <NL> for a , b in zip ( AB [ : : 2 ] , AB [ 1 : : 2 ] ) : <NEWLINE> <INDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> n_zeros += 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> g = gcd ( a , b ) <NEWLINE> a , b = a // g , b // g <NEWLINE> <NL> if a * b > 0 or b == 0 : <NEWLINE> <INDENT> c = ( abs ( a ) , abs ( b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = ( - abs ( a ) , - abs ( b ) ) <NEWLINE> <NL> <DEDENT> d [ c ] += 1 <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> n_not_paired = 0 <NEWLINE> for ab , n in d . items ( ) : <NEWLINE> <INDENT> ab_pair = ( - ab [ 1 ] , - ab [ 0 ] ) <NEWLINE> if ab_pair in d : <NEWLINE> <INDENT> if ab [ 0 ] > 0 : <NEWLINE> <INDENT> m = d [ ab_pair ] <NEWLINE> ans = ans * ( pow ( 2 , n , MOD ) + pow ( 2 , m , MOD ) - 1 ) % MOD <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> n_not_paired += n <NEWLINE> <NL> <DEDENT> <DEDENT> ans = ( ans * pow ( 2 , n_not_paired , MOD ) + n_zeros - 1 ) % MOD <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> numlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> numcount = [ 0 ] * 10 ** 6 <NEWLINE> <NL> numset = set ( ) <NEWLINE> for num in numlist : <NEWLINE> <INDENT> numcount [ num ] += 1 <NEWLINE> numset . add ( num ) <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> anslist = [ ] <NEWLINE> result = 0 <NEWLINE> for num in list ( numset ) : <NEWLINE> <INDENT> result += numcount [ num ] * num <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> numcount [ c ] += numcount [ b ] <NEWLINE> result += ( c - b ) * numcount [ b ] <NEWLINE> anslist . append ( result ) <NEWLINE> <NL> numcount [ b ] = 0 <NEWLINE> numset . add ( c ) <NEWLINE> numset . discard ( b ) <NEWLINE> <NL> <DEDENT> for ans in anslist : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> s = input ( ) <NEWLINE> <NL> flg = False <NEWLINE> lst = [ ] <NEWLINE> <NL> for i in range ( len ( s ) - 2 ) : <NEWLINE> <INDENT> if ( s [ i ] == s [ i + 1 ] ) : <NEWLINE> <INDENT> flg = True <NEWLINE> lst . append ( i + 1 ) <NEWLINE> lst . append ( i + 2 ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( s [ i ] == s [ i + 2 ] ) : <NEWLINE> <INDENT> flg = True <NEWLINE> lst . append ( i + 1 ) <NEWLINE> lst . append ( i + 3 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if not ( lst ) : <NEWLINE> <INDENT> if ( s [ len ( s ) - 1 ] == s [ len ( s ) - 2 ] ) : <NEWLINE> <INDENT> lst . append ( len ( s ) - 1 ) <NEWLINE> lst . append ( len ( s ) ) <NEWLINE> flg = True <NEWLINE> <NL> <DEDENT> <DEDENT> if ( flg ) : <NEWLINE> <INDENT> print ( * lst ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 , - 1 ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> S = list ( input ( ) ) <NEWLINE> S . reverse ( ) <NEWLINE> L = len ( S ) <NEWLINE> dp = [ 0 ] * ( L + 1 ) <NEWLINE> tmp = 0 <NEWLINE> for i in range ( L ) : <NEWLINE> <INDENT> tmp += int ( S [ i ] ) * pow ( 10 , i , 2019 ) <NEWLINE> tmp %= 2019 <NEWLINE> dp [ i ] = tmp <NEWLINE> <NL> <DEDENT> c = Counter ( dp ) <NEWLINE> ans = 0 <NEWLINE> for i , v in c . items ( ) : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> lines = sys . stdin . readlines ( ) <NEWLINE> n = int ( lines [ 0 ] ) <NEWLINE> <NL> repo = { } <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> command , acgt = lines [ i ] . split ( ) <NEWLINE> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> if acgt not in repo : <NEWLINE> <INDENT> repo [ acgt ] = 0 <NEWLINE> <DEDENT> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> if acgt in repo : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_A = [ 0 for _ in range ( n + 1 ) ] <COMMENT> <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> sum_A [ i ] = sum_A [ i - 1 ] + A [ i - 1 ] <NEWLINE> <DEDENT> sum_B = [ 0 for _ in range ( m + 1 ) ] <COMMENT> <NEWLINE> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> sum_B [ j ] = sum_B [ j - 1 ] + B [ j - 1 ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> i = 0 <NEWLINE> j = m <NEWLINE> while i <= n and sum_A [ i ] <= k : <NEWLINE> <INDENT> while sum_A [ i ] + sum_B [ j ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nums = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> nums [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> nums . sort ( ) <NEWLINE> <NL> nums = deque ( nums ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if nums [ 0 ] == 0 : <NEWLINE> <INDENT> nums . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> nums = list ( nums ) <NEWLINE> if len ( nums ) <= K : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( nums [ : len ( nums ) - K ] ) ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> h = sum ( [ i for i in range ( 1 , b - a + 1 ) ] ) <NEWLINE> print ( h - b ) <NEWLINE>
from collections import Counter <NEWLINE> import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = Counter ( A ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 0 <NEWLINE> MX = 10 ** 6 <NEWLINE> P = [ 0 ] * ( MX + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if P [ a ] == 0 : <NEWLINE> <INDENT> for i in range ( MX + 1 ) : <NEWLINE> <INDENT> x = a * i <NEWLINE> if x > MX : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> P [ x ] = 1 <NEWLINE> <DEDENT> if cnt [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> sum = sum ( A ) <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> sum -= A [ i - 1 ] <NEWLINE> ans += A [ i - 1 ] * sum <NEWLINE> ans = ans % 1000000007 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> friends = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> <NL> def dfs ( i ) : <NEWLINE> <INDENT> ans [ - 1 ] += 1 <NEWLINE> flg [ i ] = 1 <NEWLINE> for j in friends [ i ] : <NEWLINE> <INDENT> if not flg [ j ] : <NEWLINE> <INDENT> dfs ( j ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> friends [ a ] . append ( b ) <NEWLINE> friends [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> flg = [ 0 ] * n <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> if not flg [ i ] : <NEWLINE> <INDENT> dfs ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> B = <STRING> <NEWLINE> for k in range ( N - 1 ) : <NEWLINE> <INDENT> B += str ( A [ k ] ) + <STRING> <NEWLINE> <DEDENT> B += str ( A [ N - 1 ] ) <NEWLINE> print ( B ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> j = i - 1 <NEWLINE> v = A [ i ] <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> B = <STRING> <NEWLINE> for k in range ( N - 1 ) : <NEWLINE> <INDENT> B += str ( A [ k ] ) + <STRING> <NEWLINE> <DEDENT> B += str ( A [ N - 1 ] ) <NEWLINE> print ( B ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> r = np . arange ( 1 , K + 1 ) <NEWLINE> print ( np . sum ( np . gcd . outer ( np . gcd . outer ( r , r ) , r ) ) ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> sz = len ( t ) <NEWLINE> ans = 100000000000 <NEWLINE> c = 0 <NEWLINE> if len ( s ) == sz : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in range ( sz ) : <NEWLINE> <INDENT> if s [ j ] == t [ j ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( ans , sz - c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , len ( s ) - sz ) : <NEWLINE> <INDENT> k = s [ i : i + sz ] <NEWLINE> c = 0 <NEWLINE> for j in range ( sz ) : <NEWLINE> <INDENT> if k [ j ] == t [ j ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( ans , sz - c ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = min ( ans , sz - c ) <NEWLINE> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_sum = sum ( a ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans += a [ i ] * ( a_sum - a [ i ] ) <NEWLINE> <DEDENT> print ( ans // 2 % MOD ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r ** 2 * math . pi , r * 2 * math . pi ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> p = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a = 1 <NEWLINE> b = p [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if p [ i - 1 ] < b : <NEWLINE> <INDENT> b = p [ i - 1 ] <NEWLINE> <DEDENT> if p [ i ] <= b : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> money = 1000 <NEWLINE> b = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if cnt == 0 and A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> cnt += money // A [ i ] <NEWLINE> money %= A [ i ] <NEWLINE> b = A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> money += cnt * A [ i ] <NEWLINE> cnt = 0 <NEWLINE> if A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> cnt += money // A [ i ] <NEWLINE> money %= A [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if cnt > 0 : <NEWLINE> <INDENT> money += cnt * max ( A [ - 1 ] , b ) <NEWLINE> <DEDENT> print ( money ) <NEWLINE>
def gcd ( x , y ) : <NEWLINE> <INDENT> while y > 0 : <NEWLINE> <INDENT> r = x % y <NEWLINE> x = y <NEWLINE> y = r <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( gcd ( x , y ) ) <NEWLINE>
import heapq <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> AB = sorted ( AB , key = lambda x : x [ 0 ] ) <NEWLINE> <NL> x = 0 <NEWLINE> res = 0 <NEWLINE> <NL> hq = [ ] <NEWLINE> heapq . heapify ( hq ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> for j in range ( x , N ) : <NEWLINE> <INDENT> if AB [ j ] [ 0 ] > i + 1 : <NEWLINE> <INDENT> x = j <NEWLINE> break <NEWLINE> <DEDENT> heapq . heappush ( hq , AB [ j ] [ 1 ] * - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = N <NEWLINE> <NL> <DEDENT> if hq : <NEWLINE> <INDENT> res += heapq . heappop ( hq ) * - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import math <NEWLINE> <NL> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> dic = { } <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( tmp , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> from collections import defaultdict <NEWLINE> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> T = [ 0 ] <NEWLINE> P = 2019 <NEWLINE> dd = defaultdict ( int ) <NEWLINE> dd [ 0 ] += 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = ( int ( s [ - i ] ) * pow ( 10 , i - 1 , P ) + T [ i - 1 ] ) % P <NEWLINE> T . append ( x ) <NEWLINE> dd [ x ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in dd . values ( ) : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> import collections <NEWLINE> def ip ( ) : return [ int ( i ) for i in stdin . readline ( ) . split ( ) ] <NEWLINE> def sp ( ) : return [ str ( i ) for i in stdin . readline ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def find ( d , x ) : <NEWLINE> <INDENT> root = x <NEWLINE> while root != d [ root ] : <NEWLINE> <INDENT> root = d [ root ] <NEWLINE> <NL> <DEDENT> while x != root : <NEWLINE> <INDENT> nxt = d [ x ] <NEWLINE> d [ x ] = root <NEWLINE> x = nxt <NEWLINE> <DEDENT> return d , root <NEWLINE> <NL> <NL> <DEDENT> def merge ( d , s , x , y ) : <NEWLINE> <INDENT> d , x = find ( d , x ) <NEWLINE> d , y = find ( d , y ) <NEWLINE> if x == y : return d , s <NEWLINE> if s [ x ] > s [ y ] : <NEWLINE> <INDENT> s [ x ] += s [ y ] <NEWLINE> d [ y ] = d [ x ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ y ] += s [ x ] <NEWLINE> d [ x ] = d [ y ] <NEWLINE> <DEDENT> return d , s <NEWLINE> <NL> <NL> <DEDENT> n , m = ip ( ) <NEWLINE> d = { i + 1 : i + 1 for i in range ( n ) } <NEWLINE> s = { i + 1 : 1 for i in range ( n ) } <NEWLINE> seen = set ( ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <COMMENT> <NL> <INDENT> x , y = ip ( ) <NEWLINE> if ( x , y ) in seen or ( y , x ) in seen : continue <NEWLINE> seen . add ( ( x , y ) ) <NEWLINE> seen . add ( ( y , x ) ) <NEWLINE> d , s = merge ( d , s , x , y ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> ans = max ( ans , s [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = a [ 0 ] ^ a [ 1 ] <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> b = b ^ a [ i ] <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( b ^ a [ i ] ) <NEWLINE> <DEDENT> ans = list ( map ( str , ans ) ) <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> l [ a - 1 ] = max ( l [ a - 1 ] , h [ b - 1 ] ) <NEWLINE> l [ b - 1 ] = max ( l [ b - 1 ] , h [ a - 1 ] ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if h [ i ] > l [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> def main ( ) : <NEWLINE> <INDENT> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if par [ x ] > par [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> par [ x ] += par [ y ] <NEWLINE> par [ y ] = x <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> return find ( x ) == find ( y ) <NEWLINE> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> return - par [ find ( x ) ] <NEWLINE> <NL> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> par = [ - 1 ] * n <NEWLINE> r = [ - 1 ] * n <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> unite ( a , b ) <NEWLINE> r [ a ] -= 1 <NEWLINE> r [ b ] -= 1 <NEWLINE> <DEDENT> for i1 in range ( n ) : <NEWLINE> <INDENT> r [ i1 ] += size ( i1 ) <NEWLINE> <DEDENT> m = map ( int , read ( ) . split ( ) ) <NEWLINE> cd = zip ( m , m ) <NEWLINE> for c , d in cd : <NEWLINE> <INDENT> c -= 1 <NEWLINE> d -= 1 <NEWLINE> if same ( c , d ) : <NEWLINE> <INDENT> r [ c ] -= 1 <NEWLINE> r [ d ] -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( * r , end = <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> count_by_kw = Counter ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> dict = { } <NEWLINE> ans = 0 <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> a = sorted ( input ( ) ) <NEWLINE> b = <STRING> . join ( a ) <NEWLINE> if not b in dict : <NEWLINE> <INDENT> dict [ b ] = x <NEWLINE> l . append ( b ) <NEWLINE> count_by_kw [ b ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = count_by_kw [ b ] <NEWLINE> count_by_kw [ b ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for y in range ( len ( l ) ) : <NEWLINE> <INDENT> r = l [ y ] <NEWLINE> w = count_by_kw [ r ] <NEWLINE> ans += w * ( w - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
a = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> flag = 0 <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in d : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in d : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> GCD = [ [ math . gcd ( i , j ) for i in range ( 1 , N + 1 ) ] for j in range ( 1 , N + 1 ) ] <NEWLINE> <COMMENT> <NL> all_gcd = [ GCD [ GCD [ i ] [ j ] - 1 ] [ m ] for i in range ( N ) for j in range ( N ) for m in range ( N ) ] <NEWLINE> print ( sum ( all_gcd ) ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> i = max ( b - 1 if n >= b else n , 1 ) <NEWLINE> print ( math . floor ( a * i / b ) - a * math . floor ( i / b ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> def divisor ( n ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> table = [ ] <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> table . append ( i ) <NEWLINE> table . append ( n // i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> table = list ( set ( table ) ) <NEWLINE> return table <NEWLINE> <NL> <DEDENT> a = divisor ( n ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> b = sorted ( a , reverse = True ) <NEWLINE> <NL> c = [ ] <NEWLINE> for i in range ( len ( a ) // 2 + 1 ) : <NEWLINE> <INDENT> d = a [ i ] - 1 + b [ i ] - 1 <NEWLINE> c . append ( d ) <NEWLINE> <NL> <DEDENT> print ( min ( c ) ) <NEWLINE>
<COMMENT> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> cloud = [ [ i for i in input ( ) ] for i in range ( h ) ] <NEWLINE> flag = 0 <COMMENT> <NEWLINE> cnt = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if j == w - 1 and flag == 0 and cloud [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> print ( - 1 , end = <STRING> ) <NEWLINE> <DEDENT> elif j == w - 1 and cloud [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> print ( 0 , end = <STRING> ) <NEWLINE> flag = 1 <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> elif j == w - 1 and cloud [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> print ( cnt , end = <STRING> ) <NEWLINE> <DEDENT> elif flag == 0 and cloud [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> print ( - 1 , end = <STRING> ) <NEWLINE> <DEDENT> elif cloud [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> print ( 0 , end = <STRING> ) <NEWLINE> flag = 1 <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> print ( cnt , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> cnt = 0 <NEWLINE> flag = 0 <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1 << 25 ) <NEWLINE> read = sys . stdin . readline <NEWLINE> ra = range <NEWLINE> enu = enumerate <NEWLINE> <NL> <NL> def exit ( * argv , ** kwarg ) : <NEWLINE> <INDENT> print ( * argv , ** kwarg ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> def mina ( * argv , sub = 1 ) : return list ( map ( lambda x : x - sub , argv ) ) <NEWLINE> <COMMENT> <NL> <NL> <NL> def a_int ( ) : return int ( read ( ) ) <NEWLINE> <NL> <NL> def ints ( ) : return list ( map ( int , read ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def read_col ( H ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> ret . append ( list ( map ( int , read ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> return tuple ( map ( list , zip ( * ret ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def read_tuple ( H ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> ret . append ( tuple ( map ( int , read ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def read_matrix ( H ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> ret . append ( list ( map ( int , read ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> return ret <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> N , W_max = ints ( ) <NEWLINE> W , V = read_col ( N ) <NEWLINE> W = np . array ( W , dtype = np . int64 ) <NEWLINE> V = np . array ( V , dtype = np . int64 ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def solve ( N , W_max , W , V ) : <NEWLINE> <INDENT> V_max = np . sum ( V ) + 1 <NEWLINE> dp = np . full ( ( N + 1 , V_max ) , 10 ** 12 , dtype = np . int64 ) <NEWLINE> <COMMENT> <NL> dp [ 0 , 0 ] = 0 <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> dp [ i + 1 , : ] = np . minimum ( dp [ i + 1 , : ] , dp [ i , : ] ) <NEWLINE> for j in range ( V_max ) : <NEWLINE> <INDENT> jv = j + V [ i ] <NEWLINE> if jv >= V_max : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp [ i + 1 , jv ] = min ( dp [ i + 1 , jv ] , dp [ i , j ] + W [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for j in range ( V_max - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if np . any ( dp [ : , j ] <= W_max ) : <NEWLINE> <INDENT> print ( j ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> solve ( N , W_max , W , V ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> for h in range ( N ) : <NEWLINE> <INDENT> Cx , Cy , h = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( [ h , Cx , Cy ] ) <NEWLINE> <DEDENT> L . sort ( reverse = True ) <NEWLINE> <NL> for x in range ( 101 ) : <NEWLINE> <INDENT> for y in range ( 101 ) : <NEWLINE> <INDENT> cond = True <NEWLINE> H = L [ 0 ] [ 0 ] + abs ( x - L [ 0 ] [ 1 ] ) + abs ( y - L [ 0 ] [ 2 ] ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> h = L [ i ] [ 0 ] + abs ( x - L [ i ] [ 1 ] ) + abs ( y - L [ i ] [ 2 ] ) <NEWLINE> if L [ i ] [ 0 ] > 0 : <NEWLINE> <INDENT> if h != H : <NEWLINE> <INDENT> cond = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if h < H : <NEWLINE> <INDENT> cond = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if cond : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if cond : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x , y , H ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> L = 0 <NEWLINE> if K % 7 == 0 : <NEWLINE> <INDENT> L = 9 * K // 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = 9 * K <NEWLINE> <NL> <DEDENT> t = 1 <NEWLINE> ans = - 1 <NEWLINE> for i in range ( 1 , L , 1 ) : <NEWLINE> <INDENT> t = t * 10 <NEWLINE> if t % L == 1 : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> t = t % L <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> T = <STRING> <NEWLINE> <NL> for q in range ( Q ) : <NEWLINE> <INDENT> que = input ( ) . split ( ) <NEWLINE> if que [ 0 ] == <STRING> : <NEWLINE> <INDENT> S , T = T , S <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if que [ 1 ] == <STRING> : <NEWLINE> <INDENT> T += que [ 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S += que [ 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( T [ : : - 1 ] + S ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> sum_A = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum_A = ( sum_A + A [ i ] ) % MOD <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum_A = ( sum_A - A [ i ] ) % MOD <NEWLINE> sum = ( sum + sum_A * A [ i ] ) % MOD <NEWLINE> <NL> <NL> <DEDENT> print ( sum ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( N , B - 1 ) <NEWLINE> print ( int ( A * x / B ) ) <NEWLINE>
from collections import deque <NEWLINE> K = int ( input ( ) ) <NEWLINE> S = [ i for i in range ( 1 , 10 ) ] <NEWLINE> S = deque ( S ) <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> Lun = S . popleft ( ) <NEWLINE> Lu = Lun % 10 <NEWLINE> if Lu != 0 : <NEWLINE> <INDENT> S . append ( 10 * Lun + Lu - 1 ) <NEWLINE> <DEDENT> S . append ( Lun * 10 + Lu ) <NEWLINE> if Lu != 9 : <NEWLINE> <INDENT> S . append ( 10 * Lun + Lu + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( Lun ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> dp = [ False ] * ( 10 ** 6 * 2 ) <NEWLINE> ans = 0 <NEWLINE> for idx , i in enumerate ( A ) : <NEWLINE> <INDENT> if dp [ i ] : continue <NEWLINE> tmp = i <NEWLINE> ans += 1 <NEWLINE> while tmp < 10 ** 6 * 2 - 1 : <NEWLINE> <INDENT> dp [ tmp ] = True <NEWLINE> tmp += i <NEWLINE> <DEDENT> if idx != len ( A ) - 1 and A [ idx + 1 ] == i : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> k = int ( input ( ) ) <NEWLINE> d = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> d = ( 10 * d ) + 7 <NEWLINE> d %= k <NEWLINE> if d == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> count += bisect . bisect_left ( l , l [ i ] + l [ j ] ) - j - 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> INF = float ( <STRING> ) <NEWLINE> import sys , collections , heapq , math <NEWLINE> <NL> N , K = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <COMMENT> <NEWLINE> a . sort ( reverse = True ) <NEWLINE> <NL> ng = 0 <NEWLINE> ok = a [ 0 ] <NEWLINE> <NL> def isOK ( v ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> k = K <NEWLINE> i = 0 <NEWLINE> while k >= 0 and i < N : <NEWLINE> <COMMENT> <NL> <INDENT> k = k - ( math . ceil ( a [ i ] / v ) - 1 ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> return k >= 0 <NEWLINE> <NL> <DEDENT> while abs ( ng - ok ) > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> <COMMENT> <NL> if isOK ( mid ) : <COMMENT> <NEWLINE> <INDENT> ok = mid <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( math . ceil ( ok ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> room_and_connecting_room_dict = { i : set ( ) for i in range ( 1 , N + 1 ) } <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> room_and_connecting_room_dict [ A ] . add ( B ) <NEWLINE> room_and_connecting_room_dict [ B ] . add ( A ) <NEWLINE> <NL> <DEDENT> def get_child_ans ( room_numbers_set ) : <COMMENT> <NEWLINE> <NL> <INDENT> next_room_numbers_set = set ( ) <NEWLINE> <NL> for room_number in room_numbers_set : <NEWLINE> <INDENT> for child_room in room_and_connecting_room_dict [ room_number ] : <NEWLINE> <INDENT> if child_room not in calculated_room_numbers_set : <NEWLINE> <INDENT> ans_dict [ child_room ] = room_number <COMMENT> <NEWLINE> next_room_numbers_set . add ( child_room ) <NEWLINE> calculated_room_numbers_set . add ( child_room ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if len ( calculated_room_numbers_set ) == N : <COMMENT> <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif len ( next_room_numbers_set ) == 0 : <COMMENT> <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> return get_child_ans ( next_room_numbers_set ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans_dict = dict ( ) <NEWLINE> ans_dict [ 1 ] = 0 <NEWLINE> calculated_room_numbers_set = set ( ) <NEWLINE> calculated_room_numbers_set . add ( 1 ) <NEWLINE> <NL> is_there_ans = get_child_ans ( set ( [ 1 ] ) ) <NEWLINE> <NL> if is_there_ans == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( ans_dict [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from bisect import * <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> * B , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> sa = [ 0 ] + [ 0 ] * N <NEWLINE> i = 0 <NEWLINE> while i < N : <NEWLINE> <INDENT> sa [ i + 1 ] = sa [ i ] + A [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> sb = [ 0 ] + [ 0 ] * M <NEWLINE> j = 0 <NEWLINE> while j < M : <NEWLINE> <INDENT> sb [ j + 1 ] = sb [ j ] + B [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> i = bisect_right ( sa , K ) - 1 <NEWLINE> ans = 0 <NEWLINE> while 0 <= i : <NEWLINE> <INDENT> j = bisect_right ( sb , K - sa [ i ] ) - 1 <NEWLINE> ans = max ( ans , i + j ) <NEWLINE> i -= 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> sys . setrecursionlimit ( 300000 ) <NEWLINE> <NL> to = [ [ ] for _ in range ( 200005 ) ] <NEWLINE> ans : list <NEWLINE> <NL> <NL> def dfs ( v , p = - 1 ) : <NEWLINE> <INDENT> global ans <NEWLINE> for u in to [ v ] : <NEWLINE> <INDENT> if u == p : continue <NEWLINE> ans [ u ] += ans [ v ] <NEWLINE> dfs ( u , v ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> to [ a - 1 ] . append ( b - 1 ) <NEWLINE> to [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> global ans <NEWLINE> ans = [ 0 ] * N <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ p - 1 ] += x <NEWLINE> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> given_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> money = 1000 <NEWLINE> kabu = 0 <NEWLINE> <NL> a = [ ] <NEWLINE> for kabuka in given_a : <NEWLINE> <INDENT> if len ( a ) > 0 and a [ - 1 ] == kabuka : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( kabuka ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = len ( a ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( money ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if a [ i + 1 ] < a [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kabu += money // a [ i ] <NEWLINE> money %= a [ i ] <NEWLINE> <DEDENT> <DEDENT> elif i == n - 1 : <NEWLINE> <INDENT> money += kabu * a [ i ] <NEWLINE> kabu = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a [ i - 1 ] < a [ i ] and a [ i ] > a [ i + 1 ] : <NEWLINE> <INDENT> money += kabu * a [ i ] <NEWLINE> kabu = 0 <NEWLINE> <DEDENT> if a [ i - 1 ] > a [ i ] and a [ i ] < a [ i + 1 ] : <NEWLINE> <INDENT> kabu += money // a [ i ] <NEWLINE> money %= a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( money ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> flag = True <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == False : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> <NL> def marge_ponds ( lx , area_of_pond ) : <NEWLINE> <INDENT> global ponds <NEWLINE> if ponds and ponds [ - 1 ] [ 0 ] > lx : <NEWLINE> <INDENT> return marge_ponds ( lx , area_of_pond + ponds . pop ( ) [ 1 ] ) <NEWLINE> <DEDENT> return area_of_pond <NEWLINE> <NL> <NL> <DEDENT> terrains = input ( ) . strip ( ) <NEWLINE> x , last_x , ponds = 0 , deque ( ) , deque ( ) <NEWLINE> <NL> for terrain in terrains : <NEWLINE> <INDENT> if terrain == <STRING> : <NEWLINE> <INDENT> last_x . append ( x ) <NEWLINE> <DEDENT> elif terrain == <STRING> : <NEWLINE> <INDENT> if last_x : <NEWLINE> <INDENT> lx = last_x . pop ( ) <NEWLINE> ponds . append ( ( lx , marge_ponds ( lx , x - lx ) ) ) <NEWLINE> <DEDENT> <DEDENT> x += 1 <NEWLINE> <NL> <DEDENT> print ( sum ( pond [ 1 ] for pond in ponds ) ) <NEWLINE> ponds . appendleft ( ( 0 , len ( ponds ) ) ) <NEWLINE> print ( <STRING> . join ( map ( str , [ pond [ 1 ] for pond in ponds ] ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> score = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> score *= i <NEWLINE> if score > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( score ) <NEWLINE>
alp = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> a = n % 26 <NEWLINE> ans += alp [ a ] <NEWLINE> n = int ( n // 26 ) <NEWLINE> <NL> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import string <NEWLINE> <NL> l = [ c for c in string . ascii_lowercase ] <NEWLINE> def f ( N : int ) : <NEWLINE> <INDENT> N -= 1 <NEWLINE> if N // 26 : <NEWLINE> <INDENT> return f ( N // 26 ) + l [ N % 26 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return l [ N % 26 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def solve ( N ) : <NEWLINE> <INDENT> print ( f ( N ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> solve ( N ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k <= n - 1 : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> H = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> Way = [ [ ] for I in range ( N ) ] <NEWLINE> for T in range ( 0 , M ) : <NEWLINE> <INDENT> A , B = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> Way [ A - 1 ] . append ( B ) <NEWLINE> Way [ B - 1 ] . append ( A ) <NEWLINE> <NL> <DEDENT> Count = 0 <NEWLINE> for TT in range ( 0 , N ) : <NEWLINE> <INDENT> if all ( H [ TT ] > Ele for Ele in [ H [ I - 1 ] for I in Way [ TT ] ] ) : <NEWLINE> <INDENT> Count = Count + 1 <NEWLINE> <DEDENT> <DEDENT> print ( Count ) <NEWLINE>
def print_heap ( ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( i - 1 ) // 2 in range ( n ) : <NEWLINE> <INDENT> if 2 * i + 1 in range ( n ) : <NEWLINE> <INDENT> if 2 * i + 2 in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <INDENT> . format ( i + 1 , heap [ i ] , heap [ ( i - 1 ) // 2 ] , heap [ 2 * i + 1 ] , heap [ 2 * i + 2 ] ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <INDENT> . format ( i + 1 , heap [ i ] , heap [ ( i - 1 ) // 2 ] , heap [ 2 * i + 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <INDENT> . format ( i + 1 , heap [ i ] , heap [ ( i - 1 ) // 2 ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if 2 * i + 1 in range ( n ) : <NEWLINE> <INDENT> if 2 * i + 2 in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <INDENT> . format ( i + 1 , heap [ i ] , heap [ 2 * i + 1 ] , heap [ 2 * i + 2 ] ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <INDENT> . format ( i + 1 , heap [ i ] , heap [ 2 * i + 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( i + 1 , heap [ i ] ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> heap = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print_heap ( ) <NEWLINE> <DEDENT>
T = input ( ) <NEWLINE> <NL> for i , v in enumerate ( T ) : <NEWLINE> <INDENT> if v == <STRING> : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( v , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ret = 0 <NEWLINE> sum_list = [ None ] * n + [ 0 ] <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> sum_list [ i ] = sum_list [ i + 1 ] + a [ i ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ret += a [ i ] * sum_list [ i + 1 ] <NEWLINE> ret %= 1000000007 <NEWLINE> <DEDENT> print ( ret ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> import heapq <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cur = n - 1 <NEWLINE> bit = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == b [ i ] : <NEWLINE> <INDENT> while a [ i ] == b [ cur ] or a [ cur ] == b [ i ] : <NEWLINE> <INDENT> if cur == 0 : <NEWLINE> <INDENT> bit = - 1 <NEWLINE> <DEDENT> if bit == - 1 and cur == n - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> cur -= bit <NEWLINE> <DEDENT> b [ i ] , b [ cur ] = b [ cur ] , b [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( list ( map ( str , b ) ) ) ) <NEWLINE> <NL> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> root = [ - 1 ] * n <NEWLINE> def r ( x ) : <NEWLINE> <INDENT> if root [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root [ x ] = r ( root [ x ] ) <NEWLINE> return root [ x ] <NEWLINE> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = r ( x ) <NEWLINE> y = r ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> root [ x ] += root [ y ] <NEWLINE> root [ y ] = x <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> unite ( a , b ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , - root [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> m = a [ - 1 ] <NEWLINE> c = [ 0 ] * ( m + 1 ) <NEWLINE> <NL> for ai in a : <NEWLINE> <INDENT> for i in range ( ai , m + 1 , ai ) : <NEWLINE> <INDENT> c [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for ai in a : <NEWLINE> <INDENT> if c [ ai ] == 1 : <NEWLINE> <INDENT> ans += c [ ai ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n > 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = [ ] <NEWLINE> <DEDENT> a = list ( set ( list ( range ( - 100 , 102 ) ) ) - set ( p ) ) <NEWLINE> values = [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> values = values + [ [ abs ( x - i ) , i ] ] <NEWLINE> <DEDENT> values . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> mins = values [ 0 ] [ 0 ] <NEWLINE> b = [ ] <NEWLINE> for i in values : <NEWLINE> <INDENT> if i [ 0 ] > mins : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b += [ i [ 1 ] ] <NEWLINE> <DEDENT> b . sort ( ) <NEWLINE> print ( b [ 0 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max = 10 ** 18 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > max : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> ss = [ input ( ) for _ in range ( n ) ] <NEWLINE> s = sorted ( ss ) <NEWLINE> ans = <STRING> <NEWLINE> for i in s : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if h == 1 or w == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> elif ( h * w ) % 2 == 0 : <NEWLINE> <INDENT> ans = int ( h * w // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( h * w // 2 + 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> sc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> ans = - 1 <NEWLINE> <NL> for i in range ( 1000 ) : <NEWLINE> <INDENT> s_i = str ( i ) <NEWLINE> if len ( s_i ) == n and all ( int ( s_i [ s - 1 ] ) == c for s , c in sc ) : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = X <NEWLINE> A = [ X ] <NEWLINE> exists = [ 0 ] * M <NEWLINE> exists [ X ] = 1 <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> A_i = ( A [ - 1 ] * A [ - 1 ] ) % M <NEWLINE> A . append ( A_i ) <NEWLINE> S += A_i <NEWLINE> if exists [ A_i ] == 0 : <NEWLINE> <INDENT> exists [ A_i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S -= A_i <NEWLINE> del A [ - 1 ] <NEWLINE> B = A [ A . index ( A_i ) : ] <NEWLINE> S += ( ( N - len ( A ) ) // len ( B ) ) * sum ( B ) + sum ( B [ : ( ( N - len ( A ) ) % len ( B ) ) ] ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> second = K - A - B <NEWLINE> <NL> if A >= K : <NEWLINE> <INDENT> count = K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = A <NEWLINE> <NL> <DEDENT> if second > 0 : <NEWLINE> <INDENT> count -= second <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 99999999 ) <NEWLINE> <NL> <NL> [ n , m ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> friends = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> friends . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> tomodachi = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> tomodachi [ friends [ i ] [ 0 ] - 1 ] . append ( friends [ i ] [ 1 ] - 1 ) <NEWLINE> tomodachi [ friends [ i ] [ 1 ] - 1 ] . append ( friends [ i ] [ 0 ] - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> tomodachi [ i ] = list ( set ( tomodachi [ i ] ) ) <NEWLINE> <NL> <DEDENT> namelist = [ 1 for i in range ( n ) ] <NEWLINE> teams = [ ] <NEWLINE> <NL> def haba ( x , kari , tomodachi , namelist ) : <NEWLINE> <INDENT> for i in range ( len ( tomodachi [ x ] ) ) : <NEWLINE> <INDENT> if namelist [ tomodachi [ x ] [ i ] ] == 1 : <COMMENT> <NEWLINE> <INDENT> kari . append ( tomodachi [ x ] [ i ] ) <NEWLINE> namelist [ tomodachi [ x ] [ i ] ] = 0 <COMMENT> <NEWLINE> haba ( tomodachi [ x ] [ i ] , kari , tomodachi , namelist ) <NEWLINE> <DEDENT> <DEDENT> return ( kari ) <NEWLINE> <NL> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if namelist [ i ] == 1 : <NEWLINE> <INDENT> teams . append ( list ( set ( haba ( i , [ i ] , tomodachi , namelist ) ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> saidai = 0 <NEWLINE> <NL> for i in range ( len ( teams ) ) : <NEWLINE> <INDENT> if saidai < len ( teams [ i ] ) : <NEWLINE> <INDENT> saidai = len ( teams [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = saidai <NEWLINE> <NL> print ( ans ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> if A == B : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> elif A == B : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif A > B : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B * ( N - 2 ) - A * ( N - 2 ) + 1 ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a -= k <NEWLINE> if a <= - 1 : <NEWLINE> <INDENT> p = abs ( a ) <NEWLINE> a = 0 <NEWLINE> b -= p <NEWLINE> if b <= - 1 : <NEWLINE> <INDENT> b = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( str ( a ) + <STRING> + str ( b ) ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> h = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> o = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> o . append ( 1 ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> if h [ a - 1 ] <= h [ b - 1 ] : <NEWLINE> <INDENT> o [ a - 1 ] = 0 <NEWLINE> <DEDENT> if h [ a - 1 ] >= h [ b - 1 ] : <NEWLINE> <INDENT> o [ b - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( o ) ) <NEWLINE>
def primes ( n ) : <NEWLINE> <INDENT> tf = [ True ] * ( n + 1 ) <NEWLINE> tf [ 0 ] = tf [ 1 ] = False <NEWLINE> for i in range ( 2 , int ( n ** ( 1 / 2 ) ) + 1 ) : <NEWLINE> <INDENT> if tf [ i ] : <NEWLINE> <INDENT> for j in range ( i ** 2 , n + 1 , i ) : <NEWLINE> <INDENT> tf [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return [ i for i in range ( n + 1 ) if tf [ i ] ] <NEWLINE> <NL> <DEDENT> def add_twin ( prime_lst , twin_lst ) : <NEWLINE> <INDENT> prime_lst2 = prime_lst [ 1 : ] <NEWLINE> for x , y in zip ( prime_lst , prime_lst2 ) : <NEWLINE> <INDENT> if y - x == 2 : <NEWLINE> <INDENT> twin_lst . append ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def search_twin ( x , twin_lst ) : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = len ( twin_lst ) <NEWLINE> while left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if twin_lst [ mid ] > x : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> elif twin_lst [ mid ] < x : <NEWLINE> <INDENT> left = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> <DEDENT> return twin_lst [ left ] <NEWLINE> <NL> <DEDENT> prime_lst = primes ( 10000 ) <NEWLINE> twin_lst = [ ] <NEWLINE> add_twin ( prime_lst , twin_lst ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = search_twin ( n , twin_lst ) <NEWLINE> print ( a - 2 , a ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ls = [ 0 ] * n <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> ls [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in ls : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> loads = [ ] <NEWLINE> teams = [ [ i ] for i in range ( N ) ] <NEWLINE> syozoku = { i : i for i in range ( N ) } <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if syozoku [ A - 1 ] != syozoku [ B - 1 ] : <NEWLINE> <INDENT> hairu , nukeru = min ( syozoku [ A - 1 ] , syozoku [ B - 1 ] ) , max ( syozoku [ A - 1 ] , syozoku [ B - 1 ] ) <NEWLINE> team = teams [ nukeru ] <NEWLINE> teams [ nukeru ] = [ ] <NEWLINE> teams [ hairu ] += team <NEWLINE> for i in team : <NEWLINE> <INDENT> syozoku [ i ] = hairu <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = - 1 <NEWLINE> for team in teams : <NEWLINE> <INDENT> if len ( team ) != 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> while k : <NEWLINE> <INDENT> if k & 1 : <NEWLINE> <INDENT> ans = a [ ans ] <NEWLINE> <DEDENT> a = [ a [ ai ] for ai in a ] <NEWLINE> k >>= 1 <NEWLINE> <DEDENT> print ( ans + 1 ) <NEWLINE>
def is_bad_nums ( j : int , d : [ ] ) -> bool : <NEWLINE> <INDENT> while j : <NEWLINE> <INDENT> if j % 10 in d : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> j //= 10 <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> def answer ( n : int , k : int , d : [ ] ) -> int : <NEWLINE> <INDENT> for i in range ( n , 100000 ) : <NEWLINE> <INDENT> if is_bad_nums ( i , d ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> return i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( answer ( n , k , d ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> b = [ ] <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> A . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for _ in range ( M ) : <NEWLINE> <INDENT> b . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( sum ( [ A [ i ] [ j ] * b [ j ] for j in range ( M ) ] ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> B = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> <NL> a = np . append ( a , np . cumsum ( A ) ) <NEWLINE> b = np . append ( b , np . cumsum ( B ) ) <NEWLINE> <NL> j = m <NEWLINE> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while a [ i ] + b [ j ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> <COMMENT> <NL> ans = <STRING> <NEWLINE> <COMMENT> <NL> t1 , t2 = Counter ( ) , Counter ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t1 . update ( a [ i ] ) <NEWLINE> t2 . update ( a [ n - 1 - i ] ) <NEWLINE> t3 = t1 & t2 <NEWLINE> t1 -= t3 <NEWLINE> t2 -= t3 <NEWLINE> if t1 == t2 : <NEWLINE> <INDENT> ans += str ( i + 1 ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans [ : - 1 ] ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = deque ( list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> q = deque ( [ ] ) <NEWLINE> tmp = set ( ) <NEWLINE> for idx , i in enumerate ( a ) : <NEWLINE> <INDENT> x = idx <NEWLINE> y = i [ 0 ] <NEWLINE> if x == a [ y ] [ 0 ] : <NEWLINE> <INDENT> tmp . add ( x ) <NEWLINE> tmp . add ( y ) <NEWLINE> <DEDENT> <DEDENT> q = deque ( tmp ) <NEWLINE> for i in tmp : <NEWLINE> <INDENT> a [ i ] . popleft ( ) <NEWLINE> <NL> <NL> <DEDENT> day = 0 <NEWLINE> while True : <NEWLINE> <INDENT> day += 1 <NEWLINE> t = q . copy ( ) <NEWLINE> q = deque ( ) <NEWLINE> tmp = set ( ) <NEWLINE> while t : <NEWLINE> <INDENT> x = t . popleft ( ) <NEWLINE> if len ( a [ x ] ) == 0 : continue ; <NEWLINE> y = a [ x ] [ 0 ] <NEWLINE> if x == a [ y ] [ 0 ] : <NEWLINE> <INDENT> tmp . add ( x ) <NEWLINE> tmp . add ( y ) <NEWLINE> <DEDENT> <DEDENT> q = deque ( tmp ) <NEWLINE> for i in tmp : <NEWLINE> <INDENT> a [ i ] . popleft ( ) <NEWLINE> <DEDENT> if len ( q ) == 0 : break ; <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if len ( a [ i ] ) != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( day ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
ans = 1 <NEWLINE> n = int ( input ( ) ) <NEWLINE> arr = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> f = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= arr [ i ] <NEWLINE> <COMMENT> <NL> if ans > 10 ** 18 : <NEWLINE> <INDENT> f = 0 <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if f : print ( ans ) <NEWLINE> else : print ( - 1 ) <NEWLINE> <NL> <NL> <NL>
def solve ( n ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) [ : : - 1 ] <NEWLINE> ind = [ - 1 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ind [ b [ i ] ] = 0 <NEWLINE> <DEDENT> elif b [ i ] != b [ i - 1 ] : <NEWLINE> <INDENT> ind [ b [ i ] ] = i <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] != b [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> swap = 0 <NEWLINE> for j in range ( b [ i ] - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if ind [ j ] != - 1 or ind [ j ] >= ind [ j - 1 ] : <NEWLINE> <INDENT> swap = ind [ j ] <NEWLINE> ind [ j ] += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if n <= swap : <NEWLINE> <INDENT> swap = cnt <NEWLINE> cnt += 1 <NEWLINE> cnt %= n <NEWLINE> <DEDENT> b [ i ] , b [ swap ] = b [ swap ] , b [ i ] <NEWLINE> <DEDENT> <DEDENT> return a , b <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a , b = solve ( n ) <NEWLINE> if all ( a [ i ] != b [ i ] for i in range ( n ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , b ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> list_A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l , r = 0 , max ( list_A ) <NEWLINE> <NL> while l + 1 < r : <NEWLINE> <INDENT> m , cnt = ( r + l ) // 2 , 0 <NEWLINE> <NL> for a in list_A : <NEWLINE> <INDENT> cnt += ( a - 1 ) // m <NEWLINE> <NL> <DEDENT> if cnt > k : <NEWLINE> <INDENT> l = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = m <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maps = { } <NEWLINE> <NL> for i , a in enumerate ( As ) : <NEWLINE> <INDENT> maps [ i ] = a - 1 <NEWLINE> <NL> <DEDENT> probs = [ 0 ] * n <NEWLINE> p = 0 <COMMENT> <NEWLINE> target = 0 <COMMENT> <NEWLINE> h = 0 <COMMENT> <NEWLINE> t = 0 <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> probs [ p ] += 1 <NEWLINE> if ( probs [ p ] == 2 ) : <NEWLINE> <INDENT> target = p <NEWLINE> t = i <NEWLINE> break <NEWLINE> <DEDENT> p = maps [ p ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> p = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( p == target ) : <NEWLINE> <INDENT> h = i <NEWLINE> break <NEWLINE> <DEDENT> p = maps [ p ] <NEWLINE> <NL> <DEDENT> s = t - h <COMMENT> <NEWLINE> if ( k <= h ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> p = maps [ p ] <NEWLINE> <DEDENT> print ( p + 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> d = ( k - h ) % s <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> p = 0 <NEWLINE> for i in range ( h + d ) : <NEWLINE> <INDENT> p = maps [ p ] <NEWLINE> <NL> <DEDENT> print ( p + 1 ) <NEWLINE>
import collections <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> px = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> c = [ [ ] for _ in range ( n ) ] <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> a , b = a - 1 , b - 1 <NEWLINE> c [ a ] . append ( b ) <NEWLINE> c [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> point = [ 0 ] * n <NEWLINE> for p , x in px : <NEWLINE> <INDENT> point [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> parents = [ 0 ] * n <NEWLINE> ans = [ 0 ] * n <NEWLINE> q = collections . deque ( ) <NEWLINE> q . append ( 0 ) <NEWLINE> while q : <NEWLINE> <INDENT> v = q . pop ( ) <NEWLINE> ans [ v ] = ans [ parents [ v ] ] + point [ v ] <NEWLINE> for i in c [ v ] : <NEWLINE> <INDENT> if i == parents [ v ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> parents [ i ] = v <NEWLINE> q . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( list ( map ( str , ans ) ) ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 1 <NEWLINE> cnt = 0 <NEWLINE> a = lst [ 0 ] <NEWLINE> if x == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> b = lst [ i ] <NEWLINE> if b < a : <NEWLINE> <INDENT> cnt += abs ( b - a ) <NEWLINE> a = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = b <NEWLINE> <DEDENT> if i >= x - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> print ( len ( set ( s ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tmp = int ( 0 ) <NEWLINE> for t in a : <NEWLINE> <INDENT> tmp ^= t <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ i ] = tmp ^ a [ i ] <NEWLINE> <NL> <DEDENT> print ( * ans ) <NEWLINE>
<STRING> <NEWLINE> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> pin = sys . stdin . readline <NEWLINE> pout = sys . stdout . write <NEWLINE> perr = sys . stderr . write <NEWLINE> <NL> N = int ( pin ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> while N : <NEWLINE> <INDENT> N -= 1 <NEWLINE> ans += chr ( 97 + N % 26 ) <NEWLINE> N = N // 26 <NEWLINE> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE> return <NEWLINE> <DEDENT> main ( ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> cho = set ( ) <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> cho . add ( A [ i ] ) <NEWLINE> <DEDENT> <DEDENT> A = list ( set ( A ) ) <NEWLINE> SUGOI = [ False ] * ( 10 ** 6 + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> for j in range ( 2 * a , 10 ** 6 + 1 , a ) : <NEWLINE> <INDENT> SUGOI [ j ] = True <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> A = list ( set ( A ) - cho ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if SUGOI [ a ] == False : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> d = { } <NEWLINE> <NL> zero = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> zero += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = math . gcd ( a , b ) <NEWLINE> a //= g <NEWLINE> b //= g <NEWLINE> if b < 0 : <NEWLINE> <INDENT> a = - a <NEWLINE> b = - b <NEWLINE> <DEDENT> if b == 0 and a == - 1 : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> if a > 0 : <NEWLINE> <INDENT> if ( a , b ) in d : <NEWLINE> <INDENT> d [ ( a , b ) ] [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ ( a , b ) ] = [ 1 , 0 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( b , - a ) in d : <NEWLINE> <INDENT> d [ ( b , - a ) ] [ 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ ( b , - a ) ] = [ 0 , 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for ( a , b ) , ( c , d ) in d . items ( ) : <NEWLINE> <INDENT> count = ( pow ( 2 , c , mod ) + pow ( 2 , d , mod ) - 1 ) % mod <NEWLINE> ans *= count <NEWLINE> ans %= mod <NEWLINE> <NL> <NL> <DEDENT> print ( ( ans + zero - 1 ) % mod ) <NEWLINE> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> A_list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> staff_count_list = [ 0 ] * N <NEWLINE> <NL> for i in A_list : <NEWLINE> <INDENT> staff_count_list [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in staff_count_list : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> path = [ 1 ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> path . append ( a [ path [ - 1 ] - 1 ] ) <NEWLINE> <NL> <DEDENT> if k > n : <NEWLINE> <INDENT> start = path . index ( path [ - 1 ] ) <NEWLINE> index = ( k - start ) % ( len ( path ) - start - 1 ) + start <NEWLINE> t = path [ index ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = path [ k ] <NEWLINE> <DEDENT> return print ( t ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = N + 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if P [ i ] < x : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> x = P [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> for a in [ * map ( int , input ( ) . split ( ) ) ] : A [ a - 1 ] += 1 <NEWLINE> print ( * A , sep = <STRING> ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> blue = a * ( n // ( a + b ) ) <NEWLINE> if n % ( a + b ) <= a : <NEWLINE> <INDENT> blue += n % ( a + b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> blue += a <NEWLINE> <DEDENT> print ( blue ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 2 * 100000 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mark = [ - 2 ] * ( n - 1 ) <NEWLINE> dist = [ 0 ] * ( n - 1 ) <NEWLINE> path = [ [ ] for _ in range ( n - 1 ) ] <NEWLINE> path0 = [ ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 2 , input ( ) . split ( ) ) <NEWLINE> if a == - 1 : <NEWLINE> <INDENT> path0 . append ( b ) <NEWLINE> dist [ b ] = 1 <NEWLINE> mark [ b ] = - 1 <NEWLINE> <DEDENT> elif b == - 1 : <NEWLINE> <INDENT> path0 . append ( a ) <NEWLINE> dist [ a ] = 1 <NEWLINE> mark [ a ] = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> path [ a ] . append ( b ) <NEWLINE> path [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> while len ( path0 ) > 0 : <NEWLINE> <INDENT> i = path0 . pop ( 0 ) <NEWLINE> d = dist [ i ] <NEWLINE> for p in path [ i ] : <NEWLINE> <INDENT> if dist [ p ] > d + 1 or dist [ p ] == 0 : <NEWLINE> <INDENT> dist [ p ] = d + 1 <NEWLINE> mark [ p ] = i <NEWLINE> path0 . append ( p ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in mark : print ( i + 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ 0 ] * ( N + 1 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> L [ i ] += 1 <NEWLINE> <DEDENT> for i in L [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> return divisors <NEWLINE> <NL> <NL> <DEDENT> d = make_divisors ( x ) <NEWLINE> <NL> <NL> for i in d : <NEWLINE> <INDENT> for b in range ( - 10000 , 10000 ) : <NEWLINE> <INDENT> a = i + b <NEWLINE> if x // i == a ** 4 + ( a ** 3 ) * b + ( a ** 2 ) * ( b ** 2 ) + a * ( b ** 3 ) + b ** 4 : <NEWLINE> <INDENT> ans = [ str ( a ) , str ( b ) ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = sum ( A ) <NEWLINE> S2 = sum ( map ( lambda x : x * x , A ) ) <NEWLINE> <NL> print ( ( S * S - S2 ) // 2 % 1000000007 ) <NEWLINE>
import numpy as np <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> counter = np . zeros ( N ) <NEWLINE> for a in A : <NEWLINE> <INDENT> counter [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for c in counter : <NEWLINE> <INDENT> print ( int ( c ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
import numpy as np <NEWLINE> <NL> <NL> def calc ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> lim = 130 <NEWLINE> <NL> result = np . zeros ( n + 1 , dtype = int ) <NEWLINE> for x in range ( 1 , lim ) : <NEWLINE> <INDENT> for y in range ( x , lim ) : <NEWLINE> <INDENT> for z in range ( y , lim ) : <NEWLINE> <INDENT> index = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if index > n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> s = set ( [ x , y , z ] ) <NEWLINE> if len ( s ) == 1 : <NEWLINE> <INDENT> result [ index ] += 1 <NEWLINE> <DEDENT> elif len ( s ) == 2 : <NEWLINE> <INDENT> result [ index ] += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result [ index ] += 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return result [ 1 : ] <NEWLINE> <NL> <NL> <DEDENT> for i in calc ( int ( input ( ) ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> r = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> r . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> s = { } <NEWLINE> <NL> for v in a : <NEWLINE> <INDENT> if v in s : <NEWLINE> <INDENT> s [ v ] += v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ v ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> p = sum ( s . values ( ) ) <NEWLINE> <NL> for t in r : <NEWLINE> <INDENT> if t [ 0 ] in s : <NEWLINE> <INDENT> n = s [ t [ 0 ] ] // t [ 0 ] * t [ 1 ] <NEWLINE> p = p - s [ t [ 0 ] ] + n <NEWLINE> if t [ 1 ] in s : <NEWLINE> <INDENT> s [ t [ 1 ] ] += n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ t [ 1 ] ] = n <NEWLINE> <DEDENT> del s [ t [ 0 ] ] <NEWLINE> <DEDENT> print ( p ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> listK = [ K * i for i in range ( 1 , 1000 ) if K * i <= 1000 ] <NEWLINE> <NL> for j in listK : <NEWLINE> <INDENT> if A <= j and j <= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l . sort ( ) <NEWLINE> <NL> cheap = l [ : k ] <NEWLINE> <NL> print ( sum ( cheap ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( B - 1 , N ) <NEWLINE> ans = ( A * x ) // B - A * ( x // B ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( al ) <NEWLINE> ss = 0 <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> d = 500000004 <NEWLINE> for a in al : <NEWLINE> <INDENT> ss += a * a <NEWLINE> <DEDENT> print ( ( ( s * s - ss ) % m * d ) % m ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = sorted ( [ int ( v ) for v in input ( ) . split ( ) ] ) <NEWLINE> <NL> over = False <NEWLINE> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> over = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if over : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> q , r = divmod ( n , 2 ) <NEWLINE> print ( a [ 0 ] + sum ( a [ 1 : q ] ) * 2 + a [ q ] * r ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] * ( max ( A ) + 1 ) <NEWLINE> count = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> for j in range ( 0 , len ( B ) , i ) : <NEWLINE> <INDENT> B [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> for k in A : <NEWLINE> <INDENT> if B [ k ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if ( i + j ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from scipy . sparse import lil_matrix , csr_matrix <NEWLINE> from scipy . sparse . csgraph import shortest_path <NEWLINE> M = 49 * 50 + 1 <NEWLINE> n , m , s = map ( int , input ( ) . split ( ) ) <NEWLINE> s = min ( s , M - 1 ) <NEWLINE> G = lil_matrix ( ( n * M , n * M ) ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b , silver , time = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> for i in range ( silver , M ) : <NEWLINE> <INDENT> G [ a * M + i , b * M + i - silver ] = time <NEWLINE> G [ b * M + i , a * M + i - silver ] = time <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> silver , time = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( M - silver ) : <NEWLINE> <INDENT> G [ i * M + j , i * M + j + silver ] = time <NEWLINE> <DEDENT> <DEDENT> G = G . tocsr ( ) <NEWLINE> G = shortest_path ( G , method = <STRING> , indices = s ) <COMMENT> <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = np . min ( G [ i * M : i * M + M ] ) <NEWLINE> print ( int ( ans ) ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> inc = abs ( N - K ) <NEWLINE> <NL> if N <= inc : <NEWLINE> <INDENT> print ( N ) <NEWLINE> <DEDENT> elif K / 2 < N % K : <NEWLINE> <INDENT> print ( K - N % K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N % K ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> one_num = x . count ( <STRING> ) <NEWLINE> <NL> ans_reduce , ans_add = 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( one_num > 1 ) : <NEWLINE> <INDENT> ans_reduce = ( ans_reduce + pow ( 2 , n - i - 1 , one_num - 1 ) * ( 1 if x [ i ] == <STRING> else 0 ) ) % ( one_num - 1 ) <NEWLINE> <DEDENT> ans_add = ( ans_add + pow ( 2 , n - i - 1 , one_num + 1 ) * ( 1 if x [ i ] == <STRING> else 0 ) ) % ( 1 + one_num ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> now_one = one_num + ( - 1 if x [ i ] == <STRING> else 1 ) <NEWLINE> if ( now_one == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> num = ( ( ans_reduce if x [ i ] == <STRING> else ans_add ) + pow ( 2 , n - i - 1 , now_one ) * ( - 1 if x [ i ] == <STRING> else 1 ) ) % now_one <NEWLINE> ans = 1 <NEWLINE> while ( num != 0 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> num = num % bin ( num ) . count ( <STRING> ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> count = 1 <NEWLINE> d = deque ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] ) <NEWLINE> <COMMENT> <NL> while count <= k : <NEWLINE> <INDENT> v = d . popleft ( ) <NEWLINE> count += 1 <NEWLINE> last = str ( v ) [ - 1 ] <NEWLINE> if last == <STRING> : <NEWLINE> <INDENT> d . append ( int ( str ( v ) + <STRING> ) ) <NEWLINE> d . append ( int ( str ( v ) + <STRING> ) ) <NEWLINE> <DEDENT> elif last == <STRING> : <NEWLINE> <INDENT> d . append ( int ( str ( v ) + <STRING> ) ) <NEWLINE> d . append ( int ( str ( v ) + <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . append ( int ( str ( v ) + str ( int ( last ) - 1 ) ) ) <NEWLINE> d . append ( int ( str ( v ) + str ( int ( last ) ) ) ) <NEWLINE> d . append ( int ( str ( v ) + str ( int ( last ) + 1 ) ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( v ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s_list = list ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> rr , bb , gg = 0 , 0 , 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if s_list [ i ] == <STRING> : <NEWLINE> <INDENT> rr = rr + 1 <NEWLINE> <DEDENT> elif s_list [ i ] == <STRING> : <NEWLINE> <INDENT> gg = gg + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bb = bb + 1 <NEWLINE> <DEDENT> <DEDENT> sum = rr * gg * bb <NEWLINE> <NL> for p in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> for q in range ( p + 1 , n - 1 ) : <NEWLINE> <INDENT> if s_list [ p ] == s_list [ q ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif 2 * q - p < n and s_list [ 2 * q - p ] != s_list [ p ] and s_list [ 2 * q - p ] != s_list [ q ] : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum - count ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> dp = [ float ( <STRING> ) ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> cost = [ int ( input ( ) ) for _ in range ( n - 1 ) ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> if dp [ i - j ] + cost [ i - 1 ] < dp [ j ] : dp [ j ] = dp [ i - j ] + cost [ i - 1 ] <COMMENT> <NEWLINE> if dp [ j ] + cost [ i - 1 ] < dp [ i - j ] : dp [ i - j ] = dp [ j ] + cost [ i - 1 ] <COMMENT> <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( dp [ n // 2 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = sum ( A ) <NEWLINE> result = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> sum -= A [ i ] <NEWLINE> result += sum * A [ i ] <NEWLINE> <NL> <DEDENT> print ( result % ( 10 ** 9 + 7 ) ) <NEWLINE>
import math <NEWLINE> import copy <NEWLINE> import sys <NEWLINE> import fractions <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> import decimal <NEWLINE> import heapq <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 100001 ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> def getInputIntList ( ) : <NEWLINE> <INDENT> outputDataList = [ ] <NEWLINE> inputData = input ( ) . split ( ) <NEWLINE> outputDataList = [ int ( n ) for n in inputData ] <NEWLINE> <NL> return outputDataList <NEWLINE> <NL> <NL> <DEDENT> def getSomeInputInt ( n ) : <NEWLINE> <INDENT> outputDataList = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inputData = int ( input ( ) ) <NEWLINE> outputDataList . append ( inputData ) <NEWLINE> <NL> <DEDENT> return outputDataList <NEWLINE> <NL> <NL> <DEDENT> def getSomeInputListInt ( n ) : <NEWLINE> <INDENT> inputDataList = [ ] <NEWLINE> outputDataList = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inputData = input ( ) . split ( ) <NEWLINE> inputDataList = [ int ( n ) for n in inputData ] <NEWLINE> outputDataList . append ( inputDataList ) <NEWLINE> <NL> <DEDENT> return outputDataList <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> dic = { } <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> if tmp in dic : <NEWLINE> <INDENT> dic [ tmp ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ tmp ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for key in dic : <NEWLINE> <INDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( key , i ) * dic [ key ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> al = np . ones ( n , dtype = <STRING> ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AB = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> AB . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for t in range ( m ) : <NEWLINE> <INDENT> A = AB [ t ] [ 0 ] <NEWLINE> B = AB [ t ] [ 1 ] <NEWLINE> <NL> bou1 = H [ A - 1 ] <NEWLINE> bou2 = H [ B - 1 ] <NEWLINE> if bou1 < bou2 : <NEWLINE> <INDENT> al [ A - 1 ] = al [ A - 1 ] - 1 <NEWLINE> <DEDENT> elif bou2 < bou1 : <NEWLINE> <INDENT> al [ B - 1 ] = al [ B - 1 ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> al [ A - 1 ] = al [ A - 1 ] - 1 <NEWLINE> al [ B - 1 ] = al [ B - 1 ] - 1 <NEWLINE> <DEDENT> <DEDENT> print ( np . count_nonzero ( al == 1 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> for x in A : <NEWLINE> <INDENT> ans *= x <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = 10 ** 18 + 1 <NEWLINE> <DEDENT> <DEDENT> print ( - 1 if ans > 10 ** 18 else ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for item in t : <NEWLINE> <INDENT> middle = int ( ( n - 1 ) / 2 ) <NEWLINE> upper = n - 1 <NEWLINE> lower = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if s [ middle ] == item : <NEWLINE> <INDENT> count += 1 <NEWLINE> break <NEWLINE> <DEDENT> elif lower >= upper : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif s [ middle ] > item : <NEWLINE> <INDENT> upper = middle <NEWLINE> middle = int ( ( lower + lower ) / 2 ) <NEWLINE> <DEDENT> elif s [ middle ] < item : <NEWLINE> <INDENT> lower = middle + 1 <NEWLINE> middle = int ( ( upper + lower ) / 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> c1 = [ ] <NEWLINE> c2 = [ ] <NEWLINE> c3 = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> sc = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if sc [ 0 ] == 1 : <NEWLINE> <INDENT> c1 . append ( sc [ 1 ] ) <NEWLINE> <DEDENT> elif sc [ 0 ] == 2 : <NEWLINE> <INDENT> c2 . append ( sc [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c3 . append ( sc [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( set ( c1 ) ) <= 1 and len ( set ( c2 ) ) <= 1 and len ( set ( c3 ) ) <= 1 : <NEWLINE> <INDENT> if 0 in list ( set ( c1 ) ) : <NEWLINE> <INDENT> if n == 1 and len ( set ( c1 ) ) == 1 and len ( set ( c2 ) ) == 0 and len ( set ( c3 ) ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> elif not c1 and not c2 and not c3 : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if list ( set ( c1 ) ) : <NEWLINE> <INDENT> ans_c1 = list ( set ( c1 ) ) [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_c1 = 1 <NEWLINE> <DEDENT> if list ( set ( c2 ) ) : <NEWLINE> <INDENT> ans_c2 = list ( set ( c2 ) ) [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_c2 = 0 <NEWLINE> <DEDENT> if list ( set ( c3 ) ) : <NEWLINE> <INDENT> ans_c3 = list ( set ( c3 ) ) [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_c3 = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( ans_c1 ) <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> print ( ans_c1 * 10 + ans_c2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans_c1 * 100 + ans_c2 * 10 + ans_c3 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> <COMMENT> <NL> A . sort ( ) <NEWLINE> MAX = 10 ** 6 + 1 <NEWLINE> L = [ 0 ] * MAX <NEWLINE> used = set ( ) <NEWLINE> <COMMENT> <NL> for a in A : <NEWLINE> <INDENT> if L [ a ] == 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if a in used : <NEWLINE> <INDENT> for i in range ( 0 , MAX , a ) : <NEWLINE> <INDENT> L [ i ] = 2 <NEWLINE> <COMMENT> <NL> <DEDENT> continue <NEWLINE> <DEDENT> used . add ( a ) <NEWLINE> <COMMENT> <NL> L [ a ] = 1 <NEWLINE> for i in range ( 2 * a , MAX , a ) : <NEWLINE> <INDENT> L [ i ] = 2 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if L [ a ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> N = N % 10 <NEWLINE> if N in ( 2 , 4 , 5 , 7 , 9 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N in ( 0 , 1 , 6 , 8 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> readline = sys . stdin . readline <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def loop ( n , k , a ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> b = np . zeros ( n + 1 , dtype = np . int64 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ max ( i - a [ i ] , 0 ) ] += 1 <NEWLINE> b [ min ( i + a [ i ] + 1 , n ) ] -= 1 <NEWLINE> <DEDENT> a = np . cumsum ( b ) [ : - 1 ] <NEWLINE> if np . all ( a == n ) : <NEWLINE> <INDENT> return ( a ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return ( a ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , k = map ( int , readline ( ) . split ( ) ) <NEWLINE> a = np . array ( readline ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> <NL> ans = loop ( n , k , a ) <NEWLINE> print ( * ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> B . sort ( ) <NEWLINE> <NL> print ( sum ( B [ 0 : N - K ] ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> numbers = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] <NEWLINE> use = [ ] <NEWLINE> for i in numbers : <NEWLINE> <INDENT> if not i in P : <NEWLINE> <INDENT> use . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ul = [ ] <NEWLINE> if 0 in use : <NEWLINE> <INDENT> for u5 in [ 0 , use [ 1 ] ] : <NEWLINE> <INDENT> for u4 in use : <NEWLINE> <INDENT> for u3 in use : <NEWLINE> <INDENT> for u2 in use : <NEWLINE> <INDENT> for u1 in use : <NEWLINE> <INDENT> ul . append ( u5 * 10000 + u4 * 1000 + u3 * 100 + u2 * 10 + u1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for u4 in use : <NEWLINE> <INDENT> for u3 in use : <NEWLINE> <INDENT> for u2 in use : <NEWLINE> <INDENT> for u1 in use : <NEWLINE> <INDENT> ul . append ( use [ 0 ] * 10000 + u4 * 1000 + u3 * 100 + u2 * 10 + u1 ) <NEWLINE> ul . append ( u4 * 1000 + u3 * 100 + u2 * 10 + u1 ) <NEWLINE> ul . append ( u3 * 100 + u2 * 10 + u1 ) <NEWLINE> ul . append ( u2 * 10 + u1 ) <NEWLINE> ul . append ( u1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ul . sort ( ) <NEWLINE> for r in ul : <NEWLINE> <INDENT> if N <= r : <NEWLINE> <INDENT> print ( r ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . add ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( S ) ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> <NL> if K % 5 == 0 or K % 2 == 0 : <NEWLINE> <INDENT> i = - 1 <NEWLINE> <DEDENT> N = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if i == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> N = ( N * 10 + 7 ) % K <NEWLINE> if N % K != 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
def dfs ( i , sum , count , rest ) : <NEWLINE> <INDENT> global ans <NEWLINE> if i == d : <NEWLINE> <INDENT> if sum < g : <NEWLINE> <INDENT> rest_max = max ( rest ) <NEWLINE> n = min ( l [ rest_max - 1 ] [ 0 ] , - ( - ( g - sum ) // ( rest_max * 100 ) ) ) <NEWLINE> count += n <NEWLINE> sum += n * rest_max * 100 <NEWLINE> <DEDENT> if sum >= g : <NEWLINE> <INDENT> ans = min ( ans , count ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dfs ( i + 1 , sum , count , rest ) <COMMENT> <NEWLINE> dfs ( i + 1 , sum + l [ i ] [ 0 ] * ( i + 1 ) * 100 + l [ i ] [ 1 ] , count + l [ i ] [ 0 ] , rest - { i + 1 } ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> d , g = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( ( map ( int , input ( ) . split ( ) ) ) ) for _ in range ( d ) ] <NEWLINE> ans = float ( <STRING> ) <NEWLINE> dfs ( 0 , 0 , 0 , set ( range ( 1 , d + 1 ) ) ) <NEWLINE> print ( ans ) <NEWLINE>
import itertools <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = sorted ( L ) <NEWLINE> ref = list ( itertools . combinations ( L , 3 ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in ref : <NEWLINE> <INDENT> Li = i [ 0 ] <NEWLINE> Lj = i [ 1 ] <NEWLINE> Lk = i [ 2 ] <NEWLINE> if Li + Lj > Lk and Lj + Lk > Li and Lk + Li > Lj : <NEWLINE> <INDENT> if Li != Lj and Lj != Lk and Lk != Li : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> def abc ( n ) : <NEWLINE> <INDENT> return ( n + 1 ) / 2 <NEWLINE> <NL> <DEDENT> cb = list ( map ( abc , c ) ) <NEWLINE> <NL> s = sum ( cb [ : b ] ) <NEWLINE> l . append ( s ) <NEWLINE> <NL> for i in range ( b , a ) : <NEWLINE> <INDENT> s = s - cb [ i - b ] + cb [ i ] <NEWLINE> l . append ( s ) <NEWLINE> <NL> <DEDENT> L = sorted ( l ) <NEWLINE> print ( L [ - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = [ 0 for i in range ( N ) ] <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in A : <NEWLINE> <INDENT> s [ i - 1 ] += 1 <NEWLINE> <DEDENT> print ( * s , sep = <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> st = [ ] <NEWLINE> for e in s : <NEWLINE> <INDENT> if e == <STRING> : <NEWLINE> <INDENT> if len ( st ) != 0 : <NEWLINE> <INDENT> st . pop ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> st . append ( int ( e ) ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , st ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> res = [ i for i in range ( 3 , n + 1 ) if ( i % 3 == 0 ) or ( <STRING> in str ( i ) ) ] <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * res ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> s_set = { input ( ) for i in range ( n ) } <NEWLINE> print ( len ( s_set ) ) <NEWLINE>
N , M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> arrR = [ 0 ] * N <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> arrR [ a - 1 ] += 1 <NEWLINE> arrR [ b - 1 ] += 1 <NEWLINE> <DEDENT> [ print ( arrR [ i ] ) for i in range ( N ) ] <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> H = [ int ( s ) for s in str ( input ( ) ) . split ( ) ] <NEWLINE> dp = np . full ( 10 ** 5 + 10 , np . inf ) <NEWLINE> <NL> def rec ( i ) : <NEWLINE> <INDENT> if dp [ i ] < np . inf : <NEWLINE> <INDENT> return dp [ i ] <NEWLINE> <NL> <DEDENT> if i == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> res = np . inf <NEWLINE> res = rec ( i - 1 ) + abs ( H [ i ] - H [ i - 1 ] ) <NEWLINE> if i > 1 : <NEWLINE> <INDENT> res = min ( res , rec ( i - 2 ) + abs ( H [ i ] - H [ i - 2 ] ) ) <NEWLINE> <NL> <DEDENT> dp [ i ] = res <NEWLINE> return dp [ i ] <NEWLINE> <NL> <DEDENT> def main3 ( ) : <NEWLINE> <INDENT> print ( int ( rec ( N - 1 ) ) ) <NEWLINE> <NL> <DEDENT> def main1 ( ) : <NEWLINE> <INDENT> dp = np . full ( 10 ** 5 + 10 , np . inf ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + abs ( H [ i ] - H [ i - 1 ] ) ) <NEWLINE> if i > 1 : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i ] , dp [ i - 2 ] + abs ( H [ i ] - H [ i - 2 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( dp [ N - 1 ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main1 ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> table = [ ] <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> table . append ( [ a , i ] ) <NEWLINE> <DEDENT> table . sort ( ) <NEWLINE> dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> baby , pos = table . pop ( ) <NEWLINE> dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + baby * abs ( pos - i + 1 ) <NEWLINE> dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + baby * abs ( pos - ( N - i ) ) <NEWLINE> for x in range ( 1 , i ) : <NEWLINE> <INDENT> y = i - x <NEWLINE> dp [ x ] [ y ] = max ( dp [ x - 1 ] [ y ] + baby * abs ( pos - x + 1 ) , dp [ x ] [ y - 1 ] + baby * abs ( pos - ( N - y ) ) ) <NEWLINE> <DEDENT> <DEDENT> print ( int ( max ( dp [ k ] [ N - k ] for k in range ( N + 1 ) ) ) ) <NEWLINE>
def erato ( n ) : <NEWLINE> <INDENT> s = list ( range ( n + 1 ) ) <NEWLINE> s [ 1 ] = 0 <NEWLINE> for e in s : <NEWLINE> <INDENT> if e : <NEWLINE> <INDENT> for i in range ( e * 2 , n + 1 , e ) : <NEWLINE> <INDENT> s [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return s <NEWLINE> <DEDENT> e = erato ( 1000000 ) <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> print ( len ( list ( filter ( lambda x : x , e [ : n + 1 ] ) ) ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
for i in range ( 10000 ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if int ( x ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> , i + 1 , <STRING> , x , sep = <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = K <NEWLINE> b = 0 <NEWLINE> for _ in range ( N - K ) : <NEWLINE> <INDENT> if A [ a ] > A [ b ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> a += 1 <NEWLINE> b += 1 <NEWLINE> <DEDENT>
from statistics import median <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> abl = [ list ( map ( int , input ( ) . split ( ) ) ) for nesya in range ( n ) ] <NEWLINE> al = [ ] <NEWLINE> bl = [ ] <NEWLINE> for ab in abl : <NEWLINE> <INDENT> al . append ( ab [ 0 ] ) <NEWLINE> bl . append ( ab [ 1 ] ) <NEWLINE> <DEDENT> if n % 2 == 1 : <NEWLINE> <INDENT> print ( median ( bl ) - median ( al ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( median ( bl ) * 2 - median ( al ) * 2 + 1 ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) - 1 ) <NEWLINE> <NL> <DEDENT> ans = - 1 <NEWLINE> push = 0 <NEWLINE> count = set ( ) <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <NL> <INDENT> if A [ push ] == 1 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> elif A [ push ] in count : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> count . add ( push ) <NEWLINE> push = A [ push ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ [ ] for n in range ( N ) ] <NEWLINE> que = deque ( [ 1 ] ) <NEWLINE> <NL> for m in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> arr [ a - 1 ] . append ( b ) <NEWLINE> arr [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> dist = [ - 1 ] * N <NEWLINE> dist [ 0 ] = 0 <NEWLINE> arr2 = [ 0 ] * ( N - 1 ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> while que : <NEWLINE> <INDENT> c = que . popleft ( ) <NEWLINE> for i in arr [ c - 1 ] : <NEWLINE> <INDENT> if dist [ i - 1 ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> dist [ i - 1 ] = 0 <NEWLINE> arr2 [ i - 2 ] = c <NEWLINE> que . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in arr2 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <NL> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 101 ) : <NEWLINE> <INDENT> p = X - i not in P <NEWLINE> p1 = X + i not in P <NEWLINE> if p1 or p : <NEWLINE> <INDENT> if p : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( X + i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> d = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n , 100000 ) : <NEWLINE> <INDENT> for j in str ( i ) : <NEWLINE> <INDENT> if int ( j ) in d : break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> mp = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> sa = i - a [ i ] <NEWLINE> if sa in mp : <NEWLINE> <INDENT> ans += mp [ sa ] <NEWLINE> <DEDENT> wa = i + a [ i ] <NEWLINE> if wa in mp : <NEWLINE> <INDENT> mp [ wa ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mp [ wa ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> abc = list ( ( a , b , c ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> dic = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 } <NEWLINE> flag = True <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if abc [ dic [ s [ i ] [ 0 ] ] ] == 0 and abc [ dic [ s [ i ] [ 1 ] ] ] == 0 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> elif sum ( abc ) == 2 and abc [ dic [ s [ i ] [ 0 ] ] ] == 1 and abc [ dic [ s [ i ] [ 1 ] ] ] == 1 and i != n - 1 : <NEWLINE> <INDENT> ps = ( set ( s [ i ] ) & set ( s [ i + 1 ] ) ) . pop ( ) <NEWLINE> ms = ( set ( s [ i ] ) - set ( ps ) ) . pop ( ) <NEWLINE> abc [ dic [ ps ] ] += 1 <NEWLINE> abc [ dic [ ms ] ] -= 1 <NEWLINE> ans [ i ] = ps <NEWLINE> <DEDENT> elif abc [ dic [ s [ i ] [ 0 ] ] ] <= abc [ dic [ s [ i ] [ 1 ] ] ] : <NEWLINE> <INDENT> abc [ dic [ s [ i ] [ 0 ] ] ] += 1 <NEWLINE> abc [ dic [ s [ i ] [ 1 ] ] ] -= 1 <NEWLINE> ans [ i ] = s [ i ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> abc [ dic [ s [ i ] [ 0 ] ] ] -= 1 <NEWLINE> abc [ dic [ s [ i ] [ 1 ] ] ] += 1 <NEWLINE> ans [ i ] = s [ i ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( math . pi * r * r , 2 * math . pi * r ) <NEWLINE>
import math ; r = float ( input ( ) ) ; print ( math . pi * ( r ** 2 ) , 2 * math . pi * r ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> ans_list = [ 0 ] <NEWLINE> e_cnt = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> e_cnt += 1 <NEWLINE> <DEDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt -= 0 <NEWLINE> <DEDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 0 <NEWLINE> e_cnt += 1 <NEWLINE> <DEDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> ans_list . append ( cnt ) <NEWLINE> <NL> <DEDENT> print ( min ( ans_list ) + e_cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> xy_sum = [ ] <NEWLINE> xy_dif = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> xy_sum . append ( x + y ) <NEWLINE> xy_dif . append ( x - y ) <NEWLINE> <NL> <DEDENT> print ( max ( abs ( max ( xy_sum ) - min ( xy_sum ) ) , abs ( max ( xy_dif ) - min ( xy_dif ) ) ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( ( a [ i ] , 1 ) ) <NEWLINE> <NL> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s . append ( ( c , b ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> s . sort ( reverse = True ) <NEWLINE> idx = 0 <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if idx + s [ i ] [ 1 ] > n : <NEWLINE> <INDENT> sum += s [ i ] [ 0 ] * ( n - idx ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> sum += s [ i ] [ 0 ] * s [ i ] [ 1 ] <NEWLINE> idx += s [ i ] [ 1 ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( sum ) <NEWLINE> <NL>
<COMMENT> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> towns = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> arrivedList = [ 1 ] <NEWLINE> for i in range ( N * 2 ) : <NEWLINE> <INDENT> arrivedList . append ( towns [ arrivedList [ - 1 ] - 1 ] ) <NEWLINE> <DEDENT> if K <= N : <NEWLINE> <INDENT> print ( arrivedList [ K ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> loop_end = N <NEWLINE> loop_start = N - 1 <NEWLINE> while ( arrivedList [ loop_end ] != arrivedList [ loop_start ] ) : <NEWLINE> <INDENT> loop_start -= 1 <NEWLINE> <NL> <DEDENT> loop_len = loop_end - loop_start <NEWLINE> <NL> <COMMENT> <NL> K = K % loop_len <NEWLINE> while K < N : <NEWLINE> <INDENT> K += loop_len <NEWLINE> <NL> <DEDENT> print ( arrivedList [ K ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = sorted ( A ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , len ( A ) ) : <NEWLINE> <INDENT> ans += A [ len ( A ) - 1 - i // 2 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = { i : [ ] for i in range ( 1 , N + 1 ) } <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d [ a ] . append ( b ) <NEWLINE> d [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> visited = [ False for _ in range ( N + 1 ) ] <NEWLINE> <NL> <NL> def visit ( x ) : <NEWLINE> <INDENT> if visited [ x ] : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> visited [ x ] = True <NEWLINE> <NL> z = 1 <NEWLINE> for y in d [ x ] : <NEWLINE> <INDENT> z += visit ( y ) <NEWLINE> <DEDENT> return z <NEWLINE> <NL> <NL> <DEDENT> m = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> r = visit ( i ) <NEWLINE> if m < r : <NEWLINE> <INDENT> m = r <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * ( n + 1 ) <NEWLINE> cnt = 0 <NEWLINE> temp = 1 <NEWLINE> rep = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if b [ temp ] == 0 : <NEWLINE> <INDENT> b [ temp ] = cnt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rep = cnt - b [ temp ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> break <NEWLINE> <DEDENT> temp = a [ temp ] <NEWLINE> <COMMENT> <NL> <DEDENT> if ( k - b [ temp ] + 1 ) >= 0 : <NEWLINE> <INDENT> for i in range ( ( k - b [ temp ] + 1 ) % rep ) : <NEWLINE> <INDENT> temp = a [ temp ] <NEWLINE> <DEDENT> print ( temp ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> temp = a [ temp ] <NEWLINE> <DEDENT> print ( temp ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> hn = [ int ( num ) for num in input ( ) . split ( ) ] <NEWLINE> <NL> hn . sort ( reverse = True ) <NEWLINE> if len ( hn ) > k : <NEWLINE> <INDENT> print ( sum ( hn [ k : ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> from math import factorial as f <NEWLINE> <NL> from math import ceil , floor , sqrt <NEWLINE> import math <NEWLINE> <NL> import bisect <NEWLINE> import re <NEWLINE> import heapq <NEWLINE> <NL> <NL> from copy import deepcopy <NEWLINE> import itertools <NEWLINE> from itertools import permutations <NEWLINE> <NL> from sys import exit <NEWLINE> <NL> ii = lambda : int ( input ( ) ) <NEWLINE> mi = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> li = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> yes = <STRING> <NEWLINE> no = <STRING> <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> l = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> n = ii ( ) <NEWLINE> tmp = 26 <NEWLINE> cnt = 1 <NEWLINE> while n > tmp : <NEWLINE> <INDENT> n -= tmp <NEWLINE> tmp *= 26 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> cnt -= 1 <NEWLINE> tmplist = [ ] <NEWLINE> while cnt > 0 : <NEWLINE> <INDENT> tmptmp = 26 ** cnt <NEWLINE> <NL> if n % tmptmp == 0 : <NEWLINE> <INDENT> tmplist . append ( n // tmptmp - 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> tmplist . append ( n // tmptmp ) <NEWLINE> <DEDENT> n %= tmptmp <NEWLINE> cnt -= 1 <NEWLINE> <DEDENT> if n % 26 == 0 : <NEWLINE> <INDENT> tmplist . append ( 25 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmplist . append ( n - 1 ) <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> for i in tmplist : <NEWLINE> <INDENT> ans += l [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> res = 1 <NEWLINE> ls = input ( ) . split ( <STRING> ) <NEWLINE> list . sort ( ls ) <NEWLINE> if int ( ls [ 0 ] ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for a in ls : <NEWLINE> <INDENT> res = res * int ( a ) <NEWLINE> if res > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
hoge1 = list ( ) <NEWLINE> hoge2 = list ( ) <NEWLINE> total = 0 <NEWLINE> for num , c in enumerate ( input ( ) ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> hoge1 . append ( num ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> if not hoge1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> last_index = hoge1 . pop ( ) <NEWLINE> S = num - last_index <NEWLINE> if not hoge2 : <NEWLINE> <INDENT> hoge2 . append ( ( last_index , S ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if last_index >= hoge2 [ - 1 ] [ 0 ] : <NEWLINE> <INDENT> hoge2 . append ( ( last_index , S ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> new_S = S <NEWLINE> for i , j in hoge2 [ : : - 1 ] : <NEWLINE> <INDENT> if last_index >= i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> new_S += hoge2 . pop ( ) [ 1 ] <NEWLINE> <DEDENT> <DEDENT> hoge2 . append ( ( last_index , new_S ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> totals = [ x [ 1 ] for x in hoge2 ] <NEWLINE> print ( sum ( totals ) ) <NEWLINE> totals . insert ( 0 , len ( hoge2 ) ) <NEWLINE> print ( <STRING> . join ( [ str ( x ) for x in totals ] ) ) <NEWLINE>
from os import path <NEWLINE> if ( path . exists ( <STRING> ) ) : <NEWLINE> <INDENT> import sys <NEWLINE> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdout = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> from math import gcd <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> a = int ( input ( ) ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> for j in range ( a ) : <NEWLINE> <INDENT> for k in range ( a ) : <NEWLINE> <INDENT> ans += gcd ( k + 1 , gcd ( i + 1 , j + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> test_case = 1 <NEWLINE> while ( test_case ) : <NEWLINE> <INDENT> solve ( ) <NEWLINE> test_case -= 1 <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = np . prod ( list ) <NEWLINE> if ans > 10 ** 18 or ans == 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> if 0 in list : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> left = [ ] <NEWLINE> right = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> tmp = input ( ) <NEWLINE> if tmp [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num , side , st = tmp . split ( ) <NEWLINE> if side == <STRING> : <NEWLINE> <INDENT> if cnt % 2 == 0 : <NEWLINE> <INDENT> left . append ( st ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right . append ( st ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if cnt % 2 == 0 : <NEWLINE> <INDENT> right . append ( st ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left . append ( st ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> left = <STRING> . join ( left ) <NEWLINE> left = left [ : : - 1 ] <NEWLINE> right = <STRING> . join ( right ) <NEWLINE> s = left + s + right <NEWLINE> if cnt % 2 == 1 : <NEWLINE> <INDENT> s = s [ : : - 1 ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
import sys <NEWLINE> from random import choice , randint <NEWLINE> inp = sys . stdin . readline <NEWLINE> out = sys . stdout . write <NEWLINE> flsh = sys . stdout . flush <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def MI ( ) : return map ( int , inp ( ) . strip ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , inp ( ) . strip ( ) . split ( ) ) ) <NEWLINE> def LLI ( ) : return [ list ( map ( int , l . split ( ) ) ) for l in sys . stdin . readlines ( ) . strip ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in inp ( ) . strip ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in inp ( ) . strip ( ) . split ( ) ] <NEWLINE> def LS ( ) : return inp ( ) . strip ( ) . split ( ) <NEWLINE> def I ( ) : return int ( inp ( ) . strip ( ) ) <NEWLINE> def F ( ) : return float ( inp ( ) . strip ( ) ) <NEWLINE> def S ( ) : return inp ( ) . strip ( ) <NEWLINE> def pf ( s ) : return out ( s + <STRING> ) <NEWLINE> def JA ( a , sep ) : return sep . join ( map ( str , a ) ) <NEWLINE> def JAA ( a , s , t ) : return s . join ( t . join ( map ( str , b ) ) for b in a ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> a , b , c , d = MI ( ) <NEWLINE> f = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if f == 0 : <NEWLINE> <INDENT> c = c - b <NEWLINE> f = 1 <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f == 1 : <NEWLINE> <INDENT> a = a - d <NEWLINE> f = 0 <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> flag = False <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] == T [ 0 ] : <NEWLINE> <INDENT> tem = i + 1 <NEWLINE> f = 1 <NEWLINE> if tem == len ( S ) : <NEWLINE> <INDENT> tem = 0 <NEWLINE> <DEDENT> for t in range ( 1 , len ( T ) ) : <NEWLINE> <INDENT> if T [ t ] == S [ tem ] : <NEWLINE> <INDENT> tem += 1 <NEWLINE> if tem == len ( S ) : <NEWLINE> <INDENT> tem = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if t == len ( T ) - 1 : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> par = list ( range ( n ) ) <NEWLINE> <NL> <NL> def find ( x ) : <NEWLINE> <INDENT> while par [ x ] != x : <NEWLINE> <INDENT> par [ x ] = par [ par [ x ] ] <NEWLINE> x = par [ x ] <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <NL> <DEDENT> def union ( x , y ) : <NEWLINE> <INDENT> x1 = find ( x ) <NEWLINE> y1 = find ( y ) <NEWLINE> if x1 != y1 : <NEWLINE> <INDENT> par [ x1 ] = y1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> s = [ 0 for i in range ( n + 1 ) ] <NEWLINE> <NL> for k in range ( n ) : <NEWLINE> <INDENT> s [ find ( k ) ] += 1 <NEWLINE> <NL> <NL> <DEDENT> print ( max ( s ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> bombs = [ ] <NEWLINE> hs = [ 0 ] * H <NEWLINE> ws = [ 0 ] * W <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> bombs . append ( tuple ( [ h - 1 , w - 1 ] ) ) <NEWLINE> hs [ h - 1 ] += 1 <NEWLINE> ws [ w - 1 ] += 1 <NEWLINE> <DEDENT> maxh = max ( hs ) <NEWLINE> maxw = max ( ws ) <NEWLINE> ans = maxh + maxw <NEWLINE> <NL> maxhindex = [ i for i , x in enumerate ( hs ) if x == maxh ] <NEWLINE> maxwindex = [ i for i , x in enumerate ( ws ) if x == maxw ] <NEWLINE> <NL> bombs = set ( bombs ) <NEWLINE> for i in maxhindex : <NEWLINE> <INDENT> for j in maxwindex : <NEWLINE> <INDENT> if ( i , j ) not in bombs : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> A [ t - 1 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> if Q - A [ i ] < K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> d = { } <NEWLINE> for i in s : <NEWLINE> <INDENT> if i not in d : <NEWLINE> <INDENT> d [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> m = max ( d . values ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> for k in d . keys ( ) : <NEWLINE> <INDENT> if d [ k ] == m : <NEWLINE> <INDENT> l . append ( k ) <NEWLINE> <NL> <DEDENT> <DEDENT> l_s = sorted ( l ) <NEWLINE> <NL> for ans in l_s : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c_sum = sum ( A ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> c_sum -= A [ i ] <NEWLINE> ans += A [ i ] * c_sum % mod <NEWLINE> <DEDENT> ans %= mod <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> kugiri = [ 0 , 26 , 702 , 18278 , 475254 , 12356630 , 321272406 , 8353082582 , 217180147158 , 5646683826134 , 146813779479510 , 3817158266467286 ] <NEWLINE> ans = <STRING> <NEWLINE> <NL> for i in range ( len ( kugiri ) ) : <NEWLINE> <INDENT> if n <= kugiri [ i ] : <NEWLINE> <INDENT> keta = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> n -= kugiri [ i - 1 ] <NEWLINE> <NL> for i in range ( keta ) : <NEWLINE> <INDENT> moji = - ( - n // 26 ** ( keta - 1 ) ) <NEWLINE> ans += chr ( moji + 96 ) <NEWLINE> n -= ( moji - 1 ) * 26 ** ( keta - 1 ) <NEWLINE> keta -= 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> N = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> Ncum = N . cumsum ( ) <NEWLINE> L = Ncum [ : - 1 ] <NEWLINE> R = Ncum [ - 1 ] - L <NEWLINE> ans = np . abs ( L - R ) . min ( ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> tree = [ None ] * n <NEWLINE> root = set ( range ( n ) ) <NEWLINE> <NL> <NL> def set_pd ( i , parent , depth ) : <NEWLINE> <INDENT> node = tree [ i ] <NEWLINE> node [ 1 ] , node [ 2 ] = parent , depth <NEWLINE> for child in node [ 0 ] : <NEWLINE> <INDENT> set_pd ( child , i , depth + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while n : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = l [ 2 : ] <NEWLINE> tree [ l [ 0 ] ] = [ c , None , None ] <NEWLINE> root -= set ( c ) <NEWLINE> n -= 1 <NEWLINE> <NL> <DEDENT> set_pd ( root . pop ( ) , - 1 , 0 ) <NEWLINE> <NL> for i , node in enumerate ( tree ) : <NEWLINE> <INDENT> c , p , d = node <NEWLINE> print ( <STRING> . format ( <NEWLINE> <INDENT> i , p , d , <STRING> if not d else <STRING> if c else <STRING> , <STRING> . join ( map ( str , c ) ) <NEWLINE> <DEDENT> ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import heapq <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> g = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> INF = float ( <STRING> ) <NEWLINE> reach = [ INF for _ in range ( N ) ] <COMMENT> <NEWLINE> reach [ 0 ] = 0 <NEWLINE> par = [ - 1 for _ in range ( N ) ] <COMMENT> <NEWLINE> <NL> Q = [ ] <NEWLINE> heapq . heappush ( Q , ( 0 , 0 ) ) <COMMENT> <NEWLINE> <NL> while Q : <NEWLINE> <INDENT> d , v = heapq . heappop ( Q ) <NEWLINE> for i in range ( len ( g [ v ] ) ) : <COMMENT> <NEWLINE> <INDENT> u = g [ v ] [ i ] <COMMENT> <NEWLINE> <COMMENT> <NL> if u == 0 : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if reach [ u ] != INF : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> reach [ u ] = d + 1 <COMMENT> <NEWLINE> par [ u ] = v <NEWLINE> heapq . heappush ( Q , ( reach [ u ] , u ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if INF not in reach [ 1 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans = par [ i ] + 1 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = [ 0 ] * N <NEWLINE> ans = 0 <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ a - 1 ] > count [ b - 1 ] : <NEWLINE> <INDENT> count [ b - 1 ] = H [ a - 1 ] <NEWLINE> <DEDENT> if H [ b - 1 ] > count [ a - 1 ] : <NEWLINE> <INDENT> count [ a - 1 ] = H [ b - 1 ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if H [ i ] > count [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> D = Counter ( D ) <NEWLINE> T = Counter ( T ) <NEWLINE> <NL> for i in T : <NEWLINE> <INDENT> D_count = D [ i ] <NEWLINE> T_count = T [ i ] <NEWLINE> if T_count > D_count : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> maxn = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> maxn = max ( maxn , uf . size ( i ) ) <NEWLINE> <DEDENT> print ( maxn ) <NEWLINE>
def inp ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def iinp ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def inps ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <DEDENT> def miinps ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def linps ( ) : <NEWLINE> <INDENT> return list ( input ( ) . split ( ) ) <NEWLINE> <DEDENT> def lmiinps ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def lmiinpsf ( n ) : <NEWLINE> <INDENT> return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> <DEDENT> n = inp ( ) <NEWLINE> m = int ( n ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> ans += int ( n [ i ] ) <NEWLINE> <NL> <DEDENT> ans %= 9 <NEWLINE> <NL> if ans == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import bisect <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import fractions <NEWLINE> import heapq <NEWLINE> import math <NEWLINE> from operator import mul <NEWLINE> from functools import reduce <NEWLINE> from functools import lru_cache <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> readline = sys . stdin . buffer . readline <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> N , M , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> nowtime = 0 <NEWLINE> <NL> Asum = [ 0 ] <NEWLINE> Bsum = [ 0 ] <NEWLINE> tmp = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> tmp += a <NEWLINE> Asum . append ( tmp ) <NEWLINE> <DEDENT> tmp = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> tmp += b <NEWLINE> Bsum . append ( tmp ) <NEWLINE> <NL> <DEDENT> maxbooks = 0 <NEWLINE> before = M <NEWLINE> bcount = M <NEWLINE> for acount in range ( N + 1 ) : <NEWLINE> <INDENT> if Asum [ acount ] > K : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> while K < Asum [ acount ] + Bsum [ bcount ] : <NEWLINE> <INDENT> bcount -= 1 <NEWLINE> <DEDENT> maxbooks = max ( maxbooks , acount + bcount ) <NEWLINE> <NL> <DEDENT> print ( maxbooks ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> ans = len ( T ) <NEWLINE> <NL> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> tmp = len ( T ) <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ j ] == S [ i + j ] : <NEWLINE> <INDENT> tmp -= 1 <NEWLINE> ans = min ( ans , tmp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bka = [ 0 ] * N <NEWLINE> bkb = [ 0 ] * M <NEWLINE> bka [ 0 ] = A [ 0 ] <NEWLINE> bkb [ 0 ] = B [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> bka [ i ] += bka [ i - 1 ] + A [ i ] <NEWLINE> <DEDENT> for j in range ( 1 , M ) : <NEWLINE> <INDENT> bkb [ j ] += bkb [ j - 1 ] + B [ j ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> c = bisect . bisect_left ( bkb , K ) <NEWLINE> if c != M : <NEWLINE> <INDENT> if bkb [ c ] == K : <NEWLINE> <INDENT> c += + 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , c ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> count = i + 1 <NEWLINE> k = K - bka [ i ] <NEWLINE> if k < 0 : continue <NEWLINE> c = bisect . bisect_left ( bkb , k ) <NEWLINE> b = c <NEWLINE> if c != M : <NEWLINE> <INDENT> if bkb [ c ] == k : <NEWLINE> <INDENT> c += count + 1 <NEWLINE> <DEDENT> else : c += count <NEWLINE> <DEDENT> else : c += count <NEWLINE> ans = max ( ans , c ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> gcd = math . gcd ( m , n ) <NEWLINE> i = 1 <NEWLINE> ans = [ ] <NEWLINE> max = int ( math . sqrt ( gcd ) ) <NEWLINE> for i in range ( 2 , max + 2 ) : <NEWLINE> <INDENT> while gcd % i == 0 : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> gcd //= i <NEWLINE> <DEDENT> <DEDENT> if gcd > 1 : <NEWLINE> <INDENT> ans . append ( n ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( ans ) ) + 1 ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> if N % K == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> elif N < K : <NEWLINE> <INDENT> if N < K / 2 : <NEWLINE> <INDENT> print ( N ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( K - N ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> N = N % K <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> CNT = defaultdict ( int ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> ima = i - a <NEWLINE> if ima in CNT : <NEWLINE> <INDENT> ans += CNT [ ima ] <NEWLINE> <NL> <DEDENT> CNT [ i + a ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys , math <NEWLINE> input = sys . stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> m = max ( a ) <NEWLINE> primes = list ( range ( m + 1 ) ) <NEWLINE> primes [ 1 ] = 0 <NEWLINE> for i in range ( 2 , m + 1 , 2 ) : primes [ i ] = 2 <NEWLINE> <NL> for i in range ( 3 , int ( m ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for j in range ( i , m + 1 , i ) : <NEWLINE> <INDENT> if primes [ j ] > i : primes [ j ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> b = [ 0 ] * ( m + 1 ) <NEWLINE> jdg_p = True <NEWLINE> for aa in a : <NEWLINE> <INDENT> aset = set ( ) <NEWLINE> while aa != 1 : <NEWLINE> <INDENT> aset . add ( primes [ aa ] ) <NEWLINE> aa //= primes [ aa ] <NEWLINE> <DEDENT> for aaset in aset : <NEWLINE> <INDENT> b [ aaset ] += 1 <NEWLINE> if b [ aaset ] >= 2 : <NEWLINE> <INDENT> jdg_p = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b [ aaset ] += 1 <NEWLINE> <DEDENT> <DEDENT> if not jdg_p : break <NEWLINE> <NL> <DEDENT> x = a [ 0 ] <NEWLINE> jdg_s = True <NEWLINE> for aa in a [ 1 : ] : <NEWLINE> <INDENT> x = math . gcd ( x , aa ) <NEWLINE> <DEDENT> if x != 1 : <NEWLINE> <INDENT> jdg_s = False <NEWLINE> <NL> <DEDENT> if jdg_p : print ( <STRING> ) <NEWLINE> elif jdg_s : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> if n == 2 : <NEWLINE> <INDENT> exit ( print ( max ( a ) ) ) <NEWLINE> <DEDENT> b = [ a [ 0 ] , a [ 1 ] ] <NEWLINE> ans = a [ 0 ] <NEWLINE> a = a [ 1 : ] <NEWLINE> from math import floor <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> num = floor ( i / 2 ) <NEWLINE> ans += a [ num ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in li_a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> w = li_a [ 0 ] <NEWLINE> for a in li_a [ 1 : ] : <NEWLINE> <INDENT> w = w * a <NEWLINE> if w > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( w ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( sys . stdin . readline ( ) . rstrip ( <STRING> ) ) <NEWLINE> l = [ int ( s ) for s in sys . stdin . readline ( ) . rstrip ( <STRING> ) . split ( ) ] <NEWLINE> s = 1 <NEWLINE> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in l : <NEWLINE> <INDENT> s *= i <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
m = [ ] <NEWLINE> f = [ ] <NEWLINE> r = [ ] <NEWLINE> while ( True ) : <NEWLINE> <INDENT> M , F , R = map ( int , input ( ) . split ( ) ) <NEWLINE> if M == - 1 and F == - 1 and R == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m . append ( M ) <NEWLINE> f . append ( F ) <NEWLINE> r . append ( R ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( m ) ) : <NEWLINE> <INDENT> score = m [ i ] + f [ i ] <NEWLINE> if ( m [ i ] == - 1 or f [ i ] == - 1 ) or score < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif score >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 65 <= score < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 50 <= score < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 30 <= score < 50 and r [ i ] >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 30 <= score < 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A + B >= K > A : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> import numpy as np <NEWLINE> <NL> num_count = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> num_count = np . array ( num_count ) <NEWLINE> tmp = np . arange ( 10 ** 5 + 1 ) <NEWLINE> tmp_sum = sum ( A ) <NEWLINE> for i in A : <NEWLINE> <INDENT> num_count [ i ] += 1 <NEWLINE> <NL> <DEDENT> for q in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp_C = C * ( num_count [ B ] ) <NEWLINE> tmp_B = B * ( num_count [ B ] ) <NEWLINE> num_count [ C ] += num_count [ B ] <NEWLINE> num_count [ B ] = 0 <NEWLINE> tmp_sum = tmp_sum + tmp_C - tmp_B <NEWLINE> print ( tmp_sum ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> p5 = [ ] <NEWLINE> m = 1000 <NEWLINE> for i in range ( - m , m + 1 ) : <NEWLINE> <INDENT> p5 . append ( i ** 5 ) <NEWLINE> <NL> <DEDENT> for ci in range ( 2 * m + 1 ) : <NEWLINE> <INDENT> if p5 [ ci ] - x in p5 : <NEWLINE> <INDENT> a = [ ci - m , p5 . index ( p5 [ ci ] - x ) - m ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> a = [ str ( i ) for i in a ] <NEWLINE> print ( <STRING> . join ( a ) ) <NEWLINE>
print ( input ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> town = [ False ] * ( N + 1 ) <NEWLINE> visited_town = [ ] <NEWLINE> p = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if town [ p ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> visited_town . append ( p ) <NEWLINE> town [ p ] = True <NEWLINE> p = A [ p - 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> m = visited_town . index ( p ) <NEWLINE> <NL> <COMMENT> <NL> c = len ( visited_town ) - m <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if K <= m : <NEWLINE> <INDENT> print ( visited_town [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( visited_town [ m + ( K - m ) % c ] ) <NEWLINE> <DEDENT>
nums = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> current = nums [ 0 ] <NEWLINE> num = nums [ 1 ] <NEWLINE> move = nums [ 2 ] <NEWLINE> <NL> <NL> current = abs ( current ) <NEWLINE> <NL> res = current // move <NEWLINE> <NL> if res >= num : <NEWLINE> <INDENT> print ( current - move * num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> current = current - move * res <NEWLINE> num -= res <NEWLINE> if num % 2 == 0 : <NEWLINE> <INDENT> print ( current ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( current - move ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> ary = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cmd = input ( ) . split ( ) <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> ary . appendleft ( cmd [ 1 ] ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ary . remove ( cmd [ 1 ] ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> ary . popleft ( ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> ary . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( ary ) ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> hli = [ 0 ] * h <NEWLINE> wli = [ 0 ] * w <NEWLINE> li = [ ] <NEWLINE> liset = set ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> li . append ( [ a , b ] ) <NEWLINE> liset . add ( ( a , b ) ) <NEWLINE> hli [ a - 1 ] += 1 <NEWLINE> wli [ b - 1 ] += 1 <NEWLINE> <DEDENT> a = max ( hli ) <NEWLINE> b = max ( wli ) <NEWLINE> hli2 = [ ] <NEWLINE> wli2 = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if hli [ i ] == a : <NEWLINE> <INDENT> hli2 . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( w ) : <NEWLINE> <INDENT> if wli [ i ] == b : <NEWLINE> <INDENT> wli2 . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> for i in hli2 : <NEWLINE> <INDENT> for j in wli2 : <NEWLINE> <INDENT> if ( i , j ) not in liset : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a + b - 1 ) <NEWLINE>
def abc075_d ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ ] <NEWLINE> xarr = [ ] <NEWLINE> yarr = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , y = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> P . append ( ( x , y ) ) <NEWLINE> xarr . append ( x ) <NEWLINE> yarr . append ( y ) <NEWLINE> <DEDENT> xarr . sort ( ) <NEWLINE> yarr . sort ( ) <NEWLINE> <NL> ans = 5 * 10 ** 18 <NEWLINE> for s , xi in enumerate ( xarr ) : <NEWLINE> <INDENT> for xj in xarr [ s + 1 : ] : <NEWLINE> <INDENT> cand = [ ( x , y ) for x , y in P if xi <= x and x <= xj ] <NEWLINE> for t , yi in enumerate ( yarr ) : <NEWLINE> <INDENT> for yj in yarr [ t + 1 : ] : <NEWLINE> <INDENT> cnt = len ( [ y for x , y in cand if yi <= y and y <= yj ] ) <NEWLINE> if cnt >= k : <NEWLINE> <INDENT> area = ( xj - xi ) * ( yj - yi ) <NEWLINE> ans = min ( ans , area ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> abc075_d ( ) <NEWLINE> <DEDENT>
N , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> H = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> nodes = [ 1 for i in range ( N ) ] <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if H [ a - 1 ] <= H [ b - 1 ] : <NEWLINE> <INDENT> nodes [ a - 1 ] = 0 <NEWLINE> <DEDENT> if H [ b - 1 ] <= H [ a - 1 ] : <NEWLINE> <INDENT> nodes [ b - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( nodes ) ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <DEDENT> j = M <NEWLINE> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <COMMENT> <NEWLINE> <INDENT> if a [ i ] > K : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <COMMENT> <NEWLINE> <INDENT> j -= 1 <COMMENT> <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> room = [ int ( 0 ) for i in range ( 4 ) for j in range ( 3 ) for k in range ( 10 ) ] <NEWLINE> while count < n : <NEWLINE> <INDENT> x = list ( map ( lambda k : int ( k ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> room [ ( x [ 0 ] - 1 ) * 30 + ( x [ 1 ] - 1 ) * 10 + ( x [ 2 ] - 1 ) ] += x [ 3 ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> % room [ 30 * i + 10 * j + k ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> hash_p = [ 0 ] * 102 <NEWLINE> for i in P : <NEWLINE> <INDENT> hash_p [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if hash_p [ X - i ] == 0 : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> break <NEWLINE> <DEDENT> if hash_p [ X + i ] == 0 : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r ** 2 * math . pi , 2 * r * math . pi ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> EPS = 1e-6 <NEWLINE> <NL> <NL> def yes ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> def no ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> if V - W <= 0 : <NEWLINE> <INDENT> no ( ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> t = abs ( A - B ) / ( V - W ) <NEWLINE> if t <= T : <NEWLINE> <INDENT> yes ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> no ( ) <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> mi = n + 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> mi = min ( mi , p [ i ] ) <NEWLINE> <NL> if p [ i ] == mi : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , a , b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ss = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ss . append ( input ( ) ) <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> num_dic = { <STRING> : a , <STRING> : b , <STRING> : c } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = ss [ i ] <NEWLINE> if num_dic [ s [ 0 ] ] == 0 and num_dic [ s [ 1 ] ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif num_dic [ s [ 0 ] ] > num_dic [ s [ 1 ] ] : <NEWLINE> <INDENT> num_dic [ s [ 0 ] ] -= 1 <NEWLINE> num_dic [ s [ 1 ] ] += 1 <NEWLINE> ans . append ( s [ 1 ] ) <NEWLINE> <DEDENT> elif num_dic [ s [ 0 ] ] < num_dic [ s [ 1 ] ] : <NEWLINE> <INDENT> num_dic [ s [ 0 ] ] += 1 <NEWLINE> num_dic [ s [ 1 ] ] -= 1 <NEWLINE> ans . append ( s [ 0 ] ) <NEWLINE> <DEDENT> elif i == n - 1 : <NEWLINE> <INDENT> ans . append ( s [ 0 ] ) <NEWLINE> num_dic [ s [ 0 ] ] -= 1 <NEWLINE> num_dic [ s [ 1 ] ] += 1 <NEWLINE> <DEDENT> elif s [ 0 ] in ss [ i + 1 ] : <NEWLINE> <INDENT> num_dic [ s [ 0 ] ] += 1 <NEWLINE> num_dic [ s [ 1 ] ] -= 1 <NEWLINE> ans . append ( s [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num_dic [ s [ 0 ] ] -= 1 <NEWLINE> num_dic [ s [ 1 ] ] += 1 <NEWLINE> ans . append ( s [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <COMMENT> <NEWLINE> self . parents = [ - 1 ] * n <COMMENT> <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> <COMMENT> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> <DEDENT> uf = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> i , j = map ( int , input ( ) . split ( ) ) <NEWLINE> i -= 1 <NEWLINE> j -= 1 <NEWLINE> uf . union ( i , j ) <NEWLINE> <NL> <DEDENT> max_size = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if uf . parents [ i ] < 0 : <NEWLINE> <INDENT> size = uf . size ( i ) <NEWLINE> if max_size < size : <NEWLINE> <INDENT> max_size = size <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max_size ) <NEWLINE>
<COMMENT> <NL> <NL> class Combination_with_repetition ( ) : <NEWLINE> <INDENT> def getPattern ( self , arr : list , r : int ) -> list : <NEWLINE> <INDENT> self . _selected = [ ] <NEWLINE> self . _all_pattern = [ ] <NEWLINE> <NL> self . _make ( arr , r ) <NEWLINE> return self . _all_pattern <NEWLINE> <NL> <DEDENT> def _make ( self , arr : list , r : int ) : <NEWLINE> <INDENT> if r == 0 : <NEWLINE> <INDENT> self . _all_pattern . append ( self . _selected [ : ] ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> self . _selected . append ( arr [ i ] ) <NEWLINE> self . _make ( arr [ i : ] , r - 1 ) <NEWLINE> <NL> self . _selected . pop ( ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> N , M , Q = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> abcd_list = [ list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> <NL> <COMMENT> <NL> comb_rep = Combination_with_repetition ( ) <NEWLINE> pattern = comb_rep . getPattern ( list ( range ( 1 , M + 1 ) ) , N ) <NEWLINE> <NL> <NL> max_sum = 0 <NEWLINE> <NL> for pat in pattern : <NEWLINE> <INDENT> tmp_sum = 0 <NEWLINE> <NL> for a , b , c , d in abcd_list : <NEWLINE> <INDENT> if ( pat [ b - 1 ] - pat [ a - 1 ] ) == c : <NEWLINE> <INDENT> tmp_sum += d <NEWLINE> <NL> <DEDENT> <DEDENT> max_sum = max ( max_sum , tmp_sum ) <NEWLINE> <NL> <DEDENT> print ( max_sum ) <NEWLINE>
def insert ( r , n ) : <NEWLINE> <INDENT> if 0 == len ( T ) : <NEWLINE> <INDENT> T [ n ] = [ None , None , None ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n < r : <NEWLINE> <INDENT> left = T [ r ] [ 0 ] <NEWLINE> if left == None : <NEWLINE> <INDENT> T [ r ] [ 0 ] = n <NEWLINE> T [ n ] = [ None , None , r ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> insert ( left , n ) <NEWLINE> <DEDENT> <DEDENT> if r < n : <NEWLINE> <INDENT> right = T [ r ] [ 1 ] <NEWLINE> if right == None : <NEWLINE> <INDENT> T [ r ] [ 1 ] = n <NEWLINE> T [ n ] = [ None , None , r ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> insert ( right , n ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def find ( n ) : <NEWLINE> <INDENT> if n in T : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def dele ( r , n ) : <NEWLINE> <INDENT> z = T [ n ] <NEWLINE> left = z [ 0 ] <NEWLINE> right = z [ 1 ] <NEWLINE> p = z [ 2 ] <NEWLINE> if left is None and right is None : <NEWLINE> <INDENT> i = T [ p ] . index ( n ) <NEWLINE> T [ p ] [ i ] = None <NEWLINE> del T [ n ] <NEWLINE> <DEDENT> elif left is None and right is not None : <NEWLINE> <INDENT> x = T [ p ] . index ( n ) <NEWLINE> T [ p ] [ x ] = right <NEWLINE> T [ right ] [ 2 ] = z [ 2 ] <NEWLINE> del T [ n ] <NEWLINE> <DEDENT> elif left is not None and right is None : <NEWLINE> <INDENT> x = T [ p ] . index ( n ) <NEWLINE> T [ p ] [ x ] = left <NEWLINE> T [ left ] [ 2 ] = z [ 2 ] <NEWLINE> del T [ n ] <NEWLINE> <DEDENT> elif left is not None and right is not None : <NEWLINE> <INDENT> inorder = list ( map ( int , print_inorder ( r ) . split ( ) ) ) <NEWLINE> next_n = inorder [ inorder . index ( n ) + 1 ] <NEWLINE> if r == n : <NEWLINE> <INDENT> r = next_n <NEWLINE> <DEDENT> dele ( r , next_n ) <NEWLINE> T [ next_n ] = T [ n ] <NEWLINE> del T [ n ] <NEWLINE> n_r = T [ next_n ] [ 1 ] <NEWLINE> n_p = T [ next_n ] [ 2 ] <NEWLINE> if n_r is not None : <NEWLINE> <INDENT> v = T [ n_r ] <NEWLINE> if v [ 0 ] == n : <NEWLINE> <INDENT> v [ 0 ] = next_n <NEWLINE> <DEDENT> if v [ 1 ] == n : <NEWLINE> <INDENT> v [ 1 ] = next_n <NEWLINE> <DEDENT> if v [ 2 ] == n : <NEWLINE> <INDENT> v [ 2 ] = next_n <NEWLINE> <DEDENT> <DEDENT> if n_p is not None : <NEWLINE> <INDENT> v = T [ n_p ] <NEWLINE> if v [ 0 ] == n : <NEWLINE> <INDENT> v [ 0 ] = next_n <NEWLINE> <DEDENT> if v [ 1 ] == n : <NEWLINE> <INDENT> v [ 1 ] = next_n <NEWLINE> <DEDENT> if v [ 2 ] == n : <NEWLINE> <INDENT> v [ 2 ] = next_n <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return r <NEWLINE> <NL> <DEDENT> def print_inorder ( r ) : <NEWLINE> <INDENT> left = T [ r ] [ 0 ] <NEWLINE> right = T [ r ] [ 1 ] <NEWLINE> ans = <STRING> <NEWLINE> if left != None : <NEWLINE> <INDENT> ans += print_inorder ( left ) <NEWLINE> <DEDENT> ans += <STRING> . format ( r ) <NEWLINE> if right != None : <NEWLINE> <INDENT> ans += print_inorder ( right ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def print_preorder ( r ) : <NEWLINE> <INDENT> left = T [ r ] [ 0 ] <NEWLINE> right = T [ r ] [ 1 ] <NEWLINE> ans = <STRING> . format ( r ) <NEWLINE> if left != None : <NEWLINE> <INDENT> ans += print_preorder ( left ) <NEWLINE> <DEDENT> if right != None : <NEWLINE> <INDENT> ans += print_preorder ( right ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> T = { } <NEWLINE> <NL> root = None <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inst = input ( ) <NEWLINE> if inst [ 0 ] == <STRING> : <NEWLINE> <INDENT> num = int ( inst [ 7 : ] ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> root = num <NEWLINE> <DEDENT> insert ( root , num ) <NEWLINE> <DEDENT> elif inst [ 0 ] == <STRING> : <NEWLINE> <INDENT> num = int ( inst [ 5 : ] ) <NEWLINE> if find ( num ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif inst [ 0 ] == <STRING> : <NEWLINE> <INDENT> num = int ( inst [ 7 : ] ) <NEWLINE> root = dele ( root , num ) <NEWLINE> <DEDENT> elif inst [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( print_inorder ( root ) ) <NEWLINE> print ( print_preorder ( root ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Amap = dict ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] in Amap : <NEWLINE> <INDENT> Amap [ A [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Amap [ A [ i ] ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> s = 0 <NEWLINE> for k in Amap . keys ( ) : <NEWLINE> <INDENT> s += ( int ( k ) * Amap [ k ] ) <NEWLINE> <NL> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> ans = list ( ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if B in Amap : <NEWLINE> <INDENT> if C in Amap : <NEWLINE> <INDENT> Amap [ C ] += Amap [ B ] <NEWLINE> s += ( C - B ) * Amap [ B ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Amap [ C ] = Amap [ B ] <NEWLINE> s += ( C - B ) * Amap [ B ] <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if C in Amap : <NEWLINE> <INDENT> Amap [ C ] += 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Amap [ C ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> Amap [ B ] = 0 <NEWLINE> <COMMENT> <NL> <NL> <NL> ans . append ( s ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for s in ans : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ ] <NEWLINE> if n > 1 : <NEWLINE> <INDENT> for j in range ( n - 1 ) : <NEWLINE> <INDENT> c = a [ j ] - a [ j + 1 ] <NEWLINE> if c > - 1 : <NEWLINE> <INDENT> b . append ( c ) <NEWLINE> a [ j + 1 ] = a [ j + 1 ] + c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if max ( b ) > - 1 : <NEWLINE> <INDENT> print ( sum ( b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def left ( i ) : <NEWLINE> <INDENT> return i * 2 <NEWLINE> <NL> <DEDENT> def right ( i ) : <NEWLINE> <INDENT> return i * 2 + 1 <NEWLINE> <NL> <DEDENT> def maxHeapify ( A , i ) : <NEWLINE> <INDENT> H = len ( A ) - 1 <NEWLINE> l = left ( i ) <NEWLINE> r = right ( i ) <NEWLINE> <NL> child = { } <NEWLINE> child [ i ] = A [ i ] <NEWLINE> if l <= H : <NEWLINE> <INDENT> child [ l ] = A [ l ] <NEWLINE> <DEDENT> if r <= H : <NEWLINE> <INDENT> child [ r ] = A [ r ] <NEWLINE> <DEDENT> largest = max ( child . items ( ) , key = lambda x : x [ 1 ] ) [ 0 ] <NEWLINE> <NL> <NL> if largest != i : <NEWLINE> <INDENT> A [ i ] , A [ largest ] = A [ largest ] , A [ i ] <NEWLINE> maxHeapify ( A , largest ) <NEWLINE> <NL> <DEDENT> <DEDENT> def buildMaxHeap ( A ) : <NEWLINE> <INDENT> H = len ( A ) - 1 <NEWLINE> for i in range ( H // 2 , 0 , - 1 ) : <NEWLINE> <INDENT> maxHeapify ( A , i ) <NEWLINE> <DEDENT> print ( <STRING> + <STRING> . join ( list ( map ( str , A [ 1 : ] ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> H = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] <NEWLINE> B . extend ( A ) <NEWLINE> buildMaxHeap ( B ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> arr = list ( input ( ) ) <NEWLINE> a = arr . count ( <STRING> ) <NEWLINE> b = arr . count ( <STRING> ) <NEWLINE> c = arr . count ( <STRING> ) <NEWLINE> count = a * b * c <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = i + ( j - i ) * 2 <NEWLINE> if k < N and arr [ i ] != arr [ j ] and arr [ j ] != arr [ k ] and arr [ k ] != arr [ i ] : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> count = 0 <NEWLINE> a = [ 0 for i in range ( 2019 ) ] <NEWLINE> a [ 0 ] = 1 <NEWLINE> k = 0 <NEWLINE> b = [ 0 for i in range ( n ) ] <NEWLINE> b [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> b [ i ] = b [ i - 1 ] * 10 % 2019 <NEWLINE> <DEDENT> for i in reversed ( range ( 0 , n ) ) : <NEWLINE> <INDENT> k += ( b [ n - i - 1 ] ) * int ( s [ i ] ) % 2019 <NEWLINE> a [ k % 2019 ] += 1 <NEWLINE> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] >= 2 : <NEWLINE> <INDENT> count += ( a [ i ] ) * ( a [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( ( 10 ** n - 2 * 9 ** n + 8 ** n ) % 1000000007 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 1 <NEWLINE> check = 10 ** 18 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> num = A [ i ] <NEWLINE> ans *= num <NEWLINE> if ans > check : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> elif ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> x1 , y1 , x2 , y2 = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ) <NEWLINE>
import itertools <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> ans = sum ( p [ : K ] ) <NEWLINE> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> length = int ( input ( ) ) <NEWLINE> data = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> c = Counter ( data ) <NEWLINE> <NL> for i in range ( 1 , length + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> num = len ( s ) <NEWLINE> a = [ 0 ] * ( num + 1 ) <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <INDENT> if s [ i ] is <STRING> : <NEWLINE> <INDENT> a [ i + 1 ] = max ( a [ i + 1 ] , a [ i ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> if s [ - i ] is <STRING> : <NEWLINE> <INDENT> a [ - ( i + 1 ) ] = max ( a [ - ( i + 1 ) ] , a [ - i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> import math <NEWLINE> gcd = math . gcd ( a , b ) <NEWLINE> <NL> p = [ ] <NEWLINE> for i in range ( 2 , int ( math . sqrt ( gcd ) ) + 1 ) : <NEWLINE> <INDENT> while gcd % i == 0 : <NEWLINE> <INDENT> gcd /= i <NEWLINE> p . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> p . append ( int ( gcd ) ) <NEWLINE> p . append ( 1 ) <NEWLINE> print ( len ( list ( set ( p ) ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def is_passcode_exist ( S , passcode ) : <NEWLINE> <INDENT> passcode_idx = 0 <NEWLINE> passcode_is_exist = False <NEWLINE> for c in S : <NEWLINE> <INDENT> if passcode_idx == 3 : <NEWLINE> <INDENT> passcode_is_exist = True <NEWLINE> break <NEWLINE> <DEDENT> if passcode [ passcode_idx ] == c : <NEWLINE> <INDENT> passcode_idx += 1 <NEWLINE> <DEDENT> <DEDENT> if passcode_idx == 3 : <NEWLINE> <INDENT> passcode_is_exist = True <NEWLINE> <DEDENT> return passcode_is_exist <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , 1000 ) : <NEWLINE> <INDENT> if is_passcode_exist ( S , str ( i ) . zfill ( 3 ) ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> ans = collections . Counter ( s ) <NEWLINE> print ( len ( ans ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> temp = As [ i ] <NEWLINE> if temp % 2 == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % 2 == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= 2 <NEWLINE> <DEDENT> ans += cnt <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
ans = [ ] <NEWLINE> <NL> <NL> def paint ( h , w ) : <NEWLINE> <INDENT> ans . append ( <STRING> . join ( [ <STRING> * w ] * h ) ) <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : break <NEWLINE> <NL> paint ( H , W ) <NEWLINE> <NL> <DEDENT> print ( ( <STRING> * 2 ) . join ( ans ) , <STRING> , sep = <STRING> ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s . insert ( 0 , 0 ) <NEWLINE> <NL> visited = [ 0 ] * ( n + 1 ) <NEWLINE> visited [ 1 ] = 1 <NEWLINE> q = [ 1 ] <NEWLINE> <NL> def dp ( town ) : <NEWLINE> <INDENT> if visited [ town ] == 1 : <NEWLINE> <INDENT> ans = k % ( len ( q ) ) <NEWLINE> print ( q [ ans ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited [ town ] += 1 <NEWLINE> q . append ( town ) <NEWLINE> <NL> <DEDENT> <DEDENT> i = 1 <NEWLINE> next_town = s [ 1 ] <NEWLINE> while True : <NEWLINE> <INDENT> if i == k : <NEWLINE> <INDENT> print ( next_town ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if visited [ next_town ] == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited [ next_town ] += 1 <NEWLINE> q . append ( next_town ) <NEWLINE> next_town = s [ next_town ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> index = q . index ( next_town ) <NEWLINE> q = q [ index : ] <NEWLINE> ans = ( k - i ) % len ( q ) <NEWLINE> print ( q [ ans ] ) <NEWLINE> <NL>
a , b , c = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> <NL> l = [ a , b , c ] <NEWLINE> l = sorted ( l ) <NEWLINE> <NL> print ( l [ 0 ] , l [ 1 ] , l [ 2 ] ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pos = [ ] <NEWLINE> neg = [ ] <NEWLINE> zero = [ ] <NEWLINE> for v in a : <NEWLINE> <INDENT> if v == 0 : <NEWLINE> <INDENT> zero . append ( v ) <NEWLINE> <DEDENT> elif 0 < v : <NEWLINE> <INDENT> pos . append ( v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> neg . append ( v ) <NEWLINE> <DEDENT> <DEDENT> if len ( pos ) + len ( neg ) < k : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> if len ( pos ) + len ( neg ) == k and len ( pos ) % 2 == 1 : <COMMENT> <NEWLINE> <INDENT> if len ( zero ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for v in pos : <NEWLINE> <INDENT> ans *= v <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> for v in neg : <NEWLINE> <INDENT> ans *= v <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pos . sort ( reverse = True ) <NEWLINE> neg . sort ( ) <NEWLINE> ans = 1 <NEWLINE> p , q = 0 , 0 <NEWLINE> while k > 0 : <NEWLINE> <INDENT> if p + 1 < len ( pos ) and q + 1 < len ( neg ) : <NEWLINE> <INDENT> x , y = pos [ p ] * pos [ p + 1 ] , neg [ q ] * neg [ q + 1 ] <NEWLINE> if x > y : <NEWLINE> <INDENT> ans *= x <NEWLINE> p += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= y <NEWLINE> q += 2 <NEWLINE> <DEDENT> <DEDENT> elif p + 1 < len ( pos ) : <NEWLINE> <INDENT> ans *= pos [ p ] * pos [ p + 1 ] <NEWLINE> p += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= neg [ q ] * neg [ q + 1 ] <NEWLINE> q += 2 <NEWLINE> <DEDENT> k -= 2 <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if 0 == len ( pos ) : <NEWLINE> <INDENT> if 0 < len ( zero ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> neg . sort ( reverse = True ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= neg [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pos . sort ( reverse = True ) <NEWLINE> neg . sort ( ) <NEWLINE> ans = pos [ 0 ] <NEWLINE> p , q = 1 , 0 <NEWLINE> k -= 1 <NEWLINE> while k > 0 : <NEWLINE> <INDENT> if p + 1 < len ( pos ) and q + 1 < len ( neg ) : <NEWLINE> <INDENT> x , y = pos [ p ] * pos [ p + 1 ] , neg [ q ] * neg [ q + 1 ] <NEWLINE> if x > y : <NEWLINE> <INDENT> ans *= x <NEWLINE> p += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= y <NEWLINE> q += 2 <NEWLINE> <DEDENT> <DEDENT> elif p + 1 < len ( pos ) : <NEWLINE> <INDENT> ans *= pos [ p ] * pos [ p + 1 ] <NEWLINE> p += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= neg [ q ] * neg [ q + 1 ] <NEWLINE> q += 2 <NEWLINE> <DEDENT> k -= 2 <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def check_para ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : <NEWLINE> <INDENT> if x1 == x2 and x4 == x3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return 0 <NEWLINE> <DEDENT> elif x1 == x2 or x3 == x4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return 0 <NEWLINE> <DEDENT> k1 = ( y2 - y1 ) / ( x2 - x1 ) <NEWLINE> k2 = ( y4 - y3 ) / ( x4 - x3 ) <NEWLINE> if abs ( k1 - k2 ) < 1e-10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , input ( ) . split ( ) ) <NEWLINE> check_para ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - i - j <= k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> cs = 0 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> ans = ( ans + A [ i ] * cs ) % mod <NEWLINE> cs = ( cs + A [ i ] ) % mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from collections import defaultdict <NEWLINE> from heapq import heappop , heappush <NEWLINE> N = int ( input ( ) ) <NEWLINE> edge = defaultdict ( list ) <NEWLINE> length = defaultdict ( lambda : defaultdict ( lambda : 10 ** 20 ) ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> edge [ a ] . append ( b ) <NEWLINE> edge [ b ] . append ( a ) <NEWLINE> if b < a : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> length [ a ] [ b ] = c <NEWLINE> <DEDENT> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> K -= 1 <NEWLINE> cost = [ 0 ] * N <NEWLINE> length [ K ] [ K ] = 0 <NEWLINE> targets = [ ( 0 , K ) ] <NEWLINE> cost = [ 10 ** 18 ] * N <NEWLINE> cost [ K ] = 0 <NEWLINE> visited = [ False ] * N <NEWLINE> while targets : <NEWLINE> <INDENT> c , t = heappop ( targets ) <NEWLINE> if visited [ t ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cost [ t ] = c <NEWLINE> visited [ t ] = True <NEWLINE> for v in edge [ t ] : <NEWLINE> <INDENT> if cost [ v ] > cost [ t ] + length [ min ( t , v ) ] [ max ( t , v ) ] : <NEWLINE> <INDENT> heappush ( targets , ( cost [ t ] + length [ min ( t , v ) ] [ max ( t , v ) ] , v ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> out = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> x , y = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> out . append ( cost [ x ] + cost [ y ] ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , out ) ) ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : break <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> print ( <STRING> * b ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = 0 <NEWLINE> list = [ 0 ] * N <NEWLINE> list [ N - 1 ] = A [ N - 1 ] % 1000000007 <NEWLINE> for i in range ( N - 2 , 0 , - 1 ) : <NEWLINE> <INDENT> list [ i ] = list [ i + 1 ] + A [ i ] % 1000000007 <NEWLINE> list [ i ] = list [ i ] % 1000000007 <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> S = S + A [ i ] * list [ i + 1 ] % 1000000007 <NEWLINE> <DEDENT> print ( S % ( 1000000007 ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> paths = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for _ in range ( M ) ] <NEWLINE> good_observatory = [ True ] * N <NEWLINE> for path in paths : <NEWLINE> <INDENT> if good_observatory [ path [ 0 ] - 1 ] and H [ path [ 0 ] - 1 ] <= H [ path [ 1 ] - 1 ] : <NEWLINE> <INDENT> good_observatory [ path [ 0 ] - 1 ] = False <NEWLINE> <DEDENT> if good_observatory [ path [ 1 ] - 1 ] and H [ path [ 1 ] - 1 ] <= H [ path [ 0 ] - 1 ] : <NEWLINE> <INDENT> good_observatory [ path [ 1 ] - 1 ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( boolean for boolean in good_observatory ) ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if ( h == 0 and w == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for hi in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> print ( ) <COMMENT> <NEWLINE> <DEDENT> if ( h == 0 and w == 0 ) : break <NEWLINE> <DEDENT> except ( EOFError ) : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> xy = list ( list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ) <NEWLINE> <NL> <COMMENT> <NL> x_minus_y = [ ] <NEWLINE> x_plus_y = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x_minus_y . append ( xy [ i ] [ 0 ] - xy [ i ] [ 1 ] ) <NEWLINE> x_plus_y . append ( xy [ i ] [ 0 ] + xy [ i ] [ 1 ] ) <NEWLINE> <DEDENT> x_max = max ( x_minus_y ) <NEWLINE> x_min = min ( x_minus_y ) <NEWLINE> y_max = max ( x_plus_y ) <NEWLINE> y_min = min ( x_plus_y ) <NEWLINE> <NL> if x_max - x_min >= y_max - y_min : <NEWLINE> <INDENT> print ( x_max - x_min ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y_max - y_min ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ A ] . append ( B ) <NEWLINE> graph [ B ] . append ( A ) <NEWLINE> <NL> <DEDENT> queue = deque ( [ 1 ] ) <NEWLINE> flag = [ - 1 ] * ( N + 1 ) <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> node = queue . popleft ( ) <NEWLINE> children = graph [ node ] <NEWLINE> for child in children : <NEWLINE> <INDENT> if flag [ child ] == - 1 : <NEWLINE> <INDENT> flag [ child ] = node <NEWLINE> queue . append ( child ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if - 1 in flag [ 2 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * flag [ 2 : ] , sep = <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> P = 2019 <NEWLINE> ans = 0 <NEWLINE> <NL> count = [ 0 ] * P <NEWLINE> count [ 0 ] = 1 <NEWLINE> u = 0 <NEWLINE> for i , s in enumerate ( reversed ( S ) ) : <NEWLINE> <INDENT> u = ( int ( s ) * pow ( 10 , i , P ) + u ) % P <NEWLINE> ans += count [ u ] <NEWLINE> count [ u ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def ascend ( a , b ) : <NEWLINE> <INDENT> mini = min ( A [ a : a + L ] ) <NEWLINE> ans [ a ] = mini <NEWLINE> for i in range ( a + 1 , b ) : <NEWLINE> <INDENT> if A [ i + L - 1 ] <= mini : mini = A [ i + L - 1 ] <NEWLINE> elif A [ i - 1 ] == mini : mini = min ( A [ i : i + L ] ) <NEWLINE> ans [ i ] = mini <NEWLINE> <NL> <DEDENT> <DEDENT> def descend ( a , b ) : <NEWLINE> <INDENT> mini = min ( A [ b - 1 : b + L - 1 ] ) <NEWLINE> ans [ b - 1 ] = mini <NEWLINE> for i in range ( b - 2 , a - 1 , - 1 ) : <NEWLINE> <INDENT> if A [ i ] <= mini : mini = A [ i ] <NEWLINE> elif A [ i + L ] == mini : mini = min ( A [ i : i + L ] ) <NEWLINE> ans [ i ] = mini <NEWLINE> <NL> <DEDENT> <DEDENT> [ N , L ] = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = [ None ] * ( N - L + 1 ) <NEWLINE> count = 0 ; <NEWLINE> if N > 10 ** 4 : <NEWLINE> <INDENT> for i in range ( 100 ) : <NEWLINE> <INDENT> if A [ i + 1 ] > A [ i ] : count += 1 <NEWLINE> <DEDENT> if count > 80 : descend ( 0 , N - L + 1 ) <NEWLINE> else : ascend ( 0 , N - L + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ascend ( 0 , N - L + 1 ) <NEWLINE> <DEDENT> for i in ans [ : - 1 ] : print ( i , end = <STRING> ) <NEWLINE> print ( ans [ - 1 ] ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> inp = sys . stdin . buffer . readline <NEWLINE> def inpS ( ) : return inp ( ) . rstrip ( ) . decode ( ) <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , A , B , C = map ( int , inp ( ) . split ( ) ) <NEWLINE> S = [ inpS ( ) for _ in range ( N ) ] <NEWLINE> <NL> ans = [ ] <NEWLINE> def dfs ( now , a , b , c ) : <NEWLINE> <INDENT> if now == N : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if S [ now ] == <STRING> : <NEWLINE> <INDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if 0 < a and dfs ( now + 1 , a - 1 , b + 1 , c ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> if 0 < b and dfs ( now + 1 , a + 1 , b - 1 , c ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> if S [ now ] == <STRING> : <NEWLINE> <INDENT> if a == 0 and c == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if 0 < a and dfs ( now + 1 , a - 1 , b , c + 1 ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> if 0 < c and dfs ( now + 1 , a + 1 , b , c - 1 ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> if S [ now ] == <STRING> : <NEWLINE> <INDENT> if c == 0 and b == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if 0 < b and dfs ( now + 1 , a , b - 1 , c + 1 ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> if 0 < c and dfs ( now + 1 , a , b + 1 , c - 1 ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 , A , B , C ) <NEWLINE> if len ( ans ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> [ print ( a ) for a in ans [ : : - 1 ] ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N , K , Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> scores = [ K - Q ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> scores [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for score in scores : <NEWLINE> <INDENT> if score > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 200 ) : <NEWLINE> <INDENT> ans1 = x - i <NEWLINE> ans2 = x + i <NEWLINE> if ans1 not in p : <NEWLINE> <INDENT> print ( ans1 ) <NEWLINE> break <NEWLINE> <DEDENT> if ans2 not in p : <NEWLINE> <INDENT> print ( ans2 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> <NL> for i in range ( H - 2 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> <NL> <DEDENT> print ( <STRING> * W + <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if A [ i - 1 ] <= A [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += A [ i - 1 ] - A [ i ] <NEWLINE> A [ i ] = A [ i - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> r = 0 <NEWLINE> for p in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> e = 0 <NEWLINE> while n % p == 0 : <NEWLINE> <INDENT> e += 1 <NEWLINE> n /= p <NEWLINE> <DEDENT> i = 1 <NEWLINE> while e >= i : <NEWLINE> <INDENT> e -= i <NEWLINE> r += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> print ( r ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
r = float ( input ( ) ) <NEWLINE> import math <NEWLINE> PI = math . pi <NEWLINE> S = r * r * PI <NEWLINE> L = 2 * r * PI <NEWLINE> print ( <STRING> % ( S , L ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> field = [ input ( ) for i in range ( H ) ] <NEWLINE> route_count_memory = [ [ - 1 ] * W for i in range ( H ) ] <NEWLINE> route_count_memory [ 0 ] [ 0 ] = 1 <NEWLINE> <NL> def get_route_count ( i , j ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> if route_count_memory [ i ] [ j ] != - 1 : <NEWLINE> <INDENT> return route_count_memory [ i ] [ j ] <NEWLINE> <DEDENT> if 0 <= i - 1 < H and field [ i - 1 ] [ j ] != <STRING> : <NEWLINE> <INDENT> result += get_route_count ( i - 1 , j ) <NEWLINE> <DEDENT> if 0 <= j - 1 < W and field [ i ] [ j - 1 ] != <STRING> : <NEWLINE> <INDENT> result += get_route_count ( i , j - 1 ) <NEWLINE> <DEDENT> route_count_memory [ i ] [ j ] = result <NEWLINE> return result <NEWLINE> <NL> <DEDENT> print ( get_route_count ( H - 1 , W - 1 ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
X , Y , Z = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( Z , X , Y ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( readline ( ) . rstrip ( ) ) <NEWLINE> aList = list ( map ( int , readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in aList : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for a in aList : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys , re , os <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians <NEWLINE> from itertools import permutations , combinations , product , accumulate <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def S_MAP ( ) : return map ( str , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def S_LIST ( ) : return list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N , K = MAP ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( K , N + 2 ) : <NEWLINE> <INDENT> B = N * ( N + 1 ) // 2 - ( N - i ) * ( N - i + 1 ) // 2 <NEWLINE> A = ( i - 1 ) * i // 2 <NEWLINE> ans += ( B - A + 1 ) <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
import sys <NEWLINE> a = [ c for c in input ( ) ] <NEWLINE> B = 0 <NEWLINE> W = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] == <STRING> : <NEWLINE> <INDENT> B += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> W += B <NEWLINE> <NL> <DEDENT> <DEDENT> print ( W ) <NEWLINE>
from math import sqrt <NEWLINE> def isprime ( inlst , i , sq ) : <NEWLINE> <INDENT> while sq >= i : <NEWLINE> <INDENT> inlst = [ x for x in inlst if x % i > 0 or x == i ] <NEWLINE> i += 2 <NEWLINE> <DEDENT> return inlst <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> inlst = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inlst . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> inlst = [ x for x in inlst if x % 2 > 0 or x == 2 ] <NEWLINE> i = 3 <NEWLINE> maxin = max ( inlst ) <NEWLINE> inlst = isprime ( inlst , i , int ( sqrt ( maxin ) ) + 1 ) <NEWLINE> print ( len ( inlst ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> sorted_list = sorted ( a , reverse = True ) <NEWLINE> a_max = sorted_list [ 0 ] <NEWLINE> a_sec = sorted_list [ 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] != a_max : <NEWLINE> <INDENT> print ( a_max ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a_sec ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> N , A , B = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> def solve ( N , A , B ) : <NEWLINE> <INDENT> if A > B : <NEWLINE> <INDENT> A , B = B , A <NEWLINE> <DEDENT> if A == 1 : <NEWLINE> <INDENT> return pow ( 2 , N , MOD ) <NEWLINE> <DEDENT> dp1 = np . zeros ( ( N , B ) , dtype = np . int64 ) <COMMENT> <NEWLINE> dp2 = np . zeros ( ( N , B ) , dtype = np . int64 ) <COMMENT> <NEWLINE> dp1_sum = np . zeros ( N , dtype = np . int64 ) <NEWLINE> ans = 0 <NEWLINE> for n in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> if n < A : <NEWLINE> <INDENT> dp1 [ n , 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n + 1 < B : <NEWLINE> <INDENT> dp1 [ n , n + 1 ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if n > 0 : <NEWLINE> <INDENT> dp1 [ n , 1 : ] += dp1 [ n - 1 , : - 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> dp1 [ n , 1 ] += dp1_sum [ max ( 0 , n - A ) : n - 1 ] . sum ( ) % MOD <NEWLINE> <COMMENT> <NL> if n >= A + 1 < B : <NEWLINE> <INDENT> dp1 [ n , A + 1 : B ] += dp2 [ n - A - 1 , 0 : B - ( A + 1 ) ] <NEWLINE> <DEDENT> dp1 [ n ] %= MOD <NEWLINE> <COMMENT> <NL> dp1_sum [ n ] = dp1 [ n ] . sum ( ) % MOD <NEWLINE> if ( N - n - 1 ) < A : <NEWLINE> <INDENT> ans += dp1_sum [ n ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> M = B - ( N - n - 1 ) <NEWLINE> if M > 0 : <NEWLINE> <INDENT> ans += dp1 [ n , : M ] . sum ( ) % MOD <NEWLINE> <DEDENT> <DEDENT> dp2 [ n ] += dp1 [ n ] <NEWLINE> dp2 [ n , 1 : ] += dp2 [ n - 1 , : - 1 ] <NEWLINE> dp1 [ n ] %= MOD <NEWLINE> dp2 [ n ] %= MOD <NEWLINE> <DEDENT> x = pow ( 2 , N , MOD ) - ans <NEWLINE> return x % MOD <NEWLINE> <NL> <DEDENT> print ( solve ( N , A , B ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ 2 , 1 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> L = l [ i ] + l [ i + 1 ] <NEWLINE> l . append ( L ) <NEWLINE> <DEDENT> print ( l [ n ] ) <NEWLINE>
<NL> x , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> if n <= 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> p2 = [ x for x in range ( - 200 , 200 ) ] <NEWLINE> <NL> p_p2_diff = set ( p ) ^ set ( p2 ) <NEWLINE> p_p2_diff_list = list ( p_p2_diff ) <NEWLINE> <NL> min_list = [ ] <NEWLINE> for i in p_p2_diff_list : <NEWLINE> <INDENT> val = abs ( x - i ) <NEWLINE> min_list . append ( val ) <NEWLINE> <NL> <DEDENT> print ( p_p2_diff_list [ min_list . index ( min ( min_list ) ) ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> import os <NEWLINE> import random <NEWLINE> import re <NEWLINE> import sys <NEWLINE> def dpfindpath ( a ) : <NEWLINE> <INDENT> dpath = [ int ( 0 ) for _ in range ( len ( a ) ) ] <NEWLINE> dpath [ 0 ] = 0 <NEWLINE> dpath [ 1 ] = abs ( a [ 1 ] - a [ 0 ] ) <NEWLINE> for i in range ( 2 , len ( a ) ) : <NEWLINE> <INDENT> dpath [ i ] = min ( abs ( a [ i ] - a [ i - 1 ] ) + dpath [ i - 1 ] , abs ( a [ i ] - a [ i - 2 ] ) + dpath [ i - 2 ] ) <NEWLINE> <DEDENT> return dpath [ len ( a ) - 1 ] <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> <DEDENT> print ( dpfindpath ( a ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = 7 <NEWLINE> cnt = 1 <NEWLINE> l = { } <NEWLINE> while n % k != 0 : <NEWLINE> <INDENT> if n not in l : <NEWLINE> <INDENT> l [ n ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> n = ( n * 10 + 7 ) % k <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> s = 1 <NEWLINE> <NL> def tousa ( l , r ) : <NEWLINE> <INDENT> return ( ( l + r ) * ( r - l + 1 ) // 2 ) <NEWLINE> <NL> <DEDENT> for i in range ( K , N + 1 ) : <NEWLINE> <INDENT> s += ( tousa ( N - i + 1 , N ) - tousa ( 0 , i - 1 ) + 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( s % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> cnt = [ 0 ] * ( n * n + 1000 ) <NEWLINE> for a in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> cnt [ a * a + b * b + c * c + a * b + b * c + c * a ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> s = 0 <NEWLINE> <NL> def comb ( n , k ) : <NEWLINE> <INDENT> if k > n - k : <NEWLINE> <INDENT> k = n - k <NEWLINE> <DEDENT> de = 1 <NEWLINE> nu = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> de *= ( n - i ) <NEWLINE> de = de % MOD <NEWLINE> nu *= ( i + 1 ) <NEWLINE> nu = nu % MOD <NEWLINE> <DEDENT> nu = pow ( nu , - 1 , MOD ) <NEWLINE> return ( de * nu ) % MOD <NEWLINE> <NL> <DEDENT> def calc_from_step ( step ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> for i in range ( 1 + ( step // 2 ) ) : <NEWLINE> <INDENT> temp += comb ( step - i , i ) <NEWLINE> <DEDENT> return temp <NEWLINE> <NL> <NL> <DEDENT> arr = [ 1 , 1 ] <NEWLINE> steps = [ ] <NEWLINE> step = 0 <NEWLINE> s = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> l = int ( input ( ) ) - 1 <NEWLINE> steps . append ( l - s ) <NEWLINE> if s > l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if step < l - s : <NEWLINE> <INDENT> step = l - s <NEWLINE> <DEDENT> s = l + 2 <NEWLINE> <DEDENT> l = N <NEWLINE> steps . append ( l - s ) <NEWLINE> if step < l - s : <NEWLINE> <INDENT> step = l - s <NEWLINE> <NL> <DEDENT> for i in range ( step - 1 ) : <NEWLINE> <INDENT> arr . append ( ( arr [ i ] + arr [ i + 1 ] ) % MOD ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> <NL> for i in steps : <NEWLINE> <INDENT> ans *= arr [ i ] <NEWLINE> ans = ans % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> <NL> if K % 2 == 1 and A [ - 1 ] < 0 : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> ans = ans * A [ N - ( i + 1 ) ] % MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> l = 0 <NEWLINE> r = N - 1 <NEWLINE> if K % 2 == 1 : <NEWLINE> <INDENT> ans = ans * A [ r ] <NEWLINE> r -= 1 <NEWLINE> <NL> <DEDENT> for _ in range ( K // 2 ) : <NEWLINE> <INDENT> ml = A [ l ] * A [ l + 1 ] <NEWLINE> mr = A [ r ] * A [ r - 1 ] <NEWLINE> if ml > mr : <NEWLINE> <INDENT> ans = ans * ml % MOD <NEWLINE> l += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * mr % MOD <NEWLINE> r -= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> a . append ( 0 ) <NEWLINE> b = { } <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] not in b : <NEWLINE> <INDENT> for j in range ( 1 , 10 ** 6 // a [ i ] + 1 ) : <NEWLINE> <INDENT> b [ a [ i ] * j ] = 1 <NEWLINE> <DEDENT> if a [ i ] != a [ i + 1 ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( B - 1 , N ) <NEWLINE> res = int ( A * x / B ) - ( A * int ( x / B ) ) <NEWLINE> print ( res ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num = Counter ( s ) <NEWLINE> <NL> <NL> if len ( num ) <= k : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> cnt = len ( num ) - k <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> for v in sorted ( num . values ( ) ) : <NEWLINE> <INDENT> if cnt == i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += v <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys , math , collections , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> H , W , D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( H ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> LR = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> <NL> <NL> dict_map = { } <NEWLINE> for ih in range ( H ) : <NEWLINE> <INDENT> for iw in range ( W ) : <NEWLINE> <INDENT> dict_map [ A [ ih ] [ iw ] ] = ( ih , iw ) <NEWLINE> <NL> <DEDENT> <DEDENT> memo = [ - 1 ] * ( H * W + 1 ) <NEWLINE> for i in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> useMP = 0 <NEWLINE> direct = range ( i , H * W + 1 , D ) <NEWLINE> memo [ i ] = 0 <NEWLINE> for p in range ( len ( direct ) - 1 ) : <NEWLINE> <INDENT> x0 , y0 = dict_map [ direct [ p ] ] <NEWLINE> x1 , y1 = dict_map [ direct [ p + 1 ] ] <NEWLINE> dist = abs ( x0 - x1 ) + abs ( y0 - y1 ) <NEWLINE> useMP += dist <NEWLINE> memo [ direct [ p + 1 ] ] = useMP <NEWLINE> <NL> <DEDENT> <DEDENT> for q in range ( Q ) : <NEWLINE> <INDENT> L , R = LR [ q ] <NEWLINE> print ( memo [ R ] - memo [ L ] ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> max_L = 0 <NEWLINE> x = 0 <NEWLINE> if B > N : <NEWLINE> <INDENT> x = N <NEWLINE> max_L = int ( A * x / B ) - A * int ( x / B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> max_L = int ( A * x / B ) - A * int ( x / B ) <NEWLINE> <NL> <DEDENT> print ( max_L ) <NEWLINE>
<COMMENT> <NL> ( h , w , m ) , * s = [ [ * map ( int , i . split ( ) ) ] for i in open ( 0 ) ] <NEWLINE> r = [ 0 ] * ( h + 1 ) <NEWLINE> c = [ 0 ] * ( w + 1 ) <NEWLINE> for x , y in s : <NEWLINE> <INDENT> r [ x ] += 1 <NEWLINE> c [ y ] += 1 <NEWLINE> <DEDENT> R = max ( r ) <NEWLINE> nr = { i for i , x in enumerate ( r ) if x == R } <NEWLINE> C = max ( c ) <NEWLINE> nc = { i for i , x in enumerate ( c ) if x == C } <NEWLINE> count = sum ( x in nr and y in nc for x , y in s ) <NEWLINE> print ( R + C - ( len ( nr ) * len ( nc ) == count ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sumA = 0 <NEWLINE> sumB = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sumB . append ( sumB [ i ] + A [ i ] ) <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> for j in range ( N - 1 ) : <NEWLINE> <INDENT> sumA = sumA + ( A [ j ] * ( sumB [ N ] - sumB [ j + 1 ] ) ) % ( 10 ** 9 + 7 ) <NEWLINE> j = j + 1 <NEWLINE> <DEDENT> print ( sumA % ( 10 ** 9 + 7 ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> def longest_subsequence ( sequence ) : <NEWLINE> <INDENT> subsequence = [ float ( <STRING> ) for _ in range ( len ( sequence ) + 1 ) ] <NEWLINE> subsequence [ 0 ] = float ( <STRING> ) <NEWLINE> for value in sequence : <NEWLINE> <INDENT> j = bisect ( subsequence , value ) <NEWLINE> if subsequence [ j - 1 ] != value : <COMMENT> <NEWLINE> <INDENT> subsequence [ j ] = value <NEWLINE> <DEDENT> <DEDENT> return bisect_left ( dp , float ( <STRING> ) ) - 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def dfs ( vertex ) : <NEWLINE> <INDENT> visited [ vertex ] = True <NEWLINE> value = a [ vertex ] <NEWLINE> j = bisect ( subsequence , value ) <NEWLINE> previous = subsequence [ j ] <NEWLINE> if subsequence [ j - 1 ] != value : <COMMENT> <NEWLINE> <INDENT> subsequence [ j ] = value <NEWLINE> <DEDENT> ans [ vertex ] = bisect_left ( subsequence , float ( <STRING> ) ) - 1 <NEWLINE> for node in adjacent [ vertex ] : <NEWLINE> <INDENT> if not visited [ node ] : <NEWLINE> <INDENT> dfs ( node ) <NEWLINE> <DEDENT> <DEDENT> subsequence [ j ] = previous <NEWLINE> return <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> adjacent = { i : [ ] for i in range ( n ) } <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> node1 , node2 = map ( int , input ( ) . split ( ) ) <NEWLINE> node1 -= 1 <NEWLINE> node2 -= 1 <NEWLINE> adjacent [ node1 ] . append ( node2 ) <NEWLINE> adjacent [ node2 ] . append ( node1 ) <NEWLINE> <DEDENT> visited = [ False ] * n <NEWLINE> ans = [ 0 ] * n <NEWLINE> subsequence = [ float ( <STRING> ) for _ in range ( n + 1 ) ] <NEWLINE> subsequence [ 0 ] = float ( <STRING> ) <NEWLINE> dfs ( 0 ) <NEWLINE> [ print ( value ) for value in ans ] <NEWLINE>
import itertools <NEWLINE> <NL> for dn in itertools . count ( 1 ) : <NEWLINE> <INDENT> W = int ( input ( ) ) <NEWLINE> if W == 0 : break <NEWLINE> N = int ( input ( ) ) <NEWLINE> d = [ tuple ( map ( int , input ( ) . split ( <STRING> ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> v = [ 0 for _ in range ( W + 1 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( W , d [ i ] [ 1 ] - 1 , - 1 ) : <NEWLINE> <INDENT> v [ j ] = max ( v [ j ] , v [ j - d [ i ] [ 1 ] ] + d [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> % ( dn , max ( v ) , v . index ( max ( v ) ) ) ) <NEWLINE> <DEDENT>
import networkx as nx <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> G = nx . Graph ( ) <NEWLINE> <NL> G . add_edges_from ( tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ) <NEWLINE> <NL> dist = nx . shortest_path_length ( G , target = 1 ) <NEWLINE> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( min ( ( dist [ j ] , j ) for j in nx . all_neighbors ( G , i ) ) [ 1 ] ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> def popcount ( n ) : <NEWLINE> <INDENT> s = str ( bin ( n ) ) <NEWLINE> return len ( [ i for i in s if i == <STRING> ] ) <NEWLINE> <DEDENT> def f ( n ) : <NEWLINE> <INDENT> c = 1 <NEWLINE> while n != 0 : <NEWLINE> <INDENT> n = n % popcount ( n ) <NEWLINE> c = c + 1 <NEWLINE> <DEDENT> return c <NEWLINE> <DEDENT> x = int ( X , 2 ) <NEWLINE> P = popcount ( x ) <NEWLINE> F = list ( X ) <NEWLINE> L = [ 1 , 2 ] <COMMENT> <NEWLINE> M = [ 1 , 2 ] <COMMENT> <NEWLINE> if P != 1 : <NEWLINE> <INDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> L . append ( ( L [ i ] * 2 ) % ( P + 1 ) ) <NEWLINE> M . append ( ( M [ i ] * 2 ) % ( P - 1 ) ) <NEWLINE> <DEDENT> s = x % ( P + 1 ) <NEWLINE> t = x % ( P - 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if F [ i ] == <STRING> : <NEWLINE> <INDENT> q = ( t - M [ N - i - 1 ] ) % ( P - 1 ) <NEWLINE> print ( f ( q ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Q = P + 1 <NEWLINE> q = ( s + L [ N - i - 1 ] ) % ( P + 1 ) <NEWLINE> print ( f ( q ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> L . append ( 0 ) <NEWLINE> <DEDENT> s = x % 2 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if F [ i ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q = ( s + L [ N - i - 1 ] ) % 2 <NEWLINE> print ( f ( q ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> c = str ( input ( ) ) <NEWLINE> <NL> head = 0 <NEWLINE> tail = - 1 <NEWLINE> count = 0 <NEWLINE> <NL> while head < N : <NEWLINE> <INDENT> if c [ head ] == <STRING> : <NEWLINE> <INDENT> while tail >= - N and c [ tail ] == <STRING> : <NEWLINE> <INDENT> tail -= 1 <NEWLINE> <DEDENT> if head >= N + tail : <NEWLINE> <INDENT> print ( count ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> tail -= 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> head += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
print ( input ( ) [ : : - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = [ i + 1 + A [ i ] for i in range ( N ) ] <NEWLINE> R = [ j + 1 - A [ j ] for j in range ( N ) ] <NEWLINE> <NL> Ld = { } <NEWLINE> Rd = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if R [ i ] in Rd . keys ( ) : <NEWLINE> <INDENT> Rd [ R [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Rd [ R [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if L [ i ] in Rd . keys ( ) : <NEWLINE> <INDENT> ans += Rd [ L [ i ] ] <NEWLINE> <DEDENT> if L [ i ] == R [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> i_ans = 0 <NEWLINE> j_ans = 0 <NEWLINE> for i in range ( 0 , 8 ) : <NEWLINE> <INDENT> B_after = B * ( 2 ** i ) <NEWLINE> if B_after > A : <NEWLINE> <INDENT> i_ans = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> B_after = B * ( 2 ** i_ans ) <NEWLINE> for j in range ( 0 , 8 ) : <NEWLINE> <INDENT> C_after = C * ( 2 ** j ) <NEWLINE> if C_after > B_after : <NEWLINE> <INDENT> j_ans = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if i_ans + j_ans <= K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from scipy . sparse import * <NEWLINE> ( n , m , s , * D ) , * t = [ map ( int , t . split ( ) ) for t in open ( 0 ) ] <NEWLINE> x = 51 <NEWLINE> r = range ( 0 , x ** 3 , x ) <NEWLINE> for u , v , a , b in t [ : m ] : <NEWLINE> <INDENT> for i in r : D += i + a * x + u , i + v , b , i + a * x + v , i + u , b <NEWLINE> <DEDENT> i = 0 <NEWLINE> for c , d in t [ m : ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> for j in r : D += j + i , j + c * x + i , d <NEWLINE> <DEDENT> d = csgraph . dijkstra ( csr_matrix ( ( D [ 2 : : 3 ] , ( D [ : : 3 ] , D [ 1 : : 3 ] ) ) , [ 8 ** 6 ] * 2 ) , 1 , min ( x * x , s ) * x + 1 ) <NEWLINE> for i in range ( 2 , n + 1 ) : print ( int ( min ( d [ i : : x ] ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n == 10000 : <NEWLINE> <INDENT> print ( 592 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> s = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if a == 2 or a == 3 : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 3 , a + 1 , 2 ) : <NEWLINE> <INDENT> if j == a : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> elif a % j == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a <= 0 and b >= 0 or ( c <= 0 and d >= 0 ) ) : <NEWLINE> <INDENT> print ( max ( a * c , b * d , a * d , b * c , 0 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( a * c , b * d , a * d , b * c ) ) <NEWLINE> <DEDENT>
from numba import njit <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> <NL> @ njit <NEWLINE> def f ( ) : <NEWLINE> <INDENT> for h in range ( 1 , 3501 ) : <NEWLINE> <INDENT> for n in range ( 1 , 3501 ) : <NEWLINE> <INDENT> x = 4 * h * n - N * n - N * h <NEWLINE> if x != 0 and N * h * n % x == 0 : <NEWLINE> <INDENT> w = N * h * n // x <NEWLINE> if w >= 1 : <NEWLINE> <INDENT> return h , n , w <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( * f ( ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( ) <NEWLINE> b = list ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> tmp_a , tmp_b = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( tmp_a ) <NEWLINE> b . append ( tmp_b ) <NEWLINE> <DEDENT> print ( min ( b ) - max ( a ) + 1 if min ( b ) - max ( a ) >= 0 else 0 ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> mod = pow ( 10 , 9 ) + 7 <NEWLINE> <NL> for k in range ( K , N + 2 ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> ans += k * ( ( N + 1 - k ) + N ) // 2 - k * ( 0 + k - 1 ) // 2 + 1 <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = 100 <NEWLINE> num = 0 <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> num = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 102 ) : <NEWLINE> <INDENT> if i not in p : <NEWLINE> <INDENT> d_temp = abs ( x - i ) <NEWLINE> if d_temp < d : <NEWLINE> <INDENT> d = d_temp <NEWLINE> num = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
import itertools <NEWLINE> k = int ( input ( ) ) <NEWLINE> def solve ( a , b ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> if b % a == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return solve ( a , b % a ) <NEWLINE> <DEDENT> <DEDENT> if a % b == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return solve ( b , a % b ) <NEWLINE> <DEDENT> <DEDENT> arr = [ i + 1 for i in range ( k ) ] <NEWLINE> l = list ( itertools . combinations_with_replacement ( arr , 3 ) ) <NEWLINE> <COMMENT> <NL> s = 0 <NEWLINE> dic = { } <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> a , b , c = i <NEWLINE> if a == b and a == c : <NEWLINE> <INDENT> s += solve ( c , solve ( a , b ) ) <NEWLINE> <DEDENT> elif a == b or b == c or a == c : <NEWLINE> <INDENT> s += 3 * ( solve ( c , solve ( a , b ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += 6 * ( solve ( c , solve ( a , b ) ) ) <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> M = K <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if A >= B : <NEWLINE> <INDENT> B = B * 2 <NEWLINE> M = K - ( i + 1 ) <NEWLINE> <DEDENT> if A < B : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> C = C * ( 2 ** M ) <NEWLINE> if C > B and A < B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> <NL> while s [ 0 ] != <STRING> or s [ - 1 ] != <STRING> : <NEWLINE> <INDENT> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> s . pop ( ) <NEWLINE> <DEDENT> elif s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> s . pop ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . pop ( 0 ) <NEWLINE> s . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( s ) ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> <NL> if X >= D * K : <NEWLINE> <INDENT> print ( X - D * K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= int ( X / D ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> X %= D <NEWLINE> if K % 2 : <NEWLINE> <INDENT> print ( D - X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> new_array = array <NEWLINE> t = sum ( array ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if array [ i ] > array [ i + 1 ] : <NEWLINE> <INDENT> array [ i + 1 ] = array [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( sum ( array ) - t ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> l = [ chr ( i ) for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) ] <NEWLINE> if len ( s ) == 26 : <NEWLINE> <INDENT> if s == l [ - 1 : : - 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 26 ) [ - 2 : : - 1 ] : <NEWLINE> <INDENT> for j in range ( 25 , i , - 1 ) : <NEWLINE> <INDENT> if s [ i ] < s [ j ] : <NEWLINE> <INDENT> s [ i ] = s [ j ] <NEWLINE> print ( <STRING> . join ( s [ : i + 1 ] ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 26 ) [ - 1 : : - 1 ] : <NEWLINE> <INDENT> if l [ i ] in s : <NEWLINE> <INDENT> del l [ i ] <NEWLINE> <DEDENT> <DEDENT> s . append ( l [ 0 ] ) <NEWLINE> print ( <STRING> . join ( s ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> n = N - i <NEWLINE> for j in range ( n * 2 - 1 , N , n ) : <NEWLINE> <INDENT> if b [ j ] == 1 : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> <DEDENT> if a [ n - 1 ] != tmp % 2 : <NEWLINE> <INDENT> b [ n - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if b [ i ] == 1 : <NEWLINE> <INDENT> ans . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> if ans != [ ] : <NEWLINE> <INDENT> print ( len ( ans ) ) <NEWLINE> print ( * ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> M = input ( ) <NEWLINE> N = list ( str ( N ) ) <NEWLINE> M = list ( str ( M ) ) <NEWLINE> ans = [ ] <NEWLINE> if len ( N ) > len ( M ) : <NEWLINE> <INDENT> for i in range ( len ( N ) - 1 ) : <NEWLINE> <INDENT> ans . append ( N [ i ] ) <NEWLINE> ans . append ( M [ i ] ) <NEWLINE> <DEDENT> ans . append ( N [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> ans . append ( N [ i ] ) <NEWLINE> ans . append ( M [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
import math <NEWLINE> x , k , d = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if x < 0 : <NEWLINE> <INDENT> x *= - 1 <NEWLINE> <NL> <DEDENT> if x / d >= k : <NEWLINE> <INDENT> print ( x - d * k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( k - math . ceil ( x / d ) ) % 2 == 0 : <NEWLINE> <INDENT> a = x - math . ceil ( x / d ) * d <NEWLINE> print ( a * - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = x - math . ceil ( x / d ) * d <NEWLINE> print ( a + d ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> A_MAP = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A_MAP [ str ( i + 1 ) ] = A [ i ] <NEWLINE> <NL> <DEDENT> route_hash = { <STRING> : 0 } <NEWLINE> current_pos = <STRING> <NEWLINE> next_pos = <STRING> <NEWLINE> counter = 0 <NEWLINE> breaked = False <NEWLINE> while counter < K : <NEWLINE> <INDENT> next_pos = A_MAP [ current_pos ] <NEWLINE> counter += 1 <NEWLINE> if next_pos in route_hash : <NEWLINE> <INDENT> breaked = True <NEWLINE> break <NEWLINE> <DEDENT> route_hash [ next_pos ] = counter <COMMENT> <NEWLINE> current_pos = next_pos <NEWLINE> <NL> <DEDENT> if not breaked : <NEWLINE> <INDENT> print ( current_pos ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> remain = K - counter <NEWLINE> counter -= route_hash [ next_pos ] <NEWLINE> remain = remain % counter <NEWLINE> <NL> current_pos = next_pos <NEWLINE> for i in range ( remain ) : <NEWLINE> <INDENT> next_pos = A_MAP [ current_pos ] <NEWLINE> route_hash [ next_pos ] = counter <COMMENT> <NEWLINE> current_pos = next_pos <NEWLINE> <DEDENT> print ( current_pos ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> <COMMENT> <NL> for a in range ( 1 , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> cnt += ( n - 1 ) // a <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ac = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> be = ( n - 1 ) // a <NEWLINE> ac += be <NEWLINE> <DEDENT> print ( ac ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> min_left = 2 * 10 ** 5 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> min_left = min ( min_left , p [ i ] ) <NEWLINE> if min_left >= p [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict , Counter <NEWLINE> from itertools import product , groupby , count , permutations , combinations <NEWLINE> from math import pi , sqrt <NEWLINE> from collections import deque <NEWLINE> from bisect import bisect , bisect_left , bisect_right <NEWLINE> from string import ascii_lowercase <NEWLINE> from functools import lru_cache <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> YES , Yes , yes , NO , No , no = <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> num = [ 10 ** 4 , 10 ** 8 , 10 ** 12 , 10 ** 16 , 10 ** 20 , 10 ** 24 , 10 ** 28 , 10 ** 32 , 10 ** 36 , 10 ** 40 , 10 ** 44 , 10 ** 48 , 10 ** 52 , 10 ** 56 , 10 ** 60 , 10 ** 64 , 10 ** 68 ] <NEWLINE> uni = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> while True : <NEWLINE> <INDENT> m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == 0 and n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> a = m ** n <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( num ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if a >= num [ i ] : <NEWLINE> <INDENT> ans += str ( a // num [ i ] ) + uni [ i ] <NEWLINE> a %= num [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans + str ( a if a != 0 else <STRING> ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
from math import sqrt <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = [ 0 for _ in range ( N ) ] <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> a = x ** 2 + y ** 2 + z ** 2 + x * y + x * z + y * z <NEWLINE> if a >= 1 and a <= N : <NEWLINE> <INDENT> L [ a - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for x in L : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> Ninzu = [ ] <NEWLINE> for x in input ( ) . split ( ) : <NEWLINE> <INDENT> Ninzu . append ( int ( x ) ) <NEWLINE> <NL> <DEDENT> l = collections . Counter ( Ninzu ) <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> <NL> <DEDENT> print ( 0 ) <NEWLINE>
t = list ( map ( str , input ( ) ) ) <NEWLINE> ans = t [ : ] <NEWLINE> <NL> if len ( t ) == 1 : <NEWLINE> <INDENT> if t [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans [ 0 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if t [ 0 ] == <STRING> : <NEWLINE> <INDENT> if t [ 1 ] == <STRING> : <NEWLINE> <INDENT> ans [ 0 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ 0 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , len ( t ) - 1 ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> if ans [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t [ i + 1 ] == <STRING> or t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if t [ - 1 ] == <STRING> : <NEWLINE> <INDENT> ans [ - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
M = 2019 ; t = 1 ; p = 0 ; c = [ 0 ] * M ; r = 0 <NEWLINE> for x in ( input ( ) + <STRING> ) [ : : - 1 ] : p += int ( x ) * t ; p %= M ; r += c [ p ] ; c [ p ] += 1 ; t = t * 10 % M <NEWLINE> print ( r ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( ( n * ( n - 1 ) ) // 2 ) <NEWLINE>
cnt = 0 <NEWLINE> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> L = A [ left : mid ] + [ 1000000001 ] <NEWLINE> R = A [ mid : right ] + [ 1000000001 ] <NEWLINE> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> global cnt <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = ( int ) ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mergeSort ( a , 0 , n ) <NEWLINE> print ( * a ) <NEWLINE> print ( cnt ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = set ( a ) <NEWLINE> <NL> d = { } <NEWLINE> for i in s : <NEWLINE> <INDENT> d [ i ] = 0 <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in d : <NEWLINE> <INDENT> c = d [ i ] <NEWLINE> if c < i : <NEWLINE> <INDENT> ans += c <NEWLINE> <DEDENT> elif c >= i : <NEWLINE> <INDENT> ans += c - i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> def get_prime ( n ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> prime = [ 2 ] <NEWLINE> if n > 2 : <NEWLINE> <INDENT> limit = int ( math . sqrt ( n ) ) <NEWLINE> odd = [ i for i in range ( 3 , n + 1 , 2 ) ] <NEWLINE> while limit >= odd [ 0 ] : <NEWLINE> <INDENT> prime . append ( odd [ 0 ] ) <NEWLINE> odd = [ j for j in odd if j % odd [ 0 ] != 0 ] <NEWLINE> <DEDENT> prime += odd <NEWLINE> <DEDENT> return prime <NEWLINE> <NL> <DEDENT> from collections import defaultdict <NEWLINE> def prime_factorization ( n ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return { } <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> prime = get_prime ( int ( math . sqrt ( n ) ) ) <NEWLINE> dct = defaultdict ( int ) <NEWLINE> for p in prime : <NEWLINE> <INDENT> while n % p == 0 : <NEWLINE> <INDENT> dct [ p ] += 1 <NEWLINE> n //= p <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> dct [ n ] += 1 <NEWLINE> <DEDENT> dct = dict ( dct ) <NEWLINE> return dct <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> pf = prime_factorization ( n ) <NEWLINE> <NL> Z = [ ] <NEWLINE> for k , v in pf . items ( ) : <NEWLINE> <INDENT> for i in range ( 1 , v + 1 ) : <NEWLINE> <INDENT> Z . append ( k ** i ) <NEWLINE> <DEDENT> <DEDENT> Z . sort ( ) <NEWLINE> count = 0 <NEWLINE> for z in Z : <NEWLINE> <INDENT> if n % z == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> n //= z <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> LR . append ( [ l , r + 1 ] ) <NEWLINE> <NL> <DEDENT> MOD = 998244353 <NEWLINE> dp = [ 0 ] * ( n + 1 ) <COMMENT> <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dp [ 1 ] = - 1 <NEWLINE> <NL> for i in range ( n ) : <COMMENT> <NEWLINE> <INDENT> if i > 0 : dp [ i ] += dp [ i - 1 ] <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> l , r = LR [ j ] <NEWLINE> if i + l < n : <NEWLINE> <INDENT> dp [ i + l ] += dp [ i ] <NEWLINE> dp [ i + l ] %= MOD <NEWLINE> <DEDENT> if i + r < n : <NEWLINE> <INDENT> dp [ i + r ] -= dp [ i ] <NEWLINE> dp [ i + r ] %= MOD <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ( dp [ n - 1 ] + MOD ) % MOD ) <NEWLINE>
def binarySearch ( key , arr , N ) : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = N <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if arr [ mid ] == key : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif key < arr [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <NL> <DEDENT> N1 = int ( input ( ) ) <NEWLINE> arr1 = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> N2 = int ( input ( ) ) <NEWLINE> arr2 = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> print ( sum ( [ binarySearch ( key , arr1 , N1 ) for key in arr2 ] ) ) <NEWLINE> <NL>
<COMMENT> <NL> def input_array ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = input_array ( ) <NEWLINE> acc_A = [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> acc_A . append ( acc_A [ i ] + A [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += A [ i ] * ( acc_A [ n ] - acc_A [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
S = input ( ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> List = list ( S ) <NEWLINE> res = 1 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if List [ i ] != <STRING> : <NEWLINE> <INDENT> res = List [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m != 0 : <NEWLINE> <INDENT> l = [ list ( input ( ) . split ( ) ) for i in range ( m ) ] <NEWLINE> p , s = [ list ( i ) for i in zip ( * l ) ] <NEWLINE> <DEDENT> t = [ 0 ] * n <NEWLINE> ac = 0 <NEWLINE> wa = 0 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and t [ int ( p [ i ] ) - 1 ] != <STRING> : <NEWLINE> <INDENT> t [ int ( p [ i ] ) - 1 ] += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> and t [ int ( p [ i ] ) - 1 ] != <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> wa += t [ int ( p [ i ] ) - 1 ] <NEWLINE> t [ int ( p [ i ] ) - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ac , wa ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> cnts = [ 0 ] * ( n + 1 ) <NEWLINE> sn = int ( math . sqrt ( n ) ) + 1 <NEWLINE> for x in range ( 1 , sn + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , sn + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , sn + 1 ) : <NEWLINE> <INDENT> g = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if 1 <= g <= n : <NEWLINE> <INDENT> cnts [ g ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( cnts [ i ] ) <NEWLINE> <DEDENT>
mod = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> ans = sum ( nums ) * sum ( nums ) - sum ( [ num * num for num in nums ] ) <NEWLINE> <NL> print ( ( ans // 2 ) % mod ) <NEWLINE>
t = list ( input ( ) ) <NEWLINE> t . reverse ( ) <NEWLINE> <NL> tmptmp = <STRING> <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> tmp = t [ i ] <NEWLINE> continue <NEWLINE> <DEDENT> if tmp == <STRING> and tmptmp != <STRING> : <NEWLINE> <INDENT> t [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif tmp == <STRING> and tmptmp == <STRING> and t [ i ] != <STRING> : <NEWLINE> <INDENT> t [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif tmp == <STRING> and tmptmp == <STRING> and t [ i ] == <STRING> : <NEWLINE> <INDENT> t [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> tmptmp = t [ i - 1 ] <NEWLINE> tmp = t [ i ] <NEWLINE> <NL> <DEDENT> t . reverse ( ) <NEWLINE> <NL> if len ( t ) > 1 : <NEWLINE> <INDENT> if t [ 0 ] == <STRING> and t [ 1 ] == <STRING> : <NEWLINE> <INDENT> t [ 0 ] = <STRING> <NEWLINE> <DEDENT> elif t [ 0 ] == <STRING> and t [ 1 ] == <STRING> : <NEWLINE> <INDENT> t [ 0 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( t ) == 1 : <NEWLINE> <INDENT> t [ 0 ] = <STRING> <NEWLINE> <NL> <DEDENT> t = <STRING> . join ( t ) <NEWLINE> print ( t ) <NEWLINE>
n , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n >= 10 : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r + 100 * ( 10 - n ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans = a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
_ = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> num0 , num1 , val = a [ - 1 ] , 0 , float ( <STRING> ) <NEWLINE> <NL> for i in a [ : - 1 ] : <NEWLINE> <INDENT> val0 = abs ( i - num0 / 2 ) <NEWLINE> if val0 < val : <NEWLINE> <INDENT> num1 = i <NEWLINE> val = val0 <NEWLINE> <DEDENT> <DEDENT> print ( num0 , num1 ) <NEWLINE>
import numpy as np <NEWLINE> from collections import Counter <NEWLINE> from math import sqrt <NEWLINE> from time import time <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> np_a_o = list ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> np_a = Counter ( np_a_o ) <NEWLINE> <NL> np_a_keys = set ( np_a . keys ( ) ) <NEWLINE> <NL> div_list = set ( ) <NEWLINE> key_max = max ( np_a_keys ) <NEWLINE> <NL> c = 0 <NEWLINE> <NL> for key in np_a_keys : <NEWLINE> <INDENT> for div in range ( key * 2 , key_max + 1 , key ) : <NEWLINE> <INDENT> div_list . add ( div ) <NEWLINE> <NL> <DEDENT> <DEDENT> r = np_a_keys - div_list <NEWLINE> <NL> u , count = np . unique ( np . array ( np_a_o ) , return_counts = True ) <NEWLINE> r -= set ( u [ count > 1 ] ) <NEWLINE> <NL> print ( len ( r ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = [ float ( j ) * 10 ** 10 for j in input ( ) . split ( ) ] <NEWLINE> if x2 == x1 : <NEWLINE> <INDENT> if x4 == x3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif x4 == x3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> if ( y2 - y1 ) / ( x2 - x1 ) == ( y4 - y3 ) / ( x4 - x3 ) else <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> lim = 1e18 <NEWLINE> n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , str ( input ( ) ) . split ( <STRING> ) ) ) <NEWLINE> if 0 in nums : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for num in nums : <NEWLINE> <INDENT> ans *= num <NEWLINE> if ans > lim : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> from collections import Counter <NEWLINE> arr = Counter ( A ) <NEWLINE> ans = sum ( [ i * arr [ i ] for i in arr ] ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans += ( c - b ) * arr [ b ] <NEWLINE> arr [ c ] , arr [ b ] = arr [ c ] + arr [ b ] , 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
MM = input ( ) . split ( ) <NEWLINE> A = int ( MM [ 0 ] ) <NEWLINE> B = int ( MM [ 1 ] ) <NEWLINE> list1 = [ ] <NEWLINE> for i in range ( A ) : <NEWLINE> <INDENT> aa = input ( ) <NEWLINE> if <STRING> * B == aa : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list1 . append ( list ( aa ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( B ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( len ( list1 ) ) : <NEWLINE> <INDENT> if list1 [ j ] [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count == 0 : <NEWLINE> <INDENT> for j in range ( len ( list1 ) ) : <NEWLINE> <NL> <INDENT> list1 [ j ] [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in list1 : <NEWLINE> <INDENT> if <STRING> in i : <NEWLINE> <INDENT> i . remove ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in list1 : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> if j != <STRING> : <NEWLINE> <INDENT> print ( j , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( a , K + 1 ) : <NEWLINE> <INDENT> for c in range ( b , K + 1 ) : <NEWLINE> <INDENT> A = math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> if a == b and b == c : <NEWLINE> <INDENT> ans += A <NEWLINE> <DEDENT> elif a == b or b == c : <NEWLINE> <INDENT> ans += ( A * 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ( A * 6 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
R , G , B = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> <NL> while ( K > 0 ) : <NEWLINE> <INDENT> if R >= G : <NEWLINE> <INDENT> G *= 2 <NEWLINE> K -= 1 <NEWLINE> <DEDENT> elif G >= B : <NEWLINE> <INDENT> B *= 2 <NEWLINE> K -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if R < G < B : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> S = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> n = N // i <NEWLINE> S += i * ( n * ( n + 1 ) // 2 ) <NEWLINE> <DEDENT> print ( S ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Ans = 0 <NEWLINE> C = 0 <NEWLINE> for i in range ( 1 , len ( A ) ) : <NEWLINE> <INDENT> C += A [ i - 1 ] <NEWLINE> Ans += A [ i ] * C % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( Ans % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h_ = [ 0 ] * ( h + 1 ) <NEWLINE> w_ = [ 0 ] * ( w + 1 ) <NEWLINE> plot = set ( ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> h_ [ x ] += 1 <NEWLINE> w_ [ y ] += 1 <NEWLINE> plot . add ( ( x , y ) ) <NEWLINE> <DEDENT> x = max ( h_ ) <NEWLINE> y = max ( w_ ) <NEWLINE> a = [ i for i , v in enumerate ( h_ ) if v == x ] <NEWLINE> b = [ j for j , q in enumerate ( w_ ) if q == y ] <NEWLINE> ans = x + y - 1 <NEWLINE> c = False <NEWLINE> for i in a : <NEWLINE> <INDENT> for j in b : <NEWLINE> <INDENT> if ( i , j ) not in plot : <NEWLINE> <INDENT> c = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if c : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if c : <NEWLINE> <INDENT> print ( ans + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> if 0 in l : <NEWLINE> <INDENT> return ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> x = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = x * l [ i ] <NEWLINE> if x > ( 1000000000000000000 ) : <NEWLINE> <INDENT> x = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> return str ( x ) <NEWLINE> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
from collections import Counter <NEWLINE> S = input ( ) [ : : - 1 ] <NEWLINE> MOD = 2019 <NEWLINE> X = [ 0 ] <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> X . append ( ( X [ - 1 ] + int ( s ) * pow ( 10 , i , MOD ) ) % MOD ) <NEWLINE> <DEDENT> C = Counter ( X ) <NEWLINE> print ( sum ( [ v * ( v - 1 ) // 2 for v in C . values ( ) ] ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> L [ a ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> Ng = [ False ] * ( 10 ** 6 + 1 ) <NEWLINE> for a , cnt in enumerate ( L ) : <NEWLINE> <INDENT> if cnt : <NEWLINE> <INDENT> for i in range ( a * 2 , 10 ** 6 + 1 , a ) : <NEWLINE> <INDENT> Ng [ i ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for a , ( cnt , ng ) in enumerate ( zip ( L , Ng ) ) : <NEWLINE> <INDENT> if cnt == 1 and not ng : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> import os <NEWLINE> <NL> def file_input ( ) : <NEWLINE> <INDENT> f = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdin = f <NEWLINE> <NL> <DEDENT> fact = [ 1 , 1 ] <NEWLINE> factinv = [ 1 , 1 ] <NEWLINE> inv = [ 0 , 1 ] <NEWLINE> <NL> def init_cmb ( N , p ) : <NEWLINE> <INDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % p ) <NEWLINE> inv . append ( ( - inv [ p % i ] * ( p // i ) ) % p ) <NEWLINE> factinv . append ( ( factinv [ - 1 ] * inv [ - 1 ] ) % p ) <NEWLINE> <NL> <DEDENT> <DEDENT> def cmb ( n , r , p ) : <NEWLINE> <INDENT> if ( r < 0 ) or ( n < r ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return fact [ n ] * factinv [ r ] * factinv [ n - r ] % p <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mod = 998244353 <NEWLINE> ans = 0 <NEWLINE> <NL> init_cmb ( N , mod ) <NEWLINE> for k in range ( K + 1 ) : <NEWLINE> <INDENT> ans += M * cmb ( N - 1 , k , mod ) * pow ( M - 1 , N - 1 - k , mod ) <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ln = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> visit = [ 0 ] * n <NEWLINE> now = 1 <COMMENT> <NEWLINE> before = [ ] <COMMENT> <NEWLINE> roop = [ ] <COMMENT> <NEWLINE> while visit [ now - 1 ] != 2 : <NEWLINE> <INDENT> if visit [ now - 1 ] == 0 : <NEWLINE> <INDENT> before . append ( now ) <NEWLINE> <DEDENT> elif visit [ now - 1 ] == 1 : <NEWLINE> <INDENT> roop . append ( now ) <NEWLINE> <NL> <DEDENT> visit [ now - 1 ] += 1 <NEWLINE> now = ln [ now - 1 ] <NEWLINE> <NL> <NL> <DEDENT> if k < len ( before ) : <NEWLINE> <INDENT> print ( before [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( roop [ ( ( k - len ( before ) ) % len ( roop ) ) ] ) <NEWLINE> <DEDENT>
S = set ( input ( ) ) <NEWLINE> a = set ( [ chr ( i ) for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) ] ) <NEWLINE> result = sorted ( list ( a - S ) ) <NEWLINE> if len ( result ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result [ 0 ] ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , m <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ 0 ] * 2 + [ int ( n ) for n in stdin . readline ( ) . split ( ) ] <NEWLINE> ans = [ 0 ] + [ 0 ] * N <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> ans [ A [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , product , groupby , combinations_with_replacement <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N = INT ( ) <NEWLINE> p = LIST ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> i = 0 <NEWLINE> for i , x in enumerate ( p ) : <NEWLINE> <INDENT> if i + 1 == x : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> p [ i ] , p [ i + 1 ] = p [ i + 1 ] , p [ i ] <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from collections import defaultdict <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> _ = int ( input ( ) ) <NEWLINE> S = input ( ) . rstrip ( ) <NEWLINE> indices = defaultdict ( set ) <NEWLINE> for i , c in enumerate ( S ) : <NEWLINE> <INDENT> indices [ c ] . add ( i ) <NEWLINE> <DEDENT> cnt = len ( indices [ <STRING> ] ) * len ( indices [ <STRING> ] ) * len ( indices [ <STRING> ] ) <NEWLINE> for c1 , c2 , c3 in [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> cnt -= sum ( <NEWLINE> <INDENT> ( i + j ) % 2 == 0 and ( i + j ) // 2 in indices [ c3 ] <NEWLINE> for i in indices [ c1 ] <NEWLINE> for j in indices [ c2 ] <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> a_b = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( a_b , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> <NL> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> cnt = [ [ 0 ] * 19 for _ in range ( 19 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> i2 , i5 = 0 , 0 <NEWLINE> if <STRING> in a : <NEWLINE> <INDENT> b , c = a . split ( <STRING> ) <NEWLINE> i2 -= len ( c ) <NEWLINE> i5 -= len ( c ) <NEWLINE> x = int ( b + c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = int ( a ) <NEWLINE> <DEDENT> while x % 2 == 0 : <NEWLINE> <INDENT> x //= 2 <NEWLINE> i2 += 1 <NEWLINE> <DEDENT> while x % 5 == 0 : <NEWLINE> <INDENT> x //= 5 <NEWLINE> i5 += 1 <NEWLINE> <DEDENT> i2 = min ( i2 , 9 ) <NEWLINE> i5 = min ( i5 , 9 ) <NEWLINE> cnt [ i2 + 9 ] [ i5 + 9 ] += 1 <NEWLINE> <NL> <DEDENT> csum = [ [ 0 ] * 19 for _ in range ( 19 ) ] <NEWLINE> <NL> for i in range ( 17 , - 1 , - 1 ) : <NEWLINE> <INDENT> csum [ i ] [ - 1 ] = cnt [ i ] [ - 1 ] + csum [ i + 1 ] [ - 1 ] <NEWLINE> <NL> <DEDENT> for j in range ( 17 , - 1 , - 1 ) : <NEWLINE> <INDENT> csum [ - 1 ] [ j ] = cnt [ - 1 ] [ j ] + csum [ - 1 ] [ j + 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( 17 , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( 17 , - 1 , - 1 ) : <NEWLINE> <INDENT> csum [ i ] [ j ] = csum [ i + 1 ] [ j ] + csum [ i ] [ j + 1 ] + cnt [ i ] [ j ] - csum [ i + 1 ] [ j + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 19 ) : <NEWLINE> <INDENT> for j in range ( 19 ) : <NEWLINE> <INDENT> if cnt [ i ] [ j ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> i2 = i - 9 <NEWLINE> i5 = j - 9 <NEWLINE> x = csum [ 9 - i2 ] [ 9 - i5 ] <NEWLINE> if 9 - i2 <= i and 9 - i5 <= j : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> ans += x * cnt [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> dic = { } <NEWLINE> <NL> AB = [ map ( int , input ( ) . split ( ) ) for _ in range ( m ) ] <NEWLINE> <NL> dic = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> <NL> for a , b in AB : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> <NL> dic [ a ] . append ( b ) <NEWLINE> dic [ b ] . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> queue = deque ( [ 0 ] ) <NEWLINE> visited = [ ] <NEWLINE> pre = [ - 1 ] * ( n + 1 ) <NEWLINE> <NL> <COMMENT> <NL> queue . append ( 0 ) <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> v = queue . popleft ( ) <NEWLINE> <NL> for i in dic [ v ] : <NEWLINE> <INDENT> if pre [ i ] == - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> pre [ i ] = v <NEWLINE> queue . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> if ( i == 0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> ans = pre [ i ] <NEWLINE> ans += 1 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> max_A = A [ - 1 ] <NEWLINE> cnt = Counter ( A ) <NEWLINE> admissible = [ True ] * ( max_A + 1 ) <NEWLINE> checked = [ False ] * ( max_A + 1 ) <NEWLINE> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if not admissible [ a ] or checked [ a ] : continue <NEWLINE> ans += 1 <NEWLINE> i = 2 <NEWLINE> while a * i <= max_A : <NEWLINE> <INDENT> admissible [ a * i ] = False <NEWLINE> i += 1 <NEWLINE> <DEDENT> checked [ a ] = True <NEWLINE> if cnt [ a ] > 1 : ans -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> date = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> sum0 = 0 <NEWLINE> sum1 = 0 <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> sum0 += date [ i ] <NEWLINE> <DEDENT> for i in range ( num ) : <NEWLINE> <INDENT> sum0 -= date [ i ] <NEWLINE> sum1 += date [ i ] * sum0 <NEWLINE> <DEDENT> print ( sum1 % ( 10 ** 9 + 7 ) ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> flag = True <NEWLINE> i = 0 <NEWLINE> while flag : <NEWLINE> <INDENT> if i == len ( s ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif s [ i ] != <STRING> : <NEWLINE> <INDENT> res = s [ i ] <NEWLINE> flag = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> if k > i : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> a , v = list ( map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> b , w = list ( map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> direction = 1 if b > a else - 1 <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> a = a + direction * v * t <NEWLINE> b = b + direction * w * t <NEWLINE> if direction == 1 and a >= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if direction == - 1 and a <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
f = set ( range ( 0 , 3000 , 4 ) ) <NEWLINE> h = set ( range ( 0 , 3000 , 100 ) ) <NEWLINE> fh = set ( range ( 0 , 3000 , 400 ) ) <NEWLINE> lp = ( f - h ) . union ( fh ) <NEWLINE> <NL> a = False <NEWLINE> while True : <NEWLINE> <INDENT> f , l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if f == 0 and l == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> t = set ( range ( f , l + 1 ) ) <NEWLINE> it = sorted ( list ( lp . intersection ( t ) ) ) <NEWLINE> for y in it : <NEWLINE> <INDENT> print ( y ) <NEWLINE> <DEDENT> if len ( it ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> a = True <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> lst . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> number = [ [ ] for _ in range ( n ) ] <NEWLINE> for v in lst : <NEWLINE> <INDENT> keta , num = v [ 0 ] - 1 , v [ 1 ] <NEWLINE> if number [ keta ] == [ ] : <NEWLINE> <INDENT> number [ keta ] = num <NEWLINE> <NL> <DEDENT> if number [ keta ] != num : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> if not number [ 0 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( i ) for i in number ] ) ) <NEWLINE> <DEDENT> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> if number [ 0 ] == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not number [ 0 ] : <NEWLINE> <INDENT> number [ 0 ] = 1 <NEWLINE> <DEDENT> if not number [ 1 ] : <NEWLINE> <INDENT> number [ 1 ] = 0 <NEWLINE> <DEDENT> print ( <STRING> . join ( [ str ( i ) for i in number ] ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if number [ 0 ] == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not number [ 0 ] : <NEWLINE> <INDENT> number [ 0 ] = 1 <NEWLINE> <DEDENT> if not number [ 1 ] : <NEWLINE> <INDENT> number [ 1 ] = 0 <NEWLINE> <DEDENT> if not number [ 2 ] : <NEWLINE> <INDENT> number [ 2 ] = 0 <NEWLINE> <DEDENT> print ( <STRING> . join ( [ str ( i ) for i in number ] ) ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = [ 0 ] * N <NEWLINE> p = 0 <NEWLINE> q = 1 <COMMENT> <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if i == K - 1 : <NEWLINE> <INDENT> print ( A [ q - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> q = A [ q - 1 ] <COMMENT> <NEWLINE> if r [ q - 1 ] == 0 : <NEWLINE> <INDENT> p += 1 <NEWLINE> r [ q - 1 ] += p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p += 1 <NEWLINE> y = r [ q - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> z = ( K - y ) % ( p - y ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if r [ i ] == y + z : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
MOD = 1_000_000_007 <NEWLINE> def calc_combi ( n , k ) : <NEWLINE> <INDENT> frac = 1 <NEWLINE> denomi = 1 <NEWLINE> for i in range ( n - k + 1 , n + 1 ) : <NEWLINE> <INDENT> frac = frac * i % MOD <NEWLINE> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> denomi = denomi * i % MOD <NEWLINE> <DEDENT> return frac * pow ( denomi , MOD - 2 , MOD ) <NEWLINE> <NL> <DEDENT> n , a , b = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> nca = calc_combi ( n , a ) <NEWLINE> ncb = calc_combi ( n , b ) <NEWLINE> print ( ( pow ( 2 , n , MOD ) - 1 - nca - ncb ) % MOD ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if 0 < a <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a <= b < 0 : <NEWLINE> <INDENT> if ( b - a + 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( int ( input ( ) ) for i in range ( m ) ) <NEWLINE> a . append ( 0 ) <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> b = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if a [ b ] == i : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i != 1 and i != 2 : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> elif i == 2 and a [ 0 ] == 1 : <NEWLINE> <INDENT> dp [ 2 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> dp [ 2 ] = 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] % ( 10 ** 9 + 7 ) ) <NEWLINE>
def aaa ( strArg ) : <NEWLINE> <INDENT> str = <STRING> <NEWLINE> for c in strArg : <NEWLINE> <INDENT> str += <STRING> + c <NEWLINE> <DEDENT> return str <NEWLINE> <NL> <DEDENT> n = [ int ( input ( ) ) ] <NEWLINE> <NL> house = [ <STRING> * 30 , <STRING> * 30 , <STRING> * 30 , <STRING> * 30 ] <NEWLINE> hr = <STRING> * 20 <NEWLINE> <NL> for nn in range ( n [ 0 ] ) : <NEWLINE> <INDENT> bfrv = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> b = bfrv [ 0 ] - 1 <NEWLINE> f = bfrv [ 1 ] - 1 <NEWLINE> r = bfrv [ 2 ] - 1 <NEWLINE> v = bfrv [ 3 ] <NEWLINE> <NL> pos = ( f * 10 ) + r <NEWLINE> humal = int ( house [ b ] [ pos ] ) + v <NEWLINE> <NL> house [ b ] = house [ b ] [ : pos ] + str ( humal ) + house [ b ] [ pos + 1 : ] <NEWLINE> <NL> <DEDENT> for ii in range ( 4 ) : <NEWLINE> <INDENT> print ( aaa ( house [ ii ] [ : 10 ] ) ) <NEWLINE> print ( aaa ( house [ ii ] [ 10 : 20 ] ) ) <NEWLINE> print ( aaa ( house [ ii ] [ 20 : ] ) ) <NEWLINE> if ii != 3 : <NEWLINE> <INDENT> print ( hr ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> from sys import stdin <NEWLINE> from bisect import bisect_left <NEWLINE> input = stdin . readline <NEWLINE> <NL> <NL> def main ( args ) : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> for _ in range ( t ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> houses = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if k >= n : <COMMENT> <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <NL> <NL> <DEDENT> diff = [ ] <NEWLINE> prev = houses [ 0 ] <NEWLINE> for i , h in enumerate ( houses [ 1 : ] ) : <NEWLINE> <INDENT> diff . append ( ( h - prev , i ) ) <NEWLINE> prev = h <NEWLINE> <NL> <NL> <DEDENT> diff . sort ( reverse = True ) <NEWLINE> points = diff [ : k - 1 ] <NEWLINE> <NL> <NL> cable_total = 0 <NEWLINE> prev = 0 <NEWLINE> for _ , p in points : <NEWLINE> <INDENT> cable_total += houses [ p ] - houses [ prev ] <NEWLINE> prev = p + 1 <NEWLINE> <DEDENT> if prev != ( n - 1 ) : <NEWLINE> <INDENT> cable_total += houses [ - 1 ] - houses [ prev ] <NEWLINE> <NL> <DEDENT> print ( cable_total ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> for i in range ( h - 2 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> , <STRING> * ( w - 2 ) ) ) <NEWLINE> <DEDENT> print ( <STRING> * w ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <COMMENT> <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> sum_a = sum ( A ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> sum_a -= A [ i ] <NEWLINE> ans += ( A [ i ] * ( sum_a ) ) % mod <NEWLINE> <DEDENT> ans %= mod <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n_line = int ( input ( ) ) <NEWLINE> input_list = [ tuple ( input ( ) . split ( ) ) for i in range ( n_line ) ] <NEWLINE> l = set ( [ ] ) <NEWLINE> for c , s in input_list : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> l . add ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s in l : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < k : <NEWLINE> <INDENT> k -= a <NEWLINE> a = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= k <NEWLINE> k = 0 <NEWLINE> <NL> <DEDENT> b = max ( 0 , b - k ) <NEWLINE> print ( a , b ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if ( i == j ) and ( j == k ) : <NEWLINE> <INDENT> ans += math . gcd ( i , math . gcd ( j , k ) ) <NEWLINE> <DEDENT> elif ( i == j ) or ( j == k ) : <NEWLINE> <INDENT> ans += 3 * math . gcd ( i , math . gcd ( j , k ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 6 * math . gcd ( i , math . gcd ( j , k ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <NL> <INDENT> sat_z = s - x - y <NEWLINE> <NL> if sat_z >= 0 and sat_z <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ischecked = [ 0 ] * N <NEWLINE> move = [ ] <NEWLINE> move1 = [ ] <NEWLINE> now = 0 <NEWLINE> count = 0 <NEWLINE> count1 = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> move . append ( now + 1 ) <NEWLINE> nex = A [ now ] - 1 <NEWLINE> ischecked [ now ] = 1 <NEWLINE> if ischecked [ nex ] == 1 : <NEWLINE> <INDENT> roop = nex + 1 <NEWLINE> break <NEWLINE> <DEDENT> now = nex <NEWLINE> <DEDENT> for i in range ( len ( move ) ) [ : : - 1 ] : <NEWLINE> <INDENT> move1 . append ( move [ i ] ) <NEWLINE> if move [ i ] == roop : <NEWLINE> <INDENT> b = len ( move ) - i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if K >= len ( move ) : <NEWLINE> <INDENT> n = K - len ( move ) <NEWLINE> n = n % len ( move1 ) <NEWLINE> print ( move1 [ len ( move1 ) - 1 - n ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( move [ K ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> class Dice : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . top = 1 <NEWLINE> self . south = 2 <NEWLINE> self . north = 5 <NEWLINE> self . east = 3 <NEWLINE> self . west = 4 <NEWLINE> self . bottom = 6 <NEWLINE> <NL> <DEDENT> def rotate ( self , operation ) : <NEWLINE> <INDENT> if operation == <STRING> : <NEWLINE> <INDENT> self . top , self . north , self . bottom , self . south = self . south , self . top , self . north , self . bottom <NEWLINE> <DEDENT> elif operation == <STRING> : <NEWLINE> <INDENT> self . top , self . east , self . bottom , self . west = self . west , self . top , self . east , self . bottom <NEWLINE> <DEDENT> elif operation == <STRING> : <NEWLINE> <INDENT> self . top , self . east , self . bottom , self . west = self . east , self . bottom , self . west , self . top <NEWLINE> <DEDENT> elif operation == <STRING> : <NEWLINE> <INDENT> self . top , self . north , self . bottom , self . south = self . north , self . bottom , self . south , self . top <NEWLINE> <DEDENT> elif operation == <STRING> : <NEWLINE> <INDENT> self . north , self . east , self . south , self . west = self . west , self . north , self . east , self . south <NEWLINE> <DEDENT> elif operation == <STRING> : <NEWLINE> <INDENT> self . north , self . east , self . south , self . west = self . east , self . south , self . west , self . north , <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> while n != 0 : <NEWLINE> <INDENT> inputs = [ input ( ) for _ in range ( n ) ] <NEWLINE> value = 1 <NEWLINE> d = Dice ( ) <NEWLINE> for i in inputs : <NEWLINE> <INDENT> d . rotate ( i ) <NEWLINE> value += d . top <NEWLINE> <DEDENT> print ( value ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lucas_number = [ 0 ] * ( n + 1 ) <NEWLINE> lucas_number [ 0 ] = 2 <NEWLINE> lucas_number [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> lucas_number [ i ] = lucas_number [ i - 1 ] + lucas_number [ i - 2 ] <NEWLINE> <DEDENT> print ( lucas_number [ n ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> asum = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> asum += i % mod <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> s += ( ( a [ i ] % mod ) * ( asum - ( a [ i ] % mod ) ) ) % mod <NEWLINE> asum = asum - ( a [ i ] % mod ) <NEWLINE> <DEDENT> s %= mod <NEWLINE> print ( str ( s ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> <NL> sr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> ir = lambda : int ( sr ( ) ) <NEWLINE> lr = lambda : list ( map ( int , sr ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> N , M , S = lr ( ) <NEWLINE> limit = 2500 <NEWLINE> S = min ( S , limit ) <NEWLINE> graph = [ [ ] for _ in range ( ( N + 1 ) * ( limit + 1 ) ) ] <COMMENT> <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> u , v , a , b = lr ( ) <NEWLINE> for x in range ( a , limit + 1 ) : <NEWLINE> <INDENT> graph [ u * ( limit + 1 ) + x ] . append ( ( ( v * ( limit + 1 ) + x - a ) , b ) ) <NEWLINE> graph [ v * ( limit + 1 ) + x ] . append ( ( ( u * ( limit + 1 ) + x - a ) , b ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> c , d = lr ( ) <NEWLINE> for x in range ( limit - c + 1 ) : <NEWLINE> <INDENT> graph [ i * ( limit + 1 ) + x ] . append ( ( i * ( limit + 1 ) + x + c , d ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def dijkstra ( start ) : <NEWLINE> <INDENT> INF = 10 ** 15 <NEWLINE> dist = [ INF ] * ( ( N + 1 ) * ( limit + 1 ) ) <NEWLINE> dist [ start ] = 0 <NEWLINE> que = [ ( 0 , start ) ] <NEWLINE> while que : <NEWLINE> <INDENT> d , prev = heappop ( que ) <NEWLINE> if dist [ prev ] < d : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for next , time in graph [ prev ] : <NEWLINE> <INDENT> d1 = d + time <NEWLINE> if dist [ next ] > d1 : <NEWLINE> <INDENT> dist [ next ] = d1 <NEWLINE> heappush ( que , ( d1 , next ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dist <NEWLINE> <NL> <DEDENT> dist = dijkstra ( 1 * ( limit + 1 ) + S ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> answer = min ( dist [ i * ( limit + 1 ) : ( i + 1 ) * ( limit + 1 ) ] ) <NEWLINE> print ( answer ) <NEWLINE> <DEDENT>
print ( <STRING> . join ( list ( map ( lambda i : i . upper ( ) , input ( ) ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> u = set ( ) <NEWLINE> <NL> def agari ( i ) : <NEWLINE> <INDENT> if X [ i ] == 1 : <NEWLINE> <INDENT> X [ i ] = 0 <NEWLINE> agari ( i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> X = [ 0 ] * 20 <NEWLINE> k = 0 <NEWLINE> while k < ( pow ( 2 , n ) - 1 ) : <NEWLINE> <INDENT> y = 0 <NEWLINE> for l in range ( n ) : <NEWLINE> <INDENT> y += A [ l ] * X [ l ] <NEWLINE> <DEDENT> u . add ( y ) <NEWLINE> agari ( 0 ) <NEWLINE> k += 1 <NEWLINE> <NL> <DEDENT> for j in range ( q ) : <NEWLINE> <INDENT> if m [ j ] in u : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = collections . Counter ( A ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <NL> @ njit <NEWLINE> def solve ( n , k , arr ) : <NEWLINE> <INDENT> for i in range ( min ( k , 50 ) ) : <NEWLINE> <INDENT> tmp_arr = np . zeros ( n + 2 , np . int64 ) <NEWLINE> for i , power in enumerate ( arr ) : <NEWLINE> <INDENT> tmp_arr [ max ( 0 , i - power + 1 ) ] += 1 <NEWLINE> tmp_arr [ min ( n + 1 , i + power + 2 ) ] -= 1 <NEWLINE> <DEDENT> arr = np . cumsum ( tmp_arr ) [ 1 : - 1 ] <NEWLINE> <DEDENT> return arr <NEWLINE> <NL> <NL> <DEDENT> print ( * solve ( n , k , arr ) ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> color = [ <STRING> for i in range ( n ) ] <NEWLINE> d = [ [ ] for i in range ( n ) ] <NEWLINE> global t <NEWLINE> t = 0 <NEWLINE> M = [ [ False for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> u = data [ 0 ] <NEWLINE> k = data [ 1 ] <NEWLINE> if i == 0 : <NEWLINE> <INDENT> start = u <NEWLINE> <DEDENT> for v in data [ 2 : 2 + k ] : <NEWLINE> <INDENT> M [ u - 1 ] [ v - 1 ] = True <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def search ( u , t ) : <NEWLINE> <INDENT> t += 1 <NEWLINE> color [ u - 1 ] = <STRING> <NEWLINE> d [ u - 1 ] . append ( t ) <NEWLINE> for v in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if M [ u - 1 ] [ v - 1 ] and color [ v - 1 ] == <STRING> : <NEWLINE> <INDENT> t = search ( v , t ) <NEWLINE> <DEDENT> <DEDENT> color [ u - 1 ] = <STRING> <NEWLINE> t += 1 <NEWLINE> d [ u - 1 ] . append ( t ) <NEWLINE> return t <NEWLINE> <NL> <DEDENT> t = search ( start , t ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if color [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> t = search ( i , t ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( i + 1 , d [ i ] [ 0 ] , d [ i ] [ 1 ] ) <NEWLINE> <NL> <DEDENT>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( b // x - ( a - 1 ) // x ) <NEWLINE>
from collections import deque <NEWLINE> a = deque ( [ ] ) <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> c = input ( ) . split ( ) <NEWLINE> if c [ 0 ] == <STRING> : <NEWLINE> <INDENT> a . appendleft ( c [ 1 ] ) <NEWLINE> <DEDENT> elif c [ 0 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a . remove ( c [ 1 ] ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif c [ 0 ] == <STRING> : <NEWLINE> <INDENT> a . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . pop ( ) <NEWLINE> <DEDENT> <DEDENT> for i , e in enumerate ( a ) : <NEWLINE> <INDENT> if i == len ( a ) - 1 : <NEWLINE> <INDENT> print ( e ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( e , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> si = set ( ) <NEWLINE> do = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( a [ i ] in si ) : <NEWLINE> <INDENT> do . add ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> si . add ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> m = max ( si ) <NEWLINE> <NL> li = [ 1 ] * m <NEWLINE> <NL> for i in si : <NEWLINE> <INDENT> if ( i in do ) : <NEWLINE> <INDENT> li [ i - 1 ] = 0 <NEWLINE> <DEDENT> for j in range ( i * 2 , m + 1 , i ) : <NEWLINE> <INDENT> li [ j - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in si : <NEWLINE> <INDENT> if ( li [ i - 1 ] == 1 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> b [ i - 1 ] += 1 <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> print ( b [ j ] ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> b = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> b *= i <NEWLINE> if b > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
n = list ( input ( ) ) <NEWLINE> sList = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sList = list ( set ( sList ) ) <NEWLINE> sList . sort ( ) <NEWLINE> <NL> q = list ( input ( ) ) <NEWLINE> tList = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tCount = 0 <NEWLINE> <NL> <NL> def middle_idx ( tmin , tmax ) : <NEWLINE> <INDENT> return int ( ( tmin + tmax ) / 2 ) <NEWLINE> <NL> <NL> <DEDENT> for tmp_t in tList : <NEWLINE> <INDENT> tmp_min = 0 <NEWLINE> tmp_max = len ( sList ) - 1 <NEWLINE> if ( tmp_t >= sList [ tmp_min ] and tmp_t <= sList [ tmp_max ] ) : <NEWLINE> <INDENT> while ( tmp_max - tmp_min > 1 ) : <NEWLINE> <INDENT> tmp_mid = middle_idx ( tmp_max , tmp_min ) <NEWLINE> if sList [ tmp_mid ] > tmp_t : <NEWLINE> <INDENT> tmp_max = tmp_mid <NEWLINE> <DEDENT> elif sList [ tmp_mid ] < tmp_t : <NEWLINE> <INDENT> tmp_min = tmp_mid <NEWLINE> <DEDENT> elif sList [ tmp_mid ] == tmp_t : <NEWLINE> <INDENT> tmp_min = tmp_max <NEWLINE> <DEDENT> <DEDENT> if ( sList [ tmp_max ] == tmp_t or sList [ tmp_min ] == tmp_t or sList [ tmp_mid ] == tmp_t ) : <NEWLINE> <INDENT> tCount += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> print ( tCount ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K > ( B - A ) / 2 : <NEWLINE> <INDENT> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( A , A + K ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( B - K + 1 , B + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> from collections import defaultdict <NEWLINE> import collections <NEWLINE> import math <NEWLINE> import sys <NEWLINE> import queue <NEWLINE> sys . setrecursionlimit ( 200000 ) <NEWLINE> mod = 1000000007 <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph = { i : [ ] for i in range ( 1 , n + 1 ) } <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ u ] . append ( v ) <NEWLINE> graph [ v ] . append ( u ) <NEWLINE> <NL> <DEDENT> tf = [ False ] * ( n + 1 ) <NEWLINE> sirube = [ 0 ] * ( n + 1 ) <NEWLINE> def bfs ( v ) : <NEWLINE> <INDENT> q = queue . Queue ( ) <NEWLINE> q . put ( [ v , 0 ] ) <NEWLINE> tf [ v ] = True <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> sub = q . get ( ) <NEWLINE> now = sub [ 0 ] <NEWLINE> before = sub [ 1 ] <NEWLINE> for next in graph [ now ] : <NEWLINE> <INDENT> if tf [ next ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> tf [ next ] = True <NEWLINE> if sirube [ next ] == 0 : <NEWLINE> <INDENT> sirube [ next ] = now <NEWLINE> <DEDENT> q . put ( [ next , now ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> bfs ( 1 ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if sirube [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( sirube [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> print ( r * r * math . pi , r * 2 * math . pi ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> def val_add ( i , con , val ) : <NEWLINE> <INDENT> if con [ i ] : <NEWLINE> <INDENT> for j in con [ i ] : <NEWLINE> <INDENT> val [ j ] += val [ i ] <NEWLINE> val_add ( j , con , val ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def tree ( i , con ) : <NEWLINE> <INDENT> if not con [ i ] : pass <NEWLINE> else : <NEWLINE> <INDENT> for j in con [ i ] : <NEWLINE> <INDENT> con [ j ] . remove ( i ) <NEWLINE> tree ( j , con ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> con = [ [ ] for _ in range ( n ) ] <NEWLINE> val = [ 0 ] * n <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> con [ a - 1 ] . append ( b - 1 ) <NEWLINE> con [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> tree ( 0 , con ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> val [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> val_add ( 0 , con , val ) <NEWLINE> <NL> <NL> print ( <STRING> . join ( map ( str , val ) ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
s = <STRING> <NEWLINE> n = int ( input ( ) ) <NEWLINE> def number_of_alphabets ( n ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> g = 0 <NEWLINE> while g < n : <NEWLINE> <INDENT> g += 26 ** i <NEWLINE> i += 1 <NEWLINE> <DEDENT> return ( i - 1 ) <NEWLINE> <DEDENT> def what ( num ) : <NEWLINE> <INDENT> g = 0 <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> g += 26 ** i <NEWLINE> <DEDENT> return g <NEWLINE> <DEDENT> num = number_of_alphabets ( n ) <NEWLINE> name = [ <STRING> ] * num <NEWLINE> x = what ( num ) <NEWLINE> n -= x <NEWLINE> num -= 1 <NEWLINE> for i in range ( num , - 1 , - 1 ) : <NEWLINE> <INDENT> o = n // 26 ** i <NEWLINE> name [ num - i ] = s [ o ] <NEWLINE> n = n - o * 26 ** i <NEWLINE> <DEDENT> print ( <STRING> . join ( name ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> m = { } <NEWLINE> for i in range ( 0 , 26 ) : <NEWLINE> <INDENT> m [ i ] = chr ( 97 + i ) <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> while 1 : <NEWLINE> <NL> <INDENT> n -= 1 <NEWLINE> <NL> x = n // 26 <NEWLINE> y = n % 26 <NEWLINE> <NL> ans = m [ y ] + ans <NEWLINE> <NL> n = x <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> s = list ( s ) <NEWLINE> t = list ( t ) <NEWLINE> d = [ ] <NEWLINE> c = 0 <NEWLINE> if len ( s ) == len ( t ) : <NEWLINE> <INDENT> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ j ] != t [ j ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> d . append ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( s ) - len ( t ) ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ i + j ] != t [ j ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> d . append ( c ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( d ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> ab = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AB . append ( ab ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> graph [ a - 1 ] . append ( b ) <NEWLINE> graph [ b - 1 ] . append ( a ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> que = deque ( [ 1 ] ) <NEWLINE> ans = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> while que : <NEWLINE> <INDENT> x = deque . popleft ( que ) <NEWLINE> for i in graph [ x - 1 ] : <NEWLINE> <INDENT> if ans [ i - 1 ] != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ i - 1 ] = x <NEWLINE> que . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for a in ans [ 1 : ] : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , ans [ 1 : ] ) ) ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ - int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> heapq . heapify ( a ) <NEWLINE> ans = heapq . heappop ( a ) <NEWLINE> n -= 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n -= 1 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> temp = heapq . heappop ( a ) <NEWLINE> ans += temp <NEWLINE> n -= 1 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += temp <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( - ans ) <NEWLINE>
S = input ( ) <NEWLINE> l = len ( S ) <NEWLINE> a = [ 0 ] <NEWLINE> b = [ 0 ] * 2019 <NEWLINE> c = [ 1 ] <NEWLINE> d = 0 <NEWLINE> e = 0 <NEWLINE> for n in range ( l - 1 ) : <NEWLINE> <INDENT> c . append ( c [ n ] * 10 % 2019 ) <NEWLINE> <DEDENT> for n in range ( l ) : <NEWLINE> <INDENT> d += int ( S [ - n - 1 ] ) * c [ n ] <NEWLINE> a . append ( d % 2019 ) <NEWLINE> <DEDENT> for n in range ( l + 1 ) : <NEWLINE> <INDENT> b [ a [ n ] ] += 1 <NEWLINE> <DEDENT> for n in range ( 2019 ) : <NEWLINE> <INDENT> e += int ( b [ n ] * ( b [ n ] - 1 ) / 2 ) <NEWLINE> <DEDENT> print ( e ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if ans : <NEWLINE> <INDENT> ans . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
import sys <NEWLINE> _ = int ( input ( ) ) <NEWLINE> ns = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 1 <NEWLINE> flg = False <NEWLINE> if 0 in ns : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> for n in ns : <NEWLINE> <INDENT> if total > 10 ** 18 : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <DEDENT> total = total * n <NEWLINE> <DEDENT> if flg or total > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( total ) <NEWLINE> <DEDENT>
pronunciation = { 0 : <STRING> , 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> , 6 : <STRING> , 7 : <STRING> , 8 : <STRING> , 9 : <STRING> } <NEWLINE> input = input ( ) <NEWLINE> if len ( input ) > 1 : <NEWLINE> <INDENT> input = int ( input [ - 1 ] ) <NEWLINE> <DEDENT> if type ( input ) != int : <NEWLINE> <INDENT> input = int ( input ) <NEWLINE> <DEDENT> print ( pronunciation [ input ] ) <NEWLINE> <NL> <NL>
s = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> a . append ( s ) <NEWLINE> for i in range ( 10 ** 6 ) : <NEWLINE> <INDENT> if s % 2 == 0 : <NEWLINE> <INDENT> s //= 2 <NEWLINE> if s in a : <NEWLINE> <INDENT> print ( i + 2 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( s ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s = 3 * s + 1 <NEWLINE> if s in a : <NEWLINE> <INDENT> print ( i + 2 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( s ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> ans += int ( n / i ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += int ( n / i ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> m , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if m == n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> print ( <STRING> * n ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <COMMENT> <NEWLINE> <DEDENT> def find ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> if self . parents [ x ] < 0 : return x <NEWLINE> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> x , y = self . find ( x ) , self . find ( y ) <NEWLINE> if x == y : return <NEWLINE> if self . parents [ x ] > self . parents [ y ] : <COMMENT> <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <COMMENT> <NEWLINE> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> uf . unite ( a , b ) <NEWLINE> <DEDENT> uf_lis = uf . parents <NEWLINE> ans = 0 <NEWLINE> for p in uf_lis : <NEWLINE> <INDENT> if p < 0 : <NEWLINE> <INDENT> ans = max ( ans , - p ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> values = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for comb in itertools . combinations_with_replacement ( range ( 1 , m + 1 ) , n ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for a , b , c , d in values : <NEWLINE> <INDENT> if comb [ b - 1 ] - comb [ a - 1 ] == c : tmp += d <NEWLINE> <DEDENT> ans = max ( tmp , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> b , c = [ list ( i ) for i in zip ( * l ) ] <NEWLINE> x = collections . Counter ( a ) <NEWLINE> y = sum ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if b [ i ] in x : <NEWLINE> <INDENT> y -= x [ b [ i ] ] * b [ i ] <NEWLINE> y += x [ b [ i ] ] * c [ i ] <NEWLINE> x [ c [ i ] ] += x [ b [ i ] ] <NEWLINE> x [ b [ i ] ] = 0 <NEWLINE> <DEDENT> print ( y ) <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> n = 100 <NEWLINE> while True : <NEWLINE> <INDENT> if A % n == 0 and B % n == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if ans == K : <NEWLINE> <INDENT> print ( n ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> n -= 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> def main ( N , K , P , C ) : <COMMENT> <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans = int ( - 1e9 ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> cycleIDs = np . full ( N , - 1 , dtype = np . int64 ) <NEWLINE> cycleInfs = [ ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> cycleID = 0 <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <NL> <INDENT> v = n <NEWLINE> currentCycleItemCnt = 0 <NEWLINE> currentCycleTotal = 0 <NEWLINE> <NL> if cycleIDs [ v ] != - 1 : <NEWLINE> <INDENT> currentCycleItemCnt , currentCycleTotal = cycleInfs [ cycleIDs [ v ] ] <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <COMMENT> <NL> <INDENT> currentCycleItemCnt += 1 <NEWLINE> currentCycleTotal += C [ v ] <NEWLINE> <NL> v = P [ v ] <NEWLINE> if v == n : <NEWLINE> <COMMENT> <NL> <INDENT> cycleInfs . append ( ( currentCycleItemCnt , currentCycleTotal ) ) <NEWLINE> cycleID += 1 <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> cycleIDs [ v ] = cycleID <NEWLINE> <NL> <DEDENT> <DEDENT> procCnt = 0 <NEWLINE> currentCycleSumTmp = 0 <NEWLINE> <NL> while True : <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> procCnt += 1 <NEWLINE> currentCycleSumTmp += C [ v ] <NEWLINE> if K < procCnt : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> cycleLoopCnt = 0 <NEWLINE> if procCnt < K and 0 < currentCycleTotal : <NEWLINE> <INDENT> cycleLoopCnt = int ( ( K - procCnt ) // currentCycleItemCnt ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> tmp = currentCycleSumTmp + cycleLoopCnt * currentCycleTotal <NEWLINE> ans = max ( int ( ans ) , int ( tmp ) ) <NEWLINE> <NL> v = P [ v ] <NEWLINE> if v == n : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( main ) <NEWLINE> <COMMENT> <NL> cc . compile ( ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> from my_module import main <NEWLINE> <NL> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = np . array ( input ( ) . split ( ) , np . int64 ) <NEWLINE> P -= 1 <NEWLINE> C = np . array ( input ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> main ( N , K , P , C ) <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * 10000 <NEWLINE> <NL> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> for j in range ( 1 , 101 ) : <NEWLINE> <INDENT> for k in range ( 1 , 101 ) : <NEWLINE> <INDENT> m = ( ( i ** 2 ) + ( j ** 2 ) + ( k ** 2 ) + ( i * j ) + ( j * k ) + ( k * i ) ) <NEWLINE> if m < 10001 : <NEWLINE> <INDENT> ans [ m - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> dl = [ ] <NEWLINE> dr = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> line = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dl . append ( line [ 0 ] ) <NEWLINE> dr . append ( line [ 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> a = [ ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> tmp_S = S [ i : i + 2 ] <NEWLINE> if tmp_S == <STRING> : <NEWLINE> <INDENT> a . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> s = [ 0 ] <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> s . append ( s [ i ] + a [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = [ ] <NEWLINE> for l , r in zip ( dl , dr ) : <NEWLINE> <INDENT> ans . append ( s [ r - 1 ] - s [ l - 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
def lcs ( x , y ) : <NEWLINE> <INDENT> m = len ( x ) <NEWLINE> n = len ( y ) <NEWLINE> c = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> tmp = x [ i ] <NEWLINE> c_ = c [ : ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if tmp == y [ j ] : <NEWLINE> <INDENT> c [ j + 1 ] = c_ [ j ] + 1 <NEWLINE> <DEDENT> elif c [ j + 1 ] < c [ j ] : <NEWLINE> <INDENT> c [ j + 1 ] = c [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return c [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> ans . append ( lcs ( x , y ) ) <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> if M == 0 : <NEWLINE> <INDENT> print ( [ 0 , 10 , 100 ] [ N - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> m = map ( int , read ( ) . split ( ) ) <NEWLINE> S , C = zip ( * zip ( m , m ) ) <NEWLINE> <NL> def test ( n ) : <NEWLINE> <INDENT> st = str ( n ) <NEWLINE> if len ( st ) != N : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for i , c in zip ( S , C ) : <NEWLINE> <INDENT> i -= 1 <NEWLINE> if st [ i ] != str ( c ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> for n in range ( 1000 ) : <NEWLINE> <INDENT> if test ( n ) : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = set ( A ) <NEWLINE> for k , v in Counter ( A ) . items ( ) : <NEWLINE> <INDENT> if v != 1 : <NEWLINE> <INDENT> ans . discard ( k ) <NEWLINE> <DEDENT> temp = { k * i for i in range ( 2 , 10 ** 6 // k + 1 ) } <NEWLINE> ans -= ans & temp <NEWLINE> <DEDENT> print ( len ( ans ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> pn = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ex_list = [ ( pn [ i ] + 1 ) / 2 for i in range ( len ( pn ) ) ] <NEWLINE> ex_wa_list = [ ] <NEWLINE> wa = 0 <NEWLINE> for i in range ( len ( ex_list ) ) : <NEWLINE> <INDENT> wa += ex_list [ i ] <NEWLINE> ex_wa_list . append ( wa ) <NEWLINE> <DEDENT> Ans_list = [ ] <NEWLINE> wa2 = 0 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> wa2 = ex_wa_list [ k - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wa2 = ex_wa_list [ k - 1 + i ] - ex_wa_list [ i - 1 ] <NEWLINE> <DEDENT> Ans_list . append ( wa2 ) <NEWLINE> <DEDENT> print ( max ( Ans_list ) ) <NEWLINE>
def Ics ( X , Y ) : <NEWLINE> <INDENT> m = len ( X ) <NEWLINE> n = len ( Y ) <NEWLINE> c1 = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> d = X [ i ] <NEWLINE> c2 = c1 [ : ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( d == Y [ j ] ) : <NEWLINE> <INDENT> c1 [ j + 1 ] = c2 [ j ] + 1 <NEWLINE> <DEDENT> elif ( c1 [ j + 1 ] < c1 [ j ] ) : <NEWLINE> <INDENT> c1 [ j + 1 ] = c1 [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ( c1 [ - 1 ] ) <NEWLINE> <NL> <DEDENT> q = int ( input ( ) . rstrip ( ) ) <NEWLINE> t = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> s1 = input ( ) . rstrip ( ) <NEWLINE> s2 = input ( ) . rstrip ( ) <NEWLINE> t . append ( Ics ( s1 , s2 ) ) <NEWLINE> <DEDENT> print ( * t , sep = <STRING> ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ma = 0 <NEWLINE> <NL> if ( n < b ) : <NEWLINE> <INDENT> ma = ( a * n ) // b - ( a * ( n // b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ma = ( a * ( b - 1 ) ) // b - ( a * ( ( b - 1 ) // b ) ) <NEWLINE> <STRING> <NEWLINE> <NL> <DEDENT> print ( ma ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> dp [ a ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , len ( dp ) ) : <NEWLINE> <INDENT> if dp [ i ] : <NEWLINE> <INDENT> for j in range ( i + i , len ( dp ) , i ) : <NEWLINE> <INDENT> dp [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp . count ( 1 ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> b . sort ( ) <NEWLINE> if 0 in b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . sort ( reverse = True ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> c *= b [ i ] <NEWLINE> if c > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> <NL> sup = 1000000 <NEWLINE> <NL> is_prime = [ 0 ] * sup <NEWLINE> <NL> count = [ 0 ] * sup <NEWLINE> <NL> def setup ( ) : <NEWLINE> <INDENT> is_prime [ 2 ] = 1 <NEWLINE> for n in range ( 3 , sup , 2 ) : <NEWLINE> <INDENT> flag = True <NEWLINE> for i in range ( 3 , int ( math . floor ( math . sqrt ( n ) + 1 ) ) , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> is_prime [ n ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def precount ( ) : <NEWLINE> <INDENT> for n in range ( 2 , sup ) : <NEWLINE> <INDENT> count [ n ] = count [ n - 1 ] + is_prime [ n ] <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> setup ( ) <NEWLINE> precount ( ) <NEWLINE> <NL> l = [ ] <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> l . append ( int ( line ) ) <NEWLINE> <NL> <DEDENT> for line in l : <NEWLINE> <INDENT> print ( count [ line ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ] <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( ( a , b ) ) <NEWLINE> <DEDENT> L . sort ( ) <NEWLINE> DP_1 = [ 0 ] * N <NEWLINE> DP_2 = [ 0 ] * ( N + 1 ) <NEWLINE> DP_1 [ 0 ] , DP_2 [ 1 ] = 1 , 1 <NEWLINE> mod = 998244353 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for l in L : <NEWLINE> <INDENT> if l [ 0 ] > i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif l [ 1 ] > i : <NEWLINE> <INDENT> DP_1 [ i ] += DP_2 [ i - l [ 0 ] + 1 ] <NEWLINE> DP_1 [ i ] %= mod <NEWLINE> <DEDENT> elif l [ 1 ] <= i : <NEWLINE> <INDENT> DP_1 [ i ] += DP_2 [ i - l [ 0 ] + 1 ] - DP_2 [ i - l [ 1 ] ] <NEWLINE> DP_1 [ i ] %= mod <NEWLINE> <DEDENT> <DEDENT> DP_2 [ i + 1 ] = DP_2 [ i ] + DP_1 [ i ] <NEWLINE> DP_2 [ i + 1 ] %= mod <NEWLINE> <DEDENT> print ( DP_1 [ - 1 ] % mod ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sortp = sorted ( p ) <NEWLINE> sum = 0 <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> sum = sum + sortp [ k ] <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
import math <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , xp , yp = map ( float , input ( ) . split ( ) ) <NEWLINE> s1 = ( x2 - x1 ) * ( yp - y1 ) - ( y2 - y1 ) * ( xp - x1 ) <NEWLINE> s2 = ( x3 - x2 ) * ( yp - y2 ) - ( y3 - y2 ) * ( xp - x2 ) <NEWLINE> s3 = ( x1 - x3 ) * ( yp - y3 ) - ( y1 - y3 ) * ( xp - x3 ) <NEWLINE> if math . copysign ( 1 , s1 ) == math . copysign ( 1 , s2 ) and math . copysign ( 1 , s1 ) == math . copysign ( 1 , s3 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> C = list ( input ( ) ) <NEWLINE> count = list ( ) <NEWLINE> W = 0 <NEWLINE> R = 0 <NEWLINE> <NL> for i in C : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> R += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if R == 0 : <NEWLINE> <INDENT> count . append ( 0 ) <NEWLINE> <NL> <DEDENT> for i in C : <NEWLINE> <NL> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> W += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R -= 1 <NEWLINE> <NL> <DEDENT> if W <= R : <NEWLINE> <INDENT> count . append ( R ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count . append ( W ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( count ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = [ 0 ] * 100005 <NEWLINE> for val in a : <NEWLINE> <INDENT> arr [ val ] += 1 <NEWLINE> <DEDENT> sums = sum ( a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> diff = ( c - b ) * ( arr [ b ] ) <NEWLINE> sums += diff <NEWLINE> print ( sums ) <NEWLINE> arr [ c ] += arr [ b ] <NEWLINE> arr [ b ] = 0 <NEWLINE> <DEDENT>
import math <NEWLINE> import itertools <NEWLINE> <NL> N , K = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> <NL> all_combination = 0 <NEWLINE> for num in range ( K , N + 2 ) : <COMMENT> <NEWLINE> <INDENT> min = ( 0 + num - 1 ) * num / 2 <NEWLINE> max = ( N - ( num - 1 ) + N ) * num / 2 <NEWLINE> possiblility = ( int ( max ) - int ( min ) + 1 ) <NEWLINE> all_combination += possiblility <NEWLINE> <NL> <DEDENT> print ( all_combination % ( 1000000007 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> S = [ str ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> answer = [ ] <NEWLINE> answer = list ( set ( S ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> print ( len ( answer ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> for i in range ( n // 2 ) : <NEWLINE> <INDENT> l [ i ] , l [ - 1 - i ] = l [ - 1 - i ] , l [ i ] <NEWLINE> <NL> <DEDENT> for j in l : <NEWLINE> <INDENT> if j == l [ 0 ] : <NEWLINE> <INDENT> print ( str ( j ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + str ( j ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
operation = { <STRING> : ( 1 , 5 , 2 , 3 , 0 , 4 ) , <NEWLINE> <INDENT> <STRING> : ( 3 , 1 , 0 , 5 , 4 , 2 ) , <NEWLINE> <STRING> : ( 2 , 1 , 5 , 0 , 4 , 3 ) , <NEWLINE> <STRING> : ( 4 , 0 , 2 , 3 , 5 , 1 ) , <NEWLINE> <STRING> : ( 0 , 2 , 4 , 1 , 3 , 5 ) , <NEWLINE> <STRING> : ( 0 , 3 , 1 , 4 , 2 , 5 ) } <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dice = [ i + 1 for i in range ( 6 ) ] <NEWLINE> ans = 1 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> indices = operation [ input ( ) . strip ( ) ] <NEWLINE> dice = [ dice [ i ] for i in indices ] <NEWLINE> ans += dice [ 0 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
nv , ne = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> edges = [ ] <NEWLINE> for i in range ( ne ) : <NEWLINE> <INDENT> s , t , w = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> edges . append ( ( s , t , w ) ) <NEWLINE> <NL> <DEDENT> dist = [ [ float ( <STRING> ) ] * nv for i in range ( nv ) ] <NEWLINE> for i in range ( nv ) : <NEWLINE> <INDENT> dist [ i ] [ i ] = 0 <NEWLINE> <DEDENT> for s , t , w in edges : <NEWLINE> <INDENT> dist [ s ] [ t ] = w <NEWLINE> <NL> <DEDENT> for k in range ( nv ) : <NEWLINE> <INDENT> for i in range ( nv ) : <NEWLINE> <INDENT> for j in range ( nv ) : <NEWLINE> <INDENT> if dist [ i ] [ j ] > dist [ i ] [ k ] + dist [ k ] [ j ] : <NEWLINE> <INDENT> dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( nv ) : <NEWLINE> <INDENT> if dist [ i ] [ i ] < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for row in dist : <NEWLINE> <INDENT> print ( <STRING> . join ( str ( d ) if d < float ( <STRING> ) else <STRING> for d in row ) ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> count = Counter ( ls ) <NEWLINE> sm = sum ( ls ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> b , q = map ( int , input ( ) . split ( ) ) <NEWLINE> if b in count : <NEWLINE> <INDENT> sm -= count [ b ] * b <NEWLINE> sm += count [ b ] * q <NEWLINE> print ( sm ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sm ) <NEWLINE> <DEDENT> if q in count : <NEWLINE> <INDENT> count [ q ] += count [ b ] <NEWLINE> <NL> count [ b ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count [ q ] = count [ b ] <NEWLINE> <NL> count [ b ] = 0 <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] * N <NEWLINE> C = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B [ i ] = i + 1 - A [ i ] <NEWLINE> C [ i ] = i + 1 + A [ i ] <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if B [ i ] < 0 : <NEWLINE> <INDENT> B [ i ] = 200001 <NEWLINE> <DEDENT> if C [ i ] > N : <NEWLINE> <INDENT> C [ i ] = 200001 <NEWLINE> <DEDENT> <DEDENT> K = [ 0 ] * 200002 <NEWLINE> L = [ 0 ] * 200002 <NEWLINE> for i in B : <NEWLINE> <INDENT> K [ i ] += 1 <NEWLINE> <DEDENT> for i in C : <NEWLINE> <INDENT> L [ i ] += 1 <NEWLINE> <DEDENT> M = [ 0 ] * 200001 <NEWLINE> for i in range ( 200001 ) : <NEWLINE> <INDENT> M [ i ] = K [ i ] * L [ i ] <NEWLINE> <DEDENT> print ( sum ( M ) ) <NEWLINE>
import sys <NEWLINE> import copy <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def func ( x , m ) : <NEWLINE> <INDENT> return x ** 2 % m <NEWLINE> <NL> <DEDENT> N , X , M = [ int ( c ) for c in input ( ) . split ( ) ] <NEWLINE> myset = { X } <NEWLINE> mydict = { X : 0 } <NEWLINE> A = [ ] <NEWLINE> A . append ( X ) <NEWLINE> s = X <NEWLINE> i = 0 <NEWLINE> i_stop = i <NEWLINE> <COMMENT> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> A . append ( func ( A [ i - 1 ] , M ) ) <NEWLINE> if A [ i ] in myset : <NEWLINE> <INDENT> i_stop = i <NEWLINE> break <NEWLINE> <DEDENT> myset . add ( A [ i ] ) <NEWLINE> mydict [ A [ i ] ] = i <NEWLINE> s += A [ i ] <NEWLINE> if i == N - 1 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if i != 0 : <NEWLINE> <COMMENT> <NL> <INDENT> A_repeat = A [ mydict [ A [ i_stop ] ] : i_stop ] <NEWLINE> s += ( ( N - 1 ) - ( i_stop - 1 ) ) // len ( A_repeat ) * sum ( A_repeat ) <NEWLINE> <NL> for k in range ( ( ( N - 1 ) - ( i_stop - 1 ) ) % len ( A_repeat ) ) : <NEWLINE> <INDENT> s += A_repeat [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) . split ( ) for _ in range ( K * 2 ) ] <NEWLINE> new_list = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> S . append ( [ ] ) <NEWLINE> <DEDENT> S . append ( [ ] ) <NEWLINE> for i in range ( 1 , len ( S ) - 2 , 2 ) : <NEWLINE> <INDENT> for j in S [ i ] : <NEWLINE> <INDENT> new_list . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> new_list = set ( new_list ) <NEWLINE> print ( N - len ( new_list ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> dic , rst = { } , [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s in dic : <NEWLINE> <INDENT> dic [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ s ] = 1 <NEWLINE> <DEDENT> <DEDENT> max_val = max ( dic . values ( ) ) <NEWLINE> rst = [ key for key , val in dic . items ( ) if val == max_val ] <NEWLINE> [ print ( i ) for i in sorted ( rst ) ] <NEWLINE>
s = list ( input ( ) ) <NEWLINE> s = list ( set ( s ) ) <NEWLINE> s . sort ( ) <NEWLINE> if len ( s ) == 26 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> l = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> if len ( s ) <= i : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> if s [ i ] != l [ i ] : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> h = np . zeros ( H ) <NEWLINE> w = np . zeros ( W ) <NEWLINE> m = { } <NEWLINE> flag = 0 <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> tmp_h , tmp_w = map ( int , input ( ) . split ( ) ) <NEWLINE> h [ tmp_h - 1 ] += 1 <NEWLINE> w [ tmp_w - 1 ] += 1 <NEWLINE> m [ ( tmp_h - 1 , tmp_w - 1 ) ] = 1. <NEWLINE> <NL> <DEDENT> h_max = np . max ( h ) <NEWLINE> h_max_index = list ( zip ( * np . where ( h == h_max ) ) ) <NEWLINE> w_max = np . max ( w ) <NEWLINE> w_max_index = list ( zip ( * np . where ( w == w_max ) ) ) <NEWLINE> <NL> for i in h_max_index : <NEWLINE> <INDENT> for j in w_max_index : <NEWLINE> <INDENT> if ( i [ 0 ] , j [ 0 ] ) not in m . keys ( ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( int ( h_max + w_max ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( h_max + w_max - 1 ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> n_b = 4 <NEWLINE> n_f = 3 <NEWLINE> n_r = 10 <NEWLINE> <NL> from collections import defaultdict <NEWLINE> state = defaultdict ( int ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> state [ ( b , f , r ) ] += v <NEWLINE> <NL> <DEDENT> for b in range ( 1 , n_b + 1 ) : <NEWLINE> <INDENT> for f in range ( 1 , n_f + 1 ) : <NEWLINE> <INDENT> room_state = [ ] <NEWLINE> for r in range ( 1 , n_r + 1 ) : <NEWLINE> <INDENT> room_state . append ( state [ ( b , f , r ) ] ) <NEWLINE> <DEDENT> print ( <STRING> + <STRING> . join ( map ( str , room_state ) ) ) <NEWLINE> <DEDENT> if b != n_b : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
M = 2019 <NEWLINE> s = input ( ) <NEWLINE> tot , ten , ans = 0 , 1 , 0 <NEWLINE> cnt = [ 0 ] * M <NEWLINE> for si in s [ : : - 1 ] : <NEWLINE> <INDENT> cnt [ tot ] += 1 <NEWLINE> tot += int ( si ) * ten <NEWLINE> tot %= M <NEWLINE> ans += cnt [ tot ] <NEWLINE> ten *= 10 <NEWLINE> ten %= M <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> town = [ [ ] for _ in range ( N ) ] <NEWLINE> visited = [ 0 ] <NEWLINE> flag = [ - 1 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> town [ i ] = [ i , A [ i ] - 1 ] <NEWLINE> <NL> <DEDENT> f = 0 <NEWLINE> <NL> while flag [ f ] == - 1 : <NEWLINE> <INDENT> t = town [ f ] [ 1 ] <NEWLINE> flag [ f ] = t <NEWLINE> f = town [ t ] [ 0 ] <NEWLINE> visited . append ( t ) <NEWLINE> <NL> <DEDENT> l = visited [ - 1 ] <NEWLINE> lv = len ( visited ) <NEWLINE> <NL> if K <= lv : <NEWLINE> <INDENT> print ( visited [ K ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cs = visited . index ( l ) <NEWLINE> cycle = visited [ cs : - 1 ] <NEWLINE> lc = len ( cycle ) <NEWLINE> print ( cycle [ ( K - lv + 1 ) % lc ] + 1 ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> num_min = 1000001 <NEWLINE> num_max = - 1000001 <NEWLINE> num_sum = 0 <NEWLINE> num = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> a = input ( ) . split ( ) <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( num ) : <NEWLINE> <INDENT> if a [ i ] < num_min : <NEWLINE> <INDENT> num_min = a [ i ] <NEWLINE> <NL> <DEDENT> if a [ i ] > num_max : <NEWLINE> <INDENT> num_max = a [ i ] <NEWLINE> <NL> <DEDENT> num_sum += a [ i ] <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( num_min , num_max , num_sum ) ) ; <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 for _ in range ( n ) ] <NEWLINE> trees = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> trees [ a - 1 ] . append ( b - 1 ) <NEWLINE> trees [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> visited = [ False ] * n <NEWLINE> def dfs ( n ) : <NEWLINE> <INDENT> visited [ n ] = True <NEWLINE> for i in trees [ n ] : <NEWLINE> <INDENT> if visited [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ i ] += ans [ n ] <NEWLINE> dfs ( i ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT>
def examA ( ) : <NEWLINE> <INDENT> N = SI ( ) <NEWLINE> n = len ( N ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( N ) <NEWLINE> return <NEWLINE> <DEDENT> ans = ( n - 1 ) * 9 + int ( N [ 0 ] ) - 1 <NEWLINE> if int ( N [ 1 : ] ) == int ( <STRING> * ( n - 1 ) ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def examB ( ) : <NEWLINE> <INDENT> def norm2 ( vec ) : <NEWLINE> <INDENT> return math . sqrt ( vec [ 0 ] ** 2 + vec [ 1 ] ** 2 ) <NEWLINE> <COMMENT> <NL> <DEDENT> def ConvexHull ( point_list ) : <NEWLINE> <INDENT> pos2idx = { point_list [ i ] : i for i in range ( len ( point_list ) ) } <NEWLINE> y_val = defaultdict ( list ) <NEWLINE> x_list = sorted ( list ( set ( [ p [ 0 ] for p in point_list ] ) ) ) <NEWLINE> for x , y in point_list : <NEWLINE> <INDENT> y_val [ x ] . append ( y ) <NEWLINE> <NL> <DEDENT> upper = [ ( x_list [ 0 ] , max ( y_val [ x_list [ 0 ] ] ) ) ] <NEWLINE> lower = [ ( x_list [ 0 ] , min ( y_val [ x_list [ 0 ] ] ) ) ] <NEWLINE> prev = float ( <STRING> ) <NEWLINE> for xi in x_list [ 1 : ] : <NEWLINE> <INDENT> x0 , y0 = upper [ - 1 ] <NEWLINE> x1 , y1 = xi , max ( y_val [ xi ] ) <NEWLINE> if ( y1 - y0 ) / ( x1 - x0 ) < prev : <NEWLINE> <INDENT> upper . append ( ( x1 , y1 ) ) <NEWLINE> prev = ( y1 - y0 ) / ( x1 - x0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> x0 , y0 = upper [ - 1 ] <NEWLINE> if len ( upper ) == 1 : <NEWLINE> <INDENT> upper . append ( ( x1 , y1 ) ) <NEWLINE> break <NEWLINE> <DEDENT> x00 , y00 = upper [ - 2 ] <NEWLINE> if ( y1 - y0 ) / ( x1 - x0 ) > ( y1 - y00 ) / ( x1 - x00 ) : <NEWLINE> <INDENT> upper . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prev = ( y1 - y0 ) / ( x1 - x0 ) <NEWLINE> upper . append ( ( x1 , y1 ) ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> prev = - float ( <STRING> ) <NEWLINE> for xi in x_list [ 1 : ] : <NEWLINE> <INDENT> x0 , y0 = lower [ - 1 ] <NEWLINE> x1 , y1 = xi , min ( y_val [ xi ] ) <NEWLINE> if ( y1 - y0 ) / ( x1 - x0 ) > prev : <NEWLINE> <INDENT> lower . append ( ( x1 , y1 ) ) <NEWLINE> prev = ( y1 - y0 ) / ( x1 - x0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> x0 , y0 = lower [ - 1 ] <NEWLINE> if len ( lower ) == 1 : <NEWLINE> <INDENT> lower . append ( ( x1 , y1 ) ) <NEWLINE> break <NEWLINE> <DEDENT> x00 , y00 = lower [ - 2 ] <NEWLINE> if ( y1 - y0 ) / ( x1 - x0 ) < ( y1 - y00 ) / ( x1 - x00 ) : <NEWLINE> <INDENT> lower . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prev = ( y1 - y0 ) / ( x1 - x0 ) <NEWLINE> lower . append ( ( x1 , y1 ) ) <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> upper_idx , lower_idx = [ pos2idx [ xy ] for xy in upper ] , [ pos2idx [ xy ] for xy in lower ] <NEWLINE> if upper_idx [ - 1 ] == lower_idx [ - 1 ] : <NEWLINE> <INDENT> upper_idx . pop ( ) <NEWLINE> <DEDENT> CH_idx = upper_idx <NEWLINE> CH_idx . extend ( reversed ( lower_idx ) ) <NEWLINE> if CH_idx [ 0 ] == CH_idx [ - 1 ] and len ( CH_idx ) > 1 : <NEWLINE> <INDENT> CH_idx . pop ( ) <NEWLINE> <DEDENT> return CH_idx <NEWLINE> <NL> <DEDENT> N = I ( ) <NEWLINE> P = [ [ ] for _ in range ( N ) ] <NEWLINE> D = defaultdict ( int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = LI ( ) <NEWLINE> P [ i ] = ( x , y ) <NEWLINE> D [ ( x , y ) ] = i <NEWLINE> <DEDENT> C = ConvexHull ( P ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> if len ( C ) == 2 : <NEWLINE> <INDENT> for c in C : <NEWLINE> <INDENT> ans [ c ] = 0.5 <NEWLINE> <DEDENT> for v in ans : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT> return <NEWLINE> <COMMENT> <NL> <DEDENT> for i , c in enumerate ( C ) : <NEWLINE> <INDENT> s , t , u = C [ i - 1 ] , C [ i ] , C [ ( i + 1 ) % len ( C ) ] <NEWLINE> x0 , y0 = P [ s ] <NEWLINE> x1 , y1 = P [ t ] <NEWLINE> x2 , y2 = P [ u ] <NEWLINE> vec0 = ( y0 - y1 , x1 - x0 ) <NEWLINE> vec1 = ( y1 - y2 , x2 - x1 ) <NEWLINE> ans [ t ] = math . acos ( ( vec0 [ 0 ] * vec1 [ 0 ] + vec0 [ 1 ] * vec1 [ 1 ] ) / ( norm2 ( vec0 ) * norm2 ( vec1 ) ) ) / ( 2 * math . pi ) <NEWLINE> <DEDENT> for v in ans : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> def examC ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> def examD ( ) : <NEWLINE> <INDENT> S = SI ( ) <NEWLINE> N = len ( S ) <NEWLINE> K = I ( ) <NEWLINE> if K > 150 : <NEWLINE> <INDENT> K = 150 <NEWLINE> <DEDENT> dp = [ [ [ 0 ] * ( K + 1 ) for _ in range ( N ) ] for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> dp [ i ] [ i ] [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> for k in range ( K + 1 ) : <NEWLINE> <INDENT> for l , r in enumerate ( range ( i - 1 , N ) ) : <NEWLINE> <INDENT> if S [ l ] == S [ r ] : <NEWLINE> <INDENT> dp [ l ] [ r ] [ k ] = dp [ l + 1 ] [ r - 1 ] [ k ] + 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k > 0 : <NEWLINE> <INDENT> dp [ l ] [ r ] [ k ] = max ( dp [ l + 1 ] [ r ] [ k ] , dp [ l ] [ r - 1 ] [ k ] , dp [ l + 1 ] [ r - 1 ] [ k - 1 ] + 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ l ] [ r ] [ k ] = max ( dp [ l + 1 ] [ r ] [ k ] , dp [ l ] [ r - 1 ] [ k ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = max ( dp [ 0 ] [ - 1 ] ) <NEWLINE> <COMMENT> <NL> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> def examE ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> def examF ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> from decimal import Decimal as dec <NEWLINE> import sys , bisect , itertools , heapq , math , random <NEWLINE> from copy import deepcopy <NEWLINE> from heapq import heappop , heappush , heapify <NEWLINE> from collections import Counter , defaultdict , deque <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def DI ( ) : return dec ( input ( ) ) <NEWLINE> def LDI ( ) : return list ( map ( dec , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def LSI ( ) : return list ( map ( str , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def SI ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> global mod , mod2 , inf , alphabet , _ep <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> mod2 = 998244353 <NEWLINE> inf = 10 ** 18 <NEWLINE> _ep = 10 ** ( - 12 ) <NEWLINE> alphabet = [ chr ( ord ( <STRING> ) + i ) for i in range ( 26 ) ] <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> examA ( ) <NEWLINE> <NL> <DEDENT> <STRING> <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = [ 1 ] <NEWLINE> x = [ 0 ] * n <NEWLINE> x [ 0 ] = 1 <NEWLINE> y = 1 <NEWLINE> z = 0 <NEWLINE> d = 0 <NEWLINE> flag = False <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> t . append ( a [ t [ i ] - 1 ] ) <NEWLINE> if x [ a [ t [ i ] - 1 ] - 1 ] != 0 : <NEWLINE> <INDENT> y = x [ a [ t [ i ] - 1 ] - 1 ] <NEWLINE> z = i + 2 <NEWLINE> b = [ a [ t [ i ] - 1 ] ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x [ a [ t [ i ] - 1 ] - 1 ] += i + 2 <NEWLINE> z = i + 2 <NEWLINE> b = [ a [ t [ i ] - 1 ] ] <NEWLINE> <DEDENT> if i == k - 1 : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( a [ t [ k - 1 ] - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> d = z - y <NEWLINE> <NL> <NL> if d != 0 : <NEWLINE> <INDENT> r = ( k - y ) % d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = k - y <NEWLINE> <NL> <DEDENT> for i in range ( r + 1 ) : <NEWLINE> <INDENT> b . append ( a [ b [ i ] - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( b [ r + 1 ] ) <NEWLINE>
def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> <NL> L = A [ left : mid ] + [ 1000000001 ] <NEWLINE> R = A [ mid : right ] + [ 1000000001 ] <NEWLINE> <NL> i = j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> cnt += right - left <NEWLINE> <NL> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> mergeSort ( A , 0 , n ) <NEWLINE> print ( * A ) <NEWLINE> print ( cnt ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> name_len = [ 0 ] <NEWLINE> while True : <NEWLINE> <INDENT> name_len . append ( name_len [ - 1 ] + 26 ** ( len ( name_len ) ) ) <NEWLINE> if name_len [ - 1 ] > 1000000000000001 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> number = 0 <NEWLINE> for i in range ( len ( name_len ) ) : <NEWLINE> <INDENT> if name_len [ i ] < n and n <= name_len [ i + 1 ] : <NEWLINE> <INDENT> number = i + 1 <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> n -= name_len [ number - 1 ] <NEWLINE> <COMMENT> <NL> <NL> ans = <STRING> <NEWLINE> li = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <COMMENT> <NL> <NL> for i in range ( number , 0 , - 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if i == 1 : <NEWLINE> <INDENT> ans += li [ int ( n / 26 ** ( i - 1 ) ) - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n % 26 ** ( i - 1 ) == 0 : <NEWLINE> <INDENT> ans += li [ int ( n / 26 ** ( i - 1 ) ) - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += li [ int ( n / 26 ** ( i - 1 ) ) ] <NEWLINE> <DEDENT> <DEDENT> n = n % 26 ** ( i - 1 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> def precompute ( S ) : <NEWLINE> <INDENT> H , W = S . shape <NEWLINE> V = np . zeros ( ( H + 1 , W + 1 ) , np . int64 ) <NEWLINE> V [ 1 : , 1 : ] = np . cumsum ( S , axis = 0 ) . cumsum ( axis = 1 ) <NEWLINE> Ex = np . zeros ( ( H , W + 1 ) , np . int64 ) <NEWLINE> Ex [ 1 : , 1 : ] = np . cumsum ( S [ : - 1 ] & S [ 1 : ] , axis = 0 ) . cumsum ( axis = 1 ) <NEWLINE> Ey = np . zeros ( ( H + 1 , W ) , np . int64 ) <NEWLINE> Ey [ 1 : , 1 : ] = np . cumsum ( S [ : , : - 1 ] & S [ : , 1 : ] , axis = 0 ) . cumsum ( axis = 1 ) <NEWLINE> return V , Ex , Ey <NEWLINE> <NL> <DEDENT> def main ( V , Ex , Ey , query ) : <NEWLINE> <INDENT> for i in range ( len ( query ) // 4 ) : <NEWLINE> <INDENT> a , b , c , d = query [ 4 * i : 4 * i + 4 ] <NEWLINE> v = V [ c , d ] + V [ a - 1 , b - 1 ] - V [ a - 1 , d ] - V [ c , b - 1 ] <NEWLINE> e1 = Ex [ c - 1 , d ] + Ex [ a - 1 , b - 1 ] - Ex [ a - 1 , d ] - Ex [ c - 1 , b - 1 ] <NEWLINE> e2 = Ey [ c , d - 1 ] + Ey [ a - 1 , b - 1 ] - Ey [ a - 1 , d - 1 ] - Ey [ c , b - 1 ] <NEWLINE> print ( v - e1 - e2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> import numba <NEWLINE> from numba . pycc import CC <NEWLINE> i8 = numba . from_dtype ( np . int64 ) <NEWLINE> signature = ( i8 [ : , : ] , i8 [ : , : ] , i8 [ : , : ] , i8 [ : ] ) <NEWLINE> <NL> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , signature ) ( main ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> from my_module import main <NEWLINE> <NL> H , W , Q = map ( int , readline ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> S . append ( list ( readline ( ) . rstrip ( ) ) ) <NEWLINE> <DEDENT> query = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> S = ( np . concatenate ( S ) - ord ( <STRING> ) ) . reshape ( H , W ) <NEWLINE> V , Ex , Ey = precompute ( S ) <NEWLINE> <NL> main ( V , Ex , Ey , query ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> f = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> f [ A - 1 ] . append ( B - 1 ) <NEWLINE> f [ B - 1 ] . append ( A - 1 ) <NEWLINE> <DEDENT> from collections import deque <NEWLINE> d = deque ( ) <NEWLINE> x = [ - 1 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if x [ i ] == - 1 : <NEWLINE> <INDENT> x [ i ] = i <NEWLINE> d . append ( f [ i ] ) <NEWLINE> <DEDENT> while len ( d ) > 0 : <NEWLINE> <INDENT> z = d . popleft ( ) <NEWLINE> for j in z : <NEWLINE> <INDENT> if x [ j ] == - 1 : <NEWLINE> <INDENT> x [ j ] = i <NEWLINE> d . append ( f [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> import collections <NEWLINE> ans = collections . Counter ( x ) <NEWLINE> print ( ans . most_common ( ) [ 0 ] [ 1 ] ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if k % 7 == 0 : <NEWLINE> <INDENT> l = 9 * k // 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = 9 * k <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> q = 10 % l <NEWLINE> <NL> while q != 1 : <NEWLINE> <INDENT> q *= 10 <NEWLINE> q %= l <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> ans = 1001 <NEWLINE> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> for s in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ s ] != S [ i + s ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> if a < ans : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pos = 1 <NEWLINE> if k < n : <NEWLINE> <INDENT> for _ in range ( k ) : <NEWLINE> <INDENT> pos = a [ pos - 1 ] <NEWLINE> <DEDENT> print ( pos ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst = [ 1 ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> pos = a [ pos - 1 ] <NEWLINE> lst . append ( pos ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for num , i in enumerate ( lst ) : <NEWLINE> <INDENT> if i == pos and count == 1 : <NEWLINE> <INDENT> loop = num - before <NEWLINE> rem = ( k - before ) % loop <NEWLINE> print ( lst [ before + rem ] ) <NEWLINE> break <NEWLINE> <DEDENT> elif i == pos : <NEWLINE> <INDENT> count = 1 <NEWLINE> before = num <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> <NL> res = [ 0 ] * 2019 <NEWLINE> res [ 0 ] = 1 <NEWLINE> <NL> d = 1 <NEWLINE> a = 0 <NEWLINE> <NL> for c in reversed ( S ) : <NEWLINE> <INDENT> a += int ( c ) * d <NEWLINE> a %= 2019 <NEWLINE> res [ a ] += 1 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for r in res : <NEWLINE> <INDENT> ans += r * ( r - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> s = sum ( A ) <NEWLINE> x = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = s - A [ i ] <NEWLINE> x += s * A [ i ] <NEWLINE> <DEDENT> print ( x % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL>
import math <NEWLINE> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> a = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def is_greater ( b ) : <NEWLINE> <INDENT> for i in b : <NEWLINE> <INDENT> if i < X : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> cost = math . inf <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> b = [ 0 ] * ( M + 1 ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> for k in range ( M + 1 ) : <NEWLINE> <INDENT> b [ k ] += a [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if b [ 0 ] < cost and is_greater ( b [ 1 : ] ) : <NEWLINE> <INDENT> cost = b [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if cost == math . inf : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cost ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> input ( ) <NEWLINE> ms = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> enable_create = [ False ] * 2000 <NEWLINE> for bit in range ( 1 << len ( A ) ) : <NEWLINE> <INDENT> n = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if 1 & ( bit >> i ) == 1 : <NEWLINE> <INDENT> n += A [ i ] <NEWLINE> <DEDENT> <DEDENT> enable_create [ n ] = True <NEWLINE> <NL> <DEDENT> for m in ms : <NEWLINE> <INDENT> print ( <STRING> if enable_create [ m ] else <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> sr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> ir = lambda : int ( sr ( ) ) <NEWLINE> lr = lambda : list ( map ( int , sr ( ) . split ( ) ) ) <NEWLINE> <NL> S = sr ( ) <NEWLINE> mod_cnt = [ 0 ] * 2019 <NEWLINE> mod_cnt [ 0 ] = 1 <NEWLINE> power = 1 <NEWLINE> remain = 0 <NEWLINE> answer = 0 <NEWLINE> for i in range ( len ( S ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> remain += int ( S [ i ] ) * power <NEWLINE> remain %= 2019 <NEWLINE> power *= 10 ; power %= 2019 <NEWLINE> answer += mod_cnt [ remain ] <NEWLINE> mod_cnt [ remain ] += 1 <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L_sorted = sorted ( L , reverse = False ) <COMMENT> <NEWLINE> count = 0 <NEWLINE> import bisect <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> a = L_sorted [ i ] <NEWLINE> b = L_sorted [ j ] <NEWLINE> bisect . bisect_left ( L_sorted , a + b ) <NEWLINE> count += bisect . bisect_left ( L_sorted , a + b ) - j - 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<NL> import sys <NEWLINE> stdin = sys . stdin <NEWLINE> <NL> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( ns ( ) ) <NEWLINE> def na ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> x , n = na ( ) <NEWLINE> p = na ( ) <NEWLINE> <NL> ans = x <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> temp = x - i <NEWLINE> if not temp in p : <NEWLINE> <INDENT> print ( temp ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> temp = x + i <NEWLINE> if not temp in p : <NEWLINE> <INDENT> print ( temp ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> Bsize = 700 <NEWLINE> <NL> def Mo_argsort ( LR ) : <NEWLINE> <INDENT> L = LR [ : , 0 ] <NEWLINE> R = LR [ : , 1 ] <NEWLINE> key1 = L // Bsize <NEWLINE> key2 = np . where ( key1 & 1 , - R , R ) <NEWLINE> key = ( key1 << 32 ) + key2 <NEWLINE> return np . argsort ( key ) <NEWLINE> <NL> <DEDENT> def main ( A , LR ) : <NEWLINE> <INDENT> N = len ( A ) <NEWLINE> Q = len ( LR ) <NEWLINE> ind = Mo_argsort ( LR ) <NEWLINE> count = np . zeros ( N + 1 , np . int64 ) <NEWLINE> ans = 0 <NEWLINE> <NL> def add ( x ) : <NEWLINE> <INDENT> nonlocal ans <NEWLINE> if not count [ x ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> count [ x ] += 1 <NEWLINE> <NL> <DEDENT> def rem ( x ) : <NEWLINE> <INDENT> nonlocal ans <NEWLINE> count [ x ] -= 1 <NEWLINE> if not count [ x ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> answers = np . empty ( Q , np . int64 ) <NEWLINE> nl , nr = 0 , 0 <NEWLINE> for i in ind : <NEWLINE> <INDENT> l , r = LR [ i ] <NEWLINE> l -= 1 <NEWLINE> <COMMENT> <NL> while nl > l : <NEWLINE> <INDENT> nl -= 1 <NEWLINE> add ( A [ nl ] ) <NEWLINE> <DEDENT> while nr < r : <NEWLINE> <INDENT> add ( A [ nr ] ) <NEWLINE> nr += 1 <NEWLINE> <DEDENT> while nl < l : <NEWLINE> <INDENT> rem ( A [ nl ] ) <NEWLINE> nl += 1 <NEWLINE> <DEDENT> while nr > r : <NEWLINE> <INDENT> nr -= 1 <NEWLINE> rem ( A [ nr ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> answers [ i ] = ans <NEWLINE> <DEDENT> return answers <NEWLINE> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> import numba <NEWLINE> from numba . pycc import CC <NEWLINE> i4 = numba . int32 <NEWLINE> i8 = numba . int64 <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> <NL> def cc_export ( f , signature ) : <NEWLINE> <INDENT> cc . export ( f . __name__ , signature ) ( f ) <NEWLINE> return numba . njit ( f ) <NEWLINE> <NL> <DEDENT> Mo_argsort = cc_export ( Mo_argsort , ( i8 [ : , : ] , ) ) <NEWLINE> main = cc_export ( main , ( i8 [ : ] , i8 [ : , : ] ) ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> from my_module import main <NEWLINE> <NL> N , Q = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = np . array ( readline ( ) . split ( ) , np . int64 ) <NEWLINE> LR = np . array ( read ( ) . split ( ) , np . int64 ) . reshape ( Q , 2 ) <NEWLINE> <NL> ans = main ( A , LR ) <NEWLINE> print ( <STRING> . join ( map ( str , ans . tolist ( ) ) ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ input ( ) for _ in range ( n ) ] <NEWLINE> b = [ input ( ) for _ in range ( m ) ] <NEWLINE> <NL> d = n - m + 1 <NEWLINE> flg = False <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> for j in range ( d ) : <NEWLINE> <INDENT> if a [ i ] [ j : j + m ] == b [ 0 ] : <NEWLINE> <INDENT> for k in range ( 1 , m ) : <NEWLINE> <INDENT> if a [ i + k ] [ j : j + m ] != b [ k ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flg = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> <NL> if k >= n : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> d = deque ( ) <NEWLINE> d . append ( input ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> r = 1 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> q2 = input ( ) . split ( ) <NEWLINE> if int ( q2 [ 0 ] ) == 1 : <NEWLINE> <INDENT> r *= - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( r == 1 and int ( q2 [ 1 ] ) == 1 ) or ( r == - 1 and int ( q2 [ 1 ] ) == 2 ) : <NEWLINE> <INDENT> d . appendleft ( q2 [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . append ( q2 [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( d ) if r == 1 else <STRING> . join ( d ) [ : : - 1 ] ) <NEWLINE> <NL> <NL>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> a = r * r * math . pi <NEWLINE> b = r * 2 * math . pi <NEWLINE> print ( <STRING> . format ( a , b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> sum = a [ 0 ] <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> sum = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> sum = sum * a [ i ] <NEWLINE> if sum > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if sum > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> rooms = [ [ [ 0 ] * 10 for _ in range ( 3 ) ] for _ in range ( 4 ) ] <NEWLINE> stdin . readline ( ) . rstrip ( ) <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> b , f , r , v = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> rooms [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * rooms [ b ] [ f ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b != 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> M = 1 <NEWLINE> for i in L : <NEWLINE> <INDENT> M *= i <NEWLINE> if M > 10 ** 18 : <NEWLINE> <INDENT> M = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( M ) <NEWLINE>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = l [ 0 ] <NEWLINE> b = l [ 1 ] <NEWLINE> x = l [ 2 ] <NEWLINE> if a % x == 0 : <NEWLINE> <INDENT> print ( b // x - a // x + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b // x - a // x ) <NEWLINE> <DEDENT>
n , k = input ( ) . strip ( ) . split ( ) <NEWLINE> n , k = [ int ( n ) , int ( k ) ] <NEWLINE> <NL> p = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> p . sort ( ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> DP1 = [ 0 for _ in range ( N + 3 ) ] <NEWLINE> DP2 = [ 0 for _ in range ( N + 3 ) ] <NEWLINE> DP1 [ 3 ] = 1 <NEWLINE> DP2 [ 3 ] = 1 <NEWLINE> for i in range ( 4 , N + 1 ) : <NEWLINE> <INDENT> DP1 [ i ] = ( DP2 [ i - 3 ] + 1 ) % MOD <NEWLINE> DP2 [ i ] = ( DP1 [ i ] + DP2 [ i - 1 ] ) % MOD <NEWLINE> <DEDENT> print ( DP1 [ N ] ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 100000000 ) <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> prices = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> INF = 10000000000 <NEWLINE> <NL> memo = { } <NEWLINE> <NL> def minPrice ( n , k ) : <NEWLINE> <INDENT> if ( n , k ) in memo : <NEWLINE> <INDENT> return memo [ ( n , k ) ] <NEWLINE> <DEDENT> if n < k : <NEWLINE> <INDENT> return INF <NEWLINE> <DEDENT> if k == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> take = prices [ n - 1 ] + minPrice ( n - 1 , k - 1 ) <NEWLINE> skip = minPrice ( n - 1 , k ) <NEWLINE> ans = min ( INF , take , skip ) <NEWLINE> memo [ ( n , k ) ] = ans <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> print ( minPrice ( N , K ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ k + i ] > a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> ABCD = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> tl = itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) <NEWLINE> ans = 0 <NEWLINE> for l in tl : <NEWLINE> <INDENT> t = 0 <NEWLINE> for a , b , c , d in ABCD : <NEWLINE> <INDENT> if l [ b - 1 ] - l [ a - 1 ] == c : <NEWLINE> <INDENT> t += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , t ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<STRING> <NEWLINE> <NL> from collections import defaultdict <NEWLINE> <NL> def gen_10exp_mod ( n , mod ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> yield a <NEWLINE> for _ in range ( 1 , n ) : <NEWLINE> <INDENT> a = ( a * 10 ) % mod <NEWLINE> yield a <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> MOD = 2019 <NEWLINE> S = input ( ) [ : : - 1 ] <NEWLINE> <COMMENT> <NL> A = [ int ( s ) * n % MOD for s , n in zip ( S , gen_10exp_mod ( len ( S ) , MOD ) ) ] <NEWLINE> <COMMENT> <NL> ACC = [ 0 ] <NEWLINE> for a in A : <NEWLINE> <INDENT> ACC . append ( ( ACC [ - 1 ] + a ) % MOD ) <NEWLINE> <COMMENT> <NL> <DEDENT> d = defaultdict ( int ) <NEWLINE> for acc in ACC : <NEWLINE> <INDENT> d [ acc ] += 1 <NEWLINE> <DEDENT> ans = sum ( v * ( v - 1 ) // 2 for v in d . values ( ) ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> <NL> PI = math . pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> s = r * r * PI <NEWLINE> l = 2 * r * PI <NEWLINE> print ( <STRING> % ( s , l ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def readstr ( ) : <NEWLINE> <INDENT> return input ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def readint ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def readnums ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def readstrs ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <NL> <DEDENT> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <NL> <NL> <DEDENT> def check ( x , y ) : <NEWLINE> <INDENT> return x ** 4 + x ** 3 * y + x ** 2 * y ** 2 + x * y ** 3 + y ** 4 <NEWLINE> <NL> <NL> <DEDENT> X = readint ( ) <NEWLINE> l = make_divisors ( X ) <NEWLINE> <NL> ans_A = 0 <NEWLINE> ans_B = 0 <NEWLINE> for n in l : <NEWLINE> <COMMENT> <NL> <INDENT> A = n // 2 <NEWLINE> B = A - n <NEWLINE> while A ** 5 - B ** 5 <= X : <NEWLINE> <INDENT> if check ( A , B ) == ( X // n ) : <NEWLINE> <INDENT> ans_A = A <NEWLINE> ans_B = B <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A -= 1 <NEWLINE> B -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ans_A : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans_A , ans_B ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = Counter ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in set ( a ) : <NEWLINE> <INDENT> if b [ i ] < i : <NEWLINE> <INDENT> ans += b [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += b [ i ] - i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> c = c * A [ i ] <NEWLINE> if c > 10 ** 18 : <NEWLINE> <INDENT> c = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> grid = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> array = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> grid . append ( array ) <NEWLINE> <NL> <DEDENT> flag = 0 <NEWLINE> X = 0 <NEWLINE> <NL> S = [ 1 ] * N <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for b in grid : <NEWLINE> <INDENT> if H [ b [ 0 ] - 1 ] > H [ b [ 1 ] - 1 ] : <NEWLINE> <INDENT> S [ b [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ b [ 0 ] - 1 ] < H [ b [ 1 ] - 1 ] : <NEWLINE> <INDENT> S [ b [ 0 ] - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ b [ 0 ] - 1 ] == H [ b [ 1 ] - 1 ] : <NEWLINE> <INDENT> S [ b [ 0 ] - 1 ] = 0 <NEWLINE> S [ b [ 1 ] - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> X = sum ( S ) <NEWLINE> <NL> print ( X ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) + 1 <NEWLINE> print ( sum ( gcd ( c , gcd ( a , b ) ) for a in range ( 1 , k ) for b in range ( 1 , k ) for c in range ( 1 , k ) ) ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> <NL> def get_result ( data ) : <NEWLINE> <INDENT> S = data [ 0 ] <NEWLINE> mod_all_bit = [ 0 ] * 2019 <NEWLINE> mod_all_bit [ 0 ] = 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ten_i_mod = [ 0 ] * len ( S ) <NEWLINE> ten_i_mod [ 0 ] = 1 <NEWLINE> for i in range ( len ( S ) - 1 ) : <NEWLINE> <INDENT> ten_i_mod [ i + 1 ] = ( ten_i_mod [ i ] * 10 ) % 2019 <NEWLINE> <DEDENT> mod = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> mod = ( mod + ten_i_mod [ i ] * int ( S [ - ( i + 1 ) ] ) ) % 2019 <NEWLINE> mod_all_bit [ mod ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for val in mod_all_bit : <NEWLINE> <INDENT> if val >= 2 : <NEWLINE> <INDENT> ans += val * ( val - 1 ) * 0.5 <NEWLINE> <DEDENT> <DEDENT> return int ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> data = list ( map ( str , stdin . readline ( ) . rstrip ( ) . split ( <STRING> ) ) ) <NEWLINE> result = get_result ( data ) <NEWLINE> print ( result ) <NEWLINE> <DEDENT>
import queue <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> adj = [ [ ] for i in [ 0 ] * N ] <COMMENT> <NEWLINE> for i in [ 0 ] * M : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> adj [ a - 1 ] . append ( b ) <NEWLINE> adj [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> que = queue . Queue ( ) <NEWLINE> que . put ( 1 ) <NEWLINE> guide = [ - 1 ] * ( N ) <NEWLINE> <NL> while not que . empty ( ) : <NEWLINE> <INDENT> x = que . get ( ) <NEWLINE> for y in adj [ x - 1 ] : <NEWLINE> <INDENT> if guide [ y - 1 ] == - 1 : <NEWLINE> <INDENT> que . put ( y ) <NEWLINE> guide [ y - 1 ] = x <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in guide [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <NL> <DEDENT>
def merge ( A , l , m , r ) : <NEWLINE> <INDENT> L = A [ l : m ] + [ SENTINEL ] <NEWLINE> R = A [ m : r ] + [ SENTINEL ] <NEWLINE> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( l , r ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> global count <NEWLINE> count += r - l <NEWLINE> <NL> <DEDENT> def merge_sort ( A , l , r ) : <NEWLINE> <INDENT> if l + 1 < r : <NEWLINE> <INDENT> m = ( l + r ) // 2 <NEWLINE> merge_sort ( A , l , m ) <NEWLINE> merge_sort ( A , m , r ) <NEWLINE> merge ( A , l , m , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> SENTINEL = float ( <STRING> ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> merge_sort ( A , 0 , len ( A ) ) <NEWLINE> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> print ( count ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b . append ( a [ i ] + i ) <NEWLINE> c . append ( i - a [ i ] ) <NEWLINE> <DEDENT> t = Counter ( c ) <NEWLINE> for s in b : <NEWLINE> <INDENT> count += t [ s ] <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bunsi = c [ 0 ] <NEWLINE> bunbo = c [ 1 ] <NEWLINE> n = c [ 2 ] <NEWLINE> k = n // bunbo <NEWLINE> d = [ n ] <NEWLINE> if k >= 1 : <NEWLINE> <INDENT> d . append ( bunbo - 1 ) <NEWLINE> d . append ( bunbo * k - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> def floor ( x ) : <NEWLINE> <INDENT> return ( ( bunsi * x ) // bunbo ) - ( bunsi * ( x // bunbo ) ) <NEWLINE> <DEDENT> if len ( d ) >= 2 : <NEWLINE> <INDENT> print ( max ( floor ( d [ 0 ] ) , floor ( d [ - 1 ] ) , floor ( d [ - 2 ] ) ) ) <NEWLINE> <DEDENT> if len ( d ) == 1 : <NEWLINE> <INDENT> print ( floor ( d [ 0 ] ) ) <NEWLINE> <DEDENT>
def get_data ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> yield a , b <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> input_data = list ( get_data ( ) ) <NEWLINE> for i , data in enumerate ( input_data ) : <NEWLINE> <INDENT> a , b = data <NEWLINE> flg = False <NEWLINE> for x in range ( a , b + 1 ) : <NEWLINE> <INDENT> if ( x % 4 == 0 and x % 100 != 0 ) or x % 400 == 0 : <NEWLINE> <INDENT> if not flg : <NEWLINE> <INDENT> flg = True <NEWLINE> <DEDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT> if not flg : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if i != len ( input_data ) - 1 : <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> X = int ( input ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> for i in range ( 10 ** 4 ) : <NEWLINE> <INDENT> for j in range ( - 70 , i , 1 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> ans = <STRING> . format ( i , j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans != <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans != <STRING> : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( aaa ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import numpy as np <NEWLINE> from collections import deque <NEWLINE> import itertools <NEWLINE> <NL> n , m , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b , c , d = [ 0 ] * q , [ 0 ] * q , [ 0 ] * q , [ 0 ] * q <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a [ i ] -= 1 <NEWLINE> b [ i ] -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for seq in itertools . combinations_with_replacement ( range ( m ) , n ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if seq [ b [ i ] ] - seq [ a [ i ] ] == c [ i ] : <NEWLINE> <INDENT> tmp += d [ i ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> mi = n + 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> mi = min ( mi , p [ i ] ) <NEWLINE> if mi == p [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif K <= A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * A + B - K ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a_lst [ i ] += 1 <NEWLINE> <NL> <DEDENT> max_a = max ( a_lst ) <NEWLINE> count_lst = [ 0 ] * ( max_a + 2 ) <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a = a_lst [ i ] <NEWLINE> index1 = a - 1 <NEWLINE> index2 = a <NEWLINE> index3 = a + 1 <NEWLINE> <NL> count_lst [ index1 ] += 1 <NEWLINE> count_lst [ index2 ] += 1 <NEWLINE> count_lst [ index3 ] += 1 <NEWLINE> <NL> <DEDENT> maximum = max ( count_lst ) <NEWLINE> print ( maximum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sa = sorted ( a , reverse = True ) <NEWLINE> ans = sa [ 0 ] <NEWLINE> i = 2 <NEWLINE> for v in sa [ 1 : ] : <NEWLINE> <INDENT> if i >= n : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> ans += v <NEWLINE> i += 1 <NEWLINE> if i >= n : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> ans += v <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> dp = [ float ( <STRING> ) ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if dp [ i ] == float ( <STRING> ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 1 , n // 6 + 1 ) : <NEWLINE> <INDENT> if i + 6 ** j > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp [ i + 6 ** j ] = min ( dp [ i + 6 ** j ] , dp [ i ] + 1 ) <NEWLINE> <DEDENT> for j in range ( 1 , n // 9 + 1 ) : <NEWLINE> <INDENT> if i + 9 ** j > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp [ i + 9 ** j ] = min ( dp [ i + 9 ** j ] , dp [ i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = n <NEWLINE> for i in range ( max ( 0 , n - 5 ) , n + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , dp [ i ] + n - i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> def getNearestValue ( Q , num ) : <NEWLINE> <INDENT> idx = np . abs ( np . asarray ( Q ) - num ) . argmin ( ) <NEWLINE> return Q [ idx ] <NEWLINE> <NL> <DEDENT> XN = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = XN [ 0 ] <NEWLINE> N = XN [ 1 ] <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = list ( range ( - 100 , 200 , 1 ) ) <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> Q . remove ( P [ i ] ) <NEWLINE> <DEDENT> print ( getNearestValue ( Q , X ) ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = 1 <NEWLINE> for i in range ( k , n + 1 ) : <NEWLINE> <INDENT> a += n * i - i ** 2 + i + 1 <NEWLINE> <DEDENT> print ( a % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> balls = A + B <NEWLINE> an = 0 <NEWLINE> if N % balls == 0 : <NEWLINE> <INDENT> print ( int ( A * ( N // balls ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> an += A * ( N // balls ) <NEWLINE> an += min ( A , N % balls ) <NEWLINE> print ( an ) <NEWLINE> <DEDENT>
import string <NEWLINE> s = string . ascii_lowercase <NEWLINE> <NL> <NL> def f ( x , tmp ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> x -= 1 <NEWLINE> if x < 26 : <NEWLINE> <INDENT> return s [ x ] + tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return f ( x // 26 , s [ x % 26 ] + tmp ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> r = f ( n , <STRING> ) <NEWLINE> print ( r ) <NEWLINE>
N , K = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> for k in range ( K , N ) : <NEWLINE> <INDENT> if A [ k ] / A [ k - K ] > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> <NL> def main ( args ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for y in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> m = 10 ** 18 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > m : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> path = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> edges = [ [ ] for j in range ( N + 1 ) ] <NEWLINE> for p in path : <NEWLINE> <INDENT> x , y = p <NEWLINE> edges [ x ] . append ( y ) <NEWLINE> edges [ y ] . append ( x ) <NEWLINE> <NL> <DEDENT> que = deque ( [ ] ) <NEWLINE> dic = { 1 : 0 } <NEWLINE> def bfs ( now ) : <NEWLINE> <INDENT> e = edges [ now ] <NEWLINE> for q in e : <NEWLINE> <INDENT> if not q in dic : <NEWLINE> <INDENT> dic [ q ] = now <NEWLINE> que . append ( q ) <NEWLINE> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> n = que . popleft ( ) <NEWLINE> bfs ( n ) <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> bfs ( 1 ) <NEWLINE> <NL> if len ( dic ) != N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> dic_sort = sorted ( dic . items ( ) ) <NEWLINE> for elem in dic_sort : <NEWLINE> <INDENT> if elem [ 0 ] != 1 : <NEWLINE> <INDENT> print ( elem [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . buffer . readline <NEWLINE> in_n = lambda : int ( input ( ) ) <NEWLINE> in_nn = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> in_s = lambda : input ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> in_map = lambda : [ s == ord ( <STRING> ) for s in input ( ) if s != ord ( <STRING> ) ] <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = 8 * 10 ** 18 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> N , M = in_nn ( ) <NEWLINE> X = list ( in_nn ( ) ) <NEWLINE> Y = list ( in_nn ( ) ) <NEWLINE> <NL> x_tsum = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x_tsum [ i + 1 ] += x_tsum [ i ] + X [ i ] <NEWLINE> x_tsum [ i + 1 ] %= MOD <NEWLINE> <NL> <DEDENT> x_sum = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> x_sum += X [ i ] * i - x_tsum [ i ] <NEWLINE> x_sum %= MOD <NEWLINE> <NL> <DEDENT> y_tsum = [ 0 ] * ( M + 1 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> y_tsum [ i + 1 ] += y_tsum [ i ] + Y [ i ] <NEWLINE> y_tsum [ i + 1 ] %= MOD <NEWLINE> <NL> <DEDENT> y_sum = 0 <NEWLINE> for i in range ( 1 , M ) : <NEWLINE> <INDENT> y_sum += Y [ i ] * i - y_tsum [ i ] <NEWLINE> y_sum %= MOD <NEWLINE> <NL> <DEDENT> print ( x_sum * y_sum % MOD ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> num = 0 <NEWLINE> k = - 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if i + k >= n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ - i ] == <STRING> : <NEWLINE> <INDENT> j = k + 1 <NEWLINE> while True : <NEWLINE> <INDENT> if j + i == n : <NEWLINE> <INDENT> k = j <NEWLINE> break <NEWLINE> <DEDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> s [ j ] = <STRING> <NEWLINE> s [ - i ] = <STRING> <NEWLINE> k = j <NEWLINE> num += 1 <NEWLINE> break <NEWLINE> <DEDENT> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 1 <NEWLINE> cnt = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> while i % 2 == 0 : <NEWLINE> <INDENT> i //= 2 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> route = [ 0 ] <NEWLINE> check = { 0 } <NEWLINE> now = 0 <NEWLINE> while A [ now ] not in check : <NEWLINE> <INDENT> route . append ( A [ now ] ) <NEWLINE> check . add ( A [ now ] ) <NEWLINE> now = A [ now ] <NEWLINE> <DEDENT> start = route . index ( A [ now ] ) <NEWLINE> loop = len ( route ) - start <NEWLINE> <NL> if K < len ( route ) : <NEWLINE> <INDENT> print ( route [ K ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= start <NEWLINE> K %= loop <NEWLINE> print ( route [ start + K ] + 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sintinel = 1000000001 <NEWLINE> <NL> def merge_sort ( A , l , r ) : <NEWLINE> <INDENT> if l + 1 < r : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> cnt1 = merge_sort ( A , l , mid ) <NEWLINE> cnt2 = merge_sort ( A , mid , r ) <NEWLINE> cnt3 = merge ( A , l , mid , r ) <NEWLINE> return ( cnt1 + cnt2 + cnt3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> def merge ( A , l , mid , r ) : <NEWLINE> <INDENT> n1 = len ( A [ l : mid ] ) <NEWLINE> L = A [ l : mid ] + [ sintinel ] <NEWLINE> R = A [ mid : r ] + [ sintinel ] <NEWLINE> i = j = 0 <NEWLINE> cnt = 0 <NEWLINE> for k in range ( l , r ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += n1 - i <NEWLINE> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> n = int ( sys . stdin . readline ( ) ) <NEWLINE> A = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> c = merge_sort ( A , 0 , n ) <NEWLINE> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num = max ( l ) + 1 <NEWLINE> rcd = [ 0 for _ in range ( num ) ] <NEWLINE> <NL> for v in l : <NEWLINE> <INDENT> rcd [ v ] += 1 <NEWLINE> <NL> <DEDENT> unq = [ ] <NEWLINE> for w in range ( num ) : <NEWLINE> <INDENT> if rcd [ w ] == 1 : <NEWLINE> <INDENT> unq . append ( w ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> rcd = [ 0 for _ in range ( num ) ] <NEWLINE> l = set ( l ) <NEWLINE> for x in l : <NEWLINE> <INDENT> for y in range ( 2 * x , num , x ) : <NEWLINE> <INDENT> rcd [ y ] = 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for z in unq : <NEWLINE> <INDENT> if rcd [ z ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import heapq as hq <NEWLINE> n , m = input ( ) . split ( ) <NEWLINE> hq . heapify ( a : = [ - int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> for i in range ( int ( m ) ) : hq . heappush ( a , - ( v : = - hq . heappop ( a ) // 2 ) ) <NEWLINE> print ( - sum ( a ) ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> n = len ( s ) <NEWLINE> p = 2019 <NEWLINE> S = [ 0 for i in range ( n + 1 ) ] <NEWLINE> ans = [ 0 ] * p <NEWLINE> <NL> x10 = 1 <NEWLINE> for j , i in enumerate ( s ) : <NEWLINE> <INDENT> S [ j + 1 ] = ( S [ j ] + ( x10 * int ( i ) ) ) % p <NEWLINE> x10 *= 10 <NEWLINE> x10 %= p <NEWLINE> ans [ S [ j + 1 ] ] += 1 <NEWLINE> <NL> <DEDENT> cnt = ans [ 0 ] <NEWLINE> for a in ans : <NEWLINE> <INDENT> cnt += ( a * ( a - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if math . gcd ( i , j ) == 1 : <NEWLINE> <INDENT> sum += K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for l in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( math . gcd ( i , j ) , l ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n , k = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a = [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> assert len ( a ) == n <NEWLINE> current = 0 <NEWLINE> visited = [ - 1 ] * n <NEWLINE> visited [ 0 ] = 0 <NEWLINE> for i in range ( 1 , k ) : <NEWLINE> <INDENT> current = a [ current ] <NEWLINE> if visited [ current ] == - 1 : <NEWLINE> <INDENT> visited [ current ] = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pre = visited [ current ] <NEWLINE> count = ( k - pre ) % ( i - pre ) + pre <NEWLINE> print ( visited . index ( count ) + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ current ] + 1 ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> def getStart ( field ) : <NEWLINE> <INDENT> search_field = field [ 1 : ] <COMMENT> <NEWLINE> for y in range ( len ( search_field ) ) : <NEWLINE> <INDENT> for x in range ( len ( search_field [ 0 ] ) ) : <NEWLINE> <INDENT> if search_field [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> return x , y + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def bfs ( field , start_x , start_y , goal_N ) : <NEWLINE> <INDENT> direction = [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] <NEWLINE> gotten_cheese = 1 <NEWLINE> distance = 0 <NEWLINE> que = [ ] <NEWLINE> que . append ( [ start_x , start_y ] ) <NEWLINE> INF = 1000000 <NEWLINE> min_path = [ [ INF ] * field [ 0 ] [ 1 ] for i in range ( field [ 0 ] [ 0 ] ) ] <NEWLINE> min_path [ start_y - 1 ] [ start_x ] = 0 <NEWLINE> while len ( que ) != 0 : <NEWLINE> <INDENT> current = que . pop ( 0 ) <NEWLINE> for d in direction : <NEWLINE> <INDENT> nx = current [ 0 ] + d [ 0 ] <NEWLINE> ny = current [ 1 ] + d [ 1 ] <NEWLINE> if 0 <= nx < field [ 0 ] [ 1 ] and 1 <= ny < field [ 0 ] [ 0 ] + 1 and field [ ny ] [ nx ] != <STRING> and min_path [ ny - 1 ] [ nx ] == INF : <NEWLINE> <INDENT> min_path [ ny - 1 ] [ nx ] = min_path [ current [ 1 ] - 1 ] [ current [ 0 ] ] + 1 <NEWLINE> if field [ ny ] [ nx ] == gotten_cheese : <COMMENT> <NEWLINE> <INDENT> distance += min_path [ ny - 1 ] [ nx ] <NEWLINE> if field [ ny ] [ nx ] == goal_N : <COMMENT> <NEWLINE> <INDENT> print ( distance ) <NEWLINE> return <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> que = [ ] <NEWLINE> que . append ( [ nx , ny ] ) <NEWLINE> gotten_cheese += 1 <NEWLINE> min_path = [ [ INF ] * field [ 0 ] [ 1 ] for i in range ( field [ 0 ] [ 0 ] ) ] <NEWLINE> min_path [ ny - 1 ] [ nx ] = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> que . append ( [ nx , ny ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( field ) : <NEWLINE> <INDENT> sx , sy = getStart ( field ) <NEWLINE> bfs ( field , sx , sy , field [ 0 ] [ 2 ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> matrix = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> row = input ( ) . rstrip ( ) . split ( ) <NEWLINE> if len ( row ) == 3 : <NEWLINE> <INDENT> re_row = [ ] <NEWLINE> for i in row : <NEWLINE> <INDENT> re_row . append ( int ( i ) ) <NEWLINE> <DEDENT> matrix . append ( re_row ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re_row = [ ] <NEWLINE> for char in row [ 0 ] : <NEWLINE> <INDENT> if char . isdigit ( ) : <NEWLINE> <INDENT> re_row . append ( int ( char ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re_row . append ( char ) <NEWLINE> <DEDENT> <DEDENT> matrix . append ( re_row ) <NEWLINE> <DEDENT> if len ( matrix ) == int ( matrix [ 0 ] [ 0 ] ) + 1 : <NEWLINE> <INDENT> main ( matrix ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A1 = np . zeros ( n , dtype = bool ) <NEWLINE> Ai = np . zeros ( n , dtype = bool ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> A1 [ b - 1 ] = True <NEWLINE> <DEDENT> if b == n : <NEWLINE> <INDENT> Ai [ a - 1 ] = True <NEWLINE> <DEDENT> <DEDENT> if np . any ( Ai [ A1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
o = input ( ) <NEWLINE> e = input ( ) <NEWLINE> O = len ( o ) <NEWLINE> E = len ( e ) <NEWLINE> a = [ ] <NEWLINE> if O == E : <NEWLINE> <INDENT> for i in range ( O ) : <NEWLINE> <INDENT> a . append ( o [ i ] + e [ i ] ) <NEWLINE> <DEDENT> b = <STRING> . join ( a ) <NEWLINE> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( E ) : <NEWLINE> <INDENT> a . append ( o [ i ] + e [ i ] ) <NEWLINE> <DEDENT> a . append ( o [ O - 1 ] ) <NEWLINE> b = <STRING> . join ( a ) <NEWLINE> print ( b ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> C = Counter ( s ) <NEWLINE> r , g , b = C [ <STRING> ] , C [ <STRING> ] , C [ <STRING> ] <NEWLINE> ans = r * g * b <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k <= n - 1 and s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> print ( <STRING> . format ( s // 3600 , ( s % 3600 ) // 60 , s % 60 ) ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> now = K <NEWLINE> sum = 0 <NEWLINE> <NL> if A < K : <NEWLINE> <INDENT> now -= A <NEWLINE> sum += A <NEWLINE> if B < now : <NEWLINE> <INDENT> now -= B <NEWLINE> print ( sum - now ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT>
import time <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> start = time . time ( ) <NEWLINE> def function ( x , y , z ) : <NEWLINE> <INDENT> return pow ( x , 2 ) + pow ( y , 2 ) + pow ( z , 2 ) + ( x * y ) + ( x * z ) + ( y * z ) <NEWLINE> <NL> <DEDENT> p = list ( itertools . product ( range ( 1 , 100 ) , repeat = 3 ) ) <NEWLINE> a = [ ] <NEWLINE> <NL> for p_in in p : <NEWLINE> <INDENT> a . append ( function ( p_in [ 0 ] , p_in [ 1 ] , p_in [ 2 ] ) ) <NEWLINE> <NL> <DEDENT> dict = collections . Counter ( a ) <NEWLINE> <NL> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( dict [ n ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_A = 1 <NEWLINE> <NL> for i in range ( 0 , len ( A ) ) : <NEWLINE> <INDENT> if ( A [ i ] == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , len ( A ) ) : <NEWLINE> <INDENT> if ( sum_A > 1000000000000000000 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sum_A *= A [ i ] <NEWLINE> <DEDENT> if ( sum_A > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( sum_A ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( x ) - x [ 0 ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans = ans + x [ i ] * s <NEWLINE> s = s - x [ i + 1 ] <NEWLINE> <DEDENT> ans = ans % 1000000007 <NEWLINE> <NL> <NL> print ( ans ) <NEWLINE>
import math , sys <NEWLINE> <NL> <COMMENT> <NL> class SegmentTree ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . TreeRange = pow ( 2 , math . ceil ( math . log2 ( n ) ) ) <NEWLINE> self . List = [ 0 ] * ( 2 * self . TreeRange - 1 ) <NEWLINE> <NL> <DEDENT> def add ( self , i , x ) : <NEWLINE> <INDENT> i += self . TreeRange - 1 <NEWLINE> self . List [ i ] += x <NEWLINE> while i > 0 : <NEWLINE> <INDENT> i = ( i - 1 ) // 2 <NEWLINE> self . List [ i ] += x <NEWLINE> <NL> <DEDENT> <DEDENT> def getsum ( self , s , t , i = 0 , left = 0 , right = float ( <STRING> ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> if right <= s or t <= left : <NEWLINE> <INDENT> return 0 <NEWLINE> <COMMENT> <NL> <DEDENT> elif s <= left <= right <= t : <NEWLINE> <INDENT> return self . List [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> l = self . getsum ( s , t , i * 2 + 1 , left , ( left + right ) // 2 ) <NEWLINE> r = self . getsum ( s , t , i * 2 + 2 , ( left + right ) // 2 , right ) <NEWLINE> return l + r <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> _input = sys . stdin . readlines ( ) <NEWLINE> n , q = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> qlist = map ( lambda x : x . split ( ) , _input [ 1 : ] ) <NEWLINE> ST = SegmentTree ( n ) <NEWLINE> <NL> for q in qlist : <NEWLINE> <INDENT> cmd , x , y = map ( int , q ) <NEWLINE> if cmd == 0 : <NEWLINE> <INDENT> ST . add ( x - 1 , y ) <NEWLINE> <DEDENT> elif cmd == 1 : <NEWLINE> <INDENT> print ( ST . getsum ( x - 1 , y , right = ST . TreeRange ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( readline ( ) . rstrip ( ) ) <NEWLINE> aList = sorted ( list ( map ( int , readline ( ) . rstrip ( ) . split ( ) ) ) ) <NEWLINE> z = [ 0 ] * n <NEWLINE> for a in aList : <NEWLINE> <INDENT> z [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( z [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def display ( inp ) : <NEWLINE> <INDENT> s = len ( inp ) <NEWLINE> for i in range ( s ) : <NEWLINE> <INDENT> if i != len ( inp ) - 1 : <NEWLINE> <INDENT> print ( <STRING> % inp [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % inp [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> line = sys . stdin . readline ( ) <NEWLINE> size = int ( line ) <NEWLINE> line = sys . stdin . readline ( ) <NEWLINE> inp = [ ] <NEWLINE> for i in line . split ( <STRING> ) : <NEWLINE> <INDENT> inp . append ( int ( i ) ) <NEWLINE> <NL> <DEDENT> display ( inp ) <NEWLINE> <NL> for i in range ( 1 , size ) : <NEWLINE> <INDENT> if inp [ i ] != size : <NEWLINE> <INDENT> check = inp . pop ( i ) <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> if check < inp [ j ] : <NEWLINE> <INDENT> inp . insert ( j , check ) <NEWLINE> break <NEWLINE> <DEDENT> if j == i - 1 : <NEWLINE> <INDENT> inp . insert ( j + 1 , check ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> display ( inp ) <NEWLINE> <DEDENT>
N , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a [ i ] -= 1 <NEWLINE> <DEDENT> if a [ 0 ] == 0 : print ( 1 ) ; exit ( ) <NEWLINE> c = dict ( ) <NEWLINE> visited = [ False ] * N <NEWLINE> visited [ 0 ] = True <NEWLINE> c [ 0 ] = 0 <NEWLINE> cnt = 0 <NEWLINE> dap = 0 <NEWLINE> n = 0 <NEWLINE> b = [ 0 ] <NEWLINE> while True : <NEWLINE> <INDENT> n = a [ n ] <NEWLINE> if visited [ n ] : <NEWLINE> <INDENT> dap = c [ n ] <NEWLINE> break <NEWLINE> <DEDENT> visited [ n ] = True <NEWLINE> b . append ( n ) <NEWLINE> cnt += 1 <NEWLINE> c [ n ] = cnt <NEWLINE> <DEDENT> l = len ( c ) <NEWLINE> if k < dap : <NEWLINE> <INDENT> print ( b [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b [ ( k - dap ) % ( l - dap ) + dap ] + 1 ) <NEWLINE> <DEDENT>
x , y , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> plst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> qlst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> rlst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> plst . sort ( ) <NEWLINE> qlst . sort ( ) <NEWLINE> rlst . sort ( reverse = True ) <NEWLINE> inf = 10 ** 20 <NEWLINE> plst = plst [ - x : ] + [ inf ] <NEWLINE> qlst = qlst [ - y : ] + [ inf ] <NEWLINE> r_pos = 0 <NEWLINE> p_pos = 0 <NEWLINE> q_pos = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if rlst [ r_pos ] <= plst [ p_pos ] and rlst [ r_pos ] <= qlst [ q_pos ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif plst [ p_pos ] < qlst [ q_pos ] : <NEWLINE> <INDENT> plst [ p_pos ] = rlst [ r_pos ] <NEWLINE> p_pos += 1 <NEWLINE> r_pos += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> qlst [ q_pos ] = rlst [ r_pos ] <NEWLINE> q_pos += 1 <NEWLINE> r_pos += 1 <NEWLINE> <DEDENT> if r_pos == c : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ( plst ) + sum ( qlst ) - inf * 2 ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> l = 0 <NEWLINE> r = len ( s ) - 1 <NEWLINE> while l < r : <NEWLINE> <INDENT> if s [ l ] != s [ r ] : <NEWLINE> <INDENT> if s [ l ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> r += 1 <NEWLINE> <DEDENT> elif s [ r ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> l -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> l += 1 <NEWLINE> r -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <INDENT> n = int ( s ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> M = [ [ None for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> x = n // 2 <NEWLINE> y = n // 2 + 1 <NEWLINE> M [ y ] [ x ] = 1 <NEWLINE> x = x + 1 <NEWLINE> y = y + 1 <NEWLINE> counter = 2 <NEWLINE> <NL> while counter < n * n + 1 : <NEWLINE> <NL> <INDENT> if x >= n : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> elif x < 0 : <NEWLINE> <INDENT> x = n - 1 <NEWLINE> <NL> <DEDENT> if y >= n : <NEWLINE> <INDENT> y = 0 <NEWLINE> <DEDENT> elif y < 0 : <NEWLINE> <INDENT> y = n - 1 <NEWLINE> <NL> <DEDENT> if M [ y ] [ x ] is not None : <NEWLINE> <INDENT> x -= 1 <NEWLINE> y += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> M [ y ] [ x ] = counter <NEWLINE> counter += 1 <NEWLINE> x += 1 <NEWLINE> y += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for row in M : <NEWLINE> <INDENT> for v in row : <NEWLINE> <INDENT> print ( str ( v ) . rjust ( 4 ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> if X >= K * D : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( K - X // D ) % 2 == 0 : <NEWLINE> <INDENT> print ( X - X // D * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( X // D + 1 ) * D - X ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> M = 0 <NEWLINE> sum = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum += A [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> sum = sum - A [ i ] <NEWLINE> M += A [ i ] * sum <NEWLINE> if M > 10 ** 9 + 7 : <NEWLINE> <INDENT> M = M % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> <DEDENT> print ( M ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000000 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> ans = sum ( a ) <NEWLINE> <NL> x = [ 0 ] * ( 10 ** 5 + 10 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> x [ i ] += 1 <NEWLINE> <NL> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += x [ b ] * c - x [ b ] * b <NEWLINE> print ( ans ) <NEWLINE> x [ c ] += x [ b ] <NEWLINE> x [ b ] = 0 <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> def calc ( ) : <NEWLINE> <INDENT> for A in range ( - 200 , 201 , 1 ) : <NEWLINE> <INDENT> for B in range ( - 200 , 201 , 1 ) : <NEWLINE> <INDENT> if pow ( A , 5 ) - pow ( B , 5 ) == X : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> calc ( ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> trace = [ 0 ] * N <NEWLINE> loop_start = 0 <NEWLINE> loop_before = 0 <NEWLINE> cnt = 0 <NEWLINE> all_cnt = 0 <NEWLINE> <NL> if K > N : <NEWLINE> <INDENT> loop = 0 <NEWLINE> now = 0 <NEWLINE> while ( 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> trace [ now ] += 1 <NEWLINE> if trace [ now ] == 3 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if trace [ now ] == 2 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> loop += 1 <NEWLINE> if cnt == 1 : <NEWLINE> <INDENT> loop_start = now <NEWLINE> loop_before = all_cnt <NEWLINE> <DEDENT> <DEDENT> now = A [ now ] - 1 <NEWLINE> all_cnt += 1 <NEWLINE> <NL> <DEDENT> loop_before = loop_before - loop <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> min_K = ( K - 1 - loop_before ) % loop <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> now = 0 <NEWLINE> for i in range ( loop_before ) : <NEWLINE> <INDENT> now = A [ now ] - 1 <NEWLINE> <DEDENT> for i in range ( min_K ) : <NEWLINE> <INDENT> now = A [ now ] - 1 <NEWLINE> <DEDENT> print ( A [ now ] ) <NEWLINE> <NL> <DEDENT> if K <= N : <NEWLINE> <INDENT> now = 0 <NEWLINE> for i in range ( K - 1 ) : <NEWLINE> <INDENT> now = A [ now ] - 1 <NEWLINE> <DEDENT> print ( A [ now ] ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT>
<NL> <COMMENT> <NL> <NL> def solution ( nums ) : <NEWLINE> <INDENT> n = len ( nums ) <NEWLINE> dp = [ 0 , 0 , 0 ] <NEWLINE> for day in range ( n ) : <NEWLINE> <INDENT> new_dp = [ 0 , 0 , 0 ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> new_dp [ i ] = max ( new_dp [ i ] , dp [ j ] + nums [ day ] [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dp = new_dp <NEWLINE> <DEDENT> return max ( dp [ 0 ] , dp [ 1 ] , dp [ 2 ] ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> nums = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> day = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nums . append ( day ) <NEWLINE> <DEDENT> res = solution ( nums ) <NEWLINE> print ( res ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> union = UnionFind ( N ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> union . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , union . size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> s = input ( ) <NEWLINE> <NL> s = s [ : : - 1 ] <NEWLINE> <NL> x = 1 <NEWLINE> mod = 2019 <NEWLINE> total = 0 <NEWLINE> ans = 0 <NEWLINE> cnt = Counter ( ) <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> cnt [ total ] += 1 <NEWLINE> total = total + int ( s [ i ] ) * x <NEWLINE> total %= mod <NEWLINE> ans += cnt [ total ] <NEWLINE> x = x * 10 % mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ls = list ( S ) <NEWLINE> if len ( S ) > K : <NEWLINE> <INDENT> ansl = ls [ 0 : K ] <NEWLINE> print ( <STRING> . join ( ansl ) + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> r = [ ] <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> r . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> n = len ( r ) <NEWLINE> maxv = - 20000000000 <NEWLINE> minv = r [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> maxv = max ( [ maxv , r [ i ] - minv ] ) <NEWLINE> minv = min ( [ minv , r [ i ] ] ) <NEWLINE> <NL> <DEDENT> print ( maxv ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
nums = <STRING> <NEWLINE> count = 1 <NEWLINE> a = input ( ) <NEWLINE> W = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> W . reverse ( ) <NEWLINE> for i in W : <NEWLINE> <INDENT> if count == int ( a ) : <NEWLINE> <INDENT> nums += str ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nums += str ( i ) + <STRING> <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> print ( nums ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> to = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> to [ a ] . append ( b ) <NEWLINE> to [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> q = deque ( [ 1 ] ) <NEWLINE> dist = [ - 1 ] * ( n + 1 ) <NEWLINE> <COMMENT> <NL> <NL> while q : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> <NL> for u in to [ v ] : <NEWLINE> <INDENT> if dist [ u ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q . append ( u ) <NEWLINE> dist [ u ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( dist [ i ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> a_sum = sum ( A ) <NEWLINE> a_cum = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a_cum [ i + 1 ] = a_cum [ i ] + A [ i ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * ( a_sum - a_cum [ i + 1 ] ) % mod <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> res = [ 0 for i in range ( 10 ** 4 ) ] <NEWLINE> for x in range ( 1 , math . ceil ( math . sqrt ( 10 ** 4 ) ) ) : <NEWLINE> <INDENT> for y in range ( 1 , math . ceil ( math . sqrt ( 10 ** 4 ) ) ) : <NEWLINE> <INDENT> for z in range ( 1 , math . ceil ( math . sqrt ( 10 ** 4 ) ) ) : <NEWLINE> <INDENT> ans = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if ans <= 10 ** 4 : <NEWLINE> <INDENT> res [ ans - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> print ( res [ n ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> l . append ( 2 ) <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> l . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( l [ - 1 ] + l [ - 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( l [ n ] ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> <NL> if a == <STRING> and b == <STRING> : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <DEDENT> if a == <STRING> and b == <STRING> : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <DEDENT> if a == <STRING> and b == <STRING> : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <DEDENT> if a == <STRING> and b == <STRING> : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= A . pop ( 0 ) <NEWLINE> if ans > MOD : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> matrix_a = [ ] <NEWLINE> matrix_b = [ ] <NEWLINE> matrix_c = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> matrix_a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> matrix_b . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> tmp_l = list ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> tmp_n = 0 <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> tmp_n += matrix_a [ i ] [ k ] * matrix_b [ k ] [ j ] <NEWLINE> <DEDENT> tmp_l . append ( tmp_n ) <NEWLINE> <DEDENT> matrix_c . append ( tmp_l . copy ( ) ) <NEWLINE> tmp_l . clear ( ) <NEWLINE> <DEDENT> for i in matrix_c : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for j in i : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> if tmp == l : <NEWLINE> <INDENT> print ( j , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( j , <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> C = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> C . sort ( ) <NEWLINE> <NL> i = 0 <NEWLINE> <NL> while i < N : <NEWLINE> <INDENT> print ( C [ i ] , end = <STRING> ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> s = s . split ( <STRING> ) <NEWLINE> N = s [ 0 ] <NEWLINE> K = int ( s [ 1 ] ) <NEWLINE> <NL> s = input ( ) <NEWLINE> s = s . split ( <STRING> ) <NEWLINE> ds = [ int ( digit ) for digit in s ] <NEWLINE> <NL> minNum = min ( [ digit for digit in range ( 0 , 10 ) if digit not in ds ] ) <NEWLINE> nonZerominNum = min ( [ digit for digit in range ( 1 , 10 ) if digit not in ds ] ) <NEWLINE> maxNum = max ( [ digit for digit in range ( 0 , 10 ) if digit not in ds ] ) <NEWLINE> <NL> digits = [ int ( digit ) for digit in N ] <NEWLINE> <NL> result = N <NEWLINE> for index in range ( 0 , len ( digits ) ) : <NEWLINE> <INDENT> digit = digits [ index ] <NEWLINE> if digit in ds : <NEWLINE> <INDENT> i = index <NEWLINE> if digit > maxNum : <NEWLINE> <INDENT> i = index - 1 <NEWLINE> while i >= 0 and digits [ i ] == maxNum : <NEWLINE> <INDENT> i -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if i < 0 : <NEWLINE> <INDENT> result = str ( nonZerominNum ) + ( str ( minNum ) * len ( N ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> biggerDigit = min ( [ d for d in range ( 0 , 10 ) if d not in ds and d > digits [ i ] ] ) <NEWLINE> digits [ i ] = biggerDigit <NEWLINE> for j in range ( i + 1 , len ( digits ) ) : <NEWLINE> <INDENT> digits [ j ] = minNum <NEWLINE> <DEDENT> result = <STRING> . join ( [ str ( digit ) for digit in digits ] ) <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = [ 1 , 0 , - 1 ] <NEWLINE> maxres = 0 <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> if L [ 3 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> maxres += L [ i ] * n [ i ] <NEWLINE> L [ 3 ] -= L [ i ] <NEWLINE> <COMMENT> <NL> if L [ 3 ] < 0 : <NEWLINE> <INDENT> maxres -= abs ( L [ 3 ] ) * n [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( maxres ) <NEWLINE>
import itertools <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> l = list ( range ( 1 , M + 1 ) ) <NEWLINE> ans = [ ] <NEWLINE> for v in itertools . combinations_with_replacement ( l , N ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = s [ i ] <NEWLINE> if v [ b - 1 ] - v [ a - 1 ] == c : <NEWLINE> <INDENT> count += d <NEWLINE> <DEDENT> <DEDENT> ans . append ( count ) <NEWLINE> <DEDENT> print ( max ( 0 , max ( ans ) ) ) <NEWLINE>
import math <NEWLINE> <NL> A , B , C , D = input ( ) . split ( ) <NEWLINE> <NL> T_hp = int ( A ) <NEWLINE> T_atk = int ( B ) <NEWLINE> A_hp = int ( C ) <NEWLINE> A_atk = int ( D ) <NEWLINE> <NL> T_burstturn = math . ceil ( T_hp / A_atk ) <NEWLINE> A_burstturn = math . ceil ( A_hp / T_atk ) <NEWLINE> <NL> if T_burstturn < A_burstturn : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] * ( n ) <NEWLINE> p = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> p = ls [ i ] <NEWLINE> a [ p - 1 ] += 1 <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> print ( a [ j ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> c = { } <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b . append ( a [ i ] + i + 1 ) <NEWLINE> x = - a [ i ] + i + 1 <NEWLINE> if x in c : <NEWLINE> <INDENT> c [ x ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ x ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if b [ i ] in c : <NEWLINE> <INDENT> ans += c [ b [ i ] ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X , N = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> p = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> nlist = [ 0 for i in range ( 105 ) ] <NEWLINE> for i in p : <NEWLINE> <INDENT> nlist [ i ] = 1 <NEWLINE> <DEDENT> for i in range ( max ( X + 1 , 100 - X + 1 ) ) : <NEWLINE> <NL> <INDENT> if X - i >= 0 : <NEWLINE> <INDENT> if nlist [ X - i ] == 0 : <NEWLINE> <INDENT> result = X - i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if X + i <= 101 : <NEWLINE> <INDENT> if nlist [ X + i ] == 0 : <NEWLINE> <INDENT> result = X + i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
def prod ( n , A ) : <NEWLINE> <INDENT> if 0 in A : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> p = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> if p * a <= 10 ** 18 : <NEWLINE> <INDENT> p *= a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return p <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( prod ( n , A ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_list . sort ( ) <NEWLINE> <COMMENT> <NL> if A_list [ 0 ] == 0 : <NEWLINE> <INDENT> answer = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = 1 <NEWLINE> for a in A_list : <NEWLINE> <INDENT> answer *= a <NEWLINE> if len ( str ( answer - 1 ) ) > 18 : <NEWLINE> <INDENT> answer = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
import sys <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 10 ** 9 + 7 <COMMENT> <NEWLINE> sys . setrecursionlimit ( 2147483647 ) <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> import networkx as nx <NEWLINE> def resolve ( ) : <NEWLINE> <INDENT> m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> G = nx . Graph ( ) <NEWLINE> G . add_nodes_from ( range ( m + n + 2 ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> for j , c in enumerate ( input ( ) ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> G . add_edge ( i , m + j , capacity = 1 ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> G . add_edge ( - 1 , i , capacity = INF ) <NEWLINE> G . add_edge ( - 1 , m + j , capacity = INF ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> G . add_edge ( i , m + n , capacity = INF ) <NEWLINE> G . add_edge ( m + j , m + n , capacity = INF ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = nx . algorithms . flow . maximum_flow_value ( G , - 1 , m + n ) <NEWLINE> if ans >= INF : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
A , B , C , K = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> ans = K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A <NEWLINE> tmp = K - A <NEWLINE> if B >= tmp : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = tmp - B <NEWLINE> ans += tmp * ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> b = B [ i ] <NEWLINE> a = bisect . bisect_left ( A , b ) <NEWLINE> c = bisect . bisect_right ( C , b ) <NEWLINE> ans += a * ( N - c ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> Ai = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 0 , N - K ) : <NEWLINE> <NL> <INDENT> if ( Ai [ i ] < Ai [ i + K ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> X , N = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> if N != 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> elif N == 0 : <NEWLINE> <INDENT> p = [ - 1 ] <NEWLINE> <DEDENT> p . sort ( ) <NEWLINE> <COMMENT> <NL> ans = [ ] <NEWLINE> for i in range ( - 1 , 102 ) : <NEWLINE> <INDENT> if i not in p : <NEWLINE> <INDENT> ans . append ( ( abs ( i - X ) , i ) ) <NEWLINE> <DEDENT> <DEDENT> ans . sort ( ) <NEWLINE> print ( ans [ 0 ] [ 1 ] ) <NEWLINE>
import math <NEWLINE> import collections <NEWLINE> import fractions <NEWLINE> import itertools <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = collections . Counter ( t ) <NEWLINE> d = collections . Counter ( d ) <NEWLINE> for i in t : <NEWLINE> <INDENT> if t [ i ] > d [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> def D_func ( x ) : <NEWLINE> <INDENT> return math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> <DEDENT> print ( D_func ( min ( B - 1 , N ) ) ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> pi = math . pi <NEWLINE> men = ( r ** 2 ) * pi <NEWLINE> syu = 2 * r * pi <NEWLINE> <NL> print ( <STRING> . format ( men , syu ) ) <NEWLINE>
d = 1000000007 <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> summation = sum ( a ) <NEWLINE> diagonal = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> diagonal += a [ i ] ** 2 <NEWLINE> <DEDENT> ans = ( ( ( summation ** 2 ) - diagonal ) // 2 ) % d <NEWLINE> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> number = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum_number = sum ( number ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> number_count = Counter ( number ) <NEWLINE> <NL> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> sum_number += ( C - B ) * number_count [ B ] <NEWLINE> number_count [ C ] += number_count [ B ] <NEWLINE> number_count [ B ] = 0 <NEWLINE> print ( sum_number ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> ops = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ops . append ( ( b , c ) ) <NEWLINE> <NL> <DEDENT> cnt = Counter ( A ) <NEWLINE> s = sum ( k * v for k , v in cnt . items ( ) ) <NEWLINE> for b , c in ops : <NEWLINE> <INDENT> s -= b * cnt [ b ] <NEWLINE> s += c * cnt [ b ] <NEWLINE> cnt [ c ] += cnt [ b ] <NEWLINE> cnt [ b ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
import functools <NEWLINE> from math import gcd <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MAX = 10 ** 6 + 10 <NEWLINE> <NL> if functools . reduce ( gcd , A ) != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> prime_list = [ i for i in range ( MAX + 1 ) ] <NEWLINE> p = 2 <NEWLINE> while p * p <= MAX : <NEWLINE> <INDENT> if prime_list [ p ] == p : <NEWLINE> <INDENT> for q in range ( 2 * p , MAX + 1 , p ) : <NEWLINE> <INDENT> if prime_list [ q ] == q : <NEWLINE> <INDENT> prime_list [ q ] = p <NEWLINE> <DEDENT> <DEDENT> <DEDENT> p += 1 <NEWLINE> <NL> <DEDENT> prime = set ( ) <NEWLINE> for a in A : <NEWLINE> <INDENT> tmp = set ( ) <NEWLINE> while a > 1 : <NEWLINE> <INDENT> tmp . add ( prime_list [ a ] ) <NEWLINE> a //= prime_list [ a ] <NEWLINE> <DEDENT> for p in tmp : <NEWLINE> <INDENT> if p in prime : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> prime . add ( p ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> n_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in n_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <INDENT> product = 1 <NEWLINE> for num in n_list : <NEWLINE> <INDENT> product = product * num <NEWLINE> <NL> if product > 10 ** 18 : <NEWLINE> <INDENT> product = - 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( product ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> data = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> data [ a - 1 ] . append ( b ) <NEWLINE> data [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> que = deque ( [ 1 ] ) <NEWLINE> ans = [ 0 for i in range ( N ) ] <NEWLINE> while True : <NEWLINE> <INDENT> cur = que . popleft ( ) <NEWLINE> for item in data [ cur - 1 ] : <NEWLINE> <INDENT> if ans [ item - 1 ] == 0 : <NEWLINE> <INDENT> que . append ( item ) <NEWLINE> ans [ item - 1 ] = cur <NEWLINE> <DEDENT> <DEDENT> if len ( que ) == 0 : break <NEWLINE> <NL> <DEDENT> if 0 in ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : print ( ans [ i ] ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> <NL> <NL> MOD = pow ( 10 , 9 ) + 7 <NEWLINE> <NL> <NL> def solve ( S ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if S < 3 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> A = [ 1 for _ in range ( S + 1 ) ] <NEWLINE> A [ 0 ] = A [ 1 ] = A [ 2 ] = 0 <NEWLINE> for i in range ( 3 , S + 1 ) : <NEWLINE> <INDENT> k = 3 <NEWLINE> while i - k >= 0 : <NEWLINE> <INDENT> A [ i ] = A [ i - k ] + A [ i ] % MOD <NEWLINE> k += 1 <NEWLINE> <DEDENT> <DEDENT> return A [ S ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import sys <NEWLINE> S = int ( sys . stdin . readline ( ) ) <NEWLINE> print ( solve ( S ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> def gcp ( a , b ) : <NEWLINE> <INDENT> while b % a != 0 : <NEWLINE> <INDENT> mod = b % a <NEWLINE> b = a <NEWLINE> a = mod <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> r = gcp ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcp ( r , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( A ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> s -= A [ i ] <NEWLINE> ans += A [ i ] * s <NEWLINE> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( q ) ] <NEWLINE> ans = [ ] <NEWLINE> def calc ( n ) : <NEWLINE> <INDENT> return n - q <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( k ) <NEWLINE> <DEDENT> ans = list ( map ( calc , ans ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ans [ i ] <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> data = stdin . readlines ( ) <NEWLINE> <NL> a = int ( data [ 0 ] ) <NEWLINE> b = [ int ( s ) for s in data [ 1 ] . split ( ) ] <NEWLINE> <NL> if 0 in b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( 0 , a ) : <NEWLINE> <INDENT> ans = ans * b [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> m = min ( n , b - 1 ) <NEWLINE> print ( int ( a * m / b ) - a * int ( m / b ) ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> s = list ( input ( ) ) <NEWLINE> s . reverse ( ) <NEWLINE> n = len ( s ) <NEWLINE> now = 0 <NEWLINE> mods = [ 0 ] * 2019 <NEWLINE> mods [ 0 ] += 1 <NEWLINE> ten = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> now += ten * int ( s [ i ] ) <NEWLINE> now %= 2019 <NEWLINE> ten *= 10 <NEWLINE> ten %= 2019 <NEWLINE> mods [ now ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in mods : <NEWLINE> <INDENT> ans += ( i * ( i - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lst = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> lst . sort ( ) <NEWLINE> <COMMENT> <NL> <NL> if 1 in lst : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if lst [ i ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if count == 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if count == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tf_lst = [ 1 ] * lst [ n - 1 ] <NEWLINE> count = 0 <NEWLINE> if n > 1 : <NEWLINE> <INDENT> pre = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tf_lst [ pre : lst [ i ] - 1 ] = [ 0 ] * ( lst [ i ] - pre - 1 ) <NEWLINE> pre = lst [ i ] <NEWLINE> if tf_lst [ lst [ i ] - 1 ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i <= n - 2 : <NEWLINE> <INDENT> if lst [ i ] == lst [ i + 1 ] : <NEWLINE> <INDENT> tf_lst [ lst [ i ] - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> for j in range ( lst [ i ] * 2 , lst [ n - 1 ] + 1 , lst [ i ] ) : <NEWLINE> <INDENT> tf_lst [ j - 1 ] = 0 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in tf_lst : <NEWLINE> <INDENT> count += i <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sa = [ 0 ] * ( n + 1 ) <NEWLINE> sb = [ 0 ] * ( m + 1 ) <NEWLINE> r = m <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> sa [ i + 1 ] = sa [ i ] + a [ i ] <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> sb [ i + 1 ] = sb [ i ] + b [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if sa [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while sa [ i ] + sb [ r ] > k : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + r ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
tmp = ( input ( ) . split ( <STRING> ) ) <NEWLINE> n = int ( tmp [ 0 ] ) <NEWLINE> k = int ( tmp [ 1 ] ) <NEWLINE> tmp = input ( ) . split ( <STRING> ) <NEWLINE> map_tmp = map ( int , tmp ) <NEWLINE> grades = list ( map_tmp ) <NEWLINE> j = k <NEWLINE> while j < n : <NEWLINE> <INDENT> curr_res = grades [ j ] <NEWLINE> prev_res = grades [ j - k ] <NEWLINE> if curr_res > prev_res : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> j += 1 <NEWLINE> <DEDENT>
class Tree ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . nodes = { } <NEWLINE> <DEDENT> def add_node ( self , id ) : <NEWLINE> <INDENT> if id not in self . nodes : <NEWLINE> <INDENT> self . nodes [ id ] = Node ( id ) <NEWLINE> <DEDENT> <DEDENT> def add_child ( self , parent_id , child_id ) : <NEWLINE> <INDENT> self . add_node ( parent_id ) <NEWLINE> self . add_node ( child_id ) <NEWLINE> self . nodes [ parent_id ] . add_child ( self . nodes [ child_id ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , id ) : <NEWLINE> <INDENT> self . id = id <NEWLINE> self . parent = None <NEWLINE> self . children = [ ] <NEWLINE> self . depth = 0 <NEWLINE> self . nodetype = <STRING> <NEWLINE> <NL> <DEDENT> def add_child ( self , child ) : <NEWLINE> <INDENT> self . children . append ( child ) <NEWLINE> child . parent = self <NEWLINE> child . update_depth ( ) <NEWLINE> child . update_nodetype ( ) <NEWLINE> self . update_nodetype ( ) <NEWLINE> if self . parent : <NEWLINE> <INDENT> self . parent . update_nodetype ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def update_depth ( self ) : <NEWLINE> <INDENT> depth = self . depth <NEWLINE> if self . parent : <NEWLINE> <INDENT> self . depth = self . parent . depth + 1 <NEWLINE> <DEDENT> if depth != self . depth : <NEWLINE> <INDENT> for child in self . children : <NEWLINE> <INDENT> child . update_depth ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def update_nodetype ( self ) : <NEWLINE> <INDENT> if self . parent : <NEWLINE> <INDENT> if len ( self . children ) : <NEWLINE> <INDENT> self . nodetype = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . nodetype = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> self . nodetype = <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def walk ( self ) : <NEWLINE> <INDENT> yield self <NEWLINE> for child in self . children : <NEWLINE> <INDENT> for node in child . walk ( ) : <NEWLINE> <INDENT> yield node <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> parent = self . parent . id if self . parent else - 1 <NEWLINE> children = <STRING> . join ( [ str ( node . id ) for node in self . children ] ) <NEWLINE> return <STRING> . format ( self . id , parent , self . depth , self . nodetype , children ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> tree = Tree ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> line = input ( ) . split ( ) <NEWLINE> id = int ( line [ 0 ] ) <NEWLINE> tree . add_node ( id ) <NEWLINE> for ci in map ( int , line [ 2 : ] ) : <NEWLINE> <INDENT> tree . add_child ( id , ci ) <NEWLINE> <NL> <DEDENT> <DEDENT> for id in tree . nodes : <NEWLINE> <INDENT> print ( tree . nodes [ id ] ) <NEWLINE> <DEDENT>
from bisect import bisect_left <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> tree = [ list ( ) for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> tree [ u ] . append ( v ) <NEWLINE> tree [ v ] . append ( u ) <NEWLINE> <NL> <DEDENT> ans = [ 1 ] * N <NEWLINE> <NL> <COMMENT> <NL> def dfs ( u , par ) : <NEWLINE> <INDENT> nonlocal ans <NEWLINE> nonlocal dp <NEWLINE> pos = bisect_left ( dp , A [ u ] ) <NEWLINE> old = dp [ pos ] <NEWLINE> dp [ pos ] = A [ u ] <NEWLINE> <NL> ans [ u ] = bisect_left ( dp , float ( <STRING> ) ) - 1 <NEWLINE> <NL> for v in tree [ u ] : <NEWLINE> <INDENT> if v == par : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( v , u ) <NEWLINE> <NL> <DEDENT> dp [ pos ] = old <NEWLINE> <NL> <DEDENT> dp = [ float ( <STRING> ) ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = float ( <STRING> ) <NEWLINE> dfs ( 0 , - 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> main ( ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> import bisect <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> aa = list ( accumulate ( a ) ) <NEWLINE> aa . insert ( 0 , 0 ) <NEWLINE> bb = list ( accumulate ( b ) ) <NEWLINE> bb . insert ( 0 , 0 ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if aa [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> nokori = k - aa [ i ] <NEWLINE> kazu = bisect . bisect_right ( bb , nokori ) <NEWLINE> ans = max ( ans , i + kazu - 1 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( h ) ] <NEWLINE> <NL> def bfs ( x , y ) : <NEWLINE> <INDENT> q = [ ] <NEWLINE> dp = { } <NEWLINE> def qpush ( x , y , t ) : <NEWLINE> <INDENT> if 0 <= x < w and 0 <= y < h and s [ y ] [ x ] != <STRING> and ( x , y ) not in dp : <NEWLINE> <INDENT> q . append ( ( x , y ) ) <NEWLINE> dp [ ( x , y ) ] = t <NEWLINE> <NL> <DEDENT> <DEDENT> qpush ( x , y , 0 ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> ( x , y ) = q . pop ( 0 ) <NEWLINE> qpush ( x + 1 , y , dp [ ( x , y ) ] + 1 ) <NEWLINE> qpush ( x , y - 1 , dp [ ( x , y ) ] + 1 ) <NEWLINE> qpush ( x - 1 , y , dp [ ( x , y ) ] + 1 ) <NEWLINE> qpush ( x , y + 1 , dp [ ( x , y ) ] + 1 ) <NEWLINE> <DEDENT> return dp . get ( ( x , y ) , 0 ) <NEWLINE> <NL> <DEDENT> t = 0 <NEWLINE> for y in range ( h ) : <NEWLINE> <INDENT> for x in range ( w ) : <NEWLINE> <INDENT> t = max ( t , bfs ( x , y ) ) <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
for i in range ( 100000 ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if h + w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> * w ) <NEWLINE> for j in range ( h - 2 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( w - 2 ) + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * w ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> mmax = 0 <NEWLINE> N_max = N if B > N else B <NEWLINE> for n in reversed ( range ( N_max - A , N_max + 1 ) ) : <NEWLINE> <INDENT> _max = int ( A * n / B ) - ( A * int ( n / B ) ) <NEWLINE> if mmax < _max : <NEWLINE> <INDENT> mmax = _max <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mmax ) <NEWLINE>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = l [ 0 ] <NEWLINE> k = l [ 1 ] <NEWLINE> d = l [ 2 ] <NEWLINE> x1 = abs ( x ) <NEWLINE> <NL> cou = x1 // d <NEWLINE> cou += 1 <NEWLINE> x1 = x1 - d * cou <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if k < cou : <NEWLINE> <INDENT> x2 = abs ( x ) - k * d <NEWLINE> print ( x2 ) <NEWLINE> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> a = cou % 2 <NEWLINE> b = k % 2 <NEWLINE> x4 = x1 * ( - 1 ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( abs ( x1 ) ) <NEWLINE> <DEDENT> if a != b : <NEWLINE> <INDENT> print ( x1 + d ) <NEWLINE> <DEDENT> <DEDENT>
num = int ( input ( ) ) <NEWLINE> list0 = [ ] <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> date = input ( ) <NEWLINE> list0 . append ( date ) <NEWLINE> <DEDENT> list0 = set ( list0 ) <NEWLINE> print ( len ( list0 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if arr [ i ] < arr [ i - 1 ] : <NEWLINE> <INDENT> c += arr [ i - 1 ] - arr [ i ] <NEWLINE> arr [ i ] += arr [ i - 1 ] - arr [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> link = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> link [ L [ i ] [ 0 ] - 1 ] . append ( L [ i ] [ 1 ] - 1 ) <NEWLINE> link [ L [ i ] [ 1 ] - 1 ] . append ( L [ i ] [ 0 ] - 1 ) <NEWLINE> <NL> <DEDENT> checked = [ - 1 for _ in range ( N ) ] <NEWLINE> checked [ 0 ] = 0 <NEWLINE> d = deque ( [ 0 ] ) <NEWLINE> while d : <NEWLINE> <INDENT> now = d . popleft ( ) <NEWLINE> for i in range ( len ( link [ now ] ) ) : <NEWLINE> <INDENT> if checked [ link [ now ] [ i ] ] == - 1 : <NEWLINE> <INDENT> checked [ link [ now ] [ i ] ] = now + 1 <NEWLINE> d . append ( link [ now ] [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> flag = False <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if checked [ i ] == - 1 : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( checked [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> bomb = [ ] <NEWLINE> h = [ 0 ] * H <NEWLINE> w = [ 0 ] * W <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> hi , wi = map ( int , input ( ) . split ( ) ) <NEWLINE> h [ hi - 1 ] += 1 <NEWLINE> w [ wi - 1 ] += 1 <NEWLINE> bomb . append ( [ hi , wi ] ) <NEWLINE> <DEDENT> maxh = max ( h ) <NEWLINE> maxw = max ( w ) <NEWLINE> ans = maxh + maxw <NEWLINE> lh = [ ] <NEWLINE> lw = [ ] <NEWLINE> for i in range ( len ( h ) ) : <NEWLINE> <INDENT> if h [ i ] == maxh : <NEWLINE> <INDENT> lh . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( w ) ) : <NEWLINE> <INDENT> if w [ i ] == maxw : <NEWLINE> <INDENT> lw . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> a = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if ans == h [ bomb [ i ] [ 0 ] - 1 ] + w [ bomb [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> if a == len ( lh ) * len ( lw ) : <NEWLINE> <INDENT> print ( ans - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ [ 0 ] for _ in range ( n + 1 ) ] <NEWLINE> vi = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> vi [ 1 ] = - 1 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> l [ a ] . append ( b ) <NEWLINE> l [ b ] . append ( a ) <NEWLINE> <DEDENT> st = deque ( [ 1 ] ) <NEWLINE> e = set ( ) <NEWLINE> f = set ( ) <NEWLINE> <NL> <NL> while st : <NEWLINE> <INDENT> x = st . popleft ( ) <NEWLINE> if x not in e : <NEWLINE> <INDENT> e . add ( x ) <NEWLINE> for k in l [ x ] : <NEWLINE> <INDENT> if k not in f : <NEWLINE> <INDENT> st . append ( k ) <NEWLINE> f . add ( k ) <NEWLINE> vi [ k ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for m in vi [ 2 : ] : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> inf = 10 ** 18 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> DP = [ [ - inf ] * 2 for i in range ( n ) ] <NEWLINE> DP [ 0 ] [ 0 ] = 0 <NEWLINE> DP [ 0 ] [ 1 ] = A [ 0 ] <NEWLINE> DP [ 1 ] [ 0 ] = 0 <NEWLINE> DP [ 1 ] [ 1 ] = max ( A [ 0 ] , A [ 1 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> DP [ i ] [ 0 ] = max ( DP [ i - 2 ] [ 0 ] + A [ i ] , DP [ i - 1 ] [ 1 ] ) <NEWLINE> DP [ i ] [ 1 ] = DP [ i - 2 ] [ 1 ] + A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> DP [ i ] [ 0 ] = max ( DP [ i - 2 ] [ 0 ] + A [ i ] , DP [ i - 1 ] [ 0 ] ) <NEWLINE> DP [ i ] [ 1 ] = max ( DP [ i - 2 ] [ 1 ] + A [ i ] , DP [ i - 1 ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> print ( DP [ n - 1 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( DP [ n - 1 ] [ 0 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> <NL> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> def f ( m ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> r_m = math . sqrt ( m ) <NEWLINE> for i in range ( 1 , int ( r_m ) + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , int ( r_m ) + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , int ( r_m ) + 1 ) : <NEWLINE> <INDENT> if i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i == m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> res += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> n = I ( ) <NEWLINE> cnt = [ 0 ] * 10001 <NEWLINE> r_n = int ( math . sqrt ( n ) ) + 1 <NEWLINE> for x in range ( 1 , r_n ) : <NEWLINE> <INDENT> for y in range ( 1 , r_n ) : <NEWLINE> <INDENT> for z in range ( 1 , r_n ) : <NEWLINE> <INDENT> v = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if v <= n : <NEWLINE> <INDENT> cnt [ v ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
l = { } <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if not s in l : <NEWLINE> <INDENT> l [ s ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( len ( l ) ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> def combination ( n , a ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> div = 1 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> res *= n - i <NEWLINE> res %= mod <NEWLINE> div *= a - i <NEWLINE> div %= mod <NEWLINE> <DEDENT> res = ( res * pow ( div , mod - 2 , mod ) ) % mod <NEWLINE> return res <NEWLINE> <DEDENT> print ( ( pow ( 2 , n , mod ) - 1 - combination ( n , a ) - combination ( n , b ) ) % mod ) <NEWLINE>
def root ( x , rt ) : <NEWLINE> <INDENT> if rt [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while rt [ x ] != x : <NEWLINE> <INDENT> rt [ x ] = root ( rt [ x ] , rt ) <NEWLINE> return rt [ x ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> def union ( x , y , rt , rank ) : <NEWLINE> <INDENT> rootx = root ( x , rt ) <NEWLINE> rooty = root ( y , rt ) <NEWLINE> if rootx == rooty : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if rank [ rootx ] < rank [ rooty ] : <NEWLINE> <INDENT> rt [ rootx ] = rooty <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rt [ rooty ] = rootx <NEWLINE> if rank [ rootx ] == rank [ rooty ] : <NEWLINE> <INDENT> rank [ rootx ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def issame ( x , y , rt ) : <NEWLINE> <INDENT> return root ( x , rt ) == root ( y , rt ) <NEWLINE> <NL> <DEDENT> length , query = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> rootlist = [ n for n in range ( length ) ] <NEWLINE> rank = [ 0 for n in range ( length ) ] <NEWLINE> <NL> for q in range ( query ) : <NEWLINE> <COMMENT> <NL> <INDENT> com , x , y = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> if com == 0 : <NEWLINE> <INDENT> union ( x , y , rootlist , rank ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 if issame ( x , y , rootlist ) else 0 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = sorted ( a ) <NEWLINE> <NL> dp = [ 0 ] * ( a [ - 1 ] + 1 ) <NEWLINE> <NL> for ai in a : <NEWLINE> <INDENT> if dp [ ai ] : <NEWLINE> <INDENT> dp [ ai ] += 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if ai * i >= len ( dp ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp [ ai * i ] += 1 <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for ai in a : <NEWLINE> <INDENT> if dp [ ai ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( M ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> mod = 998244353 <NEWLINE> <NL> fac = [ 0 ] * N <NEWLINE> finv = [ 0 ] * N <NEWLINE> inv = [ 0 ] * N <NEWLINE> <NL> fac [ 0 ] = fac [ 1 ] = 1 <NEWLINE> finv [ 0 ] = finv [ 1 ] = 1 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i % mod <NEWLINE> inv [ i ] = mod - inv [ mod % i ] * ( mod // i ) % mod <NEWLINE> finv [ i ] = finv [ i - 1 ] * inv [ i ] % mod <NEWLINE> <NL> <DEDENT> def com ( n , k ) : <NEWLINE> <INDENT> global fac , finv , mod <NEWLINE> if n < k : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if n < 0 or k < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return fac [ n ] * ( finv [ k ] * finv [ n - k ] % mod ) % mod <NEWLINE> <NL> <DEDENT> ans = pow ( M , N , mod ) <NEWLINE> for L in range ( K + 1 , N ) : <NEWLINE> <INDENT> result = ( M * pow ( M - 1 , N - L - 1 , mod ) * com ( N - 1 , N - L - 1 ) ) % mod <NEWLINE> ans -= result <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 998244353 <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> class combination ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . fact = [ 1 ] * ( n + 1 ) <NEWLINE> self . ifact = [ 1 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> self . fact [ i ] = self . fact [ i - 1 ] * i % MOD <NEWLINE> <DEDENT> self . ifact [ n ] = pow ( self . fact [ n ] , MOD - 2 , MOD ) <NEWLINE> for i in range ( n , 0 , - 1 ) : <NEWLINE> <INDENT> self . ifact [ i - 1 ] = self . ifact [ i ] * i % MOD <NEWLINE> <DEDENT> <DEDENT> def comb ( self , n , k ) : <NEWLINE> <INDENT> if k < 0 or k > n : return 0 <NEWLINE> comb = self . fact [ n ] * self . ifact [ k ] * self . ifact [ n - k ] % MOD <NEWLINE> return comb <NEWLINE> <DEDENT> <DEDENT> comb = combination ( N ) <NEWLINE> <NL> <NL> for k in range ( K + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += ( comb . comb ( N - 1 , k ) * pow ( M - 1 , N - 1 - k , MOD ) ) % MOD <NEWLINE> <NL> <DEDENT> print ( ans * M % MOD ) <NEWLINE>
N , M , X = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> A . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> ans = float ( <STRING> ) <NEWLINE> <NL> for i in range ( 1 , 2 ** N ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> e = [ 0 ] * M <NEWLINE> bi = <STRING> * N + bin ( i ) [ 2 : ] <NEWLINE> bi = list ( bi [ len ( bi ) - N : ] ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if bi [ j ] == <STRING> : <NEWLINE> <INDENT> a += A [ j ] [ 0 ] <NEWLINE> for k in range ( M ) : <NEWLINE> <INDENT> e [ k ] += A [ j ] [ k + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> c = True <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> c &= e [ i ] >= X <NEWLINE> <DEDENT> if c : <NEWLINE> <INDENT> ans = min ( ans , a ) <NEWLINE> <DEDENT> <DEDENT> if ans > 10 ** 7 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> for i in li : <NEWLINE> <INDENT> if a < i : <NEWLINE> <INDENT> a = i <NEWLINE> <DEDENT> if i < a : <NEWLINE> <INDENT> b = b + a - i <NEWLINE> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = j * 2 - i <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - cnt ) <NEWLINE>
from math import gcd <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> def seive ( ) : <NEWLINE> <INDENT> l [ 0 ] = 0 <NEWLINE> l [ 1 ] = 0 <NEWLINE> for i in range ( 2 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if l [ i ] == 1 : <NEWLINE> <INDENT> k . append ( i ) <NEWLINE> for j in range ( i * i , 10 ** 6 + 1 , i ) : <NEWLINE> <INDENT> l [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> l = [ 1 ] * ( 10 ** 6 + 1 ) <NEWLINE> k = [ ] <NEWLINE> seive ( ) <NEWLINE> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> d = bisect . bisect_left ( k , n ) <NEWLINE> print ( k [ d ] ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> b *= a [ i ] <NEWLINE> if b > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if b <= 10 ** 18 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> nii = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> lnii = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> x , y , a , b , c = nii ( ) <NEWLINE> p = lnii ( ) <NEWLINE> q = lnii ( ) <NEWLINE> r = lnii ( ) <NEWLINE> <NL> p . sort ( reverse = True ) <NEWLINE> q . sort ( reverse = True ) <NEWLINE> r . sort ( reverse = True ) <NEWLINE> <NL> l = p [ : x ] + q [ : y ] <NEWLINE> l . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( x + y ) : <NEWLINE> <INDENT> if i < c : <NEWLINE> <INDENT> ans += max ( l [ i ] , r [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += l [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> s = input ( ) . split ( <STRING> ) <NEWLINE> <NL> sumup = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> sumup += int ( i ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> r = int ( i ) <NEWLINE> <NL> sumup -= r <NEWLINE> <NL> ans += r * sumup <NEWLINE> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> n = 0 <NEWLINE> <NL> while A >= B : <NEWLINE> <INDENT> B *= 2 <NEWLINE> n += 1 <NEWLINE> <NL> <DEDENT> while B >= C : <NEWLINE> <INDENT> C *= 2 <NEWLINE> n += 1 <NEWLINE> <NL> <DEDENT> if n <= K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from bisect import * <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> ans += ( n - bisect ( C , b ) ) * bisect_left ( A , b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> u , k , * v = map ( int , input ( ) . split ( ) ) <NEWLINE> row = <STRING> <NEWLINE> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if j in v : <NEWLINE> <INDENT> row += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> row += <STRING> <NEWLINE> <DEDENT> if j != n : <NEWLINE> <INDENT> row += <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( row ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> square = <STRING> <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for y in range ( W ) : <NEWLINE> <INDENT> square = <STRING> + square <NEWLINE> <DEDENT> for x in range ( H ) : <NEWLINE> <INDENT> print ( square ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> diff = [ 0 ] * 100002 <NEWLINE> for k in l : <NEWLINE> <INDENT> diff [ k [ 0 ] - 1 ] += 1 <NEWLINE> diff [ k [ 1 ] ] -= 1 <NEWLINE> <NL> <DEDENT> hist = [ 0 , 0 ] <NEWLINE> for i in range ( 2 , N + 2 ) : <NEWLINE> <INDENT> hist . append ( hist [ - 1 ] + diff [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( max ( [ 0 ] + [ y - 1 for ( x , y ) in zip ( hist , range ( N + 2 ) ) if x + 1 >= y ] ) ) <NEWLINE>
t = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += t [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> if ans [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += t [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> G = [ 1 ] <COMMENT> <NEWLINE> cnt = 0 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> h = 4 ** i + 3 * 2 ** ( i - 1 ) + 1 <NEWLINE> if ( h > n ) : <COMMENT> <NEWLINE> <INDENT> m = i <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> G . append ( h ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for g in reversed ( G ) : <NEWLINE> <INDENT> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE> print ( <STRING> . join ( str ( x ) for x in reversed ( G ) ) ) <NEWLINE> print ( cnt ) <NEWLINE> <NL> print ( <STRING> . join ( str ( x ) for x in A ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = ( <STRING> ) <NEWLINE> f1tob = [ ] <NEWLINE> fbtoN = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> f1tob . append ( b ) <NEWLINE> <DEDENT> elif b == N : <NEWLINE> <INDENT> fbtoN . append ( a ) <NEWLINE> <DEDENT> <DEDENT> f1toba = set ( f1tob ) <NEWLINE> fbtoNa = set ( fbtoN ) <NEWLINE> if bool ( fbtoNa & f1toba ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in lis : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for num in lis : <NEWLINE> <INDENT> ans *= num <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> s = input ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> hanten = 0 <NEWLINE> s1 = <STRING> <NEWLINE> s2 = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> Q = input ( ) <NEWLINE> if int ( Q [ 0 ] ) == 1 : <NEWLINE> <INDENT> hanten += 1 <NEWLINE> <DEDENT> elif int ( Q [ 0 ] ) == 2 : <NEWLINE> <INDENT> if hanten % 2 == int ( Q [ 2 ] ) - 1 : <NEWLINE> <INDENT> s1 = s1 + Q [ 4 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s2 = s2 + Q [ 4 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> s1 = s1 [ : : - 1 ] <NEWLINE> s = s1 + s + s2 <NEWLINE> <NL> if hanten % 2 : <NEWLINE> <INDENT> s = s [ : : - 1 ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> line = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> L = [ 0 ] * N <NEWLINE> for i in line : <NEWLINE> <INDENT> L [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in L : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import collections <NEWLINE> import math <NEWLINE> def combinations_count ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = collections . Counter ( A ) <NEWLINE> num = 0 <NEWLINE> for i in set ( A ) : <NEWLINE> <INDENT> if B [ i ] > 1 : <NEWLINE> <INDENT> num += combinations_count ( B [ i ] , 2 ) <NEWLINE> <DEDENT> <DEDENT> for i in A : <NEWLINE> <INDENT> print ( num - B [ i ] + 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import collections <NEWLINE> <NL> N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> B = collections . Counter ( A ) . most_common ( ) <NEWLINE> B . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( len ( B ) ) : <NEWLINE> <INDENT> count = B [ i ] [ 1 ] <NEWLINE> if i + 1 < len ( B ) and B [ i + 1 ] [ 0 ] == B [ i ] [ 0 ] + 1 : <NEWLINE> <INDENT> count += B [ i + 1 ] [ 1 ] <NEWLINE> if i + 2 < len ( B ) and B [ i + 2 ] [ 0 ] == B [ i ] [ 0 ] + 2 : <NEWLINE> <INDENT> count += B [ i + 2 ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , count ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def find ( x ) : <NEWLINE> <INDENT> if par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if par [ x ] > par [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> par [ x ] += par [ y ] <NEWLINE> par [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> par = [ - 1 ] * n <NEWLINE> line = [ 0 for i in range ( n ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> unite ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> line [ find ( i ) ] += 1 <NEWLINE> if line [ find ( i ) ] > ans : <NEWLINE> <INDENT> ans = line [ find ( i ) ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> map_li = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> map_li [ a ] . append ( b ) <NEWLINE> map_li [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans_li = [ - 1 ] * n <NEWLINE> queue = [ 0 ] <NEWLINE> visited = [ False ] * n <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> x = queue . pop ( 0 ) <NEWLINE> for g in map_li [ x ] : <NEWLINE> <INDENT> if visited [ g ] == False : <NEWLINE> <INDENT> queue . append ( g ) <NEWLINE> if ans_li [ g ] == - 1 : <NEWLINE> <INDENT> ans_li [ g ] = x <NEWLINE> visited [ g ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if - 1 in ans_li [ 1 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for ans in ans_li [ 1 : ] : <NEWLINE> <INDENT> print ( ans + 1 ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> dp = [ [ 0 , 0 , 0 ] for _ in range ( N // 2 + 1 ) ] <NEWLINE> for i in range ( N // 2 ) : <NEWLINE> <INDENT> dp [ i + 1 ] [ 0 ] = dp [ i ] [ 0 ] + A [ i * 2 ] <NEWLINE> dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + A [ i * 2 + 1 ] <NEWLINE> if N % 2 : <NEWLINE> <INDENT> dp [ i + 1 ] [ 2 ] = max ( dp [ i ] [ 2 ] , dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + A [ i * 2 + 2 ] <NEWLINE> <DEDENT> <DEDENT> if N % 2 : <NEWLINE> <INDENT> print ( max ( dp [ - 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( dp [ - 1 ] [ : 2 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = defaultdict ( list ) <NEWLINE> R = defaultdict ( list ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> L [ A [ i ] + i ] . append ( i ) <NEWLINE> R [ i - A [ i ] ] . append ( i ) <NEWLINE> <DEDENT> K = list ( L . keys ( ) ) <NEWLINE> <NL> answer = 0 <NEWLINE> for k in K : <NEWLINE> <INDENT> l = len ( L [ k ] ) <NEWLINE> r = len ( R [ k ] ) <NEWLINE> answer += l * r <NEWLINE> <DEDENT> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> from collections import Counter <NEWLINE> import bisect <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> n = int ( readline ( ) . rstrip ( ) ) <NEWLINE> L = sorted ( list ( map ( int , readline ( ) . rstrip ( ) . split ( ) ) ) ) <NEWLINE> for a in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , n - 1 ) : <NEWLINE> <INDENT> k = L [ a ] + L [ b ] <NEWLINE> index = bisect . bisect_left ( L , k ) <NEWLINE> cnt += index - b - 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> B = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <COMMENT> <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
def ans ( a ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if 10 ** 18 < ans : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> return ans <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( ans ( A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> newa = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> newa [ a [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> print ( * newa , sep = <STRING> ) <NEWLINE>
from math import factorial <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> def fac ( n , r ) : <NEWLINE> <INDENT> return factorial ( n ) // ( factorial ( max ( 0 , n - r ) ) * factorial ( r ) ) <NEWLINE> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> print ( ( fac ( n - k + 1 , i ) * fac ( k - 1 , i - 1 ) ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . append ( li ) <NEWLINE> a += li [ 0 ] <NEWLINE> b = max ( b , li [ 1 ] ) <NEWLINE> <NL> <DEDENT> l = sorted ( l , key = lambda x : x [ 1 ] ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> count += l [ i ] [ 0 ] <NEWLINE> if count <= l [ i ] [ 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> AB = [ ] <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> AB . append ( ( a , b ) ) <NEWLINE> <NL> <DEDENT> root = 1 <NEWLINE> parent = [ 0 ] * ( N + 1 ) <NEWLINE> order = [ ] <NEWLINE> stack = [ root ] <NEWLINE> <NL> while stack : <NEWLINE> <INDENT> x = stack . pop ( ) <NEWLINE> order . append ( x ) <NEWLINE> for y in graph [ x ] : <NEWLINE> <INDENT> if y == parent [ x ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> parent [ y ] = x <NEWLINE> stack . append ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> color = [ - 1 ] * ( N + 1 ) <NEWLINE> K = - 1 <NEWLINE> for x in order : <NEWLINE> <INDENT> ng = color [ x ] <NEWLINE> c = 1 <NEWLINE> for y in graph [ x ] : <NEWLINE> <INDENT> if y == parent [ x ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if c == ng : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> K = max ( c , K ) <NEWLINE> color [ y ] = c <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> <NL> for a , b in AB : <NEWLINE> <INDENT> if parent [ a ] == b : <NEWLINE> <INDENT> ans . append ( color [ a ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( color [ b ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( K ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> numbers = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> numbers . append ( int ( line ) ) <NEWLINE> <NL> <DEDENT> answer = numbers [ 2 ] - numbers [ 1 ] <NEWLINE> tmp_min = numbers [ 1 ] <NEWLINE> for target in range ( 2 , len ( numbers ) ) : <NEWLINE> <INDENT> answer = max ( numbers [ target ] - tmp_min , answer ) <NEWLINE> tmp_min = min ( numbers [ target ] , tmp_min ) <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE> <NL>
T = str ( input ( ) ) <NEWLINE> T += <STRING> <NEWLINE> ans = <STRING> <NEWLINE> <NL> <COMMENT> <NL> <NL> for i in range ( len ( T ) - 1 ) : <NEWLINE> <INDENT> if i == 0 and T [ i ] == <STRING> : <NEWLINE> <INDENT> if T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> if ans [ - 1 ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> elif ans [ - 1 ] == <STRING> : <NEWLINE> <INDENT> if T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> elif T [ i + 1 ] in [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += T [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> hist = set ( ) <NEWLINE> <NL> INF = 10 ** 8 <NEWLINE> <NL> w = 0 <NEWLINE> pows = 1 <NEWLINE> for i in range ( INF ) : <NEWLINE> <INDENT> w += 7 * pows <NEWLINE> pows = pows * 10 % K <NEWLINE> w %= K <NEWLINE> if w == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if w in hist : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hist . add ( w ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> A = [ int ( i ) for i in A ] <NEWLINE> S = 0 <NEWLINE> A_sum = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A_sum += A [ i ] <NEWLINE> <NL> <NL> <DEDENT> B = A_sum <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B -= A [ i ] <NEWLINE> S += A [ i ] * B <NEWLINE> <NL> <DEDENT> print ( S % ( pow ( 10 , 9 ) + 7 ) ) <NEWLINE>
from math import gcd <NEWLINE> from functools import reduce <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> j += 1 <NEWLINE> m = gcd ( i , j ) <NEWLINE> for l in range ( k ) : <NEWLINE> <INDENT> l += 1 <NEWLINE> ans += gcd ( l , m ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> paths = [ [ ] for i in range ( N ) ] <NEWLINE> longest_paths = [ - 1 for i in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> paths [ x - 1 ] . append ( y - 1 ) <NEWLINE> <NL> <DEDENT> def get_longest ( node ) : <NEWLINE> <INDENT> if longest_paths [ node ] != - 1 : <NEWLINE> <INDENT> return longest_paths [ node ] <NEWLINE> <DEDENT> if paths [ node ] == [ ] : <NEWLINE> <INDENT> longest_paths [ node ] = 0 <NEWLINE> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = max ( [ get_longest ( nd ) for nd in paths [ node ] ] ) + 1 <NEWLINE> longest_paths [ node ] = result <NEWLINE> return result <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( [ get_longest ( i ) for i in range ( N ) ] ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if h == w == 0 : break <NEWLINE> for y in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> . join ( <STRING> [ ( x + y ) % 2 ] for x in range ( w ) ) ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for m in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( tmp , m ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from collections import Counter <NEWLINE> c = Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> div = set ( ) <NEWLINE> for i in range ( 1 , int ( x ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> div . add ( i ) <NEWLINE> div . add ( x // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> div = list ( div ) <NEWLINE> <NL> for d in div : <NEWLINE> <INDENT> for a in range ( int ( pow ( x , 1 / 2 ) ) + 1 ) : <NEWLINE> <INDENT> b = a - d <NEWLINE> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N >= B - 1 : <COMMENT> <NEWLINE> <INDENT> beta = ( B - 1 ) / B <NEWLINE> print ( math . floor ( A * beta ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> beta = N / B <NEWLINE> print ( math . floor ( A * beta ) ) <NEWLINE> <DEDENT>
h , w , m = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> l1 = [ ] <NEWLINE> l2 = [ 0 ] * h <NEWLINE> l3 = [ 0 ] * w <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> l1 . append ( ( x , y ) ) <NEWLINE> l2 [ x - 1 ] += 1 <NEWLINE> l3 [ y - 1 ] += 1 <NEWLINE> <DEDENT> m1 = max ( l2 ) <NEWLINE> m2 = max ( l3 ) <NEWLINE> m3 = max ( m1 , m2 ) <NEWLINE> if ( m1 > m2 ) : <NEWLINE> <INDENT> l4 = [ 0 ] * w <NEWLINE> k = l2 . index ( m1 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if ( l1 [ i ] [ 0 ] != k + 1 ) : <NEWLINE> <INDENT> l4 [ l1 [ i ] [ 1 ] - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> k1 = max ( l4 ) <NEWLINE> print ( m3 + k1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l4 = [ 0 ] * h <NEWLINE> k = l3 . index ( m2 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if ( l1 [ i ] [ 1 ] != k + 1 ) : <NEWLINE> <INDENT> l4 [ l1 [ i ] [ 0 ] - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> k1 = max ( l4 ) <NEWLINE> print ( m3 + k1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import fractions <NEWLINE> from collections import defaultdict <NEWLINE> import heapq <NEWLINE> from bisect import bisect_left , bisect <NEWLINE> <NL> stdin = sys . stdin <NEWLINE> <NL> ns = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> ni = lambda : int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> nm = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> N , K = nm ( ) <NEWLINE> A = nl ( ) <NEWLINE> l = 0 <NEWLINE> r = 10 ** 9 <NEWLINE> mid = 0 <NEWLINE> <NL> if ( K == 0 ) : <NEWLINE> <INDENT> print ( max ( A ) ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> while ( l + 1 < r ) : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> tmp += ( ( A [ i ] - 1 ) // mid ) <NEWLINE> <DEDENT> if ( tmp <= K ) : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ma = [ 0 ] * n <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ma [ a - 1 ] = max ( ma [ a - 1 ] , h [ b - 1 ] ) <NEWLINE> ma [ b - 1 ] = max ( ma [ b - 1 ] , h [ a - 1 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ma [ i ] < h [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> datas = [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> p1 = ( datas [ 0 ] , datas [ 1 ] ) <NEWLINE> p2 = ( datas [ 2 ] , datas [ 3 ] ) <NEWLINE> <NL> print ( math . sqrt ( math . pow ( p1 [ 0 ] - p2 [ 0 ] , 2 ) + math . pow ( p1 [ 1 ] - p2 [ 1 ] , 2 ) ) ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <DEDENT> tmp_sum = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if i != j and j != k : <NEWLINE> <INDENT> tmp_list = [ i , j , k ] <NEWLINE> tmp_sum += gcd_list ( tmp_list ) * 6 <NEWLINE> <DEDENT> elif i == j and j == k : <NEWLINE> <INDENT> tmp_list = [ i , j , k ] <NEWLINE> tmp_sum += gcd_list ( tmp_list ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp_list = [ i , j , k ] <NEWLINE> tmp_sum += gcd_list ( tmp_list ) * 3 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( tmp_sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> sum_a = sum ( a ) <NEWLINE> ans = 10 ** 11 <NEWLINE> x = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x += a [ i ] <NEWLINE> diff = abs ( sum_a - 2 * x ) <NEWLINE> if diff < ans : <NEWLINE> <INDENT> ans = diff <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> x = a [ 0 ] <NEWLINE> y = a [ 1 ] <NEWLINE> z = a [ 2 ] <NEWLINE> if x ** 2 + y ** 2 == z ** 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s = str ( input ( ) ) <NEWLINE> <NL> array = list ( map ( int , s ) ) <NEWLINE> if ( sum ( array ) % 9 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = [ 0 ] * ( 102 ) <NEWLINE> for i in l : <NEWLINE> <INDENT> k [ i ] = 1 <NEWLINE> <DEDENT> s = 10000 <NEWLINE> for i in range ( 102 ) : <NEWLINE> <INDENT> if k [ i ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if abs ( x - i ) < s : <NEWLINE> <INDENT> s = abs ( x - i ) <NEWLINE> ans = i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
def memoize ( f ) : <NEWLINE> <INDENT> cache = { } <NEWLINE> def helper ( x ) : <NEWLINE> <INDENT> if x not in cache : <NEWLINE> <INDENT> cache [ x ] = f ( x ) <NEWLINE> <DEDENT> return cache [ x ] <NEWLINE> <DEDENT> return helper <NEWLINE> <NL> <DEDENT> def split_rc ( rc ) : <NEWLINE> <INDENT> for i in range ( 1 , len ( rc ) ) : <NEWLINE> <INDENT> yield rc [ : i ] , rc [ i : ] <NEWLINE> <NL> <DEDENT> <DEDENT> @ memoize <NEWLINE> def cost ( rc ) : <NEWLINE> <INDENT> if len ( rc ) == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return min ( calc_cost ( first , second ) for first , second in split_rc ( rc ) ) <NEWLINE> <NL> <DEDENT> def calc_cost ( first , second ) : <NEWLINE> <INDENT> return cost ( first ) + cost ( second ) + first [ 0 ] [ 0 ] * first [ - 1 ] [ 1 ] * second [ - 1 ] [ 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> rc = tuple ( tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ) <NEWLINE> print ( cost ( rc ) ) <NEWLINE>
from math import gcd , sqrt <NEWLINE> from functools import reduce <NEWLINE> <NL> n , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> def f ( A ) : <NEWLINE> <INDENT> sup = max ( A ) + 1 <NEWLINE> table = [ i for i in range ( sup ) ] <NEWLINE> for i in range ( 2 , int ( sqrt ( sup ) ) + 1 ) : <NEWLINE> <INDENT> if table [ i ] == i : <NEWLINE> <INDENT> for j in range ( i ** 2 , sup , i ) : <NEWLINE> <INDENT> table [ j ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> D = set ( ) <NEWLINE> for a in A : <NEWLINE> <INDENT> while a != 1 : <NEWLINE> <INDENT> if a not in D : <NEWLINE> <INDENT> D . add ( a ) <NEWLINE> a //= table [ a ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if reduce ( gcd , A ) == 1 : <NEWLINE> <INDENT> if f ( A ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> from math import ceil <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> r1 = n % k <NEWLINE> r2 = abs ( r1 - k ) <NEWLINE> r = min ( r1 , r2 ) <NEWLINE> print ( r ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if x < min ( A ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> A . sort ( ) <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> while x > 0 and ans < N : <NEWLINE> <INDENT> if x >= A [ i ] : <NEWLINE> <INDENT> x -= A [ i ] <NEWLINE> ans += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if x > 0 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> readline = stdin . readline <NEWLINE> n , k = map ( int , readline ( ) . split ( ) ) <NEWLINE> a = np . array ( list ( map ( int , readline ( ) . split ( ) ) ) , dtype = np . int64 ) <NEWLINE> <NL> cnt = 0 <NEWLINE> while cnt < k : <NEWLINE> <INDENT> s = f ( n , a ) <NEWLINE> a = np . cumsum ( s ) <NEWLINE> cnt += 1 <NEWLINE> if a [ a == n ] . size == n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * a ) <NEWLINE> <NL> <DEDENT> @ njit <NEWLINE> def f ( n , a ) : <NEWLINE> <INDENT> s = np . zeros ( n , dtype = np . int64 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x_min = i - a [ i ] <NEWLINE> x_max = i + a [ i ] + 1 <NEWLINE> s [ max ( 0 , x_min ) ] += 1 <NEWLINE> if n - 1 < x_max : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ x_max ] -= 1 <NEWLINE> <DEDENT> <DEDENT> return s <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> remainder = N % K <NEWLINE> if abs ( remainder - K ) < remainder : <NEWLINE> <INDENT> ans = abs ( remainder - K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = remainder <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N == 1 or M == 1 : <NEWLINE> <INDENT> if N + M == 2 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N * M - 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ( N - 2 ) * ( M - 2 ) ) <NEWLINE> <DEDENT>
def check ( start , end ) : <NEWLINE> <INDENT> for i in range ( start , end - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> n , a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> s = <STRING> + s + <STRING> <NEWLINE> <NL> <COMMENT> <NL> if not check ( a , c ) or not check ( b , d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if d < c : <NEWLINE> <INDENT> for i in range ( b , d + 1 ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
arr = input ( ) <NEWLINE> new = <STRING> <NEWLINE> for x in arr : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> if new : <NEWLINE> <INDENT> new = new [ : - 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> new += x <NEWLINE> <DEDENT> <DEDENT> print ( new ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> put = [ 1 ] * ( n + 1 ) <NEWLINE> <NL> ab = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab [ a ] . append ( b ) <NEWLINE> ab [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> q = deque ( [ 1 ] ) <NEWLINE> flg = [ - 1 ] * n <NEWLINE> flg [ 0 ] = 0 <NEWLINE> <NL> while q : <NEWLINE> <INDENT> item = q . popleft ( ) <NEWLINE> for i in ab [ item ] : <NEWLINE> <INDENT> if put [ i ] : <NEWLINE> <INDENT> flg [ i - 1 ] = item <NEWLINE> q . append ( i ) <NEWLINE> put [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if - 1 in flg : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , len ( flg ) ) : <NEWLINE> <INDENT> print ( flg [ i ] ) <NEWLINE> <DEDENT>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( 10001 ) : <NEWLINE> <INDENT> for x in l : <NEWLINE> <INDENT> if i == x : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> % ( ans [ 0 ] , ans [ 1 ] , ans [ 2 ] ) ) <NEWLINE>
<NL> 2 <NEWLINE> 3 <NEWLINE> 4 <NEWLINE> 5 <NEWLINE> 6 <NEWLINE> 7 <NEWLINE> 8 <NEWLINE> 9 <NEWLINE> 10 <NEWLINE> 11 <NEWLINE> 12 <NEWLINE> 13 <NEWLINE> 14 <NEWLINE> 15 <NEWLINE> 16 <NEWLINE> 17 <NEWLINE> 18 <NEWLINE> 19 <NEWLINE> 20 <NEWLINE> 21 <NEWLINE> 22 <NEWLINE> 23 <NEWLINE> 24 <NEWLINE> 25 <NEWLINE> 26 <NEWLINE> 27 <NEWLINE> def sieve ( n ) : <NEWLINE> <INDENT> p = [ True for i in range ( n + 1 ) ] <NEWLINE> p [ 0 ] = p [ 1 ] = False <NEWLINE> end = int ( n ** .5 ) <NEWLINE> for i in range ( 2 , end + 1 ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , n + 1 , i ) : <NEWLINE> <INDENT> p [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return p <NEWLINE> <NL> <DEDENT> def primes_below ( n ) : <NEWLINE> <INDENT> if n < 2 : return 0 <NEWLINE> c = 1 <NEWLINE> for i in range ( 3 , n + 1 , 2 ) : <NEWLINE> <INDENT> if p [ i ] : c += 1 <NEWLINE> <NL> <DEDENT> return c <NEWLINE> <NL> <DEDENT> p = sieve ( 1000000 ) <NEWLINE> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( primes_below ( n ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> aa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> su = sum ( aa ) <NEWLINE> new = [ n ** 2 for n in aa ] <NEWLINE> sa = sum ( new ) <NEWLINE> x = 10 ** 9 + 7 <NEWLINE> print ( ( su ** 2 - sa ) // 2 % x ) <NEWLINE> sa <NEWLINE>
from functools import reduce <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 0 , n - k ) : <NEWLINE> <INDENT> print ( <STRING> if A [ i ] < A [ i + k ] else <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> dp = [ 1 ] <NEWLINE> col = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> col . append ( 1 ) <NEWLINE> dp . append ( dp [ - 1 ] * ( 4 - len ( col ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = 0 <NEWLINE> for c in range ( len ( col ) ) : <NEWLINE> <INDENT> if col [ c ] == A [ i ] : <NEWLINE> <INDENT> p += 1 <NEWLINE> if p == 1 : <NEWLINE> <INDENT> col [ c ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dp . append ( dp [ - 1 ] * p % mod ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ - 1 ] % mod ) <NEWLINE>
def make_divisors ( n ) : <NEWLINE> <INDENT> lower , upper = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower + upper [ : : - 1 ] <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( 1 , int ( input ( ) ) + 1 , 2 ) : <NEWLINE> <INDENT> if len ( make_divisors ( i ) ) == 8 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( a ) <NEWLINE> m = [ True ] * ( 10 ** 6 + 1 ) <NEWLINE> s = list ( set ( a ) ) <NEWLINE> for u in s : <NEWLINE> <INDENT> t = u * 2 <NEWLINE> while t <= 10 ** 6 : <NEWLINE> <INDENT> m [ t ] = False <NEWLINE> t += u <NEWLINE> <DEDENT> <DEDENT> r = 0 <NEWLINE> for u in s : <NEWLINE> <INDENT> if c [ u ] == 1 and m [ u ] == True : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
import sys <NEWLINE> <NL> alpha = <STRING> <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> i = 0 <NEWLINE> idx = n <NEWLINE> if n > 26 : <NEWLINE> <INDENT> while n > 0 : <NEWLINE> <INDENT> idx = n <NEWLINE> i += 1 <NEWLINE> n = n - 26 ** i <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( alpha [ n - 1 ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> def getstr ( i , idx ) : <NEWLINE> <NL> <INDENT> if i == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> return alpha [ idx - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> t = 26 ** i <NEWLINE> <NL> <COMMENT> <NL> b = int ( 26 * idx / t ) <NEWLINE> <NL> bb = 0 <NEWLINE> tmp = idx <NEWLINE> while tmp > 0 : <NEWLINE> <INDENT> tmp -= int ( t / 26 ) <NEWLINE> bb += 1 <NEWLINE> <NL> <DEDENT> b = bb - 1 <NEWLINE> idx -= b * int ( t / 26 ) <NEWLINE> i -= 1 <NEWLINE> <NL> return alpha [ b ] + getstr ( i , idx ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( getstr ( i , idx ) ) <NEWLINE>
import numpy as np <NEWLINE> import bisect <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = np . cumsum ( np . array ( [ 0 ] + a ) ) <NEWLINE> B = np . cumsum ( np . array ( b ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if A [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t = k - A [ i ] <NEWLINE> tmp = bisect . bisect_right ( B , t ) <NEWLINE> ans = max ( ans , i + tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> first = S [ 0 ] <NEWLINE> for i in range ( 1 , len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != first : <NEWLINE> <INDENT> c += 1 <NEWLINE> first = S [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , M , * AB = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for a , b in zip ( * [ iter ( AB ) ] * 2 ) : <NEWLINE> <INDENT> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> queue = deque ( [ 1 ] ) <NEWLINE> signposts = [ 0 ] * ( N + 1 ) <NEWLINE> signposts [ 1 ] = 1 <NEWLINE> while queue : <NEWLINE> <INDENT> u = queue . popleft ( ) <NEWLINE> for v in graph [ u ] : <NEWLINE> <INDENT> if not signposts [ v ] : <NEWLINE> <INDENT> signposts [ v ] = u <NEWLINE> queue . append ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if all ( signposts [ 2 : ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , signposts [ 2 : ] ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
( r , c ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> table = [ [ 0 for j in range ( c + 1 ) ] for i in range ( r + 1 ) ] <NEWLINE> <NL> for i in range ( r ) : <NEWLINE> <INDENT> tmp = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> for j in range ( c + 1 ) : <NEWLINE> <INDENT> if not j == c : <NEWLINE> <INDENT> table [ i ] [ j ] = tmp [ j ] <NEWLINE> table [ i ] [ c ] += table [ i ] [ j ] <NEWLINE> <DEDENT> table [ r ] [ j ] += table [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( r + 1 ) : <NEWLINE> <INDENT> for j in range ( c + 1 ) : <NEWLINE> <INDENT> if j == c : <NEWLINE> <INDENT> print ( table [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( table [ i ] [ j ] , <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> dis = [ 0 ] * ( N - 1 ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N + 1 ) : <NEWLINE> <INDENT> kyori = min ( j - i , abs ( X - i ) + 1 + abs ( j - Y ) , abs ( Y - i ) + 1 + abs ( j - X ) ) <NEWLINE> dis [ kyori - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for ans in dis : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> a_ind = bisect . bisect_left ( A , b ) <NEWLINE> c_ind = bisect . bisect_right ( C , b ) <NEWLINE> ans += a_ind * ( n - c_ind ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<NL> bil_date = [ ] <NEWLINE> flag = 0 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> bil_date . append ( [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] ) <NEWLINE> <DEDENT> all_date_amo = int ( input ( ) ) <NEWLINE> for i in range ( all_date_amo ) : <NEWLINE> <INDENT> date = [ int ( indate ) for indate in input ( ) . split ( ) ] <NEWLINE> bil_date [ date [ 0 ] - 1 ] [ date [ 1 ] - 1 ] [ date [ 2 ] - 1 ] = bil_date [ date [ 0 ] - 1 ] [ date [ 1 ] - 1 ] [ date [ 2 ] - 1 ] + date [ 3 ] <NEWLINE> if bil_date [ date [ 0 ] - 1 ] [ date [ 1 ] - 1 ] [ date [ 2 ] - 1 ] < 0 : <NEWLINE> <INDENT> bil_date [ date [ 0 ] - 1 ] [ date [ 1 ] - 1 ] [ date [ 2 ] - 1 ] = 0 <NEWLINE> <DEDENT> if bil_date [ date [ 0 ] - 1 ] [ date [ 1 ] - 1 ] [ date [ 2 ] - 1 ] > 9 : <NEWLINE> <INDENT> bil_date [ date [ 0 ] - 1 ] [ date [ 1 ] - 1 ] [ date [ 2 ] - 1 ] = 9 <NEWLINE> <NL> <DEDENT> <DEDENT> for bil in bil_date : <NEWLINE> <INDENT> for flo in bil : <NEWLINE> <INDENT> for room in flo : <NEWLINE> <INDENT> print ( <STRING> . format ( room ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if flag == 3 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 20 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> flag = flag + 1 <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( W * <STRING> ) <NEWLINE> for i in range ( H - 2 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> <DEDENT> print ( W * <STRING> + <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> S . append ( s ) <NEWLINE> <NL> <DEDENT> print ( len ( list ( set ( S ) ) ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> flag = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> flag += 1 <NEWLINE> if flag == N - K + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> max_score = 0 <NEWLINE> if n < b : <NEWLINE> <INDENT> max_score = int ( a * n / b ) - a * ( n // b ) <NEWLINE> <DEDENT> elif n == b : <NEWLINE> <INDENT> max_score = max ( int ( a * n / b ) - a * ( n // b ) , int ( a * ( n - 1 ) / b ) - a * ( ( n - 1 ) // b ) ) <NEWLINE> <DEDENT> elif a <= b : <NEWLINE> <INDENT> max_score = a - 1 <NEWLINE> <DEDENT> elif a >= b : <NEWLINE> <INDENT> max_score = int ( a * ( b - 1 ) / b ) - a * ( ( b - 1 ) // b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> score = int ( a * x / b ) - a * ( x // b ) <NEWLINE> if max_score < score : <NEWLINE> <INDENT> max_score = score <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max_score ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1 <NEWLINE> flag = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> x *= a [ i ] <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if 0 in a : <NEWLINE> <INDENT> flag = 2 <NEWLINE> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> elif flag == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> def factorize ( n ) : <NEWLINE> <INDENT> result = defaultdict ( int ) <NEWLINE> m = n <NEWLINE> p = 2 <NEWLINE> while p * p <= m : <NEWLINE> <INDENT> while n % p == 0 : <NEWLINE> <INDENT> n = n // p <NEWLINE> result [ p ] += 1 <NEWLINE> <DEDENT> p += 1 <NEWLINE> <DEDENT> if n > 1 : <NEWLINE> <INDENT> result [ n ] += 1 <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> factors = factorize ( n ) <NEWLINE> ans = <STRING> . format ( n ) <NEWLINE> for p , num in factors . items ( ) : <NEWLINE> <INDENT> ans += <STRING> . format ( p ) * num <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce , lru_cache <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def TUPLE ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> def dist ( A , B ) : <NEWLINE> <INDENT> return abs ( A [ 0 ] - B [ 0 ] ) + abs ( A [ 1 ] - B [ 1 ] ) <NEWLINE> <NL> <DEDENT> N = INT ( ) <NEWLINE> xy = [ LIST ( ) + [ i ] for i in range ( N ) ] <NEWLINE> <NL> xy1 = [ [ xy [ i ] [ 0 ] + xy [ i ] [ 1 ] , i ] for i in range ( N ) ] <NEWLINE> xy1 . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> idx_a = xy1 [ 0 ] [ 1 ] <NEWLINE> idx_b = xy1 [ - 1 ] [ 1 ] <NEWLINE> a = xy [ idx_a ] <NEWLINE> b = xy [ idx_b ] <NEWLINE> <NL> xy2 = [ [ - xy [ i ] [ 0 ] + xy [ i ] [ 1 ] , i ] for i in range ( N ) ] <NEWLINE> xy2 . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> idx_c = xy2 [ 0 ] [ 1 ] <NEWLINE> idx_d = xy2 [ - 1 ] [ 1 ] <NEWLINE> c = xy [ idx_c ] <NEWLINE> d = xy [ idx_d ] <NEWLINE> <NL> print ( max ( dist ( a , b ) , dist ( a , c ) , dist ( a , d ) , dist ( b , c ) , dist ( b , d ) , dist ( c , d ) ) ) <NEWLINE>
import sys <NEWLINE> array = [ ] <NEWLINE> for inp in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> array . append ( inp . split ( ) ) <NEWLINE> <DEDENT> for i in range ( len ( array ) ) : <NEWLINE> <INDENT> a = int ( array [ i ] [ 0 ] ) + int ( array [ i ] [ 1 ] ) <NEWLINE> print ( len ( str ( a ) ) ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + k + 1 <= b : <NEWLINE> <INDENT> for i in range ( a , k + a ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> if a + k + 1 <= b + 1 - k : <NEWLINE> <INDENT> for i in range ( b + 1 - k , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a + k , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> def comb ( n , r , mod ) : <NEWLINE> <INDENT> return math . factorial ( n + r - 1 ) // ( math . factorial ( n - 1 ) * math . factorial ( r ) ) % mod <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> red = n - k <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> redmod = red - i <NEWLINE> if redmod < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> redplace = 2 + i <NEWLINE> bluemod = k - ( i + 1 ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> bluemod = 0 <NEWLINE> <DEDENT> blueplace = i + 1 <NEWLINE> ans += comb ( redplace , redmod , mod ) * comb ( blueplace , bluemod , mod ) <NEWLINE> print ( ans % mod ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> sum = K ** 2 <NEWLINE> for a in range ( 2 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if gcd ( a , b ) == 1 : <NEWLINE> <INDENT> sum += K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += gcd ( a , b , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
S = input ( ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) [ 1 : ] <NEWLINE> for i in range ( 2000 , - 2001 , - 1 ) : <NEWLINE> <INDENT> if i == 0 : continue <NEWLINE> <NL> T = S . replace ( <STRING> , str ( i ) ) <NEWLINE> <COMMENT> <NL> if eval ( T ) == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( - i ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ) <NEWLINE> <NL> <DEDENT>
a , b , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> n = a + i <NEWLINE> if n > b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans . append ( n ) <NEWLINE> <NL> <DEDENT> st = b - k + 1 <NEWLINE> st = max ( st , ans [ - 1 ] + 1 ) <NEWLINE> for i in range ( st , b + 1 ) : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> aa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> list1 = [ 0 ] * n <NEWLINE> cnt = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if aa [ i + 1 ] > aa [ i ] : <NEWLINE> <INDENT> list1 [ i + 1 ] = 1 <NEWLINE> <DEDENT> elif aa [ i + 1 ] < aa [ i ] : <NEWLINE> <INDENT> list1 [ i + 1 ] = - 1 <NEWLINE> <DEDENT> elif aa [ i + 1 ] == aa [ i ] : <NEWLINE> <INDENT> list1 [ i + 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> while 1 in list1 and - 1 in list1 : <NEWLINE> <INDENT> del list1 [ : max ( list1 . index ( 1 ) , list1 . index ( - 1 ) ) ] <NEWLINE> list1 [ 0 ] = 0 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> aa = min ( a , k ) <NEWLINE> bb = min ( b , k - aa ) <NEWLINE> cc = min ( c , k - aa - bb ) <NEWLINE> <NL> print ( aa - cc ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> k = input ( ) <NEWLINE> if ( len ( k ) > n ) : <NEWLINE> <INDENT> k = k [ : n ] + <STRING> <NEWLINE> <DEDENT> print ( k ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> num = [ ] <NEWLINE> def ap ( num1 ) : <NEWLINE> <INDENT> num . append ( num1 ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> ap ( a ) <NEWLINE> <DEDENT> num . sort ( ) <NEWLINE> num1 = num [ 0 ] <NEWLINE> num2 = 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if num [ i + 1 ] == num1 : <NEWLINE> <INDENT> num2 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num1 = num [ i + 1 ] <NEWLINE> if num2 % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> num2 = 1 <NEWLINE> <DEDENT> <DEDENT> if num2 % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> R , G , B , N = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> bingo = 0 <NEWLINE> <NL> for r in range ( N + 1 ) : <NEWLINE> <INDENT> if R * r > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for g in range ( N + 1 ) : <NEWLINE> <INDENT> b = ( N - ( R * r + G * g ) ) // B <NEWLINE> if b < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif R * r + G * g + B * b == N : <NEWLINE> <INDENT> bingo += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( bingo ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> m = max ( a ) <NEWLINE> arr = [ 0 ] * ( m + 1 ) <NEWLINE> flag = [ True ] * ( m + 1 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if flag [ a [ i ] ] : <NEWLINE> <INDENT> arr [ a [ i ] ] += 1 <NEWLINE> if not arr [ a [ i ] ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( a [ i ] * 2 , m + 1 , a [ i ] ) : <NEWLINE> <INDENT> flag [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( arr . count ( 1 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for item in A : <NEWLINE> <INDENT> ans *= item <NEWLINE> <NL> ans = min ( ans , 10 ** 18 + 1 ) <NEWLINE> <NL> <DEDENT> if ans == 10 ** 18 + 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> from collections import Counter <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> S = [ int ( x ) for x in input ( ) . strip ( ) ] <NEWLINE> N = len ( S ) <NEWLINE> ans = 0 <NEWLINE> l = [ 0 ] * ( N + 1 ) <NEWLINE> p = 1 <NEWLINE> cumsum = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> l [ i ] = ( S [ i ] * p ) % 2019 <NEWLINE> p *= 10 <NEWLINE> p %= 2019 <NEWLINE> <DEDENT> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> cumsum [ i ] = ( l [ i ] + cumsum [ i + 1 ] ) % 2019 <NEWLINE> <DEDENT> cumsum = Counter ( cumsum ) <NEWLINE> for i in range ( 0 , 2019 ) : <NEWLINE> <INDENT> ans += ( cumsum [ i ] * ( cumsum [ i ] - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> Mgr = [ int ( num ) for num in input ( ) . split ( ) ] <NEWLINE> sub = [ 0 ] * N <NEWLINE> <NL> for i in range ( len ( Mgr ) ) : <NEWLINE> <INDENT> sub [ Mgr [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( sub [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from math import gcd <NEWLINE> <NL> K = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( a , K + 1 ) : <NEWLINE> <INDENT> for c in range ( b , K + 1 ) : <NEWLINE> <INDENT> if a == b == c : <NEWLINE> <INDENT> ans += a <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> ans += gcd ( a , c ) * 3 <NEWLINE> <DEDENT> elif a == c : <NEWLINE> <INDENT> ans += gcd ( a , b ) * 3 <NEWLINE> <DEDENT> elif b == c : <NEWLINE> <INDENT> ans += gcd ( a , b ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for i in range ( n ) ] <NEWLINE> k = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a - 1 ] . append ( b - 1 ) <NEWLINE> g [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> k . append ( [ a - 1 , b ] ) <NEWLINE> <DEDENT> m = [ - 1 ] * n <NEWLINE> m [ 0 ] = 0 <NEWLINE> m1 = [ - 1 ] * n <NEWLINE> m1 [ 0 ] = 0 <NEWLINE> q = deque ( ) <NEWLINE> q . append ( 0 ) <NEWLINE> while len ( q ) : <NEWLINE> <INDENT> d = q . popleft ( ) <NEWLINE> for i in g [ d ] : <NEWLINE> <INDENT> if m [ i ] == - 1 : <NEWLINE> <INDENT> m [ i ] = m [ d ] + 1 <NEWLINE> <DEDENT> if m1 [ i ] == - 1 : <NEWLINE> <INDENT> m1 [ i ] = d <NEWLINE> q . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> kyori = [ [ ] for i in range ( max ( m ) + 1 ) ] <NEWLINE> for i , j in enumerate ( m ) : <NEWLINE> <INDENT> kyori [ j ] . append ( i ) <NEWLINE> <DEDENT> ans = [ 0 ] * n <NEWLINE> for i , j in k : <NEWLINE> <INDENT> ans [ i ] += j <NEWLINE> <DEDENT> for i in kyori [ 1 : ] : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> ans [ j ] = ans [ j ] + ans [ m1 [ j ] ] <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
n , m , l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> B = [ map ( int , input ( ) . split ( ) ) for i in range ( m ) ] <NEWLINE> B_T = list ( map ( list , zip ( * B ) ) ) <NEWLINE> for a in A : <NEWLINE> <INDENT> row = [ ] <NEWLINE> for b in B_T : <NEWLINE> <INDENT> row . append ( sum ( [ x * y for ( x , y ) in zip ( a , b ) ] ) ) <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , row ) ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> MOD = 998244353 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> L , R = [ ] , [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( l ) <NEWLINE> R . append ( r ) <NEWLINE> <DEDENT> dp = [ 0 ] * ( n + 1 ) <NEWLINE> s = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> s [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> l = max ( 1 , i - R [ j ] ) <NEWLINE> r = i - L [ j ] <NEWLINE> if r < 1 : continue <NEWLINE> dp [ i ] += s [ r ] - s [ l - 1 ] <NEWLINE> dp [ i ] %= MOD <NEWLINE> <DEDENT> s [ i ] = s [ i - 1 ] + dp [ i ] <NEWLINE> s [ i ] %= MOD <NEWLINE> <DEDENT> print ( dp [ n ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 1 <NEWLINE> List . sort ( ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> res = res * List [ i ] <NEWLINE> if res > 1000000000000000000 : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <DEDENT> elif res == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) ; MOD = pow ( 10 , 9 ) + 7 <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> G [ a ] . append ( b ) ; G [ b ] . append ( a ) <NEWLINE> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> def dfs ( v , p ) : <COMMENT> <NEWLINE> <INDENT> global ans <COMMENT> <NEWLINE> res = 1 <COMMENT> <NEWLINE> ts = [ ] <COMMENT> <NEWLINE> for u in G [ v ] : <NEWLINE> <INDENT> if u == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> t = dfs ( u , v ) <COMMENT> <NEWLINE> res += t <NEWLINE> ts . append ( t ) <NEWLINE> <DEDENT> if p != - 1 : <COMMENT> <NEWLINE> <INDENT> ts . append ( N - res ) <NEWLINE> <DEDENT> now = pow ( 2 , N - 1 , MOD ) - 1 <COMMENT> <NEWLINE> for x in ts : <NEWLINE> <INDENT> now -= pow ( 2 , x , MOD ) - 1 <COMMENT> <NEWLINE> <DEDENT> ans = ( ans + now ) % MOD <NEWLINE> return res <COMMENT> <NEWLINE> <NL> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> ALL = pow ( 2 , N , MOD ) <NEWLINE> <COMMENT> <NL> ans = ans * pow ( ALL , MOD - 2 , MOD ) % MOD <COMMENT> <NEWLINE> print ( ans ) <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> from collections import defaultdict , Counter <NEWLINE> from itertools import product , permutations , combinations , accumulate <NEWLINE> from operator import itemgetter <NEWLINE> from bisect import bisect_left , bisect <NEWLINE> from heapq import heappop , heappush , heapify <NEWLINE> from math import ceil , floor , sqrt <NEWLINE> from copy import deepcopy <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> max_num = 10 ** 5 <NEWLINE> n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> query = [ map ( int , input ( ) . split ( ) ) for _ in range ( q ) ] <NEWLINE> num = [ 0 for _ in range ( max_num + 1 ) ] <NEWLINE> for i in a_list : <NEWLINE> <INDENT> num [ i ] += 1 <NEWLINE> <NL> <DEDENT> ans = sum ( a_list ) <NEWLINE> <NL> for b , c in query : <NEWLINE> <INDENT> n = num [ b ] <NEWLINE> num [ b ] = 0 <NEWLINE> num [ c ] += n <NEWLINE> ans += ( c - b ) * n <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> tmp = i * ( N // i ) <NEWLINE> ans += ( N // i ) * ( tmp + i ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> mod_bucket = [ 0 ] * 2019 <NEWLINE> mod_bucket [ 0 ] = 1 <NEWLINE> <NL> _S = S [ : : - 1 ] <NEWLINE> mod = 0 <NEWLINE> p = 1 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> mod = ( p * int ( _S [ i ] ) + mod ) % 2019 <NEWLINE> mod_bucket [ mod ] += 1 <NEWLINE> p = p * 10 % 2019 <NEWLINE> <NL> <DEDENT> ans = sum ( [ mod * ( mod - 1 ) / 2 for mod in mod_bucket ] ) <NEWLINE> print ( int ( ans ) ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m , k = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> pileda = 0 <NEWLINE> a = [ 0 ] <NEWLINE> for x in stdin . readline ( ) . rstrip ( ) . split ( ) : <NEWLINE> <INDENT> x = int ( x ) <NEWLINE> pileda += x <NEWLINE> a . append ( pileda ) <NEWLINE> <NL> <DEDENT> piledb = 0 <NEWLINE> b = [ 0 ] <NEWLINE> for x in stdin . readline ( ) . rstrip ( ) . split ( ) : <NEWLINE> <INDENT> x = int ( x ) <NEWLINE> piledb += x <NEWLINE> b . append ( piledb ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> bi = m <NEWLINE> for ai , at in enumerate ( a ) : <NEWLINE> <INDENT> if at > k : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> while at + b [ bi ] > k : <NEWLINE> <INDENT> bi -= 1 <NEWLINE> <NL> <DEDENT> ans = max ( ans , ai + bi ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( * A [ : : - 2 ] , * A [ N % 2 : : 2 ] ) <NEWLINE>
import sys <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> arrA , arrB = [ ] , [ ] <NEWLINE> s = line . split ( ) <NEWLINE> for i in s : <NEWLINE> <INDENT> arrA . append ( int ( i ) ) <NEWLINE> <DEDENT> s = input ( ) . split ( ) <NEWLINE> for i in s : <NEWLINE> <INDENT> arrB . append ( int ( i ) ) <NEWLINE> <DEDENT> h , b = 0 , 0 <NEWLINE> for i in range ( len ( arrA ) ) : <NEWLINE> <INDENT> if arrA [ i ] == arrB [ i ] : <NEWLINE> <INDENT> h += 1 <NEWLINE> <DEDENT> elif arrB . count ( arrA [ i ] ) > 0 : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> print ( h , b ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> min_sp , cnt = p [ 0 ] , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] <= min_sp : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> min_sp = p [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def maxHeapify ( heap , index ) : <NEWLINE> <INDENT> left_index = 2 * index <NEWLINE> right_index = 2 * index + 1 <NEWLINE> <NL> if left_index < len ( heap ) and heap [ left_index ] > heap [ index ] : <NEWLINE> <INDENT> largest_index = left_index <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest_index = index <NEWLINE> <NL> <DEDENT> if right_index < len ( heap ) and heap [ right_index ] > heap [ largest_index ] : <NEWLINE> <INDENT> largest_index = right_index <NEWLINE> <NL> <DEDENT> if not largest_index == index : <NEWLINE> <INDENT> heap [ index ] , heap [ largest_index ] = heap [ largest_index ] , heap [ index ] <NEWLINE> maxHeapify ( heap , largest_index ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n_node = int ( input ( ) ) <NEWLINE> target_list = [ <STRING> ] + [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> for i in range ( 1 , int ( len ( target_list ) / 2 ) + 1 ) [ : : - 1 ] : <NEWLINE> <INDENT> maxHeapify ( target_list , i ) <NEWLINE> <NL> <DEDENT> print ( * target_list ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = max ( n - sum ( a ) , - 1 ) <NEWLINE> print ( ans ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> val = ( A * min ( N , B - 1 ) ) // B - A * ( min ( N , B - 1 ) // B ) <NEWLINE> print ( val ) <NEWLINE>
<COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = N <NEWLINE> road = { } <NEWLINE> for i , h in zip ( range ( 1 , N + 1 , 1 ) , H ) : <NEWLINE> <INDENT> road [ i ] = { <NEWLINE> <INDENT> <STRING> : h , <NEWLINE> <STRING> : True <NEWLINE> <DEDENT> } <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> Ai , Bi = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if road [ Ai ] [ <STRING> ] is True and road [ Ai ] [ <STRING> ] <= road [ Bi ] [ <STRING> ] : <NEWLINE> <INDENT> road [ Ai ] [ <STRING> ] = False <NEWLINE> cnt -= 1 <NEWLINE> <NL> <DEDENT> if road [ Bi ] [ <STRING> ] is True and road [ Bi ] [ <STRING> ] <= road [ Ai ] [ <STRING> ] : <NEWLINE> <INDENT> road [ Bi ] [ <STRING> ] = False <NEWLINE> cnt -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> dp = [ 0 ] * ( 100000 + 1 ) <NEWLINE> a = 1 <NEWLINE> b = 6 <NEWLINE> c = 9 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i >= b * 6 : <NEWLINE> <INDENT> b *= 6 <NEWLINE> <DEDENT> if i >= c * 9 : <NEWLINE> <INDENT> c *= 9 <NEWLINE> <DEDENT> if i < 6 : <NEWLINE> <INDENT> dp [ i ] = i <NEWLINE> <DEDENT> elif i < 9 : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + 1 , dp [ i - b ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = min ( [ dp [ i - a ] + 1 , dp [ i - b ] + 1 , dp [ i - c ] + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ N ] ) <NEWLINE>
from bisect import bisect_left , bisect_right <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> arr1 [ i ] = arr1 [ i ] + arr1 [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , m ) : <NEWLINE> <INDENT> arr2 [ i ] = arr2 [ i ] + arr2 [ i - 1 ] <NEWLINE> <DEDENT> ma = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if arr1 [ i ] <= k : <NEWLINE> <INDENT> ma = max ( ma , bisect_right ( arr2 , k - arr1 [ i ] ) + i + 1 ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if arr2 [ i ] <= k : <NEWLINE> <INDENT> ma = max ( ma , bisect_right ( arr1 , k - arr2 [ i ] ) + i + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ma ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> x = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list = list ( x ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> r_list = collections . Counter ( a_list ) <NEWLINE> y = [ ] <NEWLINE> for i in range ( 1 , ( n + 1 ) ) : <NEWLINE> <INDENT> if ( i in r_list ) : <NEWLINE> <INDENT> y . append ( r_list [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . append ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> r_list2 = map ( str , y ) <NEWLINE> r_list2 = list ( r_list2 ) <NEWLINE> ans = <STRING> . join ( r_list2 ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = [ i for i in map ( int , input ( ) . split ( ) ) ] <NEWLINE> ans = dict ( ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans [ i ] = 0 <NEWLINE> <DEDENT> for el in L : <NEWLINE> <INDENT> if el in ans : <NEWLINE> <INDENT> ans [ el ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
nums = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> sign = [ 0 ] * 4 <NEWLINE> for x in range ( 4 ) : <NEWLINE> <INDENT> if nums [ x ] < 0 : <NEWLINE> <INDENT> sign [ x ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> result = min ( nums [ 0 : 2 ] ) * min ( nums [ 2 : ] ) <NEWLINE> <NL> if sum ( sign ) == 1 or sum ( sign ) == 0 : <NEWLINE> <INDENT> result = max ( nums [ 0 : 2 ] ) * max ( nums [ 2 : ] ) <NEWLINE> <NL> <DEDENT> if sum ( sign ) == 2 : <NEWLINE> <INDENT> if ( sign [ 0 ] == 1 and sign [ 1 ] ) or ( sign [ 2 ] == 1 and sign [ 3 ] == 1 ) : <NEWLINE> <INDENT> if sign [ 0 ] == 1 : <NEWLINE> <INDENT> result = max ( nums [ 0 : 2 ] ) * min ( nums [ 2 : ] ) <NEWLINE> <DEDENT> elif sign [ 2 ] == 1 : <NEWLINE> <INDENT> result = min ( nums [ 0 : 2 ] ) * max ( nums [ 2 : ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cur1 = nums [ 0 ] * nums [ 2 ] <NEWLINE> cur2 = nums [ 1 ] * nums [ 3 ] <NEWLINE> if abs ( cur1 ) > abs ( cur2 ) : <NEWLINE> <INDENT> result = cur1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = cur2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
a = [ chr ( i ) for i in range ( 97 , 123 ) ] <NEWLINE> line = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> line += input ( ) . lower ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for c in a : <NEWLINE> <INDENT> print ( <STRING> . format ( c , line . count ( c ) ) ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> s = 7 <NEWLINE> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mod = k <NEWLINE> while s % mod != 0 : <NEWLINE> <INDENT> s = ( 10 * s + 7 ) % mod <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <NL> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> most = max ( a ) <NEWLINE> most_idx = a . index ( most ) <NEWLINE> second = max ( a [ : most_idx ] + a [ most_idx + 1 : ] ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( second if a [ i ] == most else most ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> hw = [ input ( ) for _ in range ( h ) ] <NEWLINE> dp = [ [ 1000 ] * w for _ in range ( h ) ] <NEWLINE> if hw [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> dp [ 0 ] [ 0 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 0 ] [ 0 ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> if hw [ i ] [ j ] == <STRING> and hw [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> if j > 0 : <NEWLINE> <INDENT> if hw [ i ] [ j ] == <STRING> and hw [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ j - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ j - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ h - 1 ] [ w - 1 ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lmax , rmin = 0 , n <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> lmax = max ( lmax , l ) <NEWLINE> rmin = min ( rmin , r ) <NEWLINE> <NL> <DEDENT> print ( ( rmin - lmax ) + 1 if ( rmin - lmax ) + 1 > 0 else 0 ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> temp = 0 <NEWLINE> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> temp = temp + i <NEWLINE> if temp >= x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] * ( N + 1 ) <NEWLINE> C = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> B [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in B : <NEWLINE> <INDENT> if i >= 2 : <NEWLINE> <INDENT> C += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> for i in A : <NEWLINE> <INDENT> print ( C - B [ i - 1 ] + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = 0 <NEWLINE> sums = sum ( A ) <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> sums = sums - A [ i ] <NEWLINE> a = A [ i ] <NEWLINE> res += ( ( a * sums ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT> print ( res % ( 10 ** 9 + 7 ) ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt1 , cnt2 = 0 , 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if 0 <= a [ i ] < x : <NEWLINE> <INDENT> cnt1 += 1 <NEWLINE> <DEDENT> if x < a [ i ] <= a [ - 1 ] : <NEWLINE> <INDENT> cnt2 += 1 <NEWLINE> <DEDENT> <DEDENT> print ( min ( cnt1 , cnt2 ) ) <NEWLINE>
S_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if S_list [ 1 ] - S_list [ 0 ] == S_list [ 2 ] - S_list [ 1 ] : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
sem , per = map ( int , input ( ) . split ( ) ) <NEWLINE> scores = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( sem - per ) : <NEWLINE> <INDENT> if scores [ i ] < scores [ i + per ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
t = input ( ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> ans . append ( t [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if ans [ i ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = tuple ( map ( int , tuple ( input ( ) ) ) ) <NEWLINE> num_pos = [ ] <COMMENT> <NEWLINE> for num in range ( 10 ) : <NEWLINE> <INDENT> if num in s : <NEWLINE> <INDENT> num_pos . append ( n - s [ : : - 1 ] . index ( num ) - 1 ) <NEWLINE> <DEDENT> <DEDENT> unique_num = [ 0 ] * n <COMMENT> <NEWLINE> for i1 in range ( n ) : <NEWLINE> <INDENT> unique_num [ i1 ] = sum ( [ np >= i1 for np in num_pos ] ) <NEWLINE> <DEDENT> unique_num . append ( 0 ) <NEWLINE> r = 0 <NEWLINE> for keta1 in range ( 10 ) : <NEWLINE> <INDENT> if keta1 in s : <NEWLINE> <INDENT> keta1_pos = s . index ( keta1 ) <NEWLINE> for keta2 in range ( 10 ) : <NEWLINE> <INDENT> if keta2 in s [ keta1_pos + 1 : ] : <NEWLINE> <INDENT> keta2_pos = s [ keta1_pos + 1 : ] . index ( keta2 ) + keta1_pos + 1 <NEWLINE> r += unique_num [ keta2_pos + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = float ( input ( ) ) <NEWLINE> aan = 0 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> scores = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> total = sum ( scores ) <NEWLINE> avg = total / len ( scores ) <NEWLINE> for score in scores : <NEWLINE> <INDENT> aan += ( score - avg ) ** 2 <NEWLINE> <DEDENT> aa = aan / len ( scores ) <NEWLINE> a = math . sqrt ( aa ) <NEWLINE> print ( a ) <NEWLINE> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( tmp , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return divisors <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> divisors = make_divisors ( N ) <NEWLINE> ans = 0 <NEWLINE> divisors . sort ( reverse = True ) <NEWLINE> for x in divisors : <NEWLINE> <INDENT> if x > 1 : <NEWLINE> <INDENT> temp = x - 1 <NEWLINE> d , m = divmod ( N , temp ) <NEWLINE> if d != m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += temp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> import sys <NEWLINE> import copy <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = copy . copy ( a ) <NEWLINE> sum_odd = sum ( a [ 1 : : 2 ] ) <NEWLINE> sum_eve = sum ( a [ : : 2 ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> sum_a = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <NL> <INDENT> sum_a = sum_a + a [ i ] <NEWLINE> <NL> if sum_a * ( - 1 ) ** ( i + 1 ) < 1 : <NEWLINE> <INDENT> kari = 1 - sum_a * ( - 1 ) ** ( i + 1 ) <NEWLINE> a [ i ] += 1 * ( - 1 ) ** ( i + 1 ) * ( kari ) <NEWLINE> sum_a += 1 * ( - 1 ) ** ( i + 1 ) * ( kari ) <NEWLINE> <NL> ans = ans + abs ( kari ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans1 = 0 <NEWLINE> sum_b = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <NL> <INDENT> sum_b = sum_b + b [ i ] <NEWLINE> if sum_b * ( - 1 ) ** ( i ) < 1 : <NEWLINE> <INDENT> kari = ( 1 - sum_b * ( - 1 ) ** ( i ) ) <NEWLINE> b [ i ] += 1 * ( - 1 ) ** ( i ) * kari <NEWLINE> sum_b += 1 * ( - 1 ) ** ( i ) * kari <NEWLINE> <NL> ans1 = ans1 + abs ( kari ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( min ( ans , ans1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> plus = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> plus += a [ n - i - 1 ] <NEWLINE> plus %= MOD <NEWLINE> ans += a [ n - i - 2 ] * plus <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE>
values = [ int ( input ( ) ) for _ in range ( int ( input ( ) ) ) ] <NEWLINE> maxv = values [ 1 ] - values [ 0 ] <NEWLINE> minv = values [ 0 ] <NEWLINE> <NL> for val in values [ 1 : ] : <NEWLINE> <INDENT> maxv = max ( maxv , val - minv ) <NEWLINE> minv = min ( minv , val ) <COMMENT> <NEWLINE> <DEDENT> print ( maxv ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = 0 <NEWLINE> before_sum = sum ( As ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> before_sum -= As [ i ] <NEWLINE> result += As [ i ] * ( before_sum ) <NEWLINE> <DEDENT> print ( result % ( 1 * 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def solve ( A ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> leaves = sum ( A ) <NEWLINE> prev_node_capacity = 1 <NEWLINE> <NL> for ai in A : <NEWLINE> <INDENT> if ai > prev_node_capacity : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> ans += min ( prev_node_capacity , leaves ) <NEWLINE> <NL> leaves -= ai <NEWLINE> prev_node_capacity -= ai <NEWLINE> prev_node_capacity *= 2 <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> print ( solve ( A ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> ans = r * g * b <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> if s [ i ] != s [ j ] : <NEWLINE> <INDENT> if 2 * j - i < n : <NEWLINE> <INDENT> if s [ i ] != s [ 2 * j - i ] and s [ j ] != s [ 2 * j - i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 10 ** 18 <NEWLINE> tmp = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> tmp *= A [ i ] <NEWLINE> if tmp > ans : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( tmp ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> for gakki in range ( k + 1 , n + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> pre = A [ gakki - k - 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> k_gakki = A [ gakki - 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> if pre < k_gakki : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> _ = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = 1 <NEWLINE> for a_i in a : <NEWLINE> <INDENT> if a_i == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for a_i in a : <NEWLINE> <INDENT> result *= a_i <NEWLINE> <NL> if 10 ** 18 < result : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> result = main ( ) <NEWLINE> print ( result ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> import math <NEWLINE> nn = int ( math . sqrt ( n ) ) + 1 <NEWLINE> a = [ 0 ] * ( 100 * n ) <NEWLINE> for x in range ( 1 , nn + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , nn + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , nn + 1 ) : <NEWLINE> <INDENT> a [ ( x + y + z ) ** 2 - x * y - x * z - y * z ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT>
import sys , collections <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> nums = [ 0 for i in range ( n ) ] <NEWLINE> day = 0 <NEWLINE> match = 0 <NEWLINE> flag = True <NEWLINE> queue = collections . deque ( [ ] ) <NEWLINE> temp = set ( ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> i2 = a [ i - 1 ] [ 0 ] <NEWLINE> if a [ i2 - 1 ] [ 0 ] == i : <NEWLINE> <INDENT> if i not in temp : <NEWLINE> <INDENT> queue . append ( [ i , i2 ] ) <NEWLINE> temp . add ( i ) <NEWLINE> temp . add ( i2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if not queue : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> while queue : <NEWLINE> <INDENT> temp = [ ] <NEWLINE> while queue : <NEWLINE> <INDENT> test = queue . popleft ( ) <NEWLINE> match += 1 <NEWLINE> num1 , num2 = test [ 0 ] , test [ 1 ] <NEWLINE> nums [ num1 - 1 ] += 1 <NEWLINE> nums [ num2 - 1 ] += 1 <NEWLINE> temp . append ( num1 ) <NEWLINE> temp . append ( num2 ) <NEWLINE> <DEDENT> flag2 = False <NEWLINE> temp2 = set ( ) <NEWLINE> for i in temp : <NEWLINE> <INDENT> if nums [ i - 1 ] <= n - 2 : <NEWLINE> <INDENT> new_num = a [ i - 1 ] [ nums [ i - 1 ] ] <NEWLINE> if nums [ new_num - 1 ] <= n - 2 and a [ new_num - 1 ] [ nums [ new_num - 1 ] ] == i : <NEWLINE> <INDENT> if i not in temp2 : <NEWLINE> <INDENT> queue . append ( [ i , new_num ] ) <NEWLINE> flag2 = True <NEWLINE> temp2 . add ( i ) <NEWLINE> temp2 . add ( new_num ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag2 == False and match < n * ( n - 1 ) // 2 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> day += 1 <NEWLINE> <NL> <DEDENT> if flag == True : <NEWLINE> <INDENT> print ( day ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> MAX_RESULT = 1000000000000000000 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> result = 0 <NEWLINE> print ( result ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> result = 1 <NEWLINE> <NL> for x in A : <NEWLINE> <INDENT> result *= x <NEWLINE> if result > MAX_RESULT : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> while N > 0 : <NEWLINE> <INDENT> count += ( N % ( 10 ** 100 ) ) % 9 <NEWLINE> N = N // ( 10 ** 100 ) <NEWLINE> <NL> <DEDENT> if count % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def IL ( ) : return map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> def BFS ( n , m , table , dist ) : <NEWLINE> <INDENT> next = deque ( [ 0 ] ) <NEWLINE> while next : <NEWLINE> <INDENT> tmp = next . popleft ( ) <NEWLINE> for rep in table [ tmp ] : <NEWLINE> <INDENT> if dist [ rep ] == - 1 : <NEWLINE> <INDENT> dist [ rep ] = tmp + 1 <NEWLINE> next . append ( rep ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return not - 1 in dist <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = IL ( ) <NEWLINE> table = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = IL ( ) <NEWLINE> table [ a - 1 ] . append ( b - 1 ) <NEWLINE> table [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> dist = [ - 1 ] * n <NEWLINE> dist [ 0 ] = 0 <NEWLINE> if BFS ( n , m , table , dist ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , len ( dist ) ) : <NEWLINE> <INDENT> print ( dist [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> d = pi * r * r <NEWLINE> l = 2 * pi * r <NEWLINE> print ( d , l ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> if sys . platform == <STRING> : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> ) <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> l . append ( [ 1 , 1 ] ) <NEWLINE> l . append ( [ 2 , 9 ] ) <NEWLINE> l . append ( [ 3 , 30 ] ) <NEWLINE> l . append ( [ 4 , 76 ] ) <NEWLINE> l . append ( [ 5 , 141 ] ) <NEWLINE> l . append ( [ 6 , 267 ] ) <NEWLINE> l . append ( [ 7 , 400 ] ) <NEWLINE> l . append ( [ 8 , 624 ] ) <NEWLINE> l . append ( [ 9 , 885 ] ) <NEWLINE> l . append ( [ 10 , 1249 ] ) <NEWLINE> l . append ( [ 11 , 1590 ] ) <NEWLINE> l . append ( [ 12 , 2208 ] ) <NEWLINE> l . append ( [ 13 , 2689 ] ) <NEWLINE> l . append ( [ 14 , 3411 ] ) <NEWLINE> l . append ( [ 15 , 4248 ] ) <NEWLINE> l . append ( [ 16 , 5248 ] ) <NEWLINE> l . append ( [ 17 , 6081 ] ) <NEWLINE> l . append ( [ 18 , 7485 ] ) <NEWLINE> l . append ( [ 19 , 8530 ] ) <NEWLINE> l . append ( [ 20 , 10248 ] ) <NEWLINE> l . append ( [ 21 , 11889 ] ) <NEWLINE> l . append ( [ 22 , 13687 ] ) <NEWLINE> l . append ( [ 23 , 15228 ] ) <NEWLINE> l . append ( [ 24 , 17988 ] ) <NEWLINE> l . append ( [ 25 , 20053 ] ) <NEWLINE> l . append ( [ 26 , 22569 ] ) <NEWLINE> l . append ( [ 27 , 25242 ] ) <NEWLINE> l . append ( [ 28 , 28588 ] ) <NEWLINE> l . append ( [ 29 , 31053 ] ) <NEWLINE> l . append ( [ 30 , 35463 ] ) <NEWLINE> l . append ( [ 31 , 38284 ] ) <NEWLINE> l . append ( [ 32 , 42540 ] ) <NEWLINE> l . append ( [ 33 , 46581 ] ) <NEWLINE> l . append ( [ 34 , 50893 ] ) <NEWLINE> l . append ( [ 35 , 55362 ] ) <NEWLINE> l . append ( [ 36 , 61824 ] ) <NEWLINE> l . append ( [ 37 , 65857 ] ) <NEWLINE> l . append ( [ 38 , 71247 ] ) <NEWLINE> l . append ( [ 39 , 76884 ] ) <NEWLINE> l . append ( [ 40 , 84388 ] ) <NEWLINE> l . append ( [ 41 , 89349 ] ) <NEWLINE> l . append ( [ 42 , 97881 ] ) <NEWLINE> l . append ( [ 43 , 103342 ] ) <NEWLINE> l . append ( [ 44 , 111528 ] ) <NEWLINE> l . append ( [ 45 , 120141 ] ) <NEWLINE> l . append ( [ 46 , 128047 ] ) <NEWLINE> l . append ( [ 47 , 134580 ] ) <NEWLINE> l . append ( [ 48 , 146316 ] ) <NEWLINE> l . append ( [ 49 , 154177 ] ) <NEWLINE> l . append ( [ 50 , 164817 ] ) <NEWLINE> l . append ( [ 51 , 174438 ] ) <NEWLINE> l . append ( [ 52 , 185836 ] ) <NEWLINE> l . append ( [ 53 , 194157 ] ) <NEWLINE> l . append ( [ 54 , 207927 ] ) <NEWLINE> l . append ( [ 55 , 218812 ] ) <NEWLINE> l . append ( [ 56 , 233268 ] ) <NEWLINE> l . append ( [ 57 , 245277 ] ) <NEWLINE> l . append ( [ 58 , 257857 ] ) <NEWLINE> l . append ( [ 59 , 268182 ] ) <NEWLINE> l . append ( [ 60 , 288216 ] ) <NEWLINE> l . append ( [ 61 , 299257 ] ) <NEWLINE> l . append ( [ 62 , 313635 ] ) <NEWLINE> l . append ( [ 63 , 330204 ] ) <NEWLINE> l . append ( [ 64 , 347836 ] ) <NEWLINE> l . append ( [ 65 , 362973 ] ) <NEWLINE> l . append ( [ 66 , 383709 ] ) <NEWLINE> l . append ( [ 67 , 397042 ] ) <NEWLINE> l . append ( [ 68 , 416448 ] ) <NEWLINE> l . append ( [ 69 , 434025 ] ) <NEWLINE> l . append ( [ 70 , 456967 ] ) <NEWLINE> l . append ( [ 71 , 471948 ] ) <NEWLINE> l . append ( [ 72 , 499740 ] ) <NEWLINE> l . append ( [ 73 , 515581 ] ) <NEWLINE> l . append ( [ 74 , 536073 ] ) <NEWLINE> l . append ( [ 75 , 559758 ] ) <NEWLINE> l . append ( [ 76 , 583960 ] ) <NEWLINE> l . append ( [ 77 , 604833 ] ) <NEWLINE> l . append ( [ 78 , 633651 ] ) <NEWLINE> l . append ( [ 79 , 652216 ] ) <NEWLINE> l . append ( [ 80 , 683712 ] ) <NEWLINE> l . append ( [ 81 , 709065 ] ) <NEWLINE> l . append ( [ 82 , 734233 ] ) <NEWLINE> l . append ( [ 83 , 754734 ] ) <NEWLINE> l . append ( [ 84 , 793188 ] ) <NEWLINE> l . append ( [ 85 , 818917 ] ) <NEWLINE> l . append ( [ 86 , 846603 ] ) <NEWLINE> l . append ( [ 87 , 874512 ] ) <NEWLINE> l . append ( [ 88 , 909496 ] ) <NEWLINE> l . append ( [ 89 , 933081 ] ) <NEWLINE> l . append ( [ 90 , 977145 ] ) <NEWLINE> l . append ( [ 91 , 1006126 ] ) <NEWLINE> l . append ( [ 92 , 1041504 ] ) <NEWLINE> l . append ( [ 93 , 1073385 ] ) <NEWLINE> l . append ( [ 94 , 1106467 ] ) <NEWLINE> l . append ( [ 95 , 1138536 ] ) <NEWLINE> l . append ( [ 96 , 1187112 ] ) <NEWLINE> l . append ( [ 97 , 1215145 ] ) <NEWLINE> l . append ( [ 98 , 1255101 ] ) <NEWLINE> l . append ( [ 99 , 1295142 ] ) <NEWLINE> l . append ( [ 100 , 1342852 ] ) <NEWLINE> l . append ( [ 101 , 1373253 ] ) <NEWLINE> l . append ( [ 102 , 1422195 ] ) <NEWLINE> l . append ( [ 103 , 1453816 ] ) <NEWLINE> l . append ( [ 104 , 1502376 ] ) <NEWLINE> l . append ( [ 105 , 1553361 ] ) <NEWLINE> l . append ( [ 106 , 1595437 ] ) <NEWLINE> l . append ( [ 107 , 1629570 ] ) <NEWLINE> l . append ( [ 108 , 1691292 ] ) <NEWLINE> l . append ( [ 109 , 1726717 ] ) <NEWLINE> l . append ( [ 110 , 1782111 ] ) <NEWLINE> l . append ( [ 111 , 1827492 ] ) <NEWLINE> l . append ( [ 112 , 1887772 ] ) <NEWLINE> l . append ( [ 113 , 1925853 ] ) <NEWLINE> l . append ( [ 114 , 1986837 ] ) <NEWLINE> l . append ( [ 115 , 2033674 ] ) <NEWLINE> l . append ( [ 116 , 2089776 ] ) <NEWLINE> l . append ( [ 117 , 2145333 ] ) <NEWLINE> l . append ( [ 118 , 2197483 ] ) <NEWLINE> l . append ( [ 119 , 2246640 ] ) <NEWLINE> l . append ( [ 120 , 2332104 ] ) <NEWLINE> l . append ( [ 121 , 2379085 ] ) <NEWLINE> l . append ( [ 122 , 2434833 ] ) <NEWLINE> l . append ( [ 123 , 2490534 ] ) <NEWLINE> l . append ( [ 124 , 2554600 ] ) <NEWLINE> l . append ( [ 125 , 2609625 ] ) <NEWLINE> l . append ( [ 126 , 2693919 ] ) <NEWLINE> l . append ( [ 127 , 2742052 ] ) <NEWLINE> l . append ( [ 128 , 2813988 ] ) <NEWLINE> l . append ( [ 129 , 2875245 ] ) <NEWLINE> l . append ( [ 130 , 2952085 ] ) <NEWLINE> l . append ( [ 131 , 3003306 ] ) <NEWLINE> l . append ( [ 132 , 3096024 ] ) <NEWLINE> l . append ( [ 133 , 3157249 ] ) <NEWLINE> l . append ( [ 134 , 3224511 ] ) <NEWLINE> l . append ( [ 135 , 3306240 ] ) <NEWLINE> l . append ( [ 136 , 3388576 ] ) <NEWLINE> l . append ( [ 137 , 3444609 ] ) <NEWLINE> l . append ( [ 138 , 3533637 ] ) <NEWLINE> l . append ( [ 139 , 3591322 ] ) <NEWLINE> l . append ( [ 140 , 3693924 ] ) <NEWLINE> l . append ( [ 141 , 3767085 ] ) <NEWLINE> l . append ( [ 142 , 3842623 ] ) <NEWLINE> l . append ( [ 143 , 3912324 ] ) <NEWLINE> l . append ( [ 144 , 4027884 ] ) <NEWLINE> l . append ( [ 145 , 4102093 ] ) <NEWLINE> l . append ( [ 146 , 4181949 ] ) <NEWLINE> l . append ( [ 147 , 4270422 ] ) <NEWLINE> l . append ( [ 148 , 4361548 ] ) <NEWLINE> l . append ( [ 149 , 4427853 ] ) <NEWLINE> l . append ( [ 150 , 4548003 ] ) <NEWLINE> l . append ( [ 151 , 4616104 ] ) <NEWLINE> l . append ( [ 152 , 4718640 ] ) <NEWLINE> l . append ( [ 153 , 4812789 ] ) <NEWLINE> l . append ( [ 154 , 4918561 ] ) <NEWLINE> l . append ( [ 155 , 5003286 ] ) <NEWLINE> l . append ( [ 156 , 5131848 ] ) <NEWLINE> l . append ( [ 157 , 5205481 ] ) <NEWLINE> l . append ( [ 158 , 5299011 ] ) <NEWLINE> l . append ( [ 159 , 5392008 ] ) <NEWLINE> l . append ( [ 160 , 5521384 ] ) <NEWLINE> l . append ( [ 161 , 5610705 ] ) <NEWLINE> l . append ( [ 162 , 5739009 ] ) <NEWLINE> l . append ( [ 163 , 5818390 ] ) <NEWLINE> l . append ( [ 164 , 5930196 ] ) <NEWLINE> l . append ( [ 165 , 6052893 ] ) <NEWLINE> l . append ( [ 166 , 6156139 ] ) <NEWLINE> l . append ( [ 167 , 6239472 ] ) <NEWLINE> l . append ( [ 168 , 6402720 ] ) <NEWLINE> l . append ( [ 169 , 6493681 ] ) <NEWLINE> l . append ( [ 170 , 6623853 ] ) <NEWLINE> l . append ( [ 171 , 6741078 ] ) <NEWLINE> l . append ( [ 172 , 6864016 ] ) <NEWLINE> l . append ( [ 173 , 6953457 ] ) <NEWLINE> l . append ( [ 174 , 7094451 ] ) <NEWLINE> l . append ( [ 175 , 7215016 ] ) <NEWLINE> l . append ( [ 176 , 7359936 ] ) <NEWLINE> l . append ( [ 177 , 7475145 ] ) <NEWLINE> l . append ( [ 178 , 7593865 ] ) <NEWLINE> l . append ( [ 179 , 7689630 ] ) <NEWLINE> l . append ( [ 180 , 7886244 ] ) <NEWLINE> l . append ( [ 181 , 7984165 ] ) <NEWLINE> l . append ( [ 182 , 8130747 ] ) <NEWLINE> l . append ( [ 183 , 8253888 ] ) <NEWLINE> l . append ( [ 184 , 8403448 ] ) <NEWLINE> l . append ( [ 185 , 8523897 ] ) <NEWLINE> l . append ( [ 186 , 8684853 ] ) <NEWLINE> l . append ( [ 187 , 8802826 ] ) <NEWLINE> l . append ( [ 188 , 8949612 ] ) <NEWLINE> l . append ( [ 189 , 9105537 ] ) <NEWLINE> l . append ( [ 190 , 9267595 ] ) <NEWLINE> l . append ( [ 191 , 9376656 ] ) <NEWLINE> l . append ( [ 192 , 9574704 ] ) <NEWLINE> l . append ( [ 193 , 9686065 ] ) <NEWLINE> l . append ( [ 194 , 9827097 ] ) <NEWLINE> l . append ( [ 195 , 9997134 ] ) <NEWLINE> l . append ( [ 196 , 10174780 ] ) <NEWLINE> l . append ( [ 197 , 10290813 ] ) <NEWLINE> l . append ( [ 198 , 10493367 ] ) <NEWLINE> l . append ( [ 199 , 10611772 ] ) <NEWLINE> l . append ( [ 200 , 10813692 ] ) <NEWLINE> print ( l [ k - 1 ] [ 1 ] ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( 10 ) : <NEWLINE> <INDENT> for y in range ( 10 ) : <NEWLINE> <INDENT> hantei = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if x != int ( S [ i ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if y != int ( S [ j ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> hantei . append ( S [ k ] ) <NEWLINE> <DEDENT> ans += len ( Counter ( hantei ) ) <NEWLINE> break <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> nc = n <NEWLINE> result = [ ] <NEWLINE> i = 2 <NEWLINE> while i <= math . sqrt ( n ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> n //= i <NEWLINE> result . append ( str ( i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> result . append ( str ( n ) ) <NEWLINE> <DEDENT> print ( str ( nc ) + <STRING> + <STRING> . join ( result ) ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> <NL> X = int ( read ( ) ) <NEWLINE> A = np . array ( [ pow ( i , 5 ) for i in range ( 7000 ) ] ) <NEWLINE> <NL> for i , B_f in enumerate ( A ) : <NEWLINE> <INDENT> for sig in [ 1 , - 1 ] : <NEWLINE> <INDENT> diff = A - ( sig * B_f ) <NEWLINE> if ( diff == X ) . any ( ) : <NEWLINE> <INDENT> A_f = X + ( sig * B_f ) <NEWLINE> AA = A . tolist ( ) . index ( A_f ) <NEWLINE> B = A . tolist ( ) . index ( B_f ) <NEWLINE> print ( AA , sig * B ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> n , s = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 998244353 <NEWLINE> modinv = pow ( 2 , mod - 2 , mod ) <NEWLINE> dp = [ 0 ] * ( s + 1 ) <NEWLINE> dp [ 0 ] = pow ( 2 , n , mod ) <NEWLINE> for i in a : <NEWLINE> <INDENT> for j in range ( s - i , - 1 , - 1 ) : <NEWLINE> <INDENT> dp [ j + i ] += dp [ j ] * modinv <NEWLINE> dp [ j + i ] %= mod <NEWLINE> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> now = 0 <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> now = ( now * 10 + 7 ) % K <NEWLINE> count += 1 <NEWLINE> if now % K == 0 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
num = int ( input ( ) ) <NEWLINE> word = input ( ) <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <INDENT> print ( word [ i ] , end = <STRING> ) <NEWLINE> if i + 1 >= len ( word ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( word ) > num : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> flag = [ False for _ in range ( M ) ] <NEWLINE> record = list ( ) <NEWLINE> record . append ( X ) <NEWLINE> flag [ X ] = 1 <NEWLINE> <NL> An = X <NEWLINE> <NL> for i in range ( M + 1 ) : <NEWLINE> <INDENT> An = pow ( An , 2 , M ) <NEWLINE> if flag [ An ] : <NEWLINE> <INDENT> start = flag [ An ] <NEWLINE> cnt = i + 2 - start <NEWLINE> cost = record [ - 1 ] - record [ start - 2 ] if start > 1 else record [ - 1 ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> record . append ( An + record [ - 1 ] ) <NEWLINE> flag [ An ] = i + 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if start >= N : <NEWLINE> <INDENT> print ( record [ N - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( ( N - start ) // cnt ) * cost <NEWLINE> <INDENT> + record [ ( N - start ) % cnt + start - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> l = list ( ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> l = [ len ( i ) for i in s . split ( <STRING> ) ] <NEWLINE> r = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> r = min ( k , len ( l ) - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = min ( k - 1 , len ( l ) - 1 ) <NEWLINE> <NL> <DEDENT> t = l [ r ] <NEWLINE> <NL> for j in range ( 1 , k + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if r - j >= 0 : <NEWLINE> <COMMENT> <NL> <INDENT> t += l [ r - j ] <NEWLINE> <DEDENT> if r + j < len ( l ) : <NEWLINE> <COMMENT> <NL> <INDENT> t += l [ r + j ] <NEWLINE> <DEDENT> <DEDENT> ans = t <NEWLINE> for i in range ( r + 2 , len ( l ) , 2 ) : <NEWLINE> <INDENT> for j in range ( 1 , 3 ) : <NEWLINE> <INDENT> if i - j - k >= 0 : <NEWLINE> <COMMENT> <NL> <INDENT> t -= l [ i - j - k ] <NEWLINE> <DEDENT> if i + j + k - 2 < len ( l ) : <NEWLINE> <COMMENT> <NL> <INDENT> t += l [ i + j + k - 2 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , t ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n -= 1000 <NEWLINE> <DEDENT> print ( abs ( n ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> al = [ 0 ] <NEWLINE> bl = [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> al . append ( al [ i ] + A_list [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> bl . append ( bl [ i ] + B_list [ i ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> book = 0 <NEWLINE> re = M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if al [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> while bl [ re ] > K - al [ i ] : <NEWLINE> <INDENT> re -= 1 <NEWLINE> <NL> <DEDENT> book = max ( book , i + re ) <NEWLINE> <NL> <DEDENT> print ( book ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = sorted ( [ int ( x ) for x in input ( ) . split ( <STRING> ) ] ) <NEWLINE> ans = 1 <NEWLINE> for i in arr : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ( ans > ( 10 ** 18 ) or ans == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( - 1 if ( ans > ( 10 ** 18 ) ) else ans ) <NEWLINE>
import itertools <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * q <NEWLINE> b = [ 0 ] * q <NEWLINE> c = [ 0 ] * q <NEWLINE> d = [ 0 ] * q <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> A = list ( itertools . combinations_with_replacement ( [ i for i in range ( 1 , m + 1 ) ] , n ) ) <NEWLINE> <NL> <NL> g = [ ] <NEWLINE> for v in A : <NEWLINE> <INDENT> e = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <NL> <INDENT> if v [ b [ i ] - 1 ] - v [ a [ i ] - 1 ] == c [ i ] : <NEWLINE> <INDENT> e += d [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> g += [ e ] <NEWLINE> <DEDENT> print ( max ( g ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 10 ** 9 ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> dp [ i + 1 ] = min ( dp [ i + 1 ] , dp [ i ] + abs ( h [ i + 1 ] - h [ i ] ) ) <NEWLINE> if i + 2 < n : <NEWLINE> <INDENT> dp [ i + 2 ] = min ( dp [ i + 2 ] , dp [ i ] + abs ( h [ i + 2 ] - h [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> a = [ 0 ] * 4 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : a [ 0 ] += 1 <NEWLINE> if S [ i ] == <STRING> : a [ 1 ] += 1 <NEWLINE> if S [ i ] == <STRING> : a [ 2 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] and j - i == k - j : <NEWLINE> <INDENT> a [ 3 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( a [ 0 ] * a [ 1 ] * a [ 2 ] - a [ 3 ] ) <NEWLINE>
line1 = input ( ) <NEWLINE> line2 = input ( ) <NEWLINE> <NL> aryLine1 = line1 . split ( ) <NEWLINE> arystrLine2 = line2 . split ( ) <NEWLINE> <NL> K = int ( aryLine1 [ 0 ] ) ; <NEWLINE> N = int ( aryLine1 [ 1 ] ) ; <NEWLINE> <NL> aryLine2 = [ int ( s ) for s in arystrLine2 ] <NEWLINE> <COMMENT> <NL> <NL> aryLine2 . sort ( ) <NEWLINE> <COMMENT> <NL> <NL> ans = K <NEWLINE> <NL> for i in range ( 0 , N ) : <NEWLINE> <INDENT> temp1 = int ( aryLine2 [ i ] ) <NEWLINE> if i == N - 1 : <NEWLINE> <INDENT> temp2 = int ( aryLine2 [ 0 ] ) + K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp2 = int ( aryLine2 [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> temp = temp1 - temp2 + K <NEWLINE> <NL> if temp < ans : <NEWLINE> <INDENT> ans = temp <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> INT = lambda : int ( input ( ) ) <NEWLINE> INTM = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> STRM = lambda : map ( str , input ( ) . split ( ) ) <NEWLINE> STR = lambda : str ( input ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LISTS = lambda : list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> def do ( ) : <NEWLINE> <INDENT> n , m = INTM ( ) <NEWLINE> roots = [ [ ] for i in range ( n ) ] <NEWLINE> visit = [ 0 ] * n <NEWLINE> visit [ 0 ] = 1 <NEWLINE> q = deque ( [ 0 ] ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = INTM ( ) <NEWLINE> roots [ a - 1 ] . append ( b - 1 ) <NEWLINE> roots [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> while q : <NEWLINE> <INDENT> temp = q . popleft ( ) <NEWLINE> for root in roots [ temp ] : <NEWLINE> <INDENT> if visit [ root ] != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . append ( root ) <NEWLINE> visit [ root ] = temp + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in visit [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> do ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> s = [ str ( input ( ) ) for i in range ( N ) ] <NEWLINE> s = set ( s ) <NEWLINE> print ( len ( s ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> G = [ [ ] for i in range ( n ) ] <NEWLINE> check = [ 0 for i in range ( n ) ] <NEWLINE> <NL> <NL> def bfs ( s , c ) : <NEWLINE> <INDENT> q = deque ( ) <NEWLINE> <NL> check [ s ] = 1 <NEWLINE> q . append ( s ) <NEWLINE> <NL> while len ( q ) != 0 : <NEWLINE> <INDENT> u = q . popleft ( ) <NEWLINE> for v in range ( len ( G [ u ] ) ) : <NEWLINE> <INDENT> if check [ G [ u ] [ v ] ] == 0 : <NEWLINE> <INDENT> check [ G [ u ] [ v ] ] = 1 <NEWLINE> q . append ( G [ u ] [ v ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> check [ u ] = c <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> cnt = 2 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if check [ i ] == 0 : <NEWLINE> <INDENT> bfs ( i , cnt ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> if check [ s ] == check [ t ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for a in range ( K ) : <NEWLINE> <INDENT> a += 1 <NEWLINE> if a == 1 : <NEWLINE> <INDENT> ans += K * K <NEWLINE> continue <NEWLINE> <DEDENT> for b in range ( K ) : <NEWLINE> <INDENT> b += 1 <NEWLINE> if b == 1 : <NEWLINE> <INDENT> ans += K <NEWLINE> continue <NEWLINE> <DEDENT> tmp = gcd ( a , b ) <NEWLINE> if tmp == 1 : <NEWLINE> <INDENT> ans += K <NEWLINE> continue <NEWLINE> <DEDENT> for c in range ( K ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> if c == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> continue <NEWLINE> <DEDENT> dada = gcd ( tmp , c ) <NEWLINE> ans += dada <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <NL> <NL> <DEDENT> b = make_divisors ( m ) <NEWLINE> <COMMENT> <NL> a = m // n <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> for i in b : <NEWLINE> <INDENT> if i <= a : <NEWLINE> <INDENT> ans = i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> map = { ( chr ( ord ( <STRING> ) + i ) ) : ( 26 - i ) % 26 for i in range ( 26 ) } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if k >= map [ s [ i ] ] : <NEWLINE> <INDENT> k -= map [ s [ i ] ] <NEWLINE> s [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if k > 0 : <NEWLINE> <INDENT> s [ n - 1 ] = chr ( ( ord ( s [ n - 1 ] ) + k % 26 ) % 123 ) <NEWLINE> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> a = [ int ( readline ( ) ) - 1 for _ in [ 0 ] * N ] <NEWLINE> result = a . count ( - 1 ) <NEWLINE> <NL> nodes = set ( ) <NEWLINE> node_add = nodes . add <NEWLINE> hoge = set ( ) <NEWLINE> hoge_add = hoge . add <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] in hoge : <NEWLINE> <INDENT> node_add ( a [ i ] ) <NEWLINE> <DEDENT> hoge_add ( a [ i ] ) <NEWLINE> <NL> <DEDENT> visited = set ( ) <NEWLINE> add = visited . add <NEWLINE> startnode = { v : K - 1 for v in { i for i in range ( N ) if a [ i ] > - 1 } - set ( a ) } <NEWLINE> while startnode : <NEWLINE> <INDENT> nextnode = dict ( ) <NEWLINE> for v , l in startnode . items ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> result += ( v not in visited ) <NEWLINE> add ( v ) <NEWLINE> v = a [ v ] <NEWLINE> while a [ v ] > - 1 and v not in nodes and l > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> if v not in visited : <NEWLINE> <INDENT> result += 1 <NEWLINE> add ( v ) <NEWLINE> <DEDENT> l -= 1 <NEWLINE> v = a [ v ] <NEWLINE> <DEDENT> if a [ v ] > - 1 and v in nodes and l > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> nextnode [ v ] = max ( nextnode . get ( v , 0 ) , l - 1 ) <NEWLINE> <DEDENT> <DEDENT> startnode = nextnode <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> new = input ( ) <NEWLINE> if not ( new in S ) : <NEWLINE> <INDENT> S [ new ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( S ) ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> <NL> print ( <STRING> . format ( r ** 2 * math . pi ) , end = <STRING> ) <NEWLINE> print ( <STRING> . format ( 2 * r * math . pi ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> <NL> <COMMENT> <NL> if n == k : <NEWLINE> <INDENT> for x in a : <NEWLINE> <INDENT> ans *= x <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> elif max ( a ) < 0 and k % 2 : <NEWLINE> <INDENT> a . sort ( ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans *= a [ - i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> pos = [ ] <NEWLINE> neg = [ ] <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> if x >= 0 : <NEWLINE> <INDENT> pos . append ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> neg . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> pos . sort ( reverse = True ) <NEWLINE> neg . sort ( ) <NEWLINE> <NL> <NL> if k % 2 : <NEWLINE> <INDENT> ans *= pos . pop ( 0 ) <NEWLINE> k -= 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> num = [ ] <NEWLINE> for x , y in zip ( pos [ : : 2 ] , pos [ 1 : : 2 ] ) : <NEWLINE> <INDENT> num . append ( x * y ) <NEWLINE> <DEDENT> for x , y in zip ( neg [ : : 2 ] , neg [ 1 : : 2 ] ) : <NEWLINE> <INDENT> num . append ( x * y ) <NEWLINE> <NL> <DEDENT> num . sort ( reverse = True ) <NEWLINE> <NL> for i in range ( k // 2 ) : <NEWLINE> <INDENT> ans *= num [ i ] <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans % MOD ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( n // ( a + b ) * a + min ( n % ( a + b ) , a ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans_list = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> ans_list . append ( 0 ) <NEWLINE> <DEDENT> h_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> road_list = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> road_list . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> roadnum = len ( road_list ) <NEWLINE> <COMMENT> <NL> <NL> for i in range ( roadnum ) : <NEWLINE> <INDENT> templist = road_list [ i ] <NEWLINE> a = templist [ 0 ] <NEWLINE> b = templist [ 1 ] <NEWLINE> <COMMENT> <NL> if h_list [ a - 1 ] > h_list [ b - 1 ] : <NEWLINE> <INDENT> ans_list [ b - 1 ] += 1 <NEWLINE> <DEDENT> elif h_list [ a - 1 ] == h_list [ b - 1 ] : <NEWLINE> <INDENT> ans_list [ a - 1 ] += 1 <NEWLINE> ans_list [ b - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_list [ a - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans_list . count ( 0 ) ) <NEWLINE>
class HashTable : <NEWLINE> <INDENT> def __init__ ( self , size = 1000003 ) : <NEWLINE> <INDENT> self . size = size <NEWLINE> self . hash_table = [ None ] * size <NEWLINE> <NL> <DEDENT> def _gen_key ( self , val ) : <NEWLINE> <INDENT> raw_hash_val = hash ( val ) <NEWLINE> h1 = raw_hash_val % self . size <NEWLINE> h2 = 1 + ( raw_hash_val % ( self . size - 1 ) ) <NEWLINE> for i in range ( self . size ) : <NEWLINE> <INDENT> candidate_key = ( h1 + i * h2 ) % self . size <NEWLINE> if not self . hash_table [ candidate_key ] or self . hash_table [ candidate_key ] == val : <NEWLINE> <INDENT> return candidate_key <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def insert ( self , val ) : <NEWLINE> <INDENT> key = self . _gen_key ( val ) <NEWLINE> self . hash_table [ key ] = val <NEWLINE> <NL> <DEDENT> def search ( self , val ) : <NEWLINE> <INDENT> key = self . _gen_key ( val ) <NEWLINE> if self . hash_table [ key ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> import sys <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> simple_dict = HashTable ( ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> operation = sys . stdin . readline ( ) <NEWLINE> if operation [ 0 ] == <STRING> : <NEWLINE> <INDENT> simple_dict . insert ( operation [ 7 : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if simple_dict . search ( operation [ 5 : ] ) : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> ans += <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans , end = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if x . count ( 0 ) != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = x [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = ans * x [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <COMMENT> <NEWLINE> <NL> <DEDENT> y = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> y *= a [ i ] <NEWLINE> if ( y > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( y ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( ( a // abs ( a ) ) if a != 0 else 1 ) * ( b // abs ( b ) ) * ( abs ( a ) // abs ( b ) ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> Alist = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> M = max ( Alist ) <NEWLINE> A0 = [ <STRING> ] <NEWLINE> Abool = A0 + [ 0 for x in range ( M ) ] <NEWLINE> Alist . sort ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in Alist : <NEWLINE> <INDENT> for j in range ( i , M + 1 , i ) : <NEWLINE> <INDENT> if Abool [ j ] >= 2 : <NEWLINE> <INDENT> None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Abool [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in Alist : <NEWLINE> <INDENT> if Abool [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> result = 1 <NEWLINE> line = pow ( 10 , 18 ) <NEWLINE> <NL> if <STRING> in A : <NEWLINE> <INDENT> result = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> result *= int ( A [ i ] ) <NEWLINE> if result > line : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> <NL> print ( c [ : c . count ( <STRING> ) ] . count ( <STRING> ) ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt , x = 0 , 0 <NEWLINE> for y in range ( k + 1 ) : <NEWLINE> <INDENT> for z in range ( k + 1 ) : <NEWLINE> <INDENT> x = s - y - z <NEWLINE> if 0 <= x <= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for j in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ j ] + B [ j ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j = j - 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = 1 <NEWLINE> flag = True <NEWLINE> if A . count ( 0 ) >= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> num *= i <NEWLINE> if num > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> print ( <STRING> % ( r * r * math . pi , 2 * r * math . pi ) ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> D = set ( ) <NEWLINE> S = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] in S : <NEWLINE> <INDENT> D . add ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . add ( A [ i ] ) <NEWLINE> <DEDENT> <DEDENT> M = max ( S ) <NEWLINE> X = [ 1 for i in range ( M + 1 ) ] <NEWLINE> for a in S : <NEWLINE> <INDENT> if a in D : <NEWLINE> <INDENT> X [ a ] = 0 <NEWLINE> <DEDENT> for i in range ( 2 * a , M + 1 , a ) : <NEWLINE> <INDENT> X [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ A [ i ] ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> for a in range ( 201 ) : <NEWLINE> <INDENT> for b in range ( 401 ) : <NEWLINE> <INDENT> if a ** 5 - ( b - 200 ) ** 5 == X : <NEWLINE> <INDENT> x = str ( a ) <NEWLINE> y = str ( b - 200 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> L = [ x , y ] <NEWLINE> L = <STRING> . join ( L ) <NEWLINE> print ( L ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> g = 0 <NEWLINE> for i in range ( 1 , 1 + n ) : <NEWLINE> <INDENT> for j in range ( 1 , 1 + n ) : <NEWLINE> <INDENT> d = math . gcd ( i , j ) <NEWLINE> for z in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> f = math . gcd ( z , d ) <NEWLINE> g += f <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( g ) <NEWLINE>
a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if i == len ( a ) - 1 : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( str ( input ( ) ) ) <NEWLINE> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( int ( ( N - 3 ) / 2 ) + 1 ) : <NEWLINE> <INDENT> for k in range ( N - i * 2 - 3 + 1 ) : <NEWLINE> <INDENT> if S [ k ] != S [ k + i + 1 ] and S [ k ] != S [ k + 2 * i + 2 ] and S [ k + i + 1 ] != S [ k + 2 * i + 2 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - count ) <NEWLINE>
terms = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> scores = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> N = terms [ 0 ] <NEWLINE> K = terms [ 1 ] <NEWLINE> <NL> tempScore = [ ] <NEWLINE> scoreSet = [ ] <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if scores [ i ] < scores [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> if a < k : <NEWLINE> <INDENT> count += a <NEWLINE> if a + b < k : <NEWLINE> <INDENT> count -= k - a - b <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count = k <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> n = int ( sys . stdin . readline ( ) [ : - 1 ] ) <NEWLINE> S = [ int ( x ) for x in ( sys . stdin . readline ( ) [ : - 1 ] . split ( ) ) ] <NEWLINE> q = int ( sys . stdin . readline ( ) [ : - 1 ] ) <NEWLINE> T = [ int ( x ) for x in ( sys . stdin . readline ( ) [ : - 1 ] . split ( ) ) ] <NEWLINE> <NL> count = 0 <NEWLINE> for t in T : <NEWLINE> <INDENT> l = 0 <NEWLINE> h = n - 1 <NEWLINE> while l <= h : <NEWLINE> <INDENT> half = ( h + l ) // 2 <NEWLINE> if S [ half ] == t : <NEWLINE> <INDENT> count += 1 <NEWLINE> break <NEWLINE> <DEDENT> elif S [ half ] < t : <NEWLINE> <INDENT> l = half + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h = half - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = str ( n ) <NEWLINE> array = list ( map ( int , s ) ) <NEWLINE> if sum ( array ) % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] + A <NEWLINE> res = [ 0 ] * ( N + 1 ) <NEWLINE> M = 0 <NEWLINE> <NL> for i in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> if sum ( res [ j ] for j in range ( i , N + 1 , i ) ) % 2 != A [ i ] : <NEWLINE> <INDENT> res [ i ] = 1 <NEWLINE> M += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( M ) <NEWLINE> print ( * [ k for k , r in enumerate ( res ) if r ] ) <NEWLINE>
<COMMENT> <NL> N , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a , b = [ ] , [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> tmp = input ( ) . split ( ) <NEWLINE> a . append ( int ( tmp [ 0 ] ) ) <NEWLINE> b . append ( int ( tmp [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> cnt = [ 0 ] * ( 100000 + 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> cnt [ a [ i ] ] += b [ i ] <NEWLINE> <NL> <DEDENT> for j in range ( 100000 + 1 ) : <NEWLINE> <INDENT> if K <= cnt [ j ] : <NEWLINE> <INDENT> print ( j ) <NEWLINE> break <NEWLINE> <DEDENT> K -= cnt [ j ] <NEWLINE> <DEDENT>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ k - q ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> p [ a - 1 ] += 1 <NEWLINE> <DEDENT> for j in p : <NEWLINE> <INDENT> if 0 < j : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> m = 100000000000000 <NEWLINE> for i in range ( 1 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> m = min ( m , i + N // i ) <NEWLINE> <DEDENT> <DEDENT> print ( m - 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ input ( ) for _ in range ( N ) ] <NEWLINE> print ( len ( list ( set ( A ) ) ) ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> L = 9 * K // 7 if K % 7 == 0 else 9 * K <NEWLINE> <NL> if L % 2 == 0 or L % 5 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> surplus = 1 <NEWLINE> for i in range ( 1 , L ) : <NEWLINE> <INDENT> surplus = ( surplus * 10 ) % L <NEWLINE> if surplus == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> if n == k and k == len ( p ) : <NEWLINE> <INDENT> print ( sum ( p ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if n > k : <NEWLINE> <INDENT> s = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> s += p [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> M = [ ] <NEWLINE> <NL> type = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> class node : <NEWLINE> <INDENT> def __init__ ( self , idx , parent , left , right ) : <NEWLINE> <INDENT> self . idx = idx <NEWLINE> self . parent = parent <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> self . sibling = - 1 <NEWLINE> self . degree = 0 <NEWLINE> self . depth = 0 <NEWLINE> self . height = 0 <NEWLINE> self . type = - 1 <NEWLINE> <NL> <DEDENT> def tostr ( self ) : <NEWLINE> <INDENT> print ( <STRING> % ( self . idx , self . parent , self . sibling , self . degree , self . depth , self . height , type [ self . type ] ) ) <NEWLINE> <DEDENT> <DEDENT> tree = [ [ ] for x in range ( N ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> for a in range ( N ) : <NEWLINE> <INDENT> idx , left , right = map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> tree [ idx ] = node ( idx , - 1 , left , right ) <NEWLINE> <NL> <DEDENT> for a in range ( N ) : <NEWLINE> <INDENT> nd = tree [ a ] <NEWLINE> if nd . left != - 1 : <NEWLINE> <INDENT> tree [ nd . left ] . parent = a <NEWLINE> <DEDENT> if nd . right != - 1 : <NEWLINE> <INDENT> tree [ nd . right ] . parent = a <NEWLINE> <DEDENT> if nd . left != - 1 : <NEWLINE> <INDENT> tree [ nd . left ] . sibling = nd . right <NEWLINE> <DEDENT> if nd . right != - 1 : <NEWLINE> <INDENT> tree [ nd . right ] . sibling = nd . left <NEWLINE> <NL> <DEDENT> if nd . left == nd . right : <NEWLINE> <INDENT> nd . type = 2 <NEWLINE> nd . degree = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nd . type = 1 <NEWLINE> if nd . left == - 1 or nd . right == - 1 : <NEWLINE> <INDENT> nd . degree = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nd . degree = 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> root = <STRING> <NEWLINE> for a in range ( N ) : <NEWLINE> <INDENT> if tree [ a ] . parent == - 1 : <NEWLINE> <INDENT> root = a <NEWLINE> tree [ root ] . type = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> def search ( root , depth ) : <NEWLINE> <INDENT> root = tree [ root ] <NEWLINE> root . depth = depth <NEWLINE> if root . type == 2 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if root . right == - 1 and root . left == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if root . right != - 1 : <NEWLINE> <INDENT> search ( root . right , depth + 1 ) <NEWLINE> <DEDENT> if root . left != - 1 : <NEWLINE> <INDENT> search ( root . left , depth + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> search ( root , 0 ) <NEWLINE> <NL> def height ( root , hei ) : <NEWLINE> <INDENT> root = tree [ root ] <NEWLINE> if root . type == 2 or ( root . right == - 1 and root . left == - 1 ) : <NEWLINE> <INDENT> root . height = 0 <NEWLINE> return hei <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if root . left == - 1 : <NEWLINE> <INDENT> return height ( root . right , hei + 1 ) <NEWLINE> <DEDENT> elif root . right == - 1 : <NEWLINE> <INDENT> return height ( root . left , hei + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return max ( height ( root . left , hei + 1 ) , height ( root . right , hei + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> tree [ i ] . height = height ( i , 0 ) <NEWLINE> <NL> <DEDENT> for a in range ( N ) : <NEWLINE> <INDENT> tree [ a ] . tostr ( ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> c = collections . Counter ( a ) <NEWLINE> for i in c : <NEWLINE> <INDENT> cnt += c [ i ] * ( c [ i ] - 1 ) // 2 <NEWLINE> <NL> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( cnt - c [ a [ i ] ] + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> box = [ True ] * ( A [ - 1 ] + 1 ) <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if i < n - 1 and A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> box [ A [ i ] ] = False <NEWLINE> <DEDENT> k = 2 <NEWLINE> while A [ i ] * k < len ( box ) : <NEWLINE> <INDENT> box [ A [ i ] * k ] = False <NEWLINE> k += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if box [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sumf = sum ( a [ : k ] ) <NEWLINE> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> sumn = sumf - a [ i - 1 ] + a [ i + k - 1 ] <NEWLINE> print ( <STRING> if sumn > sumf else <STRING> ) <NEWLINE> sumf = sumn <NEWLINE> <DEDENT>
[ a , b ] = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import heapq <NEWLINE> import collections <NEWLINE> <NL> N = int ( input ( ) . strip ( ) ) <NEWLINE> As = list ( map ( lambda s : - int ( s ) , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> heapq . heapify ( As ) <NEWLINE> <NL> g = 0 <NEWLINE> gs = collections . deque ( ) <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <NL> <INDENT> a = - heapq . heappop ( As ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> gs . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g += gs . popleft ( ) <NEWLINE> gs . append ( a ) <NEWLINE> gs . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( g ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL>
k = int ( input ( ) ) <NEWLINE> a = 7 <NEWLINE> i = 1 <NEWLINE> if k % 5 == 0 or k % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> if a % k == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> a = ( a * 10 + 7 ) % k <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> import math <COMMENT> <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> from copy import deepcopy <NEWLINE> from itertools import accumulate <COMMENT> <NEWLINE> import bisect <COMMENT> <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> from functools import lru_cache <COMMENT> <NEWLINE> INF = 10 ** 9 + 7 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <DEDENT> def get_sieve_of_eratosthenes ( n ) : <NEWLINE> <INDENT> if not isinstance ( n , int ) : <NEWLINE> <INDENT> raise TypeError ( <STRING> ) <NEWLINE> <DEDENT> if n < 2 : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> data = [ i for i in range ( 2 , n + 1 ) ] <NEWLINE> for d in data : <NEWLINE> <INDENT> data = [ x for x in data if ( x == d or x % d != 0 ) ] <NEWLINE> <DEDENT> return data <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> x = math . floor ( math . sqrt ( n - 1 ) ) <NEWLINE> ans = 0 <NEWLINE> a = 1 <NEWLINE> while ( a <= x ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // a <NEWLINE> a += 1 <NEWLINE> <DEDENT> ans -= ( x - 1 ) * x / 2 <NEWLINE> ans *= 2 <NEWLINE> ans -= x <NEWLINE> print ( int ( ans ) ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys , collections <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = input ( ) . rstrip ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Ac = collections . Counter ( A ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nb = Ac [ B ] <NEWLINE> Ac [ C ] += Ac [ B ] <NEWLINE> Ac [ B ] = 0 <NEWLINE> <NL> if i == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for key , val in Ac . items ( ) : <NEWLINE> <INDENT> ans += key * val <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += nb * C - nb * B <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def getmax ( ) : <NEWLINE> <INDENT> max = 0 <NEWLINE> for i in p : <NEWLINE> <INDENT> if i > max : <NEWLINE> <INDENT> max = i <NEWLINE> <DEDENT> <DEDENT> return max <NEWLINE> <DEDENT> def getmin ( ) : <NEWLINE> <INDENT> min = p [ 0 ] <NEWLINE> for i in p : <NEWLINE> <INDENT> if i < min : <NEWLINE> <INDENT> min = i <NEWLINE> <DEDENT> <DEDENT> return min <NEWLINE> <DEDENT> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if N == 1 : <NEWLINE> <INDENT> p = int ( input ( ) ) <NEWLINE> print ( p - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> MIN = 101 <COMMENT> <NEWLINE> minnum = 0 <NEWLINE> for i in range ( - 101 , 102 ) : <NEWLINE> <INDENT> if not i in p : <NEWLINE> <INDENT> if abs ( i - X ) < MIN : <NEWLINE> <INDENT> MIN = abs ( i - X ) <NEWLINE> minnum = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( minnum ) <NEWLINE>
g_m = 0 <NEWLINE> g_G = [ ] <NEWLINE> g_cnt = 0 <NEWLINE> A = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> def insertionSort ( A , n , g ) : <NEWLINE> <INDENT> global g_cnt <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> g_cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> def shellSort ( A , n ) : <NEWLINE> <INDENT> m = 1 <NEWLINE> G = [ ] <NEWLINE> j = 1 <NEWLINE> for i in range ( 0 , 100 ) : <NEWLINE> <INDENT> G . append ( j ) <NEWLINE> j = 3 * j + 1 <NEWLINE> <NL> <DEDENT> while G [ m ] <= n : <NEWLINE> <INDENT> m += 1 <NEWLINE> <DEDENT> G = G [ : m ] <NEWLINE> G . reverse ( ) <NEWLINE> for i in range ( 0 , m ) : <NEWLINE> <INDENT> insertionSort ( A , n , G [ i ] ) <NEWLINE> <DEDENT> return A , m , G <NEWLINE> <DEDENT> A , g_m , g_G = shellSort ( A , n ) <NEWLINE> print ( g_m ) <NEWLINE> print ( <STRING> . join ( map ( str , g_G ) ) ) <NEWLINE> print ( g_cnt ) <NEWLINE> print ( * A , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> baisuu = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if baisuu [ i ] >= 1 : <NEWLINE> <INDENT> baisuu [ i ] = 2 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> for j in range ( i , 10 ** 6 + 1 , i ) : <NEWLINE> <INDENT> baisuu [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if baisuu [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> if x + y <= S : <NEWLINE> <INDENT> if K >= S - x - y : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , m , r = map ( int , input ( ) . split ( ) ) <NEWLINE> r -= m * n <NEWLINE> if r < 0 : print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> a = 1 <NEWLINE> for i in range ( r ) : a *= i + n <NEWLINE> for i in range ( r ) : a //= i + 1 <NEWLINE> print ( a ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> max_a = a [ - 1 ] <NEWLINE> b = [ 0 ] * ( max_a + 1 ) <NEWLINE> ans = set ( ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if b [ i ] == 1 : <NEWLINE> <INDENT> if i in ans : <NEWLINE> <INDENT> ans . remove ( i ) <NEWLINE> <DEDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> for j in range ( i , max_a + 1 , i ) : <NEWLINE> <INDENT> b [ j ] = 1 <NEWLINE> <DEDENT> ans . add ( i ) <NEWLINE> <NL> <DEDENT> print ( len ( ans ) ) <NEWLINE>
import re <NEWLINE> <NL> S = input ( ) <NEWLINE> S = re . sub ( <STRING> , <STRING> , S ) <NEWLINE> S = re . sub ( <STRING> , <STRING> , S ) <NEWLINE> S = re . sub ( <STRING> , <STRING> , S ) <NEWLINE> S = re . sub ( <STRING> , <STRING> , S ) <NEWLINE> print ( <STRING> if len ( S ) == 0 else <STRING> ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( a , min ( a + k , b ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> l . append ( i ) <NEWLINE> <NL> <DEDENT> for i in range ( max ( a , b - k + 1 ) , b + 1 ) : <NEWLINE> <INDENT> if not i in l : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 1 ] <NEWLINE> seen = { } <NEWLINE> k = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if not k in seen . keys ( ) : <NEWLINE> <INDENT> seen [ k ] = i <NEWLINE> k = A [ k - 1 ] <NEWLINE> l . append ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r_start = seen [ k ] <NEWLINE> roop = i - r_start <NEWLINE> K = ( K - r_start ) % roop + r_start <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> ans = l [ K ] <NEWLINE> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 : break <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> print ( <STRING> * b ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = S [ 0 ] <NEWLINE> B = S [ 1 ] <NEWLINE> N = S [ 2 ] <NEWLINE> if N < B : <NEWLINE> <INDENT> print ( math . floor ( A * N / B ) - math . floor ( N / B ) * A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . floor ( A * ( B - 1 ) / B ) - math . floor ( ( B - 1 ) / B ) * A ) <NEWLINE> <DEDENT>
def insertion_sort ( a , n , g ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> j = i <NEWLINE> while j >= g and a [ j - g ] > a [ j ] : <NEWLINE> <INDENT> a [ j - g ] , a [ j ] = a [ j ] , a [ j - g ] <NEWLINE> j -= g <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return a , count <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , sys . stdin ) ) <NEWLINE> count = 0 <NEWLINE> <NL> G = [ 1 ] <NEWLINE> while n >= 3 * G [ - 1 ] + 1 : <NEWLINE> <INDENT> G . append ( 3 * G [ - 1 ] + 1 ) <NEWLINE> <NL> <DEDENT> for g in G [ : : - 1 ] : <NEWLINE> <INDENT> a , cnt = insertion_sort ( a , n , g ) <NEWLINE> count += cnt <NEWLINE> <NL> <DEDENT> print ( len ( G ) ) <NEWLINE> print ( * G [ : : - 1 ] ) <NEWLINE> print ( count ) <NEWLINE> print ( * a , sep = <STRING> ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> import collections <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 100000 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> ACMOD = 1000000007 <NEWLINE> INF = 1 << 62 <NEWLINE> <NL> <NL> def lmi ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def llmi ( n ) : <NEWLINE> <INDENT> return [ lmi ( ) for _ in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> N , A , B , C = lmi ( ) <NEWLINE> S = [ input ( ) . strip ( ) for _ in range ( N ) ] <NEWLINE> <NL> a = A <NEWLINE> b = B <NEWLINE> total = A + B + C <NEWLINE> ans = [ ] <NEWLINE> if total != 2 : <NEWLINE> <INDENT> for s in S : <NEWLINE> <INDENT> c = total - a - b <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if a > b : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> if a == 0 and c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if a > c : <NEWLINE> <INDENT> a -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> if b == 0 and c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if b > c : <NEWLINE> <INDENT> b -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( [ <STRING> ] + ans ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> case = { ( A , B , C ) : [ ] } <COMMENT> <NEWLINE> ans = [ ] <NEWLINE> <NL> for i , s in enumerate ( S ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> new_case = { } <NEWLINE> for ( a , b , c ) , v in case . items ( ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif a == 1 and b == 1 : <NEWLINE> <INDENT> new_case [ ( 0 , 2 , 0 ) ] = list ( v ) + [ <STRING> ] <NEWLINE> v . append ( <STRING> ) <NEWLINE> new_case [ ( 2 , 0 , 0 ) ] = v <NEWLINE> <COMMENT> <NL> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v . append ( <STRING> if b else <STRING> ) <NEWLINE> new_case [ ( abs ( a - 1 ) , abs ( b - 1 ) , c ) ] = v <NEWLINE> <DEDENT> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> if a == 0 and c == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if a == c : <NEWLINE> <INDENT> new_case [ ( 2 , 0 , 0 ) ] = list ( v ) + [ <STRING> ] <NEWLINE> v . append ( <STRING> ) <NEWLINE> new_case [ ( 0 , 0 , 2 ) ] = v <NEWLINE> <NL> <COMMENT> <NL> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v . append ( <STRING> if a else <STRING> ) <NEWLINE> new_case [ ( abs ( a - 1 ) , b , abs ( c - 1 ) ) ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> if b == 0 and c == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif b == c : <NEWLINE> <INDENT> new_case [ ( 0 , 2 , 0 ) ] = list ( v ) + [ <STRING> ] <NEWLINE> v . append ( <STRING> ) <NEWLINE> new_case [ ( 0 , 0 , 2 ) ] = v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v . append ( <STRING> if c else <STRING> ) <NEWLINE> new_case [ ( a , abs ( b - 1 ) , abs ( c - 1 ) ) ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if not new_case : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> case = new_case <NEWLINE> if len ( case ) == 1 : <NEWLINE> <INDENT> key = list ( case . keys ( ) ) [ 0 ] <NEWLINE> ans += case [ key ] <NEWLINE> case [ key ] = [ ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( [ <STRING> ] + ans + list ( case . values ( ) ) [ 0 ] ) ) <NEWLINE>
p = 1 <NEWLINE> mx = 1000000000000000000 <NEWLINE> n = int ( input ( ) ) <NEWLINE> num = input ( ) . split ( ) <NEWLINE> z = num . count ( <STRING> ) <NEWLINE> if ( z != 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in num : <NEWLINE> <INDENT> p *= int ( i ) <NEWLINE> if ( p > mx ) : <NEWLINE> <INDENT> p = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> a_index = bisect . bisect_left ( A , b ) <NEWLINE> c_index = bisect . bisect_right ( C , b ) <NEWLINE> ans += a_index * ( N - c_index ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = list ( range ( n ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i >= k : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
T = input ( ) <NEWLINE> new_T = <STRING> <NEWLINE> for i in T : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> i = <STRING> <NEWLINE> <DEDENT> new_T = new_T + i <NEWLINE> <DEDENT> print ( new_T ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> I = int ( N ** ( 0.5 ) // 1 ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( 1 , I + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> j = N // i <NEWLINE> i = len ( list ( str ( i ) ) ) <NEWLINE> j = len ( list ( str ( j ) ) ) <NEWLINE> k = max ( i , j ) <NEWLINE> a . append ( k ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( a ) ) <NEWLINE>
NTEST = 26 <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> <NL> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> SL = list ( ) <NEWLINE> SL . append ( [ 0 for i in range ( NTEST ) ] ) <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> SL . append ( S ) <NEWLINE> <NL> <DEDENT> tests = list ( ) <NEWLINE> tests . append ( 0 ) <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> tests . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> def calcSat ( test_applied ) : <NEWLINE> <INDENT> lastDay = [ 0 for i in range ( NTEST ) ] <NEWLINE> <NL> sat = 0 <NEWLINE> for d in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> tst = test_applied [ d ] - 1 <NEWLINE> lastDay [ tst ] = d <NEWLINE> sat += SL [ d ] [ tst ] <NEWLINE> for itst in range ( NTEST ) : <NEWLINE> <INDENT> sat -= C [ itst ] * ( d - lastDay [ itst ] ) <NEWLINE> <DEDENT> <DEDENT> return sat <NEWLINE> <NL> <DEDENT> satList = list ( ) <NEWLINE> satList . append ( 0 ) <NEWLINE> lastDay = [ [ 0 for i in range ( NTEST ) ] ] <NEWLINE> <NL> def calcSat_with_memo ( test_applied ) : <NEWLINE> <NL> <INDENT> total_sat = 0 <NEWLINE> for d in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> lastDay . append ( list ( lastDay [ d - 1 ] ) ) <NEWLINE> sat = 0 <NEWLINE> tst = test_applied [ d ] - 1 <NEWLINE> lastDay [ d ] [ tst ] = d <NEWLINE> sat += SL [ d ] [ tst ] <NEWLINE> for itst in range ( NTEST ) : <NEWLINE> <INDENT> sat -= C [ itst ] * ( d - lastDay [ d ] [ itst ] ) <NEWLINE> <DEDENT> satList . append ( sat ) <NEWLINE> total_sat += sat <NEWLINE> <NL> <DEDENT> return total_sat <NEWLINE> <NL> <DEDENT> def recalcSat_with_memo ( total_sat_before , tday , t_from , t_to , test_applied ) : <NEWLINE> <NL> <INDENT> d_total_sat = 0 <NEWLINE> <NL> lastDay [ tday ] [ t_from - 1 ] = lastDay [ tday - 1 ] [ t_from - 1 ] <NEWLINE> d_sat = 0 <NEWLINE> d_sat += ( SL [ tday ] [ t_to - 1 ] - SL [ tday ] [ t_from - 1 ] ) <NEWLINE> d_sat += C [ t_to - 1 ] * ( tday - lastDay [ tday ] [ t_to - 1 ] ) <NEWLINE> d_sat -= C [ t_from - 1 ] * ( tday - lastDay [ tday ] [ t_from - 1 ] ) <NEWLINE> <NL> lastDay [ tday ] [ t_to - 1 ] = tday <NEWLINE> <NL> satList [ tday ] += d_sat <NEWLINE> d_total_sat += d_sat <NEWLINE> <NL> old_last = tday <NEWLINE> new_last = lastDay [ tday ] [ t_from - 1 ] <NEWLINE> for d in range ( tday + 1 , D + 1 ) : <NEWLINE> <INDENT> if test_applied [ d ] == t_from : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> d_sat = C [ t_from - 1 ] * ( - old_last + new_last ) <NEWLINE> lastDay [ d ] [ t_from - 1 ] = new_last <NEWLINE> satList [ d ] += d_sat <NEWLINE> d_total_sat += d_sat <NEWLINE> <NL> <DEDENT> old_last = lastDay [ tday - 1 ] [ t_to - 1 ] <NEWLINE> new_last = tday <NEWLINE> for d in range ( tday + 1 , D + 1 ) : <NEWLINE> <INDENT> if test_applied [ d ] == t_to : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> d_sat = C [ t_to - 1 ] * ( - old_last + new_last ) <NEWLINE> lastDay [ d ] [ t_to - 1 ] = new_last <NEWLINE> satList [ d ] += d_sat <NEWLINE> d_total_sat += d_sat <NEWLINE> <NL> <DEDENT> return d_total_sat <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> sat = calcSat_with_memo ( tests ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> M = int ( input ( ) ) <NEWLINE> <NL> ans = list ( ) <NEWLINE> <NL> for m in range ( M ) : <NEWLINE> <INDENT> d , new_tst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d_sat = recalcSat_with_memo ( sat , d , tests [ d ] , new_tst , tests ) <NEWLINE> <NL> tests [ d ] = new_tst <NEWLINE> sat += d_sat <NEWLINE> ans . append ( sat ) <NEWLINE> <NL> <DEDENT> for m in range ( M ) : <NEWLINE> <INDENT> print ( ans [ m ] ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ab = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab . append ( ( a , b ) ) <NEWLINE> <DEDENT> di = { } <NEWLINE> z = 0 <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> while b != 0 : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> for a , b in ab : <NEWLINE> <INDENT> if a * b != 0 : <NEWLINE> <INDENT> g = gcd ( abs ( a ) , abs ( b ) ) <NEWLINE> a , b = a // g , b // g <NEWLINE> <DEDENT> if a * b > 0 : <NEWLINE> <INDENT> ind = ( abs ( a ) , abs ( b ) ) <NEWLINE> <DEDENT> elif a * b < 0 : <NEWLINE> <INDENT> ind = ( abs ( b ) , abs ( a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ind = 0 <NEWLINE> <DEDENT> if ind in di : <NEWLINE> <INDENT> x , y = di [ ind ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = y = 0 <NEWLINE> <DEDENT> if a * b == 0 : <NEWLINE> <INDENT> if b != 0 : <NEWLINE> <INDENT> di [ ind ] = ( x + 1 , y ) <NEWLINE> <DEDENT> elif a != 0 : <NEWLINE> <INDENT> di [ ind ] = ( x , y + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a * b > 0 : <NEWLINE> <INDENT> di [ ind ] = ( x + 1 , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> di [ ind ] = ( x , y + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> for i , j in di . values ( ) : <NEWLINE> <INDENT> ans *= ( pow ( 2 , i , mod ) + pow ( 2 , j , mod ) - 1 ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ( ans + z - 1 ) % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> change = [ 0 for i in range ( q ) ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> change [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> dic = { } <NEWLINE> for i in num : <NEWLINE> <INDENT> if i in dic : <NEWLINE> <INDENT> dic [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i , j in enumerate ( dic ) : <NEWLINE> <INDENT> ans += j * dic [ j ] <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> if change [ i ] [ 0 ] in dic : <NEWLINE> <INDENT> ans += dic [ change [ i ] [ 0 ] ] * ( change [ i ] [ 1 ] - change [ i ] [ 0 ] ) <NEWLINE> if change [ i ] [ 1 ] in dic : <NEWLINE> <INDENT> dic [ change [ i ] [ 1 ] ] += dic . pop ( change [ i ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ change [ i ] [ 1 ] ] = dic . pop ( change [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> ans1 = - y - ( - x ) + 2 <NEWLINE> <COMMENT> <NL> ans2 = y - ( - x ) + 1 <NEWLINE> <COMMENT> <NL> ans3 = - y - x + 1 <NEWLINE> <COMMENT> <NL> ans4 = y - x <NEWLINE> <NL> ans = [ ans1 , ans2 , ans3 , ans4 ] <NEWLINE> ans = [ a for a in ans if a > 0 ] <NEWLINE> ans = min ( ans ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = 1 <NEWLINE> x = 100 <NEWLINE> while x < n : <NEWLINE> <INDENT> x = x * ( 1.01 ) <NEWLINE> x = int ( x ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> print ( c - 1 ) <NEWLINE>
h , w = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> list_a = [ input ( ) for s in range ( 0 , h ) ] <NEWLINE> list_tmp = [ ] <NEWLINE> for i in range ( 0 , h ) : <NEWLINE> <INDENT> for j in range ( 0 , w ) : <NEWLINE> <INDENT> if list_a [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> list_tmp . append ( list ( list_a [ i ] ) ) <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> list_tmp_t = [ list ( x ) for x in zip ( * list_tmp ) ] <NEWLINE> list_tmp2 = [ ] <NEWLINE> for i in range ( 0 , len ( list_tmp_t ) ) : <NEWLINE> <INDENT> for j in range ( 0 , len ( list_tmp_t [ i ] ) ) : <NEWLINE> <INDENT> if list_tmp_t [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> list_tmp2 . append ( list ( list_tmp_t [ i ] ) ) <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> list_ans = [ list ( x ) for x in zip ( * list_tmp2 ) ] <NEWLINE> for i in range ( 0 , len ( list_ans ) ) : <NEWLINE> <INDENT> print ( <STRING> . join ( list_ans [ i ] ) ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> c = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> a = gcd ( gcd ( i , j ) , l ) <NEWLINE> c += a <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> import bisect <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> an = bisect . bisect_left ( A , b ) <NEWLINE> cn = N - bisect . bisect_right ( C , b ) <NEWLINE> ans += an * cn <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> max_A = A [ - 1 ] <NEWLINE> <COMMENT> <NL> df = [ True for _ in range ( max_A + 1 ) ] <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> if A [ i ] == A [ i - 1 ] : <NEWLINE> <INDENT> df [ a ] = False <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> if df [ a ] : <NEWLINE> <INDENT> for num in range ( 2 * a , max_A + 1 , a ) : <NEWLINE> <INDENT> df [ num ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> count = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if df [ a ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> <NL> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> row = [ 0 ] * h <NEWLINE> col = [ 0 ] * w <NEWLINE> bomb = set ( ) <NEWLINE> for x in range ( m ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> bomb . add ( ( H - 1 , W - 1 ) ) <NEWLINE> row [ H - 1 ] += 1 <NEWLINE> col [ W - 1 ] += 1 <NEWLINE> <NL> <DEDENT> maxrow = max ( row ) <NEWLINE> maxcol = max ( col ) <NEWLINE> ans = maxcol + maxrow - 1 <NEWLINE> p , q = [ ] , [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if row [ i ] == maxrow : <NEWLINE> <INDENT> p . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( w ) : <NEWLINE> <INDENT> if col [ i ] == maxcol : <NEWLINE> <INDENT> q . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in p : <NEWLINE> <INDENT> for j in q : <NEWLINE> <INDENT> if ( i , j ) not in bomb : <NEWLINE> <INDENT> print ( ans + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> ans = L [ n ] * ans <NEWLINE> if ans >= 1000000000000000001 : ans = - 1 <NEWLINE> if ans == - 1 : break <NEWLINE> <NL> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> if L [ n ] == 0 : ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> k = 0 <NEWLINE> top = [ ] <NEWLINE> bottom = [ ] <NEWLINE> t = 0 <NEWLINE> ans = 1000 <NEWLINE> ka = 0 <NEWLINE> while a [ s ] == a [ s + 1 ] and s < n - 1 : <NEWLINE> <INDENT> s += 1 <NEWLINE> if s == n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if s == n - 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a [ s ] > a [ s + 1 ] : <NEWLINE> <INDENT> k = - 1 <NEWLINE> t = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = 1 <NEWLINE> <NL> <DEDENT> while s < n - 1 : <NEWLINE> <INDENT> while a [ s ] * k <= a [ s + 1 ] * k and s < n - 1 : <NEWLINE> <INDENT> s += 1 <NEWLINE> if s == n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if k == - 1 : <NEWLINE> <INDENT> bottom . append ( a [ s ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> top . append ( a [ s ] ) <NEWLINE> <DEDENT> k *= - 1 <NEWLINE> s += 1 <NEWLINE> <DEDENT> if k == 1 : <NEWLINE> <INDENT> top . append ( a [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bottom . append ( a [ - 1 ] ) <NEWLINE> <DEDENT> if t == 1 : <NEWLINE> <INDENT> for i in range ( len ( top ) ) : <NEWLINE> <INDENT> ka += ans // bottom [ i ] <NEWLINE> ans = ans % bottom [ i ] <NEWLINE> ans += ka * top [ i ] <NEWLINE> ka = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( top ) ) : <NEWLINE> <NL> <INDENT> if i == 0 : <NEWLINE> <INDENT> ka += ans // a [ i ] <NEWLINE> ans = ans % a [ i ] <NEWLINE> ans += ka * top [ i ] <NEWLINE> ka = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ka += ans // bottom [ i - 1 ] <NEWLINE> ans = ans % bottom [ i - 1 ] <NEWLINE> ans += ka * top [ i ] <NEWLINE> ka = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> an = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> check = sorted ( an , reverse = True ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if an [ i ] == check [ 0 ] : <NEWLINE> <INDENT> print ( check [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( check [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> H , W = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> Ch , Cw = [ int ( x ) + 1 for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> Dh , Dw = [ int ( x ) + 1 for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> M = [ 0 for _ in range ( H + 4 ) ] <NEWLINE> M [ 0 ] = [ <STRING> ] * ( W + 4 ) <NEWLINE> M [ 1 ] = [ <STRING> ] * ( W + 4 ) <NEWLINE> M [ - 2 ] = [ <STRING> ] * ( W + 4 ) <NEWLINE> M [ - 1 ] = [ <STRING> ] * ( W + 4 ) <NEWLINE> for h in range ( 2 , H + 2 ) : <NEWLINE> <INDENT> M [ h ] = [ <STRING> ] * 2 + list ( input ( ) . strip ( ) ) + [ <STRING> ] * 2 <NEWLINE> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> q = set ( [ ( Ch , Cw ) ] ) <NEWLINE> M [ Ch ] [ Cw ] = <STRING> <NEWLINE> dhdw = [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> while True : <NEWLINE> <INDENT> newq = set ( ) <NEWLINE> while q : <NEWLINE> <INDENT> q_ = set ( ) <NEWLINE> for h , w in q : <NEWLINE> <COMMENT> <NL> <INDENT> if h == Dh and w == Dw : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> return True <NEWLINE> <DEDENT> newq . add ( ( h , w ) ) <NEWLINE> for dh , dw in dhdw : <NEWLINE> <INDENT> if M [ h + dh ] [ w + dw ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q_ . add ( ( h + dh , w + dw ) ) <NEWLINE> M [ h + dh ] [ w + dw ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> q = q_ <NEWLINE> <NL> <DEDENT> if newq : <NEWLINE> <INDENT> for h , w in newq : <NEWLINE> <INDENT> for dh in range ( - 2 , 3 ) : <NEWLINE> <INDENT> for dw in range ( - 2 , 3 ) : <NEWLINE> <INDENT> if M [ h + dh ] [ w + dw ] == <STRING> : <NEWLINE> <INDENT> q . add ( ( h + dh , w + dw ) ) <NEWLINE> M [ h + dh ] [ w + dw ] = <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if len ( q ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> for i in a : <NEWLINE> <INDENT> count *= i <NEWLINE> if count > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if count <= 10 ** 18 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> def lg ( value ) : <NEWLINE> <INDENT> flag = False <NEWLINE> <COMMENT> <NL> if flag : <NEWLINE> <INDENT> print ( str ( value ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def xt ( log ) : <NEWLINE> <INDENT> lg ( <STRING> + str ( log ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_results ( ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> lines = list ( ) <NEWLINE> <COMMENT> <NL> lines_count = 2 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> N = int ( lines [ 0 ] ) <NEWLINE> <COMMENT> <NL> values = list ( map ( int , lines [ 1 ] . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> lg ( <STRING> ) <NEWLINE> <NL> targets = list ( ) <NEWLINE> <COMMENT> <NL> su = 0 <NEWLINE> for j in range ( 1 , N ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> su += values [ N - j ] <NEWLINE> targets . append ( su ) <NEWLINE> <NL> <DEDENT> su = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> su = ( su + values [ i ] * targets [ N - 2 - i ] ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> return [ su ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> results = get_results ( ) <NEWLINE> <NL> for result in results : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def gcd ( x , y ) : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> while y > 0 : <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> a , b = list ( map ( int , line . split ( ) ) ) <NEWLINE> print ( <STRING> . format ( gcd ( a , b ) , int ( ( a * b ) / gcd ( a , b ) ) ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N , W = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> items = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> <COMMENT> <NL> memo = np . zeros ( shape = W + 1 , dtype = np . int64 ) <NEWLINE> <NL> for w , v in items : <NEWLINE> <INDENT> memo [ w : ] = np . maximum ( memo [ w : ] , memo [ : - w ] + v ) <NEWLINE> <NL> <DEDENT> print ( memo [ - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = [ 0 ] * n <NEWLINE> g = [ 0 ] * n <NEWLINE> b = [ 0 ] * n <NEWLINE> ri = gi = bi = 0 <NEWLINE> for i , c in enumerate ( s ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> ri += 1 <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> gi += 1 <NEWLINE> <DEDENT> if c == <STRING> : <NEWLINE> <INDENT> bi += 1 <NEWLINE> <DEDENT> r [ i ] = ri <NEWLINE> g [ i ] = gi <NEWLINE> b [ i ] = bi <NEWLINE> <NL> <NL> <DEDENT> ans = r [ - 1 ] * g [ - 1 ] * b [ - 1 ] <NEWLINE> <NL> for k in range ( 2 , n ) : <NEWLINE> <INDENT> for j in range ( 1 , k ) : <NEWLINE> <INDENT> if s [ k ] == s [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> i = 2 * j - k <NEWLINE> if i < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ k ] != s [ i ] and s [ j ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> X = SS ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> pc_X = X . count ( <STRING> ) <NEWLINE> <NL> if pc_X == 0 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> elif pc_X == 1 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i == X . index ( <STRING> ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if i == N - 1 or X . index ( <STRING> ) == N - 1 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> next_X_m1 = 0 <NEWLINE> next_X_p1 = 0 <NEWLINE> pc_m1 = pc_X - 1 <NEWLINE> pc_p1 = pc_X + 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> next_X_m1 += pow ( 2 , N - 1 - i , pc_m1 ) <NEWLINE> next_X_p1 += pow ( 2 , N - 1 - i , pc_p1 ) <NEWLINE> <DEDENT> <DEDENT> dp = [ - 1 ] * N <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def f ( n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while n : <NEWLINE> <INDENT> n %= bin ( n ) . count ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> next = 0 <NEWLINE> if X [ i ] == <STRING> : <NEWLINE> <INDENT> next = ( next_X_p1 + pow ( 2 , N - 1 - i , pc_p1 ) ) % pc_p1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if pc_m1 >= 1 : <NEWLINE> <INDENT> next = ( next_X_m1 - pow ( 2 , N - 1 - i , pc_m1 ) ) % pc_m1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> next = next_X_m1 - pow ( 2 , N - 1 - i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if pc_X == 1 and X [ i ] == <STRING> and i == N - 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ans = f ( next ) + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import Counter <NEWLINE> N = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> A = list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> A_counters = Counter ( A ) <NEWLINE> A . sort ( ) <NEWLINE> A_set = set ( A ) <NEWLINE> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a in A_set : <NEWLINE> <INDENT> if A_counters [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> for i in range ( 1 , A [ - 1 ] // a + 1 ) : <NEWLINE> <INDENT> if a * i in A_set : <NEWLINE> <INDENT> A_set . remove ( a * i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . insert ( 0 , 0 ) <NEWLINE> b . insert ( 0 , 0 ) <NEWLINE> j = 1 <NEWLINE> while j <= m and b [ j ] + b [ j - 1 ] <= k : <NEWLINE> <INDENT> b [ j ] += b [ j - 1 ] <NEWLINE> j += 1 <NEWLINE> <NL> <NL> <DEDENT> j -= 1 <NEWLINE> books = j <NEWLINE> <COMMENT> <NL> <NL> i = 1 <NEWLINE> while i < n + 1 : <NEWLINE> <INDENT> a [ i ] += a [ i - 1 ] <NEWLINE> while j >= 0 and a [ i ] + b [ j ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> if ( j != - 1 ) and a [ i ] + b [ j ] <= k : <NEWLINE> <INDENT> books = max ( books , j + i ) <NEWLINE> <NL> <NL> i += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( books ) <NEWLINE>
cnt = [ 0 for i in range ( 26 ) ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> m = ord ( s [ i ] ) - ord ( <STRING> ) <NEWLINE> if ( m >= 0 and m < 26 ) : <NEWLINE> <INDENT> cnt [ m ] += 1 <NEWLINE> <DEDENT> m = ord ( s [ i ] ) - ord ( <STRING> ) <NEWLINE> if ( m >= 0 and m < 26 ) : <NEWLINE> <INDENT> cnt [ m ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> print ( chr ( i + ord ( <STRING> ) ) , <STRING> , cnt [ i ] ) <NEWLINE> <DEDENT>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dp = [ - 1 for _i in range ( 10 ** 5 + 2 ) ] <NEWLINE> nums = [ - 1 for _i in range ( 10 ** 5 + 2 ) ] <NEWLINE> nums [ x ] = 1 <NEWLINE> <NL> dp [ x ] = x <NEWLINE> bef = x <NEWLINE> nex = ( x ** 2 ) % m <NEWLINE> r = [ 0 , x ] <NEWLINE> while dp [ nex ] < 0 : <NEWLINE> <INDENT> nums [ nex ] = nums [ bef ] + 1 <NEWLINE> dp [ nex ] = dp [ bef ] + nex <NEWLINE> r . append ( dp [ nex ] ) <NEWLINE> nex , bef = ( nex ** 2 ) % m , nex <NEWLINE> <NL> <DEDENT> if nex == 0 : <NEWLINE> <INDENT> print ( r [ min ( len ( r ) - 1 , n ) ] ) <NEWLINE> <DEDENT> elif n <= nums [ bef ] : <NEWLINE> <INDENT> print ( r [ n ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> roop = nums [ bef ] - nums [ nex ] + 1 <NEWLINE> roop_value = r [ nums [ bef ] ] - r [ nums [ nex ] - 1 ] <NEWLINE> plus = r [ nums [ nex ] - 1 ] * ( n >= nums [ nex ] + 1 ) <NEWLINE> n = max ( 0 , n - nums [ nex ] + 1 ) <NEWLINE> print ( <NEWLINE> <INDENT> roop_value * ( n // roop ) + plus + <NEWLINE> r [ n % roop + nums [ nex ] - 1 ] <NEWLINE> - r [ nums [ nex ] - 1 ] <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT>
ans = [ 1 , 9 , 30 , 76 , 141 , 267 , 400 , 624 , 885 , 1249 , 1590 , 2208 , 2689 , 3411 , 4248 , 5248 , 6081 , 7485 , 8530 , 10248 , 11889 , 13687 , 15228 , 17988 , 20053 , 22569 , 25242 , 28588 , 31053 , 35463 , 38284 , 42540 , 46581 , 50893 , 55362 , 61824 , 65857 , 71247 , 76884 , 84388 , 89349 , 97881 , 103342 , 111528 , 120141 , 128047 , 134580 , 146316 , 154177 , 164817 , 174438 , 185836 , 194157 , 207927 , 218812 , 233268 , 245277 , 257857 , 268182 , 288216 , 299257 , 313635 , 330204 , 347836 , 362973 , 383709 , 397042 , 416448 , 434025 , 456967 , 471948 , 499740 , 515581 , 536073 , 559758 , 583960 , 604833 , 633651 , 652216 , 683712 , 709065 , 734233 , 754734 , 793188 , 818917 , 846603 , 874512 , 909496 , 933081 , 977145 , 1006126 , 1041504 , 1073385 , 1106467 , 1138536 , 1187112 , 1215145 , 1255101 , 1295142 , 1342852 , 1373253 , 1422195 , 1453816 , 1502376 , 1553361 , 1595437 , 1629570 , 1691292 , 1726717 , 1782111 , 1827492 , 1887772 , 1925853 , 1986837 , 2033674 , 2089776 , 2145333 , 2197483 , 2246640 , 2332104 , 2379085 , 2434833 , 2490534 , 2554600 , 2609625 , 2693919 , 2742052 , 2813988 , 2875245 , 2952085 , 3003306 , 3096024 , 3157249 , 3224511 , 3306240 , 3388576 , 3444609 , 3533637 , 3591322 , 3693924 , 3767085 , 3842623 , 3912324 , 4027884 , 4102093 , 4181949 , 4270422 , 4361548 , 4427853 , 4548003 , 4616104 , 4718640 , 4812789 , 4918561 , 5003286 , 5131848 , 5205481 , 5299011 , 5392008 , 5521384 , 5610705 , 5739009 , 5818390 , 5930196 , 6052893 , 6156139 , 6239472 , 6402720 , 6493681 , 6623853 , 6741078 , 6864016 , 6953457 , 7094451 , 7215016 , 7359936 , 7475145 , 7593865 , 7689630 , 7886244 , 7984165 , 8130747 , 8253888 , 8403448 , 8523897 , 8684853 , 8802826 , 8949612 , 9105537 , 9267595 , 9376656 , 9574704 , 9686065 , 9827097 , 9997134 , 10174780 , 10290813 , 10493367 , 10611772 , 10813692 ] <NEWLINE> print ( ans [ int ( input ( ) ) - 1 ] ) <NEWLINE>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * ( c + 1 ) <NEWLINE> for _ in range ( r ) : <NEWLINE> <INDENT> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> for i , e in enumerate ( v ) : <NEWLINE> <INDENT> s += e <NEWLINE> a [ i ] += e <NEWLINE> <DEDENT> v . append ( s ) <NEWLINE> print ( * v ) <NEWLINE> a [ - 1 ] += s <NEWLINE> <DEDENT> print ( * a ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> edges = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> <NL> <NL> graph = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for edge in edges : <NEWLINE> <INDENT> graph [ edge [ 0 ] ] . append ( edge [ 1 ] ) <NEWLINE> graph [ edge [ 1 ] ] . append ( edge [ 0 ] ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> can = graph [ i ] <NEWLINE> hights = [ ] <NEWLINE> for j in can : <NEWLINE> <INDENT> hights . append ( H [ j - 1 ] ) <NEWLINE> <DEDENT> if len ( hights ) == 0 : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h = max ( hights ) <NEWLINE> if H [ i - 1 ] > h : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( set ( ans ) ) ) <NEWLINE>
from functools import reduce <NEWLINE> <NL> N = int ( input ( ) . strip ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> xor = reduce ( lambda x , y : x ^ y , A ) <NEWLINE> <NL> print ( <STRING> . join ( [ <NEWLINE> <INDENT> str ( xor ^ a ) <NEWLINE> for a in A <NEWLINE> <DEDENT> ] ) ) <NEWLINE>
import heapq <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a - 1 ] . append ( ( b - 1 , c ) ) <NEWLINE> G [ b - 1 ] . append ( ( a - 1 , c ) ) <NEWLINE> <DEDENT> used = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> H = [ ] <NEWLINE> for b , c in G [ i ] : <NEWLINE> <INDENT> heapq . heappush ( H , ( c , i , b ) ) <NEWLINE> <DEDENT> D = [ 10 ** 10 ] * N <NEWLINE> D [ i ] = 0 <NEWLINE> while H : <NEWLINE> <INDENT> c , a , b = heapq . heappop ( H ) <NEWLINE> if D [ b ] < c : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> D [ b ] = c <NEWLINE> if a < b : <NEWLINE> <INDENT> used . add ( ( a , b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> used . add ( ( b , a ) ) <NEWLINE> <DEDENT> for d , cc in G [ b ] : <NEWLINE> <INDENT> if D [ d ] > c + cc : <NEWLINE> <INDENT> D [ d ] = c + cc <NEWLINE> heapq . heappush ( H , ( c + cc , b , d ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return M - len ( used ) <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
import numpy as np <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = np . array ( list ( map ( int , input ( ) . split ( ) ) ) + [ 0 ] * K , dtype = np . int64 ) <NEWLINE> H = np . array ( h ) <NEWLINE> dp = np . full ( N + K , 10 ** 10 , dtype = np . int64 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ i : i + K ] = np . minimum ( dp [ i : i + K ] , <NEWLINE> <INDENT> np . abs ( H [ i : i + K ] - H [ i - 1 ] ) + dp [ i - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
from collections import Counter <NEWLINE> cnt = 0 <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> minus_list = [ j - A [ j ] for j in range ( N ) ] <NEWLINE> counter = Counter ( minus_list ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> add = A [ i ] + i <NEWLINE> cnt += counter [ add ] <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> print ( ( a ) * ( a - 1 ) // 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> root = set ( range ( n ) ) <NEWLINE> binary_tree = [ 0 for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> binary_tree [ l [ 0 ] ] = l <NEWLINE> s = set ( l [ 1 : 3 ] ) <NEWLINE> root -= s <NEWLINE> <NL> <DEDENT> def binary ( id , parent , depth , sibling , height ) : <NEWLINE> <INDENT> output = { } <NEWLINE> hline = [ ] <NEWLINE> hline . append ( height ) <NEWLINE> output [ <STRING> ] = id <NEWLINE> output [ <STRING> ] = parent <NEWLINE> output [ <STRING> ] = sibling <NEWLINE> output [ <STRING> ] = depth <NEWLINE> left = binary_tree [ id ] [ 1 ] <NEWLINE> right = binary_tree [ id ] [ 2 ] <NEWLINE> degree = 0 <NEWLINE> if ( parent == - 1 ) : <NEWLINE> <INDENT> output [ <STRING> ] = <STRING> <NEWLINE> <DEDENT> elif ( left == - 1 and right == - 1 ) : <NEWLINE> <INDENT> output [ <STRING> ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> output [ <STRING> ] = <STRING> <NEWLINE> <DEDENT> if ( left != - 1 ) : <NEWLINE> <INDENT> degree += 1 <NEWLINE> hline . append ( binary ( left , id , depth + 1 , right , height ) ) <NEWLINE> <DEDENT> if ( right != - 1 ) : <NEWLINE> <INDENT> degree += 1 <NEWLINE> hline . append ( binary ( right , id , depth + 1 , left , height ) ) <NEWLINE> <DEDENT> max_height = max ( hline ) <NEWLINE> output [ <STRING> ] = degree <NEWLINE> output [ <STRING> ] = max_height <NEWLINE> binary_tree [ id ] = output <NEWLINE> return max_height + 1 <NEWLINE> <NL> <DEDENT> binary ( list ( root ) [ 0 ] , - 1 , 0 , - 1 , 0 ) <NEWLINE> for line in binary_tree : <NEWLINE> <INDENT> print ( <STRING> . format ( line [ <STRING> ] , line [ <STRING> ] , line [ <STRING> ] , line [ <STRING> ] , line [ <STRING> ] , line [ <STRING> ] , line [ <STRING> ] ) ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> <NL> r , g , b = set ( ) , set ( ) , set ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . add ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g . add ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . add ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = len ( r ) * len ( g ) * len ( b ) <NEWLINE> for r_idx in r : <NEWLINE> <INDENT> for g_idx in g : <NEWLINE> <INDENT> j , i = max ( r_idx , g_idx ) , min ( r_idx , g_idx ) <NEWLINE> diff_ji = abs ( j - i ) <NEWLINE> cnt = 0 <NEWLINE> for v in [ j + diff_ji , i - diff_ji , ( j + i ) / 2 ] : <NEWLINE> <INDENT> if v in b : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ans -= cnt <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> result = [ <STRING> ] <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> result . append ( i ) <NEWLINE> <DEDENT> elif <STRING> in list ( ( str ( i ) ) ) : <NEWLINE> <INDENT> result . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( * result ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> a = { <NEWLINE> 1 : 1 , <NEWLINE> 2 : 9 , <NEWLINE> 3 : 30 , <NEWLINE> 4 : 76 , <NEWLINE> 5 : 141 , <NEWLINE> 6 : 267 , <NEWLINE> 7 : 400 , <NEWLINE> 8 : 624 , <NEWLINE> 9 : 885 , <NEWLINE> 10 : 1249 , <NEWLINE> 11 : 1590 , <NEWLINE> 12 : 2208 , <NEWLINE> 13 : 2689 , <NEWLINE> 14 : 3411 , <NEWLINE> 15 : 4248 , <NEWLINE> 16 : 5248 , <NEWLINE> 17 : 6081 , <NEWLINE> 18 : 7485 , <NEWLINE> 19 : 8530 , <NEWLINE> 20 : 10248 , <NEWLINE> 21 : 11889 , <NEWLINE> 22 : 13687 , <NEWLINE> 23 : 15228 , <NEWLINE> 24 : 17988 , <NEWLINE> 25 : 20053 , <NEWLINE> 26 : 22569 , <NEWLINE> 27 : 25242 , <NEWLINE> 28 : 28588 , <NEWLINE> 29 : 31053 , <NEWLINE> 30 : 35463 , <NEWLINE> 31 : 38284 , <NEWLINE> 32 : 42540 , <NEWLINE> 33 : 46581 , <NEWLINE> 34 : 50893 , <NEWLINE> 35 : 55362 , <NEWLINE> 36 : 61824 , <NEWLINE> 37 : 65857 , <NEWLINE> 38 : 71247 , <NEWLINE> 39 : 76884 , <NEWLINE> 40 : 84388 , <NEWLINE> 41 : 89349 , <NEWLINE> 42 : 97881 , <NEWLINE> 43 : 103342 , <NEWLINE> 44 : 111528 , <NEWLINE> 45 : 120141 , <NEWLINE> 46 : 128047 , <NEWLINE> 47 : 134580 , <NEWLINE> 48 : 146316 , <NEWLINE> 49 : 154177 , <NEWLINE> 50 : 164817 , <NEWLINE> 51 : 174438 , <NEWLINE> 52 : 185836 , <NEWLINE> 53 : 194157 , <NEWLINE> 54 : 207927 , <NEWLINE> 55 : 218812 , <NEWLINE> 56 : 233268 , <NEWLINE> 57 : 245277 , <NEWLINE> 58 : 257857 , <NEWLINE> 59 : 268182 , <NEWLINE> 60 : 288216 , <NEWLINE> 61 : 299257 , <NEWLINE> 62 : 313635 , <NEWLINE> 63 : 330204 , <NEWLINE> 64 : 347836 , <NEWLINE> 65 : 362973 , <NEWLINE> 66 : 383709 , <NEWLINE> 67 : 397042 , <NEWLINE> 68 : 416448 , <NEWLINE> 69 : 434025 , <NEWLINE> 70 : 456967 , <NEWLINE> 71 : 471948 , <NEWLINE> 72 : 499740 , <NEWLINE> 73 : 515581 , <NEWLINE> 74 : 536073 , <NEWLINE> 75 : 559758 , <NEWLINE> 76 : 583960 , <NEWLINE> 77 : 604833 , <NEWLINE> 78 : 633651 , <NEWLINE> 79 : 652216 , <NEWLINE> 80 : 683712 , <NEWLINE> 81 : 709065 , <NEWLINE> 82 : 734233 , <NEWLINE> 83 : 754734 , <NEWLINE> 84 : 793188 , <NEWLINE> 85 : 818917 , <NEWLINE> 86 : 846603 , <NEWLINE> 87 : 874512 , <NEWLINE> 88 : 909496 , <NEWLINE> 89 : 933081 , <NEWLINE> 90 : 977145 , <NEWLINE> 91 : 1006126 , <NEWLINE> 92 : 1041504 , <NEWLINE> 93 : 1073385 , <NEWLINE> 94 : 1106467 , <NEWLINE> 95 : 1138536 , <NEWLINE> 96 : 1187112 , <NEWLINE> 97 : 1215145 , <NEWLINE> 98 : 1255101 , <NEWLINE> 99 : 1295142 , <NEWLINE> 100 : 1342852 , <NEWLINE> 101 : 1373253 , <NEWLINE> 102 : 1422195 , <NEWLINE> 103 : 1453816 , <NEWLINE> 104 : 1502376 , <NEWLINE> 105 : 1553361 , <NEWLINE> 106 : 1595437 , <NEWLINE> 107 : 1629570 , <NEWLINE> 108 : 1691292 , <NEWLINE> 109 : 1726717 , <NEWLINE> 110 : 1782111 , <NEWLINE> 111 : 1827492 , <NEWLINE> 112 : 1887772 , <NEWLINE> 113 : 1925853 , <NEWLINE> 114 : 1986837 , <NEWLINE> 115 : 2033674 , <NEWLINE> 116 : 2089776 , <NEWLINE> 117 : 2145333 , <NEWLINE> 118 : 2197483 , <NEWLINE> 119 : 2246640 , <NEWLINE> 120 : 2332104 , <NEWLINE> 121 : 2379085 , <NEWLINE> 122 : 2434833 , <NEWLINE> 123 : 2490534 , <NEWLINE> 124 : 2554600 , <NEWLINE> 125 : 2609625 , <NEWLINE> 126 : 2693919 , <NEWLINE> 127 : 2742052 , <NEWLINE> 128 : 2813988 , <NEWLINE> 129 : 2875245 , <NEWLINE> 130 : 2952085 , <NEWLINE> 131 : 3003306 , <NEWLINE> 132 : 3096024 , <NEWLINE> 133 : 3157249 , <NEWLINE> 134 : 3224511 , <NEWLINE> 135 : 3306240 , <NEWLINE> 136 : 3388576 , <NEWLINE> 137 : 3444609 , <NEWLINE> 138 : 3533637 , <NEWLINE> 139 : 3591322 , <NEWLINE> 140 : 3693924 , <NEWLINE> 141 : 3767085 , <NEWLINE> 142 : 3842623 , <NEWLINE> 143 : 3912324 , <NEWLINE> 144 : 4027884 , <NEWLINE> 145 : 4102093 , <NEWLINE> 146 : 4181949 , <NEWLINE> 147 : 4270422 , <NEWLINE> 148 : 4361548 , <NEWLINE> 149 : 4427853 , <NEWLINE> 150 : 4548003 , <NEWLINE> 151 : 4616104 , <NEWLINE> 152 : 4718640 , <NEWLINE> 153 : 4812789 , <NEWLINE> 154 : 4918561 , <NEWLINE> 155 : 5003286 , <NEWLINE> 156 : 5131848 , <NEWLINE> 157 : 5205481 , <NEWLINE> 158 : 5299011 , <NEWLINE> 159 : 5392008 , <NEWLINE> 160 : 5521384 , <NEWLINE> 161 : 5610705 , <NEWLINE> 162 : 5739009 , <NEWLINE> 163 : 5818390 , <NEWLINE> 164 : 5930196 , <NEWLINE> 165 : 6052893 , <NEWLINE> 166 : 6156139 , <NEWLINE> 167 : 6239472 , <NEWLINE> 168 : 6402720 , <NEWLINE> 169 : 6493681 , <NEWLINE> 170 : 6623853 , <NEWLINE> 171 : 6741078 , <NEWLINE> 172 : 6864016 , <NEWLINE> 173 : 6953457 , <NEWLINE> 174 : 7094451 , <NEWLINE> 175 : 7215016 , <NEWLINE> 176 : 7359936 , <NEWLINE> 177 : 7475145 , <NEWLINE> 178 : 7593865 , <NEWLINE> 179 : 7689630 , <NEWLINE> 180 : 7886244 , <NEWLINE> 181 : 7984165 , <NEWLINE> 182 : 8130747 , <NEWLINE> 183 : 8253888 , <NEWLINE> 184 : 8403448 , <NEWLINE> 185 : 8523897 , <NEWLINE> 186 : 8684853 , <NEWLINE> 187 : 8802826 , <NEWLINE> 188 : 8949612 , <NEWLINE> 189 : 9105537 , <NEWLINE> 190 : 9267595 , <NEWLINE> 191 : 9376656 , <NEWLINE> 192 : 9574704 , <NEWLINE> 193 : 9686065 , <NEWLINE> 194 : 9827097 , <NEWLINE> 195 : 9997134 , <NEWLINE> 196 : 10174780 , <NEWLINE> 197 : 10290813 , <NEWLINE> 198 : 10493367 , <NEWLINE> 199 : 10611772 , <NEWLINE> 200 : 10813692 <NEWLINE> } <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> print ( a [ k ] ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N != 0 : <NEWLINE> <INDENT> p = input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> p [ i ] = int ( p [ i ] ) <NEWLINE> <NL> <DEDENT> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 2 * N ) : <NEWLINE> <INDENT> if not ( X - i ) in p : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> break <NEWLINE> <DEDENT> elif not ( X + i ) in p : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> <NL> conf_max = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> conf_max += A [ i // 2 ] <NEWLINE> <NL> <DEDENT> print ( conf_max ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> def ii ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def mi ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def li2 ( N ) : return [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> def dp2 ( ini , i , j ) : return [ [ ini ] * i for i2 in range ( j ) ] <NEWLINE> import bisect <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> from itertools import accumulate <COMMENT> <NEWLINE> <NL> N , M , lim = mi ( ) <NEWLINE> A = li ( ) <NEWLINE> B = li ( ) <NEWLINE> <NL> A = [ 0 ] + list ( accumulate ( A ) ) <NEWLINE> B = [ 0 ] + list ( accumulate ( B ) ) <NEWLINE> ans = 0 <NEWLINE> <STRING> <NEWLINE> right = M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if A [ i ] > lim : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> if right < 0 or A [ i ] + B [ right ] <= lim : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> right -= 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = max ( ans , i + right ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import collections as c <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = c . Counter ( x ) <NEWLINE> s = [ ] <NEWLINE> for i in y . items ( ) : <NEWLINE> <INDENT> s . append ( [ i [ 1 ] , i [ 0 ] ] ) <NEWLINE> <DEDENT> s . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( s ) - k ) : <NEWLINE> <INDENT> ans += s [ i ] [ 0 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> s = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> a_list = [ 0 ] * ( 2000 + 1 ) <NEWLINE> a_list [ 0 ] = 1 <NEWLINE> a_list [ 1 ] = 0 <NEWLINE> a_list [ 2 ] = 0 <NEWLINE> a_list [ 3 ] = 1 <NEWLINE> for i in range ( 4 , s + 1 ) : <NEWLINE> <INDENT> a_list [ i ] = a_list [ i - 1 ] + a_list [ i - 3 ] <NEWLINE> a_list [ i ] %= mod <NEWLINE> <DEDENT> print ( a_list [ s ] ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> As = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> rireki = [ ] <NEWLINE> loop = <STRING> <NEWLINE> <NL> ind = 1 <NEWLINE> flags = [ 0 for _ in range ( N ) ] <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> if flags [ ind - 1 ] == 1 : <NEWLINE> <INDENT> loop = ind <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rireki . append ( ind ) <NEWLINE> flags [ ind - 1 ] = 1 <NEWLINE> ind = As [ ind - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> loop_c = len ( rireki ) - rireki . index ( loop ) <NEWLINE> if K <= len ( rireki ) - 1 : <NEWLINE> <INDENT> print ( rireki [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nokori = K - len ( rireki ) + 1 <NEWLINE> ans = nokori % loop_c <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( rireki [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( rireki [ rireki . index ( loop ) + ans - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( r | c ) == 0 : break <NEWLINE> <NL> num = [ 0 ] * c <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> instr = input ( ) <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> num [ j ] = num [ j ] * 2 + int ( instr [ 2 * j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> maxx = - 1 <NEWLINE> for i in range ( 1 << r ) : <NEWLINE> <INDENT> answer = 0 <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> oksenbei = bin ( num [ j ] ^ i ) . count ( <STRING> ) <NEWLINE> answer += oksenbei if oksenbei * 2 // r >= 1 else r - oksenbei <NEWLINE> <DEDENT> if maxx < answer : <NEWLINE> <INDENT> maxx = answer <NEWLINE> <NL> <DEDENT> <DEDENT> print ( maxx ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> cnt_dict = { } <NEWLINE> <NL> <NL> s = sum ( A ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for item in A : <NEWLINE> <INDENT> if item not in cnt_dict : <NEWLINE> <INDENT> cnt_dict [ item ] = 0 <NEWLINE> <DEDENT> cnt_dict [ item ] += 1 <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if X not in cnt_dict : <NEWLINE> <INDENT> cnt_dict [ X ] = 0 <NEWLINE> <DEDENT> if Y not in cnt_dict : <NEWLINE> <INDENT> cnt_dict [ Y ] = 0 <NEWLINE> <NL> <DEDENT> s -= cnt_dict [ X ] * X <NEWLINE> s += cnt_dict [ X ] * Y <NEWLINE> <NL> cnt_dict [ Y ] += cnt_dict [ X ] <NEWLINE> cnt_dict [ X ] = 0 <NEWLINE> <NL> <NL> print ( s ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <STRING> <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = sorted ( l ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
from itertools import count <NEWLINE> while 1 : <NEWLINE> <INDENT> a , p = map ( int , input ( ) . split ( ) ) <NEWLINE> if not a and not p : break <NEWLINE> a = str ( a ) . zfill ( p ) <NEWLINE> b = [ a ] <NEWLINE> f = lambda l : int ( <STRING> . join ( l ) ) <NEWLINE> i = 0 <NEWLINE> for j in count ( 1 ) : <NEWLINE> <INDENT> m = sorted ( a ) <NEWLINE> a = str ( f ( m [ : : - 1 ] ) - f ( m ) ) . zfill ( p ) <NEWLINE> if a in b : <NEWLINE> <INDENT> i = b . index ( a ) <NEWLINE> break <NEWLINE> <DEDENT> b . append ( a ) <NEWLINE> <DEDENT> print ( i , int ( a ) , j - i ) <NEWLINE> <NL> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> while y : <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ 0 ] * N <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> B [ i - 1 ] = B [ i - 1 ] + 1 <NEWLINE> <NL> <DEDENT> for j in B : <NEWLINE> <INDENT> print ( str ( j ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import sys <NEWLINE> limit = 10 ** 18 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > limit : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> from sys import stdin <NEWLINE> <NL> <NL> def generate_adj_table ( v_table ) : <NEWLINE> <INDENT> for each in v_table : <NEWLINE> <INDENT> start , end , weight = map ( int , each ) <NEWLINE> init_adj_table [ start ] [ end ] = weight <NEWLINE> <NL> <DEDENT> return init_adj_table <NEWLINE> <NL> <NL> <DEDENT> def floyd ( ) : <NEWLINE> <INDENT> for k in _range : <NEWLINE> <INDENT> for i in _range : <NEWLINE> <INDENT> for j in _range : <NEWLINE> <INDENT> adj_table [ i ] [ j ] = min ( adj_table [ i ] . get ( j , float ( <STRING> ) ) , <NEWLINE> <INDENT> adj_table [ i ] . get ( k , float ( <STRING> ) ) + adj_table [ k ] . get ( j , float ( <STRING> ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return adj_table <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> ans = floyd ( ) <NEWLINE> negative = False <NEWLINE> for m in range ( vertices ) : <NEWLINE> <INDENT> if ans [ m ] [ m ] < 0 : <NEWLINE> <INDENT> negative = True <NEWLINE> <NL> <DEDENT> <DEDENT> if negative : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in _range : <NEWLINE> <INDENT> print ( * ( str ( each [ - 1 ] ) . upper ( ) for each in sorted ( ans [ a ] . items ( ) ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = stdin . readlines ( ) <NEWLINE> vertices , edges = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> info_list = map ( lambda x : x . split ( ) , _input [ 1 : ] ) <NEWLINE> _range = range ( vertices ) <NEWLINE> <NL> init_adj_table = tuple ( { i : 0 } for i in range ( vertices ) ) <NEWLINE> adj_table = generate_adj_table ( info_list ) <NEWLINE> solve ( ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> list_a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> list_b = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> a_sum = [ list_a [ 0 ] ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a_sum . append ( list_a [ i ] + a_sum [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> b_sum = [ list_b [ 0 ] ] <NEWLINE> for i in range ( 1 , m ) : <NEWLINE> <INDENT> b_sum . append ( list_b [ i ] + b_sum [ i - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> if ( a_sum [ 0 ] > k ) and ( b_sum [ 0 ] > k ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> if b_sum [ j ] <= k : <NEWLINE> <INDENT> ans = max ( ans , j + 1 ) <NEWLINE> <DEDENT> <DEDENT> j = m - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a_sum [ i ] <= k : <NEWLINE> <INDENT> ans = max ( ans , i + 1 ) <NEWLINE> while a_sum [ i ] + b_sum [ j ] > k and j > 0 : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> if a_sum [ i ] + b_sum [ j ] <= k : <NEWLINE> <INDENT> ans = max ( ans , i + j + 2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = 1 <NEWLINE> ans = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> s *= i <NEWLINE> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> k = 1 <NEWLINE> while s % i == 0 : <NEWLINE> <INDENT> s = s // i <NEWLINE> k += 1 <NEWLINE> <DEDENT> ans *= k <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 1000000007 <NEWLINE> <NL> S = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( ( S [ - 1 ] + A [ i ] ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum = ( S [ N ] - S [ i + 1 ] ) % mod <NEWLINE> ans += ( A [ i ] * sum ) <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> x = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> x = x + ( N - 1 ) // i <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n_list = [ <STRING> ] * n <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h_list [ b - 1 ] >= h_list [ a - 1 ] : <NEWLINE> <INDENT> n_list [ a - 1 ] = <STRING> <NEWLINE> <DEDENT> if h_list [ a - 1 ] >= h_list [ b - 1 ] : <NEWLINE> <INDENT> n_list [ b - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if n_list [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> N = ( int ) ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j = j - 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> <DEDENT> <DEDENT>
l = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( nums [ - 1 ] , end = <STRING> ) <NEWLINE> for i in range ( l - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( nums [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if ( A [ i - K ] < A [ i ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> buf2_min = 0 <NEWLINE> buf2_max = 0 <NEWLINE> buf_max = 0 <NEWLINE> buf_min = 0 <NEWLINE> <NL> for j in range ( k ) : <NEWLINE> <INDENT> buf2_max += n - j <NEWLINE> buf2_min += j <NEWLINE> <NL> <DEDENT> buf_max = n - k + 1 <NEWLINE> buf_min = k - 1 <NEWLINE> <NL> for i in range ( n - k + 2 ) : <NEWLINE> <INDENT> cnt += buf2_max - buf2_min + 1 <NEWLINE> buf_max -= 1 <NEWLINE> buf_min += 1 <NEWLINE> buf2_max += buf_max <NEWLINE> buf2_min += buf_min <NEWLINE> <DEDENT> cnt = cnt % ( 10 ** 9 + 7 ) <NEWLINE> <NL> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import log2 <NEWLINE> <NL> <NL> def build ( ) : <NEWLINE> <INDENT> dfs ( ) <NEWLINE> pk0 = parent [ 0 ] <NEWLINE> for k in range ( 1 , logn ) : <NEWLINE> <INDENT> pk1 = parent [ k ] <NEWLINE> for v in range ( n ) : <NEWLINE> <INDENT> pkv = pk0 [ v ] <NEWLINE> pk1 [ v ] = - 1 if pkv < 0 else pk0 [ pkv ] <NEWLINE> <DEDENT> pk0 = pk1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def dfs ( ) : <NEWLINE> <INDENT> stack = [ ( 0 , - 1 , 0 ) ] <NEWLINE> while stack : <NEWLINE> <INDENT> v , p , d = stack . pop ( ) <NEWLINE> parent [ 0 ] [ v ] = p <NEWLINE> depth [ v ] = d <NEWLINE> stack . extend ( ( child , v , d + 1 ) for child in tree [ v ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def get ( u , v ) : <NEWLINE> <INDENT> du , dv = depth [ u ] , depth [ v ] <NEWLINE> if du > dv : <NEWLINE> <INDENT> u , v = v , u <NEWLINE> du , dv = dv , du <NEWLINE> <DEDENT> for k in range ( logn ) : <NEWLINE> <INDENT> if ( dv - du ) >> k & 1 : <NEWLINE> <INDENT> v = parent [ k ] [ v ] <NEWLINE> <DEDENT> <DEDENT> if u == v : <NEWLINE> <INDENT> return u <NEWLINE> <DEDENT> for k in range ( logn - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> pk = parent [ k ] <NEWLINE> if pk [ u ] != pk [ v ] : <NEWLINE> <INDENT> u , v = pk [ u ] , pk [ v ] <NEWLINE> <DEDENT> <DEDENT> return parent [ 0 ] [ u ] <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> tree = [ set ( map ( int , input ( ) . split ( ) [ 1 : ] ) ) for _ in range ( n ) ] <NEWLINE> <NL> logn = int ( log2 ( n ) ) + 1 <NEWLINE> parent = [ [ 0 ] * n for _ in range ( logn ) ] <NEWLINE> depth = [ 0 ] * n <NEWLINE> build ( ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> print ( get ( * map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> anslist = set ( [ ] ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Amax = max ( A ) <NEWLINE> for i in A : <NEWLINE> <INDENT> j = i * 2 <NEWLINE> while j <= Amax : <NEWLINE> <INDENT> anslist . add ( j ) <NEWLINE> j += i <NEWLINE> <NL> <DEDENT> <DEDENT> anslist = list ( anslist ) <NEWLINE> anslist . extend ( A ) <NEWLINE> anslist = Counter ( anslist ) <NEWLINE> <NL> A = Counter ( A ) <NEWLINE> cnt = 0 <NEWLINE> for k , v in A . items ( ) : <NEWLINE> <INDENT> if v != 1 : <NEWLINE> <INDENT> del anslist [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = Counter ( anslist . values ( ) ) <NEWLINE> print ( cnt - ans [ 2 ] ) <NEWLINE>
a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a . append ( n ) <NEWLINE> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> print ( <STRING> , str ( i + 1 ) + <STRING> , a [ i ] ) <NEWLINE> <DEDENT>
from heapq import * <NEWLINE> i = input <NEWLINE> for s in [ 0 ] * int ( i ( ) ) : <NEWLINE> <INDENT> n , x , * y = int ( i ( ) ) , [ ] <NEWLINE> for _ in <STRING> * n : k , l , r = t = [ * map ( int , i ( ) . split ( ) ) ] ; x += [ t ] * ( l > r ) ; y += [ [ n - k , r , l ] ] * ( l <= r ) <NEWLINE> for x in x , y : <NEWLINE> <INDENT> x . sort ( ) ; n , * h = len ( x ) , <NEWLINE> while h or x : <NEWLINE> <INDENT> while [ [ n ] ] < x [ - 1 : ] : k , l , r = x . pop ( ) ; heappush ( h , ( r - l , l , r ) ) <NEWLINE> if h : s += heappop ( h ) [ ~ ( n > 0 ) ] <NEWLINE> n -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> tmp1 = ( n // ( a + b ) ) * a <NEWLINE> if tmp1 == 0 : <NEWLINE> <INDENT> tmp2 = min ( n , a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp2 = n % ( a + b ) <NEWLINE> tmp2 = min ( a , tmp2 ) <NEWLINE> <DEDENT> print ( tmp1 + tmp2 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for k in range ( N + 1 ) : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a [ k - 1 ] % 2 != 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b , c , x = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( a + 1 ) : <NEWLINE> <INDENT> for j in range ( b + 1 ) : <NEWLINE> <INDENT> for k in range ( c + 1 ) : <NEWLINE> <INDENT> if 500 * i + 100 * j + 50 * k == x : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 0 <NEWLINE> ps = list ( itertools . accumulate ( a_list ) ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> sum += a_list [ i ] * ( ps [ n - 1 ] - ps [ i ] ) <NEWLINE> <NL> <DEDENT> s = sum % ( 10 ** 9 + 7 ) <NEWLINE> print ( s ) <NEWLINE>
<COMMENT> <NL> from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> A = deque ( A ) <NEWLINE> while len ( A ) > 1 : <NEWLINE> <INDENT> s = [ ] <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> div = A [ - 1 ] % A [ 0 ] <NEWLINE> A . pop ( ) <NEWLINE> if div != 0 : <NEWLINE> <INDENT> s . append ( div ) <NEWLINE> <DEDENT> <DEDENT> s . append ( A [ 0 ] ) <NEWLINE> s . sort ( ) <NEWLINE> A = deque ( s ) <NEWLINE> <DEDENT> print ( * A ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for k in range ( N ) : <NEWLINE> <INDENT> if k == N - 1 : <NEWLINE> <INDENT> print ( str ( A [ k ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( A [ k ] ) + <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> if k == N - 1 : <NEWLINE> <INDENT> print ( str ( A [ k ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( A [ k ] ) + <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . reverse ( ) <NEWLINE> print ( <STRING> . join ( list ( map ( lambda x : str ( x ) , l ) ) ) ) <NEWLINE>
import random <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <NL> def atoi ( s ) : <NEWLINE> <INDENT> return ord ( s ) - ord ( <STRING> ) + 1 <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> mod = ( 1 << 61 ) - 1 <NEWLINE> b = random . randint ( 10000 , mod - 1 ) <NEWLINE> <NL> <NL> l = 0 <NEWLINE> r = ( N + 1 ) // 2 + 1 <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> d = ( r + l ) // 2 <NEWLINE> memo = defaultdict ( int ) <NEWLINE> isok = False <NEWLINE> h = 0 <NEWLINE> t = pow ( b , d , mod ) <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> h = ( h * b + atoi ( S [ i ] ) ) % mod <NEWLINE> <DEDENT> memo [ h ] = 1 <NEWLINE> for i in range ( 1 , N - d + 1 ) : <NEWLINE> <INDENT> h = ( h * b + atoi ( S [ i + d - 1 ] ) - t * atoi ( S [ i - 1 ] ) ) % mod <NEWLINE> if not memo [ h ] : <NEWLINE> <INDENT> memo [ h ] = i + 1 <NEWLINE> <DEDENT> elif memo [ h ] and i - memo [ h ] + 1 >= d : <NEWLINE> <INDENT> isok = True <NEWLINE> <DEDENT> <DEDENT> if isok : <NEWLINE> <INDENT> l = d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = d <NEWLINE> <NL> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
<COMMENT> <NL> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> c = 0 <NEWLINE> p = <STRING> <NEWLINE> count = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == p : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = count - c <NEWLINE> count = 1 <NEWLINE> <DEDENT> p = i <NEWLINE> <DEDENT> c = count - c <NEWLINE> print ( n - abs ( c ) ) <NEWLINE>
import numpy <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> p = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> p = [ 0 ] + p + [ 0 ] <NEWLINE> <NL> S = numpy . sum ( numpy . abs ( numpy . diff ( p ) ) ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( S - numpy . abs ( p [ i ] - p [ i - 1 ] ) - numpy . abs ( p [ i + 1 ] - p [ i ] ) + numpy . abs ( p [ i + 1 ] - p [ i - 1 ] ) ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> I = J = 0 <NEWLINE> for i in range ( - 300 , 300 ) : <NEWLINE> <INDENT> for j in range ( - 300 , 300 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> I = i <NEWLINE> J = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( I , J ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> plus = [ ] <NEWLINE> minus = [ ] <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i >= 0 : <NEWLINE> <INDENT> plus . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> plus . sort ( key = lambda x : - x ) <NEWLINE> minus . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> numplus = k <NEWLINE> numminus = 0 <NEWLINE> <NL> <STRING> <NEWLINE> while numplus > len ( plus ) : <NEWLINE> <INDENT> numplus -= 2 <NEWLINE> numminus += 2 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> while numplus - 2 >= 0 and numminus + 1 < len ( minus ) : <NEWLINE> <INDENT> if plus [ numplus - 1 ] * plus [ numplus - 2 ] <= minus [ numminus ] * minus [ numminus + 1 ] : <NEWLINE> <INDENT> numplus -= 2 <NEWLINE> numminus += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> <NL> if numplus >= 0 and numminus >= 0 and numminus <= len ( minus ) : <NEWLINE> <INDENT> for i in range ( numplus ) : <NEWLINE> <INDENT> ans = ans * plus [ i ] % mod <NEWLINE> <DEDENT> for i in range ( numminus ) : <NEWLINE> <INDENT> ans = ans * minus [ i ] % mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> tmp = sorted ( a , key = lambda x : - x ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans = ans * tmp [ i ] % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def B ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> ret = 1 <NEWLINE> for d in a : <NEWLINE> <INDENT> ret *= d <NEWLINE> if ret > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <DEDENT> B ( ) <NEWLINE>
<COMMENT> <NL> <NL> from collections import deque <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> L = deque ( ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> command = input ( ) . split ( <STRING> ) <NEWLINE> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> L . appendleft ( command [ 1 ] ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> L . remove ( command [ 1 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> L . popleft ( ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> L . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( L ) ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> heavy = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> heavy [ i ] += 1 <NEWLINE> <DEDENT> s = sum ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> be , af = map ( int , input ( ) . split ( ) ) <NEWLINE> s -= be * heavy [ be ] <NEWLINE> s += af * heavy [ be ] <NEWLINE> heavy [ af ] += heavy [ be ] <NEWLINE> heavy [ be ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
from collections import defaultdict , deque <NEWLINE> import sys , heapq , bisect , math , itertools , string , queue , datetime <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> eps = 10 ** - 7 <NEWLINE> def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def inpl_s ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> <NL> S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ i ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( S [ K - 1 ] ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> ref , count = { } , 0 <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if i - a in ref : <NEWLINE> <INDENT> count += ref [ i - a ] <NEWLINE> <DEDENT> if i + a in ref : <NEWLINE> <INDENT> ref [ i + a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ref [ i + a ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import copy <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xx = sorted ( x ) <NEWLINE> <NL> l = xx [ ( n - 1 ) // 2 ] <NEWLINE> r = xx [ n // 2 ] <NEWLINE> mid = ( l + r ) / 2 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] >= mid : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> <NL> s = list ( stdin . readline ( ) ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] . islower ( ) : <NEWLINE> <INDENT> s [ i ] = s [ i ] . upper ( ) <NEWLINE> <DEDENT> elif s [ i ] . isupper ( ) : <NEWLINE> <INDENT> s [ i ] = s [ i ] . lower ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * s , sep = <STRING> , end = <STRING> ) <NEWLINE>
class BinaryTree : <NEWLINE> <INDENT> class Node : <NEWLINE> <INDENT> def __init__ ( self , nid , left , right ) : <NEWLINE> <INDENT> self . id = nid <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> <DEDENT> def has_left ( self ) : <NEWLINE> <INDENT> return self . left is not None <NEWLINE> <NL> <DEDENT> def has_right ( self ) : <NEWLINE> <INDENT> return self . right is not None <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return str ( self . id ) <NEWLINE> <NL> <DEDENT> <DEDENT> @ classmethod <NEWLINE> def create ( cls , ids ) : <NEWLINE> <INDENT> nodes = [ None ] * len ( ids ) <NEWLINE> <NL> def _create ( nid ) : <NEWLINE> <INDENT> if nid in nodes : <NEWLINE> <INDENT> return nodes [ nid ] <NEWLINE> <DEDENT> if nid == - 1 : <NEWLINE> <INDENT> return None <NEWLINE> <NL> <DEDENT> lid , rid = ids [ nid ] <NEWLINE> if lid == - 1 and rid == - 1 : <NEWLINE> <INDENT> right = None <NEWLINE> left = None <NEWLINE> <DEDENT> elif lid == - 1 : <NEWLINE> <INDENT> right = _create ( rid ) <NEWLINE> left = None <NEWLINE> <DEDENT> elif lid == - 1 : <NEWLINE> <INDENT> right = None <NEWLINE> left = _create ( lid ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = _create ( rid ) <NEWLINE> left = _create ( lid ) <NEWLINE> <DEDENT> nodes [ nid ] = cls . Node ( nid , left , right ) <NEWLINE> return nodes [ nid ] <NEWLINE> <NL> <DEDENT> def _root ( nodeids ) : <NEWLINE> <INDENT> for nid in range ( len ( nodeids ) ) : <NEWLINE> <INDENT> if all ( [ lid != nid and rid != nid for lid , rid in nodeids ] ) : <NEWLINE> <INDENT> return nid <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> root = _create ( _root ( ids ) ) <NEWLINE> return cls ( root ) <NEWLINE> <NL> <DEDENT> def __init__ ( self , root ) : <NEWLINE> <INDENT> self . root = root <NEWLINE> <NL> <DEDENT> def preorder ( self ) : <NEWLINE> <INDENT> def _preorder ( node ) : <NEWLINE> <INDENT> yield node <NEWLINE> if node . has_left ( ) : <NEWLINE> <INDENT> yield from _preorder ( node . left ) <NEWLINE> <DEDENT> if node . has_right ( ) : <NEWLINE> <INDENT> yield from _preorder ( node . right ) <NEWLINE> <DEDENT> <DEDENT> yield from _preorder ( self . root ) <NEWLINE> <NL> <DEDENT> def inorder ( self ) : <NEWLINE> <INDENT> def _inorder ( node ) : <NEWLINE> <INDENT> if node . has_left ( ) : <NEWLINE> <INDENT> yield from _inorder ( node . left ) <NEWLINE> <DEDENT> yield node <NEWLINE> if node . has_right ( ) : <NEWLINE> <INDENT> yield from _inorder ( node . right ) <NEWLINE> <DEDENT> <DEDENT> yield from _inorder ( self . root ) <NEWLINE> <NL> <DEDENT> def postorder ( self ) : <NEWLINE> <INDENT> def _postorder ( node ) : <NEWLINE> <INDENT> if node . has_left ( ) : <NEWLINE> <INDENT> yield from _postorder ( node . left ) <NEWLINE> <DEDENT> if node . has_right ( ) : <NEWLINE> <INDENT> yield from _postorder ( node . right ) <NEWLINE> <DEDENT> yield node <NEWLINE> <DEDENT> yield from _postorder ( self . root ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> nodeids = [ None ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> nid , lid , rid = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> nodeids [ nid ] = [ lid , rid ] <NEWLINE> <NL> <DEDENT> tree = BinaryTree . create ( nodeids ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> for node in tree . preorder ( ) : <NEWLINE> <INDENT> print ( <STRING> . format ( node ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> for node in tree . inorder ( ) : <NEWLINE> <INDENT> print ( <STRING> . format ( node ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> for node in tree . postorder ( ) : <NEWLINE> <INDENT> print ( <STRING> . format ( node ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> lim = pow ( 10 , 18 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > lim : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = Counter ( l ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT>
S = input ( ) [ : : - 1 ] <NEWLINE> MOD = 2019 <NEWLINE> <NL> r = 0 <NEWLINE> C = [ 0 for _ in range ( MOD ) ] <NEWLINE> C [ 0 ] = 1 <NEWLINE> <NL> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> r += int ( s ) * pow ( 10 , i , MOD ) <NEWLINE> r %= MOD <NEWLINE> C [ r ] += 1 <NEWLINE> <NL> <DEDENT> a = 0 <NEWLINE> for c in C : <NEWLINE> <INDENT> a += c * ( c - 1 ) / 2 <NEWLINE> <NL> <DEDENT> print ( int ( a ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = ( 10 ** 5 + 1 ) * [ 0 ] <NEWLINE> ans = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a <= 10 ** 5 : <NEWLINE> <INDENT> B [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for n in range ( 10 ** 5 ) : <NEWLINE> <INDENT> if B [ n ] < n : <NEWLINE> <INDENT> ans += B [ n ] <NEWLINE> <DEDENT> elif n < B [ n ] : <NEWLINE> <INDENT> ans += B [ n ] - n <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ 1 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] > h [ b - 1 ] : <NEWLINE> <INDENT> cnt [ b - 1 ] = 0 <NEWLINE> <DEDENT> elif h [ a - 1 ] == h [ b - 1 ] : <NEWLINE> <INDENT> cnt [ a - 1 ] = 0 <NEWLINE> cnt [ b - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ a - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( cnt ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if pow ( 2 , x - 1 , x ) == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for b in B : <NEWLINE> <INDENT> if b <= A [ 0 ] or b >= C [ N - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> l , r = - 1 , N <NEWLINE> while abs ( l - r ) > 1 : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> if A [ mid ] < b : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = mid <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> l2 , r2 = - 1 , N <NEWLINE> while abs ( l2 - r2 ) > 1 : <NEWLINE> <INDENT> mid = ( l2 + r2 ) // 2 <NEWLINE> if C [ mid ] > b : <NEWLINE> <INDENT> r2 = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l2 = mid <NEWLINE> <DEDENT> <DEDENT> ans += ( l + 1 ) * ( N - r2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> from collections import Counter , deque <NEWLINE> from itertools import combinations , permutations , accumulate , groupby , product <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> visited = [ 0 ] * ( n + 1 ) <NEWLINE> step = 0 <NEWLINE> i = 1 <NEWLINE> <NL> while k : <NEWLINE> <INDENT> i = a [ i ] <NEWLINE> step += 1 <NEWLINE> k -= 1 <NEWLINE> if visited [ i ] != 0 : <NEWLINE> <INDENT> k = k % ( step - visited [ i ] ) <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> i = a [ i ] <NEWLINE> <DEDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> visited [ i ] = step <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> n = int ( stdin . readline ( ) . strip ( ) ) <NEWLINE> a = list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> a . sort ( ) <NEWLINE> <NL> dp = [ True ] * ( a [ - 1 ] + 1 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <NL> <INDENT> if a [ i ] == a [ i - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if dp [ a [ i ] ] : <NEWLINE> <NL> <INDENT> for j in range ( 2 * a [ i ] , a [ - 1 ] + 1 , a [ i ] ) : <NEWLINE> <INDENT> dp [ j ] = False <NEWLINE> <NL> <DEDENT> if i == n - 1 or a [ i ] != a [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> x_popcnt = x . count ( <STRING> ) <NEWLINE> one_popcnt = x_popcnt - 1 <NEWLINE> zero_popcnt = x_popcnt + 1 <NEWLINE> <NL> one_mod = 0 <NEWLINE> zero_mod = 0 <NEWLINE> for b in x : <NEWLINE> <INDENT> if one_popcnt != 0 : <NEWLINE> <INDENT> one_mod = ( one_mod * 2 + int ( b ) ) % one_popcnt <NEWLINE> <DEDENT> zero_mod = ( zero_mod * 2 + int ( b ) ) % zero_popcnt <NEWLINE> <NL> <DEDENT> f = [ 0 ] * 220000 <NEWLINE> popcnt = [ 0 ] * 220000 <NEWLINE> for i in range ( 1 , 220000 ) : <NEWLINE> <INDENT> popcnt [ i ] = popcnt [ i // 2 ] + i % 2 <NEWLINE> f [ i ] = f [ i % popcnt [ i ] ] + 1 <NEWLINE> <NL> <DEDENT> onepow2 = [ 1 ] * 220000 <NEWLINE> if one_popcnt != 0 : <NEWLINE> <INDENT> for i in range ( 1 , 220000 ) : <NEWLINE> <INDENT> onepow2 [ i ] = 2 * onepow2 [ i - 1 ] % one_popcnt <NEWLINE> <DEDENT> <DEDENT> zeropow2 = [ 1 ] * 220000 <NEWLINE> for i in range ( 1 , 220000 ) : <NEWLINE> <INDENT> zeropow2 [ i ] = 2 * zeropow2 [ i - 1 ] % zero_popcnt <NEWLINE> <DEDENT> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if x [ n - 1 - i ] == <STRING> : <NEWLINE> <INDENT> if one_popcnt != 0 : <NEWLINE> <INDENT> nxt = one_mod <NEWLINE> nxt -= onepow2 [ i ] <NEWLINE> nxt %= one_popcnt <NEWLINE> print ( f [ nxt ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> if x [ n - 1 - i ] == <STRING> : <NEWLINE> <INDENT> nxt = zero_mod <NEWLINE> nxt += zeropow2 [ i ] <NEWLINE> nxt %= zero_popcnt <NEWLINE> print ( f [ nxt ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for x in range ( N ) : <NEWLINE> <INDENT> ans *= A [ x ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class Node : <NEWLINE> <INDENT> def __init__ ( self , parent = - 1 , left = - 1 , right = - 1 ) : <NEWLINE> <INDENT> self . parent = parent <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> binary_tree = [ Node ( ) for i in range ( n ) ] <NEWLINE> pre_lst , in_lst , post_lst = [ ] , [ ] , [ ] <NEWLINE> <NL> <NL> def pre_order ( u ) : <NEWLINE> <INDENT> if u == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> pre_lst . append ( u ) <NEWLINE> pre_order ( binary_tree [ u ] . left ) <NEWLINE> pre_order ( binary_tree [ u ] . right ) <NEWLINE> <NL> <NL> <DEDENT> def in_order ( u ) : <NEWLINE> <INDENT> if u == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> in_order ( binary_tree [ u ] . left ) <NEWLINE> in_lst . append ( u ) <NEWLINE> in_order ( binary_tree [ u ] . right ) <NEWLINE> <NL> <NL> <DEDENT> def post_order ( u ) : <NEWLINE> <INDENT> if u == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> post_order ( binary_tree [ u ] . left ) <NEWLINE> post_order ( binary_tree [ u ] . right ) <NEWLINE> post_lst . append ( u ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> idx , left , right = map ( int , input ( ) . split ( ) ) <NEWLINE> binary_tree [ idx ] . left = left <NEWLINE> binary_tree [ idx ] . right = right <NEWLINE> if left != - 1 : <NEWLINE> <INDENT> binary_tree [ left ] . parent = idx <NEWLINE> <DEDENT> if right != - 1 : <NEWLINE> <INDENT> binary_tree [ right ] . parent = idx <NEWLINE> <NL> <DEDENT> <DEDENT> root_idx = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if binary_tree [ i ] . parent == - 1 : <NEWLINE> <INDENT> root_idx = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> pre_order ( root_idx ) <NEWLINE> in_order ( root_idx ) <NEWLINE> post_order ( root_idx ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> print ( <STRING> , <STRING> . join ( [ str ( i ) for i in pre_lst ] ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> , <STRING> . join ( [ str ( i ) for i in in_lst ] ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> , <STRING> . join ( [ str ( i ) for i in post_lst ] ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
from collections import deque <NEWLINE> <NL> def isPa ( w , k , p ) : <NEWLINE> <INDENT> tr = 0 <NEWLINE> c = 0 <NEWLINE> d = deque ( w ) <NEWLINE> while ( d ) : <NEWLINE> <INDENT> tmp = d . popleft ( ) <NEWLINE> if ( tmp > p ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> if ( tr + tmp > p ) : <NEWLINE> <INDENT> tr = tmp <NEWLINE> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tr += tmp <NEWLINE> <DEDENT> if c + 1 > k : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def MaxInP ( w , k , p ) : <NEWLINE> <INDENT> maxinp = 0 <NEWLINE> tmp = 0 <NEWLINE> d = deque ( w ) <NEWLINE> while ( d ) : <NEWLINE> <INDENT> tmp += d . popleft ( ) ; <NEWLINE> if ( tmp > p ) : <NEWLINE> <INDENT> if ( tmp > maxinp ) : <NEWLINE> <INDENT> maxinp = tmp <NEWLINE> <DEDENT> tmp = 0 <NEWLINE> <DEDENT> <DEDENT> return maxinp <NEWLINE> <NL> <DEDENT> n , k = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> w = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> w . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> mean = int ( sum ( w ) / k ) <NEWLINE> maxinp = MaxInP ( w , k , mean ) <NEWLINE> <NL> if k == 1 : <NEWLINE> <INDENT> print ( mean ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minP = mean <NEWLINE> maxP = maxinp <NEWLINE> while ( True ) : <NEWLINE> <INDENT> m = int ( ( minP + maxP ) / 2 ) <NEWLINE> if ( isPa ( w , k , m ) ) : <NEWLINE> <INDENT> maxP = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minP = m <NEWLINE> <DEDENT> if ( minP + 1 == maxP or minP == maxP ) : <NEWLINE> <INDENT> print ( maxP ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ss = { } <NEWLINE> num = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s not in ss : <NEWLINE> <INDENT> ss [ s ] = <STRING> <NEWLINE> num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> list = [ 0 ] * ( 10 ** 5 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> list [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> wa = sum ( a ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> wa += ( bc [ i ] [ 1 ] - bc [ i ] [ 0 ] ) * list [ bc [ i ] [ 0 ] - 1 ] <NEWLINE> print ( wa ) <NEWLINE> list [ bc [ i ] [ 1 ] - 1 ] += list [ bc [ i ] [ 0 ] - 1 ] <NEWLINE> list [ bc [ i ] [ 0 ] - 1 ] = 0 <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> H , W = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if ( H , W ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif H == 0 or W == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> G = [ 797161 , 265720 , 88573 , 29524 , 9841 , 3280 , 1093 , 364 , 121 , 40 , 13 , 4 , 1 ] <NEWLINE> G = [ v for v in G if v <= n ] <NEWLINE> m = len ( G ) <NEWLINE> def insertionSort ( A , n , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <DEDENT> <DEDENT> for g in G : <NEWLINE> <INDENT> insertionSort ( A , n , g ) <NEWLINE> <DEDENT> print ( m ) <NEWLINE> print ( * G ) <NEWLINE> print ( cnt ) <NEWLINE> print ( * A , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( input ( ) ) + int ( input ( ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . reverse ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i != n - 1 : <NEWLINE> <INDENT> print ( a [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> cy , cx = map ( int , input ( ) . split ( ) ) <NEWLINE> dy , dx = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> M = [ <STRING> + input ( ) + <STRING> for x in range ( h ) ] <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> M . insert ( 0 , <STRING> * ( w + 4 ) ) <NEWLINE> M . append ( <STRING> * ( w + 4 ) ) <NEWLINE> <NL> <DEDENT> C = [ [ - 1 if M [ j ] [ i ] == <STRING> else - 2 for i in range ( w + 4 ) ] for j in range ( h + 4 ) ] <NEWLINE> C [ - ~ cy ] [ - ~ cx ] = 0 <NEWLINE> QA , QB = deque ( ) , deque ( ) <NEWLINE> QA . append ( ( - ~ cy , - ~ cx , 0 ) ) <NEWLINE> W = [ [ i , j ] for i in range ( - 2 , 3 ) for j in range ( - 2 , 3 ) if abs ( i ) + abs ( j ) > 1 ] <NEWLINE> <NL> while QA : <NEWLINE> <INDENT> h , w , c = QA . popleft ( ) <NEWLINE> QB . append ( ( h , w , c ) ) <NEWLINE> <NL> for i , j in [ [ 1 , 0 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] : <NEWLINE> <INDENT> dh , dw = h + i , w + j <NEWLINE> if C [ dh ] [ dw ] == - 1 : <NEWLINE> <INDENT> C [ dh ] [ dw ] = c <NEWLINE> QA . appendleft ( ( dh , dw , c ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if QA : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> while QB : <NEWLINE> <INDENT> h , w , c = QB . popleft ( ) <NEWLINE> for i , j in W : <NEWLINE> <INDENT> dh , dw = h + i , w + j <NEWLINE> if C [ dh ] [ dw ] == - 1 : <NEWLINE> <INDENT> C [ dh ] [ dw ] = - ~ c <NEWLINE> QA . append ( ( dh , dw , - ~ c ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( C [ - ~ dy ] [ - ~ dx ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , T = map ( int , ( list ( input ( ) . split ( ) ) ) ) <NEWLINE> cost = 1001 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> c , t = map ( int , ( list ( input ( ) . split ( ) ) ) ) <NEWLINE> if t <= T : <NEWLINE> <INDENT> cost = min ( cost , c ) <NEWLINE> <DEDENT> <DEDENT> if cost == 1001 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cost ) <NEWLINE> <NL> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = [ i - 1 for i in range ( 103 ) ] <NEWLINE> flag = True <NEWLINE> if n == 0 : <NEWLINE> <INDENT> flag = False <NEWLINE> print ( x ) <NEWLINE> <NL> <DEDENT> if flag : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in p : <NEWLINE> <INDENT> lis . remove ( i ) <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( len ( lis ) ) : <NEWLINE> <INDENT> if lis [ i ] > x : <NEWLINE> <INDENT> index = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if abs ( x - lis [ index ] ) < abs ( x - lis [ index - 1 ] ) : <NEWLINE> <INDENT> print ( lis [ index ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( lis [ index - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> adj_list = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> u , v = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> adj_list [ u ] . append ( v ) <NEWLINE> adj_list [ v ] . append ( u ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> colors = [ ] <NEWLINE> <NL> def adj_dfs ( r , c ) : <NEWLINE> <INDENT> global colors <NEWLINE> stack = deque ( [ ] ) <NEWLINE> stack . append ( r ) <NEWLINE> colors [ r ] = c <NEWLINE> while len ( stack ) != 0 : <NEWLINE> <INDENT> u = stack . pop ( ) <NEWLINE> for v in adj_list [ u ] : <NEWLINE> <INDENT> if colors [ v ] == None : <NEWLINE> <INDENT> colors [ v ] = c <NEWLINE> stack . append ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def assign_color ( ) : <NEWLINE> <INDENT> global colors <NEWLINE> id = 1 <NEWLINE> colors = [ None for i in range ( n ) ] <NEWLINE> for u in range ( n ) : <NEWLINE> <INDENT> if colors [ u ] == None : <NEWLINE> <INDENT> id += 1 <NEWLINE> adj_dfs ( u , id ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> assign_color ( ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> s , e = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if colors [ s ] == colors [ e ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in T : <NEWLINE> <INDENT> a = 0 <NEWLINE> b = n - 1 <NEWLINE> while b >= a : <NEWLINE> <INDENT> mid = ( a + b ) // 2 <NEWLINE> if S [ mid ] == i : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> elif S [ mid ] > i : <NEWLINE> <INDENT> b = mid - 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = mid + 1 <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( str ( cnt ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k < n : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> data = input ( ) <NEWLINE> num = int ( data ) <NEWLINE> o = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> list = [ ] <NEWLINE> for i in o : <NEWLINE> <INDENT> list . append ( int ( i ) ) <NEWLINE> <DEDENT> p = input ( ) <NEWLINE> times = int ( p ) <NEWLINE> ans = sum ( list ) <NEWLINE> num_count = [ 0 for i in range ( 100001 ) ] <NEWLINE> for i in list : <NEWLINE> <INDENT> num_count [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( times ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a = num_count [ B ] <NEWLINE> num_count [ B ] = 0 <NEWLINE> num_count [ C ] += a <NEWLINE> ans += a * ( C - B ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i - k ] / a [ i ] < 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , M , K = input ( ) . split ( ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> B = input ( ) . split ( ) <NEWLINE> ta = 0 <NEWLINE> cnta = 0 <NEWLINE> while cnta < int ( N ) and ta + int ( A [ cnta ] ) <= int ( K ) : <NEWLINE> <INDENT> ta += int ( A [ cnta ] ) <NEWLINE> cnta += 1 <NEWLINE> <NL> <DEDENT> tb = 0 <NEWLINE> cntb = 0 <NEWLINE> while cntb < int ( M ) and ta + tb + int ( B [ cntb ] ) <= int ( K ) : <NEWLINE> <INDENT> tb += int ( B [ cntb ] ) <NEWLINE> cntb += 1 <NEWLINE> <NL> <DEDENT> ans = cnta + cntb <NEWLINE> <NL> while cnta - 1 >= 0 : <NEWLINE> <INDENT> ta -= int ( A [ cnta - 1 ] ) <NEWLINE> cnta -= 1 <NEWLINE> while cntb < int ( M ) and ta + tb + int ( B [ cntb ] ) <= int ( K ) : <NEWLINE> <INDENT> tb += int ( B [ cntb ] ) <NEWLINE> cntb += 1 <NEWLINE> <DEDENT> ans = max ( ans , cnta + cntb ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = ( n + 1 ) * ( n // 2 ) - n <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> ans += n // 2 + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> alpha = <STRING> <NEWLINE> <NL> new_S = list ( ) <NEWLINE> for word in S : <NEWLINE> <INDENT> num = alpha . index ( word ) + N <NEWLINE> if num > 25 : <NEWLINE> <INDENT> num -= 26 <NEWLINE> <DEDENT> new_S . append ( alpha [ num ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( new_S ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = pow ( 10 , N , mod ) + pow ( 8 , N , mod ) - pow ( 9 , N , mod ) - pow ( 9 , N , mod ) <NEWLINE> print ( ans % mod ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> s2 = s [ i : ] <NEWLINE> cnt = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s2 [ j ] == t [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> l . append ( cnt ) <NEWLINE> <DEDENT> print ( len ( t ) - max ( l ) ) <NEWLINE>
s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> front = [ ] <NEWLINE> rear = [ ] <NEWLINE> for qq in range ( q ) : <NEWLINE> <INDENT> l = list ( input ( ) . split ( ) ) <NEWLINE> if l [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( cnt + int ( l [ 1 ] ) ) % 2 == 1 : <NEWLINE> <INDENT> front . append ( l [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rear . append ( l [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> front = <STRING> . join ( front [ : : - 1 ] ) <NEWLINE> rear = <STRING> . join ( rear ) <NEWLINE> s = front + s + rear <NEWLINE> print ( s if cnt % 2 == 0 else s [ : : - 1 ] ) <NEWLINE>
import itertools <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> List = [ ] <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> List . append ( a ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for team in itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a = List [ i ] [ 0 ] <NEWLINE> b = List [ i ] [ 1 ] <NEWLINE> c = List [ i ] [ 2 ] <NEWLINE> d = List [ i ] [ 3 ] <NEWLINE> <NL> if team [ b - 1 ] - team [ a - 1 ] == c : <NEWLINE> <INDENT> cnt += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> e = math . ceil ( c / b ) <NEWLINE> f = math . ceil ( a / d ) <NEWLINE> if e > f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif e == f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , s = int ( input ( ) ) , int ( input ( ) ) <NEWLINE> <NL> f = lambda b , n : n if n < b else n % b + f ( b , n // b ) <NEWLINE> import math <NEWLINE> ans = math . inf <NEWLINE> if n == s : ans = n + 1 <NEWLINE> for b in range ( 2 , math . ceil ( math . sqrt ( n ) ) + 1 ) : <COMMENT> <NEWLINE> <INDENT> if f ( b , n ) == s : <NEWLINE> <INDENT> ans = b ; break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for p in range ( 1 , math . ceil ( math . sqrt ( n ) ) ) : <COMMENT> <NEWLINE> <INDENT> b = ( n - s ) / p + 1 <NEWLINE> if b > 1 and b == int ( b ) and f ( b , n ) == s : <NEWLINE> <INDENT> ans = min ( ans , int ( b ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans == math . inf : ans = - 1 <NEWLINE> print ( ans ) <NEWLINE>
N , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> P = [ 0 ] * ( N + 1 ) <COMMENT> <NEWLINE> ok = [ False ] * ( N + 1 ) <COMMENT> <NEWLINE> <NL> correct = 0 <COMMENT> <NEWLINE> penalty = 0 <COMMENT> <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> query = input ( ) . split ( ) <NEWLINE> p = int ( query [ 0 ] ) <NEWLINE> S = query [ 1 ] <NEWLINE> if ok [ p ] == False : <NEWLINE> <INDENT> if S == <STRING> : <NEWLINE> <INDENT> ok [ p ] = True <NEWLINE> correct += 1 <NEWLINE> penalty += P [ p ] <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> P [ p ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( correct , end = <STRING> ) <NEWLINE> print ( penalty ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , * ab = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> AB = [ ] <NEWLINE> for a , b in zip ( * [ iter ( ab ) ] * 2 ) : <NEWLINE> <INDENT> AB . append ( ( a , b ) ) <NEWLINE> <NL> <DEDENT> if N % 2 == 0 : <NEWLINE> <INDENT> AB . sort ( ) <NEWLINE> a1 , _ = AB [ N // 2 - 1 ] <NEWLINE> a2 , _ = AB [ N // 2 ] <NEWLINE> <NL> AB . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> _ , b1 = AB [ N // 2 - 1 ] <NEWLINE> _ , b2 = AB [ N // 2 ] <NEWLINE> <NL> ans = b1 + b2 - ( a1 + a2 ) + 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> AB . sort ( ) <NEWLINE> a , _ = AB [ N // 2 ] <NEWLINE> <NL> AB . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> _ , b = AB [ N // 2 ] <NEWLINE> <NL> ans = b - a + 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> mod = 7 <NEWLINE> cnt = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if mod % k == 0 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> mod = ( mod * 10 + 7 ) % k <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( - 1 ) <NEWLINE>
n = input ( ) <NEWLINE> l = [ int ( each ) for each in input ( ) . split ( ) ] <NEWLINE> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = 1 <NEWLINE> for each in l : <NEWLINE> <INDENT> result *= each <NEWLINE> if result > 1000000000000000000 : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nP = [ ] <NEWLINE> min = 10 ** 15 <NEWLINE> for i in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if i not in P : <NEWLINE> <INDENT> nP . append ( i ) <NEWLINE> <DEDENT> <DEDENT> anlist = [ ] <NEWLINE> for i in nP : <NEWLINE> <INDENT> if min > abs ( i - X ) : <NEWLINE> <INDENT> min = abs ( i - X ) <NEWLINE> anlist . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( anlist [ - 1 ] ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> import sys <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> import heapq <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from itertools import accumulate <NEWLINE> import copy <NEWLINE> <NL> <NL> def zz ( ) : <NEWLINE> <INDENT> return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def z ( ) : <NEWLINE> <INDENT> return int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def S ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) <NEWLINE> <NL> <NL> <DEDENT> def C ( line ) : <NEWLINE> <INDENT> return [ sys . stdin . readline ( ) [ : - 1 ] for _ in range ( line ) ] <NEWLINE> <NL> <NL> <DEDENT> N = z ( ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> for x in range ( 1 , 105 ) : <NEWLINE> <INDENT> for y in range ( 1 , 105 ) : <NEWLINE> <INDENT> for z in range ( 1 , 105 ) : <NEWLINE> <INDENT> if ( x ** 2 + y ** 2 + z ** 2 + x * y + y * z + x * z <= N ) : <NEWLINE> <INDENT> ans [ x ** 2 + y ** 2 + z ** 2 + x * y + y * z + x * z - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for i in range ( 10 ** 3 ) : <NEWLINE> <INDENT> for j in range ( 2 * 10 ** 3 ) : <NEWLINE> <INDENT> if ( i ) ** 5 - ( j - 10 ** 3 ) ** 5 == x : <NEWLINE> <INDENT> print ( i , j - 10 ** 3 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> C = Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> if len ( C ) == 1 and C [ 0 ] == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( C ) == 2 and N % 3 == 0 and C [ 0 ] == N // 3 and N - C [ 0 ] == 2 * N // 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( C ) == 3 and N % 3 == 0 : <NEWLINE> <INDENT> b = 0 <NEWLINE> for c in C . most_common ( ) : <NEWLINE> <INDENT> if c [ 1 ] != N // 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> b ^= c [ 0 ] <NEWLINE> <DEDENT> if b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> summ = sum ( lst ) <NEWLINE> summ_sq = summ ** 2 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += lst [ i ] ** 2 <NEWLINE> <NL> <DEDENT> res = ( summ_sq - ans ) // 2 <NEWLINE> print ( res % ( ( 10 ** 9 ) + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> R = [ ] <NEWLINE> G = [ ] <NEWLINE> B = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R . append ( i + 1 ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> G . append ( i + 1 ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> B . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> lenb = len ( B ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for r in R : <NEWLINE> <INDENT> for g in G : <NEWLINE> <INDENT> up = max ( r , g ) <NEWLINE> down = min ( r , g ) <NEWLINE> diff = up - down <NEWLINE> <NL> chk = 0 <NEWLINE> if up + diff <= N : <NEWLINE> <INDENT> if S [ up + diff - 1 ] == <STRING> : <NEWLINE> <INDENT> chk += 1 <NEWLINE> <DEDENT> <DEDENT> if down - diff >= 1 : <NEWLINE> <INDENT> if S [ down - diff - 1 ] == <STRING> : <NEWLINE> <INDENT> chk += 1 <NEWLINE> <DEDENT> <DEDENT> if diff % 2 == 0 : <NEWLINE> <INDENT> if S [ int ( up - diff / 2 - 1 ) ] == <STRING> : <NEWLINE> <INDENT> chk += 1 <NEWLINE> <DEDENT> <DEDENT> cnt += lenb - chk <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def insertionSort ( a , n ) : <NEWLINE> <INDENT> trace ( a , n ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and a [ j ] > v : <NEWLINE> <INDENT> a [ j + 1 ] = a [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> a [ j + 1 ] = v <NEWLINE> trace ( a , n ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def trace ( a , n ) : <NEWLINE> <INDENT> output = <STRING> <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == a [ n - 1 ] : <NEWLINE> <INDENT> output += str ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> output += str ( i ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( output ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> insertionSort ( a , n ) <NEWLINE>
M = 10 ** 6 + 1 <NEWLINE> _ , * l = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * M <NEWLINE> for i in sorted ( l ) : <NEWLINE> <INDENT> a [ i ] += 1 <NEWLINE> if a [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( 2 * i , M , i ) : a [ j ] += 9 <NEWLINE> <DEDENT> <DEDENT> print ( a . count ( 1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nodes = [ 0 for i in range ( n ) ] <NEWLINE> output = [ None for i in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> root = set ( range ( n ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> id , _ , * li = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> root -= set ( li ) <NEWLINE> nodes [ id ] = li <NEWLINE> <NL> <DEDENT> def rooted_tree ( id , depth , parent ) : <NEWLINE> <INDENT> out = { } <NEWLINE> out [ <STRING> ] = id <NEWLINE> out [ <STRING> ] = parent <NEWLINE> out [ <STRING> ] = depth <NEWLINE> out [ <STRING> ] = nodes [ id ] <NEWLINE> if depth == 0 : <NEWLINE> <INDENT> out [ <STRING> ] = <STRING> <NEWLINE> <DEDENT> elif len ( nodes [ id ] ) == 0 : <NEWLINE> <INDENT> out [ <STRING> ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> out [ <STRING> ] = <STRING> <NEWLINE> <DEDENT> output [ id ] = out <NEWLINE> for i in ( nodes [ id ] ) : <NEWLINE> <INDENT> rooted_tree ( i , depth + 1 , id ) <NEWLINE> <NL> <DEDENT> <DEDENT> rooted_tree ( root . pop ( ) , 0 , - 1 ) <NEWLINE> for line in output : <NEWLINE> <INDENT> print ( <STRING> . format ( line [ <STRING> ] , line [ <STRING> ] , line [ <STRING> ] , line [ <STRING> ] , line [ <STRING> ] ) ) <NEWLINE> <NL> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> visited = [ 0 for _ in range ( N ) ] <NEWLINE> first_visit = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> now = 0 <NEWLINE> flag = True <NEWLINE> for i in range ( 10 ** 5 * 5 ) : <NEWLINE> <INDENT> if first_visit [ now ] == 0 : <NEWLINE> <INDENT> first_visit [ now ] = i <NEWLINE> <NL> <DEDENT> visited [ A [ now ] - 1 ] += 1 <NEWLINE> now = A [ now ] - 1 <NEWLINE> <NL> if i == K - 1 : <NEWLINE> <INDENT> print ( now + 1 ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> num = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if visited [ i ] > 2 : <NEWLINE> <INDENT> num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if visited [ i ] >= 2 : <NEWLINE> <INDENT> if K % num == first_visit [ i ] % num : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> s = [ ] <NEWLINE> a = 26 <NEWLINE> tmp = 1 <NEWLINE> for i in range ( 20 ) : <NEWLINE> <INDENT> s . append ( tmp ) <NEWLINE> tmp += a <NEWLINE> a *= 26 <NEWLINE> if tmp > 100000000000000000 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if N >= s [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> size = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> b = N - s [ size - 1 ] <NEWLINE> <NL> n2a = lambda c : chr ( c + 64 ) <NEWLINE> a = 26 ** ( size - 1 ) <NEWLINE> <NL> ans = [ ] <NEWLINE> while ( a >= 1 ) : <NEWLINE> <INDENT> ans . append ( n2a ( b // a + 1 ) . lower ( ) ) <NEWLINE> b %= a <NEWLINE> a //= 26 <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = [ 0 for i in range ( n ) ] <NEWLINE> A = input ( ) . split ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] = int ( A [ i ] ) <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> B = [ 0 for i in range ( q ) ] <NEWLINE> B = input ( ) . split ( ) <NEWLINE> C = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> B [ i ] = int ( B [ i ] ) <NEWLINE> <DEDENT> l = [ 0 , 1 ] <NEWLINE> p = [ ] <NEWLINE> k = 0 <NEWLINE> D = [ ] <NEWLINE> for v in itertools . product ( l , repeat = n ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if v [ i ] == 1 : <NEWLINE> <INDENT> sum = sum + A [ i ] <NEWLINE> <DEDENT> <DEDENT> D . append ( sum ) <NEWLINE> k += 1 <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> if B [ i ] in D : <NEWLINE> <INDENT> C . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> print ( C [ i ] ) <NEWLINE> <NL> <DEDENT>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> total += gcd ( tmp , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> kekka = ( <STRING> ) <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> kekka = ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( kekka ) <NEWLINE>
from math import floor <NEWLINE> while ( True ) : <NEWLINE> <INDENT> x , y , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x , y , s ) == ( 0 , 0 , 0 ) : <NEWLINE> <INDENT> quit ( ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , s ) : <NEWLINE> <INDENT> j = s - floor ( i * ( 100 + x ) / 100 ) <NEWLINE> if j < 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> j = floor ( ( j + 1 ) * ( 100 / ( 100 + x ) ) ) <NEWLINE> for k in [ j - 1 , j ] : <NEWLINE> <INDENT> if floor ( i * ( 100 + x ) / 100 ) + floor ( k * ( 100 + x ) / 100 ) == s : <NEWLINE> <INDENT> ans = max ( ans , floor ( i * ( 100 + y ) / 100 ) + floor ( k * ( 100 + y ) / 100 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
from collections import deque <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> b = deque ( [ 0 ] * n ) <NEWLINE> j = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] * b [ j ] >= 0 : b [ j ] += a [ i ] <NEWLINE> else : j += 1 ; b [ j ] += a [ i ] <NEWLINE> <DEDENT> if b [ 0 ] < 0 and len ( b ) > 1 : b . popleft ( ) <NEWLINE> while b [ - 1 ] <= 0 and len ( b ) > 1 : b . pop ( ) <NEWLINE> if len ( b ) == 1 and b [ 0 ] <= 0 : print ( max ( a ) ) <NEWLINE> else : <NEWLINE> <INDENT> m = len ( b ) // 2 + 1 <NEWLINE> v = [ [ 0 ] * m for _ in range ( m ) ] <NEWLINE> v [ 0 ] [ 0 ] = b [ 0 ] <NEWLINE> for i in range ( 1 , m ) : <NEWLINE> <INDENT> v [ 0 ] [ i ] = v [ 0 ] [ i - 1 ] + b [ 2 * i ] + b [ 2 * i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , m ) : <NEWLINE> <INDENT> for j in range ( i , m ) : <NEWLINE> <INDENT> v [ i ] [ j ] = v [ i - 1 ] [ j ] - b [ 2 * i - 2 ] - b [ 2 * i - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( max ( [ max ( i ) for i in v ] ) ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> r = input ( ) <NEWLINE> r = float ( r ) <NEWLINE> S = math . pi * r * r <NEWLINE> L = 2 * math . pi * r <NEWLINE> print ( <STRING> . format ( round ( S , 6 ) , round ( L , 6 ) ) ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> acgt_list = [ 0 ] <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( S ) + 1 ) : <NEWLINE> <INDENT> slen = len ( S [ i : j ] ) <NEWLINE> temp = 0 <NEWLINE> for s in S [ i : j ] : <NEWLINE> <INDENT> if s == <STRING> or s == <STRING> or s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> <DEDENT> if temp == slen : <NEWLINE> <INDENT> acgt_list . append ( slen ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max ( acgt_list ) ) <NEWLINE>
n , m , q = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> arr = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for i in range ( q ) ] <NEWLINE> ans = 0 <NEWLINE> for i1 in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> for i2 in range ( i1 , m + 1 ) : <NEWLINE> <INDENT> for i3 in range ( i2 , m + 1 ) : <NEWLINE> <INDENT> for i4 in range ( i3 , m + 1 ) : <NEWLINE> <INDENT> for i5 in range ( i4 , m + 1 ) : <NEWLINE> <INDENT> for i6 in range ( i5 , m + 1 ) : <NEWLINE> <INDENT> for i7 in range ( i6 , m + 1 ) : <NEWLINE> <INDENT> for i8 in range ( i7 , m + 1 ) : <NEWLINE> <INDENT> for i9 in range ( i8 , m + 1 ) : <NEWLINE> <INDENT> for i10 in range ( i9 , m + 1 ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> arrs = [ 0 , i1 , i2 , i3 , i4 , i5 , i6 , i7 , i8 , i9 , i10 ] <NEWLINE> for a , b , c , d in arr : <NEWLINE> <INDENT> if arrs [ b ] - arrs [ a ] == c : <NEWLINE> <INDENT> tmp += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from functools import lru_cache <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def popcount ( x ) : <NEWLINE> <INDENT> return x % bin ( x ) . count ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def f ( x ) : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> while x > 0 : <NEWLINE> <INDENT> x = popcount ( x ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> count = X . count ( <STRING> ) <NEWLINE> mod_one = count - 1 <NEWLINE> if mod_one == 0 : <NEWLINE> <INDENT> mod_one = 1 <NEWLINE> <DEDENT> mod_zero = count + 1 <NEWLINE> ones = [ 1 % mod_one ] <NEWLINE> zeros = [ 1 % mod_zero ] <NEWLINE> x_mod_one = 0 if X [ - 1 ] == <STRING> else 1 % mod_one <NEWLINE> x_mod_zero = 0 if X [ - 1 ] == <STRING> else 1 % mod_zero <NEWLINE> <NL> for xi in reversed ( X [ : - 1 ] ) : <NEWLINE> <INDENT> ones . append ( ones [ - 1 ] * 2 % mod_one ) <NEWLINE> zeros . append ( zeros [ - 1 ] * 2 % mod_zero ) <NEWLINE> if xi == <STRING> : <NEWLINE> <INDENT> x_mod_one += ones [ - 1 ] <NEWLINE> x_mod_one %= mod_one <NEWLINE> x_mod_zero += zeros [ - 1 ] <NEWLINE> x_mod_zero %= mod_zero <NEWLINE> <NL> <DEDENT> <DEDENT> ones = list ( reversed ( ones ) ) <NEWLINE> zeros = list ( reversed ( zeros ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if count == 1 and X [ i ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif X [ i ] == <STRING> : <NEWLINE> <INDENT> x = ( x_mod_one - ones [ i ] ) % mod_one <NEWLINE> print ( f ( x ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = ( x_mod_zero + zeros [ i ] ) % mod_zero <NEWLINE> print ( f ( x ) ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mem = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> mem [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in mem : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> def check ( k ) : <NEWLINE> <INDENT> aaa = 0 <NEWLINE> prev = 7 % k <NEWLINE> for i in range ( 0 , k ) : <NEWLINE> <INDENT> aaa += 1 <NEWLINE> if prev == 0 : <NEWLINE> <INDENT> return ( aaa ) <NEWLINE> <DEDENT> prev = ( prev * 10 + 7 ) % k <NEWLINE> <DEDENT> return ( - 1 ) <NEWLINE> <DEDENT> print ( check ( K ) ) <NEWLINE>
count = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if int ( x ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + str ( count ) + <STRING> + str ( x ) ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> while k : <NEWLINE> <INDENT> if a >= b : <NEWLINE> <INDENT> b *= 2 <NEWLINE> k -= 1 <NEWLINE> <DEDENT> elif b >= c : <NEWLINE> <INDENT> c *= 2 <NEWLINE> k -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if a < b and b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> _ = input ( ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res_set = set ( a_list ) <NEWLINE> <COMMENT> <NL> a_counter = Counter ( a_list ) <NEWLINE> for e in a_counter . items ( ) : <COMMENT> <NEWLINE> <INDENT> if e [ 1 ] == 1 : <NEWLINE> <INDENT> for i in range ( e [ 0 ] * 2 , 10 ** 6 + 1 , e [ 0 ] ) : <COMMENT> <NEWLINE> <INDENT> res_set . discard ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( e [ 0 ] , 2 * 10 ** 6 + 1 , e [ 0 ] ) : <COMMENT> <NEWLINE> <INDENT> res_set . discard ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( res_set ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> S = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> g = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> S += math . gcd ( g , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
while True : <NEWLINE> <INDENT> num = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> H = num [ 0 ] <NEWLINE> W = num [ 1 ] <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( ( <STRING> * W + <STRING> ) * H ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans == 0 or ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> S = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for h in range ( i , K + 1 ) : <NEWLINE> <INDENT> for g in range ( h , K + 1 ) : <NEWLINE> <NL> <INDENT> if i == h and h == g : <NEWLINE> <INDENT> S += gcd ( g , h , i ) <NEWLINE> <DEDENT> elif i == h or h == g or g == i : <NEWLINE> <INDENT> S += 3 * gcd ( g , h , i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S += 6 * gcd ( g , h , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
import sys <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = [ 0 for i in range ( N ) ] <NEWLINE> location = 0 <NEWLINE> count = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> location = l [ location ] - 1 <NEWLINE> m [ location ] += 1 <NEWLINE> if m [ location ] == 2 : <NEWLINE> <INDENT> start = location <NEWLINE> for j in range ( K - i - 1 ) : <NEWLINE> <INDENT> location = l [ location ] - 1 <NEWLINE> count += 1 <NEWLINE> if location == start : <NEWLINE> <INDENT> for k in range ( ( K - i - j - 2 ) % count ) : <NEWLINE> <INDENT> location = l [ location ] - 1 <NEWLINE> <DEDENT> print ( location + 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( location + 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( location + 1 ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> import os <NEWLINE> from operator import mul <NEWLINE> import numpy as np <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def _S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( _S ( ) ) <NEWLINE> def LS ( ) : return list ( _S ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , LS ( ) ) ) <NEWLINE> <NL> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> inputFile = basename_without_ext = os . path . splitext ( os . path . basename ( __file__ ) ) [ 0 ] + <STRING> <NEWLINE> sys . stdin = open ( inputFile , <STRING> ) <NEWLINE> <DEDENT> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> N = I ( ) <NEWLINE> A1 = LI ( ) <NEWLINE> A2 = LI ( ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( A1 [ 0 ] + A2 [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , sum ( A1 [ : i ] ) + sum ( A2 [ i - 1 : ] ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_dic = Counter ( A ) <NEWLINE> <NL> set_A = sorted ( ( set ( A ) ) , reverse = True ) <NEWLINE> tmp = 0 <NEWLINE> for a in set_A : <NEWLINE> <INDENT> if A_dic [ a ] >= 4 : <NEWLINE> <INDENT> print ( max ( tmp * a , a * a ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if A_dic [ a ] >= 2 : <NEWLINE> <INDENT> ans = tmp * a <NEWLINE> if ans != 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> tmp = a <NEWLINE> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE>
N , M = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> Now = [ 0 ] * N <NEWLINE> maxL = 1 <NEWLINE> minR = N <NEWLINE> for T in range ( 0 , M ) : <NEWLINE> <INDENT> L , R = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if maxL < L : <NEWLINE> <INDENT> maxL = L <NEWLINE> <DEDENT> if minR > R : <NEWLINE> <INDENT> minR = R <NEWLINE> <DEDENT> <DEDENT> if maxL > minR : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif maxL == minR : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif maxL < minR : <NEWLINE> <INDENT> print ( minR - maxL + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> mem = [ 0 , 0 , 0 ] <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= mem . count ( A [ i ] ) <NEWLINE> ans %= mod <NEWLINE> if ans == 0 : break <NEWLINE> idx = mem . index ( A [ i ] ) <NEWLINE> mem [ idx ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if ( S [ i ] != <STRING> ) : <NEWLINE> <INDENT> ans . append ( S [ i ] ) <NEWLINE> <DEDENT> elif ( S [ i ] == <STRING> and len ( ans ) != 0 ) : <NEWLINE> <INDENT> ans . pop ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
mini , maxi , K_ban = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( maxi - mini + 1 <= 2 * K_ban ) : <NEWLINE> <INDENT> ans = [ i for i in range ( mini , maxi + 1 ) ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> left = [ i for i in range ( mini , mini + K_ban ) ] <NEWLINE> right = [ i for i in range ( maxi - K_ban + 1 , maxi + 1 ) ] <NEWLINE> <NL> ans = left + right <NEWLINE> <NL> <NL> <DEDENT> [ print ( n ) for n in ans ] <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( sys . stdin . readline ( ) ) <NEWLINE> A_list = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> cum_sum = 0 <NEWLINE> A_cum_sum = [ ] <NEWLINE> <NL> for i in range ( len ( A_list ) ) : <NEWLINE> <INDENT> cum_sum += A_list [ i ] <NEWLINE> A_cum_sum . append ( cum_sum ) <NEWLINE> <NL> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> S = 0 <NEWLINE> <NL> for i in range ( len ( A_list ) ) : <NEWLINE> <INDENT> S += A_list [ i ] * ( A_cum_sum [ - 1 ] - A_cum_sum [ i ] ) <NEWLINE> S %= mod <NEWLINE> <NL> <DEDENT> print ( S ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] * N <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> B [ A [ n ] - 1 ] = n + 1 <NEWLINE> <NL> <DEDENT> print ( * B ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> x = 0 <NEWLINE> if X == 0 : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( D ) ) <NEWLINE> <DEDENT> x = 1 <NEWLINE> <DEDENT> elif X < 0 : <NEWLINE> <INDENT> if abs ( X ) >= K * D : <NEWLINE> <INDENT> print ( abs ( X + K * D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = K - ( - 1 * X // D ) <NEWLINE> X = X + ( - 1 * X // D ) * D <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( X ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( X + D ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if X >= K * D : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = K - ( X // D ) <NEWLINE> X = X - ( X // D ) * D <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( X ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( X - D ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> x = gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( x , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b / a == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def numba_compile ( numba_config ) : <NEWLINE> <INDENT> import os , sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba import njit <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> vars ( ) [ func . __name__ ] = njit ( signature ) ( func ) <NEWLINE> cc . export ( func . __name__ , signature ) ( func ) <NEWLINE> <DEDENT> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif os . name == <STRING> : <NEWLINE> <INDENT> exec ( <STRING> ) <NEWLINE> for func , _ in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = vars ( ) [ func . __name__ ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature , cache = True ) ( func ) <NEWLINE> <DEDENT> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def bis ( K , A , B , t ) : <NEWLINE> <COMMENT> <NL> <INDENT> if t == 1 : <NEWLINE> <INDENT> ok = 0 <NEWLINE> ng = 10 ** 18 + 1 <NEWLINE> while ok + 1 < ng : <NEWLINE> <INDENT> c = ok + ng >> 1 <NEWLINE> cnt = 0 <NEWLINE> idx_B = len ( B ) - 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> while idx_B >= 0 and a * B [ idx_B ] >= c : <NEWLINE> <INDENT> idx_B -= 1 <NEWLINE> <DEDENT> cnt += idx_B + 1 <NEWLINE> <DEDENT> if cnt < K : <NEWLINE> <INDENT> ok = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = c <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ok = 0 <NEWLINE> ng = 10 ** 18 + 1 <NEWLINE> while ok + 1 < ng : <NEWLINE> <INDENT> c = ok + ng >> 1 <NEWLINE> cnt = 0 <NEWLINE> idx_A = len ( A ) - 1 <NEWLINE> idx_B = len ( B ) - 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> while idx_A >= 0 and a * A [ idx_A ] >= c : <NEWLINE> <INDENT> idx_A -= 1 <NEWLINE> <DEDENT> cnt += idx_A + 1 <NEWLINE> if a * a < c : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> for b in B : <NEWLINE> <INDENT> while idx_B >= 0 and b * B [ idx_B ] >= c : <NEWLINE> <INDENT> idx_B -= 1 <NEWLINE> <DEDENT> cnt += idx_B + 1 <NEWLINE> if b * b < c : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> cnt >>= 1 <NEWLINE> if cnt < K : <NEWLINE> <INDENT> ok = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = c <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <DEDENT> numba_compile ( [ <NEWLINE> <INDENT> [ bis , <STRING> ] , <NEWLINE> <DEDENT> ] ) <NEWLINE> <NL> import numpy as np <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt_m = cnt_0 = cnt_p = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> cnt_m += 1 <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> cnt_0 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt_p += 1 <NEWLINE> <DEDENT> <DEDENT> cnt2_m = cnt_m * cnt_p <NEWLINE> cnt2_0 = cnt_0 * N - cnt_0 * ( cnt_0 + 1 ) // 2 <NEWLINE> cnt2_p = cnt_p * ( cnt_p - 1 ) // 2 + cnt_m * ( cnt_m - 1 ) // 2 <NEWLINE> assert cnt2_m + cnt2_0 + cnt2_p == N * ( N - 1 ) // 2 <NEWLINE> <NL> if K <= cnt2_m : <NEWLINE> <COMMENT> <NL> <INDENT> X = np . array ( [ - a for a in A [ : : - 1 ] if a < 0 ] , dtype = np . int64 ) <NEWLINE> Y = np . array ( [ a for a in A if a > 0 ] , dtype = np . int64 ) <NEWLINE> ans = - bis ( cnt2_m - K + 1 , X , Y , 1 ) <NEWLINE> <DEDENT> elif K <= cnt2_m + cnt2_0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X = np . array ( [ - a for a in A [ : : - 1 ] if a < 0 ] , dtype = np . int64 ) <NEWLINE> Y = np . array ( [ a for a in A if a > 0 ] , dtype = np . int64 ) <NEWLINE> ans = bis ( K - cnt2_m - cnt2_0 , X , Y , 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import sys , os , math , bisect , itertools , collections , heapq , queue <NEWLINE> <COMMENT> <NL> from decimal import Decimal <NEWLINE> from collections import defaultdict , deque <NEWLINE> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> W , H , x , y = il ( ) <NEWLINE> print ( ( W * H ) / 2 , 1 if W / 2 == x and H / 2 == y else 0 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( a , min ( a + k , b + 1 ) ) : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> for i in range ( max ( b - k + 1 , a ) , b + 1 ) : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> ans = sorted ( list ( set ( ans ) ) ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> buka_num = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> buka_num [ i ] += 1 <NEWLINE> <DEDENT> buka_num . pop ( 0 ) <NEWLINE> for j in buka_num : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> frac = [ ] <NEWLINE> for i in range ( 1 , math . floor ( math . sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> frac . append ( len ( str ( int ( N / i ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> if N != 1 : <NEWLINE> <INDENT> print ( min ( frac ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> import math <NEWLINE> ans = [ 0 ] * ( N + 1 ) <NEWLINE> n = int ( math . sqrt ( N ) ) + 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i * i + 2 * i > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i * i + j * j + i * j > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i * i + j * j + k * k + i * j + j * k + i * k > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ans [ i * i + j * j + k * k + i * j + j * k + i * k ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> def insertionSort ( A , n , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> def shellSort ( A , n , m , G ) : <NEWLINE> <INDENT> A1 = A [ : ] <NEWLINE> global cnt <NEWLINE> cnt = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> insertionSort ( A1 , n , G [ i ] ) <NEWLINE> <DEDENT> return A1 <NEWLINE> <NL> <DEDENT> def Gmake ( n ) : <NEWLINE> <INDENT> G = [ ] <NEWLINE> k = 1 <NEWLINE> while k <= n and len ( G ) < 100 : <NEWLINE> <INDENT> G . append ( k ) <NEWLINE> k = 3 * k + 1 <NEWLINE> <DEDENT> G . reverse ( ) <NEWLINE> return G <NEWLINE> <NL> <DEDENT> G = Gmake ( n ) <NEWLINE> A2 = shellSort ( A , n , len ( G ) , G ) <NEWLINE> print ( str ( len ( G ) ) ) <NEWLINE> print ( <STRING> . join ( map ( str , G ) ) ) <NEWLINE> print ( str ( cnt ) ) <NEWLINE> for i in A2 : <NEWLINE> <INDENT> print ( str ( i ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> import math <NEWLINE> s = round ( math . sqrt ( n ) ) + 1 <NEWLINE> <NL> i = 2 <NEWLINE> c1 = 0 <NEWLINE> c2 = 1 <NEWLINE> ans = 0 <NEWLINE> while i <= s : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> n //= i <NEWLINE> c1 += 1 <NEWLINE> if c1 == c2 : <NEWLINE> <INDENT> c1 = 0 <NEWLINE> c2 += 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> c2 = 1 <NEWLINE> i += 1 <NEWLINE> c1 = 0 <NEWLINE> <DEDENT> <DEDENT> if n > s : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> x = y = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == 0 : break <NEWLINE> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , y + 1 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( 100 , 0 , - 1 ) : <NEWLINE> <INDENT> if ( A % i == 0 ) and ( B % i == 0 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count == K : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lim = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > lim : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> import math <NEWLINE> from functools import reduce <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = [ 1 , 9 , 30 , 76 , 141 , 267 , 400 , 624 , 885 , 1249 , 1590 , 2208 , 2689 , 3411 , 4248 , 5248 , 6081 , 7485 , 8530 , 10248 , 11889 , 13687 , 15228 , 17988 , 20053 , 22569 , 25242 , 28588 , 31053 , 35463 , 38284 , 42540 , 46581 , 50893 , 55362 , 61824 , 65857 , 71247 , 76884 , 84388 , 89349 , 97881 , 103342 , 111528 , 120141 , 128047 , 134580 , 146316 , 154177 , 164817 , 174438 , 185836 , 194157 , 207927 , 218812 , 233268 , 245277 , 257857 , 268182 , 288216 , 299257 , 313635 , 330204 , 347836 , 362973 , 383709 , 397042 , 416448 , 434025 , 456967 , 471948 , 499740 , 515581 , 536073 , 559758 , 583960 , 604833 , 633651 , 652216 , 683712 , 709065 , 734233 , 754734 , 793188 , 818917 , 846603 , 874512 , 909496 , 933081 , 977145 , 1006126 , 1041504 , 1073385 , 1106467 , 1138536 , 1187112 , 1215145 , 1255101 , 1295142 , 1342852 , 1373253 , 1422195 , 1453816 , 1502376 , 1553361 , 1595437 , 1629570 , 1691292 , 1726717 , 1782111 , 1827492 , 1887772 , 1925853 , 1986837 , 2033674 , 2089776 , 2145333 , 2197483 , 2246640 , 2332104 , 2379085 , 2434833 , 2490534 , 2554600 , 2609625 , 2693919 , 2742052 , 2813988 , 2875245 , 2952085 , 3003306 , 3096024 , 3157249 , 3224511 , 3306240 , 3388576 , 3444609 , 3533637 , 3591322 , 3693924 , 3767085 , 3842623 , 3912324 , 4027884 , 4102093 , 4181949 , 4270422 , 4361548 , 4427853 , 4548003 , 4616104 , 4718640 , 4812789 , 4918561 , 5003286 , 5131848 , 5205481 , 5299011 , 5392008 , 5521384 , 5610705 , 5739009 , 5818390 , 5930196 , 6052893 , 6156139 , 6239472 , 6402720 , 6493681 , 6623853 , 6741078 , 6864016 , 6953457 , 7094451 , 7215016 , 7359936 , 7475145 , 7593865 , 7689630 , 7886244 , 7984165 , 8130747 , 8253888 , 8403448 , 8523897 , 8684853 , 8802826 , 8949612 , 9105537 , 9267595 , 9376656 , 9574704 , 9686065 , 9827097 , 9997134 , 10174780 , 10290813 , 10493367 , 10611772 , 10813692 ] <NEWLINE> print ( ans [ k - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def insertion_sort ( data , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , len ( data ) ) : <NEWLINE> <INDENT> v , j = data [ i ] , i - g <NEWLINE> while j >= 0 and data [ j ] > v : <NEWLINE> <INDENT> data [ j + g ] = data [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> data [ j + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> def shell_sort ( data ) : <NEWLINE> <INDENT> global G <NEWLINE> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> tmp = ( 3 ** i - 1 ) // 2 <NEWLINE> if tmp > len ( data ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> G . append ( tmp ) <NEWLINE> <DEDENT> for g in list ( reversed ( G ) ) : <NEWLINE> <INDENT> insertion_sort ( data , g ) <NEWLINE> <NL> <DEDENT> <DEDENT> G , cnt = [ ] , 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> data = list ( int ( input ( ) ) for _ in range ( n ) ) <NEWLINE> shell_sort ( data ) <NEWLINE> print ( len ( G ) ) <NEWLINE> print ( <STRING> . join ( map ( str , list ( reversed ( G ) ) ) ) ) <NEWLINE> print ( cnt ) <NEWLINE> print ( <STRING> . join ( map ( str , data ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> gacha = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> item = input ( ) <NEWLINE> gacha . append ( item ) <NEWLINE> <NL> <DEDENT> print ( str ( len ( set ( gacha ) ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> if len ( make_divisors ( i ) ) == 8 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = ( N // K ) + 1 <NEWLINE> <NL> ans1 = - ( N - K * a ) <NEWLINE> ans2 = N - ( K * ( N // K ) ) <NEWLINE> print ( min ( ans1 , ans2 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> * a , = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_max = a [ n - 1 ] <NEWLINE> dp = [ True ] * a_max <NEWLINE> ans = 0 <NEWLINE> recent = 0 <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> if recent == i : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> recent = 0 <NEWLINE> <DEDENT> if dp [ i - 1 ] == False : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( i , a_max + 1 , i ) : <NEWLINE> <INDENT> dp [ j - 1 ] = False <NEWLINE> <DEDENT> ans += 1 <NEWLINE> recent = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import accumulate <NEWLINE> from operator import add , mul <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( [ 0 ] * ( n ) ) <NEWLINE> b . append ( [ 0 ] * ( n ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <STRING> <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> a [ l - 1 ] [ r - 1 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = list ( accumulate ( a [ i ] ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n - i - 1 ) : <NEWLINE> <INDENT> a [ n - i - j - 2 ] [ n - i - 1 ] += a [ n - i - j - 1 ] [ n - i - 1 ] <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( q ) : <NEWLINE> <INDENT> P , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a [ ( P - 1 ) ] [ ( Q - 1 ) ] ) <NEWLINE> <DEDENT> <STRING> <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> P_sum = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> P [ i ] = ( P [ i ] + 1 ) / 2 <NEWLINE> <NL> <DEDENT> for j in range ( K ) : <NEWLINE> <INDENT> P_sum += P [ j ] <NEWLINE> <NL> <DEDENT> ans = P_sum <NEWLINE> for t in range ( K , N ) : <NEWLINE> <INDENT> P_sum -= P [ t - K ] <NEWLINE> P_sum += P [ t ] <NEWLINE> ans = max ( ans , P_sum ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> import scipy . sparse as sps <NEWLINE> import scipy . misc as spm <NEWLINE> import collections as col <NEWLINE> import functools as func <NEWLINE> import itertools as ite <NEWLINE> import fractions as frac <NEWLINE> import math as ma <NEWLINE> from math import cos , sin , tan , sqrt <NEWLINE> import cmath as cma <NEWLINE> import copy as cp <NEWLINE> import sys <NEWLINE> import re <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> EPS = sys . float_info . epsilon <NEWLINE> PI = np . pi ; EXP = np . e ; INF = np . inf <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def sinput ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def iinput ( ) : return int ( sinput ( ) ) <NEWLINE> def imap ( ) : return map ( int , sinput ( ) . split ( ) ) <NEWLINE> def fmap ( ) : return map ( float , sinput ( ) . split ( ) ) <NEWLINE> def iarr ( n = 0 ) : <NEWLINE> <INDENT> if n : return [ 0 for _ in range ( n ) ] <NEWLINE> else : return list ( imap ( ) ) <NEWLINE> <DEDENT> def farr ( ) : return list ( fmap ( ) ) <NEWLINE> def sarr ( n = 0 ) : <NEWLINE> <INDENT> if n : return [ <STRING> for _ in range ( n ) ] <NEWLINE> else : return sinput ( ) . split ( ) <NEWLINE> <DEDENT> def adj ( n ) : return [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> n = iinput ( ) <NEWLINE> a = iarr ( ) <NEWLINE> amax = max ( a ) <NEWLINE> <NL> <COMMENT> <NL> dp = [ 1 for i in range ( amax + 1 ) ] <NEWLINE> for num in a : <NEWLINE> <INDENT> for i in range ( 2 , amax // num + 1 ) : <NEWLINE> <INDENT> tmp = num * i <NEWLINE> if dp [ tmp ] : dp [ tmp ] = 0 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> cnt = col . Counter ( a ) <NEWLINE> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for key , val in cnt . items ( ) : <NEWLINE> <INDENT> if dp [ key ] and val == 1 : ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
while True : <NEWLINE> <INDENT> s = input ( ) . split ( ) <NEWLINE> t = [ int ( l ) for l in s ] <NEWLINE> if t [ 0 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( t [ 0 ] ) : <NEWLINE> <INDENT> print ( <STRING> * t [ 1 ] ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT>
def solve ( prev , r , n , dic ) : <NEWLINE> <INDENT> d = [ 0 ] * n <NEWLINE> md = 0 <NEWLINE> t = r <NEWLINE> stack = [ ] <NEWLINE> stack += [ [ prev , r , 0 ] ] <NEWLINE> while stack : <NEWLINE> <INDENT> prev , r , d1 = stack . pop ( - 1 ) <NEWLINE> if r in dic : <NEWLINE> <INDENT> for vtx , cost in dic [ r ] : <NEWLINE> <INDENT> if vtx == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> stack += [ [ r , vtx , d1 + cost ] ] <NEWLINE> if d [ vtx ] < d1 + cost : <NEWLINE> <INDENT> d [ vtx ] = d1 + cost <NEWLINE> if md < d [ vtx ] : <NEWLINE> <INDENT> md = d [ vtx ] <NEWLINE> t = vtx <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return d , t <NEWLINE> <NL> <DEDENT> dic = { } <NEWLINE> line = input ( ) <NEWLINE> n = int ( line ) <NEWLINE> for _ in range ( 1 , n ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> s , t , w = list ( map ( int , line . split ( ) ) ) <NEWLINE> if s not in dic : <NEWLINE> <INDENT> dic [ s ] = [ [ t , w ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ s ] += [ [ t , w ] ] <NEWLINE> <DEDENT> if t not in dic : <NEWLINE> <INDENT> dic [ t ] = [ [ s , w ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ t ] += [ [ s , w ] ] <NEWLINE> <DEDENT> <DEDENT> d1 , t1 = solve ( - 1 , 0 , n , dic ) <NEWLINE> d2 , t2 = solve ( - 1 , t1 , n , dic ) <NEWLINE> d3 , t3 = solve ( - 1 , t2 , n , dic ) <NEWLINE> print ( <STRING> . join ( map ( str , [ max ( a , b ) for a , b in zip ( d2 , d3 ) ] ) ) ) <NEWLINE>
pictures = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> card_li = [ ] <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 1 , 14 ) : <NEWLINE> <INDENT> card_li . append ( pictures [ i ] + <STRING> + str ( j ) ) <NEWLINE> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : del card_li [ card_li . index ( input ( ) ) ] <NEWLINE> for i in card_li : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> la = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> la [ l [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> ans = [ str ( j ) for j in la ] <NEWLINE> ans = <STRING> . join ( ans ) <NEWLINE> print ( ans ) <NEWLINE>
b = [ 1 ] * 500000 <NEWLINE> for i in range ( 3 , 999 , 2 ) : <NEWLINE> <INDENT> if b [ i // 2 ] : b [ i * i // 2 : : i ] = [ 0 ] * len ( b [ i * i // 2 : : i ] ) <NEWLINE> <DEDENT> def p ( x ) : <NEWLINE> <INDENT> if x < 5 * 1e5 : return b [ x ] <NEWLINE> x = 2 * x + 1 <NEWLINE> for i in range ( 3 , int ( x ** .5 + 1 ) , 2 ) : <NEWLINE> <INDENT> if x % i == 0 : return 0 <NEWLINE> <DEDENT> return 1 <NEWLINE> <DEDENT> print ( sum ( p ( int ( input ( ) ) ) for _ in [ 0 ] * int ( input ( ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = 0 <NEWLINE> alist = [ 0 ] * 10 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> alist [ int ( s [ i ] ) ] = i <NEWLINE> <DEDENT> for i in range ( 10 ) : <NEWLINE> <INDENT> flag1 = False <NEWLINE> for a in range ( n - 2 ) : <NEWLINE> <INDENT> if s [ a ] == str ( i ) : <NEWLINE> <INDENT> flag1 = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag1 : <NEWLINE> <INDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> flag2 = False <NEWLINE> for b in range ( a + 1 , n - 1 ) : <NEWLINE> <INDENT> if s [ b ] == str ( j ) : <NEWLINE> <INDENT> flag2 = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag2 : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> if b < alist [ k ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 0 , N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> if L [ i ] != L [ j ] and L [ i ] != L [ k ] and L [ j ] != L [ k ] and L [ i ] + L [ j ] > L [ k ] and L [ i ] + L [ k ] > L [ j ] and L [ j ] + L [ k ] > L [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += gcd ( gcd ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
S = input ( ) <NEWLINE> x = len ( S ) <NEWLINE> c = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( x ) : <NEWLINE> <NL> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <NL> <INDENT> c += 1 <NEWLINE> <NL> ans += i + 1 - c <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = list ( str ( input ( ) ) ) <NEWLINE> t = list ( str ( input ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ i + j ] != t [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> l . append ( count ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> print ( min ( l ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> x [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> print ( x [ j ] ) <NEWLINE> <DEDENT>
class Dice ( object ) : <NEWLINE> <NL> <INDENT> def __init__ ( self , d ) : <NEWLINE> <NL> <INDENT> self . rows = [ d [ 0 ] , d [ 4 ] , d [ 5 ] , d [ 1 ] ] <NEWLINE> self . cols = [ d [ 0 ] , d [ 2 ] , d [ 5 ] , d [ 3 ] ] <NEWLINE> <NL> <DEDENT> def move_next_rows ( self ) : <NEWLINE> <INDENT> temp = self . rows . pop ( 0 ) <NEWLINE> self . rows . append ( temp ) <NEWLINE> self . __update ( self . cols , self . rows ) <NEWLINE> <NL> <DEDENT> def move_prev_rows ( self ) : <NEWLINE> <INDENT> temp = self . rows . pop ( 3 ) <NEWLINE> self . rows . insert ( 0 , temp ) <NEWLINE> self . __update ( self . cols , self . rows ) <NEWLINE> <NL> <DEDENT> def move_next_cols ( self ) : <NEWLINE> <INDENT> temp = self . cols . pop ( 0 ) <NEWLINE> self . cols . append ( temp ) <NEWLINE> self . __update ( self . rows , self . cols ) <NEWLINE> <NL> <DEDENT> def move_prev_cols ( self ) : <NEWLINE> <INDENT> temp = self . cols . pop ( 3 ) <NEWLINE> self . cols . insert ( 0 , temp ) <NEWLINE> self . __update ( self . rows , self . cols ) <NEWLINE> <NL> <DEDENT> def __update ( self , x , y ) : <NEWLINE> <INDENT> x [ 0 ] = y [ 0 ] <NEWLINE> x [ 2 ] = y [ 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> class DiceChecker ( object ) : <NEWLINE> <NL> <INDENT> def __init__ ( self , dice1 , dice2 ) : <NEWLINE> <INDENT> self . dice1 = dice1 <NEWLINE> self . dice2 = dice2 <NEWLINE> self . dice1_top = self . dice1 . rows [ 0 ] <NEWLINE> self . dice1_front = self . dice1 . rows [ 3 ] <NEWLINE> <NL> <DEDENT> def check_same_dice ( self ) : <NEWLINE> <NL> <INDENT> is_same = False <NEWLINE> for _ in range ( 4 ) : <NEWLINE> <INDENT> for _ in range ( 4 ) : <NEWLINE> <INDENT> for _ in range ( 4 ) : <NEWLINE> <INDENT> is_same_element = self . dice1 . rows == self . dice2 . rows and self . dice1 . cols == self . dice2 . cols <NEWLINE> if is_same_element : <NEWLINE> <INDENT> is_same = True <NEWLINE> <DEDENT> self . __rot ( self . dice2 ) <NEWLINE> <DEDENT> self . dice2 . move_next_rows ( ) <NEWLINE> <DEDENT> self . dice2 . move_next_cols ( ) <NEWLINE> <NL> <DEDENT> if is_same : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __rot ( self , dice ) : <NEWLINE> <INDENT> temp = dice . rows [ 1 ] <NEWLINE> dice . rows [ 1 ] = dice . cols [ 3 ] <NEWLINE> dice . cols [ 3 ] = dice . rows [ 3 ] <NEWLINE> dice . rows [ 3 ] = dice . cols [ 1 ] <NEWLINE> dice . cols [ 1 ] = temp <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> d1 = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> d2 = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> dice1 = Dice ( d1 ) <NEWLINE> dice2 = Dice ( d2 ) <NEWLINE> <NL> dice_checker = DiceChecker ( dice1 , dice2 ) <NEWLINE> dice_checker . check_same_dice ( ) <NEWLINE> <NL>
S = input ( ) <NEWLINE> <NL> S_list = list ( S ) <NEWLINE> N = len ( S_list ) <NEWLINE> <COMMENT> <NL> no_flag = 0 <NEWLINE> <NL> for i in range ( N // 2 ) : <NEWLINE> <INDENT> if S_list [ i ] != S_list [ N - i - 1 ] : <NEWLINE> <INDENT> no_flag = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( int ( ( N - 1 ) / 2 ) // 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if S_list [ i ] != S_list [ ( N - 1 ) // 2 - i - 1 ] : <NEWLINE> <INDENT> no_flag = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( ( N - 3 ) // 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if S_list [ ( N + 3 ) // 2 + i - 1 ] != S_list [ N - 1 - i ] : <NEWLINE> <INDENT> no_flag = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if no_flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> B . append ( K - Q ) <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> B [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> if B [ j ] >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> N = int ( input ( ) ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans = ans * i % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> n = len ( S ) <NEWLINE> k = 2019 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> A = [ 0 ] * ( n + 1 ) <COMMENT> <NEWLINE> d = { 0 : 1 } <NEWLINE> <NL> w = 1 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> A [ i ] = ( A [ i + 1 ] + w * int ( S [ i ] ) ) % k <NEWLINE> w = w * 10 % k <NEWLINE> if A [ i ] in d : <NEWLINE> <INDENT> d [ A [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ A [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for j in d : <NEWLINE> <INDENT> ans += d [ j ] * ( d [ j ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( N % K , K - N % K ) ) <NEWLINE> return <NEWLINE> <DEDENT> main ( ) <NEWLINE>
def insertion_sort ( a , n ) : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and a [ j ] > v : <NEWLINE> <INDENT> a [ j + 1 ] = a [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> a [ j + 1 ] = v <NEWLINE> print_list_split_whitespace ( a ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def print_list_split_whitespace ( a ) : <NEWLINE> <INDENT> for x in a [ : - 1 ] : <NEWLINE> <INDENT> print ( x , end = <STRING> ) <NEWLINE> <DEDENT> print ( a [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> <NL> <DEDENT> print_list_split_whitespace ( a ) <NEWLINE> insertion_sort ( a , n ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mini = p [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] <= mini : <NEWLINE> <INDENT> ans += 1 <NEWLINE> mini = min ( p [ i ] , mini ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
flag = False <NEWLINE> cli = [ 0 ] * 1001 <NEWLINE> sen = set ( ) <NEWLINE> kon = set ( ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> flag = True <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if flag : <NEWLINE> <INDENT> kon . add ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sen . add ( c ) <NEWLINE> <DEDENT> cli [ c ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 1001 ) : <NEWLINE> <INDENT> if i in sen and i in kon : <NEWLINE> <INDENT> print ( i , cli [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> a = Counter ( input ( ) ) . most_common ( ) <NEWLINE> if len ( a ) == 2 : <NEWLINE> <INDENT> if a [ 1 ] [ 1 ] == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> score = [ ] <NEWLINE> score += a * c , b * c , a * d , b * d <NEWLINE> print ( max ( score ) ) <NEWLINE>
<COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ 0 ] * k <NEWLINE> r = [ 0 ] * k <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> l [ j ] , r [ j ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> p = 998244353 <NEWLINE> dp = [ 0 ] * ( n + max ( r ) + 100 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> dp [ 2 ] = - 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> dp [ i ] += dp [ i - 1 ] <NEWLINE> dp [ i ] %= p <NEWLINE> <NL> for lj , rj in zip ( l , r ) : <NEWLINE> <INDENT> dp [ i + lj ] += dp [ i ] <NEWLINE> dp [ i + lj ] %= p <NEWLINE> dp [ i + rj + 1 ] -= dp [ i ] <NEWLINE> dp [ i + rj + 1 ] %= p <NEWLINE> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> cnt *= i <NEWLINE> if cnt > 10 ** 18 : <NEWLINE> <INDENT> cnt = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in lis : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in lis : <NEWLINE> <INDENT> ans *= i <NEWLINE> <NL> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 900000 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> from collections import Counter <NEWLINE> <NL> <NL> def dfs ( u , color , path , n , d ) : <NEWLINE> <INDENT> color [ u ] = d <NEWLINE> for v in path [ u ] : <NEWLINE> <INDENT> if color [ v ] == - 1 : <NEWLINE> <INDENT> dfs ( v , color , path , n , d ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> path = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> path [ a ] . append ( b ) <NEWLINE> path [ b ] . append ( a ) <NEWLINE> <DEDENT> color = [ - 1 ] * ( n + 1 ) <NEWLINE> d = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if color [ i ] == - 1 : <NEWLINE> <INDENT> dfs ( i , color , path , n , d ) <NEWLINE> d += 1 <NEWLINE> <DEDENT> <DEDENT> color = color [ 1 : ] <NEWLINE> color_cnt = Counter ( color ) . values ( ) <NEWLINE> print ( max ( color_cnt ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] and n != 1 : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> <NL> <DEDENT> g1 = [ 1 , 1 ] <NEWLINE> g2 = [ 1 , 1 ] <NEWLINE> inverse = [ 0 , 1 ] <NEWLINE> for i in range ( 2 , 2 * 10 ** 5 + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <NL> <NL> <DEDENT> primes = factorization ( M ) <NEWLINE> <COMMENT> <NL> <NL> ans = 1 <NEWLINE> <NL> for p , cnt in primes : <NEWLINE> <INDENT> tmp = cmb ( N + cnt - 1 , N - 1 , mod ) <NEWLINE> ans *= tmp <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> K = int ( input ( ) ) <NEWLINE> <NL> if K % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> X = 7 <NEWLINE> count = K <NEWLINE> while count > 0 : <NEWLINE> <INDENT> mod = X % K <NEWLINE> if mod == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> X = mod * 10 + 7 <NEWLINE> count -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans if count > 0 else - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , T = map ( int , input ( ) . split ( ) ) <NEWLINE> ls = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> c , t = map ( int , input ( ) . split ( ) ) <NEWLINE> if t <= T : <NEWLINE> <INDENT> ls . append ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( ls ) if ls else <STRING> ) <NEWLINE>
from itertools import product <NEWLINE> <NL> value , variety = map ( int , input ( ) . split ( ) ) <NEWLINE> coins = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ float ( <STRING> ) for _ in range ( value + 1 ) ] <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for ( c , j ) in product ( coins , list ( range ( value + 1 ) ) ) : <NEWLINE> <INDENT> if c <= j : <NEWLINE> <INDENT> dp [ j ] = min ( dp [ j ] , dp [ j - c ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ j ] = dp [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( dp [ value ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p = int ( input ( ) ) <NEWLINE> if pow ( 2 , p - 1 , p ) == 1 or p == 2 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import sys <NEWLINE> class BinaryTree : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <DEDENT> def b_insert ( self , x ) : <NEWLINE> <INDENT> if self . root is None : <NEWLINE> <INDENT> self . root = Node ( x ) <NEWLINE> return <NEWLINE> <DEDENT> node = None <NEWLINE> root = self . root <NEWLINE> while root is not None : <NEWLINE> <INDENT> node = root <NEWLINE> if x == root . data : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> elif x < root . data : <NEWLINE> <INDENT> root = root . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root = root . right <NEWLINE> <DEDENT> <DEDENT> if node is None : <NEWLINE> <COMMENT> <NL> <INDENT> node = Node ( x ) <NEWLINE> <DEDENT> elif node . data < x : <NEWLINE> <COMMENT> <NL> <INDENT> node . right = Node ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> node . left = Node ( x ) <NEWLINE> <DEDENT> <DEDENT> def b_inorder ( self ) : <NEWLINE> <INDENT> return inorder ( self . root ) <NEWLINE> <DEDENT> def b_preorder ( self ) : <NEWLINE> <INDENT> return preorder ( self . root ) <NEWLINE> <NL> <DEDENT> <DEDENT> class Node : <NEWLINE> <INDENT> def __init__ ( self , x ) : <NEWLINE> <INDENT> self . data = x <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def inorder ( node ) : <NEWLINE> <INDENT> nodelist = [ ] <NEWLINE> if node . left : <NEWLINE> <INDENT> nodelist += inorder ( node . left ) <NEWLINE> <DEDENT> nodelist += [ node . data ] <NEWLINE> if node . right : <NEWLINE> <INDENT> nodelist += inorder ( node . right ) <NEWLINE> <DEDENT> return nodelist <NEWLINE> <DEDENT> def preorder ( node ) : <NEWLINE> <INDENT> nodelist = [ node . data ] <NEWLINE> if node . left : <NEWLINE> <INDENT> nodelist += preorder ( node . left ) <NEWLINE> <DEDENT> if node . right : <NEWLINE> <INDENT> nodelist += preorder ( node . right ) <NEWLINE> <DEDENT> return nodelist <NEWLINE> <NL> <DEDENT> line = sys . stdin . readline ( ) <NEWLINE> bfs = BinaryTree ( ) <NEWLINE> <NL> for temp in sys . stdin : <NEWLINE> <INDENT> if temp [ 0 ] == <STRING> : <NEWLINE> <INDENT> command , num = ( n for n in temp . split ( <STRING> ) ) <NEWLINE> bfs . b_insert ( int ( num ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * bfs . b_inorder ( ) ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * bfs . b_preorder ( ) ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if math . gcd ( a , b ) == 1 : <NEWLINE> <INDENT> total += k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> total += math . gcd ( a , math . gcd ( b , c ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> R_index = [ ] <NEWLINE> G_index = [ ] <NEWLINE> B_index = [ ] <NEWLINE> for i , v in enumerate ( S ) : <NEWLINE> <INDENT> if v == <STRING> : <NEWLINE> <INDENT> R_index . append ( i ) <NEWLINE> <DEDENT> if v == <STRING> : <NEWLINE> <INDENT> G_index . append ( i ) <NEWLINE> <DEDENT> if v == <STRING> : <NEWLINE> <INDENT> B_index . append ( i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> R_B = [ ] <NEWLINE> B_G = [ ] <NEWLINE> count_ij_jk_onaji = 0 <NEWLINE> for r in R_index : <NEWLINE> <INDENT> for g in G_index : <NEWLINE> <INDENT> if 0 <= g - ( r - g ) and g - ( r - g ) < N : <NEWLINE> <COMMENT> <NL> <INDENT> if S [ g - ( r - g ) ] == <STRING> : <NEWLINE> <INDENT> count_ij_jk_onaji += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for b in B_index : <NEWLINE> <INDENT> for r in R_index : <NEWLINE> <INDENT> if 0 <= r - ( b - r ) and r - ( b - r ) < N : <NEWLINE> <COMMENT> <NL> <INDENT> if S [ r - ( b - r ) ] == <STRING> : <NEWLINE> <INDENT> count_ij_jk_onaji += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for g in G_index : <NEWLINE> <INDENT> for b in B_index : <NEWLINE> <INDENT> if 0 <= b - ( g - b ) and b - ( g - b ) < N : <NEWLINE> <COMMENT> <NL> <INDENT> if S [ b - ( g - b ) ] == <STRING> : <NEWLINE> <INDENT> count_ij_jk_onaji += 1 <NEWLINE> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> kotae_all = len ( R_index ) * len ( G_index ) * len ( B_index ) <NEWLINE> print ( kotae_all - count_ij_jk_onaji ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( <STRING> if n % 9 == 0 else <STRING> ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> S += <STRING> <NEWLINE> d = [ 0 ] * ( N + 1 ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( S ) - 1 ) : <NEWLINE> <INDENT> if S [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> d [ i + 1 ] = count <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = d [ r - 1 ] - d [ l - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( <STRING> ) ) <NEWLINE> yoko = x2 - x1 <NEWLINE> tate = y2 - y1 <NEWLINE> print ( math . sqrt ( yoko ** 2 + tate ** 2 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> p = x . count ( <STRING> ) <NEWLINE> Ma = [ 1 ] + [ 0 ] * ( n - 1 ) <NEWLINE> Mb = [ 1 ] + [ 0 ] * ( n - 1 ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if p > 1 : <NEWLINE> <INDENT> Ma [ i ] = Ma [ i - 1 ] * 2 % ( p - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Ma [ i ] = 0 <NEWLINE> Ma [ 0 ] = 0 <NEWLINE> <DEDENT> Mb [ i ] = Mb [ i - 1 ] * 2 % ( p + 1 ) <NEWLINE> <DEDENT> Sa = Sb = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> Sa += Ma [ n - 1 - i ] <NEWLINE> Sb += Mb [ n - 1 - i ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> if x [ i ] == <STRING> : <NEWLINE> <INDENT> if p == 1 : <NEWLINE> <INDENT> s = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = ( Sa - Ma [ n - 1 - i ] ) % ( p - 1 ) <NEWLINE> a += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s = ( Sb + Mb [ n - 1 - i ] ) % ( p + 1 ) <NEWLINE> a += 1 <NEWLINE> <DEDENT> while ( s > 0 ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> r = s <NEWLINE> while ( r > 0 ) : <NEWLINE> <INDENT> t += r & 1 <NEWLINE> r //= 2 <NEWLINE> <DEDENT> s %= t <NEWLINE> a += 1 <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> def two ( num ) : <NEWLINE> <INDENT> for i in range ( 1 , 8 ) : <NEWLINE> <INDENT> if ( 2 ** ( i - 1 ) <= num ) & ( num < 2 ** ( i ) ) : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <DEDENT> ab = two ( a / b ) <NEWLINE> b_ = b * 2 ** ab <NEWLINE> b_c = two ( b_ / c ) <NEWLINE> <NL> if k >= ( ab + b_c ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> sum_a = sum ( a ) <NEWLINE> <NL> ans = n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> sum_a -= a [ i - 1 ] <NEWLINE> if a [ i - 1 ] <= 2 * sum_a : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> f = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> f [ a - 1 ] . append ( [ b - 1 , c ] ) <NEWLINE> f [ b - 1 ] . append ( [ a - 1 , c ] ) <NEWLINE> <DEDENT> from collections import deque <NEWLINE> d = deque ( ) <NEWLINE> s = [ - 1 ] * N <NEWLINE> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> d . append ( K - 1 ) <NEWLINE> s [ K - 1 ] = 0 <NEWLINE> while len ( d ) > 0 : <NEWLINE> <INDENT> z = d . popleft ( ) <NEWLINE> for i , j in f [ z ] : <NEWLINE> <INDENT> if s [ i ] == - 1 : <NEWLINE> <INDENT> s [ i ] = j + s [ z ] <NEWLINE> d . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( s [ x - 1 ] + s [ y - 1 ] ) <NEWLINE> <DEDENT>
<NL> a , b , n = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> score = 0 <NEWLINE> <NL> if n < b : <NEWLINE> <INDENT> print ( int ( a * n / b ) - a * int ( n / b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = b - 1 <NEWLINE> print ( int ( a * n / b ) - a * int ( n / b ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> DifMax = - 9999999999999 <NEWLINE> <NL> R = [ int ( input ( ) ) ] <NEWLINE> RMin = R [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if RMin > R [ i - 1 ] : <NEWLINE> <INDENT> RMin = R [ i - 1 ] <NEWLINE> <DEDENT> R . append ( int ( input ( ) ) ) <NEWLINE> if DifMax < R [ i ] - RMin : <NEWLINE> <INDENT> DifMax = R [ i ] - RMin <NEWLINE> <NL> <DEDENT> <DEDENT> print ( DifMax ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , M = LI ( ) <NEWLINE> AB = [ LI ( ) for _ in range ( N ) ] <NEWLINE> <NL> W = [ [ ] for _ in range ( M + 1 ) ] <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> if 0 <= M - a : <NEWLINE> <INDENT> W [ M - a ] . append ( b ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> hq = [ ] <NEWLINE> for i in reversed ( W ) : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> heapq . heappush ( hq , - j ) <NEWLINE> <DEDENT> if hq : <NEWLINE> <INDENT> ans -= heapq . heappop ( hq ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> p = [ 1 ] * ( l [ - 1 ] + 1 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = l [ i ] <NEWLINE> if p [ a ] == 1 : <NEWLINE> <INDENT> b = a <NEWLINE> while a <= l [ - 1 ] : <NEWLINE> <INDENT> p [ a ] = 0 <NEWLINE> a += b <NEWLINE> <DEDENT> if i < n - 1 : <NEWLINE> <INDENT> if l [ i ] == l [ i + 1 ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a_dict = { } <NEWLINE> <NL> for a in a_list : <NEWLINE> <INDENT> if a in a_dict . keys ( ) : <NEWLINE> <INDENT> a_dict [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_dict [ a ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i + 1 in a_dict . keys ( ) : <NEWLINE> <INDENT> print ( a_dict [ i + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> npA = np . array ( A ) <NEWLINE> <NL> counts = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> <NL> for a in npA : <NEWLINE> <INDENT> counts [ a ] += 1 <NEWLINE> <NL> <DEDENT> ans = np . sum ( npA ) <NEWLINE> <NL> Q = int ( input ( ) ) <NEWLINE> <NL> for q in range ( Q ) : <NEWLINE> <INDENT> diff = 0 <NEWLINE> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if 0 < counts [ B ] : <NEWLINE> <INDENT> diff = ( C - B ) * counts [ B ] <NEWLINE> counts [ C ] += counts [ B ] <NEWLINE> counts [ B ] = 0 <NEWLINE> <NL> <DEDENT> ans += diff <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> a = sorted ( a ) <NEWLINE> <NL> b = [ ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if cnt == 3 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i == j : continue <NEWLINE> b . append ( int ( str ( a [ i ] ) + str ( a [ j ] ) ) ) <NEWLINE> b . append ( int ( str ( a [ j ] ) + str ( a [ i ] ) ) ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> b = sorted ( b ) <NEWLINE> print ( b [ 2 ] ) <NEWLINE> <NL>
from collections import Counter <NEWLINE> n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = Counter ( a ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = sum ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += b [ x ] * ( y - x ) <NEWLINE> print ( ans ) <NEWLINE> b [ y ] += b [ x ] <NEWLINE> b [ x ] = 0 <NEWLINE> <DEDENT>
import sys <NEWLINE> for b in sys . stdin : <NEWLINE> <INDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> c = <STRING> . join ( [ e , chr ( ( ord ( e ) - 96 + i ) % 26 + 97 ) ] [ 96 < ord ( e ) < 123 ] for e in b ) <NEWLINE> if any ( ( <STRING> in c , <STRING> in c , <STRING> in c ) ) : print ( c . strip ( ) ) <NEWLINE> <DEDENT> <DEDENT>
n , x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xi = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> xi = [ abs ( xval - x ) for xval in xi ] <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> res = xi [ 0 ] <NEWLINE> for i in range ( 1 , len ( xi ) ) : <NEWLINE> <INDENT> res = gcd ( res , xi [ i ] ) <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for x in [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] : <NEWLINE> <INDENT> if x in S : <NEWLINE> <INDENT> x_index = S . index ( x ) <NEWLINE> for y in [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] : <NEWLINE> <INDENT> if y in S [ x_index + 1 : ] : <NEWLINE> <INDENT> y_index = S [ x_index + 1 : ] . index ( y ) <NEWLINE> for z in [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] : <NEWLINE> <INDENT> if z in S [ x_index + 1 + y_index + 1 : ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = sum ( A ) <NEWLINE> sumpro = 0 <NEWLINE> <NL> for a in A [ : - 1 ] : <NEWLINE> <INDENT> s -= a <NEWLINE> sumpro += a * s <NEWLINE> <NL> <DEDENT> print ( sumpro % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mem = [ 0 ] * n <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> mem [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in mem : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> counter = 0 <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def cc ( n ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> n = n - i <NEWLINE> ans += 1 <NEWLINE> i += 1 <NEWLINE> if n < i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> s_list = prime_factorize ( N ) <NEWLINE> c = collections . Counter ( s_list ) <NEWLINE> values , counts = zip ( * c . most_common ( ) ) <NEWLINE> j = 0 <NEWLINE> for i in range ( len ( counts ) ) : <NEWLINE> <INDENT> counter += cc ( counts [ i ] ) <NEWLINE> <DEDENT> print ( counter ) <NEWLINE>
import math <NEWLINE> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x == a ** 2 * b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif 2 * x <= ( a ** 2 ) * b : <NEWLINE> <INDENT> print ( math . degrees ( math . atan ( ( b ** 2 ) * a / ( 2 * x ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 90 - math . degrees ( math . atan ( ( a ** 3 ) / ( 2 * ( ( a ** 2 ) * b - x ) ) ) ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> l . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( l ) ) ) <NEWLINE> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> <NL> S = [ ] <NEWLINE> counter = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> S = sorted ( S ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == S [ i + 1 ] : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> <DEDENT> print ( N - counter ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = [ ] <NEWLINE> g = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> <DEDENT> ans = len ( r ) * len ( g ) * len ( b ) <NEWLINE> r . append ( n * 4 ) <NEWLINE> g . append ( n * 4 ) <NEWLINE> b . append ( n * 4 ) <NEWLINE> for i in g : <NEWLINE> <INDENT> for j in b : <NEWLINE> <INDENT> a = i + j <NEWLINE> if a % 2 == 0 and r [ bisect . bisect_left ( r , a // 2 ) ] == a // 2 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in r : <NEWLINE> <INDENT> for j in b : <NEWLINE> <INDENT> a = i + j <NEWLINE> if a % 2 == 0 and g [ bisect . bisect_left ( g , a // 2 ) ] == a // 2 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in g : <NEWLINE> <INDENT> for j in r : <NEWLINE> <INDENT> a = i + j <NEWLINE> if a % 2 == 0 and b [ bisect . bisect_left ( b , a // 2 ) ] == a // 2 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans + 3 ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> from collections import defaultdict <NEWLINE> import queue <NEWLINE> connection = defaultdict ( lambda : defaultdict ( int ) ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> connection [ A - 1 ] [ B - 1 ] = 1 <NEWLINE> connection [ B - 1 ] [ A - 1 ] = 1 <NEWLINE> <NL> <DEDENT> c = defaultdict ( int ) <NEWLINE> q = queue . Queue ( ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> p = defaultdict ( int ) <NEWLINE> <NL> c [ 0 ] = 1 <NEWLINE> d [ 0 ] = 0 <NEWLINE> q . put ( 0 ) <NEWLINE> <NL> while not ( q . empty ( ) ) : <NEWLINE> <INDENT> u = q . get ( ) <NEWLINE> for v in connection [ u ] : <NEWLINE> <INDENT> if c [ v ] == 0 : <NEWLINE> <INDENT> c [ v ] = 1 <NEWLINE> d [ v ] = d [ u ] + 1 <NEWLINE> p [ v ] = u <NEWLINE> q . put ( v ) <NEWLINE> <DEDENT> <DEDENT> c [ u ] = 2 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( p [ i ] + 1 ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 1 or x == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> start , end , loopcnt = 0 , 0 , 0 <NEWLINE> a = { x : 0 } <NEWLINE> wk = x <NEWLINE> for i in range ( 1 , m ) : <NEWLINE> <INDENT> wk = ( wk * wk ) % m <NEWLINE> if not wk in a : <NEWLINE> <INDENT> a [ wk ] = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start = a [ wk ] <NEWLINE> end = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> a = sorted ( a . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> koteiindex = min ( n , start ) <NEWLINE> koteiwa = 0 <NEWLINE> for i in range ( koteiindex ) : <NEWLINE> <INDENT> koteiwa += a [ i ] [ 0 ] <NEWLINE> <DEDENT> loopcnt = ( n - koteiindex ) // ( end - start ) <NEWLINE> loopindex = start - 1 + ( n - koteiindex ) % ( end - start ) <NEWLINE> loopwa = 0 <NEWLINE> amariwa = 0 <NEWLINE> for i in range ( start , end ) : <NEWLINE> <INDENT> if i <= loopindex : <NEWLINE> <INDENT> amariwa += a [ i ] [ 0 ] <NEWLINE> <DEDENT> loopwa += a [ i ] [ 0 ] <NEWLINE> <DEDENT> ans = koteiwa + loopwa * loopcnt + amariwa <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> result = [ 0 ] * ( n + 1 ) <NEWLINE> border = 0 <NEWLINE> if n >= 3 : <NEWLINE> <INDENT> border = int ( math . sqrt ( n - 2 ) ) <NEWLINE> <DEDENT> for x in range ( 1 , border ) : <NEWLINE> <INDENT> for y in range ( 1 , border ) : <NEWLINE> <INDENT> for z in range ( 1 , border ) : <NEWLINE> <INDENT> r = ( ( x + y ) ** 2 + ( y + z ) ** 2 + ( z + x ) ** 2 ) // 2 <NEWLINE> if r > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result [ r ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for num in result [ 1 : : ] : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , ( input ( ) . split ( ) ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> cnt = np . zeros ( 10 ** 6 + 10 , dtype = np . int32 ) <NEWLINE> for x in A : <NEWLINE> <INDENT> if cnt [ x ] != 0 : <NEWLINE> <INDENT> cnt [ x ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> cnt [ x : : x ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for x in A : <NEWLINE> <INDENT> if cnt [ x ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , ( N + i - 1 ) // 2 + 1 ) : <NEWLINE> <INDENT> if set ( [ S [ i ] , S [ j ] , S [ 2 * j - i ] ] ) == { <STRING> , <STRING> , <STRING> } : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> dist = abs ( b - a ) <NEWLINE> mys = v - w <NEWLINE> <NL> if mys * t >= dist : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from decimal import Decimal <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> nums = [ Decimal ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> two_fives = [ ] <NEWLINE> <NL> <NL> for i , num in enumerate ( nums ) : <NEWLINE> <INDENT> int_converted = int ( num * ( 10 ** 9 ) ) <NEWLINE> <NL> two_div_count = 0 <NEWLINE> while int_converted % 2 == 0 : <NEWLINE> <INDENT> two_div_count += 1 <NEWLINE> int_converted //= 2 <NEWLINE> <NL> <DEDENT> five_div_count = 0 <NEWLINE> while int_converted % 5 == 0 : <NEWLINE> <INDENT> five_div_count += 1 <NEWLINE> int_converted //= 5 <NEWLINE> <NL> <DEDENT> two_fives . append ( ( two_div_count , five_div_count ) ) <NEWLINE> <NL> <NL> <DEDENT> ok_count = 0 <NEWLINE> <NL> two_five_exists = np . zeros ( ( 19 , 19 ) , dtype = int ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> two_count , five_count = two_fives [ i ] <NEWLINE> two_count = min ( 18 , two_count ) <NEWLINE> five_count = min ( 18 , five_count ) <NEWLINE> ok_count += two_five_exists [ two_count , five_count ] <NEWLINE> <NL> two_pair = 18 - two_count <NEWLINE> five_pair = 18 - five_count <NEWLINE> two_five_exists [ two_pair : , five_pair : ] += 1 <NEWLINE> <NL> <DEDENT> print ( ok_count ) <NEWLINE> <NL>
d , e = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 2 ) ] <NEWLINE> e [ 3 ] , e [ 4 ] = e [ 4 ] , e [ 3 ] <NEWLINE> t = 0 <NEWLINE> for i in range ( 6 ) : <NEWLINE> <INDENT> m = { 0 : <STRING> , 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> } [ i ] <NEWLINE> f = [ d [ int ( j ) ] for j in m ] ; f [ 3 ] , f [ 4 ] = f [ 4 ] , f [ 3 ] <NEWLINE> if f [ 0 ] == e [ 0 ] : <NEWLINE> <INDENT> f = f [ 1 : 5 ] * 2 <NEWLINE> for j in range ( 4 ) : <NEWLINE> <INDENT> if f [ j : j + 4 ] == e [ 1 : 5 ] : t = 1 ; break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ( <STRING> , <STRING> ) [ t == 1 ] ) <NEWLINE>
import sys , bisect , math , itertools , string , queue , copy <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def inp ( ) : return int ( input ( ) ) <NEWLINE> def inpm ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def inpls ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def inplm ( n ) : return list ( int ( input ( ) ) for _ in range ( n ) ) <NEWLINE> def inplL ( n ) : return [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inplT ( n ) : return [ tuple ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inpll ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> def inplt ( n ) : return [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> def inplls ( n ) : return sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ) <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = inpm ( ) <NEWLINE> AB = inplt ( m ) <NEWLINE> <NL> uf = UnionFind ( n ) <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> uf . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> print ( - min ( uf . parents ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = ( S - h * 3600 ) // 60 <NEWLINE> s = S - h * 3600 - m * 60 <NEWLINE> print ( <STRING> . format ( h , m , s ) ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( <STRING> ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> M = [ int ( m ) for m in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= n or m > sum ( A ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - A [ i ] ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for m in M : <NEWLINE> <INDENT> if solve ( 0 , m ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> for a in range ( K ) : <NEWLINE> <INDENT> sum += a + 1 <NEWLINE> <COMMENT> <NL> for b in range ( K ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> gcd2_sum = math . gcd ( a + 1 , b + 1 ) * 3 * 2 <NEWLINE> sum += gcd2_sum <NEWLINE> <COMMENT> <NL> for c in range ( K ) : <NEWLINE> <INDENT> if b < c : <NEWLINE> <INDENT> gcd3_sum = math . gcd ( math . gcd ( a + 1 , b + 1 ) , c + 1 ) * 6 <NEWLINE> sum += gcd3_sum <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
l = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> s = input ( ) <NEWLINE> print ( l [ l . index ( s ) + 1 ] ) <NEWLINE>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P , CP = [ ] , [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> P . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> CP . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> a , b = P [ i ] [ 0 ] , P [ i ] [ 1 ] <NEWLINE> now = 10 ** 10 <NEWLINE> for j in reversed ( range ( M ) ) : <NEWLINE> <INDENT> c , d = CP [ j ] [ 0 ] , CP [ j ] [ 1 ] <NEWLINE> distance = abs ( a - c ) + abs ( b - d ) <NEWLINE> if distance <= now : <NEWLINE> <INDENT> result = j + 1 <NEWLINE> now = distance <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> k = int ( input ( ) ) + 1 <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , k ) : <NEWLINE> <INDENT> for b in range ( 1 , k ) : <NEWLINE> <INDENT> d = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k ) : <NEWLINE> <INDENT> ans += math . gcd ( d , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> bord_x , bord_y = [ 0 ] * h , [ 0 ] * w <NEWLINE> <NL> hw = [ ] <NEWLINE> for _i in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> s -= 1 <NEWLINE> t -= 1 <NEWLINE> bord_x [ s ] += 1 <NEWLINE> bord_y [ t ] += 1 <NEWLINE> hw . append ( [ s , t ] ) <NEWLINE> <NL> <DEDENT> x_max , y_max = max ( bord_x ) , max ( bord_y ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i , j in hw : <NEWLINE> <INDENT> if bord_x [ i ] == x_max and bord_y [ j ] == y_max : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt == bord_x . count ( x_max ) * bord_y . count ( y_max ) : <NEWLINE> <INDENT> x_max -= 1 <NEWLINE> <NL> <DEDENT> print ( x_max + y_max ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a >= 0 ) and ( b >= 0 ) and ( c >= 0 ) and ( d >= 0 ) : <COMMENT> <NEWLINE> <INDENT> ans = b * d <NEWLINE> <DEDENT> elif ( b <= 0 ) and ( d <= 0 ) : <COMMENT> <NEWLINE> <INDENT> ans = a * c <NEWLINE> <DEDENT> elif ( a <= 0 ) and ( b >= 0 ) and ( c <= 0 ) and ( d >= 0 ) : <COMMENT> <NEWLINE> <INDENT> tmp1 = a * c <NEWLINE> tmp2 = b * d <NEWLINE> if tmp1 > tmp2 : <NEWLINE> <INDENT> ans = tmp1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = tmp2 <NEWLINE> <DEDENT> <DEDENT> elif ( a >= 0 ) and ( b >= 0 ) and ( d <= 0 ) : <COMMENT> <NEWLINE> <INDENT> ans = a * d <NEWLINE> <DEDENT> elif ( c >= 0 ) and ( d >= 0 ) and ( b <= 0 ) : <COMMENT> <NEWLINE> <INDENT> ans = b * c <NEWLINE> <DEDENT> elif ( a <= 0 ) and ( b >= 0 ) and ( c <= 0 ) and ( d <= 0 ) : <COMMENT> <NEWLINE> <INDENT> ans = a * c <NEWLINE> <DEDENT> elif ( a <= 0 ) and ( b <= 0 ) and ( c <= 0 ) and ( d >= 0 ) : <COMMENT> <NEWLINE> <INDENT> ans = a * c <NEWLINE> <DEDENT> elif ( a >= 0 ) and ( b >= 0 ) and ( c <= 0 ) and ( d >= 0 ) : <COMMENT> <NEWLINE> <INDENT> ans = b * d <NEWLINE> <DEDENT> elif ( a <= 0 ) and ( b >= 0 ) and ( c >= 0 ) and ( d >= 0 ) : <COMMENT> <NEWLINE> <INDENT> ans = b * d <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def power ( n , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if m % 2 == 0 : <NEWLINE> <INDENT> return power ( n * n % 1000000007 , m // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return n * power ( n , m - 1 ) % 1000000007 <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( power ( n , m ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> res = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> res [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , res ) ) ) <NEWLINE>
import collections <NEWLINE> H , W , * S = open ( 0 ) . read ( ) . split ( ) <NEWLINE> H , W = [ int ( _ ) for _ in [ H , W ] ] <NEWLINE> dist = [ [ float ( <STRING> ) ] * W for _ in range ( H ) ] <NEWLINE> dist [ 0 ] [ 0 ] = 0 <NEWLINE> Q = collections . deque ( [ 0 ] ) <NEWLINE> while True : <NEWLINE> <INDENT> if not Q : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i = Q . popleft ( ) <NEWLINE> x , y = divmod ( i , W ) <NEWLINE> d = dist [ x ] [ y ] <NEWLINE> for dx , dy in ( ( 1 , 0 ) , ( 0 , 1 ) ) : <NEWLINE> <INDENT> nx , ny = x + dx , y + dy <NEWLINE> if 0 <= nx < H and 0 <= ny < W : <NEWLINE> <INDENT> if S [ nx ] [ ny ] == <STRING> and S [ x ] [ y ] == <STRING> : <NEWLINE> <INDENT> if dist [ nx ] [ ny ] > d + 1 : <NEWLINE> <INDENT> dist [ nx ] [ ny ] = d + 1 <NEWLINE> Q += [ nx * W + ny ] <NEWLINE> <DEDENT> <DEDENT> elif dist [ nx ] [ ny ] > d : <NEWLINE> <INDENT> dist [ nx ] [ ny ] = d <NEWLINE> Q += [ nx * W + ny ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = dist [ - 1 ] [ - 1 ] <NEWLINE> if S [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import types <NEWLINE> <NL> _atcoder_code = <STRING> <NEWLINE> <NL> atcoder = types . ModuleType ( <STRING> ) <NEWLINE> exec ( _atcoder_code , atcoder . __dict__ ) <NEWLINE> <NL> _atcoder_dsu_code = <STRING> <NEWLINE> <NL> atcoder . dsu = types . ModuleType ( <STRING> ) <NEWLINE> exec ( _atcoder_dsu_code , atcoder . dsu . __dict__ ) <NEWLINE> DSU = atcoder . dsu . DSU <NEWLINE> <NL> import sys <NEWLINE> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> d = DSU ( N ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> d . merge ( A - 1 , B - 1 ) <NEWLINE> <NL> <DEDENT> print ( len ( d . groups ( ) ) - 1 ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = Counter ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MAX = 1000000 + 9 <NEWLINE> dp = [ True ] * MAX <NEWLINE> for num in a : <NEWLINE> <INDENT> for i in range ( num * 2 , MAX , num ) : <NEWLINE> <INDENT> dp [ i ] = False <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for num in a : <NEWLINE> <INDENT> if dp [ num ] and a [ num ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> hs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = [ 1 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if hs [ a - 1 ] <= hs [ b - 1 ] : <NEWLINE> <INDENT> d [ a - 1 ] = 0 <NEWLINE> <DEDENT> if hs [ a - 1 ] >= hs [ b - 1 ] : <NEWLINE> <INDENT> d [ b - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( d . count ( 1 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> dict = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] not in dict : <NEWLINE> <INDENT> dict [ S [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( len ( dict ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = { } <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> d [ i ] = 0 <NEWLINE> <DEDENT> l = [ 1 ] <NEWLINE> x = 1 <NEWLINE> if n >= k : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> x = a [ x - 1 ] <NEWLINE> <DEDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> x = a [ x - 1 ] <NEWLINE> if d [ x ] == 1 : <NEWLINE> <INDENT> k -= l . index ( x ) <NEWLINE> print ( l [ l . index ( x ) : ] [ k % ( l . index ( x ) - len ( l ) ) ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> l . append ( x ) <NEWLINE> d [ x ] += 1 <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> INPUT = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> if 0 in INPUT : <NEWLINE> <INDENT> output = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> output = 1 <NEWLINE> for i in INPUT : <NEWLINE> <INDENT> output = output * i <NEWLINE> <NL> if output > 10 ** 18 : <NEWLINE> <INDENT> output = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( output ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> import time <NEWLINE> START = time . time ( ) <NEWLINE> LIMIT = START + 1.9 <NEWLINE> <NL> from sys import stdin <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from copy import deepcopy <NEWLINE> <COMMENT> <NL> from numpy import random as np_random <NEWLINE> <COMMENT> <NL> import random <NEWLINE> input = stdin . readline <NEWLINE> <NL> CONTEST_NUM = 26 <NEWLINE> INFTY = 10 ** 9 <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> cc = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ss = [ [ 0 ] * ( CONTEST_NUM + 1 ) for _ in range ( D ) ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> ss [ i ] = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> last_day = [ - 1 ] * ( CONTEST_NUM + 1 ) <NEWLINE> content = 0 <NEWLINE> <NL> def count_discontent ( content , date ) : <NEWLINE> <INDENT> for contest in range ( 1 , CONTEST_NUM + 1 ) : <NEWLINE> <INDENT> content -= cc [ contest ] * ( date - last_day [ contest ] ) <NEWLINE> <DEDENT> return content <NEWLINE> <NL> <DEDENT> def greedy_decide_contest ( date ) : <NEWLINE> <INDENT> point = - INFTY <NEWLINE> for contest in range ( 1 , CONTEST_NUM + 1 ) : <NEWLINE> <INDENT> get_point = ss [ date ] [ contest ] + cc [ contest ] * ( date - last_day [ contest ] ) <NEWLINE> if get_point > point : <NEWLINE> <INDENT> point = get_point <NEWLINE> t = contest <NEWLINE> <DEDENT> <DEDENT> return t <NEWLINE> <NL> <DEDENT> tt = [ 0 ] * D <NEWLINE> for date in range ( D ) : <NEWLINE> <COMMENT> <NL> <INDENT> t = greedy_decide_contest ( date ) <NEWLINE> tt [ date ] = t <NEWLINE> content += ss [ date ] [ t ] <NEWLINE> last_day [ t ] = date <NEWLINE> content = count_discontent ( content , date ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> best_content = content <NEWLINE> best_tt = deepcopy ( tt ) <NEWLINE> <NL> P = 0.1 <NEWLINE> <NL> while time . time ( ) <= LIMIT : <NEWLINE> <INDENT> content = 0 <NEWLINE> tt = [ 0 ] * ( D ) <NEWLINE> for date in range ( D ) : <NEWLINE> <INDENT> if np_random . binomial ( 1 , P ) : <NEWLINE> <INDENT> t = random . randint ( 1 , CONTEST_NUM ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = greedy_decide_contest ( date ) <NEWLINE> <DEDENT> tt [ date ] = t <NEWLINE> content += ss [ date ] [ t ] <NEWLINE> last_day [ t ] = date <NEWLINE> content = count_discontent ( content , date ) <NEWLINE> <DEDENT> if content > best_content : <NEWLINE> <INDENT> best_content = content <NEWLINE> best_tt = deepcopy ( tt ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for t in tt : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <NL> <NL> <DEDENT> <STRING> <NEWLINE> <NL> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> req = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> uf = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> uf . union ( req [ i ] [ 0 ] - 1 , req [ i ] [ 1 ] - 1 ) <NEWLINE> <NL> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> List = [ ] <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> List += [ input ( ) ] <NEWLINE> <DEDENT> print ( len ( set ( List ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> lst = [ [ 0 for _ in range ( 25 ) ] for _ in range ( 25 ) ] <NEWLINE> int_cnt = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if <STRING> in a : <NEWLINE> <INDENT> pos = a . index ( <STRING> ) <NEWLINE> a1 , a2 = a [ : pos ] , a [ pos + 1 : ] <NEWLINE> l = len ( a2 ) <NEWLINE> a = a1 + a2 <NEWLINE> a = int ( a ) <NEWLINE> a *= 10 ** ( 9 - l ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( a ) <NEWLINE> int_cnt += 1 <NEWLINE> a *= 10 ** 9 <NEWLINE> <DEDENT> t = 0 <NEWLINE> while a % 2 == 0 : <NEWLINE> <INDENT> t += 1 <NEWLINE> a //= 2 <NEWLINE> <DEDENT> f = 0 <NEWLINE> while a % 5 == 0 : <NEWLINE> <INDENT> f += 1 <NEWLINE> a //= 5 <NEWLINE> <DEDENT> t = min ( t , 24 ) <NEWLINE> f = min ( f , 24 ) <NEWLINE> lst [ t ] [ f ] += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 25 ) : <NEWLINE> <INDENT> for j in range ( 25 ) : <NEWLINE> <INDENT> for k in range ( 25 ) : <NEWLINE> <INDENT> for l in range ( 25 ) : <NEWLINE> <INDENT> if i + j >= 18 and k + l >= 18 : <NEWLINE> <INDENT> if i == j and k == l : <NEWLINE> <INDENT> tmp = lst [ i ] [ k ] <NEWLINE> ans += tmp * ( tmp - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += lst [ i ] [ k ] * lst [ j ] [ l ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
import sys <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N , M , * X = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> if N >= M : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> X . sort ( ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( M - 1 ) : <NEWLINE> <INDENT> ans . append ( abs ( X [ i + 1 ] - X [ i ] ) ) <NEWLINE> <NL> <DEDENT> ans . sort ( reverse = True ) <NEWLINE> print ( X [ - 1 ] - X [ 0 ] - sum ( ans [ : N - 1 ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = sum ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += a [ i ] * ( b - a [ i ] ) <NEWLINE> b = b - a [ i ] <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 998244353 <NEWLINE> dd = [ ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) ] <NEWLINE> ddn = [ ( 0 , - 1 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 0 , 1 ) , ( - 1 , - 1 ) , ( - 1 , 0 ) , ( - 1 , 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> N , M , L , K , A , H = LI ( ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> S = set ( ) <NEWLINE> if L > 0 : <NEWLINE> <INDENT> S = set ( LI ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input ( ) <NEWLINE> <DEDENT> e = collections . defaultdict ( list ) <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> a , b , d = LI ( ) <NEWLINE> e [ a ] . append ( ( b , d ) ) <NEWLINE> e [ b ] . append ( ( a , d ) ) <NEWLINE> <NL> <DEDENT> def search ( s ) : <NEWLINE> <INDENT> d = collections . defaultdict ( lambda : inf ) <NEWLINE> d [ ( - M , s ) ] = 0 <NEWLINE> q = [ ] <NEWLINE> heapq . heappush ( q , ( 0 , - M , s ) ) <NEWLINE> v = collections . defaultdict ( bool ) <NEWLINE> while len ( q ) : <NEWLINE> <INDENT> k , m , u = heapq . heappop ( q ) <NEWLINE> if v [ ( m , u ) ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for mm in range ( m , 1 ) : <NEWLINE> <INDENT> v [ ( mm , u ) ] = True <NEWLINE> <NL> <DEDENT> for uv , ud in e [ u ] : <NEWLINE> <INDENT> if ud > - m or v [ ( m + ud , uv ) ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> vd = k + ud <NEWLINE> vm = m + ud <NEWLINE> if uv in S : <NEWLINE> <INDENT> vm = - M <NEWLINE> <DEDENT> if d [ ( vm , uv ) ] > vd : <NEWLINE> <INDENT> d [ ( vm , uv ) ] = vd <NEWLINE> heapq . heappush ( q , ( vd , vm , uv ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> d = search ( A ) <NEWLINE> r = inf <NEWLINE> for k in list ( d . keys ( ) ) : <NEWLINE> <INDENT> if k [ 1 ] == H and r > d [ k ] : <NEWLINE> <INDENT> r = d [ k ] <NEWLINE> <DEDENT> <DEDENT> if r == inf : <NEWLINE> <INDENT> rr . append ( <STRING> ) <NEWLINE> <DEDENT> elif r <= M : <NEWLINE> <INDENT> rr . append ( r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rr . append ( r * 2 - M ) <NEWLINE> <NL> <DEDENT> <DEDENT> return <STRING> . join ( map ( str , rr ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL> <NL>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s . append ( list ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> dx = [ - 1 , 0 , 1 , - 1 , 1 , - 1 , 0 , 1 ] <NEWLINE> dy = [ 1 , 1 , 1 , 0 , 0 , - 1 , - 1 , - 1 ] <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for t in range ( 8 ) : <NEWLINE> <INDENT> ni = i + dx [ t ] <NEWLINE> nj = j + dy [ t ] <NEWLINE> if ni < 0 or h <= ni : continue <NEWLINE> if nj < 0 or w <= nj : continue <NEWLINE> if s [ ni ] [ nj ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> s [ i ] [ j ] = str ( cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in s : <NEWLINE> <INDENT> print ( <STRING> . join ( i ) ) <NEWLINE> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> ch = k % 2 <NEWLINE> ans = abs ( x ) <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> if ( cnt % 2 ) == ch : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( d ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if x > 0 : <NEWLINE> <INDENT> if x // d > k : <NEWLINE> <INDENT> print ( x - k * d ) <NEWLINE> break <NEWLINE> <DEDENT> cnt += x // d <NEWLINE> x -= d * ( x // d ) <NEWLINE> xx = x - d <NEWLINE> if cnt % 2 == ch : <NEWLINE> <INDENT> print ( abs ( x ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( xx ) ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> elif x < 0 : <NEWLINE> <INDENT> if abs ( x ) // d > k : <NEWLINE> <INDENT> print ( abs ( x + k * d ) ) <NEWLINE> break <NEWLINE> <DEDENT> cnt += abs ( x ) // d <NEWLINE> x += d * ( abs ( x ) // d ) <NEWLINE> xx = x + d <NEWLINE> if cnt % 2 == ch : <NEWLINE> <INDENT> print ( abs ( x ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( xx ) ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT>
def fennec_vs_monster ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> H . sort ( reverse = True ) <NEWLINE> <COMMENT> <NL> H = H [ K : ] <NEWLINE> <COMMENT> <NL> sum_H = sum ( H ) <NEWLINE> <COMMENT> <NL> return sum_H <NEWLINE> <NL> <DEDENT> result = fennec_vs_monster ( ) <NEWLINE> print ( result ) <NEWLINE>
[ N , M ] = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> A = sorted ( A , reverse = True ) <NEWLINE> <NL> if ( A [ M - 1 ] < ( sum ( A ) * 1 / ( 4 * M ) ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> B [ A . pop ( ) - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( B [ i ] ) <NEWLINE> <DEDENT>
ni = lambda : int ( input ( ) ) <NEWLINE> nm = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> from math import log10 <NEWLINE> <NL> n , k = nm ( ) <NEWLINE> a = nl ( ) <NEWLINE> b = [ 1 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b [ i + 1 ] = log10 ( a [ i ] ) + b [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( n - k ) : <NEWLINE> <INDENT> if b [ i + k + 1 ] - b [ i + 1 ] > b [ i + k ] - b [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> a = 7 <NEWLINE> i = K <NEWLINE> while i > 0 : <NEWLINE> <INDENT> m = a % K <NEWLINE> if m == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> a = m * 10 + 7 <NEWLINE> i -= 1 <NEWLINE> <DEDENT> <DEDENT> if m != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 0 <NEWLINE> ab = 0 <NEWLINE> ac = 0 <NEWLINE> b = [ 0 ] * ( 10 ** 5 + 10 ) <NEWLINE> c = [ 0 ] * ( 10 ** 5 + 10 ) <NEWLINE> d = [ 0 ] * ( 10 ** 5 + 10 ) <NEWLINE> e = [ 0 ] * ( 10 ** 5 + 10 ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if v [ i ] == v [ i + 1 ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> if ( a == n - 1 ) : <NEWLINE> <INDENT> print ( int ( n / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , n , 2 ) : <NEWLINE> <INDENT> b [ v [ i ] ] = b [ v [ i ] ] + 1 <NEWLINE> <DEDENT> for j in range ( 1 , n + 1 , 2 ) : <NEWLINE> <INDENT> c [ v [ j ] ] = c [ v [ j ] ] + 1 <NEWLINE> <DEDENT> d = sorted ( b , reverse = True ) <NEWLINE> e = sorted ( c , reverse = True ) <NEWLINE> for s in range ( 10 ** 5 + 1 ) : <NEWLINE> <INDENT> if ( d [ 0 ] == b [ s ] ) : <NEWLINE> <INDENT> ab = s <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for t in range ( 10 ** 5 + 1 ) : <NEWLINE> <INDENT> if ( e [ 0 ] == c [ t ] ) : <NEWLINE> <INDENT> ac = t <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( s == t ) : <NEWLINE> <INDENT> print ( min ( 2 * int ( n / 2 ) - d [ 0 ] - e [ 1 ] , 2 * int ( n / 2 ) - d [ 1 ] - e [ 0 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = int ( n / 2 ) - d [ 0 ] <NEWLINE> g = int ( n / 2 ) - e [ 0 ] <NEWLINE> print ( f + g ) <NEWLINE> <DEDENT> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if s - x - y <= k and s - x - y >= 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> y = n // i <NEWLINE> ans += y * ( y + 1 ) * i // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> z = list ( range ( 1 , n + 1 ) ) <NEWLINE> a = list ( itertools . combinations ( z , 3 ) ) <NEWLINE> b = [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> b += [ sum ( i ) ] <NEWLINE> <DEDENT> print ( b . count ( x ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> st = [ ] <NEWLINE> ch = [ ] <NEWLINE> def mht ( ax , ay , bx , by ) : <NEWLINE> <INDENT> return abs ( ax - bx ) + abs ( ay - by ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> st . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> ch . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in st : <NEWLINE> <INDENT> ax = i [ 0 ] <NEWLINE> ay = i [ 1 ] <NEWLINE> mn = 1000000000 <NEWLINE> for ( j , k ) in zip ( ch , range ( len ( ch ) ) ) : <NEWLINE> <INDENT> bx = j [ 0 ] <NEWLINE> by = j [ 1 ] <NEWLINE> mh = mht ( ax , ay , bx , by ) <NEWLINE> if mh < mn : <NEWLINE> <INDENT> mn = mh <NEWLINE> nm = k <NEWLINE> <DEDENT> <DEDENT> print ( nm + 1 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> N_list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> res = 1 <NEWLINE> <NL> if ( N_list . count ( 0 ) > 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in range ( len ( N_list ) ) : <NEWLINE> <INDENT> res = res * N_list [ i ] <NEWLINE> if ( res > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> dp = a [ : 2 ] <NEWLINE> for i in range ( 1 , n // 2 ) : <NEWLINE> <INDENT> dp = dp [ 0 ] + a [ 2 * i ] , max ( dp ) + a [ 2 * i + 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp = a [ : 3 ] <NEWLINE> for i in range ( 1 , n // 2 ) : <NEWLINE> <INDENT> dp = dp [ 0 ] + a [ 2 * i ] , max ( dp [ : 2 ] ) + a [ 2 * i + 1 ] , max ( dp ) + a [ 2 * i + 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( dp ) ) <NEWLINE>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import sys , math , os <NEWLINE> <NL> <COMMENT> <NL> PYDEV = os . environ . get ( <STRING> ) <NEWLINE> if PYDEV == <STRING> : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> pi = math . pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> % ( pi * r ** 2 , 2 * pi * r ) ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - x - y <= k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from math import gcd <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> d = sorted ( list ( ( input ( ) ) for _ in range ( N ) ) ) <NEWLINE> count = 0 <NEWLINE> dum = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if d [ i ] != dum : <NEWLINE> <INDENT> dum = d [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from math import gcd <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> g = gcd ( n , m ) <NEWLINE> ans = n * m // g <NEWLINE> <NL> <STRING> <NEWLINE> for i in range ( g ) : <NEWLINE> <INDENT> if not s [ i * n // g ] == t [ i * m // g ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 10 == 3 or ( i % 100 ) // 10 == 3 or ( i % 1000 ) // 100 == 3 or ( i % 10000 ) // 1000 == 3 : <NEWLINE> <INDENT> a . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * a ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> k = n // i <NEWLINE> ans += i * ( k * ( k + 1 ) // 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lis = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lis [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> import collections <NEWLINE> <NL> ans = 0 <NEWLINE> lis = collections . Counter ( lis ) <NEWLINE> <NL> for i in lis . values ( ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections as col <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> List = col . Counter ( List ) <NEWLINE> Count_List = [ 0 ] * n <NEWLINE> for i in List : <NEWLINE> <INDENT> Count_List [ i - 1 ] = List [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( 0 , len ( Count_List ) ) : <NEWLINE> <INDENT> print ( Count_List [ i ] ) <NEWLINE> <DEDENT>
<NL> <STRING> <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> d = n // i <NEWLINE> ans += i * d * ( d + 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
N , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> dic = { } <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if a in dic : <NEWLINE> <INDENT> dic [ a ] += b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ a ] = b <NEWLINE> <NL> <DEDENT> <DEDENT> dic = sorted ( dic . items ( ) ) <NEWLINE> <NL> for i in range ( len ( dic ) ) : <NEWLINE> <INDENT> sum += dic [ i ] [ 1 ] <NEWLINE> if K <= sum : <NEWLINE> <INDENT> print ( dic [ i ] [ 0 ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
def isPrime ( x ) : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if x < 2 or x % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i , root_x = 3 , int ( pow ( x , 0.5 ) ) <NEWLINE> while i <= root_x : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i += 2 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> primes = [ 2 ] <NEWLINE> for i in range ( 3 , 104730 ) : <NEWLINE> <INDENT> if isPrime ( i ) : <NEWLINE> <INDENT> primes . append ( primes [ - 1 ] + i ) <NEWLINE> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( primes [ n - 1 ] ) <NEWLINE> <DEDENT>
values = [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> values . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> top3 = [ ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> Max = max ( values ) <NEWLINE> top3 . append ( Max ) <NEWLINE> values . remove ( Max ) <NEWLINE> <NL> <DEDENT> for x in top3 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> stopFlag = 0 <NEWLINE> for i in range ( - 201 , 201 ) : <NEWLINE> <INDENT> a = i <NEWLINE> for j in range ( - 201 , 201 ) : <NEWLINE> <INDENT> if a ** 5 - j ** 5 == X : <NEWLINE> <INDENT> print ( a , j ) <NEWLINE> stopFlag = 1 <NEWLINE> <DEDENT> if stopFlag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if stopFlag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( input ( ) . split ( ) ) <NEWLINE> A = [ int ( A [ i ] ) for i in range ( N + 1 ) ] <NEWLINE> MAX = [ 1 for i in range ( N + 1 ) ] <NEWLINE> A_inter = list ( reversed ( list ( itertools . accumulate ( reversed ( A ) ) ) ) ) <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if A [ i ] > MAX [ i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif i != N : <NEWLINE> <INDENT> MAX [ i + 1 ] = ( MAX [ i ] - A [ i ] ) * 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( [ min ( MAX [ i ] , A_inter [ i ] ) for i in range ( N + 1 ) ] ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( B - 1 , N ) <NEWLINE> print ( A * x // B - A * ( x // B ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> ul = pow ( 10 , 18 ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> for x in a : <NEWLINE> <INDENT> ans *= x <NEWLINE> if ans > ul : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> K = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> s = 0 <NEWLINE> d = 0 <NEWLINE> e = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( a , K + 1 ) : <NEWLINE> <INDENT> for c in range ( b , K + 1 ) : <NEWLINE> <INDENT> d = math . gcd ( c , b ) <NEWLINE> e = math . gcd ( a , d ) <NEWLINE> if a == b and b == c : <NEWLINE> <INDENT> s += e <NEWLINE> <DEDENT> elif a != b and b != c : <NEWLINE> <INDENT> s += 6 * e <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += 3 * e <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = set ( nums ) <NEWLINE> if 0 in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> ans = 1 <NEWLINE> bound = 10 ** 18 <NEWLINE> for num in nums : <NEWLINE> <INDENT> ans *= num <NEWLINE> if ans > bound : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <DEDENT> S = set ( S ) <NEWLINE> print ( len ( S ) ) <NEWLINE>
Q = int ( input ( ) ) <NEWLINE> <NL> def solve ( x , ans ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if len ( x ) == 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> return <NEWLINE> <DEDENT> ret = 0 <NEWLINE> for i in range ( 1 , len ( x ) ) : <NEWLINE> <INDENT> n = int ( x [ i : ] ) * int ( x [ : i ] ) <NEWLINE> ret = max ( ret , n ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> return solve ( str ( ret ) , ans + 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> solve ( input ( ) , 0 ) <NEWLINE> <NL> <DEDENT>
H = int ( input ( ) ) <NEWLINE> def f ( H ) : <NEWLINE> <INDENT> if H == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif H > 1 : <NEWLINE> <INDENT> return 2 * f ( H // 2 ) + 1 <NEWLINE> <DEDENT> <DEDENT> re = 0 <NEWLINE> re = f ( H ) <NEWLINE> print ( re ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> x = 1 <NEWLINE> y = 1 <NEWLINE> z = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> f = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if f > n : <NEWLINE> <INDENT> if z > 1 : <NEWLINE> <INDENT> y += 1 <NEWLINE> z = 1 <NEWLINE> <DEDENT> elif y > 1 : <NEWLINE> <INDENT> x += 1 <NEWLINE> y = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans [ f ] += 1 <NEWLINE> z += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> abc = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a = list ( input ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> a = str ( a ) <NEWLINE> abc . append ( a ) <NEWLINE> <NL> <DEDENT> c = collections . Counter ( abc ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in c : <NEWLINE> <INDENT> num = c [ i ] <NEWLINE> if num != 1 : <NEWLINE> <INDENT> cnt += num * ( num - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def find ( x ) : <NEWLINE> <INDENT> if par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if x < y : x , y = y , x <NEWLINE> par [ x ] = y <NEWLINE> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> par = [ i for i in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> i , j = map ( int , input ( ) . split ( ) ) <NEWLINE> unite ( i , j ) <NEWLINE> <DEDENT> ans = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> find ( i ) <NEWLINE> <DEDENT> for i in par : <NEWLINE> <INDENT> ans [ i ] += 1 <NEWLINE> <DEDENT> print ( max ( ans ) ) <NEWLINE>
<COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> a , b = [ list ( i ) for i in zip ( * ab ) ] <NEWLINE> result = [ ] <NEWLINE> for i in ab : <NEWLINE> <INDENT> if h [ i [ 0 ] - 1 ] > h [ i [ 1 ] - 1 ] : <NEWLINE> <INDENT> result . append ( i [ 1 ] ) <NEWLINE> <DEDENT> elif h [ i [ 1 ] - 1 ] > h [ i [ 0 ] - 1 ] : <NEWLINE> <INDENT> result . append ( i [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( i [ 0 ] ) <NEWLINE> result . append ( i [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> result = list ( set ( result ) ) <NEWLINE> print ( n - len ( result ) ) <NEWLINE>
R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for r in range ( min ( 3000 , 3000 // R ) + 1 ) : <NEWLINE> <INDENT> if R * r <= N : <NEWLINE> <INDENT> for g in range ( min ( 3000 , 3000 // G ) + 1 ) : <NEWLINE> <INDENT> v = R * r + G * g <NEWLINE> if N >= v and ( N - v ) % B == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> m = max ( a ) + 1 <NEWLINE> c = [ 0 ] * m <NEWLINE> for x in a : <NEWLINE> <INDENT> for i in range ( x , m , x ) : <NEWLINE> <INDENT> if c [ i ] < 2 : c [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if c [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> S = V - W <NEWLINE> d = abs ( A - B ) <NEWLINE> if S <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif d <= T * S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> s = r ** 2 * math . pi <NEWLINE> l = 2 * r * math . pi <NEWLINE> print ( <STRING> . format ( s , l ) ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> if A [ k + i ] > A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> N , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> P = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> prev_K_sum = max_K_sum = sum ( P [ : K ] ) <NEWLINE> start = 0 <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> cur_K_sum = prev_K_sum - P [ i ] + P [ i + K ] <NEWLINE> if cur_K_sum > max_K_sum : <NEWLINE> <INDENT> start = i + 1 <NEWLINE> max_K_sum = cur_K_sum <NEWLINE> <DEDENT> prev_K_sum = cur_K_sum <NEWLINE> <DEDENT> target = P [ start : start + K ] <NEWLINE> ans = sum ( [ ( num + 1 ) / 2.0 for num in target ] ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
def abc144_e ( ) : <NEWLINE> <INDENT> import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> F = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> A = np . sort ( A ) <NEWLINE> F = np . sort ( F ) [ : : - 1 ] <NEWLINE> <NL> low = - 1 <NEWLINE> up = 10 ** 12 <NEWLINE> while up - low > 1 : <NEWLINE> <INDENT> v = ( up + low ) // 2 <NEWLINE> x = A - v // F <NEWLINE> if x [ x > 0 ] . sum ( ) > K : <NEWLINE> <INDENT> low = v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> up = v <NEWLINE> <DEDENT> <DEDENT> print ( up ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> abc144_e ( ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( b - 1 , n ) <NEWLINE> print ( a * x // b - a * ( x // b ) ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N = ( int ( input ( ) ) + 1 ) // 2 * 2 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 0 , N , 2 ) : <NEWLINE> <INDENT> if A [ i ] % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in nums : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= nums [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> A = list ( input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , A ) ) <NEWLINE> A = sorted ( A , reverse = True ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> try : <NEWLINE> <INDENT> while len ( A ) != 0 : <NEWLINE> <INDENT> a += A . pop ( 0 ) <NEWLINE> b += A . pop ( 0 ) <NEWLINE> <DEDENT> print ( a - b ) <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import itertools <NEWLINE> import bisect <NEWLINE> <NL> n , m , k = map ( int , ( input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . insert ( 0 , 0 ) <NEWLINE> b . insert ( 0 , 0 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> a_cumsum = list ( itertools . accumulate ( a ) ) <NEWLINE> b_cumsum = list ( itertools . accumulate ( b ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> books = [ ] <NEWLINE> <NL> <NL> <COMMENT> <NL> for i in range ( len ( a_cumsum ) ) : <NEWLINE> <INDENT> minutes = 0 <NEWLINE> numbers = 0 <NEWLINE> <NL> a_minutes = a_cumsum [ i ] <NEWLINE> minutes += a_minutes <NEWLINE> <NL> if minutes <= k : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> numbers += i <NEWLINE> <NL> <COMMENT> <NL> rest_minutes = k - a_minutes <NEWLINE> <NL> <COMMENT> <NL> if b_cumsum [ - 1 ] == rest_minutes : <NEWLINE> <INDENT> b_books = len ( b_cumsum ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> b_books = bisect . bisect_right ( b_cumsum , rest_minutes ) <NEWLINE> b_books -= 1 <NEWLINE> <NL> <DEDENT> numbers += b_books <NEWLINE> <NL> <DEDENT> books . append ( numbers ) <NEWLINE> <NL> <DEDENT> print ( max ( books ) ) <NEWLINE>
<NL> n = map ( int , input ( ) ) <NEWLINE> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> INF = 1e18 <NEWLINE> ans = 1 <NEWLINE> <NL> for d in data : <NEWLINE> <INDENT> ans = ans * d <NEWLINE> if ans > INF : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 in data : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def f ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> now = 1 <NEWLINE> <NL> for i in range ( k . bit_length ( ) ) : <NEWLINE> <INDENT> if k % 2 : now = l [ now - 1 ] <NEWLINE> l = [ l [ l [ i ] - 1 ] for i in range ( n ) ] <NEWLINE> k //= 2 <NEWLINE> <DEDENT> print ( now ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> f ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> sum_num = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( j , i ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> s = math . gcd ( l , tmp ) <NEWLINE> sum_num += s <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum_num ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( 1 , n + 1 , 1 ) : <NEWLINE> <INDENT> y = int ( n / x ) <NEWLINE> ans += y * ( y + 1 ) * x / 2 <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S_list = [ ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> S_list . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( S_list ) ) ) <NEWLINE>
class DataSet : <NEWLINE> <INDENT> def __init__ ( self , x , y ) : <NEWLINE> <INDENT> self . x = x <NEWLINE> self . y = y <NEWLINE> <NL> <DEDENT> def swap ( self ) : <NEWLINE> <INDENT> temp = self . y <NEWLINE> self . y = self . x <NEWLINE> self . x = temp <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> data = [ ] <NEWLINE> while 1 : <NEWLINE> <COMMENT> <NL> <INDENT> n = input ( ) . split ( ) <NEWLINE> x = int ( n [ 0 ] ) <NEWLINE> y = int ( n [ 1 ] ) <NEWLINE> <NL> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> data . append ( DataSet ( x , y ) ) <NEWLINE> <NL> <DEDENT> length = len ( data ) <NEWLINE> what_large = length > 3000 <NEWLINE> <NL> if what_large : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( data ) ) : <NEWLINE> <INDENT> d_val = data [ i ] <NEWLINE> if d_val . x > d_val . y : <NEWLINE> <INDENT> d_val . swap ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( d_val . x , d_val . y ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> _sum = 0 <NEWLINE> x = 0 <NEWLINE> for i in range ( len ( As ) - 1 ) : <NEWLINE> <INDENT> _sum += As [ i + 1 ] * ( x + As [ i ] ) <NEWLINE> x += As [ i ] <NEWLINE> <NL> <DEDENT> print ( _sum % ( 10 ** 9 + 7 ) ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_c = collections . Counter ( a ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> s_old = 0 <NEWLINE> for k , v in a_c . items ( ) : <NEWLINE> <INDENT> s_old += k * v <NEWLINE> <DEDENT> for bc in BC : <NEWLINE> <INDENT> b = bc [ 0 ] <NEWLINE> c = bc [ 1 ] <NEWLINE> s = s_old <NEWLINE> if b in a_c : <NEWLINE> <INDENT> n = a_c . pop ( b ) <NEWLINE> a_c [ c ] += n <NEWLINE> s -= n * b <NEWLINE> s += n * c <NEWLINE> <DEDENT> print ( s ) <NEWLINE> s_old = s <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def stoidx ( s ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> return ( 0 , 1 ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> return ( 1 , 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( 0 , 2 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def answer ( ans ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> def add_answer ( x ) : <NEWLINE> <INDENT> if s [ x [ 0 ] ] > s [ x [ 1 ] ] : <NEWLINE> <INDENT> s [ x [ 0 ] ] -= 1 <NEWLINE> s [ x [ 1 ] ] += 1 <NEWLINE> ans . append ( abc [ x [ 1 ] ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ x [ 0 ] ] += 1 <NEWLINE> s [ x [ 1 ] ] -= 1 <NEWLINE> ans . append ( abc [ x [ 0 ] ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , * s = map ( int , input ( ) . split ( ) ) <NEWLINE> sl = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> sl . append ( stoidx ( input ( ) ) ) <NEWLINE> <DEDENT> abc = <STRING> <NEWLINE> ans = [ ] <NEWLINE> if sum ( s ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> elif sum ( s ) == 1 : <NEWLINE> <INDENT> for x in sl : <NEWLINE> <INDENT> if s [ x [ 0 ] ] == 0 and s [ x [ 1 ] ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> add_answer ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i , x in enumerate ( sl ) : <NEWLINE> <INDENT> if s [ x [ 0 ] ] == 0 and s [ x [ 1 ] ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if i < n - 1 and s [ x [ 0 ] ] == 1 and s [ x [ 1 ] ] == 1 : <NEWLINE> <INDENT> nx = sl [ i + 1 ] <NEWLINE> if x != nx and sum ( s ) == 2 : <NEWLINE> <INDENT> if x [ 0 ] in nx : <NEWLINE> <INDENT> s [ x [ 0 ] ] += 1 <NEWLINE> s [ x [ 1 ] ] -= 1 <NEWLINE> ans . append ( abc [ x [ 0 ] ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ x [ 0 ] ] -= 1 <NEWLINE> s [ x [ 1 ] ] += 1 <NEWLINE> ans . append ( abc [ x [ 1 ] ] ) <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> <DEDENT> add_answer ( x ) <NEWLINE> <DEDENT> <DEDENT> answer ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import copy <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ 0 ] * n <NEWLINE> <NL> for x in A : <NEWLINE> <INDENT> L [ x - 1 ] += 1 <NEWLINE> <DEDENT> for i in L : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . readline <NEWLINE> read = sys . stdin . read <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> from heapq import heappop , heappush <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def run ( ) : <NEWLINE> <INDENT> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , sysread ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> plus = [ a for a in A if a >= 0 ] <NEWLINE> minus = [ - a for a in A if a < 0 ] <NEWLINE> <NL> plus = sorted ( plus , reverse = True ) <NEWLINE> minus = sorted ( minus , reverse = True ) <NEWLINE> <NL> P , M = [ 1 ] , [ 1 ] <NEWLINE> for p in plus : <NEWLINE> <INDENT> P . append ( ( P [ - 1 ] * p ) % mod ) <NEWLINE> <DEDENT> for m in minus : <NEWLINE> <INDENT> M . append ( ( ( M [ - 1 ] * ( - m ) ) % mod ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> max_ans = - 1 <NEWLINE> <NL> for i in range ( K , - 1 , - 2 ) : <NEWLINE> <INDENT> if len ( plus ) < i : continue <NEWLINE> if len ( minus ) < K - i : continue <NEWLINE> if max_ans == - 1 : <NEWLINE> <INDENT> max_ans = P [ i ] * M [ K - i ] % mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not plus [ i ] or not plus [ i + 1 ] : <NEWLINE> <INDENT> max_ans = P [ i ] * M [ K - i ] % mod <NEWLINE> continue <NEWLINE> <DEDENT> if plus [ i + 1 ] * plus [ i ] < minus [ K - i - 2 ] * minus [ K - i - 1 ] : <NEWLINE> <INDENT> max_ans = P [ i ] * M [ K - i ] % mod <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if max_ans == - 1 : <NEWLINE> <INDENT> plus = plus [ : : - 1 ] <NEWLINE> minus = minus [ : : - 1 ] <NEWLINE> P , M = [ 1 ] , [ 1 ] <NEWLINE> for p in plus : <NEWLINE> <INDENT> P . append ( ( P [ - 1 ] * p ) % mod ) <NEWLINE> <DEDENT> for m in minus : <NEWLINE> <INDENT> M . append ( ( ( M [ - 1 ] * ( - m ) ) % mod ) ) <NEWLINE> <NL> <DEDENT> for i in range ( K - 1 , - 1 , - 2 ) : <NEWLINE> <INDENT> if len ( plus ) < i : continue <NEWLINE> if len ( minus ) < K - i : continue <NEWLINE> if max_ans == - 1 : <NEWLINE> <INDENT> max_ans = P [ i ] * M [ K - i ] % mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not plus [ i ] or not plus [ i + 1 ] : <NEWLINE> <INDENT> max_ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> if plus [ i + 1 ] * plus [ i ] > minus [ K - i - 2 ] * minus [ K - i - 1 ] : <NEWLINE> <INDENT> max_ans = P [ i ] * M [ K - i ] % mod <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( max_ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r_cnt = s . count ( <STRING> ) <NEWLINE> g_cnt = s . count ( <STRING> ) <NEWLINE> b_cnt = s . count ( <STRING> ) <NEWLINE> <NL> ans = r_cnt * g_cnt * b_cnt <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for d in range ( n ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = 1 <NEWLINE> ok = False <NEWLINE> for i in x : <NEWLINE> <INDENT> res = res * i <NEWLINE> if res > int ( 1e18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> ok = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not ok : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> work , temp = [ 0 ] * 2019 , 0 <NEWLINE> work [ 0 ] = 1 <NEWLINE> a = 1 <NEWLINE> for s in S [ : : - 1 ] : <NEWLINE> <INDENT> temp += int ( s ) * a <NEWLINE> work [ temp % 2019 ] += 1 <NEWLINE> a *= 10 <NEWLINE> a %= 2019 <NEWLINE> <DEDENT> print ( sum ( [ w * ( w - 1 ) // 2 for w in work ] ) ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> c = [ ] <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ j + i ] == t [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> c . append ( count ) <NEWLINE> <DEDENT> print ( len ( t ) - max ( c ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> L = 10 ** 18 <NEWLINE> S = 1 <NEWLINE> if A [ N - 1 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> S = S * A [ i ] <NEWLINE> if S > L : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if S <= L : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> V = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> eve = V [ 0 : : 2 ] <NEWLINE> odd = V [ 1 : : 2 ] <NEWLINE> cntEve = collections . Counter ( eve ) <NEWLINE> cntOdd = collections . Counter ( odd ) <NEWLINE> <NL> if cntEve . most_common ( ) [ 0 ] [ 0 ] == cntOdd . most_common ( ) [ 0 ] [ 0 ] : <NEWLINE> <INDENT> if len ( cntEve ) == 1 and len ( cntOdd ) > 1 : <NEWLINE> <INDENT> ans = N - max ( cntEve . most_common ( ) [ 0 ] [ 1 ] , cntOdd . most_common ( ) [ 0 ] [ 1 ] ) - cntOdd . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <DEDENT> elif len ( cntEve ) > 1 and len ( cntOdd ) == 1 : <NEWLINE> <INDENT> ans = N - max ( cntEve . most_common ( ) [ 0 ] [ 1 ] , cntOdd . most_common ( ) [ 0 ] [ 1 ] ) - cntEve . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <DEDENT> elif len ( cntEve ) == 1 and len ( cntOdd ) == 1 : <NEWLINE> <INDENT> ans = N - max ( cntEve . most_common ( ) [ 0 ] [ 1 ] , cntOdd . most_common ( ) [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = N - max ( cntEve . most_common ( ) [ 0 ] [ 1 ] , cntOdd . most_common ( ) [ 0 ] [ 1 ] ) - max ( cntEve . most_common ( ) [ 1 ] [ 1 ] , cntOdd . most_common ( ) [ 1 ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = N - int ( cntEve . most_common ( ) [ 0 ] [ 1 ] ) - int ( cntOdd . most_common ( ) [ 0 ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = Counter ( a ) <NEWLINE> <NL> dict1 = { } <NEWLINE> dict2 = { } <NEWLINE> for key in d : <NEWLINE> <INDENT> m = d [ key ] <NEWLINE> if m == 1 : <NEWLINE> <INDENT> dict1 [ key ] = 0 <NEWLINE> dict2 [ key ] = 0 <NEWLINE> <DEDENT> elif m == 2 : <NEWLINE> <INDENT> dict1 [ key ] = 1 <NEWLINE> dict2 [ key ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict1 [ key ] = m * ( m - 1 ) // 2 <NEWLINE> dict2 [ key ] = ( m - 1 ) * ( m - 2 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> s = sum ( dict1 . values ( ) ) <NEWLINE> for each in a : <NEWLINE> <INDENT> tmp = s - dict1 [ each ] + dict2 [ each ] <NEWLINE> print ( tmp ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( a * c , a * d , b * c , b * d ) ) <NEWLINE>
<COMMENT> <NL> <NL> import math <NEWLINE> x = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> border = 1 ; <NEWLINE> while border ** 5 - ( border - 1 ) ** 5 < x : <NEWLINE> <INDENT> border += 1 <NEWLINE> <NL> <DEDENT> for i in range ( border + 1 ) : <NEWLINE> <INDENT> aa = ( ( x + i ** 5 ) ** ( 1.0 / 5.0 ) ) <COMMENT> <NEWLINE> a = round ( aa ) <NEWLINE> if a ** 5 - i ** 5 == x : <NEWLINE> <INDENT> b = i <NEWLINE> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> b = - 1 <NEWLINE> <NL> while x + b ** 5 >= 0 : <NEWLINE> <NL> <INDENT> aa = ( ( x + b ** 5 ) ** ( 1.0 / 5.0 ) ) <COMMENT> <NEWLINE> a = round ( aa ) <NEWLINE> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> b -= 1 <NEWLINE> <DEDENT> <DEDENT>
from functools import reduce <NEWLINE> MOD = 1_000_000_007 <NEWLINE> print ( reduce ( lambda a , b : a * b % MOD , range ( 1 , int ( input ( ) ) + 1 ) ) ) <NEWLINE>
import collections <NEWLINE> S = input ( ) <NEWLINE> col_S = collections . Counter ( S ) <NEWLINE> print ( min ( col_S [ <STRING> ] , col_S [ <STRING> ] ) * 2 ) <NEWLINE>
s_l = list ( input ( ) ) <NEWLINE> n = len ( s_l ) <NEWLINE> <NL> <COMMENT> <NL> dp_dict = { 0 : 1 } <NEWLINE> t = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( s_l [ - ( i + 1 ) ] ) <NEWLINE> t = ( t + a * ( pow ( 10 , i , 2019 ) ) ) % 2019 <NEWLINE> dp_dict [ t ] = dp_dict . get ( t , 0 ) + 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for val in dp_dict . values ( ) : <NEWLINE> <INDENT> ans += val * ( val - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for i in range ( H ) ] <NEWLINE> c = [ [ <STRING> ] * W for i in range ( H ) ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> countX = 0 <NEWLINE> nowX = s [ i ] [ 0 ] <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> if nowX == s [ i ] [ j ] : <NEWLINE> <INDENT> countX += 1 <NEWLINE> if 1 < countX and nowX == <STRING> : <NEWLINE> <INDENT> c [ i ] [ j - 1 ] , c [ i ] [ j ] = <STRING> , <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> countX = 1 <NEWLINE> <DEDENT> nowX = s [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( W ) : <NEWLINE> <INDENT> countY = 0 <NEWLINE> nowY = s [ 0 ] [ i ] <NEWLINE> for j in range ( H ) : <NEWLINE> <INDENT> if nowY == s [ j ] [ i ] : <NEWLINE> <INDENT> countY += 1 <NEWLINE> if 1 < countY and nowY == <STRING> : <NEWLINE> <INDENT> c [ j - 1 ] [ i ] , c [ j ] [ i ] = <STRING> , <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> countY = 1 <NEWLINE> <DEDENT> nowY = s [ j ] [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if c == s else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = max ( A ) + 1 <NEWLINE> li = [ 0 ] * ( l ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if li [ a ] == 0 : <NEWLINE> <INDENT> li [ a ] = 1 <NEWLINE> for i in range ( a * 2 , l , a ) : <NEWLINE> <INDENT> li [ i ] = 2 <NEWLINE> <DEDENT> <DEDENT> elif li [ a ] == 1 : <NEWLINE> <INDENT> li [ a ] = 2 <NEWLINE> <DEDENT> <DEDENT> print ( li . count ( 1 ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_p = [ ] <NEWLINE> a_m = [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> if i >= 0 : <NEWLINE> <INDENT> a_p . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_m . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> a_p . sort ( ) <NEWLINE> a_m . sort ( reverse = True ) <NEWLINE> <NL> <NL> a_select = [ ] <NEWLINE> <NL> if n == k : <NEWLINE> <INDENT> a_select = a <NEWLINE> <DEDENT> elif len ( a_p ) == 0 and k % 2 == 1 : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> a_select . append ( a_m [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while len ( a_select ) < k : <NEWLINE> <INDENT> if len ( a_select ) == k - 1 : <NEWLINE> <INDENT> a_select . append ( a_p [ - 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> if len ( a_p ) == 1 and ( k - len ( a_select ) ) % 2 == 1 : <NEWLINE> <INDENT> a_select . append ( a_p . pop ( - 1 ) ) <NEWLINE> <DEDENT> elif len ( a_p ) == 1 and ( k - len ( a_select ) ) % 2 == 0 : <NEWLINE> <INDENT> a_select . append ( a_m . pop ( - 1 ) ) <NEWLINE> a_select . append ( a_m . pop ( - 1 ) ) <NEWLINE> <DEDENT> elif len ( a_p ) == 0 : <NEWLINE> <INDENT> a_select . append ( a_m . pop ( - 1 ) ) <NEWLINE> a_select . append ( a_m . pop ( - 1 ) ) <NEWLINE> <DEDENT> elif len ( a_m ) <= 1 : <NEWLINE> <INDENT> a_select . append ( a_p . pop ( - 1 ) ) <NEWLINE> <DEDENT> elif a_p [ - 1 ] * a_p [ - 2 ] > a_m [ - 1 ] * a_m [ - 2 ] : <NEWLINE> <INDENT> a_select . append ( a_p . pop ( - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_select . append ( a_m . pop ( - 1 ) ) <NEWLINE> a_select . append ( a_m . pop ( - 1 ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for i in a_select : <NEWLINE> <INDENT> ans = ans * i % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> E = int ( input ( ) ) <NEWLINE> <NL> r = [ ] <NEWLINE> <NL> if A % 10 != 0 : <NEWLINE> <INDENT> r . append ( 10 - A % 10 ) <NEWLINE> A += 10 - A % 10 <NEWLINE> <DEDENT> if B % 10 != 0 : <NEWLINE> <INDENT> r . append ( 10 - B % 10 ) <NEWLINE> B += 10 - B % 10 <NEWLINE> <DEDENT> if C % 10 != 0 : <NEWLINE> <INDENT> r . append ( 10 - C % 10 ) <NEWLINE> C += 10 - C % 10 <NEWLINE> <DEDENT> if D % 10 != 0 : <NEWLINE> <INDENT> r . append ( 10 - D % 10 ) <NEWLINE> D += 10 - D % 10 <NEWLINE> <DEDENT> if E % 10 != 0 : <NEWLINE> <INDENT> r . append ( 10 - E % 10 ) <NEWLINE> E += 10 - E % 10 <NEWLINE> <NL> <DEDENT> if r : <NEWLINE> <INDENT> print ( A + B + C + D + E - max ( r ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A + B + C + D + E ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bl = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if sum ( al ) + sum ( bl ) <= k : <NEWLINE> <INDENT> print ( n + m ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> used = 0 <NEWLINE> indexa = indexb = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if used + al [ i ] <= k : <NEWLINE> <INDENT> used += al [ i ] <NEWLINE> indexa = i <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if used + bl [ i ] <= k : <NEWLINE> <INDENT> used += bl [ i ] <NEWLINE> indexb = i <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> tmp = ans <NEWLINE> for i in range ( indexa , - 1 , - 1 ) : <NEWLINE> <INDENT> used -= al [ i ] <NEWLINE> tmp -= 1 <NEWLINE> while indexb < m - 1 and bl [ indexb + 1 ] + used <= k : <NEWLINE> <INDENT> used += bl [ indexb + 1 ] <NEWLINE> indexb += 1 <NEWLINE> tmp += 1 <NEWLINE> <DEDENT> ans = max ( tmp , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = max ( A ) <NEWLINE> B = [ 0 ] * ( M + 1 ) <NEWLINE> ans = 0 <NEWLINE> A . sort ( ) <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> B [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <INDENT> if B [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> for j in range ( i , M + 1 , i ) : <NEWLINE> <INDENT> B [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> flflag = True <NEWLINE> <NL> if ( 2 * x - y ) % 3 == 0 : <NEWLINE> <INDENT> a = ( 2 * x - y ) // 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flflag = False <NEWLINE> <DEDENT> if ( 2 * y - x ) % 3 == 0 : <NEWLINE> <INDENT> b = ( 2 * y - x ) // 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flflag = False <NEWLINE> <NL> <DEDENT> def kaijou ( n ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans *= i % mod <NEWLINE> ans %= mod <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> if flflag : <NEWLINE> <INDENT> N = a + b <NEWLINE> R = min ( a , b ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> if flflag == True and a >= 0 and b >= 0 : <NEWLINE> <INDENT> ans = kaijou ( N ) <NEWLINE> ans1 = ( kaijou ( N - R ) * kaijou ( R ) ) % mod <NEWLINE> print ( ( ans * pow ( ans1 , mod - 2 , mod ) ) % mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
def solve ( n ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> y = n // i <NEWLINE> ans += ( y * ( y + 1 ) * i ) / 2 <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> print ( int ( solve ( n ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def binarysearch ( key , a , length ) : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = length <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> if a [ mid ] == key : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif key < a [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in T : <NEWLINE> <INDENT> if binarysearch ( i , S , n ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import itertools <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A , B , C , D = [ ] , [ ] , [ ] , [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> D . append ( d ) <NEWLINE> <DEDENT> if m == 1 : <NEWLINE> <INDENT> return sum ( D ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> length = m + n - 1 <NEWLINE> for item in itertools . combinations ( range ( length ) , m - 1 ) : <NEWLINE> <INDENT> ptn = [ ] <NEWLINE> num = 1 <NEWLINE> p = 0 <NEWLINE> for i in range ( length ) : <NEWLINE> <INDENT> if i == item [ p ] : <NEWLINE> <INDENT> num += 1 <NEWLINE> p += 1 <NEWLINE> p = min ( m - 2 , p ) <NEWLINE> continue <NEWLINE> <DEDENT> ptn . append ( num ) <NEWLINE> <DEDENT> tmp = 0 <NEWLINE> for k in range ( q ) : <NEWLINE> <INDENT> if ( ptn [ B [ k ] - 1 ] - ptn [ A [ k ] - 1 ] ) == C [ k ] : <NEWLINE> <INDENT> tmp += D [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( tmp , ans ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = [ [ 0 ] * 10 for i in range ( 12 ) ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ ( b - 1 ) * 3 + ( f - 1 ) ] [ r - 1 ] += v <NEWLINE> <DEDENT> for i , v in enumerate ( A , 1 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( [ str ( p ) for p in v ] ) ) <NEWLINE> if i == 3 or i == 6 or i == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys , math , re <NEWLINE> from itertools import accumulate <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <DEDENT> def mi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def ii ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def i2 ( n ) : <NEWLINE> <INDENT> tmp = [ list ( mi ( ) ) for i in range ( n ) ] <NEWLINE> return [ list ( i ) for i in zip ( * tmp ) ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = ii ( ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> x , y = i2 ( N ) <NEWLINE> d = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> pair = ( x [ i ] - x [ j ] , y [ i ] - y [ j ] ) <NEWLINE> if not pair in d : <NEWLINE> <INDENT> d [ pair ] = 0 <NEWLINE> <NL> <DEDENT> d [ pair ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( N - max ( d . values ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
Num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Num . sort ( ) <NEWLINE> Num = Num [ : : - 1 ] <NEWLINE> for i in range ( len ( Num ) ) : <NEWLINE> <INDENT> if i == len ( Num ) - 1 : <NEWLINE> <INDENT> print ( Num [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Num [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> from itertools import accumulate <NEWLINE> import numpy as np <NEWLINE> <NL> n , m , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> pq = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> data = [ [ 0 ] * 500 for i in range ( 500 ) ] <NEWLINE> <COMMENT> <NL> <NL> for l , r in lr : <NEWLINE> <INDENT> data [ l - 1 ] [ r - 1 ] += 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> data = np . array ( data ) <NEWLINE> <NL> data = np . cumsum ( data , axis = 1 ) <NEWLINE> data = np . cumsum ( data , axis = 0 ) <NEWLINE> <NL> <COMMENT> <NL> for p , q in pq : <NEWLINE> <INDENT> ans = 0 <NEWLINE> if p == 1 : <NEWLINE> <INDENT> ans = data [ q - 1 ] [ q - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = data [ q - 1 ] [ q - 1 ] - data [ p - 1 - 1 ] [ q - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ 0 for i in range ( N ) ] <NEWLINE> A = input ( ) . split ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = ( int ) ( A [ i ] ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <NL> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j = j - 1 <NEWLINE> A [ j + 1 ] = v <NEWLINE> <DEDENT> for k in range ( N ) : <NEWLINE> <INDENT> if k < N - 1 : <NEWLINE> <INDENT> print ( A [ k ] , end = <STRING> ) <NEWLINE> <DEDENT> if k == N - 1 : <NEWLINE> <INDENT> print ( A [ k ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( k ) ] <NEWLINE> <NL> MOD = 998244353 <NEWLINE> <NL> dp = [ 0 ] * n <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> ruidp = [ 0 ] * ( n + 1 ) <NEWLINE> ruidp [ 1 ] = 1 <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for l , r in LR : <NEWLINE> <INDENT> dp [ i ] += ( ruidp [ max ( i - l + 1 , 0 ) ] - ruidp [ max ( i - r , 0 ) ] ) <NEWLINE> dp [ i ] %= MOD <NEWLINE> <DEDENT> ruidp [ i + 1 ] = ruidp [ i ] + dp [ i ] <NEWLINE> ruidp [ i + 1 ] %= MOD <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
<COMMENT> <NL> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> T = input ( ) <NEWLINE> ran_T = range ( len ( T ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> count = 0 <NEWLINE> <NL> for a , b in zip ( S , T ) : <NEWLINE> <INDENT> if a != b : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> mod_cnt = [ 0 ] * 2019 <NEWLINE> mod_cnt [ 0 ] = 1 <NEWLINE> t = 0 <NEWLINE> d = 1 <NEWLINE> for c in s : <NEWLINE> <INDENT> t += int ( c ) * d <NEWLINE> t %= 2019 <NEWLINE> mod_cnt [ t ] += 1 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> <DEDENT> print ( sum ( [ m * ( m - 1 ) // 2 for m in mod_cnt ] ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = { } <NEWLINE> for v in a : <NEWLINE> <INDENT> if v in dic : <NEWLINE> <INDENT> dic [ v ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ v ] = 1 <NEWLINE> <DEDENT> <DEDENT> key = [ v for v in dic . keys ( ) ] <NEWLINE> key . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> for v in key : <NEWLINE> <INDENT> num = dic [ v ] <NEWLINE> if num > 0 : <NEWLINE> <INDENT> for i in reversed ( range ( 1 , 32 ) ) : <NEWLINE> <INDENT> target = 2 ** i <NEWLINE> if 2 * v < target : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if target < v : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> u = target - v <NEWLINE> if v == u : <NEWLINE> <INDENT> z = dic [ v ] // 2 <NEWLINE> ans += z <NEWLINE> dic [ v ] -= 2 * z <NEWLINE> <DEDENT> elif u in dic : <NEWLINE> <INDENT> x , y = dic [ v ] , dic [ u ] <NEWLINE> z = 0 <NEWLINE> if x < y : <NEWLINE> <INDENT> z = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = y <NEWLINE> <DEDENT> dic [ v ] -= z <NEWLINE> dic [ u ] -= z <NEWLINE> ans += z <NEWLINE> <DEDENT> if dic [ v ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) [ : : - 1 ] <NEWLINE> <NL> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> <NL> num , d = 0 , 1 <NEWLINE> <NL> for char in s : <NEWLINE> <INDENT> num += int ( char ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> counts [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in counts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> deg = [ 0 ] * n <NEWLINE> child , parent = { } , { } <NEWLINE> sib = [ None ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a [ 1 ] != - 1 : <NEWLINE> <INDENT> if a [ 2 ] == - 1 : <NEWLINE> <INDENT> child [ a [ 0 ] ] = [ a [ 1 ] ] <NEWLINE> sib [ a [ 1 ] ] = a [ 2 ] <NEWLINE> deg [ a [ 0 ] ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> child [ a [ 0 ] ] = a [ 1 : ] <NEWLINE> sib [ a [ 1 ] ] = a [ 2 ] <NEWLINE> sib [ a [ 2 ] ] = a [ 1 ] <NEWLINE> deg [ a [ 0 ] ] = 2 <NEWLINE> <DEDENT> for j in child [ a [ 0 ] ] : <NEWLINE> <INDENT> parent [ j ] = a [ 0 ] <NEWLINE> <DEDENT> <DEDENT> elif a [ 2 ] != - 1 : <NEWLINE> <INDENT> child [ a [ 0 ] ] = [ a [ 2 ] ] <NEWLINE> sib [ a [ 2 ] ] = a [ 1 ] <NEWLINE> deg [ a [ 0 ] ] = 1 <NEWLINE> for j in child [ a [ 0 ] ] : <NEWLINE> <INDENT> parent [ j ] = a [ 0 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> child [ a [ 0 ] ] = [ ] <NEWLINE> <NL> <DEDENT> <DEDENT> root = ( set ( child ) - set ( parent ) ) . pop ( ) <NEWLINE> depth = [ None ] * n <NEWLINE> depth [ root ] = 0 <NEWLINE> hei = [ None ] * n <NEWLINE> parent [ root ] = - 1 <NEWLINE> sib [ root ] = - 1 <NEWLINE> <NL> def dfs ( s ) : <NEWLINE> <INDENT> if len ( child [ s ] ) == 0 : <NEWLINE> <INDENT> hei [ s ] = 0 <NEWLINE> return <NEWLINE> <DEDENT> for i in child [ s ] : <NEWLINE> <INDENT> depth [ i ] = depth [ s ] + 1 <NEWLINE> dfs ( i ) <NEWLINE> <DEDENT> hei [ s ] = max ( hei [ i ] for i in child [ s ] ) + 1 <NEWLINE> <NL> <NL> <DEDENT> dfs ( root ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> node_type = <STRING> if parent [ i ] == - 1 else <STRING> if len ( child [ i ] ) == 0 else <STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while a [ i ] + b [ j ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> Sum = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> Sum += A . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> temp = A . pop ( ) <NEWLINE> Sum += temp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Sum += temp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( Sum ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> b = - 1 <NEWLINE> while True : <NEWLINE> <INDENT> b += 1 <NEWLINE> amin = ( x + b ** 5 ) ** 0.2 <NEWLINE> apls = ( x - b ** 5 ) ** 0.2 <NEWLINE> <NL> if isinstance ( amin , float ) : <NEWLINE> <INDENT> amin = round ( amin , 10 ) <NEWLINE> if amin . is_integer ( ) : <NEWLINE> <INDENT> print ( int ( amin ) , b ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if isinstance ( apls , float ) : <NEWLINE> <INDENT> apls = round ( apls , 10 ) <NEWLINE> if apls . is_integer ( ) : <NEWLINE> <INDENT> print ( int ( apls ) , - 1 * b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import itertools <NEWLINE> from collections import defaultdict <NEWLINE> import collections <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 200000 ) <NEWLINE> mod = 1000000007 <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tf = [ False ] * ( n + 1 ) <NEWLINE> tf [ 1 ] = True <NEWLINE> ss = [ 1 ] <NEWLINE> cnt = 0 <NEWLINE> while cnt < max ( k , n ** 2 ) : <NEWLINE> <INDENT> if len ( ss ) != 1 and tf [ a [ ss [ cnt ] - 1 ] ] : <NEWLINE> <INDENT> d = a [ ss [ cnt ] - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> tf [ a [ ss [ cnt ] - 1 ] ] = True <NEWLINE> ss . append ( a [ ss [ cnt ] - 1 ] ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> if len ( ss ) > k : <NEWLINE> <INDENT> print ( ss [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sss = ss . index ( d ) <NEWLINE> print ( ss [ sss + ( k - len ( ss ) ) % ( len ( ss ) - sss ) ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
<NL> A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total = 0 <NEWLINE> K -= A <NEWLINE> total += A <NEWLINE> K -= B <NEWLINE> total = total - ( K ) <NEWLINE> print ( total ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> k , t = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if not k == t : <NEWLINE> <INDENT> count *= 0 <NEWLINE> <DEDENT> if k == t : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if count == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> break <NEWLINE> <NL> <DEDENT> <DEDENT> if count == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> from collections import defaultdict <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> dis = defaultdict ( int ) <NEWLINE> for i1 in range ( n ) : <NEWLINE> <INDENT> for i2 in range ( i1 + 1 , n ) : <NEWLINE> <INDENT> d = min ( abs ( i2 - i1 ) , abs ( x - i1 ) + abs ( y - i2 ) + 1 , abs ( x - i2 ) + abs ( y - i1 ) + 1 ) <NEWLINE> dis [ d ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for k1 in range ( 1 , n ) : <NEWLINE> <INDENT> print ( dis [ k1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from numpy import * <NEWLINE> N , M , * U = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> T = array ( U [ N : ] ) <NEWLINE> p = ones ( M + 1 , dtype = <STRING> ) <NEWLINE> for s in U [ : N ] : p [ 1 : ] = ( ( p [ : - 1 ] * ( s == T ) ) . cumsum ( ) + p [ 1 : ] ) % ( 10 ** 9 + 7 ) <NEWLINE> print ( p [ - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> r = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> ans = r * b * g <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for s in range ( N ) : <NEWLINE> <INDENT> j = i + s <NEWLINE> k = j + s <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> T = list ( input ( ) ) <NEWLINE> <NL> i = 0 <NEWLINE> ans = [ ] <NEWLINE> <NL> while i + len ( T ) <= len ( S ) : <NEWLINE> <INDENT> n = 0 <NEWLINE> for s , t in zip ( S [ i : i + len ( T ) ] , T ) : <NEWLINE> <INDENT> if s != t : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> ans . append ( n ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> print ( min ( ans ) ) <NEWLINE>
import sys , string <NEWLINE> <NL> lines = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> lines . append ( line ) <NEWLINE> <NL> <DEDENT> text = <STRING> . join ( lines ) . lower ( ) <NEWLINE> <NL> for char in string . ascii_lowercase : <NEWLINE> <INDENT> print ( <STRING> . format ( char , text . count ( char ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> mini = a [ 0 ] <NEWLINE> b = - 10000000000 <NEWLINE> del a [ 0 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> if b < i - mini : <NEWLINE> <INDENT> b = i - mini <NEWLINE> <DEDENT> if mini > i : <NEWLINE> <INDENT> mini = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( b ) <NEWLINE> <NL>
from itertools import islice <NEWLINE> <NL> def make_seq ( ) : <NEWLINE> <INDENT> n , m , l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m1 = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> m2 = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> def g ( ) : <NEWLINE> <INDENT> for r1 in m1 : <NEWLINE> <INDENT> for r2 in zip ( * m2 ) : <NEWLINE> <INDENT> yield str ( sum ( i * j for i , j in zip ( r1 , r2 ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return ( n , l , list ( g ( ) ) ) <NEWLINE> <NL> <DEDENT> n , l , lst = make_seq ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( islice ( lst , i * l , ( i + 1 ) * l ) ) ) <NEWLINE> <DEDENT>
def ri ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def rii ( ) : <NEWLINE> <INDENT> return [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> N = ri ( ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , N ) : <NEWLINE> <INDENT> b = 1 <NEWLINE> while b * a < N : <NEWLINE> <INDENT> ans += 1 <NEWLINE> b += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> n = len ( S ) <NEWLINE> p = 2019 <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> S = [ S [ i ] for i in range ( n - 1 , - 1 , - 1 ) ] <NEWLINE> <COMMENT> <NL> modp_counter = [ 0 ] * p <NEWLINE> modp = 0 <NEWLINE> modp_counter [ 0 ] = 1 <COMMENT> <NEWLINE> pair_count = 0 <NEWLINE> d = 1 <NEWLINE> for s in S : <NEWLINE> <INDENT> modp = ( int ( s ) * d % p + modp ) % p <NEWLINE> pair_count += modp_counter [ modp ] <NEWLINE> modp_counter [ modp ] += 1 <NEWLINE> d *= 10 <NEWLINE> d %= p <COMMENT> <NEWLINE> <DEDENT> print ( pair_count ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
input_ = input ( ) <NEWLINE> a = int ( input_ . split ( <STRING> ) [ 0 ] ) <NEWLINE> b = int ( input_ . split ( <STRING> ) [ 1 ] ) <NEWLINE> c = int ( input_ . split ( <STRING> ) [ 2 ] ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> ans = <STRING> <NEWLINE> while count < k : <NEWLINE> <INDENT> if a >= b : <NEWLINE> <INDENT> b *= 2 <NEWLINE> count += 1 <NEWLINE> <DEDENT> elif b >= c : <NEWLINE> <INDENT> c *= 2 <NEWLINE> count += 1 <NEWLINE> <DEDENT> if a < b and b < c : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> S = list ( map ( int , input ( ) ) ) <NEWLINE> N = len ( S ) <NEWLINE> P = 2019 <NEWLINE> num = [ 0 ] * P <NEWLINE> num [ 0 ] = 1 <NEWLINE> now , ans = 0 , 0 <NEWLINE> _10 = 1 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> now = ( now + S [ i ] * _10 ) % P <NEWLINE> _10 *= 10 <NEWLINE> _10 %= P <NEWLINE> ans += num [ now ] <NEWLINE> num [ now ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<NL> import collections , sys <NEWLINE> def s ( ) : <NEWLINE> <INDENT> d = collections . deque ( ) <NEWLINE> input ( ) <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> if <STRING> == e [ 0 ] : d . appendleft ( e [ 7 : - 1 ] ) <NEWLINE> else : <NEWLINE> <INDENT> if <STRING> == e [ 6 ] : <NEWLINE> <INDENT> m = e [ 7 : 0 - 1 ] <NEWLINE> if m in d : d . remove ( m ) <NEWLINE> <DEDENT> elif <STRING> == e [ 7 ] : d . popleft ( ) <NEWLINE> else : d . pop ( ) <NEWLINE> <DEDENT> <DEDENT> print ( * d ) <NEWLINE> <NL> <DEDENT> s ( ) <NEWLINE> <NL>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . ps = [ - 1 ] * ( n + 1 ) <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . ps [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . ps [ x ] = self . find ( self . ps [ x ] ) <NEWLINE> return self . ps [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if self . ps [ x ] > self . ps [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . ps [ x ] += self . ps [ y ] <NEWLINE> self . ps [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> return - self . ps [ x ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> uf = UnionFind ( n ) <NEWLINE> <NL> friends = [ 0 ] * ( n + 1 ) <NEWLINE> chain = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> friends [ a ] += 1 <NEWLINE> friends [ b ] += 1 <NEWLINE> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> for _ in range ( k ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if uf . same ( c , d ) : <NEWLINE> <INDENT> friends [ c ] += 1 <NEWLINE> friends [ d ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans . append ( uf . size ( i ) - friends [ i ] - 1 ) <NEWLINE> <NL> <DEDENT> print ( * ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> t = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> t . append ( str ( i // 100 ) ) <NEWLINE> t . append ( str ( i // 10 % 10 ) ) <NEWLINE> t . append ( str ( i % 10 ) ) <NEWLINE> k = 0 <NEWLINE> p = 0 <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> if t [ j ] in s [ k : ] : <NEWLINE> <INDENT> p = s [ k : ] . index ( t [ j ] ) + 1 <NEWLINE> k += p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if p != - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> t . clear ( ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> rev_s = s + s [ : : - 1 ] <NEWLINE> mido = <STRING> * n <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if mido > rev_s [ i : i + n ] : <NEWLINE> <INDENT> mido = rev_s [ i : i + n ] <NEWLINE> <DEDENT> <DEDENT> ind = float ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if mido [ i ] != mido [ 0 ] : <NEWLINE> <INDENT> if i < ind : <NEWLINE> <INDENT> ind = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = ind * ( 2 ** min ( k - 1 , 20 ) ) <NEWLINE> print ( ( mido [ 0 ] * ans + mido [ ind : ind + n - ans ] ) [ : n ] ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 200005 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> abL = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> pxL = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> to = [ [ ] for _ in range ( 200005 ) ] <NEWLINE> ans = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> <NL> <NL> def dfs ( v , p = - 1 ) : <NEWLINE> <INDENT> for u in to [ v ] : <NEWLINE> <INDENT> if u == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ u ] += ans [ v ] <NEWLINE> dfs ( u , v ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for a , b in abL : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> to [ a ] . append ( b ) <NEWLINE> to [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for p , x in pxL : <NEWLINE> <INDENT> p -= 1 <NEWLINE> ans [ p ] += x <NEWLINE> <NL> <DEDENT> dfs ( 0 ) <NEWLINE> <NL> for a in ans [ : n ] : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
S = input ( ) [ : : - 1 ] <NEWLINE> l = [ 0 ] * 2019 <NEWLINE> a = 1 <NEWLINE> d = 0 <NEWLINE> <NL> for s in S : <NEWLINE> <INDENT> d = d + int ( s ) * a <NEWLINE> l [ d % 2019 ] += 1 <NEWLINE> a *= 10 <NEWLINE> a %= 2019 <NEWLINE> <NL> <DEDENT> ans = l [ 0 ] <NEWLINE> for i in l : <NEWLINE> <INDENT> if i >= 2 : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect , sys <NEWLINE> from itertools import * <NEWLINE> n = range ( 50001 ) ; a = list ( n ) ; a [ 1 ] = 0 <NEWLINE> for i in range ( 2 , 224 ) : a [ i * 2 : : i ] = [ 0 ] * len ( a [ i * 2 : : i ] ) <NEWLINE> for x in map ( int , sys . stdin ) : <NEWLINE> <INDENT> if x : y = x // 2 + 1 ; print ( sum ( 1 for d in compress ( n [ : y ] , a [ : y ] ) if a [ x - d ] ) ) <NEWLINE> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> n , k = I ( ) <NEWLINE> a = l ( ) <NEWLINE> town = [ ] <NEWLINE> num = [ 0 ] * ( n + 1 ) <NEWLINE> cnt = 1 <NEWLINE> num [ 0 ] = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> num [ a [ cnt - 1 ] ] += 1 <NEWLINE> if num [ a [ cnt - 1 ] ] == 2 : <NEWLINE> <INDENT> ans = a [ cnt - 1 ] <NEWLINE> p = town . index ( ans ) <NEWLINE> b = town [ p : ] <NEWLINE> x = len ( town ) <NEWLINE> y = len ( b ) <NEWLINE> q = k - x + y <NEWLINE> if y == 0 : <NEWLINE> <INDENT> print ( town [ n - 1 ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if q < 0 : <NEWLINE> <INDENT> print ( town [ k - 1 ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> z = q % y <NEWLINE> if z == 0 : <NEWLINE> <INDENT> print ( town [ z - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b [ z - 1 ] ) <NEWLINE> <DEDENT> sys . exit ( ) <NEWLINE> break <NEWLINE> <DEDENT> town . append ( a [ cnt - 1 ] ) <NEWLINE> cnt = a [ cnt - 1 ] <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> H , W , M = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> targets = [ [ int ( item ) - 1 for item in input ( ) . split ( ) ] for _ in range ( M ) ] <NEWLINE> <NL> col = [ 0 for _ in range ( H ) ] <NEWLINE> row = [ 0 for _ in range ( W ) ] <NEWLINE> <NL> bomb_set = set ( ) <NEWLINE> <COMMENT> <NL> <NL> <NL> for i , j in targets : <NEWLINE> <INDENT> col [ i ] += 1 <NEWLINE> row [ j ] += 1 <NEWLINE> bomb_set . add ( ( i , j ) ) <NEWLINE> <NL> <DEDENT> max_col = max ( col ) <NEWLINE> max_row = max ( row ) <NEWLINE> max_col_index = [ ] <NEWLINE> max_row_index = [ ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> if col [ i ] == max_col : <NEWLINE> <INDENT> max_col_index . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( W ) : <NEWLINE> <INDENT> if row [ i ] == max_row : <NEWLINE> <INDENT> max_row_index . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> res = 0 <NEWLINE> for item in max_col_index : <NEWLINE> <INDENT> for jtem in max_row_index : <NEWLINE> <INDENT> if ( item , jtem ) not in bomb_set : <NEWLINE> <INDENT> res = max_col + max_row <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res = max ( res , max_col + max_row - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = { i : [ ] for i in range ( n + 1 ) } <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s [ a ] . append ( b ) <NEWLINE> s [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> bfs = [ 0 ] * ( n + 1 ) <NEWLINE> try : <NEWLINE> <INDENT> bfs [ 1 ] = s [ 1 ] [ 0 ] <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> q = collections . deque ( ) <NEWLINE> q . append ( { 1 : s [ 1 ] } ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> tmp = q . popleft ( ) <COMMENT> <NEWLINE> for k , v in tmp . items ( ) : <NEWLINE> <INDENT> for room in v : <NEWLINE> <INDENT> if bfs [ room ] == 0 : <NEWLINE> <INDENT> bfs [ room ] = k <NEWLINE> q . append ( { room : s [ room ] } ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if bfs . count ( 0 ) <= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in bfs [ 2 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> dic = { } <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a in dic : <NEWLINE> <INDENT> dic [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ a ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> m = max ( dic . values ( ) ) <NEWLINE> <NL> for s in sorted ( k for k in dic if dic [ k ] == m ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
num = int ( input ( ) ) <NEWLINE> h = input ( ) . split ( ) <NEWLINE> hi = sorted ( h ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans = ans + int ( hi [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * int ( hi [ i ] ) <NEWLINE> if ans > 10 ** 18 or ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A_int_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> sum_A = sum ( A_int_list ) <NEWLINE> <NL> for i in range ( len ( A_int_list ) ) : <NEWLINE> <INDENT> sum_A -= A_int_list [ i ] <NEWLINE> ans += A_int_list [ i ] * sum_A <NEWLINE> <NL> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
input_list = [ ] <NEWLINE> flag = True <NEWLINE> <NL> while flag : <NEWLINE> <INDENT> input_value = input ( ) <NEWLINE> <NL> if input_value == <STRING> : <NEWLINE> <INDENT> flag = False <NEWLINE> <NL> <DEDENT> input_list . append ( input_value ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 0 , len ( input_list ) - 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i + 1 , input_list [ i ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> w = [ ( input ( ) ) for _ in range ( n ) ] <NEWLINE> l = set ( w ) <NEWLINE> if len ( w ) != len ( l ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if w [ i ] [ len ( w [ i ] ) - 1 ] != w [ i + 1 ] [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += gcd ( c , gcd ( a , b ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> D = set ( ) <COMMENT> <NEWLINE> S = set ( ) <COMMENT> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] in S : <NEWLINE> <INDENT> D . add ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . add ( A [ i ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> M = max ( S ) <NEWLINE> <COMMENT> <NL> X = [ 1 for i in range ( M + 1 ) ] <COMMENT> <NEWLINE> <COMMENT> <NL> for a in S : <NEWLINE> <INDENT> if a in D : <NEWLINE> <INDENT> X [ a ] = 0 <COMMENT> <NEWLINE> <DEDENT> for i in range ( 2 * a , M + 1 , a ) : <NEWLINE> <INDENT> X [ i ] = 0 <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ A [ i ] ] == 1 : <COMMENT> <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = np . array ( [ list ( input ( ) ) for _ in range ( H ) ] ) == <STRING> <COMMENT> <NEWLINE> <NL> up = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> down = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> left = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> right = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> <NL> for i in range ( H - 1 ) : <NEWLINE> <INDENT> up [ i + 1 , : ] = ( up [ i , : ] + 1 ) * S [ i , : ] <COMMENT> <NEWLINE> <DEDENT> for i in range ( H - 1 ) : <COMMENT> <NEWLINE> <INDENT> down [ H - 2 - i , : ] = ( down [ H - 1 - i , : ] + 1 ) * S [ H - 1 - i , : ] <NEWLINE> <DEDENT> for i in range ( W - 1 ) : <NEWLINE> <INDENT> left [ : , i + 1 ] = ( left [ : , i ] + 1 ) * S [ : , i ] <NEWLINE> <DEDENT> for i in range ( W - 1 ) : <NEWLINE> <INDENT> right [ : , W - 2 - i ] = ( right [ : , W - 1 - i ] + 1 ) * S [ : , W - 1 - i ] <NEWLINE> <NL> <DEDENT> print ( ( ( up + down + left + right ) * S ) . max ( ) + 1 ) <COMMENT> <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( [ a , b , c , d ] ) <NEWLINE> <NL> <DEDENT> nums = list ( itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) ) <NEWLINE> scores = [ ] <NEWLINE> for row in nums : <NEWLINE> <INDENT> score = 0 <NEWLINE> i = 0 <NEWLINE> while i < Q : <NEWLINE> <INDENT> if row [ l [ i ] [ 1 ] - 1 ] - row [ l [ i ] [ 0 ] - 1 ] == l [ i ] [ 2 ] : <NEWLINE> <INDENT> score += l [ i ] [ 3 ] <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> scores . append ( score ) <NEWLINE> <NL> <DEDENT> print ( max ( scores ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> from sys import stdin <NEWLINE> readline = stdin . readline <NEWLINE> <NL> from builtins import max , min , range <NEWLINE> <NL> INF = 10 ** 6 <NEWLINE> <NL> H , W = map ( int , readline ( ) . split ( ) ) <NEWLINE> Ch , Cw = map ( lambda x : int ( x ) - 1 , readline ( ) . split ( ) ) <NEWLINE> Dh , Dw = map ( lambda x : int ( x ) - 1 , readline ( ) . split ( ) ) <NEWLINE> S = [ readline ( ) [ : - 1 ] for _ in range ( H ) ] <NEWLINE> <NL> t = [ [ INF ] * W for _ in range ( H ) ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> th = t [ h ] <NEWLINE> Sh = S [ h ] <NEWLINE> for w in range ( W ) : <NEWLINE> <INDENT> if Sh [ w ] == <STRING> : <NEWLINE> <INDENT> th [ w ] = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> t [ Ch ] [ Cw ] = 0 <NEWLINE> q = deque ( [ ( Ch , Cw ) ] ) <NEWLINE> a = 0 <NEWLINE> while q : <NEWLINE> <INDENT> warpq = [ ] <NEWLINE> while q : <NEWLINE> <INDENT> h , w = q . popleft ( ) <NEWLINE> warpq . append ( ( h , w ) ) <NEWLINE> if h - 1 >= 0 and t [ h - 1 ] [ w ] > a : <NEWLINE> <INDENT> q . append ( ( h - 1 , w ) ) <NEWLINE> t [ h - 1 ] [ w ] = a <NEWLINE> <DEDENT> if h + 1 < H and t [ h + 1 ] [ w ] > a : <NEWLINE> <INDENT> q . append ( ( h + 1 , w ) ) <NEWLINE> t [ h + 1 ] [ w ] = a <NEWLINE> <DEDENT> if w - 1 >= 0 and t [ h ] [ w - 1 ] > a : <NEWLINE> <INDENT> q . append ( ( h , w - 1 ) ) <NEWLINE> t [ h ] [ w - 1 ] = a <NEWLINE> <DEDENT> if w + 1 < W and t [ h ] [ w + 1 ] > a : <NEWLINE> <INDENT> q . append ( ( h , w + 1 ) ) <NEWLINE> t [ h ] [ w + 1 ] = a <NEWLINE> <NL> <DEDENT> <DEDENT> if t [ Dh ] [ Dw ] != INF : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> a += 1 <NEWLINE> for h , w in warpq : <NEWLINE> <INDENT> for i in range ( max ( 0 , h - 2 ) , min ( H , h + 3 ) ) : <NEWLINE> <INDENT> ti = t [ i ] <NEWLINE> for j in range ( max ( 0 , w - 2 ) , min ( W , w + 3 ) ) : <NEWLINE> <INDENT> if ti [ j ] > a : <NEWLINE> <INDENT> ti [ j ] = a <NEWLINE> q . append ( ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if t [ Dh ] [ Dw ] == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t [ Dh ] [ Dw ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_sum = sum ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a_sum -= a [ i ] <NEWLINE> ans += a [ i ] * a_sum <NEWLINE> <NL> <DEDENT> ans = int ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = { } <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> dic [ i ] = 0 <NEWLINE> <DEDENT> for j in lis : <NEWLINE> <INDENT> dic [ j ] += 1 <NEWLINE> <DEDENT> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( dic [ k ] ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> total = 0 <NEWLINE> count = 0 <NEWLINE> flag = n - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> total += a [ i ] <NEWLINE> if total > k : <NEWLINE> <INDENT> total -= a [ i ] <NEWLINE> flag = i - 1 <NEWLINE> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> ans = count <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if b [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> total += b [ i ] <NEWLINE> count += 1 <NEWLINE> while total > k : <NEWLINE> <INDENT> if flag == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total -= a [ flag ] <NEWLINE> flag -= 1 <NEWLINE> count -= 1 <NEWLINE> <DEDENT> <DEDENT> if total > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = max ( ans , count ) <NEWLINE> <NL> <DEDENT> total = 0 <NEWLINE> count = 0 <NEWLINE> flag = m - 1 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> total += b [ i ] <NEWLINE> if total > k : <NEWLINE> <INDENT> total -= b [ i ] <NEWLINE> flag = i - 1 <NEWLINE> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> total += a [ i ] <NEWLINE> count += 1 <NEWLINE> while total > k : <NEWLINE> <INDENT> if flag == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total -= b [ flag ] <NEWLINE> flag -= 1 <NEWLINE> count -= 1 <NEWLINE> <DEDENT> <DEDENT> if total > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = max ( ans , count ) <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
c = str ( input ( ) ) <NEWLINE> cl = list ( c ) <NEWLINE> for i in range ( len ( cl ) ) : <NEWLINE> <INDENT> if cl [ i ] . islower ( ) : <NEWLINE> <INDENT> cl [ i ] = cl [ i ] . upper ( ) <NEWLINE> print ( cl [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> elif cl [ i ] . isupper ( ) : <NEWLINE> <INDENT> cl [ i ] = cl [ i ] . lower ( ) <NEWLINE> print ( cl [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> elif not cl [ i ] . isalpha ( ) : <NEWLINE> <INDENT> print ( cl [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> Edge = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> Edge [ a ] . append ( b ) <NEWLINE> Edge [ b ] . append ( a ) <NEWLINE> <DEDENT> looked = [ 1 for i in range ( n ) ] <NEWLINE> counter = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if looked [ i ] : <NEWLINE> <INDENT> looked [ i ] = 0 <NEWLINE> counter += 1 <NEWLINE> queue = deque ( [ i ] ) <NEWLINE> while queue : <NEWLINE> <INDENT> now = deque . popleft ( queue ) <NEWLINE> for j in Edge [ now ] : <NEWLINE> <INDENT> if looked [ j ] : <NEWLINE> <INDENT> deque . append ( queue , j ) <NEWLINE> looked [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( counter - 1 ) <NEWLINE>
import sys <NEWLINE> import os <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , value ) : <NEWLINE> <INDENT> self . value = value <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <DEDENT> def insert_node ( self , node ) : <NEWLINE> <INDENT> if node . value <= self . value : <NEWLINE> <INDENT> if self . left is None : <NEWLINE> <INDENT> self . left = node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . left . insert_node ( node ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if self . right is None : <NEWLINE> <INDENT> self . right = node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . right . insert_node ( node ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def find_node_by_value ( self , value ) : <NEWLINE> <INDENT> if self . value == value : <NEWLINE> <INDENT> return self <NEWLINE> <DEDENT> elif value < self . value : <NEWLINE> <INDENT> if self . left is None : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . left . find_node_by_value ( value ) <NEWLINE> <DEDENT> <DEDENT> elif value > self . value : <NEWLINE> <INDENT> if self . right is None : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . right . find_node_by_value ( value ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> assert ( False ) <NEWLINE> <NL> <DEDENT> <DEDENT> def next_node_in_inorder ( self ) : <NEWLINE> <INDENT> if self . right is not None : <NEWLINE> <INDENT> return self . right . smallest_offspring ( self ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <NL> <DEDENT> <DEDENT> def smallest_offspring ( self , parent ) : <NEWLINE> <INDENT> if self . left is not None : <NEWLINE> <INDENT> return self . left . smallest_offspring ( self ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( self , parent ) <NEWLINE> <NL> <DEDENT> <DEDENT> def get_parent_of ( self , value , parent_cand = None , is_left_child = None ) : <NEWLINE> <INDENT> if self . value == value : <NEWLINE> <INDENT> return parent_cand , is_left_child <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if value < self . value and self . left is not None : <NEWLINE> <INDENT> return self . left . get_parent_of ( value , self , True ) <NEWLINE> <DEDENT> elif value > self . value and self . right is not None : <NEWLINE> <INDENT> return self . right . get_parent_of ( value , self , False ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> assert ( False ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def delete_child ( self , node ) : <NEWLINE> <INDENT> if self . left == node : <NEWLINE> <INDENT> self . left = None <NEWLINE> <DEDENT> elif self . right == node : <NEWLINE> <INDENT> self . right = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> assert ( False ) <NEWLINE> <NL> <DEDENT> <DEDENT> def delete_node ( self , parent , value ) : <NEWLINE> <COMMENT> <NL> <INDENT> if value < self . value and self . left is not None : <NEWLINE> <INDENT> self . left . delete_node ( self , value ) <NEWLINE> <DEDENT> elif self . value < value and self . right is not None : <NEWLINE> <INDENT> self . right . delete_node ( self , value ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif self . left is None and self . right is None : <NEWLINE> <COMMENT> <NL> <INDENT> parent . delete_child ( self ) <NEWLINE> <DEDENT> elif self . left is not None and self . right is not None : <NEWLINE> <INDENT> n , p = self . next_node_in_inorder ( ) <NEWLINE> self . value = n . value <NEWLINE> n . delete_node ( p , n . value ) <NEWLINE> <DEDENT> elif self . left is not None : <NEWLINE> <INDENT> self . value = self . left . value <NEWLINE> self . right = self . left . right <NEWLINE> self . left = self . left . left <NEWLINE> <DEDENT> elif self . right is not None : <NEWLINE> <INDENT> self . value = self . right . value <NEWLINE> self . left = self . right . left <NEWLINE> self . right = self . right . right <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> def print_node_by_preorder ( self ) : <NEWLINE> <INDENT> print ( <STRING> , self . value , end = <STRING> ) <NEWLINE> if self . left is not None : <NEWLINE> <INDENT> self . left . print_node_by_preorder ( ) <NEWLINE> <DEDENT> if self . right is not None : <NEWLINE> <INDENT> self . right . print_node_by_preorder ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def print_node_by_inorder ( self ) : <NEWLINE> <INDENT> if self . left is not None : <NEWLINE> <INDENT> self . left . print_node_by_inorder ( ) <NEWLINE> <DEDENT> print ( <STRING> , self . value , end = <STRING> ) <NEWLINE> if self . right is not None : <NEWLINE> <INDENT> self . right . print_node_by_inorder ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> class BST : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def cmd_insert ( self , k ) : <NEWLINE> <INDENT> if self . root is None : <NEWLINE> <INDENT> self . root = Node ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . root . insert_node ( Node ( k ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def cmd_find ( self , k ) : <NEWLINE> <INDENT> if self . root is None : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( self . root . find_node_by_value ( k ) is not None ) <NEWLINE> <NL> <DEDENT> <DEDENT> def cmd_delete ( self , k ) : <NEWLINE> <INDENT> if self . root is None : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . root . delete_node ( parent = self , value = k ) <NEWLINE> <NL> <DEDENT> <DEDENT> def delete_child ( self , node ) : <NEWLINE> <INDENT> assert ( self . root == node ) <NEWLINE> self . root = None <NEWLINE> <NL> <DEDENT> def cmd_print ( self ) : <NEWLINE> <INDENT> if self . root is not None : <NEWLINE> <INDENT> self . root . print_node_by_inorder ( ) <NEWLINE> print ( ) <NEWLINE> self . root . print_node_by_preorder ( ) <NEWLINE> print ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> bst = BST ( ) <NEWLINE> <NL> lines = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> lines . append ( line . rstrip ( ) ) <NEWLINE> <DEDENT> num_cmds = int ( lines [ 0 ] ) <NEWLINE> for line in lines [ 1 : 1 + num_cmds ] : <NEWLINE> <INDENT> line_split = line . split ( <STRING> ) <NEWLINE> cmd = line_split [ 0 ] <NEWLINE> <NL> try : <NEWLINE> <INDENT> val = int ( line_split [ 1 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> if cmd == <STRING> : <NEWLINE> <INDENT> bst . cmd_insert ( val ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> if bst . cmd_find ( val ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> bst . cmd_print ( ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> bst . cmd_delete ( val ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> assert ( False ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if K % 7 == 0 : <NEWLINE> <INDENT> L = 9 * K // 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = 9 * K <NEWLINE> <DEDENT> rest = 10 % L <NEWLINE> for i in range ( 1 , L + 1 ) : <NEWLINE> <INDENT> if rest == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rest = ( rest * 10 ) % L <NEWLINE> <DEDENT> if i == L and rest != 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> a = ( 2 * x - y ) // 3 <NEWLINE> b = ( 2 * y - x ) // 3 <NEWLINE> <NL> <NL> <NL> if a != ( 2 * x - y ) / 3 or b != ( 2 * y - x ) / 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif a < 0 or b < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max = a + b + 10 <NEWLINE> fac = [ 0 ] * max <NEWLINE> finv = [ 0 ] * max <NEWLINE> inv = [ 0 ] * max <NEWLINE> <NL> fac [ 0 ] = fac [ 1 ] = 1 <NEWLINE> finv [ 0 ] = finv [ 1 ] = 1 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> for i in range ( 2 , max ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i % mod <NEWLINE> inv [ i ] = mod - inv [ mod % i ] * ( mod // i ) % mod <NEWLINE> finv [ i ] = finv [ i - 1 ] * inv [ i ] % mod <NEWLINE> <NL> <DEDENT> ans = fac [ a + b ] * ( finv [ a ] * finv [ b ] % mod ) % mod <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> table = [ [ 0 ] * n for i in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> l -= 1 <NEWLINE> r -= 1 <NEWLINE> table [ r ] [ l ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 1 , n ) : <NEWLINE> <INDENT> table [ i ] [ j ] = table [ i ] [ j ] + table [ i ] [ j - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 1 , n ) : <NEWLINE> <INDENT> table [ j ] [ i ] = table [ j ] [ i ] + table [ j - 1 ] [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> l -= 1 <NEWLINE> r -= 1 <NEWLINE> if l != 0 : <NEWLINE> <INDENT> ans = table [ r ] [ r ] - table [ r ] [ l - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = table [ r ] [ r ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> s = 0 <NEWLINE> <NL> def mod ( x ) : <NEWLINE> <INDENT> return int ( x % int ( 1e+9 + 7 ) ) <NEWLINE> <NL> <DEDENT> for i in reversed ( range ( N - 1 ) ) : <NEWLINE> <INDENT> s += A [ i + 1 ] <NEWLINE> s = mod ( s ) <NEWLINE> ans += A [ i ] * s <NEWLINE> <NL> ans = mod ( ans ) <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
x = input ( ) . split ( ) <NEWLINE> x . sort ( ) <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( x [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( x [ 2 ] ) <NEWLINE>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 13 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> <NL> def f ( n ) : <NEWLINE> <INDENT> a , b = LS ( ) <NEWLINE> if a == b : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> a = [ int ( c ) for c in a ] <NEWLINE> b = [ int ( c ) for c in b ] <NEWLINE> aa = [ a ] <NEWLINE> ad = set ( ) <NEWLINE> ad . add ( tuple ( a ) ) <NEWLINE> r = 0 <NEWLINE> while True : <NEWLINE> <INDENT> r += 1 <NEWLINE> na = [ ] <NEWLINE> for a in aa : <NEWLINE> <INDENT> ti = 0 <NEWLINE> for i in range ( r - 1 , n ) : <NEWLINE> <INDENT> if a [ i ] != b [ i ] : <NEWLINE> <INDENT> ti = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> sa = b [ ti ] - a [ ti ] <NEWLINE> for j in range ( ti + 1 , n + 1 ) : <NEWLINE> <INDENT> t = [ ( a [ i ] + sa ) % 10 if ti <= i < j else a [ i ] for i in range ( n ) ] <NEWLINE> k = tuple ( t ) <NEWLINE> if k in ad : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if t == b : <NEWLINE> <INDENT> return r <NEWLINE> <DEDENT> ad . add ( k ) <NEWLINE> na . append ( t ) <NEWLINE> <DEDENT> <DEDENT> aa = na <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rr . append ( f ( n ) ) <NEWLINE> <NL> <DEDENT> return <STRING> . join ( map ( str , rr ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 2000000 ) <NEWLINE> <NL> s = input ( ) <NEWLINE> <NL> def solve ( i ) : <NEWLINE> <INDENT> if i == 2 : <NEWLINE> <INDENT> if s [ i - 1 ] == s [ i ] : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return solve ( i - 1 ) + 1 <NEWLINE> <DEDENT> <DEDENT> if i == 1 : <NEWLINE> <INDENT> if s [ i - 1 ] == s [ i ] : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> <DEDENT> if i == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> if s [ i ] != s [ i - 1 ] : <NEWLINE> <INDENT> return solve ( i - 1 ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return solve ( i - 3 ) + 2 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( solve ( len ( s ) - 1 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> res = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> L . append ( S ) <NEWLINE> <NL> <DEDENT> L . sort ( ) <NEWLINE> <NL> max_cnt = 0 <NEWLINE> cnt = 0 <NEWLINE> <NL> L . append ( 0 ) <NEWLINE> <NL> for i in range ( len ( L ) - 1 ) : <NEWLINE> <INDENT> if L [ i ] == L [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if cnt > max_cnt : <NEWLINE> <INDENT> max_cnt = cnt <NEWLINE> res = [ ] <NEWLINE> res . append ( L [ i ] ) <NEWLINE> <DEDENT> elif cnt == max_cnt : <NEWLINE> <INDENT> res . append ( L [ i ] ) <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in res : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> if x > k * d : <NEWLINE> <INDENT> print ( x - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( k - x // d ) % 2 == 0 : <NEWLINE> <INDENT> print ( x - d * ( x // d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> print ( abs ( d - ( x - d * ( x // d ) ) ) ) <NEWLINE> <DEDENT> <DEDENT>
s = list ( input ( ) ) <NEWLINE> ls = len ( s ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> lt = len ( t ) <NEWLINE> can = [ ] <NEWLINE> for i in range ( ls - lt , - 1 , - 1 ) : <NEWLINE> <INDENT> ok = 0 <NEWLINE> for j in range ( lt ) : <NEWLINE> <INDENT> if s [ i + j ] == t [ j ] or s [ i + j ] == <STRING> : <NEWLINE> <INDENT> ok += 1 <NEWLINE> <DEDENT> <DEDENT> if ok == lt : <NEWLINE> <INDENT> c = [ 0 ] * ls <NEWLINE> for k in range ( ls ) : <NEWLINE> <INDENT> if s [ k ] == <STRING> : <NEWLINE> <INDENT> if k < i or k >= i + lt : <NEWLINE> <INDENT> c [ k ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ k ] = t [ k - i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> c [ k ] = s [ k ] <NEWLINE> <DEDENT> <DEDENT> can . append ( <STRING> . join ( c ) ) <NEWLINE> <DEDENT> <DEDENT> if len ( can ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sorted ( list ( can ) ) [ 0 ] ) <NEWLINE> <DEDENT>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> mh = [ 0 for i in range ( h ) ] <NEWLINE> mw = [ 0 for j in range ( w ) ] <NEWLINE> <NL> for i , j in a : <NEWLINE> <INDENT> mh [ i ] += 1 <NEWLINE> mw [ j ] += 1 <NEWLINE> <NL> <DEDENT> hmax = max ( mh ) <NEWLINE> wmax = max ( mw ) <NEWLINE> ans = hmax + wmax <NEWLINE> <NL> flag = mh . count ( hmax ) * mw . count ( wmax ) <NEWLINE> for i , j in a : <NEWLINE> <INDENT> if mh [ i ] == hmax and mw [ j ] == wmax : <NEWLINE> <INDENT> flag -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( ans - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = { } <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> B [ i ] = 0 <NEWLINE> <NL> <DEDENT> for j in A : <NEWLINE> <INDENT> B [ j ] += 1 <NEWLINE> <NL> <DEDENT> for l in B . values ( ) : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> file_input = sys . stdin <NEWLINE> N , W = map ( int , file_input . readline ( ) . split ( ) ) <NEWLINE> C = [ 0 ] * ( W + 1 ) <NEWLINE> for line in file_input : <NEWLINE> <INDENT> item_v , item_w = map ( int , line . split ( ) ) <NEWLINE> for i , vals in enumerate ( zip ( C , C [ item_w : ] ) , start = item_w ) : <NEWLINE> <INDENT> v1 , v2 = vals <NEWLINE> C [ i ] = max ( v1 + item_v , v2 ) <NEWLINE> <DEDENT> <DEDENT> print ( C [ W ] ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
def solve ( ) : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ a [ i ] for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> sum_e = 0 <NEWLINE> ans_e = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> sum_e += a [ i ] <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> if sum_e <= 0 : <NEWLINE> <INDENT> ans_e += abs ( sum_e ) + 1 <NEWLINE> sum_e += abs ( sum_e ) + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if sum_e >= 0 : <NEWLINE> <INDENT> ans_e += abs ( sum_e ) + 1 <NEWLINE> sum_e -= abs ( sum_e ) + 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> sum_o = 0 <NEWLINE> ans_o = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> sum_o += b [ i ] <NEWLINE> if i % 2 == 1 : <NEWLINE> <INDENT> if sum_o <= 0 : <NEWLINE> <INDENT> ans_o += abs ( sum_o ) + 1 <NEWLINE> sum_o += abs ( sum_o ) + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if sum_o >= 0 : <NEWLINE> <INDENT> ans_o += abs ( sum_o ) + 1 <NEWLINE> sum_o -= abs ( sum_o ) + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans_o <= ans_e : <NEWLINE> <INDENT> ans = ans_o <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans_e <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> count [ a ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , 10 ** 5 ) : <NEWLINE> <INDENT> X = count [ i - 1 ] + count [ i ] + count [ i + 1 ] <NEWLINE> ans = max ( ans , X ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> records = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> l = <STRING> . join ( sorted ( input ( ) ) ) <NEWLINE> records . setdefault ( l , 0 ) <NEWLINE> records [ l ] += 1 <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for v in records . values ( ) : <NEWLINE> <INDENT> if v == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += math . comb ( v , 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in set ( A ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import numpy as np <NEWLINE> <NL> N = 10 <NEWLINE> ARR = [ 3 , 1 , 4 , 1 , 5 , 9 , 2 , 6 , 5 , 3 ] <NEWLINE> <NL> N = 10 <NEWLINE> ARR = [ 3 , 14 , 159 , 2653 , 58979 , 323846 , 2643383 , 27950288 , 419716939 , 9375105820 ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> ARR = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def calculate ( n , arr ) : <NEWLINE> <INDENT> if max ( arr ) == 0 : <NEWLINE> <INDENT> mathNum = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mathNum = math . ceil ( math . log ( max ( arr ) , 2 ) ) <NEWLINE> <NL> <DEDENT> oneArray = [ 0 ] * mathNum <NEWLINE> zeroArray = [ 0 ] * mathNum <NEWLINE> <NL> result = 0 <NEWLINE> arr = np . array ( arr ) <NEWLINE> for i in range ( mathNum ) : <NEWLINE> <INDENT> s = ( arr >> i ) & 1 <NEWLINE> <NL> oneCount = np . count_nonzero ( s ) <NEWLINE> zeroCount = n - oneCount <NEWLINE> oneArray [ i ] = oneCount <NEWLINE> zeroArray [ i ] = zeroCount <NEWLINE> <NL> <DEDENT> for i in range ( mathNum ) : <NEWLINE> <INDENT> result += ( 2 ** i ) * ( oneArray [ i ] * zeroArray [ i ] ) <NEWLINE> <NL> <DEDENT> print ( result % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <NL> <DEDENT> calculate ( N , ARR ) <NEWLINE>
NUM = 1000000007 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> all_colab = pow ( 10 , N ) <NEWLINE> except_0or9_colab = pow ( 9 , N ) <NEWLINE> except_0and9_colab = pow ( 8 , N ) <NEWLINE> <NL> include_0and9_colab = all_colab - ( 2 * except_0or9_colab - except_0and9_colab ) <NEWLINE> <NL> print ( include_0and9_colab % NUM ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import copy <NEWLINE> import random <NEWLINE> import bisect <COMMENT> <NEWLINE> import fractions <COMMENT> <NEWLINE> import math <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( mod ) <COMMENT> <NEWLINE> <NL> d = collections . deque ( ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> def factorint ( N ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> table = [ ] <NEWLINE> tmp = 2 <NEWLINE> while ( N > 1 ) : <NEWLINE> <INDENT> for i in range ( tmp , N + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> while N % i == 0 : <NEWLINE> <INDENT> N = N // i <NEWLINE> table . append ( i ) <NEWLINE> <DEDENT> tmp = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> table_ = collections . Counter ( table ) <NEWLINE> return table_ <NEWLINE> <NL> <DEDENT> def primes ( n ) : <COMMENT> <NEWLINE> <INDENT> cnt = collections . defaultdict ( int ) <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> n //= i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> cnt [ n ] += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> factors = primes ( N ) <NEWLINE> ans = 0 <NEWLINE> <NL> for key in factors . keys ( ) : <NEWLINE> <INDENT> f_c = factors [ key ] <NEWLINE> tmp = 1 <NEWLINE> while f_c >= tmp : <NEWLINE> <INDENT> ans += 1 <NEWLINE> f_c -= tmp <NEWLINE> tmp += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from collections import defaultdict <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> def convolve ( x , y ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> z = np . convolve ( x , y ) % MOD <NEWLINE> z [ : 12 ] += z [ 13 : 25 ] <NEWLINE> return z [ : 13 ] % MOD <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> mod = 10 ** 9 + 7 <NEWLINE> S = input ( ) [ : : - 1 ] <NEWLINE> dp = np . zeros ( ( len ( S ) , 13 ) , dtype = <STRING> ) <NEWLINE> amari = 1 <NEWLINE> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> dp [ 0 ] [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp [ 0 ] [ int ( S [ 0 ] ) ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , len ( S ) ) : <NEWLINE> <INDENT> arr = np . zeros ( 13 , dtype = <STRING> ) <NEWLINE> amari = 10 * amari % 13 <NEWLINE> if S [ i ] == <STRING> : <NEWLINE> <INDENT> for si in range ( 10 ) : <NEWLINE> <INDENT> arr [ amari * si % 13 ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> arr [ amari * int ( S [ i ] ) % 13 ] = 1 <NEWLINE> <DEDENT> dp [ i ] = convolve ( dp [ i - 1 ] , arr ) <NEWLINE> <NL> <DEDENT> print ( dp [ len ( S ) - 1 ] [ 5 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> flag = True <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> flag = False <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> flag = False <NEWLINE> <NL> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) [ : : - 1 ] <NEWLINE> N = len ( S ) <NEWLINE> sum_of_mod = [ 0 ] * 2019 <NEWLINE> sum_of_mod [ 0 ] += 1 <NEWLINE> digit = 1 <NEWLINE> now = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> now = int ( S [ i ] ) * digit + now <NEWLINE> now %= 2019 <NEWLINE> digit *= 10 <NEWLINE> digit %= 2019 <NEWLINE> sum_of_mod [ now ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> ans += sum_of_mod [ i ] * ( sum_of_mod [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
num = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> n = num [ 0 ] <NEWLINE> k = num [ 1 ] <NEWLINE> v = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if ( v [ i - k ] < v [ i ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
from bisect import * <NEWLINE> from collections import defaultdict <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> T = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * T <NEWLINE> for t in range ( T ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> left = defaultdict ( lambda : [ ] ) <NEWLINE> right = defaultdict ( lambda : [ ] ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> k , l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if k == N : <NEWLINE> <INDENT> ans [ t ] += l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if l > r : <NEWLINE> <INDENT> insort_right ( left [ k ] , l - r ) <NEWLINE> <DEDENT> elif l < r : <NEWLINE> <INDENT> insort_right ( right [ k + 1 ] , r - l ) <NEWLINE> <DEDENT> ans [ t ] += min ( l , r ) <NEWLINE> <DEDENT> <DEDENT> lis = [ ] <NEWLINE> for i in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> for l in left [ i ] : <NEWLINE> <INDENT> insort_right ( lis , l ) <NEWLINE> <DEDENT> if len ( lis ) : <NEWLINE> <INDENT> ans [ t ] += lis . pop ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> lis = [ ] <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> for r in right [ i ] : <NEWLINE> <INDENT> insort_right ( lis , r ) <NEWLINE> <DEDENT> if len ( lis ) : <NEWLINE> <INDENT> ans [ t ] += lis . pop ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> print ( * solve ( ) , sep = <STRING> ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = ( sum ( p [ 0 : K ] ) + K ) / 2 <NEWLINE> pre = ans <NEWLINE> for i in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> pre -= ( p [ i - 1 ] - p [ i + K - 1 ] ) / 2 <NEWLINE> ans = max ( pre , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> import bisect <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> from numba import jit <NEWLINE> <NL> @ jit <NEWLINE> def run_dp ( MAP , dp , Rs , Cs ) : <NEWLINE> <INDENT> for i in range ( 1 , len ( Rs ) + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , len ( Cs ) + 1 ) : <NEWLINE> <INDENT> for k in range ( 4 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] [ 0 ] = max ( dp [ i ] [ j ] [ 0 ] , dp [ i - 1 ] [ j ] [ k ] ) <NEWLINE> if MAP [ i ] [ j ] : <NEWLINE> <INDENT> dp [ i ] [ j ] [ 1 ] = max ( dp [ i ] [ j ] [ 1 ] , dp [ i - 1 ] [ j ] [ k ] + MAP [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> dp [ i ] [ j ] [ k ] = max ( dp [ i ] [ j ] [ k ] , dp [ i ] [ j - 1 ] [ k ] ) <NEWLINE> if MAP [ i ] [ j ] and k < 3 : <NEWLINE> <INDENT> dp [ i ] [ j ] [ k + 1 ] = max ( dp [ i ] [ j ] [ k + 1 ] , dp [ i ] [ j - 1 ] [ k ] + MAP [ i ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return dp <NEWLINE> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> R , C , K = map ( int , sysread ( ) . split ( ) ) <NEWLINE> Rs = set ( ) <NEWLINE> Cs = set ( ) <NEWLINE> vals = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> r , c , v = map ( int , sysread ( ) . split ( ) ) <NEWLINE> vals . append ( ( r , c , v ) ) <NEWLINE> Rs . add ( r ) <NEWLINE> Cs . add ( c ) <NEWLINE> <COMMENT> <NL> <DEDENT> Rs = np . array ( sorted ( list ( Rs ) ) ) <NEWLINE> <COMMENT> <NL> Cs = np . array ( sorted ( list ( Cs ) ) ) <NEWLINE> r_idx = { r : i + 1 for i , r in enumerate ( Rs ) } <NEWLINE> c_idx = { c : i + 1 for i , c in enumerate ( Cs ) } <NEWLINE> <COMMENT> <NL> MAP = np . zeros ( ( len ( Rs ) + 1 , len ( Cs ) + 1 ) , dtype = np . int64 ) <NEWLINE> for r , c , v in vals : <NEWLINE> <INDENT> rn = r_idx [ r ] <NEWLINE> cn = c_idx [ c ] <NEWLINE> MAP [ rn ] [ cn ] = v <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> dp = np . zeros ( ( len ( Rs ) + 1 , len ( Cs ) + 1 , 4 ) , dtype = np . int64 ) <NEWLINE> <NL> run_dp ( MAP , dp , Rs , Cs ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> dp = run_dp ( MAP , dp , Rs , Cs ) <NEWLINE> <NL> print ( max ( dp [ len ( Rs ) ] [ len ( Cs ) ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ai = - 1 <NEWLINE> bi = - 1 <NEWLINE> answer = 0 <NEWLINE> t_sum = 0 <NEWLINE> if sum ( a ) + sum ( b ) <= k : <NEWLINE> <INDENT> print ( n + m ) <NEWLINE> <DEDENT> elif sum ( a ) <= k : <NEWLINE> <INDENT> t_sum = sum ( a ) <NEWLINE> ai = n - 1 <NEWLINE> while True : <NEWLINE> <INDENT> bi += 1 <NEWLINE> if bi == m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if t_sum + b [ bi ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t_sum += b [ bi ] <NEWLINE> <DEDENT> bi -= 1 <NEWLINE> answer = ai + bi + 2 <NEWLINE> while ai >= 0 : <NEWLINE> <INDENT> t_sum -= a [ ai ] <NEWLINE> ai -= 1 <NEWLINE> while bi <= m - 1 : <NEWLINE> <INDENT> bi += 1 <NEWLINE> if bi == m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if t_sum + b [ bi ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t_sum += b [ bi ] <NEWLINE> <DEDENT> bi -= 1 <NEWLINE> if ai + bi + 2 > answer : <NEWLINE> <INDENT> answer = ai + bi + 2 <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> ai += 1 <NEWLINE> if t_sum + a [ ai ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t_sum += a [ ai ] <NEWLINE> <DEDENT> ai -= 1 <NEWLINE> while True : <NEWLINE> <INDENT> bi += 1 <NEWLINE> if bi == m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if t_sum + b [ bi ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t_sum += b [ bi ] <NEWLINE> <DEDENT> bi -= 1 <NEWLINE> answer = ai + bi + 2 <NEWLINE> while ai >= 0 : <NEWLINE> <INDENT> t_sum -= a [ ai ] <NEWLINE> ai -= 1 <NEWLINE> while bi <= m - 1 : <NEWLINE> <INDENT> bi += 1 <NEWLINE> if bi == m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if t_sum + b [ bi ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t_sum += b [ bi ] <NEWLINE> <DEDENT> bi -= 1 <NEWLINE> if ai + bi + 2 > answer : <NEWLINE> <INDENT> answer = ai + bi + 2 <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE> <DEDENT>
import math <NEWLINE> s = input ( ) . split ( ) <NEWLINE> n = int ( s [ 0 ] ) <NEWLINE> m = int ( s [ 1 ] ) <NEWLINE> l = 0 <NEWLINE> r = float ( <STRING> ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = max ( l , s [ 0 ] ) <NEWLINE> r = min ( r , s [ 1 ] ) <NEWLINE> <DEDENT> a = r - l <NEWLINE> if a >= 0 : <NEWLINE> <INDENT> print ( a + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = [ 0 ] * 10 ** 5 <NEWLINE> for i in A : <NEWLINE> <INDENT> if i > 1 : <NEWLINE> <INDENT> count [ i - 1 ] += 1 <NEWLINE> <DEDENT> count [ i ] += 1 <NEWLINE> if i < 10 ** 5 - 1 : <NEWLINE> <INDENT> count [ i + 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( max ( count ) ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 2017 * 2018 <NEWLINE> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , i * j % 2019 ) <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from copy import deepcopy <NEWLINE> from collections import deque <NEWLINE> from heapq import heappush , heappop <NEWLINE> <NL> <NL> def warshallfloyd ( cost , V ) : <NEWLINE> <INDENT> INF = float ( <STRING> ) <NEWLINE> for k in range ( V ) : <NEWLINE> <INDENT> for i in range ( V ) : <NEWLINE> <INDENT> for j in range ( V ) : <NEWLINE> <INDENT> if cost [ i ] [ k ] != INF and cost [ k ] [ j ] != INF : <NEWLINE> <INDENT> cost [ i ] [ j ] = min ( cost [ i ] [ j ] , cost [ i ] [ k ] + cost [ k ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in cost : <NEWLINE> <INDENT> if float ( <STRING> ) in i : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ float ( <STRING> ) for i in range ( N ) ] for j in range ( N ) ] <NEWLINE> ab = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab . append ( [ a - 1 , b - 1 ] ) <NEWLINE> edge [ a - 1 ] [ b - 1 ] = 1 <NEWLINE> edge [ b - 1 ] [ a - 1 ] = 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for a , b in ab : <NEWLINE> <INDENT> tmp = deepcopy ( edge ) <NEWLINE> tmp [ a ] [ b ] = float ( <STRING> ) <NEWLINE> tmp [ b ] [ a ] = float ( <STRING> ) <NEWLINE> if not warshallfloyd ( tmp , N ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> re = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> re = re * i <NEWLINE> if re > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( re ) <NEWLINE> <DEDENT>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 2018 <NEWLINE> <NL> if r - l > 2018 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , ( i * j ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if D [ 0 ] != 0 or 0 in D [ 1 : ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> A = collections . Counter ( D ) <NEWLINE> A = list ( A . items ( ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> if len ( A ) != max ( D ) + 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( max ( D ) ) : <NEWLINE> <INDENT> ans *= A [ i ] [ 1 ] ** A [ i + 1 ] [ 1 ] <NEWLINE> if ans >= 998244353 : <NEWLINE> <INDENT> ans %= 998244353 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
MOD = ( 10 ** 9 ) + 7 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> negs = [ - x for x in a if x < 0 ] <NEWLINE> non_negs = [ x for x in a if x >= 0 ] <NEWLINE> <NL> if len ( non_negs ) == 0 and k % 2 == 1 : <NEWLINE> <INDENT> negs . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans = ans * - negs [ i ] % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> negs_p , non_negs_p = 0 , 0 <NEWLINE> <NL> negs . sort ( reverse = True ) <NEWLINE> non_negs . sort ( reverse = True ) <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> if negs_p == len ( negs ) : <NEWLINE> <INDENT> non_negs_p += 1 <NEWLINE> <DEDENT> elif non_negs_p == len ( non_negs ) : <NEWLINE> <INDENT> negs_p += 1 <NEWLINE> <DEDENT> elif negs [ negs_p ] > non_negs [ non_negs_p ] : <NEWLINE> <INDENT> negs_p += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> non_negs_p += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if negs_p % 2 == 0 or k == n : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( negs_p ) : <NEWLINE> <INDENT> ans = ans * - negs [ i ] % MOD <NEWLINE> <DEDENT> for i in range ( non_negs_p ) : <NEWLINE> <INDENT> ans = ans * non_negs [ i ] % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if negs_p == len ( negs ) or non_negs_p == 0 : <NEWLINE> <INDENT> negs_p -= 1 <NEWLINE> non_negs_p += 1 <NEWLINE> ans = 1 <NEWLINE> for i in range ( negs_p ) : <NEWLINE> <INDENT> ans = ans * - negs [ i ] % MOD <NEWLINE> <DEDENT> for i in range ( non_negs_p ) : <NEWLINE> <INDENT> ans = ans * non_negs [ i ] % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if non_negs_p == len ( non_negs ) or negs_p == 0 : <NEWLINE> <INDENT> negs_p += 1 <NEWLINE> non_negs_p -= 1 <NEWLINE> ans = 1 <NEWLINE> for i in range ( negs_p ) : <NEWLINE> <INDENT> ans = ans * - negs [ i ] % MOD <NEWLINE> <DEDENT> for i in range ( non_negs_p ) : <NEWLINE> <INDENT> ans = ans * non_negs [ i ] % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> a = negs [ negs_p - 1 ] <NEWLINE> b = negs [ negs_p ] <NEWLINE> c = non_negs [ non_negs_p - 1 ] <NEWLINE> d = non_negs [ non_negs_p ] <NEWLINE> <NL> if a * b > c * d : <NEWLINE> <INDENT> negs_p += 1 <NEWLINE> non_negs_p -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> negs_p -= 1 <NEWLINE> non_negs_p += 1 <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( negs_p ) : <NEWLINE> <INDENT> ans = ans * - negs [ i ] % MOD <NEWLINE> <DEDENT> for i in range ( non_negs_p ) : <NEWLINE> <INDENT> ans = ans * non_negs [ i ] % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> y = n // i <NEWLINE> ans += y * ( y + 1 ) * i // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from itertools import combinations_with_replacement <NEWLINE> <NL> N , M , Q , * ABCD = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> L = list ( zip ( * [ iter ( ABCD ) ] * 4 ) ) <NEWLINE> <NL> print ( max ( sum ( d for a , b , c , d in L if A [ b - 1 ] - A [ a - 1 ] == c ) for A in combinations_with_replacement ( range ( 1 , M + 1 ) , N ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = sorted ( arr ) <NEWLINE> m = arr [ - 1 ] <NEWLINE> li = [ 0 ] * ( m + 1 ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in arr : <NEWLINE> <INDENT> for j in range ( i , m + 1 , i ) : <NEWLINE> <INDENT> li [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in arr : <NEWLINE> <INDENT> if li [ i ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> rem = [ 0 ] * 2019 <COMMENT> <NEWLINE> rem [ 0 ] = 1 <COMMENT> <NEWLINE> <NL> temp = 0 <NEWLINE> digit = 1 <NEWLINE> for i , c in enumerate ( s [ : : - 1 ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> temp += int ( c ) * digit <NEWLINE> rem [ temp % 2019 ] += 1 <NEWLINE> digit *= 10 <NEWLINE> digit %= 2019 <NEWLINE> <NL> <DEDENT> return sum ( c * ( c - 1 ) // 2 for c in rem ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
def make_cyclic ( w , v ) : <NEWLINE> <INDENT> flags = [ True ] * len ( w ) <NEWLINE> <NL> cyclics = [ ] <NEWLINE> for i in range ( len ( w ) ) : <NEWLINE> <INDENT> if flags [ i ] : <NEWLINE> <INDENT> flags [ i ] = False <NEWLINE> cycle = [ w [ i ] ] <NEWLINE> now = w [ i ] <NEWLINE> while True : <NEWLINE> <INDENT> j = v . index ( now ) <NEWLINE> if j == i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cycle . append ( w [ j ] ) <NEWLINE> now = w [ j ] <NEWLINE> flags [ j ] = False <NEWLINE> <DEDENT> cyclics . append ( cycle ) <NEWLINE> <NL> <DEDENT> <DEDENT> return cyclics <NEWLINE> <NL> <NL> <DEDENT> def min_cost_sort ( w ) : <NEWLINE> <INDENT> v = w . copy ( ) <NEWLINE> v . sort ( ) <NEWLINE> <NL> cyclics = make_cyclic ( w , v ) <NEWLINE> <NL> ans = 0 <NEWLINE> for cycle in cyclics : <NEWLINE> <INDENT> inner_cycle = min ( cycle ) * ( len ( cycle ) - 2 ) + sum ( cycle ) <NEWLINE> if len ( set ( w ) - set ( cycle ) ) >= 1 : <NEWLINE> <INDENT> outer_cycle = min ( cycle ) + min ( set ( w ) - set ( cycle ) ) * ( len ( cycle ) + 1 ) + sum ( cycle ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> outer_cycle = inner_cycle + 1 <NEWLINE> <DEDENT> ans += min ( inner_cycle , outer_cycle ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> w = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> print ( min_cost_sort ( w ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 0 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> back = sum ( a ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> back -= a [ i ] <NEWLINE> total += a [ i ] * back <NEWLINE> total = total % MOD <NEWLINE> <DEDENT> print ( total ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> num = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> if ( A >= K ) : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif ( A < K and K <= ( A + B ) ) : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A - ( K - ( A + B ) ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> c [ A [ i ] - 1 ] = c [ A [ i ] - 1 ] + 1 <NEWLINE> <NL> <DEDENT> for j in c : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> ok = [ 0 ] * k <NEWLINE> x = 7 % k <NEWLINE> ok [ x ] = 1 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> now += 1 <NEWLINE> x = ( x * 10 + 7 ) % k <NEWLINE> if ok [ x ] == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif x == 0 : <NEWLINE> <INDENT> print ( now ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ok [ x ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> notwinner = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> ab = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if H [ ab [ 0 ] - 1 ] > H [ ab [ 1 ] - 1 ] : <NEWLINE> <INDENT> notwinner . append ( ab [ 1 ] ) <NEWLINE> <DEDENT> elif H [ ab [ 0 ] - 1 ] < H [ ab [ 1 ] - 1 ] : <NEWLINE> <INDENT> notwinner . append ( ab [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> notwinner . append ( ab [ 0 ] ) <NEWLINE> notwinner . append ( ab [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> wtou = N - len ( set ( notwinner ) ) <COMMENT> <NEWLINE> print ( wtou ) <NEWLINE>
from math import gcd <NEWLINE> z = range ( 1 , 1 + int ( input ( ) ) ) <NEWLINE> y = 0 <NEWLINE> for a in z : <NEWLINE> <INDENT> for b in z : <NEWLINE> <INDENT> for c in z : <NEWLINE> <INDENT> y += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( y ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = input ( ) . split ( ) <NEWLINE> x_int = [ int ( i ) for i in x ] <NEWLINE> y = list ( range ( n ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> y [ - i - 1 ] = x_int [ i ] <NEWLINE> <DEDENT> y_str = [ str ( i ) for i in y ] <NEWLINE> print ( <STRING> . join ( y_str ) ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if k <= a : <NEWLINE> <INDENT> ans = k <NEWLINE> <DEDENT> elif k <= b + a : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a - ( k - ( a + b ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> V = [ S . count ( <STRING> ) , S . count ( <STRING> ) , S . count ( <STRING> ) ] <NEWLINE> V . sort ( ) <NEWLINE> ans = <STRING> <NEWLINE> if V [ 2 ] - V [ 0 ] > 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> print ( A - K , B ) <NEWLINE> <DEDENT> elif K <= ( A + B ) : <NEWLINE> <INDENT> print ( 0 , B - ( K - A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> xlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 10 ** 20 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = min ( abs ( xlist [ i ] - xlist [ i + k - 1 ] ) + min ( abs ( xlist [ i ] ) , abs ( xlist [ i + k - 1 ] ) ) , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> def ii ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def mi ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def li2 ( N ) : return [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> def dp2 ( ini , i , j ) : return [ [ ini ] * i for _ in range ( j ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N , M = mi ( ) <NEWLINE> Q = li2 ( M ) <NEWLINE> Q = sorted ( Q , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> l = [ N ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> ind = max ( 0 , Q [ i ] [ 0 ] - 1 ) <NEWLINE> l [ ind ] = min ( Q [ i ] [ 1 ] - 1 , l [ ind ] ) <NEWLINE> <NL> <DEDENT> for i in reversed ( range ( N - 1 ) ) : <NEWLINE> <INDENT> l [ i ] = min ( l [ i ] , l [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> i = 0 <NEWLINE> <COMMENT> <NL> while True : <NEWLINE> <INDENT> i = l [ i ] <NEWLINE> cnt += 1 <NEWLINE> if l [ i ] == N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from sys import stdin <NEWLINE> nii = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> lnii = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n , k = nii ( ) <NEWLINE> a = lnii ( ) <NEWLINE> <NL> x = 0 <NEWLINE> x_list = [ 1 ] <NEWLINE> x_table = [ 0 for i in range ( n + 1 ) ] <NEWLINE> x_table [ 1 ] = 1 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> nx = a [ x ] <NEWLINE> <NL> if x_table [ nx ] != 0 : <NEWLINE> <INDENT> inx = x_list . index ( nx ) <NEWLINE> loop = x_list [ inx : ] <NEWLINE> zan = k - i <NEWLINE> <NL> q = zan % len ( loop ) <NEWLINE> <NL> nx = loop [ q - 1 ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> x = nx - 1 <NEWLINE> x_list . append ( nx ) <NEWLINE> x_table [ nx ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( nx ) <NEWLINE>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = x <NEWLINE> dup = [ 0 ] * ( 10 ** 5 + 10 ) <NEWLINE> mod = [ a ] <NEWLINE> loop = [ ] <NEWLINE> cnt = 0 <NEWLINE> while cnt < n : <NEWLINE> <INDENT> a = a ** 2 % m <NEWLINE> if dup [ a ] == 1 : <NEWLINE> <INDENT> i = mod . index ( a ) <NEWLINE> before = mod [ : i ] <NEWLINE> loop = mod [ i : ] <NEWLINE> break <NEWLINE> <DEDENT> mod . append ( a ) <NEWLINE> dup [ a ] = 1 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> length = len ( loop ) <NEWLINE> if length == 0 : <NEWLINE> <INDENT> print ( sum ( mod [ : n ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = ( n - i ) // length <NEWLINE> amari = ( n - i ) % length <NEWLINE> ans = sum ( before ) + t * sum ( loop ) + sum ( loop [ : amari ] ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def isprime ( z ) : <NEWLINE> <INDENT> if z == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> if z < 2 or z % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i = 3 <NEWLINE> while i <= math . sqrt ( z ) : <NEWLINE> <INDENT> if z % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i += 2 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> if isprime ( int ( input ( ) ) ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
def power ( x , y , mod ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> if y == 0 : return 1 <NEWLINE> elif y == 1 : return x % mod <NEWLINE> elif y % 2 == 0 : return power ( x , y // 2 , mod ) ** 2 % mod <NEWLINE> else : return power ( x , y // 2 , mod ) ** 2 * x % mod <NEWLINE> <NL> <NL> <DEDENT> def mul ( a , b , mod ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ( ( a % mod ) * ( b % mod ) ) % mod <NEWLINE> <NL> <DEDENT> def div ( a , b , mod ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if a == b : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return mul ( a , inv_t [ b ] , mod ) <NEWLINE> <NL> <NL> <DEDENT> def factorial_part ( start , last , mod ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> assert ( start <= last ) <NEWLINE> x = 1 <NEWLINE> for k in range ( start , last + 1 ) : <NEWLINE> <INDENT> x *= k <NEWLINE> x %= mod <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def combination ( n , a , mod ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> nCa = div ( factorial_part ( n - a + 1 , n , mod ) , factorial_part ( 1 , a , mod ) , mod ) <NEWLINE> return nCa <NEWLINE> <NL> <DEDENT> n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 998244353 <NEWLINE> <NL> P = mod <NEWLINE> N = max ( [ max ( [ n , m ] ) , k ] ) + 5 <NEWLINE> inv_t = [ 0 ] + [ 1 ] <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> inv_t += [ inv_t [ P % i ] * ( P - int ( P / i ) ) % P ] <NEWLINE> <NL> <DEDENT> powers = [ 0 ] * n <NEWLINE> a = m <NEWLINE> for kk in range ( n ) : <NEWLINE> <INDENT> powers [ kk ] = a <NEWLINE> a = ( a * ( m - 1 ) ) % mod <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> p = 1 <NEWLINE> comb = 1 <NEWLINE> kk = 0 <NEWLINE> a = n - kk <NEWLINE> c += powers [ a - 1 ] * comb <NEWLINE> <NL> for kk in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> a = n - kk <NEWLINE> comb = ( div ( comb , kk , mod ) * ( a ) ) % mod <NEWLINE> c = c + powers [ a - 1 ] * comb <NEWLINE> c = c % mod <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> n = int ( readline ( ) ) <NEWLINE> a = np . array ( readline ( ) . split ( ) , np . int32 ) <NEWLINE> <NL> a -= 1 <NEWLINE> ans = np . bincount ( a , minlength = n ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . buffer . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> S . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> S . sort ( ) <NEWLINE> goukei = sum ( S ) <NEWLINE> if goukei % 10 != 0 : <NEWLINE> <INDENT> print ( goukei ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> temp = goukei - S [ i ] <NEWLINE> if temp % 10 == 0 : <NEWLINE> <INDENT> temp = 0 <NEWLINE> <DEDENT> ans = max ( ans , temp ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
i = j = x = int ( input ( ) ) <NEWLINE> while i ** 5 - j ** 5 - x : i = - ~ i % 120 ; j = - ~ j % 217 - 98 <NEWLINE> print ( i , j ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> ans = r * g * b <NEWLINE> <NL> for k in range ( 1 , n // 2 + 1 ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i + 2 * k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ i + k ] and s [ i ] != s [ i + 2 * k ] and s [ i + k ] != s [ i + 2 * k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> query = ( map ( int , readline ( ) . strip ( ) . split ( ) ) for _ in range ( N - 1 ) ) <NEWLINE> <NL> tree = [ [ ] for _ in range ( N ) ] <NEWLINE> for u , v in query : <NEWLINE> <INDENT> tree [ u - 1 ] . append ( v - 1 ) <NEWLINE> tree [ v - 1 ] . append ( u - 1 ) <NEWLINE> <NL> <DEDENT> inf = 10 ** 18 <NEWLINE> dp = [ inf ] * ( N + 1 ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> <NL> def dfs ( node , parent ) : <NEWLINE> <INDENT> v = As [ node ] <NEWLINE> lb = binary_search ( dp , v ) <NEWLINE> old = dp [ lb ] <NEWLINE> dp [ lb ] = v <NEWLINE> ans [ node ] = binary_search ( dp , inf ) <NEWLINE> for child in tree [ node ] : <NEWLINE> <INDENT> if child == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( child , node ) <NEWLINE> <DEDENT> dp [ lb ] = old <NEWLINE> <NL> <DEDENT> dfs ( 0 , 0 ) <NEWLINE> <NL> for k in range ( N ) : <NEWLINE> <INDENT> print ( ans [ k ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def binary_search ( seq , v ) : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = len ( seq ) - 1 <NEWLINE> center = right // 2 <NEWLINE> <NL> while left != right : <NEWLINE> <INDENT> if v <= seq [ center ] : <NEWLINE> <INDENT> right = center <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = center + 1 <NEWLINE> <DEDENT> center = ( right + left ) // 2 <NEWLINE> <NL> <DEDENT> return center <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import isfinite <NEWLINE> from itertools import dropwhile <NEWLINE> <NL> n , knapsack = map ( int , input ( ) . split ( ) ) <NEWLINE> dpn = n * 100 <COMMENT> <NEWLINE> dp = [ float ( <STRING> ) ] * ( dpn + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> value , weight = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( dpn - value , 0 , - 1 ) : <NEWLINE> <INDENT> if not isfinite ( dp [ j ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> new_weight = dp [ j ] + weight <NEWLINE> if new_weight <= knapsack and dp [ j + value ] > new_weight : <NEWLINE> <INDENT> dp [ j + value ] = new_weight <NEWLINE> <DEDENT> <DEDENT> if weight <= knapsack and dp [ value ] > weight : <NEWLINE> <INDENT> dp [ value ] = weight <NEWLINE> <NL> <DEDENT> <DEDENT> print ( next ( dropwhile ( lambda i : not isfinite ( dp [ i ] ) , range ( dpn , - 1 , - 1 ) ) ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> <NL> input1 = input ( ) <NEWLINE> kbai = int ( input1 ) <NEWLINE> <NL> input2 = input ( ) . split ( <STRING> ) <NEWLINE> mins = int ( input2 [ 0 ] ) <NEWLINE> maxs = int ( input2 [ 1 ] ) <NEWLINE> flg = 0 <NEWLINE> ans = 0 <NEWLINE> tmp = 0 <NEWLINE> <NL> tmp = math . floor ( mins / kbai ) <NEWLINE> ans = tmp * kbai <NEWLINE> <COMMENT> <NL> <NL> while ans <= maxs : <NEWLINE> <INDENT> if ans >= mins and ans <= maxs : <NEWLINE> <INDENT> flg = 1 <NEWLINE> <DEDENT> ans = ans + kbai <NEWLINE> <NL> <DEDENT> if flg == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> A . sort ( ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> value = input ( ) <NEWLINE> if value not in S : <NEWLINE> <INDENT> S [ value ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ value ] += 1 <NEWLINE> <DEDENT> <DEDENT> S_largest = max ( S . values ( ) ) <NEWLINE> S_sorted = sorted ( S . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( len ( S_sorted ) ) : <NEWLINE> <INDENT> if S_sorted [ i ] [ 1 ] == S_largest : <NEWLINE> <INDENT> ans . append ( S_sorted [ i ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans_sorted = sorted ( ans ) <NEWLINE> for a in ans_sorted : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
mod = 998244353 <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> S = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> S . append ( ( L , R ) ) <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dpsum = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> dpsum [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> for s in S : <NEWLINE> <INDENT> l = i - s [ 1 ] <NEWLINE> r = i - s [ 0 ] <NEWLINE> if r < 1 : continue <NEWLINE> l = max ( 1 , l ) <NEWLINE> <NL> dp [ i ] += dpsum [ r ] - dpsum [ l - 1 ] <NEWLINE> dp [ i ] %= mod <NEWLINE> <NL> <DEDENT> dpsum [ i ] = ( dpsum [ i - 1 ] + dp [ i ] ) % mod <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
import time <NEWLINE> import sys <NEWLINE> start = time . clock ( ) <NEWLINE> def main ( ) : <NEWLINE> <INDENT> [ V , E , r ] = input ( ) . split ( <STRING> ) <NEWLINE> V = int ( V ) <NEWLINE> E = int ( E ) <NEWLINE> r = int ( r ) <NEWLINE> edgeset = [ ] <NEWLINE> for i in range ( E ) : <NEWLINE> <INDENT> [ s , t , d ] = input ( ) . split ( <STRING> ) <NEWLINE> edgeset . append ( [ int ( s ) , int ( t ) , int ( d ) ] ) <NEWLINE> <NL> <DEDENT> <STRING> <NEWLINE> <NL> <NL> <STRING> <NEWLINE> <STRING> <NEWLINE> edgeset . sort ( ) <NEWLINE> nedgeset = [ [ ] ] <NEWLINE> parameter = 0 <NEWLINE> for i in range ( len ( edgeset ) ) : <NEWLINE> <INDENT> if ( edgeset [ i ] [ 0 ] != parameter ) : <NEWLINE> <INDENT> for j in range ( edgeset [ i ] [ 0 ] - parameter ) : <NEWLINE> <INDENT> nedgeset . append ( [ ] ) <NEWLINE> <DEDENT> parameter = edgeset [ i ] [ 0 ] <NEWLINE> nedgeset [ parameter ] . append ( edgeset [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nedgeset [ parameter ] . append ( edgeset [ i ] ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( V - len ( nedgeset ) ) : <NEWLINE> <INDENT> nedgeset . append ( [ ] ) <NEWLINE> <DEDENT> edgeset = nedgeset <NEWLINE> <NL> setS = [ ] <NEWLINE> setV = [ ] <NEWLINE> setdist = [ 500000 * 10000 + 1 for i in range ( V ) ] <NEWLINE> <STRING> <NEWLINE> <NL> setS . append ( r ) <NEWLINE> setV . append ( [ r , 0 ] ) <NEWLINE> setdist [ r ] = 0 <NEWLINE> <STRING> <NEWLINE> <NL> for i in range ( 9999999999 ) : <NEWLINE> <INDENT> nowvert = setS [ - 1 ] <NEWLINE> for j in range ( len ( edgeset [ nowvert ] ) ) : <NEWLINE> <INDENT> newdist = edgeset [ nowvert ] [ j ] [ 2 ] + setdist [ nowvert ] <NEWLINE> olddist = setdist [ edgeset [ nowvert ] [ j ] [ 1 ] ] <NEWLINE> <STRING> <NEWLINE> if ( newdist < olddist ) : <NEWLINE> <INDENT> setdist [ edgeset [ nowvert ] [ j ] [ 1 ] ] = newdist <NEWLINE> setV = binary_heap_add ( setV , newdist , edgeset [ nowvert ] [ j ] [ 1 ] ) <NEWLINE> <DEDENT> <STRING> <NEWLINE> <DEDENT> if ( setV == [ [ r , 0 ] ] ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> setS . append ( setV [ 1 ] [ 0 ] ) <NEWLINE> setV = binary_heap_deletion ( setV ) <NEWLINE> <STRING> <NEWLINE> <NL> <DEDENT> for i in range ( V ) : <NEWLINE> <INDENT> if ( setdist [ i ] == 500000 * 10000 + 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( setdist [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <STRING> <NEWLINE> <NL> return 0 <NEWLINE> <NL> <DEDENT> def binary_heap_building ( dataset ) : <NEWLINE> <INDENT> for i in [ len ( dataset ) - x - 1 for x in range ( len ( dataset ) ) ] : <NEWLINE> <INDENT> if ( dataset [ i ] [ 1 ] < dataset [ int ( i / 2 ) ] [ 1 ] ) : <NEWLINE> <INDENT> trans = dataset [ i ] <NEWLINE> dataset [ i ] = dataset [ int ( i / 2 ) ] <NEWLINE> dataset [ int ( i / 2 ) ] = trans <NEWLINE> <DEDENT> <DEDENT> return dataset <NEWLINE> <NL> <DEDENT> def binary_heap_sorting ( dataset ) : <NEWLINE> <INDENT> lenth = len ( dataset ) <NEWLINE> dataset . insert ( 0 , [ - 1 , - 1 ] ) <NEWLINE> dataset = binary_heap_building ( dataset ) <NEWLINE> parameter = 0 <NEWLINE> ndataset = [ [ ] ] <NEWLINE> <NL> for i in range ( lenth ) : <NEWLINE> <INDENT> if ( parameter != dataset [ 1 ] [ 0 ] ) : <NEWLINE> <INDENT> for i in range ( dataset [ 1 ] [ 0 ] - parameter ) : <NEWLINE> <INDENT> ndataset . append ( [ ] ) <NEWLINE> <DEDENT> parameter = dataset [ 1 ] [ 0 ] <NEWLINE> ndataset [ parameter ] . append ( dataset [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ndataset [ parameter ] . append ( dataset [ 1 ] ) <NEWLINE> <DEDENT> dataset = binary_heap_deletion ( dataset ) <NEWLINE> <DEDENT> print ( 1 ) <NEWLINE> return ndataset <NEWLINE> <NL> <NL> <DEDENT> def binary_heap_change ( dataset , newdata , position ) : <NEWLINE> <INDENT> biposition = [ a [ 0 ] for a in dataset ] . index ( position ) <NEWLINE> dataset [ biposition ] [ 1 ] = newdata <NEWLINE> for i in range ( 999999 ) : <NEWLINE> <INDENT> if ( newdata < dataset [ int ( biposition / 2 ) ] [ 1 ] ) : <NEWLINE> <INDENT> trans = dataset [ biposition ] <NEWLINE> dataset [ biposition ] = dataset [ int ( biposition / 2 ) ] <NEWLINE> dataset [ int ( biposition / 2 ) ] = trans <NEWLINE> biposition = int ( biposition / 2 ) <NEWLINE> <NL> <DEDENT> elif ( biposition * 2 < len ( dataset ) and biposition * 2 + 1 < len ( dataset ) and ( newdata > dataset [ biposition * 2 ] [ 1 ] or newdata > dataset [ biposition * 2 + 1 ] [ 1 ] ) ) : <NEWLINE> <INDENT> if ( dataset [ biposition * 2 ] [ 1 ] >= dataset [ biposition * 2 + 1 ] [ 1 ] ) : <NEWLINE> <INDENT> trans = dataset [ biposition ] <NEWLINE> dataset [ biposition ] = dataset [ biposition * 2 + 1 ] <NEWLINE> dataset [ biposition * 2 + 1 ] = trans <NEWLINE> biposition = biposition * 2 + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> trans = dataset [ biposition ] <NEWLINE> dataset [ biposition ] = dataset [ biposition * 2 ] <NEWLINE> dataset [ biposition * 2 ] = trans <NEWLINE> biposition = biposition * 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return dataset <NEWLINE> <NL> <NL> <NL> <DEDENT> def binary_heap_deletion ( dataset ) : <NEWLINE> <INDENT> newdata = dataset [ - 1 ] [ 1 ] <NEWLINE> trans = dataset [ 1 ] <NEWLINE> dataset [ 1 ] = dataset [ - 1 ] <NEWLINE> dataset [ - 1 ] = trans <NEWLINE> dataset . pop ( - 1 ) <NEWLINE> biposition = 1 <NEWLINE> for i in range ( 999999 ) : <NEWLINE> <INDENT> if ( biposition * 2 < len ( dataset ) and biposition * 2 + 1 < len ( dataset ) and ( newdata > dataset [ biposition * 2 ] [ 1 ] or newdata > dataset [ biposition * 2 + 1 ] [ 1 ] ) ) : <NEWLINE> <INDENT> if ( dataset [ biposition * 2 ] [ 1 ] >= dataset [ biposition * 2 + 1 ] [ 1 ] ) : <NEWLINE> <INDENT> trans = dataset [ biposition ] <NEWLINE> dataset [ biposition ] = dataset [ biposition * 2 + 1 ] <NEWLINE> dataset [ biposition * 2 + 1 ] = trans <NEWLINE> biposition = biposition * 2 + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> trans = dataset [ biposition ] <NEWLINE> dataset [ biposition ] = dataset [ biposition * 2 ] <NEWLINE> dataset [ biposition * 2 ] = trans <NEWLINE> biposition = biposition * 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return dataset <NEWLINE> <NL> <DEDENT> def binary_heap_add ( dataset , newdata , position ) : <NEWLINE> <INDENT> dataset . append ( [ position , newdata ] ) <NEWLINE> biposition = len ( dataset ) - 1 <NEWLINE> for i in range ( 999999 ) : <NEWLINE> <INDENT> if ( newdata < dataset [ int ( biposition / 2 ) ] [ 1 ] ) : <NEWLINE> <INDENT> trans = dataset [ biposition ] <NEWLINE> dataset [ biposition ] = dataset [ int ( biposition / 2 ) ] <NEWLINE> dataset [ int ( biposition / 2 ) ] = trans <NEWLINE> biposition = int ( biposition / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return dataset <NEWLINE> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE> <STRING> <NEWLINE>
K = int ( input ( ) ) <NEWLINE> seven_number = 0 <NEWLINE> ality = 0 <NEWLINE> for ans in range ( 1 , 10 ** 7 ) : <NEWLINE> <INDENT> if ans > K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> seven_number = ( seven_number * 10 + 7 ) % K <NEWLINE> if seven_number == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> D = { } <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> if i in D : <NEWLINE> <INDENT> D [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> s = 0 <NEWLINE> for j in D : <NEWLINE> <INDENT> s += j * D [ j ] <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> bi , ci = map ( int , input ( ) . split ( ) ) <NEWLINE> if bi in D : <NEWLINE> <INDENT> if ci in D : <NEWLINE> <INDENT> D [ ci ] += D [ bi ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D [ ci ] = D [ bi ] <NEWLINE> <DEDENT> s += ( ci - bi ) * D [ bi ] <NEWLINE> del D [ bi ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if <STRING> in N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
line = input ( ) <NEWLINE> N , M , X = [ int ( v ) for v in line . split ( <STRING> ) ] <NEWLINE> <NL> Ci , Aij = [ ] , [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> line = input ( ) . split ( <STRING> ) <NEWLINE> line = [ int ( v ) for v in line ] <NEWLINE> <NL> Ci . append ( line [ 0 ] ) <NEWLINE> Aij . append ( line [ 1 : ] ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> def dfs ( candidate ) : <NEWLINE> <INDENT> if len ( candidate ) == N : <NEWLINE> <INDENT> X_ = [ 0 for _ in range ( M ) ] <NEWLINE> cost = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if candidate [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cost += Ci [ i ] <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> X_ [ j ] += Aij [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> if min ( X_ ) >= X : <NEWLINE> <INDENT> ans . append ( cost ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for bit in range ( 2 ) : <NEWLINE> <INDENT> candidate . append ( bit ) <NEWLINE> dfs ( candidate ) <NEWLINE> candidate . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( [ ] ) <NEWLINE> if len ( ans ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> <NL> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> x = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = ( int ( j ) for j in input ( ) . split ( ) ) <NEWLINE> x [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> + str ( x [ i ] [ j ] [ k ] ) , end = <STRING> if k != 9 else <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> * 20 if i != 3 else <STRING> , end = <STRING> if i != 3 else <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> <NL> n = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> m = { } <NEWLINE> <NL> <NL> def doit ( n , k ) : <NEWLINE> <INDENT> if len ( n ) == 0 : <NEWLINE> <INDENT> return k == 0 <NEWLINE> <DEDENT> d = int ( n [ 0 ] ) <NEWLINE> if ( n , k ) not in m : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for i in range ( d + 1 ) : <NEWLINE> <INDENT> if i == d : <NEWLINE> <INDENT> ret += doit ( n [ 1 : ] , k - 1 if i > 0 else k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret += doit ( <STRING> * ( len ( n ) - 1 ) , k - 1 if i > 0 else k ) <NEWLINE> <DEDENT> <DEDENT> m [ ( n , k ) ] = ret <NEWLINE> <DEDENT> return m [ ( n , k ) ] <NEWLINE> <NL> <NL> <DEDENT> print ( doit ( n , k ) ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> r = [ 0 ] * ( h + 1 ) <NEWLINE> c = [ 0 ] * ( w + 1 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> bh , bw = map ( int , input ( ) . split ( ) ) <NEWLINE> s . append ( [ bh , bw ] ) <NEWLINE> r [ bh ] += 1 <NEWLINE> c [ bw ] += 1 <NEWLINE> <DEDENT> R = max ( r ) <NEWLINE> nr = { i for i , x in enumerate ( r ) if x == R } <NEWLINE> C = max ( c ) <NEWLINE> nc = { i for i , x in enumerate ( c ) if x == C } <NEWLINE> count = sum ( x in nr and y in nc for x , y in s ) <NEWLINE> print ( R + C - ( len ( nr ) * len ( nc ) == count ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> cnt += A [ i ] * ( a [ N ] - a [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> ans = cnt % mod <NEWLINE> print ( ans ) <NEWLINE>
S , T , operation = input ( ) , input ( ) , 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : operation += 1 <NEWLINE> <DEDENT> print ( operation ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> zero = s . count ( <STRING> ) <NEWLINE> one = s . count ( <STRING> ) <NEWLINE> print ( min ( zero , one ) * 2 ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> a_i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list . sort ( a_i , reverse = True ) <NEWLINE> if num <= 3 : <NEWLINE> <INDENT> print ( sum ( a_i [ : num - 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = sum ( a_i [ : 2 ] ) <NEWLINE> for x in range ( 3 , num ) : <NEWLINE> <INDENT> if x == 3 : ans += a_i [ 1 ] <NEWLINE> else : ans += a_i [ x // 2 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = list ( map ( int , input ( ) ) ) <NEWLINE> if sum ( n ) / 9 == sum ( n ) // 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
nn = int ( input ( ) ) <NEWLINE> nc = [ 0 ] * ( nn + 1 ) <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> a = x * x + y * y + z * z + x * y + x * z + y * z <NEWLINE> if a > nn : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> nc [ a ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , nn + 1 ) : <NEWLINE> <INDENT> print ( nc [ i ] ) <NEWLINE> <DEDENT>
x , y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def quick_sort ( arr ) : <NEWLINE> <INDENT> left = [ ] <NEWLINE> right = [ ] <NEWLINE> if len ( arr ) <= 1 : <NEWLINE> <INDENT> return arr <NEWLINE> <DEDENT> if ( 1 <= x , y <= 1000 and 1 <= max ( arr ) <= 1000 and 1 <= min ( arr ) <= 1000 ) : <NEWLINE> <INDENT> ref = arr [ 0 ] <NEWLINE> ref_count = 0 <NEWLINE> <NL> for ele in arr : <NEWLINE> <INDENT> if ele < ref : <NEWLINE> <INDENT> left . append ( ele ) <NEWLINE> <DEDENT> elif ele > ref : <NEWLINE> <INDENT> right . append ( ele ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ref_count += 1 <NEWLINE> <DEDENT> <DEDENT> left = quick_sort ( left ) <NEWLINE> right = quick_sort ( right ) <NEWLINE> return left + [ ref ] * ref_count + right <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> sorted_list = quick_sort ( arr ) <NEWLINE> <NL> result = 0 <NEWLINE> <NL> for i in range ( 0 , y ) : <NEWLINE> <INDENT> result += sorted_list [ i ] <NEWLINE> <NL> <NL> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> data = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> data . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> memo = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> memo . append ( [ - 1 ] * n ) <NEWLINE> <NL> <NL> <DEDENT> def mul ( i , j ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if memo [ i ] [ j ] >= 0 : <NEWLINE> <INDENT> return memo [ i ] [ j ] <NEWLINE> <DEDENT> num = 100000 <NEWLINE> for k in range ( i , j ) : <NEWLINE> <INDENT> num = min ( num , mul ( i , k ) + mul ( k + 1 , j ) + data [ i ] [ 0 ] * data [ k ] [ 1 ] * data [ j ] [ 1 ] ) <NEWLINE> <DEDENT> memo [ i ] [ j ] = num <NEWLINE> return memo [ i ] [ j ] <NEWLINE> <NL> <DEDENT> print ( mul ( 0 , n - 1 ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> root = [ - 1 ] * n <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> if root [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root [ x ] = find ( root [ x ] ) <NEWLINE> return root [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> gx = find ( x ) <NEWLINE> gy = find ( y ) <NEWLINE> <NL> if gx == gy : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if root [ gx ] > root [ gy ] : <NEWLINE> <INDENT> gx , gy = gy , gx <NEWLINE> <NL> <DEDENT> root [ gx ] += root [ gy ] <NEWLINE> root [ gy ] = gx <NEWLINE> <NL> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> return - root [ x ] <NEWLINE> <NL> <DEDENT> for a , b in AB : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> unite ( a , b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> pre = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ino = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = [ ] <NEWLINE> root = pre [ 0 ] <NEWLINE> pre = iter ( pre ) . __next__ <NEWLINE> <NL> def dfs ( l , r ) : <NEWLINE> <INDENT> global d <NEWLINE> if l >= r : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> c = pre ( ) <NEWLINE> m = ino . index ( c ) <NEWLINE> dfs ( l , m ) <NEWLINE> dfs ( m + 1 , r ) <NEWLINE> d += [ c ] <NEWLINE> <NL> <DEDENT> dfs ( 0 , len ( ino ) ) <NEWLINE> print ( * d ) <NEWLINE> <NL>
import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> stdin = sys . stdin <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> MIN = - 10 ** 9 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> IINF = 10 ** 18 <NEWLINE> <NL> def solve ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N , M , K = map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> a = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> b = [ 0 ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A_list = [ A for A in input ( ) . split ( ) ] <NEWLINE> A_list = list ( map ( int , A_list ) ) <NEWLINE> <NL> A_list . sort ( ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> for i in range ( 0 , K ) : <NEWLINE> <INDENT> ans = ans + A_list [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
r = float ( input ( ) ) <NEWLINE> pi = 3.141592653589793 <NEWLINE> A = float ( pow ( r , 2 ) * pi ) <NEWLINE> S = float ( 2 * pi * r ) <NEWLINE> print ( <STRING> . format ( A ) + <STRING> + <STRING> . format ( S ) ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> <NL> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> <NL> num , d = 0 , 1 <NEWLINE> <NL> for char in s : <NEWLINE> <INDENT> num += int ( char ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> counts [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in counts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> flag = True <NEWLINE> for i in range ( M - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= L and b <= R : <NEWLINE> <INDENT> L = a <NEWLINE> R = b <NEWLINE> <DEDENT> elif L <= b and R >= b : <NEWLINE> <INDENT> R = b <NEWLINE> <DEDENT> elif L <= a and R >= a : <NEWLINE> <INDENT> L = a <NEWLINE> <DEDENT> elif a < L and R < b : <NEWLINE> <INDENT> L = L <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( R - L + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> saidan = input ( ) <NEWLINE> <NL> isiall = min ( saidan . count ( <STRING> ) , saidan . count ( <STRING> ) ) <NEWLINE> <NL> tesuu = 0 <NEWLINE> for i in range ( len ( saidan ) // 2 ) : <NEWLINE> <INDENT> r_iti = saidan . rfind ( <STRING> ) <NEWLINE> w_iti = saidan . find ( <STRING> ) <NEWLINE> <NL> if r_iti == - 1 or w_iti == - 1 or r_iti < w_iti : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> saidan = saidan [ w_iti + 1 : r_iti ] <NEWLINE> tesuu += 1 <NEWLINE> <NL> <DEDENT> print ( min ( tesuu , isiall ) ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> <NL> a = math . pi * r ** 2 <NEWLINE> b = math . pi * r * 2 <NEWLINE> <NL> print ( str ( a ) + <STRING> + str ( b ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ls = list ( s ) <NEWLINE> all = ls . count ( <STRING> ) * ls . count ( <STRING> ) * ls . count ( <STRING> ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if 2 * j - i < n : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ i ] != s [ 2 * j - i ] and s [ j ] != s [ 2 * j - i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( all - cnt ) <NEWLINE>
t = input ( ) <NEWLINE> p = input ( ) <NEWLINE> l_t = len ( t ) <NEWLINE> l_p = len ( p ) <NEWLINE> for i in range ( l_t - l_p + 1 ) : <NEWLINE> <INDENT> if t [ i : i + l_p ] == p : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
import heapq <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ - int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> heapq . heapify ( A ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> pop = heapq . heappop ( A ) <NEWLINE> if pop % 2 == 0 : <NEWLINE> <INDENT> num = pop // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = ( pop + 1 ) // 2 <NEWLINE> <DEDENT> heapq . heappush ( A , num ) <NEWLINE> <NL> <DEDENT> print ( - sum ( A ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> b = 0 <NEWLINE> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> x = 0.5 * i * ( i - 1 ) <NEWLINE> b += i * n - 2 * x + 1 <NEWLINE> <DEDENT> print ( int ( b % ( 10 ** 9 + 7 ) ) ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> S = set ( [ ] ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> S . add ( s ) <NEWLINE> <DEDENT> print ( len ( S ) ) <NEWLINE>
import bisect <NEWLINE> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> graph = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ x ] . append ( y ) <NEWLINE> graph [ y ] . append ( x ) <NEWLINE> <NL> <DEDENT> ans = [ - 1 ] * ( N + 1 ) <NEWLINE> inf = 10 ** 18 <NEWLINE> LIS = [ inf ] * ( N + 1 ) <NEWLINE> <NL> def DFS ( s , parent = 0 ) : <NEWLINE> <INDENT> a = A [ s - 1 ] <NEWLINE> i = bisect . bisect_left ( LIS , a ) <NEWLINE> v = LIS [ i ] <NEWLINE> LIS [ i ] = a <NEWLINE> ans [ s ] = bisect . bisect_left ( LIS , inf ) <NEWLINE> for t in graph [ s ] : <NEWLINE> <INDENT> if t == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> DFS ( t , s ) <NEWLINE> <DEDENT> LIS [ i ] = v <NEWLINE> return <NEWLINE> <NL> <DEDENT> DFS ( 1 ) <NEWLINE> print ( * ans [ 1 : ] , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> As = list ( sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> <NL> max_num = max ( As ) <NEWLINE> tfs = [ 0 for _ in range ( max_num + 1 ) ] <NEWLINE> <NL> for A in As : <NEWLINE> <INDENT> if tfs [ A ] != 0 : <NEWLINE> <INDENT> tfs [ A ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> for j in range ( A , max_num + 1 , A ) : <NEWLINE> <INDENT> tfs [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> result = 0 <NEWLINE> for A in As : <NEWLINE> <INDENT> if tfs [ A ] == 1 : <NEWLINE> <INDENT> result += 1 <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit , b1 , i4 , i8 , f8 <NEWLINE> <NL> @ njit ( ( i8 , i8 , i8 , i8 [ : , : ] ) , cache = True ) <NEWLINE> def solve ( R , C , K , item ) : <NEWLINE> <INDENT> dp = np . zeros ( ( C + 1 , 5 ) , dtype = np . int64 ) <NEWLINE> for i in range ( 1 , R + 1 ) : <NEWLINE> <INDENT> new_dp = np . zeros ( ( C + 1 , 4 ) , dtype = np . int64 ) <NEWLINE> <COMMENT> <NL> for k in range ( 4 ) : <NEWLINE> <INDENT> new_dp [ : , 0 ] = np . maximum ( new_dp [ : , 0 ] , dp [ : , k ] ) <NEWLINE> <DEDENT> dp = new_dp <NEWLINE> for j in range ( 1 , C + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> new_dp [ j ] = np . maximum ( new_dp [ j ] , new_dp [ j - 1 ] ) <NEWLINE> <COMMENT> <NL> for k in range ( 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> dp [ j , k + 1 ] = np . maximum ( dp [ j , k + 1 ] , dp [ j , k ] + item [ i - 1 ] [ j - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = dp [ - 1 ] . max ( ) <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> R , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> item = np . zeros ( ( R , C ) , dtype = np . int64 ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> r , c , v = map ( int , input ( ) . split ( ) ) <NEWLINE> item [ r - 1 , c - 1 ] = v <NEWLINE> <DEDENT> print ( solve ( R , C , K , item ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> dp = [ 0 ] * 10 ** 7 <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = i + 1 - A [ i ] <NEWLINE> if x >= 0 : <NEWLINE> <INDENT> ans += dp [ x ] <NEWLINE> <DEDENT> y = i + 1 + A [ i ] <NEWLINE> if y < 10 ** 7 : <NEWLINE> <INDENT> dp [ y ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from operator import itemgetter <NEWLINE> from itertools import combinations , takewhile <NEWLINE> from math import sqrt <NEWLINE> <NL> def solve ( a : list , sorted_axis : int = - 1 ) : <NEWLINE> <INDENT> length = len ( a ) <NEWLINE> if length <= 3 : <NEWLINE> <INDENT> return min ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 for ( x1 , y1 ) , ( x2 , y2 ) in combinations ( a , 2 ) ) <NEWLINE> <NL> <DEDENT> x_set_len = len ( set ( x for x , _ in a ) ) <NEWLINE> axis1 = 0 if x_set_len > length / 2 else 1 <NEWLINE> <NL> if sorted_axis != axis1 : <NEWLINE> <INDENT> a . sort ( key = itemgetter ( axis1 ) ) <NEWLINE> <NL> <DEDENT> mid_index = length // 2 <NEWLINE> left , right = a [ : mid_index ] , a [ mid_index : ] <NEWLINE> delta = min ( solve ( left , axis1 ) , solve ( right , axis1 ) ) <NEWLINE> <NL> axis2 = not axis1 <NEWLINE> median = a [ mid_index ] [ axis1 ] <NEWLINE> mid_a = sorted ( [ p for _iter in ( <NEWLINE> <INDENT> ( takewhile ( lambda p : median - sqrt ( delta ) < p [ axis1 ] , left [ : : - 1 ] ) ) , <NEWLINE> ( takewhile ( lambda p : p [ axis1 ] < median + sqrt ( delta ) , right ) ) <NEWLINE> <DEDENT> ) for p in _iter ] , key = itemgetter ( axis2 ) ) <NEWLINE> <NL> for i , ( x1 , y1 ) in enumerate ( mid_a ) : <NEWLINE> <INDENT> ub = ( x1 if axis1 else y1 ) + sqrt ( delta ) <NEWLINE> for x2 , y2 in takewhile ( lambda p : p [ axis2 ] < ub , mid_a [ i + 1 : ] ) : <NEWLINE> <INDENT> delta = min ( delta , ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> return delta <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> a = [ tuple ( map ( int , l . split ( ) ) ) for l in sys . stdin . readlines ( ) ] <NEWLINE> print ( solve ( a ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 2000000 ) <NEWLINE> def f ( i , ans , l , t ) : <NEWLINE> <INDENT> if ( i + 1 ) == ( len ( l ) - 1 ) : <NEWLINE> <INDENT> if ( ans + l [ i ] ) > l [ i + 1 ] : <NEWLINE> <INDENT> ans = ans + l [ i ] - l [ i + 1 ] <NEWLINE> return t + ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return t <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( ans + l [ i ] ) > l [ i + 1 ] : <NEWLINE> <INDENT> ans = ans + l [ i ] - l [ i + 1 ] <NEWLINE> return f ( i + 1 , ans , l , t + ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return f ( i + 1 , 0 , l , t ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> n = input ( <STRING> ) <NEWLINE> an = input ( <STRING> ) . split ( <STRING> ) <NEWLINE> ani = [ int ( a ) for a in an ] <NEWLINE> if len ( ani ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( f ( 0 , 0 , ani , 0 ) ) ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <COMMENT> <NL> out = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> RGBs = list ( itertools . permutations ( [ <STRING> , <STRING> , <STRING> ] , 3 ) ) <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( N - i * 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ( S [ j ] , S [ j + i ] , S [ j + i * 2 ] ) in RGBs : <NEWLINE> <INDENT> out -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( out ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from collections import deque , Counter <NEWLINE> from heapq import heappop , heappush <NEWLINE> from bisect import bisect_right <NEWLINE> from itertools import accumulate <NEWLINE> import math <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> INF = 10 ** 12 <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if K == 0 : <NEWLINE> <INDENT> print ( max ( A ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> MIN = 0 <NEWLINE> MAX = max ( A ) <NEWLINE> <NL> while MAX - MIN > 1 : <NEWLINE> <INDENT> MID = ( MIN + MAX ) // 2 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> cnt += ( A [ i ] - 1 ) // MID <NEWLINE> <DEDENT> if cnt <= K : <NEWLINE> <INDENT> MAX = MID <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> MIN = MID <NEWLINE> <DEDENT> <DEDENT> print ( MAX ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> a = 10 ** n - 9 ** n - 9 ** n + 8 ** n <NEWLINE> print ( a % mod ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> absX = abs ( X ) <NEWLINE> k = absX // D <NEWLINE> if k < K : <NEWLINE> <INDENT> abs_pos = absX - k * D <NEWLINE> K -= k <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> print ( int ( abs_pos ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( abs ( abs_pos - D ) ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( abs ( absX - D * K ) ) ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> k = min ( k , b - a + 1 ) <NEWLINE> * al , = range ( a , a + k ) <NEWLINE> * al2 , = range ( b - k + 1 , b + 1 ) <NEWLINE> ans = al + al2 <NEWLINE> ans = list ( set ( ans ) ) <NEWLINE> ans . sort ( ) <NEWLINE> for i in ans : print ( i ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> <DEDENT> k = ( n + 1 ) // 2 <NEWLINE> j = 1 <NEWLINE> <NL> while j < k and m > 0 : <NEWLINE> <INDENT> print ( j , k ) <NEWLINE> j += 1 <NEWLINE> k -= 1 <NEWLINE> m -= 1 <NEWLINE> <NL> <DEDENT> j = ( n + 1 ) // 2 + 1 <NEWLINE> k = n <NEWLINE> <NL> while j < k and m > 0 : <NEWLINE> <INDENT> if k <= n : <NEWLINE> <INDENT> print ( j , k ) <NEWLINE> m -= 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> k -= 1 <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> N = str ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> while len ( N ) > 1 and c < 15 : <NEWLINE> <INDENT> M = 0 <NEWLINE> for j in range ( 1 , len ( N ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> l = int ( N [ : j ] ) <NEWLINE> r = int ( N [ j : ] ) <NEWLINE> l *= r <NEWLINE> if M < l : <NEWLINE> <INDENT> M = l <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> N = str ( M ) <NEWLINE> c += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if c >= 15 : <NEWLINE> <INDENT> d = [ int ( N ) ] <NEWLINE> while len ( N ) > 1 and c >= 0 and c < 50 : <NEWLINE> <INDENT> M = 0 <NEWLINE> <COMMENT> <NL> for j in range ( 1 , len ( N ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> l = int ( N [ : j ] ) <NEWLINE> r = int ( N [ j : ] ) <NEWLINE> l *= r <NEWLINE> if M < l : <NEWLINE> <INDENT> M = l <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> k = 0 <NEWLINE> while k < len ( d ) and M > d [ k ] : <NEWLINE> <INDENT> k += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if k >= len ( d ) : <NEWLINE> <INDENT> k = - 1 <NEWLINE> <DEDENT> elif M == d [ k ] : <NEWLINE> <INDENT> c = - 1 <NEWLINE> <DEDENT> d . insert ( k , M ) <NEWLINE> N = str ( M ) <NEWLINE> c += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
n , m , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> xl = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> yl = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xl . append ( x ) <NEWLINE> yl . append ( y ) <NEWLINE> xl . sort ( ) <NEWLINE> yl . sort ( ) <NEWLINE> <NL> if xl [ - 1 ] < yl [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> sum = 0 <NEWLINE> K = int ( input ( ) ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> t = gcd ( k , j ) <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += gcd ( t , i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> R , L = 0 , s . count ( <STRING> ) <NEWLINE> times = max ( R , L ) <NEWLINE> for c in s : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> R += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L -= 1 <NEWLINE> <DEDENT> if times > max ( R , L ) : <NEWLINE> <INDENT> times = max ( R , L ) <NEWLINE> <DEDENT> <DEDENT> print ( times ) <NEWLINE>
from copy import deepcopy <NEWLINE> import itertools <NEWLINE> <NL> A , B , C , D , E , F = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> qA = [ i // 100 for i in range ( 0 , F + 1 , A * 100 ) ] <NEWLINE> qB = [ i // 100 for i in range ( 0 , F + 1 , B * 100 ) ] <NEWLINE> qC = [ i for i in range ( 0 , F + 1 , C ) ] <NEWLINE> qD = [ i for i in range ( 0 , F + 1 , D ) ] <NEWLINE> <NL> W = set ( qA + qB ) <NEWLINE> for i in range ( F // min ( A , B ) ) : <NEWLINE> <INDENT> nW = deepcopy ( W ) <NEWLINE> for w in W : <NEWLINE> <INDENT> if ( w + A ) * 100 <= F : <NEWLINE> <INDENT> nW . add ( w + A ) <NEWLINE> <DEDENT> if ( w + B ) * 100 <= F : <NEWLINE> <INDENT> nW . add ( w + B ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( W ) == len ( nW ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> W = deepcopy ( nW ) <NEWLINE> <NL> <DEDENT> W = nW <NEWLINE> <NL> S = set ( qC + qD ) <NEWLINE> for i in range ( F // min ( C , D ) ) : <NEWLINE> <INDENT> nS = deepcopy ( S ) <NEWLINE> for s in S : <NEWLINE> <INDENT> if ( s + C ) <= F : <NEWLINE> <INDENT> nS . add ( s + C ) <NEWLINE> <DEDENT> if ( s + D ) <= F : <NEWLINE> <INDENT> nS . add ( s + D ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( S ) == len ( nS ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> S = deepcopy ( nS ) <NEWLINE> <DEDENT> S = nS <NEWLINE> <NL> M = 0 <NEWLINE> Ms = 0 <NEWLINE> Mw = A <NEWLINE> for w , s in itertools . product ( W , S ) : <NEWLINE> <INDENT> if w != 0 and s <= w * E and s + 100 * w <= F : <NEWLINE> <INDENT> if M < s / ( w * 100 + s ) : <NEWLINE> <INDENT> M = s / ( w * 100 + s ) <NEWLINE> Ms = s <NEWLINE> Mw = w <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( Ms + Mw * 100 ) <NEWLINE> print ( Ms ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> p = ( a + b ) * 2 <NEWLINE> Area = a * b <NEWLINE> print ( Area , p ) <NEWLINE> <NL>
import sys <NEWLINE> sys . setrecursionlimit ( 500 * 500 ) <NEWLINE> <NL> h , w = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ [ 1 if c == <STRING> else 0 for c in input ( ) ] for _ in range ( h ) ] <NEWLINE> g = [ [ ] for _ in range ( h * w ) ] <NEWLINE> <NL> for i in range ( w ) : <NEWLINE> <INDENT> for j in range ( h ) : <NEWLINE> <INDENT> for di in [ - 1 , 0 , 1 ] : <NEWLINE> <INDENT> for dj in [ - 1 , 0 , 1 ] : <NEWLINE> <INDENT> if abs ( di ) + abs ( dj ) != 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if 0 <= i + di < w and 0 <= j + dj < h : <NEWLINE> <INDENT> if s [ j ] [ i ] != s [ j + dj ] [ i + di ] : <NEWLINE> <INDENT> g [ j * w + i ] . append ( i + di + ( j + dj ) * w ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> visit = [ 0 ] * ( h * w ) <NEWLINE> black = [ 0 ] * ( h * w ) <NEWLINE> white = [ 0 ] * ( h * w ) <NEWLINE> <NL> def rec ( j , i , rj , ri ) : <NEWLINE> <INDENT> if s [ j ] [ i ] : <NEWLINE> <INDENT> black [ rj * w + ri ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> white [ rj * w + ri ] += 1 <NEWLINE> <NL> <DEDENT> for n in g [ j * w + i ] : <NEWLINE> <INDENT> if visit [ n ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> visit [ n ] = 1 <NEWLINE> <NL> rec ( n // w , n % w , rj , ri ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( w ) : <NEWLINE> <INDENT> for j in range ( h ) : <NEWLINE> <INDENT> if visit [ w * j + i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visit [ w * j + i ] = 1 <NEWLINE> <NL> rec ( j , i , j , i ) <NEWLINE> <NL> ans += black [ w * j + i ] * white [ w * j + i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( k [ 1 ] ) ] <NEWLINE> <NL> import networkx as nx <NEWLINE> G = nx . Graph ( ) <NEWLINE> for i in range ( k [ 0 ] ) : <NEWLINE> <INDENT> G . add_node ( i + 1 ) <NEWLINE> <DEDENT> for i in m : <NEWLINE> <INDENT> G . add_edge ( i [ 0 ] , i [ 1 ] ) <NEWLINE> <DEDENT> re = 0 <NEWLINE> for i in list ( G . nodes ) : <NEWLINE> <INDENT> if len ( list ( nx . all_neighbors ( G , i ) ) ) != 0 : <NEWLINE> <INDENT> max_height = max ( [ h [ x - 1 ] for x in list ( nx . all_neighbors ( G , i ) ) ] ) <NEWLINE> if h [ i - 1 ] > max_height : <NEWLINE> <INDENT> re += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> re += 1 <NEWLINE> <DEDENT> <DEDENT> print ( re ) <NEWLINE>
S = input ( ) <NEWLINE> C , m , T = 2019 , 0 , [ 1 ] + [ 0 ] * 2018 <NEWLINE> for i , s in enumerate ( S [ : : - 1 ] ) : <NEWLINE> <INDENT> m = ( m + int ( s ) * pow ( 10 , i , C ) ) % C <NEWLINE> T [ m ] += 1 <NEWLINE> <DEDENT> print ( sum ( T [ i ] * ~ - T [ i ] // 2 for i in range ( 2019 ) ) ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> num = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( num , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> s = math . pi <NEWLINE> print ( <STRING> % ( r * r * s ) , <STRING> % ( 2 * r * s ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( 1200 ) : <NEWLINE> <INDENT> S . append ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> k = input ( ) . split ( ) <NEWLINE> b = int ( k [ 0 ] ) <NEWLINE> f = int ( k [ 1 ] ) <NEWLINE> r = int ( k [ 2 ] ) <NEWLINE> v = int ( k [ 3 ] ) <NEWLINE> S [ ( b - 1 ) * 30 + ( f - 1 ) * 10 + r - 1 ] += v <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> msg = <STRING> <NEWLINE> for t in range ( 10 ) : <NEWLINE> <INDENT> msg += <STRING> + str ( S [ i * 30 + j * 10 + t ] ) <NEWLINE> <DEDENT> print ( msg ) <NEWLINE> <DEDENT> if i < 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> s = sum ( arr ) <NEWLINE> d = { } <NEWLINE> for i in arr : <NEWLINE> <INDENT> if i in d : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> for _ in range ( k ) : <NEWLINE> <INDENT> v = 0 <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a not in d : <NEWLINE> <INDENT> print ( s ) <NEWLINE> continue <NEWLINE> <DEDENT> s += ( b - a ) * d [ a ] <NEWLINE> if b in d : <NEWLINE> <INDENT> d [ b ] += d [ a ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ b ] = d [ a ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE> del d [ a ] <NEWLINE> <DEDENT>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> HB = [ 0 ] * H <NEWLINE> WB = [ 0 ] * W <NEWLINE> <NL> place = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> place . append ( ( h , w , ) ) <NEWLINE> <NL> HB [ h - 1 ] += 1 <NEWLINE> WB [ w - 1 ] += 1 <NEWLINE> <DEDENT> m_hb = max ( HB ) <NEWLINE> m_wb = max ( WB ) <NEWLINE> result = m_hb + m_wb <NEWLINE> <NL> count = 0 <NEWLINE> for x , y in place : <NEWLINE> <INDENT> if HB [ x - 1 ] == m_hb and WB [ y - 1 ] == m_wb : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if HB . count ( m_hb ) * WB . count ( m_wb ) <= count : <NEWLINE> <INDENT> result -= 1 <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
import bisect <NEWLINE> <NL> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p . sort ( ) <NEWLINE> <NL> index = bisect . bisect_left ( p , x ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = p + [ p [ n - 1 ] + 2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if p [ max ( index - i , 0 ) ] != x - i : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> break <NEWLINE> <DEDENT> elif p [ min ( index + i , n ) ] != x + i : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( p [ 0 ] - 1 ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if ( a [ i ] < a [ k + i ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = { } <NEWLINE> ans = <STRING> <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> d [ a [ i ] ] = i + 1 <NEWLINE> <NL> <DEDENT> d_sorted = sorted ( d . items ( ) , key = lambda x : x [ 0 ] ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if ans != <STRING> : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> ans = ans + str ( d_sorted [ i ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for r in range ( 0 , N + 1 , R ) : <NEWLINE> <INDENT> for g in range ( 0 , N + 1 , G ) : <NEWLINE> <INDENT> if r + g > N : break <NEWLINE> if ( N - r - g ) % B == 0 : cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if b == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b - 1 > n : <NEWLINE> <INDENT> x = n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = ( b - 1 ) * ( n // ( b - 1 ) ) <NEWLINE> <NL> <DEDENT> ans = max ( a * x // b - a * ( x // b ) , a * n // b - a * ( n // b ) ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> x_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x_lst . sort ( ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> minimum = abs ( x_lst [ 0 ] - x ) <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> minimum = abs ( x_lst [ 1 ] - x_lst [ 0 ] ) <NEWLINE> lst = [ abs ( x_lst [ 1 ] - x ) , abs ( x_lst [ 0 ] - x ) ] <NEWLINE> lst . sort ( ) <NEWLINE> lst . reverse ( ) <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> if minimum % lst [ i ] == 0 : <NEWLINE> <INDENT> minimum = lst [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> lst1 = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i != n - 1 : <NEWLINE> <INDENT> lst1 . append ( abs ( x_lst [ i + 1 ] - x_lst [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> minimum = math . gcd ( lst1 [ 0 ] , lst1 [ 1 ] ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if i != n - 2 : <NEWLINE> <INDENT> minimum = min ( minimum , math . gcd ( lst1 [ i ] , lst1 [ i + 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> lst2 = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lst2 . append ( abs ( x_lst [ i ] - x ) ) <NEWLINE> <NL> <DEDENT> lst2 . sort ( ) <NEWLINE> lst2 . reverse ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if minimum % lst2 [ i ] == 0 : <NEWLINE> <INDENT> minimum = lst2 [ i ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( minimum ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> sm = 1 <NEWLINE> color = [ 0 , 0 , 0 ] <NEWLINE> for x in lst : <NEWLINE> <INDENT> if x not in color : sm = 0 ; break <NEWLINE> sm *= color . count ( x ) <NEWLINE> sm %= mod <NEWLINE> color [ color . index ( x ) ] += 1 <NEWLINE> <DEDENT> print ( sm ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> if k >= a : <NEWLINE> <INDENT> sum += a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += k <NEWLINE> print ( sum ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> k -= a + b <NEWLINE> if k <= 0 : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if k >= c : <NEWLINE> <INDENT> sum -= c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum -= k <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> al = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> al [ i ] = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> n = 1 <NEWLINE> cnt = 1 <NEWLINE> visited = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> visited [ 1 ] = 1 <NEWLINE> while al [ n ] != 2 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> n = al [ n ] <NEWLINE> if visited [ n ] == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited [ n ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lis = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> lis [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in lis : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = np . zeros ( ( H , W ) ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> Si = np . array ( [ int ( s == <STRING> ) for s in input ( ) ] ) <NEWLINE> S [ i ] = Si <NEWLINE> <NL> <DEDENT> top = S . copy ( ) <NEWLINE> bottom = S . copy ( ) <NEWLINE> left = S . copy ( ) <NEWLINE> right = S . copy ( ) <NEWLINE> <NL> for i in range ( 1 , H ) : <NEWLINE> <INDENT> top [ i ] = ( top [ i - 1 ] + 1 ) * S [ i ] <NEWLINE> bottom [ - i - 1 ] = ( bottom [ - i ] + 1 ) * S [ - i - 1 ] <NEWLINE> <NL> <DEDENT> for j in range ( 1 , W ) : <NEWLINE> <INDENT> left [ : , j ] = ( left [ : , j - 1 ] + 1 ) * S [ : , j ] <NEWLINE> right [ : , - j - 1 ] = ( right [ : , - j ] + 1 ) * S [ : , - j - 1 ] <NEWLINE> <NL> <DEDENT> print ( np . max ( ( top + bottom + left + right - 3 ) . astype ( np . int ) ) ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = 1 <NEWLINE> frag = 0 <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( 0 in a ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> s *= a [ i ] <NEWLINE> if ( s > 10 ** 18 ) : <NEWLINE> <INDENT> frag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( frag ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . append ( l ) <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> rikai = [ 0 for _ in range ( M ) ] <NEWLINE> cost = 0 <NEWLINE> for b in range ( N ) : <NEWLINE> <INDENT> if i & ( 1 << b ) : <NEWLINE> <INDENT> for x in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> rikai [ x - 1 ] += L [ b ] [ x ] <NEWLINE> <DEDENT> cost += L [ b ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT> for x in rikai : <NEWLINE> <INDENT> if x < X : break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( cost ) <NEWLINE> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> total = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> total += int ( n [ i ] ) <NEWLINE> <DEDENT> if total % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> apple = [ L + i for i in range ( N ) ] <NEWLINE> min = 500 <NEWLINE> for k in range ( len ( apple ) ) : <NEWLINE> <INDENT> if abs ( apple [ k ] ) < abs ( min ) : <NEWLINE> <INDENT> min = apple [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> apple . remove ( min ) <NEWLINE> print ( sum ( apple ) ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> ans = set ( ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> ans . add ( S ) <NEWLINE> <DEDENT> print ( len ( ans ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( int ( 1e6 ) ) <NEWLINE> <NL> def search ( x , num ) : <NEWLINE> <INDENT> nodes . remove ( x ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for y in edge [ x ] : <NEWLINE> <INDENT> if y in nodes : <NEWLINE> <INDENT> num = search ( y , num ) <NEWLINE> <DEDENT> <DEDENT> return num + 1 <NEWLINE> <NL> <DEDENT> ( n , m ) , * d = [ list ( map ( int , s . split ( ) ) ) for s in open ( 0 ) ] <NEWLINE> <NL> edge = [ set ( ) for _ in range ( n + 1 ) ] <NEWLINE> for x in d : <NEWLINE> <INDENT> edge [ x [ 0 ] ] . add ( x [ 1 ] ) <NEWLINE> edge [ x [ 1 ] ] . add ( x [ 0 ] ) <NEWLINE> <NL> <DEDENT> nodes = set ( range ( 1 , n + 1 ) ) <NEWLINE> ans = 1 <NEWLINE> for x in list ( nodes ) : <NEWLINE> <INDENT> if x in nodes : <NEWLINE> <INDENT> ans = max ( ans , search ( x , 0 ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> indexA = { } <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a not in indexA : <NEWLINE> <INDENT> indexA [ a ] = 0 <NEWLINE> <DEDENT> indexA [ a ] += 1 <NEWLINE> <NL> <DEDENT> sumA = sum ( A ) <NEWLINE> <NL> for ( b , c ) in BC : <NEWLINE> <INDENT> if b in indexA : <NEWLINE> <INDENT> sumA += ( c - b ) * indexA [ b ] <NEWLINE> if c not in indexA : <NEWLINE> <INDENT> indexA [ c ] = 0 <NEWLINE> <DEDENT> indexA [ c ] += indexA [ b ] <NEWLINE> indexA [ b ] = 0 <NEWLINE> <DEDENT> print ( sumA ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> <NL> r = set ( ) <NEWLINE> g = set ( ) <NEWLINE> b = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . add ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g . add ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . add ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> score = len ( r ) * len ( g ) * len ( b ) <NEWLINE> for i in r : <NEWLINE> <INDENT> for j in g : <NEWLINE> <INDENT> dist = abs ( j - i ) <NEWLINE> if ( i > j ) : <NEWLINE> <INDENT> bi = i + dist <NEWLINE> if bi in b : <NEWLINE> <INDENT> score -= 1 <NEWLINE> <DEDENT> bi = j - dist <NEWLINE> if bi in b : <NEWLINE> <INDENT> score -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> bi = j + dist <NEWLINE> if bi in b : <NEWLINE> <INDENT> score -= 1 <NEWLINE> <DEDENT> bi = i - dist <NEWLINE> if bi in b : <NEWLINE> <INDENT> score -= 1 <NEWLINE> <DEDENT> <DEDENT> if ( ( i + j ) % 2 == 0 and ( i + j ) / 2 in b ) : <NEWLINE> <INDENT> score -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( score ) <NEWLINE>
mod = 1000000007 <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> b = sum ( a ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> b = b - a [ i ] <NEWLINE> ans += ( a [ i ] * ( b ) ) % mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maxA = max ( A ) <NEWLINE> abs_min = 10 ** 9 <NEWLINE> A . remove ( maxA ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if abs_min > abs ( maxA / 2 - a ) : <NEWLINE> <INDENT> abs_min = abs ( maxA / 2 - a ) <NEWLINE> r = a <NEWLINE> <DEDENT> <DEDENT> print ( maxA , r ) <NEWLINE>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def ii ( ) : return int ( input ( ) ) <NEWLINE> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( mi ( ) ) <NEWLINE> <NL> from collections import deque <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = ii ( ) <NEWLINE> edge = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> u , v , w = mi ( ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> edge [ u ] . append ( ( v , w ) ) <NEWLINE> edge [ v ] . append ( ( u , w ) ) <NEWLINE> <DEDENT> dist = [ 0 ] * n <NEWLINE> parent = [ - 1 ] * n <NEWLINE> que = deque ( [ 0 ] ) <NEWLINE> while que : <NEWLINE> <INDENT> v = que . pop ( ) <NEWLINE> for nv , nx in edge [ v ] : <NEWLINE> <INDENT> if parent [ v ] == nv : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> parent [ nv ] = v <NEWLINE> dist [ nv ] = dist [ v ] + nx % 2 <NEWLINE> dist [ nv ] %= 2 <NEWLINE> que . append ( nv ) <NEWLINE> <DEDENT> <DEDENT> print ( * dist , sep = <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> B = Counter ( i + a for i , a in enumerate ( A ) ) <NEWLINE> C = Counter ( j - a for j , a in enumerate ( A ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for k , v in B . items ( ) : <NEWLINE> <INDENT> cnt += C [ k ] * v <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> def count_ans ( a , b ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for c1 , c2 in zip ( a , b ) : <NEWLINE> <INDENT> if c1 == c2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> ans_ = count_ans ( s [ i : i + len ( t ) ] , t ) <NEWLINE> if ans < ans_ : <NEWLINE> <INDENT> ans = ans_ <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( t ) - ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ i - 1 for i in range ( n + 2 ) ] <NEWLINE> r = [ i + 1 for i in range ( n + 2 ) ] <NEWLINE> ind = [ 0 ] * n <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> ind [ a - 1 ] = i <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> x = ind [ i ] <NEWLINE> ans += ( i + 1 ) * ( r [ x ] - x ) * ( x - l [ x ] ) <NEWLINE> l [ r [ x ] ] , r [ l [ x ] ] , = l [ x ] , r [ x ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans <= 10 ** 18 and ans != 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( a ) <NEWLINE> result = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> result [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( * result , sep = <STRING> ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A_list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 1 <NEWLINE> is_zero = False <NEWLINE> is_over = False <NEWLINE> for i in A_list : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> is_zero = True <NEWLINE> break <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> is_over = True <NEWLINE> <NL> <DEDENT> if is_over : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= i <NEWLINE> <NL> <DEDENT> <DEDENT> if is_zero : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif is_over or ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = sum ( p [ 0 : k ] ) <NEWLINE> ans = num <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> num = num - p [ i ] + p [ i + k ] <NEWLINE> ans = max ( ans , num ) <NEWLINE> <DEDENT> print ( ( ans + k ) / 2 ) <NEWLINE>
from sys import stdin , setrecursionlimit <NEWLINE> input = stdin . readline <NEWLINE> <NL> setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> neighborlist = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> neighborlist [ a ] . append ( b ) <NEWLINE> neighborlist [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> pointlist = [ 0 ] * ( N + 1 ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> pointlist [ p ] += x <NEWLINE> <NL> <DEDENT> def DFS ( v ) : <NEWLINE> <INDENT> if not checkedlist [ v ] : <NEWLINE> <INDENT> checkedlist [ v ] = True <NEWLINE> <NL> global point <NEWLINE> point += pointlist [ v ] <NEWLINE> for neighbor in neighborlist [ v ] : <NEWLINE> <INDENT> DFS ( neighbor ) <NEWLINE> <NL> <DEDENT> totallist [ v ] = point <NEWLINE> point -= pointlist [ v ] <NEWLINE> <NL> <DEDENT> <DEDENT> totallist = [ 0 ] * ( N + 1 ) <NEWLINE> checkedlist = [ False ] * ( N + 1 ) <NEWLINE> point = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if not checkedlist [ i ] : <NEWLINE> <INDENT> DFS ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * totallist [ 1 : ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ) <NEWLINE> A = [ ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> a , b = S [ i ] <NEWLINE> c , d = S [ j ] <NEWLINE> for k in range ( len ( A ) ) : <NEWLINE> <INDENT> e , f , g = A [ k ] <NEWLINE> if e == a - c and f == b - d : <NEWLINE> <INDENT> A [ k ] = ( e , f , g + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> A . append ( ( a - c , b - d , 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( N - max ( list ( x [ 2 ] for x in A ) ) ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l_dis = [ num - x for num in l ] <NEWLINE> <NL> def s_func ( x ) : <NEWLINE> <INDENT> if x < 0 : <NEWLINE> <INDENT> return abs ( x ) - 0.5 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return abs ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> l_dis = sorted ( l_dis , key = s_func ) <NEWLINE> if len ( l_dis ) == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> elif l_dis [ 0 ] != 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 1 <NEWLINE> j = 1 <NEWLINE> b = - 1 <NEWLINE> while True : <NEWLINE> <INDENT> if i > len ( l_dis ) - 1 or l_dis [ i ] != j * b : <NEWLINE> <INDENT> print ( x + j * b ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> b *= - 1 <NEWLINE> if i > len ( l_dis ) - 1 or l_dis [ i ] != j * b : <NEWLINE> <INDENT> print ( x + j * b ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> b *= - 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> import itertools <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = 10 ** 20 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> ni = lambda : int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> ns = lambda : map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> na = lambda : list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> na1 = lambda : list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> k = ni ( ) <NEWLINE> l = 50 <NEWLINE> ans = [ l - 1 for _ in range ( l ) ] <NEWLINE> <NL> for i in range ( l ) : <NEWLINE> <INDENT> ans [ i ] += k // l <NEWLINE> <NL> <DEDENT> for i in range ( l ) : <NEWLINE> <INDENT> tgt = k % l <NEWLINE> if i < tgt : <NEWLINE> <INDENT> ans [ i ] += l <NEWLINE> ans [ i ] -= tgt - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] -= tgt <NEWLINE> <NL> <DEDENT> <DEDENT> print ( l ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> tree = { n : { <STRING> : - 1 , <STRING> : - 1 , <STRING> : - 1 } for n in range ( N ) } <COMMENT> <NEWLINE> parent = set ( [ n for n in range ( N ) ] ) <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> inp = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> tree [ inp [ 0 ] ] [ <STRING> ] = inp [ 2 : ] <NEWLINE> <NL> tree [ inp [ 0 ] ] [ <STRING> ] = inp [ 2 ] if len ( inp ) > 2 else - 1 <NEWLINE> <NL> for ip in inp [ 2 : ] : <NEWLINE> <INDENT> tree [ ip ] [ <STRING> ] = inp [ 0 ] <NEWLINE> <NL> <DEDENT> for i , ip in enumerate ( inp [ 2 : - 1 ] ) : <NEWLINE> <INDENT> tree [ inp [ 2 + i ] ] [ <STRING> ] = inp [ 3 + i ] <NEWLINE> <DEDENT> parent = parent . difference ( inp [ 2 : ] ) <NEWLINE> <NL> <DEDENT> def set_depth ( n , depth ) : <NEWLINE> <INDENT> print ( depth ) <NEWLINE> tree [ n ] [ <STRING> ] = depth <NEWLINE> if tree [ n ] [ <STRING> ] != - 1 : <NEWLINE> <INDENT> set_depth ( tree [ n ] [ <STRING> ] , depth + 1 ) <NEWLINE> <DEDENT> if tree [ n ] [ <STRING> ] != - 1 : <NEWLINE> <INDENT> set_depth ( tree [ n ] [ <STRING> ] , depth ) <NEWLINE> <NL> <DEDENT> <DEDENT> def get_depth ( n ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> while tree [ n ] [ <STRING> ] != - 1 : <NEWLINE> <INDENT> d += 1 <NEWLINE> n = tree [ n ] [ <STRING> ] <NEWLINE> <DEDENT> return d <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> tree [ n ] [ <STRING> ] = get_depth ( n ) <NEWLINE> if tree [ n ] [ <STRING> ] == - 1 : <NEWLINE> <INDENT> tree [ n ] [ <STRING> ] = <STRING> <NEWLINE> <DEDENT> elif tree [ n ] [ <STRING> ] != [ ] : <NEWLINE> <INDENT> tree [ n ] [ <STRING> ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree [ n ] [ <STRING> ] = <STRING> <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( n , tree [ n ] [ <STRING> ] , tree [ n ] [ <STRING> ] , tree [ n ] [ <STRING> ] , tree [ n ] [ <STRING> ] ) ) <NEWLINE> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) + [ 10 ** 7 ] <NEWLINE> a . sort ( ) <NEWLINE> l = [ True ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> ans = 0 <NEWLINE> a . sort ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if l [ a [ i ] ] : <NEWLINE> <INDENT> for j in range ( a [ i ] , 10 ** 6 + 1 , a [ i ] ) : <NEWLINE> <INDENT> l [ j ] = False <NEWLINE> <DEDENT> if a [ i ] != a [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def combinations_with_replacement ( elements , N ) : <NEWLINE> <INDENT> for i , element in enumerate ( elements ) : <NEWLINE> <INDENT> if N == 1 : <NEWLINE> <INDENT> yield [ element ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for combination in combinations_with_replacement ( elements [ : i + 1 ] , N - 1 ) : <NEWLINE> <INDENT> combination . append ( element ) <NEWLINE> yield combination <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ None for _ in range ( Q ) ] <NEWLINE> b = [ None for _ in range ( Q ) ] <NEWLINE> c = [ None for _ in range ( Q ) ] <NEWLINE> d = [ None for _ in range ( Q ) ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> elements = list ( range ( 1 , M + 1 ) ) <NEWLINE> for combination in combinations_with_replacement ( elements , N ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> if combination [ b [ i ] - 1 ] - combination [ a [ i ] - 1 ] == c [ i ] : <NEWLINE> <INDENT> score += d [ i ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( score , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> import os <NEWLINE> import itertools <NEWLINE> import string <NEWLINE> import heapq <NEWLINE> import _collections <NEWLINE> from collections import Counter <NEWLINE> from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from functools import lru_cache <NEWLINE> import bisect <NEWLINE> import re <NEWLINE> import queue <NEWLINE> import copy <NEWLINE> import decimal <NEWLINE> <NL> <NL> class Scanner ( ) : <NEWLINE> <INDENT> @ staticmethod <NEWLINE> def int ( ) : <NEWLINE> <INDENT> return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def string ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def map_int ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in Scanner . string ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def string_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . string ( ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def int_list_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . map_int ( ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def int_cols_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . int ( ) for i in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solve ( K ) : <NEWLINE> <INDENT> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> X = 7 <NEWLINE> cnt = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if X % K == 0 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> return <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> X = X * 10 + 7 <NEWLINE> X %= K <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> K = Scanner . int ( ) <NEWLINE> solve ( K ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
num = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( min ( ls ) , end = <STRING> ) <NEWLINE> print ( max ( ls ) , end = <STRING> ) <NEWLINE> print ( sum ( ls ) ) <NEWLINE>
<STRING> <NEWLINE> ALPHABET = <STRING> <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> ll = 0 <NEWLINE> for l in range ( 1 , 12 ) : <NEWLINE> <INDENT> ll += 26 ** l <NEWLINE> if ll >= n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for li in range ( 1 , l + 1 ) : <NEWLINE> <INDENT> r = n % 26 <NEWLINE> q = n // 26 <NEWLINE> if r == 0 : <NEWLINE> <INDENT> q -= 1 <NEWLINE> <DEDENT> ans . append ( r ) <NEWLINE> n = q <NEWLINE> <NL> <DEDENT> answer = <STRING> <NEWLINE> for s in ans [ : : - 1 ] : <NEWLINE> <INDENT> answer += ALPHABET [ s - 1 ] <NEWLINE> <DEDENT> print ( answer ) <NEWLINE> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif a <= k <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> cnt = 1 <NEWLINE> while True : <NEWLINE> <INDENT> tmp = cnt * k <NEWLINE> if a <= tmp <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif b <= tmp : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> sys . setrecursionlimit ( 20000000 ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> C = Counter ( S ) <NEWLINE> r = C . get ( <STRING> , 0 ) <NEWLINE> g = C . get ( <STRING> , 0 ) <NEWLINE> b = C . get ( <STRING> , 0 ) <NEWLINE> answer = r * g * b <NEWLINE> for left in range ( N ) : <NEWLINE> <INDENT> for mid in range ( left + 1 , N ) : <NEWLINE> <INDENT> right = mid * 2 - left <NEWLINE> if right < N : <NEWLINE> <INDENT> if S [ right ] != S [ mid ] and S [ mid ] != S [ left ] and S [ right ] != S [ left ] : <NEWLINE> <INDENT> answer -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> out_sum = 0 <NEWLINE> <NL> <COMMENT> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> out_sum += a <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for a in range ( 2 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , a ) : <NEWLINE> <INDENT> out_sum += 6 * math . gcd ( a , b ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for a in range ( 3 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 2 , a ) : <NEWLINE> <INDENT> for c in range ( 1 , b ) : <NEWLINE> <INDENT> out_sum += 6 * math . gcd ( a , math . gcd ( b , c ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( out_sum ) <NEWLINE>
K = list ( range ( 1 , int ( input ( ) ) + 1 ) ) <NEWLINE> <NL> import itertools <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if b > a : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> result = 0 <NEWLINE> <NL> <NL> if len ( K ) >= 3 : <NEWLINE> <INDENT> for i in list ( itertools . combinations ( K , 3 ) ) : <NEWLINE> <INDENT> result += gcd ( gcd ( i [ 0 ] , i [ 1 ] ) , i [ 2 ] ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( K ) >= 2 : <NEWLINE> <INDENT> for i in list ( itertools . combinations ( K , 2 ) ) : <NEWLINE> <INDENT> result += gcd ( i [ 0 ] , i [ 1 ] ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in list ( itertools . combinations ( K , 1 ) ) : <NEWLINE> <INDENT> result += i [ 0 ] <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
s = input ( ) [ : : - 1 ] <COMMENT> <NEWLINE> <NL> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> <NL> num , d = 0 , 1 <NEWLINE> <NL> for char in s : <NEWLINE> <INDENT> num += int ( char ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> counts [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in counts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <COMMENT> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = max ( a ) <NEWLINE> m = x / 2 <NEWLINE> a . remove ( x ) <NEWLINE> a . sort ( ) <NEWLINE> ans = x <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> y = abs ( i - m ) <NEWLINE> if ans >= y : <NEWLINE> <INDENT> ans = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> z = i <NEWLINE> <NL> <DEDENT> print ( x , z ) <NEWLINE>
import sys , os , math , bisect , itertools , collections , heapq , queue , copy , array <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> K = ii ( ) <NEWLINE> <NL> ret = [ ] <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ret . append ( 7 % K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret . append ( ( ret [ i - 1 ] * 10 + 7 ) % K ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( K + 1 ) : <NEWLINE> <INDENT> if ret [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for a in range ( 1 , N ) : <NEWLINE> <INDENT> for b in range ( a , N ) : <NEWLINE> <INDENT> if ( a * b < N ) : <NEWLINE> <INDENT> if ( a == b ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import bisect <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_sum = [ ] <NEWLINE> b_sum = [ ] <NEWLINE> a_sum . append ( 0 ) <NEWLINE> b_sum . append ( 0 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a_sum . append ( a_sum [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> b_sum . append ( b_sum [ j ] + b [ j ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for x in range ( n + 1 ) : <NEWLINE> <INDENT> timecount = k - a_sum [ x ] <NEWLINE> if timecount >= 0 : <NEWLINE> <INDENT> y = bisect . bisect_right ( b_sum , k - a_sum [ x ] ) - 1 <NEWLINE> ans = max ( x + y , ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> aa = sorted ( A ) <NEWLINE> ans = [ 0 for i in range ( aa [ - 1 ] + 1 ) ] <NEWLINE> for i in aa : <NEWLINE> <INDENT> ans [ i ] += 1 <NEWLINE> if ans [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( i * 2 , aa [ - 1 ] + 1 , i ) : <NEWLINE> <INDENT> ans [ j ] += 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans . count ( 1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ 0 ] * n <NEWLINE> boss_num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for num in boss_num : <NEWLINE> <INDENT> l [ num - 1 ] += 1 <NEWLINE> <DEDENT> for m in l : print ( m ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r_count = s . count ( <STRING> ) <NEWLINE> g_count = s . count ( <STRING> ) <NEWLINE> b_count = s . count ( <STRING> ) <NEWLINE> <NL> count = r_count * g_count * b_count <NEWLINE> <NL> <NL> for i , elem in enumerate ( s ) : <NEWLINE> <INDENT> length = min ( i , n - 1 - i ) <NEWLINE> for j in range ( 1 , length + 1 ) : <NEWLINE> <INDENT> elem_2 = s [ i - j ] <NEWLINE> elem_3 = s [ i + j ] <NEWLINE> if elem != elem_2 and elem != elem_3 and elem_2 != elem_3 : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> result = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> result *= i <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) + [ 0 ] <NEWLINE> dist = [ abs ( a [ i ] - a [ i - 1 ] ) for i in range ( 1 , n + 2 ) ] <NEWLINE> total = sum ( dist ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ i ] = total - dist [ i ] - dist [ i + 1 ] + abs ( a [ i ] - a [ i + 2 ] ) <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> MIN = A [ 0 ] <NEWLINE> MAX = A [ 1 ] - A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> MAX = max ( MAX , A [ i ] - MIN ) <NEWLINE> MIN = min ( MIN , A [ i ] ) <NEWLINE> <DEDENT> print ( MAX ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> def search ( values , hp , vp , item ) : <NEWLINE> <INDENT> if not ( 0 <= hp < len ( values ) ) : return <NEWLINE> if not ( 0 <= vp < len ( values [ hp ] ) ) : return <NEWLINE> if item != values [ hp ] [ vp ] : return <NEWLINE> values [ hp ] [ vp ] = True <NEWLINE> search ( values , hp - 1 , vp , item ) <NEWLINE> search ( values , hp + 1 , vp , item ) <NEWLINE> search ( values , hp , vp - 1 , item ) <NEWLINE> search ( values , hp , vp + 1 , item ) <NEWLINE> <NL> <DEDENT> def solve ( values ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( len ( values ) ) : <NEWLINE> <INDENT> for j in range ( len ( values [ i ] ) ) : <NEWLINE> <INDENT> if values [ i ] [ j ] in [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> search ( values , i , j , values [ i ] [ j ] ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> line , values = input ( ) . strip ( ) , list ( ) <NEWLINE> while line != <STRING> : <NEWLINE> <INDENT> H , W = list ( map ( int , line . split ( <STRING> ) ) ) <NEWLINE> value = list ( ) <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> value . append ( list ( x for x in input ( ) . strip ( ) ) ) <NEWLINE> <DEDENT> values . append ( value ) <NEWLINE> line = input ( ) . strip ( ) <NEWLINE> <DEDENT> for value in values : <NEWLINE> <INDENT> print ( solve ( value ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> on = [ ] <NEWLINE> off = [ ] <NEWLINE> <NL> acnt = 0 <NEWLINE> bcnt = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> if bcnt > 0 : <NEWLINE> <INDENT> off . append ( bcnt ) <NEWLINE> bcnt = 0 <NEWLINE> <DEDENT> acnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if acnt > 0 : <NEWLINE> <INDENT> on . append ( acnt ) <NEWLINE> acnt = 0 <NEWLINE> <DEDENT> bcnt += 1 <NEWLINE> <DEDENT> <DEDENT> if bcnt > 0 : <NEWLINE> <INDENT> off . append ( bcnt ) <NEWLINE> bcnt = 0 <NEWLINE> <DEDENT> if acnt > 0 : <NEWLINE> <INDENT> on . append ( acnt ) <NEWLINE> acnt = 0 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> for i in range ( len ( on ) - k + 1 ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> if i == 0 : <NEWLINE> <INDENT> a = sum ( on [ i : i + k ] ) <NEWLINE> b = sum ( off [ i : i + k + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += on [ i + k - 1 ] <NEWLINE> a -= on [ i - 1 ] <NEWLINE> if i + k <= len ( off ) - 1 : <NEWLINE> <INDENT> b += off [ i + k ] <NEWLINE> <DEDENT> b -= off [ i - 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> s = a + b <NEWLINE> ans = max ( ans , s ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( on ) - k + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> a = sum ( on [ i : i + k ] ) <NEWLINE> b = sum ( off [ i : i + k ] ) <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> a = sum ( on [ i : i + k ] ) <NEWLINE> b = sum ( off [ i - 1 : i + k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += on [ i + k - 1 ] <NEWLINE> a -= on [ i - 1 ] <NEWLINE> if i + k - 1 <= len ( off ) - 1 : <NEWLINE> <INDENT> b += off [ i + k - 1 ] <NEWLINE> <DEDENT> b -= off [ i - 2 ] <NEWLINE> <DEDENT> s = a + b <NEWLINE> <COMMENT> <NL> ans = max ( ans , s ) <NEWLINE> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > mod : <NEWLINE> <INDENT> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import combinations <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> letters = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , } <NEWLINE> to_check = combinations ( [ i for i in <STRING> ] , 3 ) <NEWLINE> <NL> for word in s : <NEWLINE> <INDENT> if word [ 0 ] in letters : <NEWLINE> <INDENT> letters [ word [ 0 ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in to_check : <NEWLINE> <INDENT> count += letters [ i [ 0 ] ] * letters [ i [ 1 ] ] * letters [ i [ 2 ] ] <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> pop_X = sum ( map ( int , list ( X ) ) ) <NEWLINE> X_10 = int ( <STRING> + X , 2 ) <NEWLINE> <NL> r_0 = X_10 % ( pop_X + 1 ) <NEWLINE> diff_0 = 1 % ( pop_X + 1 ) <NEWLINE> <NL> zero_flag = False <NEWLINE> if pop_X == 1 : <NEWLINE> <INDENT> zero_flag = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r_1 = X_10 % ( pop_X - 1 ) <NEWLINE> diff_1 = 1 % ( pop_X - 1 ) <NEWLINE> <NL> <DEDENT> answer = [ ] <NEWLINE> <NL> <NL> for i in range ( N ) [ : : - 1 ] : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> r = ( r_0 + diff_0 ) % ( pop_X + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if zero_flag : <NEWLINE> <INDENT> answer . append ( 0 ) <NEWLINE> diff_0 = ( diff_0 * 2 ) % ( pop_X + 1 ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = ( r_1 - diff_1 ) % ( pop_X - 1 ) <NEWLINE> <DEDENT> <DEDENT> count = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if r == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> pop = sum ( map ( int , list ( bin ( r ) [ 2 : ] ) ) ) <NEWLINE> r = r % pop <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> answer . append ( count ) <NEWLINE> diff_0 = ( diff_0 * 2 ) % ( pop_X + 1 ) <NEWLINE> if zero_flag : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> diff_1 = ( diff_1 * 2 ) % ( pop_X - 1 ) <NEWLINE> <NL> <DEDENT> for i in answer [ : : - 1 ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> abcd . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> abcd . sort ( ) <NEWLINE> <NL> import itertools <NEWLINE> A = list ( itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> for item in A : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for req in abcd : <NEWLINE> <INDENT> if item [ req [ 1 ] - 1 ] - item [ req [ 0 ] - 1 ] == req [ 2 ] : <NEWLINE> <INDENT> tmp += req [ 3 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> d = { 0 : 0 } <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> d [ i ] = bisect . bisect_right ( a , i ) <NEWLINE> print ( d [ i ] - d [ i - 1 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> MOD = 1000000007 <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> d_p = dict ( ) <NEWLINE> d_m = dict ( ) <NEWLINE> ans = 1 <NEWLINE> zz = 0 <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a == 0 and b == 0 : <NEWLINE> <INDENT> zz += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if a == 0 : <NEWLINE> <INDENT> n_sign = 0 <NEWLINE> b = 0 <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> n_sign = 1 <NEWLINE> a = 0 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> n_sign = ( ( a < 0 ) + ( b < 0 ) ) % 2 <NEWLINE> a = abs ( a ) <NEWLINE> b = abs ( b ) <NEWLINE> gcd = math . gcd ( a , b ) <NEWLINE> a //= gcd <NEWLINE> b //= gcd <NEWLINE> <NL> <DEDENT> if n_sign == 1 : <NEWLINE> <INDENT> s = str ( b ) + <STRING> + str ( a ) <NEWLINE> d_m [ s ] = d_m . get ( s , 0 ) + 1 <NEWLINE> <DEDENT> elif n_sign == 0 : <NEWLINE> <INDENT> s = str ( a ) + <STRING> + str ( b ) <NEWLINE> d_p [ s ] = d_p . get ( s , 0 ) + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for k , v in d_m . items ( ) : <NEWLINE> <INDENT> if k in d_p : <NEWLINE> <INDENT> ans *= ( 2 ** v + 2 ** d_p [ k ] - 1 ) <NEWLINE> d_p . pop ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= 2 ** v <NEWLINE> <DEDENT> ans %= MOD <NEWLINE> <NL> <DEDENT> for k , v in d_p . items ( ) : <NEWLINE> <INDENT> ans *= 2 ** v <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> ans -= 1 <NEWLINE> ans += zz <NEWLINE> ans %= MOD <NEWLINE> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> <NL> def inpl ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> N , K = inpl ( ) <NEWLINE> aa = inpl ( ) <NEWLINE> <NL> s = 1 <NEWLINE> <NL> route = [ s ] <NEWLINE> ed = set ( [ s ] ) <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> s = aa [ s - 1 ] <NEWLINE> if s in ed : <NEWLINE> <INDENT> Li = route . index ( s ) <NEWLINE> Ri = len ( route ) <NEWLINE> idx = Li + ( K - Li ) % ( Ri - Li ) <NEWLINE> print ( route [ idx ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> route . append ( s ) <NEWLINE> ed . add ( s ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
from collections import defaultdict , Counter <NEWLINE> import sys <NEWLINE> <NL> <COMMENT> <NL> dp = [ defaultdict ( Counter ) for _ in [ 0 ] * 11 ] <NEWLINE> dp [ 0 ] [ 0 ] [ 0 ] = 1 <NEWLINE> <NL> for i in range ( 1 , 11 ) : <NEWLINE> <INDENT> for used , counter in dp [ i - 1 ] . items ( ) : <NEWLINE> <INDENT> for j in filter ( lambda x : used & 2 ** x == 0 , range ( 10 ) ) : <NEWLINE> <INDENT> for total , count in counter . items ( ) : <NEWLINE> <INDENT> dp [ i ] [ used | 2 ** j ] [ total + j * i ] += count <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for n , s in ( map ( int , l . rstrip ( ) . split ( ) ) for l in sys . stdin ) : <NEWLINE> <INDENT> print ( sum ( v for counter in dp [ n ] . values ( ) for k , v in counter . items ( ) if k == s ) ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> anslist = [ ] <NEWLINE> for i in range ( 1 , max ( A , B ) + 1 ) : <NEWLINE> <INDENT> if ( A % i == 0 ) & ( B % i == 0 ) : <NEWLINE> <INDENT> anslist . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( anslist [ 0 - K ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> deepen_x = [ ] <NEWLINE> cur_x = 0 <NEWLINE> ponds = [ ] <COMMENT> <NEWLINE> while len ( line ) > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> tmp_char = line [ 0 ] <NEWLINE> if tmp_char == <STRING> : <NEWLINE> <INDENT> deepen_x . append ( cur_x ) <NEWLINE> <DEDENT> elif tmp_char == <STRING> and len ( deepen_x ) != 0 : <NEWLINE> <INDENT> pre_x = deepen_x . pop ( ) <NEWLINE> volume = cur_x - pre_x <NEWLINE> if len ( ponds ) == 0 : <NEWLINE> <INDENT> ponds . append ( [ pre_x , volume ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if pre_x < ponds [ - 1 ] [ 0 ] : <NEWLINE> <COMMENT> <NL> <INDENT> a = list ( filter ( lambda x : x [ 0 ] > pre_x , ponds ) ) <NEWLINE> pond = 0 <NEWLINE> for item in a : <NEWLINE> <INDENT> pond += item [ 1 ] <NEWLINE> <DEDENT> [ ponds . pop ( ) for x in range ( len ( a ) ) ] <NEWLINE> ponds . append ( [ pre_x , pond + volume ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ponds . append ( [ pre_x , volume ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> cur_x += 1 <NEWLINE> line = line [ 1 : ] <NEWLINE> <NL> <DEDENT> print ( sum ( [ x [ 1 ] for x in ponds ] ) ) <NEWLINE> if len ( ponds ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( len ( ponds ) ) + <STRING> . join ( [ str ( x [ 1 ] ) for x in ponds ] ) ) <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import queue <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> b = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( s - 1 ) <NEWLINE> b . append ( t - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> c = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> c [ a [ i ] ] . append ( b [ i ] ) <NEWLINE> c [ b [ i ] ] . append ( a [ i ] ) <NEWLINE> <NL> <DEDENT> q = queue . Queue ( ) <NEWLINE> q . put ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> inf = 10 ** 8 <NEWLINE> d = [ inf ] * n <NEWLINE> d [ 0 ] = 0 <NEWLINE> ans = [ 0 ] * n <NEWLINE> <NL> while not q . empty ( ) : <NEWLINE> <INDENT> x = q . get ( ) <NEWLINE> for i in c [ x ] : <NEWLINE> <INDENT> if d [ i ] == inf : <NEWLINE> <INDENT> q . put ( i ) <NEWLINE> d [ i ] = d [ x ] + 1 <NEWLINE> ans [ i ] = x + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1 <NEWLINE> if 0 in li : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in li : <NEWLINE> <INDENT> x = x * i <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import collections <NEWLINE> c = collections . Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] / A [ i - K ] > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def sgn ( x ) : <NEWLINE> <INDENT> if x > 0 : return 1 <NEWLINE> if x < 0 : return - 1 <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if X > 0 : <NEWLINE> <INDENT> x_greedy = X - K * D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x_greedy = X + K * D <NEWLINE> <NL> <DEDENT> if sgn ( X ) == sgn ( x_greedy ) : <NEWLINE> <INDENT> print ( abs ( x_greedy ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> x_r = X % D <NEWLINE> x_l = x_r - D <NEWLINE> <NL> r_parity = ( abs ( X - x_r ) // D ) % 2 <NEWLINE> <NL> if K % 2 == r_parity : <NEWLINE> <INDENT> print ( abs ( x_r ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x_l ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> while a [ i ] % 2 == 0 : <NEWLINE> <INDENT> a [ i ] //= 2 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> <NL> <NL> <NL> <STRING> <NEWLINE> <NL> def include3 ( v ) : <NEWLINE> <INDENT> s = str ( v ) <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def call ( n ) : <NEWLINE> <INDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( i , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if include3 ( i ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( i , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> call ( n ) <NEWLINE> print ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = set ( ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> b = input ( ) <NEWLINE> a . add ( b ) <NEWLINE> <DEDENT> print ( len ( a ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> d = defaultdict ( int ) <COMMENT> <NEWLINE> for a in A : <NEWLINE> <INDENT> d [ a ] ^= 1 <COMMENT> <NEWLINE> <DEDENT> print ( sum ( d . values ( ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ 0 ] * Q <NEWLINE> C = [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B [ i ] , C [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> num = [ 0 ] * 100000 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> num [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> S = [ sum ( A ) ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> S . append ( S [ i ] + ( C [ i ] - B [ i ] ) * num [ B [ i ] - 1 ] ) <NEWLINE> num [ C [ i ] - 1 ] += num [ B [ i ] - 1 ] <NEWLINE> num [ B [ i ] - 1 ] = 0 <NEWLINE> <NL> <DEDENT> S . pop ( 0 ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> print ( S [ i ] ) <NEWLINE> <DEDENT>
def max_heapify ( A , i ) : <NEWLINE> <INDENT> l = i * 2 <NEWLINE> r = l + 1 <NEWLINE> largest = i <NEWLINE> if l <= H and A [ l ] > A [ i ] : largest = l <NEWLINE> if r <= H and A [ r ] > A [ largest ] : largest = r <NEWLINE> if largest != i : <NEWLINE> <INDENT> A [ i ] , A [ largest ] = A [ largest ] , A [ i ] <NEWLINE> max_heapify ( A , largest ) <NEWLINE> <NL> <DEDENT> <DEDENT> def build_max_heap ( A ) : <NEWLINE> <INDENT> for i in range ( H // 2 , 0 , - 1 ) : <NEWLINE> <INDENT> max_heapify ( A , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> H = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . insert ( 0 , 0 ) <NEWLINE> build_max_heap ( A ) <NEWLINE> <NL> print ( <STRING> + <STRING> . join ( map ( str , A [ 1 : ] ) ) ) <NEWLINE>
from math import floor , sqrt <NEWLINE> <NL> cubics = [ x * x * x for x in range ( 101 ) ] <NEWLINE> squares = [ x * x for x in range ( 1000 ) ] <NEWLINE> while True : <NEWLINE> <INDENT> m = 1000000 <NEWLINE> e = int ( input ( ) ) <NEWLINE> if e == 0 : break <NEWLINE> for z in range ( len ( cubics ) ) : <NEWLINE> <INDENT> if e < cubics [ z ] : break <NEWLINE> tmp = e - cubics [ z ] <NEWLINE> y = floor ( sqrt ( tmp ) ) <NEWLINE> x = tmp - y ** 2 <NEWLINE> m = min ( m , x + y + z ) <NEWLINE> <DEDENT> print ( m ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> bomb = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> h -= 1 ; w -= 1 <NEWLINE> bomb . append ( ( h , w ) ) <NEWLINE> <NL> <DEDENT> row = [ 0 ] * H <NEWLINE> col = [ 0 ] * W <NEWLINE> <NL> for h , w in bomb : <NEWLINE> <INDENT> row [ h ] += 1 <NEWLINE> col [ w ] += 1 <NEWLINE> <NL> <DEDENT> lmax = max ( row ) + max ( col ) <NEWLINE> row = [ ( r , i ) for i , r in enumerate ( row ) ] <NEWLINE> col = [ ( c , i ) for i , c in enumerate ( col ) ] <NEWLINE> row . sort ( reverse = True ) <NEWLINE> col . sort ( reverse = True ) <NEWLINE> bomb = set ( bomb ) <NEWLINE> <NL> for r , i in row : <NEWLINE> <INDENT> for c , j in col : <NEWLINE> <INDENT> if r + c < lmax : break <NEWLINE> if not ( i , j ) in bomb : <NEWLINE> <INDENT> print ( lmax ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( lmax - 1 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * ( 2 ** n + 1 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> temp = 0 <NEWLINE> for i in c : <NEWLINE> <INDENT> temp += 2 ** ( i - 1 ) <NEWLINE> <DEDENT> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> if i != 0 and dp [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> t = i | temp <NEWLINE> if dp [ t ] == 0 : <NEWLINE> <INDENT> dp [ t ] = dp [ i ] + a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ t ] = min ( dp [ i ] + a , dp [ t ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = dp [ 2 ** n - 1 ] <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n_list = list ( input ( ) ) <NEWLINE> <NL> a = 0 <NEWLINE> for num_s in n_list : <NEWLINE> <INDENT> a += int ( num_s ) <NEWLINE> <NL> <DEDENT> if a % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> pn1 = p - 1 <NEWLINE> <NL> ans = sum ( pn1 [ : K ] ) <NEWLINE> spb = ans <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> sp = spb - pn1 [ i ] + pn1 [ i + K ] <NEWLINE> <COMMENT> <NL> ans = max ( sp , ans ) <NEWLINE> spb = sp <NEWLINE> <DEDENT> print ( ans / 2 + K ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( input ( ) . split ( ) ) <NEWLINE> B = [ int ( a ) for a in A ] <NEWLINE> x = 10 ** 9 + 7 <NEWLINE> summation1 = sum ( B ) ** 2 <NEWLINE> summation2 = sum ( b ** 2 for b in B ) <NEWLINE> summation = ( ( summation1 - summation2 ) // 2 ) % x <NEWLINE> print ( summation ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ 0 ] * N <NEWLINE> D = { } <NEWLINE> c = 1 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if L [ A - 1 ] == L [ B - 1 ] == 0 : <NEWLINE> <INDENT> D [ c ] = set ( ) <NEWLINE> D [ c ] . add ( A ) <NEWLINE> D [ c ] . add ( B ) <NEWLINE> L [ A - 1 ] = c <NEWLINE> L [ B - 1 ] = c <NEWLINE> c += 1 <NEWLINE> <DEDENT> elif L [ A - 1 ] == 0 : <NEWLINE> <INDENT> D [ L [ B - 1 ] ] . add ( A ) <NEWLINE> L [ A - 1 ] = L [ B - 1 ] <NEWLINE> <DEDENT> elif L [ B - 1 ] == 0 : <NEWLINE> <INDENT> D [ L [ A - 1 ] ] . add ( B ) <NEWLINE> L [ B - 1 ] = L [ A - 1 ] <NEWLINE> <DEDENT> elif L [ A - 1 ] != L [ B - 1 ] : <NEWLINE> <INDENT> if len ( D [ L [ A - 1 ] ] ) < len ( D [ L [ B - 1 ] ] ) : <NEWLINE> <INDENT> A , B = B , A <NEWLINE> <DEDENT> D [ L [ A - 1 ] ] |= D [ L [ B - 1 ] ] <NEWLINE> for j in D . pop ( L [ B - 1 ] ) : <NEWLINE> <INDENT> L [ j - 1 ] = L [ A - 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( D ) + L . count ( 0 ) - 1 ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> s [ 0 ] = <STRING> <NEWLINE> <DEDENT> for i in range ( 1 , len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and ( s [ i + 1 ] == <STRING> or s [ i + 1 ] == <STRING> ) : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if s [ len ( s ) - 1 ] == <STRING> : <NEWLINE> <INDENT> s [ len ( s ) - 1 ] = <STRING> <NEWLINE> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> AS = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> m = 10 ** 18 <NEWLINE> acc = 1 <NEWLINE> if 0 in AS : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> import sys <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in AS : <NEWLINE> <INDENT> acc *= i <NEWLINE> if acc > m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> import sys <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( acc ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> from collections import defaultdict <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> class Graph ( object ) : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . N = N <NEWLINE> self . E = defaultdict ( list ) <NEWLINE> <NL> <DEDENT> def add_edge ( self , f , t , w = 1 ) : <NEWLINE> <INDENT> self . E [ f ] . append ( t ) <NEWLINE> self . E [ t ] . append ( f ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def make_order ( g , v ) : <NEWLINE> <INDENT> seen = [ False ] * g . N <NEWLINE> last_order = [ - 1 ] * g . N <NEWLINE> parent = [ - 1 ] * g . N <NEWLINE> size = [ 1 ] * g . N <NEWLINE> counter = { <STRING> : 0 } <NEWLINE> <NL> def recur ( v ) : <NEWLINE> <INDENT> seen [ v ] = True <NEWLINE> for to in g . E [ v ] : <NEWLINE> <INDENT> if seen [ to ] == True : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> parent [ to ] = v <NEWLINE> recur ( to ) <NEWLINE> size [ v ] += size [ to ] <NEWLINE> <NL> <DEDENT> last_order [ counter [ <STRING> ] ] = v <NEWLINE> counter [ <STRING> ] += 1 <NEWLINE> <NL> <DEDENT> recur ( v ) <NEWLINE> return last_order , parent , size <NEWLINE> <NL> <NL> <DEDENT> def merge ( d : dict , e : dict ) : <NEWLINE> <INDENT> if len ( d ) < len ( e ) : <NEWLINE> <INDENT> d , e = e , d <NEWLINE> <DEDENT> for k in e : <NEWLINE> <INDENT> d [ k ] += e [ k ] <NEWLINE> <DEDENT> return d <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> c = [ x - 1 for x in map ( int , input ( ) . split ( ) ) ] <NEWLINE> A = [ None ] * ( N - 1 ) <NEWLINE> B = [ None ] * ( N - 1 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> g = Graph ( N ) <NEWLINE> for a , b in zip ( A , B ) : <NEWLINE> <INDENT> g . add_edge ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * N <NEWLINE> <NL> ret = { } <NEWLINE> last_order , parent , size = make_order ( g , 0 ) <NEWLINE> for curr in last_order : <NEWLINE> <INDENT> cn = c [ curr ] <NEWLINE> rrr = defaultdict ( int ) <NEWLINE> for dest in g . E [ curr ] : <NEWLINE> <INDENT> if dest == parent [ curr ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> child = ret . pop ( dest ) <NEWLINE> <NL> n = size [ dest ] - child [ cn ] <NEWLINE> ans [ cn ] += n * ( n + 1 ) // 2 <NEWLINE> <NL> <COMMENT> <NL> rrr = merge ( rrr , child ) <NEWLINE> <NL> <DEDENT> rrr [ cn ] = size [ curr ] <NEWLINE> ret [ curr ] = rrr <NEWLINE> <NL> <NL> <DEDENT> tot = N * ( N + 1 ) // 2 <NEWLINE> for color in range ( N ) : <NEWLINE> <INDENT> if color != c [ 0 ] : <NEWLINE> <INDENT> n = N - ret [ 0 ] [ color ] <NEWLINE> ans [ color ] += n * ( n + 1 ) // 2 <NEWLINE> <DEDENT> print ( tot - ans [ color ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> p = 1000000007 <NEWLINE> N = int ( readline ( ) . strip ( ) ) <NEWLINE> A = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> ai , bi = map ( int , readline ( ) . split ( ) ) <NEWLINE> if ai == 0 and bi == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> ans %= p <NEWLINE> continue <NEWLINE> <DEDENT> gi = math . gcd ( ai , bi ) <NEWLINE> ai //= gi <NEWLINE> bi //= gi <NEWLINE> if ai != 0 and bi != 0 : <NEWLINE> <INDENT> if ai < 0 and bi < 0 : <NEWLINE> <INDENT> ai *= - 1 <NEWLINE> bi *= - 1 <NEWLINE> <DEDENT> elif ai < 0 : <NEWLINE> <INDENT> ai *= - 1 <NEWLINE> s = <STRING> <NEWLINE> <DEDENT> elif bi < 0 : <NEWLINE> <INDENT> bi *= - 1 <NEWLINE> s = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif ai == 0 and bi != 0 : <NEWLINE> <INDENT> ai = 0 <NEWLINE> bi = 1 <NEWLINE> <DEDENT> elif bi == 0 and ai != 0 : <NEWLINE> <INDENT> ai = 1 <NEWLINE> bi = 0 <NEWLINE> s = <STRING> <NEWLINE> <DEDENT> xi = s + str ( ai ) + <STRING> + str ( bi ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> yi = s + str ( bi ) + <STRING> + str ( ai ) <NEWLINE> if xi in A : <NEWLINE> <INDENT> A [ xi ] [ 0 ] += 1 <NEWLINE> A [ xi ] [ 0 ] %= p <NEWLINE> <DEDENT> elif yi in A : <NEWLINE> <INDENT> A [ yi ] [ 1 ] += 1 <NEWLINE> A [ yi ] [ 1 ] %= p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ xi ] = [ 1 , 0 ] <NEWLINE> <DEDENT> <DEDENT> r = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> r *= ( pow ( 2 , A [ i ] [ 0 ] , p ) + pow ( 2 , A [ i ] [ 1 ] , p ) - 1 ) <NEWLINE> r %= p <NEWLINE> <DEDENT> ans += r - 1 <NEWLINE> ans %= p <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
inData = int ( input ( ) ) <NEWLINE> <NL> seqData = list ( range ( 1 , inData + 1 , 1 ) ) <NEWLINE> outData = [ 0 ] * inData <NEWLINE> for thisData in seqData : <NEWLINE> <INDENT> if thisData == inData : <NEWLINE> <INDENT> if thisData % 3 == 0 or thisData % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> + str ( thisData ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 5 ) : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> over = 10 ** i <NEWLINE> tmp = thisData / over <NEWLINE> if int ( tmp % 10 ) == 3 : <NEWLINE> <INDENT> print ( <STRING> + str ( thisData ) ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if thisData % 3 == 0 or thisData % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> + str ( thisData ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 5 ) : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> over = 10 ** i <NEWLINE> tmp = thisData / over <NEWLINE> if int ( tmp % 10 ) == 3 : <NEWLINE> <INDENT> print ( <STRING> + str ( thisData ) , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> V = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> even = { 0 : 0 } <NEWLINE> odd = { 0 : 0 } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> v = V [ i ] <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> if v in even : <NEWLINE> <INDENT> even [ v ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> even [ v ] = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if v in odd : <NEWLINE> <INDENT> odd [ v ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> odd [ v ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> omax = 0 <NEWLINE> emax = 0 <NEWLINE> onext = 0 <NEWLINE> enext = 0 <NEWLINE> <NL> for e in even : <NEWLINE> <INDENT> if even [ e ] > even [ emax ] : <NEWLINE> <INDENT> if even [ emax ] > even [ enext ] : <NEWLINE> <INDENT> enext = emax <NEWLINE> <DEDENT> emax = e <NEWLINE> <DEDENT> elif even [ e ] > even [ enext ] : <NEWLINE> <INDENT> enext = e <NEWLINE> <NL> <DEDENT> <DEDENT> for o in odd : <NEWLINE> <INDENT> if odd [ o ] > odd [ omax ] : <NEWLINE> <INDENT> if odd [ omax ] > odd [ onext ] : <NEWLINE> <INDENT> onext = omax <NEWLINE> <DEDENT> omax = o <NEWLINE> <DEDENT> elif odd [ o ] > odd [ onext ] : <NEWLINE> <INDENT> onext = o <NEWLINE> <NL> <DEDENT> <DEDENT> if omax != emax : <NEWLINE> <INDENT> print ( n - even [ emax ] - odd [ omax ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - even [ emax ] - odd [ omax ] + min ( even [ emax ] - even [ enext ] , odd [ omax ] - odd [ onext ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] == i + 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if i != n - 1 : <NEWLINE> <INDENT> p [ i ] , p [ i + 1 ] = p [ i + 1 ] , p [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> <DEDENT>
import math <NEWLINE> import itertools <NEWLINE> K = int ( input ( ) ) <NEWLINE> l = list ( itertools . combinations_with_replacement ( range ( 1 , K + 1 ) , 3 ) ) <NEWLINE> S = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> a = i [ 0 ] <NEWLINE> b = i [ 1 ] <NEWLINE> c = i [ 2 ] <NEWLINE> x = math . gcd ( a , b ) <NEWLINE> if a == b == c : <NEWLINE> <INDENT> S += math . gcd ( x , c ) <NEWLINE> <DEDENT> elif a == b or b == c or c == a : <NEWLINE> <INDENT> S += math . gcd ( x , c ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S += math . gcd ( x , c ) * 6 <NEWLINE> <DEDENT> <DEDENT> print ( S ) <NEWLINE> <NL> <NL> <NL>
a = input ( ) <NEWLINE> <NL> st = str ( a ) <NEWLINE> <NL> <NL> if st [ - 3 : ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> z = st [ - 3 : ] <NEWLINE> print ( 1000 - int ( z ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> scop = [ ] <COMMENT> <NEWLINE> scom = [ ] <NEWLINE> ssum = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> sa = 0 <NEWLINE> ms = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> sa += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sa -= 1 <NEWLINE> <DEDENT> if ms > sa : <NEWLINE> <INDENT> ms = sa <NEWLINE> <DEDENT> <DEDENT> if sa > 0 : <NEWLINE> <INDENT> scop . append ( [ ms , sa ] ) <NEWLINE> <DEDENT> elif not sa == ms : <NEWLINE> <INDENT> scom . append ( [ ms , sa ] ) <NEWLINE> <DEDENT> ssum += sa <NEWLINE> <NL> <DEDENT> if not ssum == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> scop . sort ( reverse = True ) <NEWLINE> scom . sort ( ) <NEWLINE> <NL> now = 0 <NEWLINE> for i in scop : <NEWLINE> <INDENT> if now + i [ 0 ] < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> now += i [ 1 ] <NEWLINE> <DEDENT> for i in scom : <NEWLINE> <INDENT> if now + i [ 0 ] < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> now += i [ 1 ] <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
import math <NEWLINE> import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> A_log = A <NEWLINE> try : <NEWLINE> <INDENT> A_log = list ( map ( math . log10 , A ) ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if sum ( A_log ) > 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> <DEDENT> if ans <= 1e18 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> from collections import defaultdict , deque <NEWLINE> <NL> N , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> G = defaultdict ( set ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> G [ a ] . add ( b ) <NEWLINE> G [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> grp = [ - 1 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> q = deque ( ) <NEWLINE> q . append ( ( i , i ) ) <NEWLINE> <NL> while ( len ( q ) != 0 ) : <NEWLINE> <INDENT> node , color = q . popleft ( ) <NEWLINE> if grp [ node ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> grp [ node ] = color <NEWLINE> for n in G [ node ] : <NEWLINE> <INDENT> if grp [ n ] == - 1 : <NEWLINE> <INDENT> q . append ( ( n , color ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n = defaultdict ( int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> n [ grp [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> for r in n : <NEWLINE> <INDENT> ret = max ( ret , n [ r ] ) <NEWLINE> <DEDENT> print ( ret ) <NEWLINE>
def main1 ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> ans = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <DEDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> ans [ A [ i ] ] += 1 <NEWLINE> if ans [ A [ i ] ] == 1 : <NEWLINE> <INDENT> for j in range ( A [ i ] * 2 , 10 ** 6 + 1 , A [ i ] ) : <NEWLINE> <INDENT> ans [ j ] = 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans . count ( 1 ) ) <NEWLINE> <DEDENT> main1 ( ) <NEWLINE>
import itertools <NEWLINE> <NL> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> if R - L + 1 >= 2019 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> LL = L % 2019 <NEWLINE> RR = R % 2019 <NEWLINE> if LL < RR : <NEWLINE> <INDENT> Amari_List = list ( range ( LL , RR + 1 ) ) <NEWLINE> ans = 2019 <NEWLINE> for v1 , v2 in itertools . combinations ( Amari_List , 2 ) : <NEWLINE> <INDENT> ca = ( v1 * v2 ) % 2019 <NEWLINE> if ca < ans : <NEWLINE> <INDENT> ans = ca <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL>
S = input ( ) <NEWLINE> if len ( S ) == 26 : <NEWLINE> <INDENT> done = set ( ) <NEWLINE> for i , s in enumerate ( S [ : : - 1 ] ) : <NEWLINE> <INDENT> s = ord ( s ) <NEWLINE> if done : <NEWLINE> <INDENT> if max ( done ) < s : <NEWLINE> <INDENT> done . add ( s ) <NEWLINE> if i == 25 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> elif i != 25 : <NEWLINE> <INDENT> l = 30 <NEWLINE> for d in done : <NEWLINE> <INDENT> if l > abs ( d - s ) and s < d : <NEWLINE> <INDENT> x = d <NEWLINE> l = d - s <NEWLINE> <DEDENT> <DEDENT> print ( S [ : - ( i + 1 ) ] + chr ( x ) ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( chr ( ord ( S [ 0 ] ) + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> done . add ( s ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) : <NEWLINE> <INDENT> if not ( chr ( i ) in S ) : <NEWLINE> <INDENT> print ( S + chr ( i ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ls = list ( s ) <NEWLINE> ls [ k - 1 ] = ls [ k - 1 ] . lower ( ) <NEWLINE> print ( <STRING> . join ( ls ) ) <NEWLINE>
s = input ( ) . split ( ) <NEWLINE> <NL> a = int ( s [ 0 ] ) <NEWLINE> b = int ( s [ 1 ] ) <NEWLINE> n = int ( s [ 2 ] ) <NEWLINE> <NL> if b == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = min ( b - 1 , n ) <NEWLINE> m = ( a * c ) // b <NEWLINE> print ( m ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> opt = [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> opt += [ min ( [ opt [ - j ] + abs ( h [ i - j ] - h [ i ] ) for j in range ( 1 , min ( i , k ) + 1 ) ] ) ] <NEWLINE> <DEDENT> print ( opt [ - 1 ] ) <NEWLINE>
from collections import deque , defaultdict <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> return b if not a % b else gcd ( b , a % b ) <NEWLINE> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // gcd ( a , b ) <NEWLINE> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> tmp = A [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> tmp = lcm ( tmp , A [ i ] ) <NEWLINE> <DEDENT> ans = m // tmp <NEWLINE> lis = set ( ) <NEWLINE> for i in A : <NEWLINE> <INDENT> r = i <NEWLINE> k = 0 <NEWLINE> while ( r % 2 == 0 ) : <NEWLINE> <INDENT> k += 1 <NEWLINE> r //= 2 <NEWLINE> <DEDENT> lis . add ( k ) <NEWLINE> <DEDENT> if ( m // ( tmp ) * tmp + tmp // 2 <= m ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> if ( len ( lis ) != 1 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
<COMMENT> <NL> import sys <NEWLINE> <NL> line = sys . stdin <NEWLINE> <NL> count = 1 <NEWLINE> for x in line : <NEWLINE> <INDENT> if int ( x ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( count , x ) , end = <STRING> ) <NEWLINE> count += 1 <NEWLINE> <DEDENT>
import itertools <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Sigma = sorted ( P , reverse = False ) <NEWLINE> print ( sum ( Sigma [ : K ] ) ) <NEWLINE>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n < b : <NEWLINE> <INDENT> print ( math . floor ( ( a * n ) / b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . floor ( a * ( b - 1 ) / b ) - a * math . floor ( ( b - 1 ) / b ) ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ ] <NEWLINE> ans = 10 ** 10 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = int ( input ( ) ) <NEWLINE> h . append ( tmp ) <NEWLINE> <DEDENT> h = sorted ( h ) [ : : - 1 ] <NEWLINE> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> ans = min ( h [ i ] - h [ i + K - 1 ] , ans ) <NEWLINE> <DEDENT> print ( str ( ans ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> temp = A [ 0 ] <NEWLINE> su = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if A [ i - 1 ] > A [ i ] : <NEWLINE> <INDENT> su += A [ i - 1 ] - A [ i ] <NEWLINE> A [ i ] = A [ i - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( su ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * ( n ) <NEWLINE> if k + 1 <= n : <NEWLINE> <INDENT> max = k + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max = n <NEWLINE> <NL> <DEDENT> for i in range ( 1 , max ) : <NEWLINE> <INDENT> dp [ i ] = abs ( h [ 0 ] - h [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( k , n ) : <NEWLINE> <INDENT> li = [ abs ( h [ i ] - h [ ik ] ) + dp [ ik ] for ik in range ( i - 1 , i - k - 1 , - 1 ) ] <NEWLINE> dp [ i ] = min ( li ) <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x_abs = abs ( x ) <NEWLINE> if x_abs - k * d >= 0 : <NEWLINE> <INDENT> print ( x_abs - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kk = k - x_abs // d <NEWLINE> x_now = x_abs - ( k - kk ) * d <NEWLINE> if kk % 2 == 0 : <NEWLINE> <INDENT> print ( x_now ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x_now - d ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> from bisect import bisect_right <NEWLINE> def prime_factorize_dict ( n ) : <NEWLINE> <INDENT> d = dict ( ) <NEWLINE> while not n & 1 : <NEWLINE> <INDENT> d [ 2 ] = d . get ( 2 , 0 ) + 1 <NEWLINE> n >>= 1 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if not n % f : <NEWLINE> <INDENT> d [ f ] = d . get ( f , 0 ) + 1 <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> d [ n ] = d . get ( n , 0 ) + 1 <NEWLINE> <DEDENT> return d <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> l = list ( prime_factorize_dict ( N ) . values ( ) ) <NEWLINE> L = list ( accumulate ( range ( 10 ** 6 ) ) ) <NEWLINE> print ( sum ( bisect_right ( L , item ) - 1 for item in l ) ) <NEWLINE>
from math import * <NEWLINE> <NL> def cin ( ) : <COMMENT> <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def cins ( ) : <COMMENT> <NEWLINE> <INDENT> return input . split ( ) <NEWLINE> <NL> <DEDENT> def cino ( test = False ) : <COMMENT> <NEWLINE> <INDENT> if not test : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> return input ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def cina ( ) : <COMMENT> <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def ssplit ( ) : <COMMENT> <NEWLINE> <INDENT> return list ( input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def printlist ( l ) : <COMMENT> <NEWLINE> <INDENT> for i in l : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> a = cino ( ) <NEWLINE> l = cina ( ) <NEWLINE> check = True <NEWLINE> suma = 1 <NEWLINE> l . sort ( ) <NEWLINE> if l [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in l : <NEWLINE> <INDENT> suma = suma * i <NEWLINE> if suma > 1000000000000000000 : <NEWLINE> <INDENT> check = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if check : <NEWLINE> <INDENT> print ( suma ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B , C = [ 0 for i in range ( Q ) ] , [ 0 for i in range ( Q ) ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B [ i ] , C [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> n = [ 0 for i in range ( 100001 ) ] <NEWLINE> S = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> n [ A [ i ] ] = n [ A [ i ] ] + 1 <NEWLINE> S = S + A [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> S = S + ( C [ i ] - B [ i ] ) * n [ B [ i ] ] <NEWLINE> n [ C [ i ] ] = n [ C [ i ] ] + n [ B [ i ] ] <NEWLINE> n [ B [ i ] ] = 0 <NEWLINE> print ( S ) <NEWLINE> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if abs ( X ) < ( K * D ) : <NEWLINE> <INDENT> a = abs ( X ) % D <NEWLINE> b = abs ( D - a ) <NEWLINE> c = abs ( X ) // D + 1 <NEWLINE> if ( K - c ) % 2 == 0 : <NEWLINE> <INDENT> goal = b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> goal = a <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> goal = abs ( X ) - ( D * K ) <NEWLINE> <NL> <DEDENT> print ( goal ) <NEWLINE>
import math <NEWLINE> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> X = H * 30 + M * 0.5 <NEWLINE> Y = M * 6 <NEWLINE> if - 180 < X - Y < 0 : <NEWLINE> <INDENT> z = Y - X <NEWLINE> <DEDENT> elif X - Y <= - 180 : <NEWLINE> <INDENT> z = 360 - ( Y - X ) <NEWLINE> <DEDENT> elif 180 > X - Y >= 0 : <NEWLINE> <INDENT> z = X - Y <NEWLINE> <DEDENT> elif X - Y >= 180 : <NEWLINE> <INDENT> z = 360 - ( X - Y ) <NEWLINE> <DEDENT> ans = A * A + B * B - 2 * A * B * math . cos ( math . radians ( z ) ) <NEWLINE> ANS = math . sqrt ( ans ) <NEWLINE> <NL> print ( ANS ) <NEWLINE>
import copy <NEWLINE> <NL> def num_from_card ( card ) : <NEWLINE> <INDENT> return int ( card [ 2 : ] ) <NEWLINE> <NL> <DEDENT> def partition ( A , p , r ) : <NEWLINE> <INDENT> x = num_from_card ( A [ r ] ) <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if num_from_card ( A [ j ] ) <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> <DEDENT> <DEDENT> A [ i + 1 ] , A [ r ] = A [ r ] , A [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <NL> <DEDENT> def quick_sort ( A , p , r ) : <NEWLINE> <INDENT> if p < r : <NEWLINE> <INDENT> q = partition ( A , p , r ) <NEWLINE> quick_sort ( A , p , q - 1 ) <NEWLINE> quick_sort ( A , q + 1 , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> L = A [ left : mid ] <NEWLINE> R = A [ mid : right ] <NEWLINE> L . append ( <STRING> + str ( int ( 10e9 + 1 ) ) ) <NEWLINE> R . append ( <STRING> + str ( int ( 10e9 + 1 ) ) ) <NEWLINE> i , j = 0 , 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if num_from_card ( L [ i ] ) <= num_from_card ( R [ j ] ) : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def merge_sort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> merge_sort ( A , left , mid ) <NEWLINE> merge_sort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> cards = [ input ( ) for i in range ( n ) ] <NEWLINE> merge_cards = copy . copy ( cards ) <NEWLINE> <NL> quick_sort ( cards , 0 , n - 1 ) <NEWLINE> merge_sort ( merge_cards , 0 , n ) <NEWLINE> <NL> if merge_cards == cards : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> for c in cards : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <NL> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans_l = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> tmp = s [ i ] + s [ i + 1 ] <NEWLINE> if tmp == <STRING> : <NEWLINE> <INDENT> ans_l [ i + 1 ] = ans_l [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_l [ i + 1 ] = ans_l [ i ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ans_l [ r - 1 ] - ans_l [ l - 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> R = S . count ( <STRING> ) <NEWLINE> G = S . count ( <STRING> ) <NEWLINE> B = S . count ( <STRING> ) <NEWLINE> ans = R * G * B <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i , N ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from bisect import bisect_left <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> ans += bisect_left ( l , l [ i ] + l [ j ] ) - j - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> <NL> def bracket ( x ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> f = m = 0 <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> f += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f -= 1 <NEWLINE> <DEDENT> m = min ( m , f ) <NEWLINE> <COMMENT> <NL> <DEDENT> return f , m <NEWLINE> <NL> <NL> <DEDENT> def func ( l ) : <NEWLINE> <COMMENT> <NL> <INDENT> l . sort ( key = lambda x : - x [ 1 ] ) <NEWLINE> v = 0 <NEWLINE> for fi , mi in l : <NEWLINE> <INDENT> if v + mi >= 0 : <NEWLINE> <INDENT> v += fi <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return v <NEWLINE> <NL> <NL> <DEDENT> l1 = [ ] <NEWLINE> l2 = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> fi , mi = bracket ( s [ i ] ) <NEWLINE> if fi >= 0 : <NEWLINE> <INDENT> l1 . append ( ( fi , mi ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l2 . append ( ( - fi , mi - fi ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> v1 = func ( l1 ) <NEWLINE> v2 = func ( l2 ) <NEWLINE> if v1 == - 1 or v2 == - 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> if v1 == v2 else <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def gcd ( x , y ) : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> while y > 0 : <NEWLINE> <INDENT> r = x % y <NEWLINE> x = y <NEWLINE> y = r <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> print ( str ( gcd ( x , y ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> plst = sorted ( [ x for x in lst if x >= 0 ] , reverse = True ) <NEWLINE> nlst = sorted ( [ abs ( x ) for x in lst if x < 0 ] , reverse = True ) <NEWLINE> out = [ None for _ in range ( k ) ] <NEWLINE> lenn = len ( nlst ) <NEWLINE> lenp = len ( plst ) <NEWLINE> <NL> <NL> <NL> if lenp == 0 and k % 2 == 1 : <NEWLINE> <INDENT> sm = 1 <NEWLINE> for i in range ( lenn - 1 , lenn - k - 1 , - 1 ) : <NEWLINE> <INDENT> sm *= - nlst [ i ] <NEWLINE> sm %= mod <NEWLINE> <DEDENT> print ( sm ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if n == k : <NEWLINE> <INDENT> sm = 1 <NEWLINE> for x in lst : <NEWLINE> <INDENT> sm *= x <NEWLINE> sm %= mod <NEWLINE> <DEDENT> print ( sm ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT> ptoken = 0 <NEWLINE> ntoken = 0 <NEWLINE> token = 0 <NEWLINE> pm = 0 <NEWLINE> <NL> <NL> <NL> while token < k : <NEWLINE> <INDENT> if ptoken == lenp : <NEWLINE> <INDENT> out [ token ] = nlst [ ntoken ] <NEWLINE> pm = ( pm + 1 ) % 2 <NEWLINE> ntoken += 1 <NEWLINE> <DEDENT> elif ntoken == lenn : <NEWLINE> <INDENT> out [ token ] = plst [ ptoken ] <NEWLINE> ptoken += 1 <NEWLINE> <DEDENT> elif plst [ ptoken ] > nlst [ ntoken ] : <NEWLINE> <INDENT> out [ token ] = plst [ ptoken ] <NEWLINE> ptoken += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> out [ token ] = nlst [ ntoken ] <NEWLINE> pm = ( pm + 1 ) % 2 <NEWLINE> ntoken += 1 <NEWLINE> <DEDENT> token += 1 <NEWLINE> <NL> <DEDENT> if pm == 1 : <NEWLINE> <INDENT> if ptoken == lenp : <NEWLINE> <INDENT> out . remove ( plst [ ptoken - 1 ] ) <NEWLINE> out . append ( nlst [ ntoken ] ) <NEWLINE> <DEDENT> elif ntoken == lenn : <NEWLINE> <INDENT> out . remove ( nlst [ ntoken - 1 ] ) <NEWLINE> out . append ( plst [ ptoken ] ) <NEWLINE> <DEDENT> elif ptoken == 0 : <NEWLINE> <INDENT> out . remove ( nlst [ ntoken - 1 ] ) <NEWLINE> out . append ( plst [ ptoken ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if nlst [ ntoken - 1 ] * nlst [ ntoken ] >= plst [ ptoken - 1 ] * plst [ ptoken ] : <NEWLINE> <INDENT> out . remove ( plst [ ptoken - 1 ] ) <NEWLINE> out . append ( nlst [ ntoken ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> out . remove ( nlst [ ntoken - 1 ] ) <NEWLINE> out . append ( plst [ ptoken ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> sm = 1 <NEWLINE> for x in out : <NEWLINE> <INDENT> sm *= x <NEWLINE> sm %= mod <NEWLINE> <NL> <DEDENT> print ( sm ) <NEWLINE>
A , B , N = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> x = B - 1 <NEWLINE> if x > N : <NEWLINE> <INDENT> x = N <NEWLINE> <DEDENT> print ( int ( A * x / B ) - A * int ( x / B ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> l = [ ] <NEWLINE> h . sort ( ) <NEWLINE> for i in range ( n + 1 - k ) : <NEWLINE> <INDENT> x = h [ i + k - 1 ] - h [ i ] <NEWLINE> l . append ( x ) <NEWLINE> <DEDENT> print ( min ( l ) ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> <NL> S = A [ left : mid ] <NEWLINE> T = A [ mid : right ] <NEWLINE> S . append ( float ( <STRING> ) ) <NEWLINE> T . append ( float ( <STRING> ) ) <NEWLINE> <NL> s_i = 0 <NEWLINE> t_i = 0 <NEWLINE> for i in range ( right - left ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if S [ s_i ] < T [ t_i ] : <NEWLINE> <INDENT> A [ left + i ] = S [ s_i ] <NEWLINE> s_i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ left + i ] = T [ t_i ] <NEWLINE> t_i += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def merge_sort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 == right : <NEWLINE> <COMMENT> <NL> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( A , left , mid ) <NEWLINE> merge_sort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> merge_sort ( A , 0 , len ( A ) ) <NEWLINE> print ( * A ) <NEWLINE> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> res = 1 <NEWLINE> xx = 10 ** 18 <NEWLINE> f = 0 <NEWLINE> a . sort ( ) <NEWLINE> for i in a : <NEWLINE> <INDENT> res *= i <NEWLINE> if res > xx : <NEWLINE> <INDENT> f = 1 <NEWLINE> print ( - 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if f == 0 : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ a [ 0 ] ] <NEWLINE> k = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> b . append ( a [ i ] + b [ i - 1 ] ) <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> k += a [ i ] * ( b [ n - 1 ] - b [ i ] ) <NEWLINE> <DEDENT> print ( k % ( 10 ** 9 + 7 ) ) <NEWLINE>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( pi * r * r , 2 * pi * r ) <NEWLINE>
from collections import defaultdict <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d [ i + 1 ] = l [ i ] <NEWLINE> <DEDENT> visited = set ( ) <NEWLINE> l = [ ] <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> if i not in visited : <NEWLINE> <INDENT> visited . add ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i = d [ i ] <NEWLINE> <DEDENT> first = l . index ( l [ - 1 ] ) <NEWLINE> if k < first : <NEWLINE> <INDENT> print ( l [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = ( k - first ) % ( ( len ( l ) - 1 ) - first ) <NEWLINE> k += first <NEWLINE> print ( l [ k ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sorted_A = list ( reversed ( sorted ( A ) ) ) <NEWLINE> print ( <STRING> if sorted_A [ m - 1 ] < sum ( A ) / ( 4 * m ) else <STRING> ) <NEWLINE>
def mergeSort ( A , left , right , n ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = int ( ( right + left ) / 2 ) <NEWLINE> mergeSort ( A , left , mid , n ) <NEWLINE> mergeSort ( A , mid , right , n ) <NEWLINE> return ( merge ( A , left , mid , right , n ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def merge ( A , left , mid , right , n ) : <NEWLINE> <INDENT> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> L = A [ left : mid ] + [ 10 ** 9 + 1 ] <NEWLINE> R = A [ mid : right ] + [ 10 ** 9 + 1 ] <NEWLINE> i , j = 0 , 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> A [ n ] += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> key = L [ i ] <NEWLINE> A [ k ] = key <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> key = R [ j ] <NEWLINE> A [ k ] = key <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> return A <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . append ( 0 ) <NEWLINE> S = mergeSort ( A , 0 , len ( A ) - 1 , n ) <NEWLINE> print ( <STRING> . join ( list ( map ( str , S [ : n ] ) ) ) ) <NEWLINE> print ( S [ n ] ) <NEWLINE>
cnt = 1 <NEWLINE> mod = 7 <NEWLINE> k = int ( input ( ) ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if mod % k == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> mod = ( mod * 10 + 7 ) % k <NEWLINE> <DEDENT> if mod % k == 0 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if M == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> INF = 10 ** 6 <NEWLINE> pqc = [ tuple ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> to1d = { v : { } for v in range ( N ) } <NEWLINE> count = 2 <NEWLINE> for p , q , c in pqc : <NEWLINE> <INDENT> if not to1d [ p ] . get ( c ) : <NEWLINE> <INDENT> to1d [ p ] [ c ] = count <NEWLINE> count += 1 <NEWLINE> <DEDENT> if not to1d [ q ] . get ( c ) : <NEWLINE> <INDENT> to1d [ q ] [ c ] = count <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> G = [ { } for _ in range ( N + count ) ] <NEWLINE> for p , q , c in pqc : <NEWLINE> <INDENT> v1 , v2 = to1d [ p ] [ c ] , to1d [ q ] [ c ] <NEWLINE> G [ v1 ] [ v2 ] = G [ v2 ] [ v1 ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if len ( to1d [ i ] ) <= 1 : continue <NEWLINE> for c in to1d [ i ] . keys ( ) : <NEWLINE> <INDENT> v = to1d [ i ] [ c ] <NEWLINE> G [ v ] [ count ] = 1 <NEWLINE> G [ count ] [ v ] = 0 <NEWLINE> <DEDENT> count += 1 <NEWLINE> <NL> <DEDENT> def dijkstra ( start = 0 , goal = 1 ) : <NEWLINE> <INDENT> from heapq import heappop , heappush <NEWLINE> NN = len ( G ) <NEWLINE> d = [ INF ] * NN <NEWLINE> d [ start ] = 0 <NEWLINE> que = [ ] <NEWLINE> heappush ( que , start ) <NEWLINE> while que : <NEWLINE> <INDENT> p = divmod ( heappop ( que ) , NN ) <NEWLINE> v = p [ 1 ] <NEWLINE> if d [ v ] < p [ 0 ] : continue <NEWLINE> for u in G [ v ] . keys ( ) : <NEWLINE> <INDENT> if d [ u ] > d [ v ] + G [ v ] [ u ] : <NEWLINE> <INDENT> d [ u ] = d [ v ] + G [ v ] [ u ] <NEWLINE> heappush ( que , d [ u ] * NN + u ) <NEWLINE> <DEDENT> <DEDENT> if v == goal : return d [ goal ] <NEWLINE> <DEDENT> return d [ goal ] <NEWLINE> <NL> <DEDENT> for c in to1d [ 0 ] . keys ( ) : <NEWLINE> <INDENT> v = to1d [ 0 ] [ c ] <NEWLINE> G [ 0 ] [ v ] = 1 <NEWLINE> <DEDENT> for c in to1d [ N - 1 ] . keys ( ) : <NEWLINE> <INDENT> v = to1d [ N - 1 ] [ c ] <NEWLINE> G [ v ] [ 1 ] = 0 <NEWLINE> <NL> <DEDENT> ans = dijkstra ( 0 , 1 ) <NEWLINE> print ( ans if ans < INF else - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> B_list = A_list . copy ( ) <NEWLINE> <NL> for i in range ( 1 , len ( A_list ) ) : <NEWLINE> <INDENT> if A_list [ i ] < A_list [ i - 1 ] : <NEWLINE> <INDENT> A_list [ i ] = A_list [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> A_array = np . array ( A_list ) <NEWLINE> B_array = np . array ( B_list ) <NEWLINE> <NL> print ( np . sum ( A_array - B_array ) ) <NEWLINE>
def init ( ) : <NEWLINE> <INDENT> global top <NEWLINE> top = 0 <NEWLINE> <NL> <DEDENT> def isEmpty ( ) : <NEWLINE> <INDENT> global top <NEWLINE> return top == 0 <NEWLINE> <NL> <DEDENT> def isFull ( ) : <NEWLINE> <INDENT> global top , MAX <NEWLINE> return top >= MAX <NEWLINE> <NL> <DEDENT> def push ( x ) : <NEWLINE> <INDENT> global top , s <NEWLINE> if isFull ( ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> s [ top ] = x <NEWLINE> top += 1 <NEWLINE> <NL> <NL> <DEDENT> def pop ( ) : <NEWLINE> <INDENT> global top , s <NEWLINE> if isEmpty ( ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> top -= 1 <NEWLINE> return s [ top ] <NEWLINE> <NL> <NL> <DEDENT> def calc ( i_1 , i_2 , op ) : <NEWLINE> <INDENT> if op == <STRING> : <NEWLINE> <INDENT> return i_1 + i_2 <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> return i_1 - i_2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return i_1 * i_2 <NEWLINE> <NL> <DEDENT> <DEDENT> data = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> top = 0 <NEWLINE> MAX = 100 <NEWLINE> s = [ 0 for i in range ( MAX ) ] <NEWLINE> for i in data : <NEWLINE> <INDENT> if i == <STRING> or i == <STRING> or i == <STRING> : <NEWLINE> <INDENT> a = pop ( ) <NEWLINE> b = pop ( ) <NEWLINE> push ( calc ( int ( b ) , int ( a ) , i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> push ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( s [ 0 ] ) <NEWLINE> <NL>
MOD = 1000000007 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> answer = 0 <NEWLINE> s = sum ( A ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> s -= a <NEWLINE> answer += ( a * s ) <NEWLINE> <DEDENT> print ( answer % MOD ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> B = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> total = 0 <NEWLINE> Asum = sum ( A ) <NEWLINE> nA = len ( A ) <NEWLINE> Bsum = 0 <NEWLINE> ans = 0 <NEWLINE> for nB in range ( len ( B ) + 1 ) : <NEWLINE> <INDENT> if nB != 0 : <NEWLINE> <INDENT> Bsum += B [ nB - 1 ] <NEWLINE> <DEDENT> if Bsum > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while Asum + Bsum > K : <NEWLINE> <INDENT> nA -= 1 <NEWLINE> Asum -= A [ nA ] <NEWLINE> <DEDENT> ans = max ( nA + nB , ans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = sorted ( x ) <NEWLINE> a = y [ n // 2 - 1 ] <NEWLINE> b = y [ n // 2 ] <NEWLINE> for i in x : <NEWLINE> <INDENT> print ( ( a , b ) [ i <= a ] ) <NEWLINE> <DEDENT>
import math , sys <NEWLINE> MAX = pow ( 2 , 31 ) - 1 <NEWLINE> <NL> <COMMENT> <NL> class SegmentTree ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . TreeRange = pow ( 2 , math . ceil ( math . log2 ( n ) ) ) <NEWLINE> self . List = [ MAX ] * ( 2 * self . TreeRange - 1 ) <NEWLINE> <NL> <DEDENT> def update ( self , i , x ) : <NEWLINE> <INDENT> i += self . TreeRange - 1 <NEWLINE> self . List [ i ] = x <NEWLINE> while i > 0 : <NEWLINE> <INDENT> i = ( i - 1 ) // 2 <NEWLINE> self . List [ i ] = min ( self . List [ i * 2 + 1 ] , self . List [ i * 2 + 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( self , s , t , i = 0 , left = 0 , right = float ( <STRING> ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> if right <= s or t <= left : <NEWLINE> <INDENT> return MAX <NEWLINE> <COMMENT> <NL> <DEDENT> elif s <= left <= right <= t : <NEWLINE> <INDENT> return self . List [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> l = self . find ( s , t , i * 2 + 1 , left , ( left + right ) // 2 ) <NEWLINE> r = self . find ( s , t , i * 2 + 2 , ( left + right ) // 2 , right ) <NEWLINE> return min ( l , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> _input = sys . stdin . readlines ( ) <NEWLINE> n , q = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> qlist = map ( lambda x : x . split ( ) , _input [ 1 : ] ) <NEWLINE> ST = SegmentTree ( n ) <NEWLINE> <NL> for q in qlist : <NEWLINE> <INDENT> cmd , x , y = map ( int , q ) <NEWLINE> if cmd == 0 : <NEWLINE> <INDENT> ST . update ( x , y ) <NEWLINE> <DEDENT> elif cmd == 1 : <NEWLINE> <INDENT> print ( ST . find ( x , y + 1 , right = ST . TreeRange ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> count = 0 <NEWLINE> <NL> i , j = 0 , n - 1 <NEWLINE> if c . count ( <STRING> ) == 0 : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> elif c . count ( <STRING> ) == 0 : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> white_cnt = [ ] <NEWLINE> red_cnt = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> white_cnt . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> red_cnt . append ( i ) <NEWLINE> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> white_num = white_cnt . pop ( 0 ) <NEWLINE> red_num = red_cnt . pop ( ) <NEWLINE> if white_num < red_num : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if len ( white_cnt ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if len ( red_cnt ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<NL> def tax ( p , x ) : <NEWLINE> <INDENT> return p * ( 100 + x ) // 100 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> x , y , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x , y , s ) == ( 0 , 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> r = 0 <NEWLINE> for i in range ( 1 , s ) : <NEWLINE> <INDENT> for j in range ( 1 , s ) : <NEWLINE> <INDENT> t = tax ( i , x ) + tax ( j , x ) <NEWLINE> if t > s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( t ) == s : <NEWLINE> <INDENT> r = max ( ( tax ( i , y ) + tax ( j , y ) ) , r ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <DEDENT>
a = input ( ) . split ( ) <NEWLINE> X = int ( a [ 0 ] ) <NEWLINE> N = int ( a [ 1 ] ) <NEWLINE> OK = [ ] <NEWLINE> list = [ ] <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = input ( ) . split ( ) <NEWLINE> for i in range ( 102 ) : <NEWLINE> <INDENT> OK . append ( str ( i ) ) <NEWLINE> <DEDENT> for i in range ( len ( P ) ) : <NEWLINE> <INDENT> OK . remove ( P [ i ] ) <NEWLINE> <DEDENT> for i in range ( len ( OK ) ) : <NEWLINE> <INDENT> list . append ( abs ( int ( OK [ i ] ) - X ) ) <NEWLINE> <DEDENT> Y = list . index ( min ( list ) ) <NEWLINE> print ( OK [ Y ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> while n > 999 : <NEWLINE> <INDENT> n = n % 1000 <NEWLINE> <DEDENT> if n == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - n ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> from itertools import product <NEWLINE> K = int ( input ( ) ) <NEWLINE> gcd = 0. <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> a = math . gcd ( i + 1 , j + 1 ) <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> gcd += math . gcd ( a , k + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( int ( gcd ) ) <NEWLINE>
import queue <NEWLINE> import math <NEWLINE> <NL> <NL> def warshall ( graph , n ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> graph [ i ] [ i ] = 0 <NEWLINE> <NL> <DEDENT> for k in range ( n ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> graph [ i ] [ j ] = min ( graph [ i ] [ j ] , graph [ i ] [ k ] + graph [ k ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return graph <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ float ( <STRING> ) for _ in range ( n ) ] for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> graph [ data [ 0 ] ] [ data [ 1 ] ] = data [ 2 ] <NEWLINE> <NL> <DEDENT> dist = warshall ( graph , n ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if dist [ i ] [ i ] < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <NL> <INDENT> if j == 0 : <NEWLINE> <INDENT> print ( dist [ i ] [ j ] if dist [ i ] [ j ] != float ( <STRING> ) else <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( dist [ i ] [ j ] if dist [ i ] [ j ] != float ( <STRING> ) else <STRING> ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> S1 = set ( [ ] ) <NEWLINE> S2 = set ( [ ] ) <NEWLINE> S3 = set ( [ ] ) <NEWLINE> for i in S : <NEWLINE> <INDENT> for s3 in S2 : <NEWLINE> <INDENT> S3 . add ( s3 + i ) <NEWLINE> <DEDENT> for s2 in S1 : <NEWLINE> <INDENT> S2 . add ( s2 + i ) <NEWLINE> <DEDENT> S1 . add ( i ) <NEWLINE> <DEDENT> print ( len ( S3 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> d = int ( n / 2 ) <NEWLINE> r = l [ d ] - l [ d - 1 ] <NEWLINE> print ( r ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 0 <NEWLINE> x = sum ( A ) ** 2 <NEWLINE> for i in A : <NEWLINE> <INDENT> x -= i ** 2 <NEWLINE> <DEDENT> print ( x // 2 % 1000000007 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> s = list ( S ) <NEWLINE> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r = r + 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> g = g + 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <DEDENT> <DEDENT> p = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if 2 * j - i < N : <NEWLINE> <INDENT> if s [ 2 * j - i ] == s [ i ] or s [ 2 * j - i ] == s [ j ] or s [ i ] == s [ j ] : <NEWLINE> <INDENT> p = p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = p + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - p ) <NEWLINE>
<COMMENT> <NL> import bisect <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> INF = 2 ** 62 - 1 <NEWLINE> <NL> <NL> def read_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def read_int_n ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def read_float ( ) : <NEWLINE> <INDENT> return float ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def read_float_n ( ) : <NEWLINE> <INDENT> return list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def read_str ( ) : <NEWLINE> <INDENT> return input ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def read_str_n ( ) : <NEWLINE> <INDENT> return list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def error_print ( * args ) : <NEWLINE> <INDENT> print ( * args , file = sys . stderr ) <NEWLINE> <NL> <NL> <DEDENT> def mt ( f ) : <NEWLINE> <INDENT> import time <NEWLINE> <NL> def wrap ( * args , ** kwargs ) : <NEWLINE> <INDENT> s = time . time ( ) <NEWLINE> ret = f ( * args , ** kwargs ) <NEWLINE> e = time . time ( ) <NEWLINE> <NL> error_print ( e - s , <STRING> ) <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> return wrap <NEWLINE> <NL> <NL> <DEDENT> ans = [ - 1 ] * ( 2 * 10 ** 5 + 1 ) <NEWLINE> <NL> <NL> @ mt <NEWLINE> def slv ( N , A , UV ) : <NEWLINE> <INDENT> A . insert ( 0 , - 1 ) <NEWLINE> g = [ list ( ) for _ in range ( 0 , N + 1 ) ] <NEWLINE> for u , v in UV : <NEWLINE> <INDENT> g [ u ] . append ( v ) <NEWLINE> g [ v ] . append ( u ) <NEWLINE> <NL> <DEDENT> def dfs ( u , p , dp ) : <NEWLINE> <INDENT> global ans <NEWLINE> <NL> for v in g [ u ] : <NEWLINE> <INDENT> if v == p : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> i = bisect . bisect_left ( dp , A [ v ] ) <NEWLINE> b = dp [ i ] <NEWLINE> dp [ i ] = A [ v ] <NEWLINE> ans [ v ] = bisect . bisect_left ( dp , INF ) <NEWLINE> dfs ( v , u , dp ) <NEWLINE> dp [ i ] = b <NEWLINE> <DEDENT> <DEDENT> dp = [ INF ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = A [ 1 ] <NEWLINE> dfs ( 1 , 0 , dp ) <NEWLINE> <NL> ans [ 1 ] = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = read_int ( ) <NEWLINE> A = read_int_n ( ) <NEWLINE> UV = [ read_int_n ( ) for _ in range ( N - 1 ) ] <NEWLINE> slv ( N , A , UV ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> numgcd = [ 0 ] * ( K + 1 ) <NEWLINE> sumgcd = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( 1 , K + 1 ) [ : : - 1 ] : <NEWLINE> <INDENT> numgcd [ i ] = pow ( K // i , N , mod ) <NEWLINE> count = 2 <NEWLINE> while count * i <= K : <NEWLINE> <INDENT> numgcd [ i ] -= numgcd [ count * i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> sumgcd += numgcd [ i ] * i <NEWLINE> <DEDENT> print ( sumgcd % mod ) <NEWLINE>
l = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> c = 0 <NEWLINE> <NL> for i in range ( 1 , l ) : <NEWLINE> <INDENT> for ii in range ( i , l ) : <NEWLINE> <INDENT> sum = i * ii <NEWLINE> if sum >= l : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i != ii : <NEWLINE> <INDENT> c += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a >= k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if k - a - b <= 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( a - ( k - a - b ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> <NL> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = input ( ) <NEWLINE> if A in ans : <NEWLINE> <INDENT> ans [ A ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ A ] = 1 <NEWLINE> <DEDENT> <DEDENT> c = 0 <NEWLINE> for i in ans : <NEWLINE> <INDENT> if ans [ i ] % 2 == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import sys <NEWLINE> import os <NEWLINE> <NL> def file_input ( ) : <NEWLINE> <INDENT> f = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdin = f <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> S = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . add ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( S ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ i for i in range ( 201 ) ] <NEWLINE> b = sorted ( list ( set ( a ) - set ( p ) ) ) <NEWLINE> min_v = 1000 <NEWLINE> min_id = 0 <NEWLINE> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> if abs ( x - b [ i ] ) < min_v : <NEWLINE> <INDENT> min_v = abs ( x - b [ i ] ) <NEWLINE> min_id = i <NEWLINE> <DEDENT> <DEDENT> print ( b [ min_id ] ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n != 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = [ ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> if x in p : <NEWLINE> <INDENT> low = x <NEWLINE> high = x <NEWLINE> while True : <NEWLINE> <INDENT> low -= 1 <NEWLINE> high += 1 <NEWLINE> if low in p : <NEWLINE> <INDENT> if high in p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = high <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = low <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> hoge = math . gcd ( x , y ) <NEWLINE> for z in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( hoge , z ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> if A [ 0 ] == 0 : <NEWLINE> <INDENT> ANS = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A . sort ( reverse = True ) <NEWLINE> ANS = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ANS = ANS * a <NEWLINE> if ANS > 10 ** 18 : <NEWLINE> <INDENT> ANS = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ANS ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> li = [ True for _ in range ( 0 , 10 ** 6 + 1 ) ] <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> used = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] not in used . keys ( ) : <NEWLINE> <INDENT> used [ A [ i ] ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> used [ A [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k in used . keys ( ) : <NEWLINE> <INDENT> if used [ k ] > 1 : <NEWLINE> <INDENT> for j in range ( k , 10 ** 6 + 1 , k ) : <NEWLINE> <INDENT> li [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if li [ A [ i ] ] and used [ A [ i ] ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( A [ i ] , 10 ** 6 + 1 , A [ i ] ) : <NEWLINE> <INDENT> li [ j ] = False <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dic = { } <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a in dic : <NEWLINE> <INDENT> dic [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ a ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> li = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> for a in dic : <NEWLINE> <INDENT> li [ dic [ a ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> k = len ( dic ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if li [ i ] > 0 : <NEWLINE> <INDENT> if k - li [ i ] >= K : <NEWLINE> <INDENT> ans += i * li [ i ] <NEWLINE> k -= li [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += i * ( k - K ) <NEWLINE> k -= li [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> if k <= K : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> S = str ( input ( ) ) <NEWLINE> ans = 2 * min ( S . count ( <STRING> ) , S . count ( <STRING> ) ) <NEWLINE> <NL> print ( ans ) <NEWLINE> return <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
<COMMENT> <NL> import time <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> rank = [ 0 for i in range ( N ) ] <NEWLINE> <NL> class Tree : <NEWLINE> <INDENT> def __init__ ( self , par , key ) : <NEWLINE> <INDENT> self . par = par <NEWLINE> self . key = key <NEWLINE> <NL> <DEDENT> <DEDENT> List = [ Tree ( i , i ) for i in range ( N ) ] <NEWLINE> <NL> def unit ( x , y ) : <NEWLINE> <INDENT> while List [ x ] . par != x : <NEWLINE> <INDENT> x = List [ x ] . par <NEWLINE> <DEDENT> a = rank [ x ] <NEWLINE> <NL> while List [ y ] . par != y : <NEWLINE> <INDENT> y = List [ y ] . par <NEWLINE> <DEDENT> b = rank [ y ] <NEWLINE> if a <= b : <NEWLINE> <INDENT> if a == b : <NEWLINE> <INDENT> rank [ x ] += 1 <NEWLINE> <DEDENT> List [ y ] . par = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> List [ x ] . par = y <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def Find ( x , y ) : <NEWLINE> <INDENT> Q = [ ] <NEWLINE> P = [ ] <NEWLINE> while List [ x ] . par != x : <NEWLINE> <INDENT> x = List [ x ] . par <NEWLINE> Q . append ( x ) <NEWLINE> <NL> <DEDENT> while List [ y ] . par != y : <NEWLINE> <INDENT> y = List [ y ] . par <NEWLINE> P . append ( y ) <NEWLINE> <DEDENT> for xi in Q : <NEWLINE> <INDENT> List [ xi ] . par = x <NEWLINE> rank [ xi ] = 1 <NEWLINE> <DEDENT> for yi in P : <NEWLINE> <INDENT> List [ yi ] . par = y <NEWLINE> rank [ yi ] = 1 <NEWLINE> <DEDENT> if x == y : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> com , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if com == 0 : <NEWLINE> <INDENT> unit ( x , y ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> Find ( x , y ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> a . sort ( ) <NEWLINE> ret = 1 <NEWLINE> if k % 2 == 0 or a [ - 1 ] >= 0 : <NEWLINE> <INDENT> l = 0 <NEWLINE> r = - 1 <NEWLINE> mlt1 = a [ 0 ] * a [ 1 ] <NEWLINE> mlt2 = a [ - 2 ] * a [ - 1 ] <NEWLINE> for _ in range ( k // 2 ) : <NEWLINE> <INDENT> if mlt1 >= mlt2 : <NEWLINE> <INDENT> ret *= mlt1 % mod <NEWLINE> l += 2 <NEWLINE> if l <= n - 2 : <NEWLINE> <INDENT> mlt1 = a [ l + 1 ] * a [ l ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ret *= mlt2 % mod <NEWLINE> r -= 2 <NEWLINE> if r >= - n + 1 : <NEWLINE> <INDENT> mlt2 = a [ r - 1 ] * a [ r ] <NEWLINE> <DEDENT> <DEDENT> ret %= mod <NEWLINE> <NL> <DEDENT> if k % 2 == 1 : <NEWLINE> <INDENT> ret *= a [ r ] <NEWLINE> ret %= mod <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> ret *= a [ n - 1 - i ] <NEWLINE> ret %= mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import sys <COMMENT> <NEWLINE> import os <NEWLINE> import time <NEWLINE> import re <NEWLINE> from pydoc import help <NEWLINE> import string <NEWLINE> import math <NEWLINE> from operator import itemgetter <NEWLINE> from collections import Counter <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict as dd <NEWLINE> import fractions <NEWLINE> from heapq import heappop , heappush , heapify <NEWLINE> import array <NEWLINE> from bisect import bisect_left , bisect_right , insort_left , insort_right <NEWLINE> from copy import deepcopy as dcopy <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = 10 ** 20 <NEWLINE> GOSA = 1.0 / 10 ** 10 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> ALPHABETS = [ chr ( i ) for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) ] <COMMENT> <NEWLINE> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def DP ( N , M , first ) : return [ [ first ] * M for n in range ( N ) ] <NEWLINE> def DP3 ( N , M , L , first ) : return [ [ [ first ] * L for n in range ( M ) ] for _ in range ( N ) ] <NEWLINE> from inspect import currentframe <NEWLINE> def dump ( * args ) : <NEWLINE> <INDENT> names = { id ( v ) : k for k , v in currentframe ( ) . f_back . f_locals . items ( ) } <NEWLINE> print ( <STRING> . join ( names . get ( id ( arg ) , <STRING> ) + <STRING> + repr ( arg ) for arg in args ) , file = sys . stderr ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> def local_input ( ) : <COMMENT> <NEWLINE> <INDENT> from pcm . utils import set_stdin <NEWLINE> import sys <NEWLINE> from pathlib import Path <NEWLINE> parentdir = Path ( os . path . dirname ( __file__ ) ) . parent <NEWLINE> inputfile = parentdir . joinpath ( <STRING> ) <NEWLINE> if len ( sys . argv ) == 1 : <NEWLINE> <INDENT> set_stdin ( inputfile ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def cum ( i ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> res += bit [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def add ( i , x ) : <NEWLINE> <INDENT> while i <= N : <NEWLINE> <INDENT> bit [ i ] += x <NEWLINE> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> def pos ( a ) : <NEWLINE> <INDENT> return i <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> global N , A , bit <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bit = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> B = list ( set ( A ) ) <NEWLINE> B . sort ( ) <NEWLINE> B = [ - 1 ] + B <NEWLINE> <NL> res = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> j = bisect_left ( B , A [ i ] ) <NEWLINE> res += cum ( j ) <NEWLINE> add ( j , 1 ) <NEWLINE> <NL> <DEDENT> print ( N * ( N - 1 ) // 2 - res ) <NEWLINE> <NL> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <COMMENT> <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> local_input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> solve ( ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT>
h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> ) if sum ( a ) >= h else print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> n = input ( ) <NEWLINE> list_num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> output = 1 <NEWLINE> if 0 in list_num : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in list_num : <NEWLINE> <INDENT> output = output * i <NEWLINE> if output > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( output ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> def get_ints ( ) : <NEWLINE> <INDENT> return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , k = get_ints ( ) <NEWLINE> a = list ( get_ints ( ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( a ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> s -= a [ i ] <NEWLINE> ans += a [ i ] * s <NEWLINE> <DEDENT> m = 7 + 10 ** 9 <NEWLINE> print ( ans % m ) <NEWLINE>
n , T = map ( int , input ( ) . split ( ) ) <NEWLINE> ct = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> li = [ ] <NEWLINE> for k in ct : <NEWLINE> <INDENT> if k [ 1 ] <= T : <NEWLINE> <INDENT> li += [ k [ 0 ] ] <NEWLINE> <DEDENT> <DEDENT> if li == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( li ) ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> cnts = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> cnts [ a ] += 1 <NEWLINE> cnts [ b ] += 1 <NEWLINE> <DEDENT> if all ( [ c % 2 == 0 for c in cnts ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from math import floor , ceil , sqrt , factorial , log , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from collections import Counter , defaultdict <NEWLINE> from heapq import heappop , heappush , heappushpop , heapify <NEWLINE> import copy <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def lcm ( a , b ) : return a * b / gcd ( a , b ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = LI ( ) <NEWLINE> a = sorted ( list ( LI ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> bc = LIR ( m ) <NEWLINE> bc . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> d = [ ] <NEWLINE> i = 0 <NEWLINE> while len ( d ) < n and i < len ( bc ) : <NEWLINE> <INDENT> if bc [ i ] [ 0 ] + len ( d ) < n : <NEWLINE> <INDENT> d . extend ( [ bc [ i ] [ 1 ] ] * bc [ i ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . extend ( [ bc [ i ] [ 1 ] ] * ( n - len ( d ) ) ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> for i in range ( len ( d ) ) : <NEWLINE> <INDENT> if d [ i ] < a [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a [ i ] = d [ i ] <NEWLINE> <DEDENT> print ( sum ( a ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import re <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = sys . stdin . readlines ( ) <NEWLINE> <COMMENT> <NL> A = [ b . strip ( ) for b in A ] <NEWLINE> <NL> <NL> print ( len ( list ( set ( A ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> t = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( 1 if S [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> res = 1 <NEWLINE> a . sort ( reverse = True ) <NEWLINE> if a [ 0 ] < 0 and k % 2 == 1 : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> res = ( res * a [ i ] ) % mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> right = n - 1 <NEWLINE> left = 0 <NEWLINE> while k > 1 : <NEWLINE> <INDENT> if a [ right ] * a [ right - 1 ] < a [ left ] * a [ left + 1 ] : <NEWLINE> <INDENT> res = ( res * a [ left ] ) % mod <NEWLINE> left += 1 <NEWLINE> k -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = ( res * a [ right ] * a [ right - 1 ] ) % mod <NEWLINE> right -= 2 <NEWLINE> k -= 2 <NEWLINE> <DEDENT> <DEDENT> if k == 1 : <NEWLINE> <INDENT> res = ( res * a [ left ] ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> counter = Counter ( A ) <NEWLINE> <NL> baseline = sum ( k * v for k , v in counter . items ( ) ) <NEWLINE> <COMMENT> <NL> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> n = counter . pop ( b , 0 ) <NEWLINE> baseline += n * ( c - b ) <NEWLINE> counter [ c ] += n <NEWLINE> print ( baseline ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if h != 0 or w != 0 : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> for i in range ( h - 2 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( w - 2 ) + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * w ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> Yes = lambda boolean : print ( <STRING> ) if boolean else print ( <STRING> ) <NEWLINE> YES = lambda boolean : print ( <STRING> ) if boolean else print ( <STRING> ) <NEWLINE> aint = lambda : int ( input ( ) ) <NEWLINE> ints = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> is_even = lambda x : True if x % 2 == 0 else False <NEWLINE> <NL> n = aint ( ) <NEWLINE> get = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> get . append ( s ) <NEWLINE> <DEDENT> ss = set ( get ) <NEWLINE> print ( len ( ss ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> def num2alpha ( num ) : <NEWLINE> <INDENT> if num <= 26 : <NEWLINE> <INDENT> return chr ( 64 + num ) <NEWLINE> <DEDENT> elif num % 26 == 0 : <NEWLINE> <INDENT> return num2alpha ( num // 26 - 1 ) + chr ( 90 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return num2alpha ( num // 26 ) + chr ( 64 + num % 26 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num2alpha ( N ) . lower ( ) ) <NEWLINE>
x = [ ] <NEWLINE> a = 0 <NEWLINE> while True : <NEWLINE> <INDENT> x . append ( int ( input ( ) ) ) <NEWLINE> if x [ a ] == 0 or a == 9999 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a += 1 <NEWLINE> <DEDENT> i = 0 <NEWLINE> for b in x : <NEWLINE> <INDENT> if b == 0 or i == 10000 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> + str ( i + 1 ) + <STRING> + str ( b ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
import math <NEWLINE> from math import gcd , pi , sqrt <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import itertools <NEWLINE> from collections import Counter , deque <NEWLINE> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , x , y = i_map ( ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> <NL> for fr in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for to in range ( fr + 1 , n + 1 ) : <NEWLINE> <INDENT> cost = min ( to - fr , abs ( x - fr ) + abs ( to - y ) + 1 ) <NEWLINE> ans [ cost ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( * ans [ 1 : ] , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> limit = 10 ** 18 <NEWLINE> if ( 0 in l ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for x in l : <NEWLINE> <INDENT> x = int ( x ) <NEWLINE> ans *= x <NEWLINE> <NL> if ( ans > limit ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> from math import gcd <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> c = collections . Counter ( ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g = abs ( gcd ( a , b ) ) <NEWLINE> if g == 0 : <NEWLINE> <INDENT> g = 1 <NEWLINE> <DEDENT> a //= g <NEWLINE> b //= g <NEWLINE> c [ ( a , b ) ] += 1 <NEWLINE> <DEDENT> ans = 1 <NEWLINE> s = set ( ) <NEWLINE> for i , j in c : <NEWLINE> <INDENT> if ( i , j ) == ( 0 , 0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( i , j ) not in s : <NEWLINE> <INDENT> s . add ( ( i , j ) ) <NEWLINE> s . add ( ( - i , - j ) ) <NEWLINE> s . add ( ( - j , i ) ) <NEWLINE> s . add ( ( j , - i ) ) <NEWLINE> ans *= ( pow ( 2 , c [ ( i , j ) ] + c [ ( - i , - j ) ] , mod ) + pow ( 2 , c [ ( j , - i ) ] + c [ ( - j , i ) ] , mod ) - 1 ) % mod <NEWLINE> <DEDENT> <DEDENT> print ( ( ans - 1 + c [ ( 0 , 0 ) ] ) % mod ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for A in itertools . combinations_with_replacement ( range ( 1 , m + 1 ) , n ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for a , b , c , d in li : <NEWLINE> <INDENT> if A [ b - 1 ] - A [ a - 1 ] == c : <NEWLINE> <INDENT> tmp += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ 0 ] * ( Q + 1 ) <NEWLINE> C = [ 0 ] * ( Q + 1 ) <NEWLINE> S = [ 0 ] * ( Q + 1 ) <NEWLINE> <NL> <NL> for i in range ( 1 , Q + 1 , 1 ) : <NEWLINE> <INDENT> B [ i ] , C [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> a = [ 0 ] * ( 10 ** 5 + 3 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a [ A [ i ] ] += 1 <NEWLINE> S [ 0 ] += A [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , Q + 1 , 1 ) : <NEWLINE> <INDENT> S [ i ] = S [ i - 1 ] + a [ B [ i ] ] * ( C [ i ] - B [ i ] ) <NEWLINE> a [ C [ i ] ] = a [ C [ i ] ] + a [ B [ i ] ] <NEWLINE> a [ B [ i ] ] = 0 <NEWLINE> print ( S [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def judge ( A ) : <NEWLINE> <INDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> result = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> result = result * A [ i ] <NEWLINE> if result > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> if result <= 1000000000000000000 : <NEWLINE> <INDENT> print ( result ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> judge ( A ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num = [ 1 ] * 102 <NEWLINE> count = 1 <NEWLINE> <NL> for i in p : <NEWLINE> <INDENT> num [ i ] = 0 <NEWLINE> <DEDENT> if num [ x ] == 1 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if x - count > - 1 : <NEWLINE> <INDENT> if num [ x - count ] == 1 : <NEWLINE> <INDENT> print ( x - count ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if x + count < 103 : <NEWLINE> <INDENT> if num [ x + count ] == 1 : <NEWLINE> <INDENT> print ( x + count ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mi = n % k <NEWLINE> if mi > abs ( mi - k ) : <NEWLINE> <INDENT> print ( abs ( mi - k ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mi ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( a , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> R0 , W0 , C , R = map ( int , input ( ) . split ( ) ) <NEWLINE> if not R0 and not W0 and not C and not R : break <NEWLINE> n = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if W0 > 1 and int ( ( R0 + R * n ) / W0 ) >= C : break <NEWLINE> elif W0 == 1 and ( R0 + R * n ) >= C : break <NEWLINE> n += 1 <NEWLINE> <DEDENT> print ( n ) <NEWLINE> <NL> <NL> <DEDENT>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ input ( ) for _ in range ( n ) ] <NEWLINE> A . sort ( ) <NEWLINE> print ( <STRING> . join ( A ) ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> import math <NEWLINE> import collections <NEWLINE> <COMMENT> <NL> import bisect <NEWLINE> import itertools <NEWLINE> import fractions <NEWLINE> <COMMENT> <NL> import copy <NEWLINE> <COMMENT> <NL> import decimal <NEWLINE> <COMMENT> <NL> import queue <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000001 ) <NEWLINE> INF = 10 ** 16 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> ni = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> n = ni ( ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> q = ni ( ) <NEWLINE> <NL> alphabet_idx = { } <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> alphabet_idx [ i ] = [ ] <NEWLINE> <NL> <DEDENT> for i , si in enumerate ( s ) : <NEWLINE> <INDENT> alphabet_idx [ ord ( si ) - ord ( <STRING> ) ] . append ( i ) <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> qi , a , b = input ( ) . split ( ) <NEWLINE> qi , a = int ( qi ) , int ( a ) <NEWLINE> <NL> if qi == 1 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> if s [ a ] == b : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> current_char = ord ( s [ a ] ) - ord ( <STRING> ) <NEWLINE> del_idx = bisect . bisect_left ( alphabet_idx [ current_char ] , a ) <NEWLINE> del alphabet_idx [ current_char ] [ del_idx ] <NEWLINE> <NL> insert_idx = bisect . bisect_left ( alphabet_idx [ ord ( b ) - ord ( <STRING> ) ] , a ) <NEWLINE> alphabet_idx [ ord ( b ) - ord ( <STRING> ) ] . insert ( insert_idx , a ) <NEWLINE> <NL> s [ a ] = b <NEWLINE> <NL> <DEDENT> if qi == 2 : <NEWLINE> <INDENT> b = int ( b ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 26 ) : <NEWLINE> <INDENT> a_idx = bisect . bisect_left ( alphabet_idx [ i ] , a ) <NEWLINE> if a_idx < len ( alphabet_idx [ i ] ) : <NEWLINE> <INDENT> if alphabet_idx [ i ] [ a_idx ] <= b : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> from math import gcd , pi , sqrt <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import itertools <NEWLINE> from collections import Counter , deque <NEWLINE> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = i_input ( ) <NEWLINE> a = i_list ( ) <NEWLINE> ans = 0 <NEWLINE> k = 0 <NEWLINE> for i in range ( n - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> k += a [ i + 1 ] <NEWLINE> ans += a [ i ] * k <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . replace ( <STRING> , <STRING> ) . split ( ) ) <NEWLINE> <NL> print ( int ( a * b // 100 ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> n -= 2 <NEWLINE> m -= 2 <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if n == 0 or m == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> elif n == - 1 and m == - 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <NL> <DEDENT> elif n == - 1 or m == - 1 : <NEWLINE> <INDENT> ans = max ( n , m ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = n * m <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
x = 1 <NEWLINE> while True : <NEWLINE> <INDENT> y = int ( input ( ) ) <NEWLINE> if y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( x , y ) ) <NEWLINE> x += 1 <NEWLINE> <NL> <DEDENT>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ aa - 1 for aa in a ] <NEWLINE> check = [ 0 for i in range ( n ) ] <NEWLINE> <NL> count = 0 <NEWLINE> point = 0 <NEWLINE> check [ 0 ] = 1 <NEWLINE> path = [ 0 ] <NEWLINE> for i in range ( min ( n , k ) ) : <NEWLINE> <INDENT> if i == 0 or check [ point ] == 0 : <NEWLINE> <INDENT> check [ point ] = i + 1 <NEWLINE> point = a [ point ] <NEWLINE> path . append ( point ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> cycle_len = len ( path ) - check [ point ] <NEWLINE> pre = check [ point ] <NEWLINE> if pre > k : <NEWLINE> <INDENT> print ( path [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= pre <NEWLINE> k %= cycle_len <NEWLINE> print ( path [ pre + k ] + 1 ) <NEWLINE> <DEDENT>
def insertionSort ( A , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> <NL> for i in range ( g , len ( A ) ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> def shellSort ( A ) : <NEWLINE> <INDENT> global cnt <NEWLINE> cnt = 0 <NEWLINE> h = 1 <NEWLINE> g = [ ] <NEWLINE> while h <= len ( A ) : <NEWLINE> <INDENT> g . append ( h ) <NEWLINE> h = 3 * h + 1 <NEWLINE> <DEDENT> g . reverse ( ) <NEWLINE> m = len ( g ) <NEWLINE> print ( m ) <NEWLINE> print ( <STRING> . join ( map ( str , g ) ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> insertionSort ( A , g [ i ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> <NL> shellSort ( A ) <NEWLINE> print ( cnt ) <NEWLINE> for i in A : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT>
N = 50030 <NEWLINE> a = [ True ] * N <NEWLINE> i = 3 <NEWLINE> while i * i < N : <NEWLINE> <INDENT> for j in range ( 3 * i , N , 2 * i ) : a [ j ] = False <NEWLINE> i += 2 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> n0 = n + 2 if ( n & 1 ) else n + 1 <NEWLINE> for maxv in range ( n0 , N , 2 ) : <NEWLINE> <INDENT> if a [ maxv ] : break <NEWLINE> <DEDENT> n0 = n - 2 if ( n & 1 ) else n - 1 <NEWLINE> for minv in range ( n0 , 2 , - 2 ) : <NEWLINE> <INDENT> if a [ minv ] : break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minv = 2 <NEWLINE> <NL> <DEDENT> print ( minv , maxv ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = np . zeros ( n + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> s [ i ] += 1 <NEWLINE> <DEDENT> al = sum ( ( s * ( s - 1 ) ) / 2 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = al - ( s [ a [ i ] ] - 1 ) <NEWLINE> print ( int ( ans ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> inputs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if inputs . count ( 0 ) >= 1 : <NEWLINE> <INDENT> multiple = 0 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> multiple = inputs [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> multiple *= inputs [ i ] <NEWLINE> <NL> <DEDENT> if multiple > 10 ** 18 : <NEWLINE> <INDENT> multiple = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( multiple ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if K <= A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) + [ 0 ] <NEWLINE> data = [ ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> data . append ( abs ( a [ i ] - a [ i + 1 ] ) ) <NEWLINE> <DEDENT> s = sum ( data ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( s - data [ i ] - data [ i + 1 ] + abs ( a [ i ] - a [ i + 2 ] ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> cnt = 0 <NEWLINE> <NL> for k in range ( N ) : <NEWLINE> <INDENT> x = math . sqrt ( A [ k ] ) <NEWLINE> x = ( int ) ( x ) <NEWLINE> for j in range ( 2 , x + 1 ) : <NEWLINE> <INDENT> if A [ k ] % j == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if cnt == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> <NL> <NL> <DEDENT> print ( c ) <NEWLINE>
from bisect import bisect_left <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> <NL> def dfs ( v , p ) : <NEWLINE> <INDENT> i = bisect_left ( dp , a [ v ] ) <NEWLINE> dp [ i ] , old = a [ v ] , dp [ i ] <NEWLINE> ans [ v ] = bisect_left ( dp , INF ) - 1 <NEWLINE> for u in to [ v ] : <NEWLINE> <INDENT> if u == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( u , v ) <NEWLINE> <DEDENT> dp [ i ] = old <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> to = [ [ ] for _ in range ( n ) ] <NEWLINE> ans = [ 0 ] * n <NEWLINE> INF = 10 ** 20 <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> to [ u ] . append ( v ) <NEWLINE> to [ v ] . append ( u ) <NEWLINE> <DEDENT> dp = [ INF ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = - INF <NEWLINE> dfs ( 0 , - 1 ) <NEWLINE> print ( <STRING> . join ( list ( map ( str , ans ) ) ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> arr = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( 0 , N , 2 ) : <NEWLINE> <INDENT> if arr [ i ] % 2 != 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> dic = [ 0 for _ in range ( 10 ** 5 + 1 ) ] <NEWLINE> count = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> dic [ i ] += 1 <NEWLINE> count += i <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> count -= b * dic [ b ] <NEWLINE> dic [ c ] += dic [ b ] <NEWLINE> count += c * dic [ b ] <NEWLINE> dic [ b ] = 0 <NEWLINE> print ( count ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> <NL> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> <DEDENT> g1 = [ 1 , 1 ] <COMMENT> <NEWLINE> g2 = [ 1 , 1 ] <COMMENT> <NEWLINE> inverse = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for k in range ( K + 1 ) : <NEWLINE> <INDENT> ans += ( M * pow ( M - 1 , N - 1 - k , mod ) * cmb ( N - 1 , k , mod ) ) % mod <NEWLINE> ans = ans % mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 1 <NEWLINE> i = 0 <NEWLINE> while a <= 10 ** 18 and i <= n - 1 : <NEWLINE> <INDENT> a = a * lis [ i ] <NEWLINE> i = i + 1 <NEWLINE> <NL> <DEDENT> if 0 in lis : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif a > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> cc = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> cc . append ( a ) <NEWLINE> <DEDENT> aa = set ( cc ) <NEWLINE> print ( len ( aa ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> S = [ ] <NEWLINE> e = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> e += i <NEWLINE> S . append ( e ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] % ( 10 ** 9 + 7 ) * ( ( S [ N - 1 ] - S [ i ] ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> alf = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> order = 0 <NEWLINE> def func ( m ) : <NEWLINE> <INDENT> return int ( 26 * ( 26 ** m - 1 ) / 25 + 0.5 ) <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( 11 , 0 , - 1 ) : <NEWLINE> <INDENT> if n > func ( i ) : <NEWLINE> <INDENT> n = n - func ( i ) <NEWLINE> order = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( order , 0 , - 1 ) : <NEWLINE> <INDENT> if n % 26 ** i == 0 : <NEWLINE> <INDENT> m = n // ( 26 ** i ) - 1 <NEWLINE> n -= m * 26 ** i <NEWLINE> ans += alf [ m ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> m = n // 26 ** i <NEWLINE> n %= 26 ** i <NEWLINE> ans += alf [ m ] <NEWLINE> <DEDENT> <DEDENT> ans += alf [ n - 1 ] <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = [ ] <NEWLINE> <COMMENT> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> prize = input ( ) <NEWLINE> prize_num = 0 <NEWLINE> for i , p in enumerate ( prize [ : : - 1 ] ) : <NEWLINE> <INDENT> prize_num += 26 ** i * ord ( p ) <NEWLINE> <DEDENT> P . append ( prize_num ) <NEWLINE> <NL> <DEDENT> P . sort ( ) <NEWLINE> now = - 1 <NEWLINE> count = 0 <NEWLINE> for p in P : <NEWLINE> <INDENT> if not p == now : <NEWLINE> <INDENT> now = p <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
<COMMENT> <NL> import itertools <NEWLINE> <COMMENT> <NL> q = int ( input ( ) ) <NEWLINE> for a in range ( q ) : <NEWLINE> <INDENT> X = input ( ) <NEWLINE> Y = input ( ) <NEWLINE> cost = [ 0 ] <NEWLINE> for c in Y : <NEWLINE> <INDENT> for i in range ( len ( cost ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> index = X . find ( c , cost [ i ] ) + 1 <NEWLINE> if index : <NEWLINE> <INDENT> if i + 1 < len ( cost ) : <NEWLINE> <INDENT> cost [ i + 1 ] = min ( cost [ i + 1 ] , index ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cost . append ( index ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( cost ) - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> x = int ( input ( ) ) <NEWLINE> h = int ( x / 3600 ) <NEWLINE> m = int ( x % 3600 / 60 ) <NEWLINE> s = int ( x % 60 ) <NEWLINE> print ( <STRING> % ( h , m , s ) ) <NEWLINE>
a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n . find ( <STRING> ) > 0 : break <NEWLINE> a . append ( n ) <NEWLINE> <DEDENT> for s in a : <NEWLINE> <INDENT> t = s . split ( ) <NEWLINE> if t [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( int ( t [ 0 ] ) // int ( t [ 2 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = eval ( <STRING> . join ( t ) ) <NEWLINE> print ( b ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> hcnt = [ 0 ] * w <NEWLINE> wcnt = [ 0 ] * h <NEWLINE> field = { } <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> y , x = map ( int , input ( ) . split ( ) ) <NEWLINE> y -= 1 ; x -= 1 <NEWLINE> wcnt [ y ] += 1 <NEWLINE> hcnt [ x ] += 1 <NEWLINE> row = field . get ( y , { } ) <NEWLINE> row [ x ] = True <NEWLINE> field [ y ] = row <NEWLINE> <DEDENT> def f ( y , x ) : <NEWLINE> <INDENT> return bool ( field . get ( y , { } ) . get ( x ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> hmax = max ( hcnt ) <NEWLINE> wmax = max ( wcnt ) <NEWLINE> ans = hmax + wmax - 1 <NEWLINE> harg = np . argsort ( hcnt ) [ : : - 1 ] <NEWLINE> warg = np . argsort ( wcnt ) [ : : - 1 ] <NEWLINE> for i in harg : <NEWLINE> <INDENT> if hcnt [ i ] != hmax : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in warg : <NEWLINE> <INDENT> if wcnt [ j ] != wmax : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if not f ( j , i ) : <NEWLINE> <INDENT> print ( ans + 1 ) <NEWLINE> __import__ ( <STRING> ) . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> def solve ( n , a ) : <NEWLINE> <INDENT> d = Counter ( a ) <NEWLINE> if len ( d ) == 1 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> d_lst = list ( sorted ( d . keys ( ) ) ) <NEWLINE> first = d_lst [ - 1 ] <NEWLINE> second = d_lst [ - 2 ] <NEWLINE> if d [ first ] != 1 : <NEWLINE> <INDENT> return [ first ] * n <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> return [ second if a [ i ] == first else first for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * solve ( N , a ) , sep = <STRING> ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if X < min ( P ) : <NEWLINE> <INDENT> ans = X <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> elif X in range ( min ( P ) , max ( P ) + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans_len = 200 <COMMENT> <NEWLINE> for i in range ( 250 ) : <NEWLINE> <INDENT> if i in P : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = abs ( X - i ) <NEWLINE> if l < ans_len : <NEWLINE> <INDENT> ans_len = l <NEWLINE> ans = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = X <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> b = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> t = sum ( b ) <NEWLINE> j = m <NEWLINE> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> while j > 0 and t > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> t -= b [ j ] <NEWLINE> <DEDENT> if t > k : break <NEWLINE> ans = max ( ans , i + j ) <NEWLINE> if i == n : break <NEWLINE> t += a [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> for a in A : <NEWLINE> <INDENT> ans [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
A , B , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def function ( a , b , x ) : <NEWLINE> <INDENT> return ( a * x ) // b - a * ( x // b ) <NEWLINE> <DEDENT> print ( max ( [ function ( A , B , N ) , function ( A , B , max ( [ 1 , N - N % B - 1 ] ) ) ] ) ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> all = pow ( 10 , N , MOD ) <NEWLINE> sub9 = pow ( 9 , N , MOD ) <NEWLINE> sub8 = pow ( 8 , N , MOD ) <NEWLINE> print ( ( all - 2 * sub9 + sub8 ) % MOD ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> if ( n % 1000 == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = n // 1000 <NEWLINE> print ( ( a + 1 ) * 1000 - n ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> s , t = 0 , 0 <NEWLINE> for i in x : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s : <NEWLINE> <INDENT> s -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s + t ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> Cost = [ 0 ] * N <NEWLINE> Cost [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> tmp = [ Cost [ k ] + abs ( h [ i ] - h [ k ] ) for k in range ( max ( 0 , i - K ) , i ) ] <NEWLINE> Cost [ i ] = min ( tmp ) <NEWLINE> <NL> <DEDENT> print ( Cost [ - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> R = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> maxv = R [ 1 ] - R [ 0 ] <NEWLINE> minv = R [ 0 ] <NEWLINE> <NL> for j in range ( 1 , n ) : <NEWLINE> <INDENT> maxv = R [ j ] - minv if R [ j ] - minv > maxv else maxv <NEWLINE> minv = R [ j ] if R [ j ] < minv else minv <NEWLINE> <NL> <DEDENT> print ( maxv ) <NEWLINE>
<COMMENT> <NL> <NL> listc = [ 0 ] * 1001 <NEWLINE> cnt = [ 0 ] * 1001 <NEWLINE> n = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> c , d = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> listc [ c ] = 1 <NEWLINE> cnt [ c ] += 1 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> c , d = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if listc [ c ] == 1 : <NEWLINE> <INDENT> listc [ c ] = 2 <NEWLINE> <DEDENT> cnt [ c ] += 1 <NEWLINE> <NL> <DEDENT> for c in range ( 1 , 1001 ) : <NEWLINE> <INDENT> if listc [ c ] == 2 : <NEWLINE> <INDENT> print ( c , cnt [ c ] ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> root_kouho = set ( list ( range ( n ) ) ) <NEWLINE> leaf = set ( list ( range ( n ) ) ) <NEWLINE> ki = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 + m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> root_kouho . discard ( b ) <NEWLINE> leaf . discard ( a ) <NEWLINE> ki [ b ] . append ( a ) <NEWLINE> <DEDENT> root = root_kouho . pop ( ) <NEWLINE> ans = [ - 1 ] * n <NEWLINE> dp = [ - 1 ] * n <COMMENT> <NEWLINE> ans [ root ] = 0 <NEWLINE> dp [ root ] = 0 <NEWLINE> def func ( v ) : <NEWLINE> <INDENT> if dp [ v ] >= 0 : <NEWLINE> <INDENT> return dp [ v ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = - 1 <NEWLINE> for nv in ki [ v ] : <NEWLINE> <INDENT> tmp = func ( nv ) <NEWLINE> if ret < tmp : <NEWLINE> <INDENT> ret = tmp <NEWLINE> ans [ v ] = nv + 1 <NEWLINE> <DEDENT> <DEDENT> dp [ v ] = ret + 1 <NEWLINE> return ret + 1 <NEWLINE> <DEDENT> <DEDENT> while leaf : <NEWLINE> <INDENT> l = leaf . pop ( ) <NEWLINE> func ( l ) <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
from collections import Counter <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) . strip ( ) ) <NEWLINE> A_list = [ int ( i ) for i in input ( ) . strip ( ) . split ( ) ] <NEWLINE> Q = int ( input ( ) . strip ( ) ) <NEWLINE> _sum = sum ( A_list ) <NEWLINE> num_count = Counter ( A_list ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = [ int ( i ) for i in input ( ) . strip ( ) . split ( ) ] <NEWLINE> if B in num_count : <NEWLINE> <INDENT> if C in num_count : <NEWLINE> <INDENT> num_count [ C ] = num_count [ C ] + num_count [ B ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num_count [ C ] = num_count [ B ] <NEWLINE> <NL> <DEDENT> _sum = _sum - ( num_count [ B ] * B ) + num_count [ B ] * C <NEWLINE> del num_count [ B ] <NEWLINE> print ( _sum ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( _sum ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> S_set = list ( set ( S ) ) <NEWLINE> <NL> <NL> <NL> print ( len ( S_set ) ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) + 1 <NEWLINE> cache = [ ] <NEWLINE> <NL> for i in range ( 1 , K ) : <NEWLINE> <INDENT> for j in range ( i , K ) : <NEWLINE> <INDENT> if ( i == j ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cache . append ( gcd ( i , j ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> sum = 0 <NEWLINE> for j in range ( 1 , K ) : <NEWLINE> <INDENT> for i in range ( len ( cache ) ) : <NEWLINE> <INDENT> if ( cache [ i ] == 1 or j == 1 ) : <NEWLINE> <INDENT> sum += 1 * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += gcd ( cache [ i ] , j ) * 2 <NEWLINE> <DEDENT> <DEDENT> for k in range ( 1 , K ) : <NEWLINE> <INDENT> sum += gcd ( j , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import math <NEWLINE> <COMMENT> <NL> K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> cnt = 0 <NEWLINE> <NL> for X in range ( K + 1 ) : <NEWLINE> <INDENT> for Y in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - ( X + Y ) <= K : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> if n % 3 == 1 or n % 3 == 0 : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> and s [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif n % 3 == 2 : <NEWLINE> <INDENT> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> and s [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t = 10 ** 9 + 7 <NEWLINE> z = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> _sum = 0 <NEWLINE> x = sum ( z ) <NEWLINE> y = len ( z ) <NEWLINE> for i in range ( y - 1 ) : <NEWLINE> <INDENT> x = x - z [ i ] <NEWLINE> _sum += ( z [ i ] * x ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( _sum % t ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> f = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> f = f + a [ i ] <NEWLINE> sum += f * a [ i + 1 ] <NEWLINE> <NL> <DEDENT> print ( sum % ( 10 ** 9 + 7 ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> value = [ ] <NEWLINE> weight = [ ] <NEWLINE> num = [ ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> vi , wi , ni = map ( int , input ( ) . split ( ) ) <NEWLINE> value . append ( vi ) <NEWLINE> weight . append ( wi ) <NEWLINE> num . append ( ni ) <NEWLINE> <NL> <DEDENT> def to_digit ( x ) : <NEWLINE> <INDENT> acc = 1 <NEWLINE> ret = [ 0 ] <NEWLINE> while x >= acc : <NEWLINE> <INDENT> ret . append ( acc ) <NEWLINE> x -= acc <NEWLINE> acc *= 2 <NEWLINE> <DEDENT> if x : <NEWLINE> <INDENT> ret . append ( x ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> num = list ( map ( to_digit , num ) ) <NEWLINE> <NL> dp = [ 0 for _ in range ( w + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> vi = value [ i ] <NEWLINE> wi = weight [ i ] <NEWLINE> numsi = num [ i ] <NEWLINE> for k in numsi : <NEWLINE> <INDENT> wik = wi * k <NEWLINE> vik = vi * k <NEWLINE> for j in range ( w , wik - 1 , - 1 ) : <NEWLINE> <INDENT> dp [ j ] = max ( dp [ j ] , dp [ j - wik ] + vik ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ w ] ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( As ) <NEWLINE> bs = [ not A * 4 * M < s for A in As ] <NEWLINE> if bs . count ( True ) >= M : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1000000007 <NEWLINE> print ( ( ( sum ( a ) ** 2 - sum ( map ( lambda x : x ** 2 , a ) ) ) // 2 ) % c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> Y = N // i <NEWLINE> ans += Y * ( Y + 1 ) * i // 2 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = sorted ( d ) <NEWLINE> print ( d [ N // 2 ] - d [ ( N // 2 ) - 1 ] ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def get_sliding_minimum_element ( nums , k ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> queue = [ ] <NEWLINE> for i , v in enumerate ( nums ) : <NEWLINE> <INDENT> if queue and queue [ 0 ] <= i - k : <NEWLINE> <INDENT> queue = queue [ 1 : ] <NEWLINE> <DEDENT> while queue and nums [ queue [ - 1 ] ] > v : <NEWLINE> <INDENT> queue . pop ( ) <NEWLINE> <DEDENT> queue . append ( i ) <NEWLINE> if i + 1 >= k : <NEWLINE> <INDENT> res . append ( nums [ queue [ 0 ] ] ) <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> b = [ 0 for _ in range ( 1000000 ) ] <NEWLINE> deq = [ 0 for _ in range ( 1000000 ) ] <NEWLINE> <NL> line = sys . stdin . readline ( ) <NEWLINE> n , l = map ( int , line . split ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> t = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> while s < t and arr [ deq [ t - 1 ] ] >= arr [ i ] : <NEWLINE> <INDENT> t -= 1 <NEWLINE> <DEDENT> deq [ t ] = i <NEWLINE> t += 1 <NEWLINE> if i - l + 1 >= 0 : <NEWLINE> <INDENT> b [ i - l + 1 ] = arr [ deq [ s ] ] <NEWLINE> if deq [ s ] == i - l + 1 : <NEWLINE> <INDENT> s += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n - l + 1 ) : <NEWLINE> <INDENT> if i == n - l : <NEWLINE> <INDENT> print ( str ( b [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( b [ i ] ) + <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> <NL> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> sum = l [ i ] + l [ j ] <NEWLINE> index = bisect . bisect_left ( l , sum ) <NEWLINE> cnt += index - j - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> result = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> result = result * A [ i ] <NEWLINE> <NL> if result > 10 ** 18 : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> dict = { } <NEWLINE> for a in range ( K ) : <NEWLINE> <INDENT> for b in range ( K ) : <NEWLINE> <INDENT> ab = math . gcd ( a + 1 , b + 1 ) <NEWLINE> if ab in dict : <NEWLINE> <INDENT> dict [ ab ] = dict [ ab ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict [ ab ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for c in range ( K ) : <NEWLINE> <INDENT> for ab in dict : <NEWLINE> <INDENT> sum += math . gcd ( ab , c + 1 ) * dict [ ab ] <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> A . sort ( ) <NEWLINE> for i in A : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if ( k > a ) : <NEWLINE> <INDENT> ans = a <NEWLINE> k = k - a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = k <NEWLINE> k = k - a <NEWLINE> <DEDENT> if ( k > 0 ) : <NEWLINE> <INDENT> k = k - b <NEWLINE> <DEDENT> if ( k > 0 ) : <NEWLINE> <INDENT> ans = ans - k <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def popcount ( n ) : <NEWLINE> <INDENT> bit_count = bin ( n ) . count ( <STRING> ) <NEWLINE> n = n % bit_count <NEWLINE> return n <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> readline = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> X = readline ( ) <NEWLINE> bit_count = X . count ( <STRING> ) <NEWLINE> mod1 = int ( X , 2 ) % ( bit_count + 1 ) <NEWLINE> mod2 = int ( X , 2 ) % ( bit_count - 1 ) if ( bit_count - 1 ) != 0 else 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> X_rest = ( mod1 + pow ( 2 , N - 1 - i , bit_count + 1 ) ) % ( bit_count + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if bit_count - 1 != 0 : <NEWLINE> <INDENT> X_rest = ( mod2 - pow ( 2 , N - 1 - i , bit_count - 1 ) ) % ( bit_count - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT> counter = 1 <NEWLINE> while X_rest != 0 : <NEWLINE> <INDENT> X_rest = popcount ( X_rest ) <NEWLINE> counter += 1 <NEWLINE> <DEDENT> print ( counter ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = [ ( x + 1 ) / 2 for x in p ] <NEWLINE> q1 = sum ( q [ : k ] ) <NEWLINE> ans = q1 <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> x = q1 - q [ i ] + q [ i + k ] <NEWLINE> q1 = x <NEWLINE> if ans < x : <NEWLINE> <INDENT> ans = x <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = defaultdict ( int ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( K , 0 , - 1 ) : <NEWLINE> <INDENT> dd [ i ] = pow ( K // i , N , mod ) <NEWLINE> for temp in range ( i * 2 , K + 1 , i ) : <NEWLINE> <INDENT> dd [ i ] -= dd [ temp ] <NEWLINE> <DEDENT> ans += dd [ i ] * i <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_tmp = sorted ( A , key = abs , reverse = True , ) <NEWLINE> total = 0 <NEWLINE> for i , v in enumerate ( A_tmp ) : <NEWLINE> <INDENT> if ( v <= 0 ) and ( i < len ( A_tmp ) - 1 ) : <NEWLINE> <INDENT> A_tmp [ i ] = ( - 1 ) * A_tmp [ i ] <NEWLINE> A_tmp [ i + 1 ] = ( - 1 ) * A_tmp [ i + 1 ] <NEWLINE> total += A_tmp [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total += v <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) for _ in range ( n ) ) <NEWLINE> s . sort ( ) <NEWLINE> now = s [ 0 ] <NEWLINE> ans = [ s [ 0 ] , ] <NEWLINE> cnt = 0 <NEWLINE> m_cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> word = s [ i ] <NEWLINE> if word == now : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt > m_cnt : <NEWLINE> <INDENT> ans = [ word , ] <NEWLINE> m_cnt = cnt <NEWLINE> <DEDENT> elif cnt == m_cnt : <NEWLINE> <INDENT> ans . append ( word ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> now = word <NEWLINE> if cnt > m_cnt : <NEWLINE> <INDENT> ans = [ word , ] <NEWLINE> m_cnt = cnt <NEWLINE> <DEDENT> elif cnt == m_cnt : <NEWLINE> <INDENT> ans . append ( word ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for k in sorted ( ans ) : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT>
r , g , b , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( n // r + 1 ) : <NEWLINE> <INDENT> for j in range ( n // g + 1 ) : <NEWLINE> <INDENT> nb = ( n - ( i * r + j * g ) ) <NEWLINE> <NL> if ( nb >= 0 ) : <NEWLINE> <INDENT> if ( nb % b == 0 ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n < b : <NEWLINE> <INDENT> print ( ( ( a * n ) // b ) - a * ( n // b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( ( a * ( b - 1 ) ) // b ) - a * ( ( b - 1 ) // b ) ) <NEWLINE> <DEDENT>
x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> X = ( x2 - x1 ) ** 2 <NEWLINE> Y = ( y2 - y1 ) ** 2 <NEWLINE> <NL> distance = ( X + Y ) ** ( 1 / 2 ) <NEWLINE> print ( <STRING> % ( float ( distance ) ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> i = 1 <NEWLINE> for a in sys . stdin : <NEWLINE> <INDENT> if a == <STRING> : break <NEWLINE> print ( <STRING> ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> TNow , ANow = ( int ( T ) for T in input ( ) . split ( ) ) <NEWLINE> for TN in range ( 1 , N ) : <NEWLINE> <INDENT> TNext , ANext = ( int ( T ) for T in input ( ) . split ( ) ) <NEWLINE> Magn = max ( TNow // TNext + ( TNow % TNext != 0 ) , ANow // ANext + ( ANow % ANext != 0 ) ) <NEWLINE> TNow , ANow = TNext * Magn , ANext * Magn <NEWLINE> <DEDENT> print ( TNow + ANow ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> road = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> road . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> except : <NEWLINE> <INDENT> break ; <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> x = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if li [ road [ i ] [ 1 ] - 1 ] >= x [ road [ i ] [ 0 ] - 1 ] : <NEWLINE> <INDENT> x [ road [ i ] [ 0 ] - 1 ] = li [ road [ i ] [ 1 ] - 1 ] <NEWLINE> <DEDENT> if li [ road [ i ] [ 0 ] - 1 ] >= x [ road [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> x [ road [ i ] [ 1 ] - 1 ] = li [ road [ i ] [ 0 ] - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if li [ i ] > x [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> list_a = [ ] <NEWLINE> if len ( S ) - len ( T ) == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ j ] != S [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> list_a . append ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( S ) - len ( T ) ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ j ] != S [ i + j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> list_a . append ( cnt ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( list_a ) ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if i == j == k : <NEWLINE> <INDENT> ans += gcd ( i , j , k ) <NEWLINE> <DEDENT> elif i == j or j == k : <NEWLINE> <INDENT> ans += 3 * gcd ( i , j , k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 6 * gcd ( i , j , k ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> used = [ False ] * n <NEWLINE> ans = 0 <NEWLINE> def dfs ( itr , n , cnt = 0 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> if len ( itr ) == n : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = cnt <NEWLINE> for e in g [ itr [ - 1 ] ] : <NEWLINE> <INDENT> if used [ e ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> used [ e ] = True <NEWLINE> ans += dfs ( itr + [ e ] , n ) <NEWLINE> used [ e ] = False <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> used [ 0 ] = True <NEWLINE> print ( dfs ( [ 0 ] , n , 0 ) ) <NEWLINE>
n , k = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> a = tuple ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> c = [ 0 ] + [ - 1 ] * ( n ) <NEWLINE> l = [ 1 ] <NEWLINE> now = 1 <NEWLINE> dupl = - 1 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> now = a [ now - 1 ] <NEWLINE> c [ now - 1 ] += 1 <NEWLINE> <NL> if c [ now - 1 ] == 1 : <NEWLINE> <INDENT> dupl = now <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( now ) <NEWLINE> <NL> <DEDENT> <DEDENT> if dupl == - 1 : <NEWLINE> <INDENT> print ( now ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> notloop = l . index ( dupl ) <NEWLINE> length = len ( l ) - notloop <NEWLINE> print ( l [ ( k - notloop ) % length + notloop ] ) <NEWLINE>
import sys <NEWLINE> import collections <NEWLINE> s = sys . stdin . readlines ( ) <NEWLINE> n , q = map ( int , s [ 0 ] . split ( ) ) <NEWLINE> d = collections . deque ( e . split ( ) for e in s [ 1 : ] ) <NEWLINE> t = 0 <NEWLINE> while d : <NEWLINE> <INDENT> k , v = d . popleft ( ) <NEWLINE> v = int ( v ) <NEWLINE> if v > q : <NEWLINE> <INDENT> v -= q <NEWLINE> t += q <NEWLINE> d . append ( [ k , v ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t += v <NEWLINE> print ( k , t ) <NEWLINE> <DEDENT> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> while a [ 0 ] > 0 : <NEWLINE> <INDENT> b = a [ 1 ] % a [ 0 ] <NEWLINE> a [ 1 ] = a [ 0 ] <NEWLINE> a [ 0 ] = b <NEWLINE> <NL> <DEDENT> print ( a [ 1 ] ) <NEWLINE>
<NL> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A >= K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( A + B ) >= K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : r += 1 <NEWLINE> elif i == <STRING> : g += 1 <NEWLINE> elif i == <STRING> : b += 1 <NEWLINE> <DEDENT> ans = r * b * g <NEWLINE> <NL> for j in range ( n ) : <NEWLINE> <INDENT> for i in range ( j ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k < n : <NEWLINE> <NL> <INDENT> if s [ i ] == s [ j ] : continue <NEWLINE> if s [ j ] == s [ k ] : continue <NEWLINE> if s [ k ] == s [ i ] : continue <NEWLINE> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> import os <NEWLINE> from operator import mul <NEWLINE> import numpy as np <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def _S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( _S ( ) ) <NEWLINE> def LS ( ) : return list ( _S ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , LS ( ) ) ) <NEWLINE> <NL> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> inputFile = basename_without_ext = os . path . splitext ( os . path . basename ( __file__ ) ) [ 0 ] + <STRING> <NEWLINE> sys . stdin = open ( inputFile , <STRING> ) <NEWLINE> <DEDENT> INF = float ( <STRING> ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> N = I ( ) <NEWLINE> A = LI ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> sum = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum [ i + 1 ] = sum [ i ] + A [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * ( sum [ N ] - sum [ i + 1 ] ) % MOD <NEWLINE> <NL> <NL> <DEDENT> print ( ans % MOD ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = np . int32 ( A ) - 1 <NEWLINE> <NL> nxt = np . zeros ( ( 70 , N ) , dtype = int ) <NEWLINE> nxt [ 0 ] = A <NEWLINE> for i in range ( 0 , 69 ) : <NEWLINE> <INDENT> nxt [ i + 1 ] = nxt [ i , nxt [ i ] ] <NEWLINE> <NL> <DEDENT> pos = 0 <NEWLINE> for i , v in enumerate ( reversed ( bin ( K ) [ 2 : ] ) ) : <NEWLINE> <INDENT> if v == <STRING> : <NEWLINE> <INDENT> pos = nxt [ i , pos ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( pos + 1 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> print ( IsPrime ( N ) ) <NEWLINE> <NL> <DEDENT> def IsPrime ( N ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> inputNum = int ( input ( ) ) <NEWLINE> if ( inputNum == 2 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif ( inputNum % 2 == 0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> flag = 0 <NEWLINE> for j in range ( 3 , int ( pow ( inputNum , 1 / 2 ) ) + 1 ) : <NEWLINE> <INDENT> if ( inputNum % j == 0 ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if ( flag == 0 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def fib ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if F [ n ] > 0 : <NEWLINE> <INDENT> return F [ n ] <NEWLINE> <DEDENT> F [ n ] = fib ( n - 1 ) + fib ( n - 2 ) <NEWLINE> return F [ n ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> F = [ 0 for i in range ( n + 1 ) ] <NEWLINE> print ( fib ( n ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> H = sorted ( H ) <NEWLINE> ans = 10 ** 9 <NEWLINE> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , H [ i + K - 1 ] - H [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from collections import defaultdict , deque <NEWLINE> from heapq import heappush , heappop <NEWLINE> from itertools import permutations , accumulate <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import bisect <NEWLINE> <NL> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> <NL> <NL> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> <NL> def LS ( ) : return [ list ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> <NL> <NL> def S ( ) : <NEWLINE> <INDENT> res = list ( sys . stdin . readline ( ) ) <NEWLINE> if res [ - 1 ] == <STRING> : <NEWLINE> <INDENT> return res [ : - 1 ] <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def IR ( n ) : <NEWLINE> <INDENT> return [ I ( ) for i in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> def LIR ( n ) : <NEWLINE> <INDENT> return [ LI ( ) for i in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> def SR ( n ) : <NEWLINE> <INDENT> return [ S ( ) for i in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> def LSR ( n ) : <NEWLINE> <INDENT> return [ LS ( ) for i in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , X , Y = LI ( ) <NEWLINE> X -= 1 <NEWLINE> Y -= 1 <NEWLINE> dist = [ [ N ] * N for _ in range ( N ) ] <NEWLINE> <NL> q = deque ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> q . append ( i ) <NEWLINE> dist [ i ] [ i ] = 0 <NEWLINE> while q : <NEWLINE> <INDENT> u = q . popleft ( ) <NEWLINE> t = dist [ i ] [ u ] + 1 <NEWLINE> if u < N - 1 : <NEWLINE> <INDENT> if dist [ i ] [ u + 1 ] > t : <NEWLINE> <INDENT> q . append ( u + 1 ) <NEWLINE> dist [ i ] [ u + 1 ] = t <NEWLINE> <DEDENT> <DEDENT> if u >= 1 : <NEWLINE> <INDENT> if dist [ i ] [ u - 1 ] > t : <NEWLINE> <INDENT> q . append ( u - 1 ) <NEWLINE> dist [ i ] [ u - 1 ] = t <NEWLINE> <DEDENT> <DEDENT> if u == X : <NEWLINE> <INDENT> if dist [ i ] [ Y ] > t : <NEWLINE> <INDENT> q . append ( Y ) <NEWLINE> dist [ i ] [ Y ] = t <NEWLINE> <DEDENT> <DEDENT> if u == Y : <NEWLINE> <INDENT> if dist [ i ] [ X ] > t : <NEWLINE> <INDENT> q . append ( X ) <NEWLINE> dist [ i ] [ X ] = t <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> cnt = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> cnt [ dist [ i ] [ j ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in cnt [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
data = input ( ) . split ( ) <NEWLINE> N = int ( data [ 0 ] ) <NEWLINE> M = int ( data [ 1 ] ) <NEWLINE> data_gate = [ input ( ) . split ( ) for i in range ( M ) ] <NEWLINE> data_min = [ ] <NEWLINE> data_max = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> data_min . append ( int ( data_gate [ i ] [ 0 ] ) ) <NEWLINE> data_max . append ( int ( data_gate [ i ] [ 1 ] ) ) <NEWLINE> <DEDENT> m = max ( data_min ) <NEWLINE> M = min ( data_max ) <NEWLINE> if M >= m : <NEWLINE> <INDENT> ans = M - m + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> aminus = [ ] <NEWLINE> aplus = [ ] <NEWLINE> p = 0 <NEWLINE> q = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i >= 0 : <NEWLINE> <INDENT> aplus . append ( i ) <NEWLINE> p += 1 <NEWLINE> <DEDENT> elif i < 0 : <NEWLINE> <INDENT> aminus . append ( i ) <NEWLINE> q += 1 <NEWLINE> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> cou = 0 <NEWLINE> if aplus and aminus : <NEWLINE> <INDENT> now = aminus [ 0 ] <NEWLINE> for i in range ( p - 1 ) : <NEWLINE> <INDENT> ans . append ( ( now , aplus [ i ] ) ) <NEWLINE> now = now - aplus [ i ] <NEWLINE> <DEDENT> aminus [ 0 ] = now <NEWLINE> now = aplus [ p - 1 ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> ans . append ( ( now , aminus [ i ] ) ) <NEWLINE> now = now - aminus [ i ] <NEWLINE> <DEDENT> cou = now <NEWLINE> <DEDENT> elif aplus : <NEWLINE> <INDENT> now = aplus [ 0 ] <NEWLINE> for i in range ( 1 , p - 1 ) : <NEWLINE> <INDENT> ans . append ( ( now , aplus [ i ] ) ) <NEWLINE> now = now - aplus [ i ] <NEWLINE> <DEDENT> ans . append ( ( aplus [ p - 1 ] , now ) ) <NEWLINE> cou = aplus [ p - 1 ] - now <NEWLINE> <DEDENT> elif aminus : <NEWLINE> <INDENT> now = aminus [ q - 1 ] <NEWLINE> for i in range ( q - 1 ) : <NEWLINE> <INDENT> ans . append ( ( now , aminus [ i ] ) ) <NEWLINE> now = now - aminus [ i ] <NEWLINE> <DEDENT> cou = now <NEWLINE> <NL> <DEDENT> print ( cou ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( * ans [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> B = sorted ( A ) <NEWLINE> B = B [ : len ( B ) - 1 ] <NEWLINE> C = [ max ( A ) ] * N <NEWLINE> C [ A . index ( max ( A ) ) ] = max ( B ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> print ( C [ j ] ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> num = [ 0 ] * n <NEWLINE> count = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> num [ i + 1 ] = count <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = num [ r - 1 ] - num [ l - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> b = b // x + 1 <NEWLINE> a = ( a - 1 ) // x + 1 <NEWLINE> print ( b - a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> c = 0 <NEWLINE> if len ( S ) > 2 : <NEWLINE> <INDENT> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> if S [ i - 1 ] == <STRING> and S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> lis = [ ] <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> lis . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> s = set ( lis ) <NEWLINE> print ( len ( s ) ) <NEWLINE>
import bisect <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> dic = { } <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] in dic : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if t [ i ] not in dic : <NEWLINE> <INDENT> dic [ t [ i ] ] = [ ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] in dic : <NEWLINE> <INDENT> dic [ s [ i ] ] . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for k , v in dic . items ( ) : <NEWLINE> <INDENT> if v == [ ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> n = - 1 <NEWLINE> k = 0 <NEWLINE> <NL> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> l = bisect . bisect_right ( dic [ t [ i ] ] , n ) <NEWLINE> if l < len ( dic [ t [ i ] ] ) : <NEWLINE> <INDENT> n = dic [ t [ i ] ] [ l ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = dic [ t [ i ] ] [ 0 ] <NEWLINE> k += 1 <NEWLINE> <DEDENT> <DEDENT> print ( len ( s ) * k + n + 1 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> ans = r * g * b <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> b = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b *= a [ i ] <NEWLINE> if b > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
def sieve ( n ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> prime = [ 0 ] * n <NEWLINE> is_prime = [ 0 ] * ( n + 1 ) <NEWLINE> for i in xrange ( n + 1 ) : <NEWLINE> <INDENT> is_prime [ i ] = True <NEWLINE> <DEDENT> is_prime [ 0 ] = is_prime [ 1 ] = False <NEWLINE> for i in xrange ( 2 , n + 1 ) : <NEWLINE> <INDENT> if is_prime [ i ] : <NEWLINE> <INDENT> p += 1 <NEWLINE> prime [ p ] = i <NEWLINE> for j in xrange ( 2 * i , n + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return p <NEWLINE> <DEDENT> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> print ( sieve ( n ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import copy <NEWLINE> def hashnum ( state ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> num *= 10 <NEWLINE> num += state [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> return num <NEWLINE> <NL> <DEDENT> answer = 123456780 <NEWLINE> ini_state = [ ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> temp = [ int ( n ) for n in input ( ) . split ( <STRING> ) ] <NEWLINE> if 0 in temp : <NEWLINE> <INDENT> zero_x , zero_y = temp . index ( 0 ) , i <NEWLINE> <DEDENT> ini_state . append ( temp ) <NEWLINE> <DEDENT> end_state = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 0 ] ] <NEWLINE> queue = [ [ ini_state , zero_x , zero_y , 0 ] , [ end_state , 2 , 2 , 1 ] ] <NEWLINE> dx = [ 1 , 0 , - 1 , 0 ] <NEWLINE> dy = [ 0 , 1 , 0 , - 1 ] <NEWLINE> visited = { } <NEWLINE> if hashnum ( ini_state ) == answer : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited [ hashnum ( ini_state ) ] = [ 0 , 0 ] <NEWLINE> visited [ answer ] = [ 0 , 1 ] <NEWLINE> trial = 0 <NEWLINE> ended = 0 <NEWLINE> while queue : <NEWLINE> <INDENT> new_queue = [ ] <NEWLINE> trial += 1 <NEWLINE> for q in queue : <NEWLINE> <INDENT> if ended : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> state , zero_x , zero_y , direction = q <NEWLINE> for i in range ( len ( dx ) ) : <NEWLINE> <INDENT> new_state = copy . deepcopy ( state ) <NEWLINE> new_x = zero_x + dx [ i ] <NEWLINE> new_y = zero_y + dy [ i ] <NEWLINE> if 0 <= new_x < 3 and 0 <= new_y < 3 : <NEWLINE> <INDENT> new_state [ new_y ] [ new_x ] , new_state [ zero_y ] [ zero_x ] = new_state [ zero_y ] [ zero_x ] , new_state [ new_y ] [ new_x ] <NEWLINE> perm = hashnum ( new_state ) <NEWLINE> if perm in visited and direction != visited [ perm ] [ 1 ] : <NEWLINE> <INDENT> print ( trial + visited [ perm ] [ 0 ] ) <NEWLINE> ended = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif perm not in visited : <NEWLINE> <INDENT> visited [ perm ] = [ trial , direction ] <NEWLINE> new_queue . append ( [ new_state , new_x , new_y , direction ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> queue = new_queue <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 100 * sys . getrecursionlimit ( ) ) <NEWLINE> V , E = map ( int , input ( ) . split ( ) ) <NEWLINE> G = defaultdict ( list ) <NEWLINE> T = defaultdict ( list ) <NEWLINE> for i in range ( E ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ s ] . append ( t ) <NEWLINE> G [ t ] . append ( s ) <NEWLINE> <NL> <DEDENT> prenum = [ float ( <STRING> ) ] * V <NEWLINE> lowest = [ float ( <STRING> ) ] * V <NEWLINE> parent = [ None ] * V <NEWLINE> visited = [ False ] * V <NEWLINE> <NL> def dfs ( g , s , c = 0 , p = None ) : <NEWLINE> <INDENT> visited [ s ] = True <NEWLINE> prenum [ s ] = c <NEWLINE> lowest [ s ] = c <NEWLINE> c += 1 <NEWLINE> for v in g [ s ] : <NEWLINE> <INDENT> if not visited [ v ] : <NEWLINE> <INDENT> parent [ v ] = s <NEWLINE> T [ v ] . append ( s ) <NEWLINE> T [ s ] . append ( v ) <NEWLINE> dfs ( g , v , c , s ) <NEWLINE> lowest [ s ] = min ( lowest [ s ] , lowest [ v ] ) <NEWLINE> <DEDENT> elif v != p : <NEWLINE> <INDENT> lowest [ s ] = min ( lowest [ s ] , prenum [ v ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( G , 0 ) <NEWLINE> k = [ ] <NEWLINE> if len ( T [ 0 ] ) > 1 : k . append ( 0 ) <NEWLINE> for u in range ( V ) : <NEWLINE> <INDENT> p = parent [ u ] <NEWLINE> if p is None or p == 0 : continue <NEWLINE> if prenum [ p ] <= lowest [ u ] : k . append ( p ) <NEWLINE> <DEDENT> for i in sorted ( set ( k ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( A ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> res = 0 <NEWLINE> m = 1 <NEWLINE> p = [ 0 ] * 2019 <NEWLINE> for i in map ( int , s [ : : - 1 ] ) : <NEWLINE> <INDENT> res += i * m <NEWLINE> res %= 2019 <NEWLINE> p [ res ] += 1 <NEWLINE> m *= 10 <NEWLINE> m %= 2019 <NEWLINE> <DEDENT> print ( p [ 0 ] + sum ( [ i * ( i - 1 ) // 2 for i in p ] ) ) <NEWLINE>
from collections import deque <NEWLINE> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> bomb = [ ] <NEWLINE> counth = [ 0 for _ in range ( H ) ] <NEWLINE> countw = [ 0 for _ in range ( W ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> h -= 1 <NEWLINE> w -= 1 <NEWLINE> bomb . append ( h + w * H ) <NEWLINE> counth [ h ] += 1 <NEWLINE> countw [ w ] += 1 <NEWLINE> <NL> <NL> <DEDENT> maxh = max ( counth ) <NEWLINE> maxw = max ( countw ) <NEWLINE> <NL> counth = deque ( counth ) <NEWLINE> countw = deque ( countw ) <NEWLINE> <NL> index_h = deque ( [ ] ) <NEWLINE> index_w = [ ] <NEWLINE> for k in range ( H ) : <NEWLINE> <INDENT> h = counth . popleft ( ) <NEWLINE> if h == maxh : <NEWLINE> <INDENT> index_h . append ( k ) <NEWLINE> <DEDENT> <DEDENT> lenh = len ( index_h ) <NEWLINE> <NL> for k in range ( W ) : <NEWLINE> <INDENT> w = countw . popleft ( ) <NEWLINE> if w == maxw : <NEWLINE> <INDENT> index_w . append ( k ) <NEWLINE> lenw = len ( index_w ) <NEWLINE> if lenh * lenw > M : <NEWLINE> <INDENT> print ( maxh + maxw ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = maxh + maxw - 1 <NEWLINE> <NL> bomb . sort ( ) <NEWLINE> bomb = deque ( bomb ) <NEWLINE> kouho = [ ] <NEWLINE> for i in range ( lenh ) : <NEWLINE> <INDENT> h = index_h . pop ( ) <NEWLINE> for j in range ( lenw ) : <NEWLINE> <INDENT> w = index_w [ j ] <NEWLINE> kouho . append ( h + H * w ) <NEWLINE> <DEDENT> <DEDENT> kouho . sort ( ) <NEWLINE> kouho = deque ( kouho ) <NEWLINE> B = bomb . popleft ( ) <NEWLINE> K = kouho . popleft ( ) <NEWLINE> while True : <NEWLINE> <INDENT> if B > K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> elif B == K : <NEWLINE> <INDENT> if len ( kouho ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = kouho . popleft ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if len ( bomb ) == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = bomb . popleft ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
x , y , a , b , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> red_list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> green_list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> non_col_list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> red_list . sort ( ) <NEWLINE> green_list . sort ( ) <NEWLINE> non_col_list . sort ( ) <NEWLINE> <NL> eat_red = [ ] <NEWLINE> eat_green = [ ] <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> eat_red . append ( red_list . pop ( ) ) <NEWLINE> <DEDENT> for i in range ( y ) : <NEWLINE> <INDENT> eat_green . append ( green_list . pop ( ) ) <NEWLINE> <NL> <NL> <DEDENT> ans_list = eat_green + eat_red + non_col_list <NEWLINE> ans_list . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( x + y ) : <NEWLINE> <INDENT> ans += ans_list . pop ( ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> def yo ( a , b , th ) : <NEWLINE> <INDENT> thr = math . radians ( th ) <NEWLINE> cosa = math . cos ( thr ) <NEWLINE> tmp = float ( a ** 2 ) + float ( b ** 2 ) - float ( 2 * b * a * cosa ) <NEWLINE> re = float ( math . sqrt ( tmp ) ) <NEWLINE> return re <NEWLINE> <DEDENT> A , B , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> longdig = m * 6 <NEWLINE> shortdig = ( h * 60 + m ) * 0.5 <NEWLINE> theta = abs ( longdig - shortdig ) <NEWLINE> print ( yo ( A , B , theta ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit , i8 <NEWLINE> <NL> <NL> @ njit ( i8 ( i8 , i8 , i8 [ : , : ] ) , cache = True ) <NEWLINE> def solve ( H , N , magics ) : <NEWLINE> <INDENT> dp = np . full ( ( H + 1 ) , 1 << 31 , dtype = np . int64 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A , B = magics [ i ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> dp [ min ( h + A , H ) ] = min ( dp [ min ( h + A , H ) ] , dp [ h ] + B ) <NEWLINE> <DEDENT> <DEDENT> return dp [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> H , N , * AB = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> magics = np . array ( [ ( A , B ) for A , B in zip ( * [ iter ( AB ) ] * 2 ) ] , dtype = np . int64 ) <NEWLINE> print ( solve ( H , N , magics ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> def func ( ) : <NEWLINE> <INDENT> for a in range ( - 10 ** 2 - 200 , 10 ** 2 + 200 ) : <NEWLINE> <INDENT> for b in range ( - 10 ** 2 - 200 , 10 ** 2 + 200 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> k = [ a , b ] <NEWLINE> return k <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> k = func ( ) <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> print ( k [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( i , math . gcd ( j , k ) ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( i , j ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import random <NEWLINE> from decimal import Decimal <NEWLINE> import itertools <NEWLINE> import re <NEWLINE> import bisect <NEWLINE> from collections import deque , Counter <NEWLINE> from functools import lru_cache <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 10 ** 13 <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> def MSRL ( n ) : return [ [ int ( j ) for j in list ( S ( ) ) ] for i in range ( n ) ] <NEWLINE> def SERIES ( n ) : return np . fromstring ( sys . stdin . buffer . read ( ) , dtype = np . int32 , sep = <STRING> ) <NEWLINE> def GRID ( h , w ) : return np . fromstring ( sys . stdin . buffer . read ( ) , dtype = np . int32 , sep = <STRING> ) . reshape ( h , - 1 ) [ : , : w ] <NEWLINE> def GRIDfromString ( h , w ) : return np . frombuffer ( sys . stdin . buffer . read ( ) , <STRING> ) . reshape ( h , - 1 ) [ : , : w ] <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> a_list = LI ( ) <NEWLINE> a_dict = list ( Counter ( a_list ) . items ( ) ) <NEWLINE> a_dict . sort ( ) <NEWLINE> ans = 1 <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( len ( a_dict ) ) : <NEWLINE> <INDENT> diff , number = a_dict [ i ] <NEWLINE> if diff % 2 == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> if diff != 2 * i + 1 or number != 2 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> ans *= 2 <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( a_dict ) ) : <NEWLINE> <INDENT> diff , number = a_dict [ i ] <NEWLINE> if diff % 2 == 1 or ( diff == 0 and number != 1 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> if diff != 2 * i or ( diff > 0 and number != 2 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> if diff != 0 : <NEWLINE> <INDENT> ans *= 2 <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> count = 1 <NEWLINE> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> for n in range ( 2 , 10 ) : <NEWLINE> <INDENT> if i ** n <= x : <NEWLINE> <INDENT> count = max ( i ** n , count ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> from collections import Counter <NEWLINE> x = Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( x [ str ( i ) ] ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> d = defaultdict ( lambda : 0 ) <NEWLINE> Sum = 0 <NEWLINE> for nums in a : <NEWLINE> <INDENT> d [ nums ] += 1 <NEWLINE> <DEDENT> for keys in d : <NEWLINE> <INDENT> cnt = d [ keys ] <NEWLINE> keys = int ( keys ) <NEWLINE> Sum += keys * cnt <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> d [ c ] += d [ b ] <NEWLINE> Sum += ( c - b ) * d [ b ] <NEWLINE> del d [ b ] <NEWLINE> print ( Sum ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> j = 1 <NEWLINE> l = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> S = <STRING> <NEWLINE> while i < N : <NEWLINE> <INDENT> i += 26 ** j <NEWLINE> j += 1 <NEWLINE> <DEDENT> N -= i - 26 ** ( j - 1 ) <NEWLINE> if N == 26 ** ( j - 1 ) : <NEWLINE> <INDENT> print ( <STRING> * ( j - 1 ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in reversed ( range ( j - 1 ) ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> a = N // 26 ** i <NEWLINE> S += l [ a ] <NEWLINE> N -= a * ( 26 ** i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S += l [ N - 1 ] <NEWLINE> <DEDENT> if N == 0 : <NEWLINE> <INDENT> S = S [ : len ( S ) - 1 ] <NEWLINE> S += l [ a - 1 ] <NEWLINE> S += <STRING> * i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( S ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
import sys <NEWLINE> import os <NEWLINE> import itertools <NEWLINE> import numpy as np <NEWLINE> from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) == <STRING> : <NEWLINE> <INDENT> sys . stdin = open ( os . path . dirname ( __file__ ) + <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> A_set = list ( set ( A ) ) <NEWLINE> A_set . sort ( reverse = True ) <NEWLINE> set_p = 0 <NEWLINE> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> arc = { k : 0 for k in A_set } <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> arc [ A_set [ 0 ] ] = arc [ A_set [ 0 ] ] + 1 <NEWLINE> max = A_set [ 0 ] <COMMENT> <NEWLINE> for a in A [ 1 : ] : <NEWLINE> <COMMENT> <NL> <INDENT> arc [ a ] += 2 <NEWLINE> <NL> ans += max <NEWLINE> arc [ max ] -= 1 <NEWLINE> if arc [ max ] == 0 : <NEWLINE> <INDENT> set_p += 1 <NEWLINE> max = A_set [ set_p ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
answermap = [ 0 ] * 51 <NEWLINE> answermap [ 0 ] = 1 <NEWLINE> answermap [ 1 ] = 4 <NEWLINE> answermap [ 2 ] = 10 <NEWLINE> answermap [ 3 ] = 20 <NEWLINE> answermap [ 4 ] = 35 <NEWLINE> answermap [ 5 ] = 56 <NEWLINE> answermap [ 6 ] = 84 <NEWLINE> answermap [ 7 ] = 120 <NEWLINE> answermap [ 8 ] = 165 <NEWLINE> answermap [ 9 ] = 220 <NEWLINE> answermap [ 10 ] = 282 <NEWLINE> answermap [ 11 ] = 348 <NEWLINE> answermap [ 12 ] = 415 <NEWLINE> answermap [ 13 ] = 480 <NEWLINE> answermap [ 14 ] = 540 <NEWLINE> answermap [ 15 ] = 592 <NEWLINE> answermap [ 16 ] = 633 <NEWLINE> answermap [ 17 ] = 660 <NEWLINE> answermap [ 18 ] = 670 <NEWLINE> answermap [ 19 ] = 660 <NEWLINE> answermap [ 20 ] = 633 <NEWLINE> answermap [ 21 ] = 592 <NEWLINE> answermap [ 22 ] = 540 <NEWLINE> answermap [ 23 ] = 480 <NEWLINE> answermap [ 24 ] = 415 <NEWLINE> answermap [ 25 ] = 348 <NEWLINE> answermap [ 26 ] = 282 <NEWLINE> answermap [ 27 ] = 220 <NEWLINE> answermap [ 28 ] = 165 <NEWLINE> answermap [ 29 ] = 120 <NEWLINE> answermap [ 30 ] = 84 <NEWLINE> answermap [ 31 ] = 56 <NEWLINE> answermap [ 32 ] = 35 <NEWLINE> answermap [ 33 ] = 20 <NEWLINE> answermap [ 34 ] = 10 <NEWLINE> answermap [ 35 ] = 4 <NEWLINE> answermap [ 36 ] = 1 <NEWLINE> answermap [ 37 ] = 0 <NEWLINE> answermap [ 38 ] = 0 <NEWLINE> answermap [ 39 ] = 0 <NEWLINE> answermap [ 40 ] = 0 <NEWLINE> answermap [ 41 ] = 0 <NEWLINE> answermap [ 42 ] = 0 <NEWLINE> answermap [ 43 ] = 0 <NEWLINE> answermap [ 44 ] = 0 <NEWLINE> answermap [ 45 ] = 0 <NEWLINE> answermap [ 46 ] = 0 <NEWLINE> answermap [ 47 ] = 0 <NEWLINE> answermap [ 48 ] = 0 <NEWLINE> answermap [ 49 ] = 0 <NEWLINE> answermap [ 50 ] = 0 <NEWLINE> <NL> inputs = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> inputs . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in inputs : <NEWLINE> <INDENT> print ( answermap [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> gcd_equal_i = [ 0 ] * ( K + 1 ) <COMMENT> <NEWLINE> <NL> for D in range ( K , 0 , - 1 ) : <NEWLINE> <INDENT> num_of_mul = K // D <NEWLINE> tmp = pow ( num_of_mul , N , MOD ) <NEWLINE> <NL> i = 2 <NEWLINE> while D * i <= K : <NEWLINE> <INDENT> tmp -= gcd_equal_i [ D * i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> gcd_equal_i [ D ] = tmp <NEWLINE> ans += D * tmp <NEWLINE> ans %= MOD <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( ( input ( ) ) ) <NEWLINE> <NL> if N % 1000 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> N = str ( N ) <NEWLINE> a = len ( N ) <NEWLINE> if a >= 3 : <NEWLINE> <INDENT> x = int ( N [ a - 3 ] + N [ a - 2 ] + N [ a - 1 ] ) <NEWLINE> print ( 1000 - x ) <NEWLINE> <DEDENT> elif a == 2 : <NEWLINE> <INDENT> x = int ( N [ a - 2 ] + N [ a - 1 ] ) <NEWLINE> print ( 1000 - x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = int ( N [ a - 1 ] ) <NEWLINE> print ( 1000 - x ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> from collections import defaultdict <NEWLINE> <NL> readline = sys . stdin . readline <NEWLINE> MOD = 1000000007 <NEWLINE> N = int ( readline ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> d_S = defaultdict ( int ) <NEWLINE> d_T = defaultdict ( int ) <NEWLINE> <NL> def gcd ( x , y ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( y % x , x ) <NEWLINE> <NL> <DEDENT> <DEDENT> pow2_mod = [ 1 ] + [ 0 ] * ( N * 2 ) <NEWLINE> for i in range ( 1 , N * 2 ) : <NEWLINE> <INDENT> pow2_mod [ i ] = pow2_mod [ i - 1 ] * 2 % MOD <NEWLINE> <NL> <DEDENT> zeros = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A , B = map ( int , readline ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if A == 0 and B == 0 : <NEWLINE> <INDENT> zeros += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> elif A == 0 : <NEWLINE> <INDENT> d_S [ ( 1 , 0 ) ] += 0 <NEWLINE> d_T [ ( 0 , - 1 ) ] += 1 <NEWLINE> <DEDENT> elif B == 0 : <NEWLINE> <INDENT> d_S [ ( 1 , 0 ) ] += 1 <NEWLINE> d_T [ ( 0 , - 1 ) ] += 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = gcd ( A , B ) <NEWLINE> A //= g <NEWLINE> B //= g <NEWLINE> <COMMENT> <NL> if A < 0 and B < 0 : <NEWLINE> <INDENT> A *= - 1 <NEWLINE> B *= - 1 <NEWLINE> <DEDENT> if A * B > 0 : <NEWLINE> <INDENT> d_S [ ( A , B ) ] += 1 <NEWLINE> d_T [ ( B , - A ) ] += 0 <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> if A > B : <NEWLINE> <INDENT> A , B = B , A <NEWLINE> <DEDENT> d_S [ ( - A , B ) ] += 0 <NEWLINE> d_T [ ( B , A ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for ( si , sj ) , s_cnt in d_S . items ( ) : <NEWLINE> <INDENT> t_cnt = d_T [ ( sj , - 1 * si ) ] <NEWLINE> tmp = 0 <NEWLINE> tmp += pow2_mod [ s_cnt ] - 1 <COMMENT> <NEWLINE> tmp += pow2_mod [ t_cnt ] - 1 <COMMENT> <NEWLINE> tmp += 1 <COMMENT> <NEWLINE> ans = ( ans * tmp ) % MOD <NEWLINE> <NL> <DEDENT> ans -= 1 <COMMENT> <NEWLINE> ans += zeros <COMMENT> <NEWLINE> <NL> print ( ans % MOD ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> table = [ 0 ] * 26 <NEWLINE> <NL> letters = [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] <NEWLINE> input_str = sys . stdin . read ( ) <NEWLINE> <NL> for A in input_str : <NEWLINE> <INDENT> index = 0 <NEWLINE> for B in letters : <NEWLINE> <INDENT> if A == B or A == B . upper ( ) : <NEWLINE> <INDENT> table [ index ] += 1 <NEWLINE> break <NEWLINE> <DEDENT> index += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( letters ) ) : <NEWLINE> <INDENT> print ( <STRING> % ( letters [ i ] , table [ i ] ) ) <NEWLINE> <NL> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> ans = len ( T ) <NEWLINE> l = len ( T ) <NEWLINE> for m in range ( len ( S ) - l + 1 ) : <NEWLINE> <INDENT> diff = 0 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> if S [ m + i ] != T [ i ] : <NEWLINE> <INDENT> diff += 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , diff ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> amax = 0 <NEWLINE> samax = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if samax + a [ i ] <= k : <NEWLINE> <INDENT> amax += 1 <NEWLINE> samax += a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> book = amax <NEWLINE> ans = book <NEWLINE> samax = sum ( a [ 0 : amax ] ) <NEWLINE> sbmax = 0 <NEWLINE> <NL> for j in range ( m ) : <NEWLINE> <INDENT> sbmax += b [ j ] <NEWLINE> while samax + sbmax > k and amax >= 1 : <NEWLINE> <INDENT> amax -= 1 <NEWLINE> samax = samax - a [ amax ] <NEWLINE> book -= 1 <NEWLINE> <DEDENT> if samax + sbmax <= k : <NEWLINE> <INDENT> book += 1 <NEWLINE> if book > ans : <NEWLINE> <INDENT> ans = book <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from fractions import gcd <NEWLINE> from functools import reduce <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ans = reduce ( lcm , a , 1 ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // gcd ( a , b ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if ( A [ i - k ] < A [ i ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> a = 0 <NEWLINE> b = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> hantei_p = ( X + b ** 5 ) ** 0.2 <NEWLINE> hantei_n = ( X - b ** 5 ) ** 0.2 <NEWLINE> <NL> if abs ( int ( hantei_p ) - hantei_p ) < 1 : <NEWLINE> <INDENT> a = int ( hantei_p ) <NEWLINE> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> print ( <STRING> . format ( a , b ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if isinstance ( hantei_n ** 0.2 , float ) : <NEWLINE> <INDENT> if abs ( int ( hantei_n ) - hantei_n ) < 1 : <NEWLINE> <INDENT> a = int ( hantei_n ) <NEWLINE> if a ** 5 + b ** 5 == X : <NEWLINE> <INDENT> print ( <STRING> . format ( a , - b ) ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> b += 1 <NEWLINE> <NL> <NL> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def g ( x ) : <NEWLINE> <INDENT> return int ( A * x / B ) - A * int ( x / B ) <NEWLINE> <NL> <DEDENT> print ( g ( min ( B - 1 , N ) ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> i += 1 <NEWLINE> s = ( s * 10 + 7 ) % k <NEWLINE> if s % k == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in lst : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> mul = 1 <NEWLINE> for ele in lst : <NEWLINE> <INDENT> mul = mul * ele <NEWLINE> if mul > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mul ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> count = 0 <NEWLINE> count2 = 0 <NEWLINE> <NL> for i in range ( len ( A ) - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if A [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> count = A [ i ] - A [ i + 1 ] <NEWLINE> <COMMENT> <NL> A [ i + 1 ] = A [ i ] <NEWLINE> count2 += count <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count2 ) <NEWLINE>
X , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if X - i not in ( p ) : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if X + i not in ( p ) : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> nump = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nump . sort ( ) <NEWLINE> x_ind = - 1 <NEWLINE> nump_io = [ 0 ] * 103 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> nump_io [ nump [ i ] - 1 ] = 1 <NEWLINE> if ( nump [ i ] == x ) : <NEWLINE> <INDENT> x_ind = i <NEWLINE> <DEDENT> <DEDENT> if ( x_ind == - 1 ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , 51 ) : <NEWLINE> <INDENT> if ( nump_io [ ( x - 1 ) - i ] == 0 ) : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> break <NEWLINE> <DEDENT> if ( nump_io [ ( x - 1 ) + i ] == 0 ) : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> break <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ps = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> maxpro = - 999999999 <NEWLINE> minp = 1000000000 <NEWLINE> for i , p in enumerate ( ps [ : - 1 ] ) : <NEWLINE> <INDENT> if p >= minp : continue <NEWLINE> pro = max ( ps [ i + 1 : ] ) - p <NEWLINE> maxpro = max ( pro , maxpro ) <NEWLINE> minp = p <NEWLINE> <DEDENT> print ( maxpro ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> yosen = 0 <NEWLINE> yosen_b = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and yosen < ( A + B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> yosen += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> and yosen < ( A + B ) and yosen_b <= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> yosen += 1 <NEWLINE> yosen_b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , int ( N ** 0.5 ) ) : <NEWLINE> <INDENT> for j in range ( 1 , int ( N ** 0.5 ) ) : <NEWLINE> <INDENT> for k in range ( 1 , int ( N ** 0.5 ) ) : <NEWLINE> <INDENT> num = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> if num <= N : <NEWLINE> <INDENT> ans [ num ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in ans [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
f = [ 1 , 1 ] <NEWLINE> for _ in range ( 2 , 45 ) : f += [ sum ( f [ - 2 : ] ) ] <NEWLINE> print ( f [ int ( input ( ) ) ] ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab [ a - 1 ] . append ( b - 1 ) <NEWLINE> ab [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> cd = [ set ( [ ] ) for i in range ( n ) ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> cd [ c - 1 ] . add ( d - 1 ) <NEWLINE> cd [ d - 1 ] . add ( c - 1 ) <NEWLINE> <NL> <DEDENT> ans = [ 0 for i in range ( n ) ] <NEWLINE> data = [ 0 for i in range ( n ) ] <COMMENT> <NEWLINE> for i in range ( n ) : <COMMENT> <NEWLINE> <INDENT> if ( data [ i ] != 0 ) : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> data [ i ] = 1 <COMMENT> <NEWLINE> data2 = ab [ i ] + [ i ] <NEWLINE> data2 = set ( data2 ) <NEWLINE> for j in ab [ i ] : <NEWLINE> <INDENT> data [ j ] = 1 <NEWLINE> <DEDENT> new_friends = [ ab [ i ] ] <NEWLINE> for fris in new_friends : <NEWLINE> <INDENT> new = [ ] <COMMENT> <NEWLINE> for fri in fris : <COMMENT> <NEWLINE> <INDENT> for frfr in ab [ fri ] : <COMMENT> <NEWLINE> <INDENT> if ( data [ frfr ] == 0 ) : <COMMENT> <NEWLINE> <INDENT> data [ frfr ] = 1 <NEWLINE> new . append ( frfr ) <COMMENT> <NEWLINE> data2 . add ( frfr ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ( len ( new ) == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> new_friends . append ( new ) <NEWLINE> <NL> <DEDENT> <DEDENT> sam = len ( data2 ) <NEWLINE> for j in data2 : <NEWLINE> <INDENT> count = sam <NEWLINE> ans [ j ] = count - len ( ab [ j ] ) - len ( cd [ j ] & data2 ) - 1 <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = <STRING> <NEWLINE> b = <STRING> <NEWLINE> while n / 26 > 0 : <NEWLINE> <INDENT> b = a [ n % 26 ] + b <NEWLINE> n = ( n - 1 ) // 26 <NEWLINE> <DEDENT> print ( b ) <NEWLINE>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> Q = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> R = [ range ( i , m ) for i in range ( m ) ] <NEWLINE> def dfs ( d , s , l ) : <NEWLINE> <INDENT> global n , m , Q , ans <NEWLINE> if d == n : <NEWLINE> <INDENT> ans_ = 0 <NEWLINE> for k in Q : <NEWLINE> <INDENT> a , b , c , e = k <NEWLINE> if int ( s [ b - 1 ] ) - int ( s [ a - 1 ] ) == c : <NEWLINE> <INDENT> ans_ += e <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , ans_ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in R [ l ] : <NEWLINE> <INDENT> dfs ( d + 1 , s + str ( i ) , i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , <STRING> , 0 ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> check = [ 0 ] * ( n + 10 ) <NEWLINE> res = [ ] <NEWLINE> next = 0 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> if check [ next ] == 0 : <NEWLINE> <INDENT> check [ next ] = 1 <NEWLINE> next = li [ next ] - 1 <NEWLINE> <DEDENT> elif check [ next ] == 1 : <NEWLINE> <INDENT> check [ next ] += 1 <NEWLINE> res . append ( next + 1 ) <NEWLINE> next = li [ next ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = len ( res ) <NEWLINE> k -= check . count ( 1 ) <NEWLINE> amari = k % cnt <NEWLINE> print ( res [ amari ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( next + 1 ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( int ( input ( ) ) for i in range ( N ) ) ) <NEWLINE> c = collections . Counter ( A ) <NEWLINE> count = 0 <NEWLINE> <NL> for v in c . values ( ) : <NEWLINE> <INDENT> if v % 2 != 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( A , min ( B , A + K - 1 ) + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( max ( B - K + 1 , A + K ) , B + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> S = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> calc = gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> S += gcd ( calc , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
alp_count = [ 0 ] * 26 <NEWLINE> <NL> <NL> <NL> string = open ( 0 ) . read ( ) <NEWLINE> string = string . lower ( ) <NEWLINE> <NL> <NL> alp = [ chr ( ord ( <STRING> ) + i ) for i in range ( 26 ) ] <NEWLINE> <NL> c = 0 <NEWLINE> <NL> for j in range ( 26 ) : <NEWLINE> <INDENT> c = string . count ( alp [ j ] ) <NEWLINE> alp_count [ j ] += c <NEWLINE> print ( <STRING> % ( alp [ j ] , alp_count [ j ] ) ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> import sys <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> import functools <NEWLINE> import itertools <NEWLINE> from collections import deque , Counter , defaultdict <NEWLINE> from operator import mul <NEWLINE> import copy <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> import heapq <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <COMMENT> <NL> INF = 10 ** 18 <NEWLINE> import bisect <NEWLINE> import statistics <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> x = np . argsort ( list ( map ( lambda x : - abs ( x ) , A ) ) ) <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> <NL> for xx in x : <NEWLINE> <INDENT> B . append ( A [ xx ] ) <NEWLINE> C . append ( np . sign ( A [ xx ] ) ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> s = 1 <NEWLINE> flag4 = 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> s *= C [ i ] <NEWLINE> <NL> <DEDENT> if s < 0 : <NEWLINE> <INDENT> p = np . sign ( B [ K - 1 ] ) <NEWLINE> flag1 = 0 <NEWLINE> for i in range ( K - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if C [ i ] == p * ( - 1 ) : <NEWLINE> <INDENT> idx1 = i <NEWLINE> flag1 = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> flag2 = 0 <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if C [ i ] == p * ( - 1 ) : <NEWLINE> <INDENT> idx2 = i <NEWLINE> flag2 = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> flag3 = 0 <NEWLINE> if flag1 == 1 : <NEWLINE> <INDENT> for i in range ( K , N ) : <NEWLINE> <INDENT> if C [ i ] == p : <NEWLINE> <INDENT> idx3 = i <NEWLINE> flag3 = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag1 and flag2 and flag3 : <NEWLINE> <INDENT> if abs ( B [ K - 1 ] ) * abs ( B [ idx3 ] ) <= abs ( B [ idx1 ] ) * abs ( B [ idx2 ] ) : <NEWLINE> <INDENT> B [ K - 1 ] = B [ idx2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B [ idx1 ] = B [ idx3 ] <NEWLINE> <DEDENT> <DEDENT> elif flag1 and ( not flag2 ) and flag3 : <NEWLINE> <INDENT> B [ idx1 ] = B [ idx3 ] <NEWLINE> <DEDENT> elif flag1 and flag2 and ( not flag3 ) : <NEWLINE> <INDENT> B [ K - 1 ] = B [ idx2 ] <NEWLINE> <DEDENT> elif ( not flag1 ) and flag2 : <NEWLINE> <INDENT> B [ K - 1 ] = B [ idx2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag4 = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag4 : <NEWLINE> <INDENT> for i in range ( N - 1 , N - K - 1 , - 1 ) : <NEWLINE> <INDENT> ans = ( ans * ( B [ i ] % mod ) ) % mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> ans = ( ans * ( B [ i ] % mod ) ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans % mod ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
<COMMENT> <NL> import sys <NEWLINE> from itertools import accumulate <NEWLINE> MOD = 1000000007 <COMMENT> <NEWLINE> <NL> <NL> def solve ( N : int , A : <STRING> ) : <NEWLINE> <INDENT> aa = list ( accumulate ( A ) ) <NEWLINE> <COMMENT> <NL> x = sum ( A ) <NEWLINE> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans += A [ i ] * ( aa [ N - 1 ] - aa [ i ] ) % MOD <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> return print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> A = [ int ( next ( tokens ) ) for _ in range ( N ) ] <COMMENT> <NEWLINE> solve ( N , A ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> a = np . array ( [ int ( input ( ) ) for i in range ( N ) ] ) <NEWLINE> <NL> <NL> <COMMENT> <NL> def button ( i , n ) : <NEWLINE> <INDENT> n_new = a [ n - 1 ] <NEWLINE> <NL> if i == N : <NEWLINE> <INDENT> if n != 2 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> if n_new == 2 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return button ( i + 1 , n_new ) <NEWLINE> <NL> <DEDENT> <DEDENT> button ( 1 , 1 ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> i = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if K % 7 == 0 : <NEWLINE> <INDENT> K = K // 7 <NEWLINE> <DEDENT> L = 9 * K <NEWLINE> a = 10 % L <NEWLINE> if a == 1 : <NEWLINE> <INDENT> i = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 2 , L + 1 ) : <NEWLINE> <INDENT> a = ( a * 10 ) % L <NEWLINE> if a == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n <= 0 or n >= 101 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> ans = n * n * n <NEWLINE> print ( <STRING> . format ( ans ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> <NL> def show_2d_array ( array ) : <NEWLINE> <INDENT> [ print ( a ) for a in array ] <NEWLINE> <NL> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cave = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> cave [ a - 1 ] . append ( b - 1 ) <NEWLINE> cave [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> def bfs ( tree , p ) : <NEWLINE> <INDENT> seen = [ False ] * len ( tree ) <NEWLINE> queue = deque ( ( p , ) ) <NEWLINE> depth = [ 0 ] * N <NEWLINE> depth [ p ] = 0 <NEWLINE> current_depth = depth [ p ] <NEWLINE> while len ( queue ) > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> q = queue . popleft ( ) <NEWLINE> seen [ q ] = True <NEWLINE> <COMMENT> <NL> for v in tree [ q ] : <NEWLINE> <INDENT> if not seen [ v ] : <NEWLINE> <INDENT> depth [ v ] = depth [ q ] + 1 <NEWLINE> queue . append ( v ) <NEWLINE> seen [ v ] = True <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> return depth <NEWLINE> <NL> <NL> <DEDENT> depth = bfs ( cave , 0 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> sign = [ 0 ] * N <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> this_depth = depth [ i ] <NEWLINE> found = False <NEWLINE> for j in cave [ i ] : <NEWLINE> <INDENT> if depth [ j ] == this_depth - 1 : <NEWLINE> <INDENT> sign [ i ] = j <NEWLINE> found = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not found : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <STRING> <NEWLINE> <NL> print ( ans ) <NEWLINE> if ans == <STRING> : <NEWLINE> <INDENT> [ print ( s + 1 ) for s in sign [ 1 : ] ] <NEWLINE> <NL> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] < a [ k + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> if <STRING> in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cutoff = 10 ** 18 <NEWLINE> res = 1 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> res *= int ( A [ n ] ) <NEWLINE> if res > cutoff : <NEWLINE> <INDENT> res = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
from math import sqrt <NEWLINE> x1 , y1 , x2 , y2 = ( float ( i ) for i in input ( ) . split ( ) ) <NEWLINE> d = sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) <NEWLINE> print ( d ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> boss_list = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> employee_list = [ 0 ] * n <NEWLINE> <NL> for boss in boss_list : <NEWLINE> <INDENT> employee_list [ boss - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for employee in employee_list : <NEWLINE> <INDENT> print ( employee ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> a = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> a = ( a * 10 + 7 ) % k <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
<COMMENT> <NL> import sys , io , os , time <NEWLINE> from collections import defaultdict <NEWLINE> from collections import OrderedDict <NEWLINE> from collections import deque <NEWLINE> from itertools import combinations <NEWLINE> from itertools import permutations <NEWLINE> import bisect , math , heapq <NEWLINE> alphabet = <STRING> <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <COMMENT> <NL> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL>
from collections import Counter <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> while b : a , b = b , a % b <NEWLINE> return abs ( a ) <NEWLINE> <NL> <DEDENT> MOD = 1000000007 <NEWLINE> <NL> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> d [ ( 1 , 0 ) ] = ( 0 , 0 ) <NEWLINE> z = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> g = gcd ( a , b ) <NEWLINE> if g != 0 : <NEWLINE> <INDENT> a = a // g <NEWLINE> b = b // g <NEWLINE> if a * b < 0 : a = - abs ( a ) <NEWLINE> elif a * b > 0 : a = abs ( a ) <NEWLINE> <DEDENT> b = abs ( b ) <NEWLINE> <NL> if a * b == 0 : <NEWLINE> <INDENT> if a == b == 0 : z += 1 <NEWLINE> elif b == 0 : d [ ( 1 , 0 ) ] = ( d [ ( 1 , 0 ) ] [ 0 ] + 1 , d [ ( 1 , 0 ) ] [ 1 ] ) <NEWLINE> elif a == 0 : d [ ( 1 , 0 ) ] = ( d [ ( 1 , 0 ) ] [ 0 ] , d [ ( 1 , 0 ) ] [ 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( a , b ) in d : d [ ( a , b ) ] = ( d [ ( a , b ) ] [ 0 ] + 1 , d [ ( a , b ) ] [ 1 ] ) <NEWLINE> elif ( b , - a ) in d : d [ ( b , - a ) ] = ( d [ ( b , - a ) ] [ 0 ] , d [ ( b , - a ) ] [ 1 ] + 1 ) <NEWLINE> elif ( - b , a ) in d : d [ ( - b , a ) ] = ( d [ ( - b , a ) ] [ 0 ] , d [ ( - b , a ) ] [ 1 ] + 1 ) <NEWLINE> else : d [ ( a , b ) ] = ( 1 , 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for i , j in d . values ( ) : <NEWLINE> <INDENT> ans *= ( pow ( 2 , i , MOD ) + pow ( 2 , j , MOD ) - 1 ) <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ( ans - 1 + z ) % MOD ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> len_s = len ( s ) <NEWLINE> L = [ ] <NEWLINE> m = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( len_s - i + 1 ) : <NEWLINE> <INDENT> if s [ j : j + i ] not in L : <NEWLINE> <INDENT> L . append ( s [ j : j + i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> L . sort ( ) <NEWLINE> print ( L [ k - 1 ] ) <NEWLINE>
def min_diam ( A , B , C ) : <COMMENT> <NEWLINE> <INDENT> segments = [ A , B , C ] <NEWLINE> segments . sort ( ) <NEWLINE> return ( segments [ 0 ] ** 2 + segments [ 1 ] ** 2 ) ** ( 1 / 2 ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <COMMENT> <NL> <INDENT> A , B , C = tuple ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> if ( A , B , C ) == ( 0 , 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> R = [ None ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> R [ i ] = float ( input ( ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> diam = min_diam ( A , B , C ) <NEWLINE> <COMMENT> <NL> for r in R : <NEWLINE> <INDENT> if diam < 2 * r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> c = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> t = [ np . random . randint ( 1 , 27 ) for _ in range ( D ) ] <NEWLINE> <NL> MAX = 0 <NEWLINE> for _ in range ( 1000 ) : <NEWLINE> <INDENT> d = np . random . randint ( 1 , D + 1 ) <NEWLINE> q = np . random . randint ( 1 , 27 ) <NEWLINE> last = np . array ( [ 0 ] * 26 ) <NEWLINE> v = 0 <NEWLINE> for i in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> if i == d : <NEWLINE> <INDENT> v += s [ d - 1 ] [ q - 1 ] <NEWLINE> last [ q - 1 ] = d <NEWLINE> v -= np . dot ( c , d - last ) <NEWLINE> continue <NEWLINE> <DEDENT> v += s [ i - 1 ] [ t [ i - 1 ] - 1 ] <NEWLINE> last [ t [ i - 1 ] - 1 ] = i <NEWLINE> v -= np . dot ( c , i - last ) <NEWLINE> <DEDENT> if v > MAX : <NEWLINE> <INDENT> MAX = v <NEWLINE> t [ d - 1 ] = q <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> print ( t [ i ] ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> mod = 2019 <NEWLINE> dic = [ 0 ] * mod <NEWLINE> dic [ 0 ] += 1 <NEWLINE> <NL> tmp = 0 <NEWLINE> d = 1 <NEWLINE> for i in reversed ( range ( len ( s ) ) ) : <NEWLINE> <INDENT> tmp += int ( s [ i ] ) * d <NEWLINE> tmp %= mod <NEWLINE> d *= 10 <NEWLINE> d %= mod <NEWLINE> dic [ tmp ] += 1 <NEWLINE> <NL> <DEDENT> ans = [ i * ( i - 1 ) / 2 for i in dic ] <NEWLINE> print ( int ( sum ( ans ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = set ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> arr . add ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( arr ) ) <NEWLINE>
import math <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> before = 0 <NEWLINE> now = 1 <NEWLINE> <NL> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> stdin = sys . stdin <NEWLINE> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def nm ( ) : return map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> def nl ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = nm ( ) <NEWLINE> friends = [ set ( ) for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = nm ( ) <NEWLINE> friends [ a - 1 ] . add ( b - 1 ) <NEWLINE> friends [ b - 1 ] . add ( a - 1 ) <NEWLINE> <NL> <DEDENT> groups = [ ] <NEWLINE> in_group = [ False ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if in_group [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> d = deque ( friends [ i ] ) <NEWLINE> group = [ i ] <NEWLINE> in_group [ i ] = True <NEWLINE> while d : <NEWLINE> <INDENT> c = d . pop ( ) <NEWLINE> if in_group [ c ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> group . append ( c ) <NEWLINE> in_group [ c ] = True <NEWLINE> for friend in friends [ c ] : <NEWLINE> <INDENT> if not in_group [ friend ] : <NEWLINE> <INDENT> d . append ( friend ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> groups . append ( group ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for group in groups : <NEWLINE> <INDENT> ans = max ( ans , len ( group ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> limit = 1000000000000000000 <NEWLINE> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> flag = False <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > limit : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) if flag else print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> a = int ( X , 2 ) <NEWLINE> <NL> def popcount ( x ) : <NEWLINE> <INDENT> return bin ( x ) . count ( <STRING> ) <NEWLINE> <DEDENT> p = X . count ( <STRING> ) <NEWLINE> <NL> pl = a % ( p + 1 ) <NEWLINE> if p != 1 : <NEWLINE> <INDENT> mi = a % ( p - 1 ) <NEWLINE> <NL> <DEDENT> def f ( x ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return f ( x % popcount ( x ) ) + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> b = pl <NEWLINE> b += pow ( 2 , N - i - 1 , p + 1 ) <NEWLINE> b %= p + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if p != 1 : <NEWLINE> <INDENT> b = mi <NEWLINE> b -= pow ( 2 , N - i - 1 , p - 1 ) <NEWLINE> b %= p - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> print ( f ( b ) ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> r = [ ] <NEWLINE> for right in range ( 0 , n ) : <NEWLINE> <INDENT> for left in range ( right + 1 , right + k + 1 ) : <NEWLINE> <INDENT> r . append ( s [ right : left ] ) <NEWLINE> <DEDENT> <DEDENT> print ( sorted ( set ( r ) ) [ k - 1 ] ) <NEWLINE>
N , M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> cnt = min ( N , M // 2 ) <NEWLINE> N -= cnt <NEWLINE> M -= cnt * 2 <NEWLINE> <NL> if M > 0 : <NEWLINE> <INDENT> cnt += M // 4 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> A = [ int ( t ) for t in A ] <NEWLINE> <NL> d = 10 ** 9 + 7 <NEWLINE> s = sum ( A ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> s = s - A [ i ] <NEWLINE> ans += A [ i ] * ( s ) <NEWLINE> <NL> <DEDENT> print ( ans % d ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> print ( <STRING> if A [ i + K ] > A [ i ] else <STRING> ) <NEWLINE> <DEDENT>
line = input ( ) <NEWLINE> n , k = map ( int , line . split ( ) ) <NEWLINE> sums = 0 <NEWLINE> while k != ( n + 2 ) : <NEWLINE> <INDENT> if k == 1 : <NEWLINE> <INDENT> mini = 0 <NEWLINE> <DEDENT> if k >= 2 : <NEWLINE> <INDENT> mini = ( ( ( k ) * ( k - 1 ) ) / 2 ) <COMMENT> <NEWLINE> <DEDENT> maxi = ( ( ( ( n + 1 ) * ( n ) ) - ( ( n + 1 - k ) * ( n - k ) ) ) / 2 ) <COMMENT> <NEWLINE> sums += ( maxi - mini + 1 ) <NEWLINE> sums = sums % ( ( 10 ** 9 ) + 7 ) <NEWLINE> k += 1 <NEWLINE> <DEDENT> print ( int ( sums ) ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> ans = 0 <NEWLINE> min = 2e5 + 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if min > p [ i ] : <NEWLINE> <INDENT> min = p [ i ] <NEWLINE> <DEDENT> if p [ i ] <= min : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> start , end = 0 , len ( t ) <NEWLINE> def f ( s , t , start , end ) : <NEWLINE> <INDENT> min_changes = len ( t ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ start : end ] [ i ] != t [ i ] : count += 1 <NEWLINE> <DEDENT> if start + len ( t ) == len ( s ) : return min ( count , min_changes ) <NEWLINE> else : return min ( count , f ( s , t , start + 1 , end + 1 ) ) <NEWLINE> <NL> <DEDENT> print ( f ( s , t , start , end ) ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> B = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> s = 0 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if s + a > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s += a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> for j , b in enumerate ( B ) : <NEWLINE> <INDENT> if s + b > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s += b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j += 1 <NEWLINE> <NL> <DEDENT> ans = i + j <NEWLINE> while i : <NEWLINE> <INDENT> i -= 1 <NEWLINE> s -= A [ i ] <NEWLINE> while j < M and s + B [ j ] <= K : <NEWLINE> <INDENT> s += B [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from collections import deque , Counter <NEWLINE> from heapq import heappop , heappush <NEWLINE> from bisect import bisect_right <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , * A = map ( int , open ( 0 ) ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 0 <NEWLINE> if N % 2 == 1 : <NEWLINE> <INDENT> ans += sum ( A [ N // 2 : ] ) * 2 - sum ( A [ : N // 2 ] ) * 2 <NEWLINE> ans -= A [ N // 2 ] + A [ N // 2 + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += sum ( A [ N // 2 : ] ) * 2 - sum ( A [ : N // 2 ] ) * 2 <NEWLINE> ans -= A [ N // 2 ] - A [ N // 2 - 1 ] <NEWLINE> <NL> <NL> <DEDENT> ans2 = 0 <NEWLINE> if N % 2 == 1 : <NEWLINE> <INDENT> ans2 += sum ( A [ N // 2 + 1 : ] ) * 2 - sum ( A [ : N // 2 + 1 ] ) * 2 <NEWLINE> ans2 += A [ N // 2 ] + A [ N // 2 - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans2 += sum ( A [ N // 2 : ] ) * 2 - sum ( A [ : N // 2 ] ) * 2 <NEWLINE> ans2 += A [ N // 2 - 1 ] - A [ N // 2 ] <NEWLINE> <NL> <DEDENT> print ( max ( ans , ans2 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( q ) ] <NEWLINE> <NL> m = [ 0 ] * n <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> m [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> m [ j ] = k + m [ j ] - q <NEWLINE> <NL> <DEDENT> ans = [ <STRING> ] * n <NEWLINE> <NL> for h in range ( n ) : <NEWLINE> <INDENT> if m [ h ] > 0 : <NEWLINE> <INDENT> ans [ h ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
from collections import deque <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> pathes = [ ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> pathes . append ( ( a , b ) ) <NEWLINE> <DEDENT> childs = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> for a , b in pathes : <NEWLINE> <INDENT> childs [ a ] . append ( b ) <NEWLINE> childs [ b ] . append ( a ) <NEWLINE> <DEDENT> cnt = [ 0 ] * ( N + 1 ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ p ] += x <NEWLINE> <DEDENT> closed = [ False ] * ( N + 1 ) <NEWLINE> nodes = deque ( ) <NEWLINE> nodes . append ( 1 ) <NEWLINE> while len ( nodes ) != 0 : <NEWLINE> <INDENT> node = nodes . popleft ( ) <NEWLINE> closed [ node ] = True <NEWLINE> for c in childs [ node ] : <NEWLINE> <INDENT> if closed [ c ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> nodes . append ( c ) <NEWLINE> cnt [ c ] += cnt [ node ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
<NL> N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> R = [ ] <NEWLINE> G = [ ] <NEWLINE> B = [ ] <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R . append ( i ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> G . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> B = set ( B ) <NEWLINE> b = len ( B ) <NEWLINE> <NL> for i in R : <NEWLINE> <INDENT> for j in G : <NEWLINE> <INDENT> check = 0 <NEWLINE> m = min ( i , j ) <NEWLINE> M = max ( i , j ) <NEWLINE> r = M - m <NEWLINE> left = m - r <NEWLINE> right = M + r <NEWLINE> if r % 2 == 0 : <NEWLINE> <INDENT> center = m + r // 2 <NEWLINE> if center in B : <NEWLINE> <INDENT> check += 1 <NEWLINE> <DEDENT> <DEDENT> if left in B : <NEWLINE> <INDENT> check += 1 <NEWLINE> <DEDENT> if right in B : <NEWLINE> <INDENT> check += 1 <NEWLINE> <DEDENT> cnt += b - check <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = 0 <NEWLINE> if k <= n : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> b = a [ b ] - 1 <NEWLINE> <DEDENT> print ( b + 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> c = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b = a [ b ] - 1 <NEWLINE> c . append ( b ) <NEWLINE> <DEDENT> d = c [ : - 1 ] . index ( c [ - 1 ] ) <NEWLINE> c = c [ d : - 1 ] <NEWLINE> k = k - d <NEWLINE> print ( c [ k % len ( c ) ] + 1 ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> arr = set ( ) <NEWLINE> s = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> arr . add ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( arr ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = input ( ) . split ( ) <NEWLINE> c = [ int ( n ) for n in c ] <NEWLINE> <NL> s = dict . fromkeys ( [ int ( n ) for n in range ( 1 , n + 1 ) ] , 0 ) <NEWLINE> <NL> for i in c : <NEWLINE> <INDENT> s [ i ] = s [ i ] + 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 1 <NEWLINE> flag = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if ( i == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> flag = 2 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( flag == 0 ) : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> sum = sum * i <NEWLINE> if ( sum > 10 ** 18 ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ( flag == 0 ) : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT> elif ( flag == 1 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ns = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in ns : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> s = 1 <NEWLINE> for i in ns : <NEWLINE> <INDENT> s = s * i <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lista = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> n2 = int ( input ( ) ) <NEWLINE> listb = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> cnt = 0 <NEWLINE> <NL> <NL> for i in listb : <NEWLINE> <INDENT> C = int ( len ( lista ) / 2 ) <NEWLINE> D = [ 0 , len ( lista ) ] <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> if i < lista [ C ] : <NEWLINE> <INDENT> for k in D : <NEWLINE> <INDENT> if C > k : <NEWLINE> <INDENT> d = k <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> D . insert ( 0 , C ) <NEWLINE> C = int ( ( C + d ) / 2 ) <NEWLINE> <NL> <DEDENT> elif i > lista [ C ] : <NEWLINE> <INDENT> for k in D : <NEWLINE> <INDENT> if C < k : <NEWLINE> <INDENT> d = k <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> D . insert ( 0 , C ) <NEWLINE> C = int ( ( C + d ) / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> if C == D [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> a = 1 <NEWLINE> ans = 0 <NEWLINE> <NL> while a < N : <NEWLINE> <INDENT> b = a + 1 <NEWLINE> while a * b < N : <NEWLINE> <INDENT> ans += 2 <NEWLINE> b += 1 <NEWLINE> <DEDENT> a += 1 <NEWLINE> <DEDENT> a = 1 <NEWLINE> while a ** 2 < N : <NEWLINE> <INDENT> ans += 1 <NEWLINE> a += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def intlist ( x ) : <NEWLINE> <INDENT> y = [ ] <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> y . append ( int ( x [ i ] ) ) <NEWLINE> <DEDENT> return y <NEWLINE> <NL> <DEDENT> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> price = - 1 <NEWLINE> <NL> L = [ ] <NEWLINE> a = [ ] <NEWLINE> c = [ ] <NEWLINE> suit = [ ] <NEWLINE> for i in range ( M + 1 ) : <NEWLINE> <INDENT> a . append ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> text = input ( ) . split ( ) <NEWLINE> L . append ( intlist ( text ) ) <NEWLINE> <NL> <DEDENT> def buy ( x , y ) : <NEWLINE> <NL> <INDENT> if x + y <= N : <NEWLINE> <NL> <INDENT> for i in range ( 0 , M + 1 ) : <NEWLINE> <NL> <INDENT> a [ i ] += L [ x + y - 1 ] [ i ] <NEWLINE> <NL> <NL> <DEDENT> if x + y == N : <NEWLINE> <INDENT> score = a [ 1 : len ( a ) ] <NEWLINE> <NL> if min ( score ) >= X : <NEWLINE> <INDENT> suit . append ( a . copy ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif x + y != N : <NEWLINE> <INDENT> buy ( x + 1 , y ) <NEWLINE> for i in range ( 0 , M + 1 ) : <NEWLINE> <INDENT> a [ i ] -= L [ x + y ] [ i ] <NEWLINE> <NL> <DEDENT> notbuy ( x , y + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def notbuy ( x , y ) : <NEWLINE> <NL> <INDENT> if x + y <= N : <NEWLINE> <NL> <INDENT> if x + y == N : <NEWLINE> <INDENT> score = a [ 1 : len ( a ) ] <NEWLINE> if min ( score ) >= X : <NEWLINE> <INDENT> suit . append ( a . copy ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> elif x + y != N : <NEWLINE> <INDENT> buy ( x + 1 , y ) <NEWLINE> for i in range ( 0 , M + 1 ) : <NEWLINE> <INDENT> a [ i ] -= L [ x + y ] [ i ] <NEWLINE> <DEDENT> notbuy ( x , y + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def textbook ( x , y ) : <NEWLINE> <INDENT> buy ( x + 1 , y ) <NEWLINE> for i in range ( 0 , M + 1 ) : <NEWLINE> <INDENT> a [ i ] -= L [ x + y ] [ i ] <NEWLINE> <DEDENT> notbuy ( x , y + 1 ) <NEWLINE> <NL> <DEDENT> textbook ( 0 , 0 ) <NEWLINE> <NL> <NL> <NL> <NL> if suit != [ ] : <NEWLINE> <INDENT> if len ( suit ) >= 2 : <NEWLINE> <NL> <INDENT> cheaper = suit [ 0 ] [ 0 ] <NEWLINE> for i in range ( len ( suit ) ) : <NEWLINE> <INDENT> if cheaper > suit [ i ] [ 0 ] : <NEWLINE> <INDENT> cheaper = suit [ i ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT> price = cheaper <NEWLINE> <DEDENT> elif len ( suit ) == 1 : <NEWLINE> <INDENT> price = suit [ 0 ] [ 0 ] <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( price ) <NEWLINE>
from collections import Counter <NEWLINE> import sys <NEWLINE> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> h = [ 0 ] * M <NEWLINE> w = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h [ i ] , w [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> S = Counter ( h ) <NEWLINE> T = Counter ( w ) <NEWLINE> <NL> if ( M == 1 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if ( S . most_common ( ) [ 0 ] [ 1 ] > T . most_common ( ) [ 0 ] [ 1 ] ) : <NEWLINE> <INDENT> smc = S . most_common ( ) [ 0 ] [ 0 ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if ( h [ i ] == smc ) : <NEWLINE> <INDENT> w [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> w1 = [ s for s in w if s != <STRING> ] <NEWLINE> T = Counter ( w1 ) <NEWLINE> if ( len ( w1 ) == 0 ) : <NEWLINE> <INDENT> print ( M ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> tmc = T . most_common ( ) [ 0 ] [ 0 ] <NEWLINE> for i in range ( len ( w1 ) ) : <NEWLINE> <INDENT> if ( w1 [ i ] == tmc ) : <NEWLINE> <INDENT> w1 [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> w2 = [ s for s in w1 if s != <STRING> ] <NEWLINE> print ( M - len ( w2 ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> tmc = T . most_common ( ) [ 0 ] [ 0 ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if ( w [ i ] == tmc ) : <NEWLINE> <INDENT> h [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> h1 = [ s for s in h if s != <STRING> ] <NEWLINE> S = Counter ( h1 ) <NEWLINE> if ( len ( h1 ) == 0 ) : <NEWLINE> <INDENT> print ( M ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> smc = S . most_common ( ) [ 0 ] [ 0 ] <NEWLINE> for i in range ( len ( h1 ) ) : <NEWLINE> <INDENT> if ( h1 [ i ] == smc ) : <NEWLINE> <INDENT> h1 [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> h2 = [ s for s in h1 if s != <STRING> ] <NEWLINE> print ( M - len ( h2 ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> keta = 0 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for x in A : <NEWLINE> <INDENT> ans *= x <NEWLINE> keta += len ( str ( x ) ) <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
max_row , max_col = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> rows = [ [ 0 for i in range ( max_col ) ] for j in range ( max_row ) ] <NEWLINE> row = <STRING> <NEWLINE> <NL> for i in range ( max_row ) : <NEWLINE> <INDENT> row = input ( ) . split ( <STRING> ) <NEWLINE> total_row = 0 <NEWLINE> for j in range ( max_col ) : <NEWLINE> <INDENT> rows [ i ] [ j ] = int ( row [ j ] ) <NEWLINE> total_row = total_row + int ( row [ j ] ) <NEWLINE> <DEDENT> rows [ i ] . append ( total_row ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> total = [ 0 for i in range ( max_col + 1 ) ] <NEWLINE> for m in range ( max_col + 1 ) : <NEWLINE> <INDENT> for n in range ( max_row ) : <NEWLINE> <INDENT> total [ m ] = total [ m ] + rows [ n ] [ m ] <NEWLINE> <DEDENT> <DEDENT> rows . append ( total ) <NEWLINE> <NL> <NL> for i in range ( max_row + 1 ) : <NEWLINE> <INDENT> out_str = <STRING> <NEWLINE> for j in range ( max_col + 1 ) : <NEWLINE> <INDENT> out_str = out_str + <STRING> + str ( rows [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> print ( out_str . strip ( ) ) <NEWLINE> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( h == 0 and w == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for _ in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> bombh = [ ] <NEWLINE> bombw = [ ] <NEWLINE> bomb = [ ] <NEWLINE> w = [ 0 ] * W <NEWLINE> h = [ 0 ] * H <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> hs , ws = map ( int , input ( ) . split ( ) ) <NEWLINE> w [ ws - 1 ] += 1 <NEWLINE> h [ hs - 1 ] += 1 <NEWLINE> bomb . append ( [ hs - 1 , ws - 1 ] ) <NEWLINE> <DEDENT> maxh = max ( h ) <NEWLINE> maxw = max ( w ) <NEWLINE> ans = maxh + maxw <NEWLINE> count = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if ans == h [ bomb [ i ] [ 0 ] ] + w [ bomb [ i ] [ 1 ] ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> a = h . count ( maxh ) * w . count ( maxw ) <NEWLINE> if a == count : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from collections import defaultdict <NEWLINE> I = defaultdict ( int ) <NEWLINE> J = defaultdict ( int ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> I [ A [ i ] + i ] += 1 <NEWLINE> J [ i - A [ i ] ] += 1 <NEWLINE> <DEDENT> for i , j in I . items ( ) : <NEWLINE> <INDENT> ans += J [ i ] * j <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> t = list ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> if i == len ( t ) - 1 : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> elif i == 0 : <NEWLINE> <INDENT> if t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif t [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> elif t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> elif t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> elif t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> t [ i + 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( t ) ) <NEWLINE>
import math <NEWLINE> <NL> <COMMENT> <NL> dict = { 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> , 6 : <STRING> , 7 : <STRING> , 8 : <STRING> , 9 : <STRING> , 10 : <STRING> , <NEWLINE> <INDENT> 11 : <STRING> , 12 : <STRING> , 13 : <STRING> , 14 : <STRING> , 15 : <STRING> , 16 : <STRING> , 17 : <STRING> , 18 : <STRING> , 19 : <STRING> , 20 : <STRING> , <NEWLINE> 21 : <STRING> , 22 : <STRING> , 23 : <STRING> , 24 : <STRING> , 25 : <STRING> , 26 : <STRING> } <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> ans = str ( dict [ ( n - 1 ) % 26 + 1 ] ) <NEWLINE> <NL> n = ( n - 1 ) // 26 <NEWLINE> while n : <NEWLINE> <INDENT> ans = str ( dict [ ( n - 1 ) % 26 + 1 ] ) + ans <NEWLINE> n = ( n - 1 ) // 26 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> magic = [ _ for _ in range ( N ) ] <NEWLINE> <NL> for k in range ( N ) : <NEWLINE> <INDENT> magic [ k ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> magic [ k ] . append ( magic [ k ] [ 0 ] / magic [ k ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> magic . sort ( key = lambda x : x [ 2 ] , reverse = True ) <NEWLINE> ans = [ 0 for _ in range ( H + 1 ) ] <NEWLINE> visited = [ 0 ] <NEWLINE> anskouho = [ float ( <STRING> ) ] <NEWLINE> <NL> def solve ( start , power , point , maryoku ) : <NEWLINE> <INDENT> if start == H : <NEWLINE> <INDENT> print ( min ( point , min ( anskouho ) ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif start > H : <NEWLINE> <INDENT> anskouho . append ( point ) <NEWLINE> visited . sort ( reverse = True ) <NEWLINE> return 0 <NEWLINE> <DEDENT> elif ans [ start ] != 0 : <NEWLINE> <INDENT> visited . sort ( reverse = True ) <NEWLINE> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited . append ( start ) <NEWLINE> ans [ start ] = point <NEWLINE> solve ( start + power , power , point + maryoku , maryoku ) <NEWLINE> <NL> <DEDENT> <DEDENT> for k in range ( N ) : <NEWLINE> <INDENT> for item in visited : <NEWLINE> <INDENT> solve ( item + magic [ k ] [ 0 ] , magic [ k ] [ 0 ] , ans [ item ] + magic [ k ] [ 1 ] , magic [ k ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( anskouho ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from heapq import heappush , heappop , heapify <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return [ LIST ( ) for _ in range ( n ) ] <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> H , W , K = MAP ( ) <NEWLINE> HH = max ( H , W ) + 2 <NEWLINE> x1 , y1 , x2 , y2 = LIST ( ) <NEWLINE> c = [ [ - 1 ] + [ 0 if c == <STRING> else - 1 for c in input ( ) ] + [ - 1 ] <NEWLINE> <INDENT> for i in range ( H ) ] <NEWLINE> <DEDENT> c = [ [ - 1 ] * ( W + 2 ) ] + c + [ [ - 1 ] * ( W + 2 ) ] <NEWLINE> <NL> <COMMENT> <NL> stack = [ ] <NEWLINE> heappush ( stack , ( 0 , x1 , y1 , 0 ) ) <NEWLINE> heappush ( stack , ( 0 , x1 , y1 , 1 ) ) <NEWLINE> heappush ( stack , ( 0 , x1 , y1 , 2 ) ) <NEWLINE> heappush ( stack , ( 0 , x1 , y1 , 3 ) ) <NEWLINE> DX = ( 1 , 0 , - 1 , 0 ) <NEWLINE> DY = ( 0 , 1 , 0 , - 1 ) <NEWLINE> while stack : <NEWLINE> <INDENT> new_stack = [ ] <NEWLINE> while stack : <NEWLINE> <INDENT> curr , x , y , d = heappop ( stack ) <NEWLINE> flag = True <NEWLINE> a = curr + 1 <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> xx , yy = x + k * DX [ d ] , y + k * DY [ d ] <NEWLINE> if c [ xx ] [ yy ] == 0 : <NEWLINE> <INDENT> b = c [ xx + DX [ ( d - 1 ) % 4 ] ] [ yy + DY [ ( d - 1 ) % 4 ] ] <NEWLINE> if b == 0 or b == a + 1 : <NEWLINE> <INDENT> heappush ( new_stack , ( a , xx , yy , ( d - 1 ) % 4 ) ) <NEWLINE> <DEDENT> b = c [ xx + DX [ ( d + 1 ) % 4 ] ] [ yy + DY [ ( d + 1 ) % 4 ] ] <NEWLINE> if b == 0 or b == a + 1 : <NEWLINE> <INDENT> heappush ( new_stack , ( a , xx , yy , ( d + 1 ) % 4 ) ) <NEWLINE> <DEDENT> c [ xx ] [ yy ] = a <NEWLINE> <DEDENT> elif c [ xx ] [ yy ] != a : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> heappush ( new_stack , ( a , xx , yy , d ) ) <NEWLINE> <DEDENT> if c [ x2 ] [ y2 ] > 0 : <NEWLINE> <INDENT> print ( c [ x2 ] [ y2 ] ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> stack = new_stack <NEWLINE> <NL> <DEDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> t = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( S [ i : i + 2 ] == <STRING> ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i in A : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> print ( ans [ j ] ) <NEWLINE> <DEDENT>
str = input ( ) <NEWLINE> length = len ( str ) <NEWLINE> ans = [ <STRING> ] * length <NEWLINE> for x in range ( length ) : <NEWLINE> <INDENT> if str [ length - ( x + 1 ) ] == <STRING> : ans [ length - ( x + 1 ) ] += <STRING> <NEWLINE> elif str [ length - ( x + 1 ) ] == <STRING> : ans [ length - ( x + 1 ) ] += <STRING> <NEWLINE> elif str [ length - ( x + 1 ) ] == <STRING> : <NEWLINE> <INDENT> if x == 0 or x == length - 1 : ans [ length - ( x + 1 ) ] = <STRING> <NEWLINE> elif ans [ length - x ] == <STRING> : ans [ length - ( x + 1 ) ] = <STRING> <NEWLINE> elif ans [ length - x ] == <STRING> and str [ length - ( x + 2 ) ] == <STRING> : ans [ length - ( x + 1 ) ] = <STRING> <NEWLINE> elif ans [ length - x ] == <STRING> and str [ length - ( x + 2 ) ] == <STRING> : ans [ length - ( x + 1 ) ] = <STRING> <NEWLINE> elif ans [ length - x ] == <STRING> and str [ length - ( x + 2 ) ] == <STRING> : ans [ length - ( x + 1 ) ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = ( n - 1 ) // 2 <NEWLINE> l = sorted ( x ) <NEWLINE> for i in x : <NEWLINE> <INDENT> if i > l [ m ] : print ( l [ m ] ) <NEWLINE> else : print ( l [ m + 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> arr = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> arr . sort ( ) <NEWLINE> prod = 1 <NEWLINE> for i in arr : <NEWLINE> <INDENT> prod *= i <NEWLINE> if prod > 10 ** 18 : <NEWLINE> <INDENT> prod = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n < 10 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> a = i <NEWLINE> <DEDENT> <DEDENT> b = n // a <NEWLINE> j = 1 <NEWLINE> while True : <NEWLINE> <INDENT> m = b / ( 10 ** j ) <NEWLINE> if m >= 1 and m < 10 : <NEWLINE> <INDENT> ans = j + 1 <NEWLINE> break <NEWLINE> <DEDENT> j += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
number_list = [ ] <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> number_list . append ( a ) <NEWLINE> <DEDENT> for n in range ( int ( number_list [ 0 ] [ 0 ] ) ) : <NEWLINE> <INDENT> if n != int ( number_list [ 0 ] [ 0 ] ) - 1 : <NEWLINE> <INDENT> print ( <STRING> . format ( number_list [ 1 ] [ int ( number_list [ 0 ] [ 0 ] ) - 1 - n ] ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( number_list [ 1 ] [ int ( number_list [ 0 ] [ 0 ] ) - 1 - n ] ) ) <NEWLINE> <DEDENT> <DEDENT>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = sorted ( l ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> x = bisect . bisect_left ( l , l [ i ] + l [ j ] ) <NEWLINE> cnt += x - j - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] * ( 10 ** 4 + 1 ) <NEWLINE> <NL> for x in range ( 1 , 10 ** 2 ) : <NEWLINE> <INDENT> for y in range ( 1 , 10 ** 2 ) : <NEWLINE> <INDENT> for z in range ( 1 , 10 ** 2 ) : <NEWLINE> <INDENT> n = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if n < 10 ** 4 + 1 : <NEWLINE> <INDENT> ans [ n ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tour = [ 0 ] <NEWLINE> visited = [ 0 ] * n <NEWLINE> visited [ 0 ] = 1 <NEWLINE> next_town = 0 <NEWLINE> flag = False <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> next_town = A [ next_town ] - 1 <NEWLINE> if i + 1 == k : <NEWLINE> <INDENT> flag = True <NEWLINE> ans = next_town <NEWLINE> break <NEWLINE> <DEDENT> if next_town == 0 : <NEWLINE> <INDENT> first_roop_idx = 0 <NEWLINE> break <NEWLINE> <DEDENT> if visited [ next_town ] > 0 : <NEWLINE> <INDENT> first_roop_idx = visited [ next_town ] <NEWLINE> break <NEWLINE> <DEDENT> tour . append ( next_town ) <NEWLINE> visited [ next_town ] = i + 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if not flag : <NEWLINE> <INDENT> if k <= len ( tour ) : <NEWLINE> <INDENT> ans = tour [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= first_roop_idx <NEWLINE> <COMMENT> <NL> if len ( tour ) - first_roop_idx == 0 : <NEWLINE> <INDENT> k = 0 <NEWLINE> <DEDENT> else : k = k % ( len ( tour ) - first_roop_idx ) <NEWLINE> <COMMENT> <NL> ans = tour [ first_roop_idx + k ] <NEWLINE> <DEDENT> <DEDENT> print ( ans + 1 ) <NEWLINE> <COMMENT> <NL>
def main ( ) : <NEWLINE> <INDENT> N , X , M = [ int ( a ) for a in input ( ) . split ( <STRING> ) ] <NEWLINE> used_r = [ 0 ] * M <NEWLINE> r = [ - 1 , X ] <NEWLINE> used_r [ X ] = 1 <NEWLINE> loop_start_elm = - 1 <NEWLINE> loop_start_n_2 = - 1 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A = r [ - 1 ] <NEWLINE> B = ( A * A ) % M <NEWLINE> if used_r [ B ] == 0 : <NEWLINE> <INDENT> r . append ( B ) <NEWLINE> used_r [ B ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop_start_elm = B <NEWLINE> loop_start_n_2 = i + 2 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> loop_start_n = r . index ( B ) <NEWLINE> <NL> s1 = sum ( r [ : loop_start_n ] ) + 1 <NEWLINE> s2 = sum ( r [ loop_start_n : loop_start_n_2 ] ) <NEWLINE> loop_len = loop_start_n_2 - loop_start_n <NEWLINE> loop_n = int ( ( N - loop_start_n + 1 ) / loop_len ) <NEWLINE> rest_n = ( N - loop_start_n + 1 ) % loop_len <NEWLINE> s3 = sum ( r [ loop_start_n : ( loop_start_n + rest_n ) ] ) <NEWLINE> print ( s1 + s2 * loop_n + s3 ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <NL>
<COMMENT> <NL> from math import floor , ceil , sqrt , factorial , log , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from collections import Counter , defaultdict <NEWLINE> from heapq import heappop , heappush , heappushpop , heapify <NEWLINE> import copy <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> from functools import lru_cache <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def lcm ( a , b ) : return a * b / gcd ( a , b ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> <NL> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def dp ( i , j ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> return 0 if j == 0 else - INF <NEWLINE> <DEDENT> if j == 0 : <NEWLINE> <INDENT> return max ( dp ( i - 1 , 0 ) + a [ i - 1 ] , dp ( i - 1 , 1 ) - a [ i - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return max ( dp ( i - 1 , 0 ) - a [ i - 1 ] , dp ( i - 1 , 1 ) + a [ i - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = I ( ) <NEWLINE> a = LI ( ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> print ( dp ( n , 0 ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
T = input ( ) <NEWLINE> res = <STRING> <NEWLINE> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if len ( T ) == 1 : <NEWLINE> <INDENT> res += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> res += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i + 1 < len ( T ) : <NEWLINE> <INDENT> if res [ i - 1 ] == <STRING> or T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> res += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res += <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res += T [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
_ = input ( ) <NEWLINE> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 1 <NEWLINE> m = 10 ** 18 <NEWLINE> <NL> if data . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for d in data : <NEWLINE> <INDENT> p *= d <NEWLINE> if m < p : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> result = 0 <NEWLINE> <NL> for a in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if math . gcd ( a , b ) == 1 : <NEWLINE> <INDENT> result += 1 * N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for c in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> result += math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> c = [ 0 , 0 , 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] not in c : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= c . count ( a [ i ] ) <NEWLINE> ans %= 1000000007 <NEWLINE> c [ c . index ( a [ i ] ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) . split ( <STRING> ) <NEWLINE> N = eval ( a [ 0 ] ) <NEWLINE> K = eval ( a [ 1 ] ) <NEWLINE> dic = { } <NEWLINE> b = input ( ) . split ( <STRING> ) <NEWLINE> n_lst = [ - 1 ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> dic [ i ] = eval ( b [ i - 1 ] ) <NEWLINE> n_lst . append ( - 1 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> lst = [ ] <NEWLINE> length = 0 <NEWLINE> while K > 0 : <NEWLINE> <INDENT> if n_lst [ ans ] != - 1 : <NEWLINE> <INDENT> left = n_lst [ ans ] <NEWLINE> zq = length - left <NEWLINE> K = K % zq <NEWLINE> if K == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> n_lst [ ans ] = length <NEWLINE> length += 1 <NEWLINE> <DEDENT> ans = dic [ ans ] <NEWLINE> K -= 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> B = [ 0 ] * N <NEWLINE> res = 0 <NEWLINE> B [ N - 1 ] = A [ N - 1 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> B [ N - i - 1 ] = B [ N - i ] + A [ N - i - 1 ] <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> res = ( res + A [ i ] * B [ i + 1 ] ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> <NL> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> s = x + pow ( i , 5 ) <NEWLINE> t = pow ( s , 0.2 ) <NEWLINE> if ( t . imag == 0 ) : <NEWLINE> <INDENT> t = int ( t ) <NEWLINE> if ( pow ( t , 5 ) == s ) : <NEWLINE> <INDENT> print ( t , i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> am = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> hole = [ False ] * ( n + 1 ) <NEWLINE> <NL> for i in am : <NEWLINE> <INDENT> hole [ i ] = True <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , min ( n , i + 2 ) + 1 ) : <NEWLINE> <INDENT> if not hole [ j ] : <NEWLINE> <INDENT> dp [ j ] += dp [ i ] <NEWLINE> dp [ j ] %= 1000000007 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE>
<COMMENT> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( a ) - 1 for a in input ( ) . split ( ) ] <NEWLINE> <NL> if K <= N : <NEWLINE> <INDENT> p = 0 <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> p = A [ p ] <NEWLINE> <DEDENT> print ( p + 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> p = 0 <NEWLINE> t = [ - 1 ] * N <NEWLINE> t [ 0 ] = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> p = A [ p ] <NEWLINE> if t [ p ] != - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t [ p ] = i <NEWLINE> <NL> <DEDENT> d = i - t [ p ] <NEWLINE> K -= i <NEWLINE> K %= d <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> p = A [ p ] <NEWLINE> <DEDENT> print ( p + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> i = 1 <NEWLINE> up = 0 <NEWLINE> down = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> if up == down : <NEWLINE> <INDENT> if a [ i ] > a [ i - 1 ] : <NEWLINE> <INDENT> up += 1 <NEWLINE> down = 0 <NEWLINE> <DEDENT> elif a [ i ] < a [ i - 1 ] : <NEWLINE> <INDENT> down += 1 <NEWLINE> up = 0 <NEWLINE> <DEDENT> elif a [ i ] == a [ i - 1 ] : <NEWLINE> <INDENT> up += 1 <NEWLINE> down += 1 <NEWLINE> <DEDENT> <DEDENT> elif up == 0 and down != 0 : <NEWLINE> <INDENT> if a [ i ] <= a [ i - 1 ] : <NEWLINE> <INDENT> down += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> down = 0 <NEWLINE> <DEDENT> <DEDENT> elif down == 0 and up != 0 : <NEWLINE> <INDENT> if a [ i ] >= a [ i - 1 ] : <NEWLINE> <INDENT> up += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> up = 0 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( ans + 1 ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if a >= k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a + b >= k and k > a : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - a - b ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A2 = [ 0 ] * N <NEWLINE> <NL> i = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> A2 [ a - 1 ] = i <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> print ( * A2 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import collections <NEWLINE> num = int ( input ( ) ) <NEWLINE> line = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> clist = collections . Counter ( line ) <NEWLINE> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> print ( clist [ i ] ) <NEWLINE> <DEDENT>
def Recording ( ) : <NEWLINE> <INDENT> n , c = map ( int , input ( ) . split ( ) ) <NEWLINE> num = 2 * 10 ** 5 + 1 <NEWLINE> <NL> <COMMENT> <NL> imos = [ [ 0 ] * num for _ in range ( c ) ] <NEWLINE> <NL> <COMMENT> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> s , t , c0 = map ( int , input ( ) . split ( ) ) <NEWLINE> if imos [ c0 - 1 ] [ s * 2 ] < 0 and imos [ c0 - 1 ] [ t * 2 - 1 ] > 0 : <NEWLINE> <INDENT> imos [ c0 - 1 ] [ s * 2 ] = 0 <NEWLINE> imos [ c0 - 1 ] [ t * 2 - 1 ] = 0 <NEWLINE> <DEDENT> elif imos [ c0 - 1 ] [ s * 2 ] < 0 : <NEWLINE> <INDENT> imos [ c0 - 1 ] [ s * 2 ] = 0 <NEWLINE> imos [ c0 - 1 ] [ t * 2 ] -= 1 <NEWLINE> <DEDENT> elif imos [ c0 - 1 ] [ t * 2 - 1 ] > 0 : <NEWLINE> <INDENT> imos [ c0 - 1 ] [ s * 2 - 1 ] += 1 <NEWLINE> imos [ c0 - 1 ] [ t * 2 - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> imos [ c0 - 1 ] [ s * 2 - 1 ] += 1 <NEWLINE> imos [ c0 - 1 ] [ t * 2 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> ans = [ 0 for _ in range ( num ) ] <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> for j in range ( 1 , num ) : <NEWLINE> <INDENT> imos [ i ] [ j ] += imos [ i ] [ j - 1 ] <NEWLINE> ans [ j ] += imos [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Recording ( ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = max ( a ) <NEWLINE> alist = [ 0 ] * ( m + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> for j in range ( i , m + 1 , i ) : <NEWLINE> <INDENT> alist [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if alist [ i ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmp = [ 0 ] * 100001 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp [ a [ i ] ] += 1 <NEWLINE> ans += a [ i ] <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans -= x * tmp [ x ] <NEWLINE> ans += y * tmp [ x ] <NEWLINE> tmp [ y ] += tmp [ x ] <NEWLINE> tmp [ x ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> S = input ( ) <NEWLINE> <COMMENT> <NL> N = len ( S ) <NEWLINE> <NL> l = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> l [ i ] = ( l [ i + 1 ] + pow ( 10 , N - i , 2019 ) * int ( S [ i ] ) ) % 2019 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> r = sum ( m * ( m - 1 ) // 2 for m in Counter ( l ) . values ( ) ) <NEWLINE> print ( r ) <NEWLINE>
i = [ i for i in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> op = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> stack = [ ] <NEWLINE> <NL> for j in i : <NEWLINE> <INDENT> if j in op : <NEWLINE> <INDENT> r = stack . pop ( ) <NEWLINE> l = stack . pop ( ) <NEWLINE> stack . append ( str ( eval ( l + j + r ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . append ( j ) <NEWLINE> <DEDENT> <DEDENT> print ( stack [ 0 ] ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <NL> n , m = map ( int , readline ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> l = [ 1 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if h [ ab [ i ] [ 0 ] - 1 ] < h [ ab [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> l [ ab [ i ] [ 0 ] - 1 ] = 0 <NEWLINE> <DEDENT> elif h [ ab [ i ] [ 0 ] - 1 ] > h [ ab [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> l [ ab [ i ] [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ ab [ i ] [ 0 ] - 1 ] = 0 <NEWLINE> l [ ab [ i ] [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( l ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> if False : <NEWLINE> <COMMENT> <NL> <INDENT> fh = open ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fh = sys . stdin <NEWLINE> <DEDENT> input = fh . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> pmax = a [ 1 ] - a [ 0 ] <NEWLINE> pmin = a [ 0 ] <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> pmax = max ( a [ j ] - pmin , pmax ) <NEWLINE> pmin = min ( pmin , a [ j ] ) <NEWLINE> <NL> <DEDENT> print ( pmax ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
import itertools as it <NEWLINE> import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> itr = range ( 1 , K + 1 ) <NEWLINE> gcd_ = sum ( [ math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <INDENT> for i , j , k in it . product ( itr , itr , itr ) ] ) <NEWLINE> <DEDENT> print ( gcd_ ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> mysum = sum ( A_list ) <NEWLINE> myans = 0 <NEWLINE> for n in range ( N - 1 ) : <NEWLINE> <INDENT> mysum -= A_list [ n ] <NEWLINE> myans += mysum * A_list [ n ] <NEWLINE> <DEDENT> print ( myans % ( 1000000007 ) ) <NEWLINE>
import math <COMMENT> <NEWLINE> from typing import Dict , List , Optional , Tuple , Union <COMMENT> <NEWLINE> <NL> <NL> def main ( N : int , A : List [ int ] ) : <NEWLINE> <INDENT> A = sorted ( A , reverse = True ) <NEWLINE> if A [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> main ( N , A ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ar = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> z = 0 <NEWLINE> p = 0 <NEWLINE> for i in ar : <NEWLINE> <INDENT> if ans != - 1 : <NEWLINE> <INDENT> ans *= i <NEWLINE> <DEDENT> if i == 0 : <NEWLINE> <INDENT> z += 1 <NEWLINE> <DEDENT> if ans > 1e18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> <DEDENT> if z : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if 1 <= N <= 999 : <NEWLINE> <INDENT> print ( 1000 - N ) <NEWLINE> <DEDENT> elif int ( str ( N ) [ 1 : ] ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - int ( str ( N ) [ 1 : ] ) ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> at = [ 0 ] <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> at . append ( A [ i ] ) <NEWLINE> if i > 0 : <NEWLINE> <INDENT> at [ - 1 ] += at [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> bt = [ 0 ] <NEWLINE> for i in range ( len ( B ) ) : <NEWLINE> <INDENT> bt . append ( B [ i ] ) <NEWLINE> if i > 0 : <NEWLINE> <INDENT> bt [ - 1 ] += bt [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = 0 <NEWLINE> time = 0 <NEWLINE> <NL> <NL> for i , a in enumerate ( at ) : <NEWLINE> <INDENT> if a > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> l = 0 <NEWLINE> r = len ( bt ) - 1 <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> m = ( l + r ) // 2 <NEWLINE> if bt [ m ] < K - a : <NEWLINE> <INDENT> l = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> <DEDENT> if bt [ r ] <= K - a : <NEWLINE> <INDENT> b = bt [ r ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r -= 1 <NEWLINE> b = bt [ r ] <NEWLINE> <DEDENT> if i + r >= n : <NEWLINE> <INDENT> n = i + r <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> for a in A : <NEWLINE> <INDENT> l [ a ] += a <NEWLINE> <DEDENT> suml = sum ( l ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> suml += ( ( l [ b ] // b ) * c - l [ b ] ) <NEWLINE> l [ c ] += ( l [ b ] // b ) * c <NEWLINE> l [ b ] = 0 <NEWLINE> print ( suml ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if min ( a ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans if ans != 0 else - 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> combinations = { } <NEWLINE> <NL> def create_combinations ( idx , sum ) : <NEWLINE> <INDENT> combinations [ sum ] = 1 <NEWLINE> if idx >= N : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> create_combinations ( idx + 1 , sum ) <NEWLINE> create_combinations ( idx + 1 , sum + A [ idx ] ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> create_combinations ( 0 , 0 ) <NEWLINE> <NL> for target in M : <NEWLINE> <INDENT> if target in combinations . keys ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> line = <STRING> * W <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> print ( line ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> s += math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> f = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] == h [ b - 1 ] : <NEWLINE> <INDENT> f [ a - 1 ] = 1 <NEWLINE> f [ b - 1 ] = 1 <NEWLINE> <DEDENT> elif h [ a - 1 ] > h [ b - 1 ] : <NEWLINE> <INDENT> f [ b - 1 ] = 1 <NEWLINE> <DEDENT> elif h [ a - 1 ] < h [ b - 1 ] : <NEWLINE> <INDENT> f [ a - 1 ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if f [ i ] <= 0 : <NEWLINE> <COMMENT> <NL> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> num_a = [ 0 ] * 100001 <NEWLINE> num_b = [ ] <NEWLINE> sum_a = sum ( a ) <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> num_a [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> b1 , c1 = map ( int , input ( ) . split ( ) ) <NEWLINE> b . append ( b1 ) <NEWLINE> c . append ( c1 ) <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> if num_a [ b [ i ] ] == 0 : <NEWLINE> <INDENT> num_b . append ( 0 ) <NEWLINE> sum_a = sum_a - b [ i ] * num_b [ i ] + c [ i ] * num_b [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num_b . append ( num_a [ b [ i ] ] ) <NEWLINE> num_a [ c [ i ] ] += num_a [ b [ i ] ] <NEWLINE> num_a [ b [ i ] ] = 0 <NEWLINE> sum_a = sum_a - b [ i ] * num_b [ i ] + c [ i ] * num_b [ i ] <NEWLINE> <DEDENT> print ( sum_a ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A = 7 % K <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if A % K == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> A = ( 10 * A + 7 ) % K <NEWLINE> <DEDENT> print ( - 1 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> mod = 2019 <NEWLINE> count = [ 0 ] * 2019 <NEWLINE> count [ 0 ] = 1 <NEWLINE> s = input ( ) . strip ( ) <NEWLINE> digit = 1 <NEWLINE> current = 0 <NEWLINE> for c in s [ : : - 1 ] : <NEWLINE> <INDENT> current = ( current + int ( c ) * digit ) % mod <NEWLINE> count [ current ] += 1 <NEWLINE> digit = digit * 10 % mod <NEWLINE> <DEDENT> return sum ( [ n * ( n - 1 ) // 2 for n in count if n > 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
from collections import deque <NEWLINE> S = deque ( input ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> Q = [ list ( map ( str , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> flg = True <NEWLINE> for q in Q : <NEWLINE> <INDENT> if q [ 0 ] == <STRING> : <NEWLINE> <INDENT> flg = not flg <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> F = int ( q [ 1 ] ) <NEWLINE> if not flg : <NEWLINE> <INDENT> F = 3 - F <NEWLINE> <DEDENT> if F == 1 : <NEWLINE> <INDENT> S . appendleft ( q [ 2 ] ) <NEWLINE> <DEDENT> if F == 2 : <NEWLINE> <INDENT> S . append ( q [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if not flg : <NEWLINE> <INDENT> S . reverse ( ) <NEWLINE> <DEDENT> print ( <STRING> . join ( S ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> if b == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 20 ) : <NEWLINE> <INDENT> if b <= a + ( a - 1 ) * i : <NEWLINE> <INDENT> ans . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> k = input ( ) . split ( ) <NEWLINE> H = int ( k [ 0 ] ) <NEWLINE> W = int ( k [ 1 ] ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> msg = <STRING> <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> msg += <STRING> <NEWLINE> <DEDENT> print ( msg ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> sum_min = 0 <NEWLINE> sum_max = 0 <NEWLINE> diff = 0 <NEWLINE> while K != N + 2 : <NEWLINE> <INDENT> sum_min = 1 / 2 * K * ( K - 1 ) <NEWLINE> sum_max = 1 / 2 * K * ( 2 * N - K + 1 ) <NEWLINE> diff += sum_max - sum_min + 1 <NEWLINE> K += 1 <NEWLINE> <DEDENT> diff = diff % mod <NEWLINE> print ( int ( diff ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> new = [ ] <NEWLINE> s = set ( ) <NEWLINE> d = { } <NEWLINE> for i in range ( 0 , len ( l ) ) : <NEWLINE> <INDENT> new . append ( i + 1 - l [ i ] ) <NEWLINE> s . add ( i + 1 + l [ i ] ) <NEWLINE> if i + 1 + l [ i ] in d . keys ( ) : <NEWLINE> <INDENT> d [ i + 1 + l [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i + 1 + l [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 0 , len ( new ) ) : <NEWLINE> <INDENT> if new [ i ] in s : <NEWLINE> <INDENT> count += d [ new [ i ] ] <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> si = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> [ n , k ] = [ int ( e ) for e in si ( ) . split ( ) ] <NEWLINE> trace = dict ( ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> trace [ i ] = 0 <NEWLINE> <NL> <DEDENT> l = [ int ( e ) for e in si ( ) . split ( ) ] <NEWLINE> i , cnt = 1 , 0 <NEWLINE> while k > 0 : <NEWLINE> <INDENT> k -= 1 <NEWLINE> cnt += 1 <NEWLINE> i = l [ i - 1 ] <NEWLINE> if i == 1 or trace [ i ] != 0 : <NEWLINE> <INDENT> cy = cnt - trace [ i ] <NEWLINE> k %= cy <NEWLINE> break <NEWLINE> <DEDENT> trace [ i ] = cnt <NEWLINE> <DEDENT> while k > 0 : <NEWLINE> <INDENT> i = l [ i - 1 ] <NEWLINE> k -= 1 <NEWLINE> <DEDENT> print ( i ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
dice = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dice2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mask = { <NEWLINE> <INDENT> <STRING> : ( 1 , 5 , 2 , 3 , 0 , 4 ) , <NEWLINE> <STRING> : ( 0 , 2 , 4 , 1 , 3 , 5 ) <NEWLINE> } <NEWLINE> <NL> <DEDENT> a , b = dice2 [ 0 ] , dice2 [ 1 ] <NEWLINE> <NL> find = False <NEWLINE> <NL> for i in range ( 4 ) : <NEWLINE> <NL> <INDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> if dice == dice2 : <NEWLINE> <INDENT> find = True <NEWLINE> break <NEWLINE> <DEDENT> dice = [ dice [ x ] for x in mask [ <STRING> ] ] <NEWLINE> <NL> <DEDENT> if dice == dice2 : <NEWLINE> <INDENT> find = True <NEWLINE> break <NEWLINE> <DEDENT> dice = [ dice [ x ] for x in mask [ <STRING> ] ] <NEWLINE> <NL> <DEDENT> dice = [ dice [ x ] for x in mask [ <STRING> ] ] <NEWLINE> dice = [ dice [ x ] for x in mask [ <STRING> ] ] <NEWLINE> for j in range ( 4 ) : <NEWLINE> <INDENT> if dice == dice2 : <NEWLINE> <INDENT> find = True <NEWLINE> break <NEWLINE> <DEDENT> dice = [ dice [ x ] for x in mask [ <STRING> ] ] <NEWLINE> <NL> <DEDENT> dice = [ dice [ x ] for x in mask [ <STRING> ] ] <NEWLINE> dice = [ dice [ x ] for x in mask [ <STRING> ] ] <NEWLINE> for j in range ( 4 ) : <NEWLINE> <INDENT> if dice == dice2 : <NEWLINE> <INDENT> find = True <NEWLINE> break <NEWLINE> <DEDENT> dice = [ dice [ x ] for x in mask [ <STRING> ] ] <NEWLINE> <NL> <DEDENT> if find : <NEWLINE> <NL> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import numpy as np <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> m = n ** 2 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dp = np . zeros ( ( n + 1 , n + 1 , m + 1 ) , dtype = np . int64 ) <NEWLINE> dp [ 0 , 0 , 0 ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 ) : <NEWLINE> <INDENT> dp [ i , j , 2 * j : ] = ( 2 * j + 1 ) * dp [ i - 1 , j , : m + 1 - 2 * j ] <NEWLINE> if j + 1 <= i - 1 : <NEWLINE> <INDENT> dp [ i , j , 2 * j : ] += ( j + 1 ) * ( j + 1 ) * dp [ i - 1 , j + 1 , : m + 1 - 2 * j ] <NEWLINE> <DEDENT> if j : <NEWLINE> <INDENT> dp [ i , j , 2 * j : ] += dp [ i - 1 , j - 1 , : m + 1 - 2 * j ] <NEWLINE> <DEDENT> dp [ i , j , 2 * j : ] %= mod <NEWLINE> <DEDENT> <DEDENT> ans = dp [ n , 0 , k ] <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> from heapq import heappush <NEWLINE> from heapq import heappop <NEWLINE> <NL> <NL> <COMMENT> <NL> n_V , n_E , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> E = [ [ ] for _ in range ( n_V ) ] <NEWLINE> for i in range ( n_E ) : <NEWLINE> <INDENT> v , e , c = map ( int , input ( ) . split ( ) ) <NEWLINE> E [ v ] . append ( ( e , c ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> D = [ sys . maxsize for _ in range ( n_V ) ] <NEWLINE> D [ r ] = 0 <NEWLINE> <NL> h = [ ] <NEWLINE> heappush ( h , ( D [ r ] , r ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> while len ( h ) != 0 : <NEWLINE> <INDENT> _ , index = heappop ( h ) <NEWLINE> <NL> for e , c in E [ index ] : <NEWLINE> <INDENT> d = D [ index ] + c <NEWLINE> if D [ e ] > d : <NEWLINE> <INDENT> D [ e ] = d <NEWLINE> heappush ( h , ( d , e ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for d in D : <NEWLINE> <INDENT> if d == sys . maxsize : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import heapq <NEWLINE> <NL> <COMMENT> <NL> def input_array ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = input_array ( ) <NEWLINE> sortA = sorted ( A , reverse = True ) <COMMENT> <NEWLINE> <NL> ans = 0 <NEWLINE> q = [ ] <NEWLINE> heapq . heappush ( q , - sortA [ 0 ] ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> tmp = heapq . heappop ( q ) <NEWLINE> tmp *= - 1 <NEWLINE> ans += tmp <NEWLINE> heapq . heappush ( q , - sortA [ i ] ) <NEWLINE> heapq . heappush ( q , - sortA [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> ps = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if i + 1 == ps [ i ] : <NEWLINE> <INDENT> tmp = ps [ i ] <NEWLINE> ps [ i ] = ps [ i + 1 ] <NEWLINE> ps [ i + 1 ] = tmp <NEWLINE> cnt += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if ps [ n - 1 ] == n : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> has_zero = False <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> has_zero = True <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for a in A : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans *= a <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if has_zero is True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = int ( N ) <NEWLINE> MA = max ( A ) <NEWLINE> s = 0 <NEWLINE> LS = [ 0 for i in range ( 0 , MA ) ] <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> k = 1 <NEWLINE> while A [ i ] * k <= MA : <NEWLINE> <INDENT> LS [ A [ i ] * k - 1 ] += 1 <NEWLINE> k += 1 <NEWLINE> <DEDENT> <DEDENT> for j in range ( 0 , N ) : <NEWLINE> <INDENT> if LS [ A [ j ] - 1 ] == 1 : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> route = [ 1 ] <NEWLINE> dest = A [ 0 ] <NEWLINE> check = { i : False for i in range ( n ) } <NEWLINE> while not check [ dest - 1 ] : <NEWLINE> <INDENT> check [ dest - 1 ] = True <NEWLINE> route . append ( dest ) <NEWLINE> dest = A [ dest - 1 ] <NEWLINE> <DEDENT> ind = route . index ( dest ) <NEWLINE> cycle = route [ ind : ] <NEWLINE> if k >= ind : <NEWLINE> <INDENT> ans = ( k - ind ) % len ( cycle ) <NEWLINE> print ( cycle [ ans ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( route [ k ] ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> ans = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = [ int ( i . strip ( ) ) for i in input ( ) . split ( ) ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> ch_1 = x - i <NEWLINE> ch_2 = x + i <NEWLINE> if p . count ( ch_1 ) == 0 : <NEWLINE> <INDENT> ans = ch_1 <NEWLINE> break <NEWLINE> <DEDENT> elif p . count ( ch_2 ) == 0 : <NEWLINE> <INDENT> ans = ch_2 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> room_adjacent = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> room1 , room2 = map ( int , input ( ) . split ( ) ) <NEWLINE> room_adjacent [ room1 - 1 ] . append ( room2 ) <NEWLINE> room_adjacent [ room2 - 1 ] . append ( room1 ) <NEWLINE> <NL> <DEDENT> room_labels = [ 1 ] + [ 0 ] * ( n - 1 ) <NEWLINE> old_room = 1 <NEWLINE> path_queue = deque ( ( old_room , room ) for room in room_adjacent [ old_room - 1 ] ) <NEWLINE> while path_queue : <NEWLINE> <INDENT> old_room , new_room = path_queue . pop ( ) <NEWLINE> if room_labels [ new_room - 1 ] == 0 : <NEWLINE> <INDENT> room_labels [ new_room - 1 ] = old_room <NEWLINE> for another_room in room_adjacent [ new_room - 1 ] : <NEWLINE> <INDENT> path_queue . appendleft ( ( new_room , another_room ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if 0 in room_labels : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> [ print ( value ) for value in room_labels [ 1 : ] ] <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> d , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if d == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> E = [ 0 ] * d <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> * E [ i ] , = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for x2 in range ( d ) : <NEWLINE> <INDENT> for y2 in range ( w ) : <NEWLINE> <INDENT> for x1 in range ( x2 - 1 ) : <NEWLINE> <INDENT> for y1 in range ( y2 - 1 ) : <NEWLINE> <INDENT> co = 10 ** 18 <NEWLINE> for x in range ( x1 , x2 + 1 ) : <NEWLINE> <INDENT> co = min ( co , E [ x ] [ y1 ] , E [ x ] [ y2 ] ) <NEWLINE> <DEDENT> for y in range ( y1 , y2 + 1 ) : <NEWLINE> <INDENT> co = min ( co , E [ x1 ] [ y ] , E [ x2 ] [ y ] ) <NEWLINE> <DEDENT> ci = cnt = 0 <NEWLINE> for x in range ( x1 + 1 , x2 ) : <NEWLINE> <INDENT> for y in range ( y1 + 1 , y2 ) : <NEWLINE> <INDENT> ci = max ( ci , E [ x ] [ y ] ) <NEWLINE> cnt += E [ x ] [ y ] <NEWLINE> <DEDENT> <DEDENT> if ci < co : <NEWLINE> <INDENT> ans = max ( ans , ( x2 - x1 - 1 ) * ( y2 - y1 - 1 ) * co - cnt ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> buka = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> buka [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( buka [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> def n_div ( n ) : <NEWLINE> <INDENT> div_list = [ ] <NEWLINE> import math <NEWLINE> for i in range ( 1 , math . ceil ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> div_list . append ( i ) <NEWLINE> if i * i == n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> div_list . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> div_list . sort ( ) <NEWLINE> return div_list <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> lr = n_div ( n ) <NEWLINE> <COMMENT> <NL> if len ( lr ) % 2 == 0 : <NEWLINE> <INDENT> a = len ( lr ) / 2 <NEWLINE> a = int ( a ) <NEWLINE> ans = lr [ a ] + lr [ a - 1 ] - 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = math . floor ( len ( lr ) / 2 ) <NEWLINE> <COMMENT> <NL> ans = lr [ a ] * 2 - 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 1 ] <NEWLINE> ba = { 1 } <NEWLINE> c = 0 <NEWLINE> m = 0 <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ m ] not in ba : <NEWLINE> <INDENT> b . append ( a [ m ] ) <NEWLINE> ba . add ( a [ m ] ) <NEWLINE> c += 1 <NEWLINE> m = a [ m ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e = a [ m ] <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> e = b . index ( e ) <NEWLINE> <COMMENT> <NL> bc = b <NEWLINE> b = b [ e : c + 1 ] <NEWLINE> f = c + 1 - e <NEWLINE> if c > k : <NEWLINE> <INDENT> if c - 1 >= k : <NEWLINE> <NL> <INDENT> print ( bc [ k ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if 1 not in b : <NEWLINE> <COMMENT> <NL> <INDENT> ans = ( k - e ) % f <NEWLINE> print ( b [ ans ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> ans = k % f <NEWLINE> print ( b [ ans ] ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , product , groupby , combinations_with_replacement <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> N = INT ( ) <NEWLINE> X = input ( ) <NEWLINE> <NL> def popcount ( n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while n : <NEWLINE> <INDENT> n %= <STRING> . format ( n ) . count ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> pl = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> pl [ i ] = popcount ( i ) <NEWLINE> <DEDENT> bn = X . count ( <STRING> ) <NEWLINE> <NL> modp = [ 0 ] * N <NEWLINE> modm = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> modp [ i ] = pow ( 2 , N - 1 - i , bn + 1 ) <NEWLINE> if not bn == 1 : <NEWLINE> <INDENT> modm [ i ] = pow ( 2 , N - 1 - i , bn - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> sp = sum ( modp ) <NEWLINE> sm = sum ( modm ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> if bn == 1 : <NEWLINE> <INDENT> ans [ i ] = 0 <NEWLINE> continue <NEWLINE> <DEDENT> s = sm <NEWLINE> s -= modm [ i ] <NEWLINE> s %= bn - 1 <NEWLINE> ans [ i ] = pl [ s ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = sp <NEWLINE> s += pow ( 2 , N - 1 - i , bn + 1 ) <NEWLINE> s %= bn + 1 <NEWLINE> ans [ i ] = pl [ s ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
N , * D = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> S = sorted ( D , reverse = True ) <NEWLINE> if S [ 1 ] == S [ 0 ] : <NEWLINE> <INDENT> [ print ( S [ 0 ] ) for i in range ( N ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> import numpy as np <NEWLINE> max_i = np . arange ( N ) [ np . array ( D ) == S [ 0 ] ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i == max_i : <NEWLINE> <INDENT> print ( S [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = defaultdict ( list ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = defaultdict ( int ) <NEWLINE> next_list = [ ] <NEWLINE> for j in graph [ 1 ] : <NEWLINE> <INDENT> ans [ j ] = 1 <NEWLINE> next_list . append ( j ) <NEWLINE> <NL> <DEDENT> target_list = next_list [ : ] <NEWLINE> while True : <NEWLINE> <INDENT> next_list = [ ] <NEWLINE> if len ( target_list ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in target_list : <NEWLINE> <INDENT> for j in graph [ i ] : <NEWLINE> <INDENT> if j not in ans : <NEWLINE> <INDENT> ans [ j ] = i <NEWLINE> next_list . append ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> target_list = next_list [ : ] <NEWLINE> <NL> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> pot_starts = [ ] <NEWLINE> pot_ends = [ ] <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i [ 0 ] == 1 : <NEWLINE> <INDENT> pot_starts . append ( i [ 1 ] ) <NEWLINE> <DEDENT> elif i [ 1 ] == n : <NEWLINE> <INDENT> pot_ends . append ( i [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if set ( pot_starts ) . intersection ( pot_ends ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> class Union_Find : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parent = [ i for i in range ( n ) ] <NEWLINE> self . rank = [ 1 for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parent [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . find ( self . parent [ x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> px = self . find ( x ) <NEWLINE> py = self . find ( y ) <NEWLINE> if px == py : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . rank [ px ] == self . rank [ py ] : <NEWLINE> <INDENT> self . parent [ py ] = px <NEWLINE> self . rank [ px ] += 1 <NEWLINE> <DEDENT> elif self . rank [ px ] > self . rank [ py ] : <NEWLINE> <INDENT> self . parent [ py ] = px <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ px ] = py <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> uftree = Union_Find ( N + 1 ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> x , y , _ = map ( int , input ( ) . split ( ) ) <NEWLINE> uftree . unite ( x , y ) <NEWLINE> <NL> <DEDENT> result = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if uftree . find ( i ) == i : <NEWLINE> <INDENT> result += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL>
s = list ( input ( ) ) <NEWLINE> <COMMENT> <NL> n = len ( s ) <NEWLINE> ans = 0 <NEWLINE> s . reverse ( ) <NEWLINE> <COMMENT> <NL> x = 1 <NEWLINE> tot = 0 <NEWLINE> count = [ 0 ] * 2019 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> count [ tot ] += 1 <NEWLINE> tot += int ( s [ i ] ) * x <NEWLINE> <COMMENT> <NL> tot %= 2019 <NEWLINE> ans += count [ tot ] <NEWLINE> x = x * 10 % 2019 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for h in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( tmp , h ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( n , x ) ) <NEWLINE> n += 1 <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = collections . Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( a . get ( i , 0 ) ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> flag = [ 1 for i in range ( N ) ] <NEWLINE> height = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if height [ a - 1 ] < height [ b - 1 ] : <NEWLINE> <INDENT> flag [ a - 1 ] = 0 <NEWLINE> <DEDENT> elif height [ a - 1 ] > height [ b - 1 ] : <NEWLINE> <INDENT> flag [ b - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag [ a - 1 ] = 0 <NEWLINE> flag [ b - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( flag ) ) <NEWLINE>
S = input ( ) <NEWLINE> unko = [ 0 ] * 2019 <NEWLINE> tmp = 0 <NEWLINE> num = 1 <NEWLINE> for s in S [ : : - 1 ] : <NEWLINE> <INDENT> s = int ( s ) <NEWLINE> tmp = ( tmp + s * num ) % 2019 <NEWLINE> num = ( num * 10 ) % 2019 <NEWLINE> unko [ tmp ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> ans += ( unko [ 0 ] + 1 ) * unko [ 0 ] / 2 <NEWLINE> for i in unko [ 1 : ] : <NEWLINE> <INDENT> ans += i * ( i - 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> t = [ 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t . append ( a [ t [ - 1 ] - 1 ] ) <NEWLINE> <NL> <DEDENT> t_sort = sorted ( t ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if t_sort [ i ] == t_sort [ i + 1 ] : <NEWLINE> <INDENT> b = t_sort [ i ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if t [ i ] == b : <NEWLINE> <INDENT> if count == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> s_first = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s_second = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> s = s_second - s_first <NEWLINE> <NL> for i in range ( n - s + 1 ) : <NEWLINE> <INDENT> if t [ i ] == t [ i + s ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if k < i : <NEWLINE> <INDENT> print ( t [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t [ ( k - i ) % s + i ] ) <NEWLINE> <DEDENT>
a = [ input ( ) for i in range ( 2 ) ] <NEWLINE> <NL> s = a [ 0 ] <NEWLINE> t = a [ 1 ] <NEWLINE> <NL> if s == t [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a > b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> print ( str ( a ) + <STRING> + str ( b ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> from itertools import chain <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def solve ( N : int , K : int , p : <STRING> ) : <NEWLINE> <INDENT> p = sorted ( p ) <NEWLINE> return sum ( p [ : K ] ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> tokens = chain ( * ( line . split ( ) for line in sys . stdin ) ) <NEWLINE> <COMMENT> <NL> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> K = int ( next ( tokens ) ) <COMMENT> <NEWLINE> p = [ int ( next ( tokens ) ) for _ in range ( N ) ] <COMMENT> <NEWLINE> answer = solve ( N , K , p ) <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 for i in range ( N ) ] <NEWLINE> for a in A : <NEWLINE> <INDENT> ans [ a - 1 ] += 1 <NEWLINE> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( A ) <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> CB = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> CB . append ( ( c , b ) ) <NEWLINE> <DEDENT> CB . sort ( reverse = True ) <NEWLINE> for c , b in CB : <NEWLINE> <INDENT> for j in range ( b ) : <NEWLINE> <INDENT> tmp = heapq . heappop ( A ) <NEWLINE> if tmp >= c : <NEWLINE> <INDENT> heapq . heappush ( A , tmp ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> heapq . heappush ( A , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
<COMMENT> <NL> from sys import stdin <NEWLINE> from operator import itemgetter <NEWLINE> from collections import deque <NEWLINE> import math <NEWLINE> import pprint <NEWLINE> from functools import reduce <NEWLINE> <COMMENT> <NL> <NL> def keta ( kazu ) : <NEWLINE> <INDENT> kazu_str = str ( kazu ) <NEWLINE> kazu_list = [ int ( kazu_str [ i ] ) for i in range ( 0 , len ( kazu_str ) ) ] <NEWLINE> return kazu_list <NEWLINE> <NL> <DEDENT> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> K = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> ans = 0 <NEWLINE> for_c = [ ] <NEWLINE> <NL> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if math . gcd ( a , b ) == 1 : <NEWLINE> <INDENT> ans += K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for_c . append ( math . gcd ( a , b ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for ab in range ( len ( for_c ) ) : <NEWLINE> <INDENT> ans += math . gcd ( for_c [ ab ] , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . readline <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> data = range ( 1 , M + 1 ) <NEWLINE> A = list ( itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) ) <NEWLINE> l = [ ] <NEWLINE> m = 0 <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( [ a , b , c , d ] ) <NEWLINE> <DEDENT> for a_list in A : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> if a_list [ i [ 1 ] - 1 ] - a_list [ i [ 0 ] - 1 ] == i [ 2 ] : <NEWLINE> <INDENT> tmp += i [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if tmp > m : <NEWLINE> <INDENT> m = tmp <NEWLINE> <DEDENT> <DEDENT> return m <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <NL> <DEDENT>
S = input ( ) [ : : - 1 ] <NEWLINE> <NL> <COMMENT> <NL> counts = [ 0 ] * 2019 <NEWLINE> <COMMENT> <NL> counts [ 0 ] = 1 <NEWLINE> <NL> num , d = 0 , 1 <NEWLINE> <NL> for c in S : <NEWLINE> <COMMENT> <NL> <INDENT> num += int ( c ) * d <NEWLINE> num %= 2019 <NEWLINE> <NL> <COMMENT> <NL> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> <NL> counts [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in counts : <NEWLINE> <COMMENT> <NL> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> klist = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if ( i <= x and j <= x ) or ( y <= i and y <= j ) : <NEWLINE> <INDENT> k = j - i <NEWLINE> klist [ k ] += 1 <NEWLINE> <DEDENT> elif i <= x and x < j <= y : <NEWLINE> <INDENT> k = min ( j - i , ( x - i + y - j ) + 1 ) <NEWLINE> klist [ k ] += 1 <NEWLINE> <DEDENT> elif i <= x and y <= j : <NEWLINE> <INDENT> k = ( j - i ) - ( y - x ) + 1 <NEWLINE> klist [ k ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = min ( ( j - i ) , ( ( i - x ) + abs ( y - j ) + 1 ) ) <NEWLINE> klist [ k ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i1 in range ( 1 , n ) : <NEWLINE> <INDENT> print ( klist [ i1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
for i in range ( 10000 ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> x = int ( x ) <NEWLINE> <NL> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + str ( i + 1 ) + <STRING> + str ( x ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( q ) ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( i + 1 ) <NEWLINE> <DEDENT> import itertools <NEWLINE> l = list ( itertools . combinations_with_replacement ( b , n ) ) <NEWLINE> max = 0 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> for ll in l : <NEWLINE> <INDENT> m = 0 <NEWLINE> <COMMENT> <NL> for aa in a : <NEWLINE> <COMMENT> <NL> <INDENT> if ll [ aa [ 1 ] - 1 ] - ll [ aa [ 0 ] - 1 ] == aa [ 2 ] : <NEWLINE> <COMMENT> <NL> <INDENT> m += aa [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if max < m : <NEWLINE> <INDENT> max = m <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 , 0 ] <NEWLINE> ans_abs = 10 ** 200 <NEWLINE> <NL> A_sum = sum ( A ) <NEWLINE> A_1 = 0 <NEWLINE> A_2 = A_sum <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> A_1 += A [ i ] <NEWLINE> A_2 -= A [ i ] <NEWLINE> ans_abs = min ( ans_abs , abs ( A_1 - A_2 ) ) <NEWLINE> <NL> <DEDENT> print ( ans_abs ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <NL> def index ( A , x ) : <NEWLINE> <INDENT> i = bisect_left ( A , x ) <NEWLINE> if i != len ( A ) and A [ i ] == x : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for t in T : <NEWLINE> <INDENT> if index ( S , t ) >= 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for d in range ( X + 1 ) : <NEWLINE> <INDENT> for s in [ - 1 , + 1 ] : <NEWLINE> <INDENT> a = X + s * d <NEWLINE> if p . count ( a ) == 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> flag = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % n == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) [ : : - 1 ] <NEWLINE> ans = 0 <NEWLINE> mod = 0 <NEWLINE> ten = 1 <NEWLINE> count = [ 0 ] * 2019 <NEWLINE> count [ 0 ] = 1 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> mod = ( mod + int ( S [ i ] ) * ten ) % 2019 <NEWLINE> ten = ten * 10 % 2019 <NEWLINE> count [ mod ] += 1 <NEWLINE> <DEDENT> for c in count : <NEWLINE> <INDENT> ans += c * ( c - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> tmp = sum ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp -= A [ i ] <NEWLINE> ans += A [ i ] * tmp <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_sum = [ 0 ] <NEWLINE> B_sum = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A_sum . append ( A_sum [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> B_sum . append ( B_sum [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> num = 0 <NEWLINE> J = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if A_sum [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in reversed ( range ( J + 1 ) ) : <NEWLINE> <INDENT> if A_sum [ i ] + B_sum [ j ] <= K : <NEWLINE> <INDENT> if num < i + j : <NEWLINE> <INDENT> num = i + j <NEWLINE> <DEDENT> J = j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> S = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) <NEWLINE> L = [ S [ 0 ] ] <NEWLINE> used = [ False ] * ( 1 << n ) <NEWLINE> used [ 0 ] = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> L . sort ( reverse = True ) <NEWLINE> idx = 0 <NEWLINE> for j , s in enumerate ( S ) : <NEWLINE> <INDENT> if used [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if L [ idx ] > s : <NEWLINE> <INDENT> L . append ( s ) <NEWLINE> used [ j ] = True <NEWLINE> idx += 1 <NEWLINE> if idx == 1 << i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = input ( ) <NEWLINE> A = A . split ( <STRING> ) <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> X = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> X *= int ( i ) <NEWLINE> if X > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( X ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> stdin = sys . stdin <NEWLINE> from collections import defaultdict <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( ns ( ) ) <NEWLINE> def na ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = ni ( ) <NEWLINE> a = np . array ( na ( ) ) <NEWLINE> b = np . arange ( 1 , n + 1 ) <NEWLINE> c = a + b <NEWLINE> d = b - a <NEWLINE> l = defaultdict ( lambda : 0 ) <NEWLINE> ans = 0 <NEWLINE> for ci in c : <NEWLINE> <INDENT> l [ ci ] += 1 <NEWLINE> <DEDENT> for di in d : <NEWLINE> <INDENT> ans += l [ di ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
T = [ 0 ] <NEWLINE> <NL> def curserch ( N , k , T , P , n ) : <NEWLINE> <INDENT> T [ 0 ] = T [ 0 ] + 1 <NEWLINE> P [ k ] [ <STRING> ] = T [ 0 ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if N [ k ] [ i ] == 1 and P [ i ] [ <STRING> ] == 0 : <NEWLINE> <INDENT> curserch ( N , i , T , P , n ) <NEWLINE> T [ 0 ] = T [ 0 ] + 1 <NEWLINE> P [ i ] [ <STRING> ] = T [ 0 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = [ [ 0 for j in range ( n + 1 ) ] for i in range ( n + 1 ) ] <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> vec = input ( ) . split ( ) <NEWLINE> u = int ( vec [ 0 ] ) <NEWLINE> k = int ( vec [ 1 ] ) <NEWLINE> nodes = vec [ 2 : ] <NEWLINE> for i in range ( int ( k ) ) : <NEWLINE> <INDENT> v = int ( nodes [ i ] ) <NEWLINE> A [ u ] [ v ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> P = [ { <STRING> : 0 } for i in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if P [ i ] [ <STRING> ] == 0 : <NEWLINE> <INDENT> curserch ( A , i , T , P , n ) <NEWLINE> T [ 0 ] = T [ 0 ] + 1 <NEWLINE> P [ i ] [ <STRING> ] = T [ 0 ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( i , P [ i ] [ <STRING> ] , P [ i ] [ <STRING> ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> * a , = map ( int , input ( ) . split ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> for i in a : <NEWLINE> <INDENT> if i in d : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> ans = sum ( a ) <NEWLINE> for _ in [ 0 ] * q : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b in d : <NEWLINE> <INDENT> if c in d : <NEWLINE> <INDENT> d [ c ] += d [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ c ] = d [ b ] <NEWLINE> <DEDENT> ans += ( c - b ) * d [ b ] <NEWLINE> d [ b ] = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> q = deque ( ) <NEWLINE> t = { i : set ( ) for i in range ( 1 , n + 1 ) } <NEWLINE> v = [ - 1 ] * n <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> t [ a ] . add ( b ) <NEWLINE> t [ b ] . add ( a ) <NEWLINE> <DEDENT> q . append ( 1 ) <NEWLINE> v [ 0 ] = 1 <NEWLINE> while q : <NEWLINE> <INDENT> next = q . popleft ( ) <NEWLINE> for i in t [ next ] : <NEWLINE> <INDENT> if v [ i - 1 ] == - 1 : <NEWLINE> <INDENT> q . append ( i ) <NEWLINE> v [ i - 1 ] = next <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * v [ 1 : ] , sep = <STRING> ) <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> print ( <STRING> % ( r ** 2 * math . pi , r * 2 * math . pi ) ) <NEWLINE>
<STRING> <NEWLINE> A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> if A >= 1 : <NEWLINE> <INDENT> if K - A >= 0 : <NEWLINE> <INDENT> sum += A <NEWLINE> K -= A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += K <NEWLINE> K = 0 <NEWLINE> <DEDENT> <DEDENT> if B >= 1 and K >= 1 : <NEWLINE> <INDENT> if K - B >= 0 : <NEWLINE> <INDENT> K -= B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if C >= 1 and K >= 1 : <NEWLINE> <INDENT> if K - C >= 0 : <NEWLINE> <INDENT> sum -= C <NEWLINE> K -= C <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum -= K <NEWLINE> K = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
t = input ( ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = max ( lst ) <NEWLINE> b = min ( lst ) <NEWLINE> c = sum ( lst ) <NEWLINE> print ( str ( b ) + <STRING> + str ( a ) + <STRING> + str ( c ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> data . reverse ( ) <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> print ( data [ x ] , end = <STRING> ) <NEWLINE> if x != n - 1 : print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> mat = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( r ) ] <NEWLINE> for row in mat : <NEWLINE> <INDENT> row . append ( sum ( row ) ) <NEWLINE> print ( * row ) <NEWLINE> <DEDENT> colSum = [ sum ( col ) for col in zip ( * mat ) ] <NEWLINE> print ( * colSum ) <NEWLINE>
H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = H * W <NEWLINE> <NL> <COMMENT> <NL> wall = [ ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w_idx , w in enumerate ( list ( input ( ) ) ) : <NEWLINE> <INDENT> if w == <STRING> : <NEWLINE> <INDENT> wall . append ( W * h + w_idx + 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> path = [ _ for _ in range ( 1 , N + 1 ) if _ not in wall ] <NEWLINE> <NL> <COMMENT> <NL> ad = { } <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> ad [ n + 1 ] = [ ] <NEWLINE> <NL> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> n = n + 1 <NEWLINE> if n not in wall : <NEWLINE> <INDENT> up = n - W <NEWLINE> if up > 0 and up not in wall : <NEWLINE> <INDENT> ad [ n ] . append ( up ) <NEWLINE> <NL> <DEDENT> down = n + W <NEWLINE> if down <= N and down not in wall : <NEWLINE> <INDENT> ad [ n ] . append ( down ) <NEWLINE> <NL> <DEDENT> left = n - 1 <NEWLINE> if n % W != 1 and left not in wall and left > 0 : <NEWLINE> <INDENT> ad [ n ] . append ( left ) <NEWLINE> <NL> <DEDENT> right = n + 1 <NEWLINE> if n % W != 0 and right not in wall : <NEWLINE> <INDENT> ad [ n ] . append ( right ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> from collections import deque <NEWLINE> <NL> def BFS ( start ) : <NEWLINE> <INDENT> que = deque ( [ start ] ) <NEWLINE> visit = deque ( [ ] ) <NEWLINE> <NL> color = { } <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> color [ n + 1 ] = - 1 <NEWLINE> <DEDENT> color [ start ] = 0 <NEWLINE> <NL> depth = { } <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> depth [ n + 1 ] = - 1 <NEWLINE> <NL> <DEDENT> depth [ start ] = 0 <NEWLINE> while len ( que ) > 0 : <NEWLINE> <INDENT> start = que [ 0 ] <NEWLINE> for v in ad [ start ] : <NEWLINE> <INDENT> if color [ v ] == - 1 : <NEWLINE> <INDENT> que . append ( v ) <NEWLINE> color [ v ] = 0 <NEWLINE> depth [ v ] = depth [ start ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> color [ start ] = 1 <NEWLINE> visit . append ( que . popleft ( ) ) <NEWLINE> <NL> <DEDENT> return depth [ start ] <NEWLINE> <NL> <DEDENT> ans = - 1 <NEWLINE> for start in path : <NEWLINE> <INDENT> ans_ = BFS ( start ) <NEWLINE> if ans < BFS ( start ) : <NEWLINE> <INDENT> ans = ans_ <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 0 <NEWLINE> m = sum ( a ) <NEWLINE> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> m = ( m - a [ i ] ) % ( 10 ** 9 + 7 ) <NEWLINE> x += a [ i ] * m <NEWLINE> x = x % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( x % ( 10 ** 9 + 7 ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> visit = [ - 1 for i in range ( n ) ] <NEWLINE> root = [ ] <NEWLINE> now = 1 <NEWLINE> length = 0 <NEWLINE> root . append ( now ) <NEWLINE> if k > n : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if visit [ now - 1 ] != 1 : <NEWLINE> <INDENT> visit [ now - 1 ] = 1 <NEWLINE> now = a [ now - 1 ] <NEWLINE> root . append ( now ) <NEWLINE> length += 1 <NEWLINE> <DEDENT> else : break <NEWLINE> <DEDENT> start = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if root [ i ] == now : <NEWLINE> <INDENT> start = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> length -= start <NEWLINE> k -= start <NEWLINE> k %= length <NEWLINE> ans = root [ start + k ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> now = a [ now - 1 ] <NEWLINE> <DEDENT> print ( now ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from bisect import bisect_left <NEWLINE> <NL> <NL> def solve ( * args : str ) -> str : <NEWLINE> <INDENT> x = int ( args [ 0 ] ) <NEWLINE> <NL> P = [ pow ( i , 5 ) for i in range ( 128 ) ] <NEWLINE> ret = None <NEWLINE> for b , b5 in enumerate ( P ) : <NEWLINE> <INDENT> a5 = x + b5 <NEWLINE> like_a = bisect_left ( P , a5 ) <NEWLINE> if like_a < len ( P ) : <NEWLINE> <INDENT> if P [ like_a ] == a5 : <NEWLINE> <INDENT> ret = ( like_a , b ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> a5 = abs ( x - b5 ) <NEWLINE> like_a = bisect_left ( P , a5 ) <NEWLINE> if like_a < len ( P ) : <NEWLINE> <INDENT> if P [ like_a ] == a5 : <NEWLINE> <INDENT> ret = ( like_a if b5 < x else - like_a , - b ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return <STRING> . join ( map ( str , ret ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( solve ( * ( open ( 0 ) . read ( ) . splitlines ( ) ) ) ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 : break <NEWLINE> for i in range ( h ) : print ( ( <STRING> * w ) [ i % 2 : ] [ : w ] ) <NEWLINE> print ( ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = n // ( a + b ) * a <NEWLINE> rem = n % ( a + b ) <NEWLINE> ans += min ( rem , a ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> import collections , sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> friend = [ [ ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> block = [ [ ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> teams = [ 0 ] * ( n + 1 ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> friend [ a ] . append ( b ) <NEWLINE> friend [ b ] . append ( a ) <NEWLINE> <DEDENT> for _ in range ( k ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> block [ c ] . append ( d ) <NEWLINE> block [ d ] . append ( c ) <NEWLINE> <NL> <DEDENT> def dfs ( i ) : <NEWLINE> <INDENT> teams [ i ] = team <NEWLINE> for j in friend [ i ] : <NEWLINE> <INDENT> if teams [ j ] != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> team = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if teams [ i ] != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( i ) <NEWLINE> team += 1 <NEWLINE> <NL> <DEDENT> c = collections . Counter ( teams ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> temp = c [ teams [ i ] ] - len ( friend [ i ] ) - 1 <NEWLINE> for j in block [ i ] : <NEWLINE> <INDENT> if teams [ j ] == teams [ i ] : <NEWLINE> <INDENT> temp -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( temp , end = <STRING> ) <NEWLINE> if i != n : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b and b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
wor = raw_input ( ) <NEWLINE> word = raw_input ( ) <NEWLINE> a = [ [ wor ] for i in range ( 10 ) ] <NEWLINE> b = <STRING> <NEWLINE> for i in a : <NEWLINE> <INDENT> b = b + <STRING> . join ( i ) <NEWLINE> <NL> <NL> <DEDENT> if b . count ( word ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ij = gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( ij , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> <NL> def p ( k , w , maxP ) : <NEWLINE> <INDENT> count = 1 <NEWLINE> tmpWeight = 0 <NEWLINE> for x in w : <NEWLINE> <INDENT> if tmpWeight + x <= maxP : <NEWLINE> <INDENT> tmpWeight += x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count > k : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> tmpWeight = x <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> w = [ ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> w . append ( ( int ) ( input ( ) ) ) <NEWLINE> <DEDENT> rangeMax = sum ( w ) <NEWLINE> rangeMin = max ( w ) <NEWLINE> rangeMid = 0 <NEWLINE> while rangeMin < rangeMax : <NEWLINE> <INDENT> rangeMid = ( rangeMax + rangeMin ) // 2 <NEWLINE> <STRING> <NEWLINE> if p ( k , w , rangeMid ) == True : <NEWLINE> <INDENT> rangeMax = rangeMid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rangeMid += 1 <NEWLINE> rangeMin = rangeMid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( rangeMid ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A_list = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> A_array = np . array ( A_list ) <NEWLINE> sort_A = np . sort ( A_array ) <NEWLINE> <NL> n_array = np . zeros ( 10 ** 6 ) <NEWLINE> <NL> for a in sort_A : <NEWLINE> <NL> <INDENT> if n_array [ a - 1 ] >= 2 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> a_times = np . array ( range ( a , 10 ** 6 + 1 , a ) ) <NEWLINE> <NL> n_array [ ( a_times - 1 ) . astype ( int ) ] += 1 <NEWLINE> <NL> <DEDENT> print ( ( n_array [ sort_A - 1 ] == 1 ) . sum ( ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for el in a : <NEWLINE> <INDENT> if el == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> for el in a : <NEWLINE> <INDENT> ans *= el <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
ope = { <STRING> : lambda a , b : b + a , <NEWLINE> <INDENT> <STRING> : lambda a , b : b - a , <NEWLINE> <STRING> : lambda a , b : b * a } <NEWLINE> <DEDENT> stack = [ ] <NEWLINE> <NL> for c in input ( ) . split ( ) : <NEWLINE> <INDENT> if c in ope : <NEWLINE> <INDENT> stack . append ( ope [ c ] ( stack . pop ( ) , stack . pop ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . append ( int ( c ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( stack [ - 1 ] ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 , 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 , 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 , 1 ) : <NEWLINE> <INDENT> if i == j and j == k : <NEWLINE> <INDENT> ans = ans + math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <DEDENT> elif i == j and j != k : <NEWLINE> <INDENT> ans = ans + 3 * math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <DEDENT> elif i != j and j == k : <NEWLINE> <INDENT> ans = ans + 3 * math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <DEDENT> elif i != j and j != k : <NEWLINE> <INDENT> ans = ans + 6 * math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> from __future__ import print_function <NEWLINE> from __future__ import unicode_literals <NEWLINE> from __future__ import division <NEWLINE> from __future__ import absolute_import <NEWLINE> <NL> def array2d ( row , col , init = None ) : <NEWLINE> <INDENT> return [ [ init for _ in range ( col ) ] for _ in range ( row ) ] <NEWLINE> <NL> <DEDENT> N , W = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> v = [ ] <NEWLINE> w = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> vi , wi = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> v . append ( vi ) <NEWLINE> w . append ( wi ) <NEWLINE> <NL> <DEDENT> dpt = array2d ( N + 1 , W + 1 ) <NEWLINE> <NL> def dp ( i , j ) : <NEWLINE> <INDENT> if dpt [ i ] [ j ] is not None : <NEWLINE> <INDENT> return dpt [ i ] [ j ] <NEWLINE> <DEDENT> if i == 0 : <NEWLINE> <INDENT> dpt [ i ] [ j ] = 0 <NEWLINE> return 0 <NEWLINE> <DEDENT> if j < w [ i - 1 ] : <NEWLINE> <INDENT> dpt [ i ] [ j ] = dp ( i - 1 , j ) <NEWLINE> return dpt [ i ] [ j ] <NEWLINE> <DEDENT> dpt [ i ] [ j ] = max ( dp ( i - 1 , j ) , dp ( i , j - w [ i - 1 ] ) + v [ i - 1 ] ) <NEWLINE> return dpt [ i ] [ j ] <NEWLINE> <NL> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for j in range ( W + 1 ) : <NEWLINE> <INDENT> dp ( i , j ) <NEWLINE> <DEDENT> <DEDENT> print ( dp ( N , W ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> for a in range ( 1 , 120 ) : <NEWLINE> <INDENT> for b in range ( - 120 , 120 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> import numpy as np <NEWLINE> ss = [ si + si for si in s ] <NEWLINE> ss = np . array ( ss + ss ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = ss [ i : i + n , : n ] <NEWLINE> if np . array_equal ( a , a . T ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans * n ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> ans = None <NEWLINE> <NL> for i in range ( 120 ) : <NEWLINE> <INDENT> for j in range ( 120 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> ans = ( i , j ) <NEWLINE> <DEDENT> elif ( i * - 1 ) ** 5 - j ** 5 == X : <NEWLINE> <INDENT> ans = ( - i , j ) <NEWLINE> <DEDENT> elif i ** 5 - ( j * - 1 ) ** 5 == X : <NEWLINE> <INDENT> ans = ( i , - j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans [ 0 ] , ans [ 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> t = int ( n ** 0.5 ) <NEWLINE> while len ( l ) == 0 : <NEWLINE> <INDENT> if n % t == 0 : <NEWLINE> <INDENT> l . append ( ( t , n // t ) ) <NEWLINE> <DEDENT> t -= 1 <NEWLINE> <DEDENT> x , y = l [ 0 ] [ 0 ] , l [ 0 ] [ 1 ] <NEWLINE> ans = max ( len ( list ( str ( x ) ) ) , len ( list ( str ( y ) ) ) ) <NEWLINE> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> x = [ 0 ] * n <NEWLINE> x . append ( 0 ) <NEWLINE> v = 1 <NEWLINE> c = 1 <NEWLINE> l = 0 <NEWLINE> while x [ v ] == 0 : <NEWLINE> <INDENT> x [ v ] = len ( s ) <NEWLINE> s . append ( v ) <NEWLINE> v = a [ v - 1 ] <NEWLINE> <DEDENT> c = len ( s ) - x [ v ] <NEWLINE> l = x [ v ] <NEWLINE> <NL> <NL> if k < l : <NEWLINE> <INDENT> print ( s [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= l <NEWLINE> k = k % c <NEWLINE> print ( s [ l + k ] ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( B - 1 , N ) <NEWLINE> print ( ( A * x // B ) - A * ( x // B ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> _ , _ , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> row_dict = defaultdict ( int ) <NEWLINE> col_dict = defaultdict ( int ) <NEWLINE> row_col_dict = defaultdict ( set ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> row , col = map ( int , input ( ) . split ( ) ) <NEWLINE> row_dict [ row ] += 1 <NEWLINE> col_dict [ col ] += 1 <NEWLINE> row_col_dict [ row ] . add ( col ) <NEWLINE> <NL> <DEDENT> max_row_val = max ( row_dict . values ( ) ) <NEWLINE> max_col_val = max ( col_dict . values ( ) ) <NEWLINE> <NL> max_rows = { k for k , v in row_dict . items ( ) if v == max_row_val } <NEWLINE> max_cols = { k for k , v in col_dict . items ( ) if v == max_col_val } <NEWLINE> ans = max_row_val + max_col_val - 1 <NEWLINE> flg = False <NEWLINE> if ans < m : <NEWLINE> <INDENT> for row in max_rows : <NEWLINE> <INDENT> for col in max_cols : <NEWLINE> <INDENT> if not col in row_col_dict [ row ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> flg = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ map ( int , input ( ) . split ( ) ) for _ in range ( M ) ] <NEWLINE> <COMMENT> <NL> links = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> links [ a ] . append ( b ) <NEWLINE> links [ b ] . append ( a ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> result = [ - 1 ] * ( N + 1 ) <NEWLINE> q = deque ( [ 1 ] ) <NEWLINE> <COMMENT> <NL> while q : <NEWLINE> <INDENT> i = q . popleft ( ) <NEWLINE> for j in links [ i ] : <NEWLINE> <INDENT> if result [ j ] == - 1 : <NEWLINE> <INDENT> result [ j ] = i <NEWLINE> q . append ( j ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( str ( i ) for i in result [ 2 : ] ) ) <NEWLINE>
def power_set ( item_lists ) : <NEWLINE> <NL> <INDENT> p_sets = [ [ ] ] <NEWLINE> <NL> for item in item_lists : <NEWLINE> <INDENT> tmp = [ ] <NEWLINE> for element in p_sets : <NEWLINE> <INDENT> tmp . append ( element + [ item ] ) <NEWLINE> <DEDENT> p_sets . extend ( tmp ) <NEWLINE> <NL> <DEDENT> return p_sets <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p_set = [ sum ( l ) for l in power_set ( A ) ] <NEWLINE> <NL> for m_i in m : <NEWLINE> <NL> <INDENT> if m_i in p_set : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> n , m , * ab = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> to = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> ans = [ None ] * ( n + 1 ) <NEWLINE> for i in range ( 0 , m * 2 , 2 ) : <NEWLINE> <INDENT> a = ab [ i ] <NEWLINE> b = ab [ i + 1 ] <NEWLINE> to [ a ] . append ( b ) <NEWLINE> to [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> q = deque ( [ 1 ] ) <NEWLINE> while q : <NEWLINE> <INDENT> p = q . pop ( ) <NEWLINE> children = to [ p ] <NEWLINE> for child in children : <NEWLINE> <INDENT> if ans [ child ] is None : <NEWLINE> <INDENT> ans [ child ] = p <NEWLINE> q . appendleft ( child ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , ans [ 2 : ] ) ) ) <NEWLINE>
import numpy as np <NEWLINE> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> ans = X <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ps = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ps_sort = sorted ( ps ) <NEWLINE> <NL> ind_crit = N - 1 <NEWLINE> for p in ps_sort : <NEWLINE> <INDENT> if p >= X : <NEWLINE> <INDENT> ind_crit = ps_sort . index ( p ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if not ps_sort [ ind_crit ] == X : <NEWLINE> <INDENT> ans = X <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> diff += 1 <NEWLINE> if not X - diff in ps_sort : <NEWLINE> <INDENT> ans = X - diff <NEWLINE> break <NEWLINE> <DEDENT> if not X + diff in ps_sort : <NEWLINE> <INDENT> ans = X + diff <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> hyo = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> all_hyo = sum ( hyo ) <NEWLINE> <NL> hyo . sort ( reverse = True ) <NEWLINE> <NL> a = True <NEWLINE> <NL> for x in range ( m ) : <NEWLINE> <INDENT> if hyo [ x ] < all_hyo / 4 / m : <NEWLINE> <INDENT> a = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
primes = [ 0 , 0 ] + [ 1 ] * 50020 <NEWLINE> for i in range ( 2 , 225 ) : <NEWLINE> <INDENT> if primes [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , 50022 , i ) : <NEWLINE> <INDENT> primes [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m , o = n - 1 , n + 1 <NEWLINE> while not primes [ m ] : <NEWLINE> <INDENT> m -= 1 <NEWLINE> <DEDENT> while not primes [ o ] : <NEWLINE> <INDENT> o += 1 <NEWLINE> <DEDENT> print ( m , o ) <NEWLINE> <DEDENT>
import math <NEWLINE> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if H == 0 : <NEWLINE> <INDENT> H = 12 <NEWLINE> <DEDENT> elif M == 0 : <NEWLINE> <INDENT> M = 60 <NEWLINE> <DEDENT> L = M / 5 <NEWLINE> <NL> <NL> <NL> N = min ( abs ( L - H ) , abs ( H - L ) ) <NEWLINE> <NL> if L >= H : <NEWLINE> <INDENT> if M == 60 : <NEWLINE> <INDENT> M = 0 <NEWLINE> <DEDENT> S = 360 * N / 12 - ( 0.5 * M ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = 360 * N / 12 + ( 0.5 * M ) <NEWLINE> <NL> <NL> <DEDENT> ANS = A ** 2 + B ** 2 - ( 2 * A * B * math . cos ( math . radians ( S ) ) ) <NEWLINE> ANS = math . sqrt ( ANS ) <NEWLINE> print ( ANS ) <NEWLINE>
import math <NEWLINE> def getInput ( ) : <NEWLINE> <INDENT> return [ int ( i ) for i in input ( ) . rstrip ( ) . split ( <STRING> ) ] <NEWLINE> <NL> <NL> <DEDENT> N = getInput ( ) [ 0 ] <NEWLINE> sums = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> n = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> sums += math . gcd ( n , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sums ) <NEWLINE>
t = list ( input ( ) ) <NEWLINE> tl = len ( t ) <NEWLINE> <NL> for i in range ( tl ) : <NEWLINE> <INDENT> if t [ i ] != <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if tl == 1 : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> elif i == tl - 1 : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> elif t [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> elif t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> elif t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( t ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> popcount_X = X . count ( <STRING> ) <NEWLINE> X_ = int ( X , 2 ) <NEWLINE> <NL> X_mod_minus = X_ % ( popcount_X - 1 ) if popcount_X > 1 else - 1 <NEWLINE> X_mod_plus = X_ % ( popcount_X + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> popcount = popcount_X + 1 <NEWLINE> X_i = ( X_mod_plus + pow ( 2 , N - i - 1 , popcount ) ) % ( popcount ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if X_mod_minus == - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> popcount = popcount_X - 1 <NEWLINE> X_i = ( X_mod_minus - pow ( 2 , N - i - 1 , popcount ) ) % ( popcount ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> while X_i > 0 : <NEWLINE> <INDENT> X_i %= bin ( X_i ) . count ( <STRING> ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> def findProductSum ( A , n ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> array_sum = 0 <NEWLINE> for i in range ( 0 , n , 1 ) : <NEWLINE> <INDENT> array_sum = array_sum + A [ i ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> array_sum_square = array_sum * array_sum <NEWLINE> <NL> <COMMENT> <NL> individual_square_sum = 0 <NEWLINE> for i in range ( 0 , n , 1 ) : <NEWLINE> <INDENT> individual_square_sum += A [ i ] * A [ i ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> return ( array_sum_square - <NEWLINE> <INDENT> individual_square_sum ) <NEWLINE> <DEDENT> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> <NL> def modinv ( a , mod = 10 ** 9 + 7 ) : <NEWLINE> <INDENT> return pow ( a , mod - 2 , mod ) <NEWLINE> <NL> <DEDENT> print ( modinv ( 2 ) * int ( findProductSum ( a , n ) ) % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> if str ( i ) in s : <NEWLINE> <INDENT> first = s . index ( str ( i ) ) <NEWLINE> ss = s [ first + 1 : ] <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> if str ( j ) in ss : <NEWLINE> <INDENT> sec = ss . index ( str ( j ) ) <NEWLINE> <NL> for k in range ( 10 ) : <NEWLINE> <INDENT> if str ( k ) in ss [ sec + 1 : ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k , s = input ( ) . split ( ) <NEWLINE> k = int ( k ) <NEWLINE> s = int ( s ) <NEWLINE> cnt = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if z >= 0 and z <= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import numpy as np <NEWLINE> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) - 1 <NEWLINE> mem = { } <NEWLINE> <NL> c = 0 <COMMENT> <NEWLINE> cK = 0 <COMMENT> <NEWLINE> flg = True <NEWLINE> mem [ c ] = 0 <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> c = A [ c ] <COMMENT> <NEWLINE> if c in mem : <NEWLINE> <INDENT> T = k - mem [ c ] <NEWLINE> cK = k <NEWLINE> flg = False <NEWLINE> break <NEWLINE> <DEDENT> mem [ c ] = k <NEWLINE> <NL> <DEDENT> if flg : <NEWLINE> <INDENT> print ( c + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> iterN = int ( np . mod ( int ( K - cK ) , int ( T ) ) ) <NEWLINE> for i in range ( iterN ) : <NEWLINE> <INDENT> c = A [ c ] <NEWLINE> <DEDENT> print ( c + 1 ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> if x - i not in p : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> break <NEWLINE> <DEDENT> elif x + i not in p : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_list = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] , reverse = True ) <NEWLINE> <NL> if a_list [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> s = 10 ** 18 <NEWLINE> for a in a_list : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > s : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> k = K + 1 <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k ) : <NEWLINE> <INDENT> for b in range ( a , k ) : <NEWLINE> <INDENT> for c in range ( b , k ) : <NEWLINE> <INDENT> m = math . gcd ( a , b ) <NEWLINE> o = math . gcd ( m , c ) <NEWLINE> if a == b and b == c : <NEWLINE> <INDENT> n = o <NEWLINE> <DEDENT> elif a == b or b == c : <NEWLINE> <INDENT> n = o * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = o * 6 <NEWLINE> <NL> <DEDENT> ans += n <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> alpha = [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] <NEWLINE> d = { i : [ { 0 } , { 0 } , { 0 } , { 0 } , { 0 } , { 0 } , { 0 } , { 0 } , { 0 } , { 0 } ] for i in alpha } <NEWLINE> ans = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s not in d [ s [ 0 ] ] [ len ( s ) - 1 ] : <NEWLINE> <INDENT> d [ s [ 0 ] ] [ len ( s ) - 1 ] |= { s } <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import product <NEWLINE> <NL> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> CA = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> cost = - 1 <NEWLINE> for cand in product ( ( 0 , 1 ) , repeat = n ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> scores = [ 0 ] * m <NEWLINE> for bought , ca in zip ( cand , CA ) : <NEWLINE> <INDENT> if not bought : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> scores [ i - 1 ] += ca [ i ] <NEWLINE> <DEDENT> tmp += ca [ 0 ] <NEWLINE> <DEDENT> if min ( scores ) >= x and ( cost == - 1 or tmp < cost ) : <NEWLINE> <INDENT> cost = tmp <NEWLINE> <DEDENT> <DEDENT> print ( cost ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = [ ] <NEWLINE> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> c . sort ( ) <NEWLINE> def binary_search1 ( list , item ) : <NEWLINE> <INDENT> low = 0 <NEWLINE> high = len ( list ) - 1 <NEWLINE> <NL> while low <= high : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> guess = list [ mid ] <NEWLINE> if low == high : <NEWLINE> <INDENT> if guess >= item : <NEWLINE> <INDENT> return mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return mid + 1 <NEWLINE> <DEDENT> <DEDENT> if guess >= item : <NEWLINE> <INDENT> high = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def binary_search2 ( list , item ) : <NEWLINE> <INDENT> low = 0 <NEWLINE> high = len ( list ) - 1 <NEWLINE> <NL> while low <= high : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> guess = list [ mid ] <NEWLINE> if low == high : <NEWLINE> <INDENT> if guess > item : <NEWLINE> <INDENT> return n - mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return n - 1 - mid <NEWLINE> <DEDENT> <DEDENT> if guess > item : <NEWLINE> <INDENT> high = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += binary_search2 ( c , b [ i ] ) * binary_search1 ( a , b [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for _ in range ( M ) ] ) <NEWLINE> INF = 1000000007 <NEWLINE> <NL> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if 1 not in a : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> dp [ i ] %= INF <NEWLINE> <NL> <DEDENT> print ( dp [ N ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = A [ i ] <NEWLINE> ans += ( tmp // 2 ) <NEWLINE> if i < N - 1 and tmp % 2 and A [ i + 1 ] > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> A [ i + 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
listA = [ ] <NEWLINE> listOP = [ ] <NEWLINE> listB = [ ] <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> a , op , b = input ( ) . split ( ) <NEWLINE> listA . append ( int ( a ) ) <NEWLINE> listOP . append ( op ) <NEWLINE> listB . append ( int ( b ) ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> del listA [ len ( listA ) - 1 ] <NEWLINE> del listOP [ len ( listOP ) - 1 ] <NEWLINE> del listB [ len ( listB ) - 1 ] <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> while count <= len ( listA ) - 1 : <NEWLINE> <INDENT> if listOP [ count ] == <STRING> : <NEWLINE> <INDENT> print ( listA [ count ] + listB [ count ] ) <NEWLINE> <DEDENT> elif listOP [ count ] == <STRING> : <NEWLINE> <INDENT> print ( listA [ count ] - listB [ count ] ) <NEWLINE> <DEDENT> elif listOP [ count ] == <STRING> : <NEWLINE> <INDENT> print ( listA [ count ] * listB [ count ] ) <NEWLINE> <DEDENT> elif listOP [ count ] == <STRING> : <NEWLINE> <INDENT> print ( listA [ count ] // listB [ count ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> flag = 0 <NEWLINE> if ( 0 in A ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if ( ans * A [ i ] > 10 ** 18 ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> <DEDENT> <DEDENT> if ( flag == 1 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ln = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 1 <NEWLINE> <NL> for i in sorted ( ln ) : <NEWLINE> <INDENT> if a > 10 ** 18 or a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = a * i <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> lists = [ ] <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> mid = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> lists . append ( math . gcd ( mid , k ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( lists ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( N , B - 1 ) <NEWLINE> print ( int ( A * x / B ) ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( a , gcd ( b , c ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def solve ( k ) : <NEWLINE> <INDENT> def gcd ( a , b ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def cc_export ( ) : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> cc_export ( ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> from my_module import solve <NEWLINE> print ( solve ( int ( input ( ) ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def dfs ( x , y , symbol , land ) : <NEWLINE> <INDENT> if land [ y ] [ x ] != <STRING> : <NEWLINE> <INDENT> return ( [ land [ y ] [ x ] ] if not str ( land [ y ] [ x ] ) . isnumeric ( ) else False ) , 0 <NEWLINE> <DEDENT> land [ y ] [ x ] = symbol <NEWLINE> count = 1 <NEWLINE> dxdy = [ ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ] <NEWLINE> <NL> owner_list = [ ] <NEWLINE> for dx , dy in dxdy : <NEWLINE> <INDENT> if 0 <= x + dx < len ( land [ 0 ] ) and 0 <= y + dy < len ( land ) : <NEWLINE> <INDENT> ret , c = dfs ( x + dx , y + dy , symbol , land ) <NEWLINE> count += c <NEWLINE> <NL> if ret is not False : <NEWLINE> <INDENT> owner_list += ret <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ( list ( set ( owner_list ) ) , count ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if w == 0 and h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> land = [ list ( input ( ) ) for i in range ( 0 , h ) ] <NEWLINE> <NL> symbol = 0 <NEWLINE> count_dict = { <STRING> : 0 , <STRING> : 0 } <NEWLINE> <NL> for y in range ( h ) : <NEWLINE> <INDENT> for x in range ( w ) : <NEWLINE> <INDENT> if land [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> ret , count = dfs ( x , y , symbol , land ) <NEWLINE> if len ( ret ) == 1 : <NEWLINE> <INDENT> count_dict [ ret [ 0 ] ] += count <NEWLINE> <DEDENT> symbol += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count_dict [ <STRING> ] , count_dict [ <STRING> ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A_cnt = [ 0 for i in range ( N ) ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> A_cnt [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( A_cnt [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> X = int ( input ( ) ) <NEWLINE> <NL> def decompose ( n ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> half = math . floor ( math . sqrt ( n ) ) <NEWLINE> i = 2 <NEWLINE> while i <= half : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> result . append ( i ) <NEWLINE> n //= i <NEWLINE> half = math . floor ( math . sqrt ( n ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> if n > 1 : <NEWLINE> <INDENT> result . append ( n ) <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> facts = decompose ( X ) <NEWLINE> <NL> fact_table = { } <NEWLINE> for f in facts : <NEWLINE> <INDENT> if f not in fact_table : <NEWLINE> <INDENT> fact_table [ f ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fact_table [ f ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> facts = list ( fact_table . items ( ) ) <NEWLINE> facts . sort ( ) <NEWLINE> <NL> def bisearch_smallest ( f , s , e = None ) : <NEWLINE> <INDENT> if e == None : <NEWLINE> <INDENT> e = s - 1 <NEWLINE> s = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e -= 1 <NEWLINE> <NL> <DEDENT> while s < e : <NEWLINE> <INDENT> m = ( s + e ) // 2 <NEWLINE> if f ( m ) : <NEWLINE> <INDENT> e = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = m + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if s == e and f ( s ) : <NEWLINE> <INDENT> return s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( num , n ) : <NEWLINE> <INDENT> if n >= len ( facts ) : <NEWLINE> <INDENT> m = bisearch_smallest ( lambda A : 5 * A ** 4 - 5 * ( A - num ) ** 4 >= 0 , 0 , 10 ** 9 ) <NEWLINE> i = bisearch_smallest ( lambda A : A ** 5 - ( A - num ) ** 5 <= X , 0 , m + 1 ) <NEWLINE> j = bisearch_smallest ( lambda A : A ** 5 - ( A - num ) ** 5 >= X , m - 1 , 10 ** 9 ) <NEWLINE> <NL> if i ** 5 - ( i - num ) ** 5 == X : <NEWLINE> <INDENT> return i , i - num <NEWLINE> <DEDENT> if j ** 5 - ( j - num ) ** 5 == X : <NEWLINE> <INDENT> return j , j - num <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> f , c = facts [ n ] <NEWLINE> for i in range ( c + 1 ) : <NEWLINE> <INDENT> ret = find ( num , n + 1 ) <NEWLINE> if ret != None : <NEWLINE> <INDENT> return ret <NEWLINE> <DEDENT> num *= f <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <DEDENT> A , B = find ( 1 , 0 ) <NEWLINE> <NL> <NL> print ( A , B ) <NEWLINE>
import sys <NEWLINE> import copy <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> <NL> H = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( int ( math . log2 ( H ) ) + 1 ) : <NEWLINE> <INDENT> cnt += 2 ** i <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
s = input ( ) <NEWLINE> lst = s . split ( ) <NEWLINE> <NL> ex1 = int ( lst [ 0 ] ) <NEWLINE> ex2 = int ( lst [ 1 ] ) <NEWLINE> ret = <STRING> <NEWLINE> <NL> for i in range ( ex1 + 1 ) : <NEWLINE> <INDENT> if 4 * ( ex1 - i ) + 2 * i == ex2 : <NEWLINE> <INDENT> ret = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n * a >= b : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n * a ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> def ii ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def mi ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def li2 ( N ) : return [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> def dp2 ( ini , i , j ) : return [ [ ini ] * i for i2 in range ( j ) ] <NEWLINE> def dp3 ( ini , i , j , k ) : return [ [ [ ini ] * i for i2 in range ( j ) ] for i3 in range ( k ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N , * D = mi ( ) <NEWLINE> S = [ sys . stdin . readline ( ) [ : 2 ] for _ in range ( N ) ] <NEWLINE> ans = [ 0 ] * N <NEWLINE> <NL> def cv ( m ) : <NEWLINE> <INDENT> if m == <STRING> : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if m == <STRING> : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if m == <STRING> : <NEWLINE> <INDENT> return 2 <NEWLINE> <NL> <DEDENT> <DEDENT> def dfs ( i , A , B , C , ans ) : <NEWLINE> <INDENT> if A < 0 or B < 0 or C < 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if i == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for m in ans : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> <STRING> <NEWLINE> if S [ i ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> dfs ( i + 1 , A + 1 , B - 1 , C , ans ) <NEWLINE> ans [ i ] = <STRING> <NEWLINE> dfs ( i + 1 , A - 1 , B + 1 , C , ans ) <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> dfs ( i + 1 , A , B + 1 , C - 1 , ans ) <NEWLINE> ans [ i ] = <STRING> <NEWLINE> dfs ( i + 1 , A , B - 1 , C + 1 , ans ) <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> dfs ( i + 1 , A + 1 , B , C - 1 , ans ) <NEWLINE> ans [ i ] = <STRING> <NEWLINE> dfs ( i + 1 , A - 1 , B , C + 1 , ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 , D [ 0 ] , D [ 1 ] , D [ 2 ] , ans ) <NEWLINE> print ( <STRING> ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> h . sort ( ) <NEWLINE> result = 10 ** 9 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> result = min ( result , h [ i + k - 1 ] - h [ i ] ) <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> v = [ ] <NEWLINE> v = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> v . sort ( ) <NEWLINE> for x in v : <NEWLINE> <INDENT> ans = ans * x <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import copy <NEWLINE> <NL> <COMMENT> <NL> def get_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def get_string ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def get_int_list ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def get_string_list ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def get_int_multi ( ) : <COMMENT> <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def get_string_char_list ( ) : <NEWLINE> <INDENT> return list ( str ( input ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <STRING> <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> n , k = get_int_multi ( ) <NEWLINE> a_list = get_int_list ( ) <NEWLINE> <NL> p_list = [ ] <NEWLINE> m_list = [ ] <NEWLINE> for num in a_list : <NEWLINE> <INDENT> if num > 0 : <NEWLINE> <INDENT> p_list . append ( num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m_list . append ( num ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> p_list . sort ( ) <NEWLINE> m_list . sort ( reverse = True ) <NEWLINE> <NL> <NL> if k % 2 == 1 : <NEWLINE> <INDENT> if ( len ( p_list ) > 0 ) : <NEWLINE> <INDENT> ans = p_list . pop ( ) <NEWLINE> k -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m_list . sort ( ) <NEWLINE> ans = m_list . pop ( ) <NEWLINE> k -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <NL> <DEDENT> nokori = k <NEWLINE> while nokori > 0 : <NEWLINE> <INDENT> if len ( p_list ) == 1 and len ( m_list ) == 1 : <NEWLINE> <INDENT> ans = ans * p_list . pop ( ) * m_list [ 0 ] <NEWLINE> del m_list [ 0 ] <NEWLINE> nokori -= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( p_list ) >= 2 : <NEWLINE> <INDENT> pval = p_list [ - 1 ] * p_list [ - 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pval = 0 <NEWLINE> <NL> <DEDENT> if len ( m_list ) >= 2 : <NEWLINE> <INDENT> mval = m_list [ - 1 ] * m_list [ - 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mval = 0 <NEWLINE> <NL> <DEDENT> if pval > mval : <NEWLINE> <INDENT> p_list . pop ( ) <NEWLINE> p_list . pop ( ) <NEWLINE> ans = ans * pval % 1000000007 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m_list . pop ( ) <NEWLINE> m_list . pop ( ) <NEWLINE> ans = ans * mval % 1000000007 <NEWLINE> <DEDENT> nokori -= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans % 1000000007 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> M = { } <NEWLINE> for a in A : <NEWLINE> <INDENT> M [ a ] = M . get ( a , 0 ) + 1 <NEWLINE> <NL> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> print ( M . get ( n + 1 , 0 ) ) <NEWLINE> <DEDENT>
MOD = ( 10 ** 9 ) + 7 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> negs = [ - x for x in a if x < 0 ] <NEWLINE> non_negs = [ x for x in a if x >= 0 ] <NEWLINE> <NL> if len ( non_negs ) == 0 and k % 2 == 1 : <NEWLINE> <INDENT> negs . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans = ans * - negs [ i ] % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> negs_p , non_negs_p = 0 , 0 <NEWLINE> <NL> negs . sort ( reverse = True ) <NEWLINE> non_negs . sort ( reverse = True ) <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> if negs_p == len ( negs ) : <NEWLINE> <INDENT> non_negs_p += 1 <NEWLINE> <DEDENT> elif non_negs_p == len ( non_negs ) : <NEWLINE> <INDENT> negs_p += 1 <NEWLINE> <DEDENT> elif negs [ negs_p ] > non_negs [ non_negs_p ] : <NEWLINE> <INDENT> negs_p += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> non_negs_p += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if negs_p % 2 == 0 or k == n : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( negs_p ) : <NEWLINE> <INDENT> ans = ans * - negs [ i ] % MOD <NEWLINE> <DEDENT> for i in range ( non_negs_p ) : <NEWLINE> <INDENT> ans = ans * non_negs [ i ] % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if negs_p == len ( negs ) or non_negs_p == 0 : <NEWLINE> <INDENT> negs_p -= 1 <NEWLINE> non_negs_p += 1 <NEWLINE> ans = 1 <NEWLINE> for i in range ( negs_p ) : <NEWLINE> <INDENT> ans = ans * - negs [ i ] % MOD <NEWLINE> <DEDENT> for i in range ( non_negs_p ) : <NEWLINE> <INDENT> ans = ans * non_negs [ i ] % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if non_negs_p == len ( non_negs ) or negs_p == 0 : <NEWLINE> <INDENT> negs_p += 1 <NEWLINE> non_negs_p -= 1 <NEWLINE> ans = 1 <NEWLINE> for i in range ( negs_p ) : <NEWLINE> <INDENT> ans = ans * - negs [ i ] % MOD <NEWLINE> <DEDENT> for i in range ( non_negs_p ) : <NEWLINE> <INDENT> ans = ans * non_negs [ i ] % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> a = negs [ negs_p - 1 ] <NEWLINE> b = negs [ negs_p ] <NEWLINE> c = non_negs [ non_negs_p - 1 ] <NEWLINE> d = non_negs [ non_negs_p ] <NEWLINE> <NL> if a * b > c * d : <NEWLINE> <INDENT> negs_p += 1 <NEWLINE> non_negs_p -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> negs_p -= 1 <NEWLINE> non_negs_p += 1 <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( negs_p ) : <NEWLINE> <INDENT> ans = ans * - negs [ i ] % MOD <NEWLINE> <DEDENT> for i in range ( non_negs_p ) : <NEWLINE> <INDENT> ans = ans * non_negs [ i ] % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from math import ceil , floor , comb , factorial , gcd , pow , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> def bfs ( ) : <NEWLINE> <INDENT> que = deque ( ) <NEWLINE> que . append ( [ 0 , 0 ] ) <NEWLINE> if s [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> d [ 0 ] [ 0 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ 0 ] [ 0 ] = 0 <NEWLINE> <NL> <DEDENT> while que : <NEWLINE> <INDENT> p = que . popleft ( ) <NEWLINE> if p [ 0 ] == h - 1 and p [ 1 ] == w - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( 2 ) : <NEWLINE> <INDENT> ny = p [ 0 ] + dy [ i ] <NEWLINE> nx = p [ 1 ] + dx [ i ] <NEWLINE> if 0 <= ny < h and 0 <= nx < w : <NEWLINE> <INDENT> if s [ p [ 0 ] ] [ p [ 1 ] ] == <STRING> and s [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> if d [ ny ] [ nx ] > d [ p [ 0 ] ] [ p [ 1 ] ] + 1 : <NEWLINE> <INDENT> d [ ny ] [ nx ] = d [ p [ 0 ] ] [ p [ 1 ] ] + 1 <NEWLINE> que . append ( [ ny , nx ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if d [ ny ] [ nx ] > d [ p [ 0 ] ] [ p [ 1 ] ] : <NEWLINE> <INDENT> d [ ny ] [ nx ] = d [ p [ 0 ] ] [ p [ 1 ] ] <NEWLINE> que . append ( [ ny , nx ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return d [ h - 1 ] [ w - 1 ] <NEWLINE> <NL> <DEDENT> h , w = MAP ( ) <NEWLINE> s = [ input ( ) for i in range ( h ) ] <NEWLINE> d = [ [ inf ] * w for i in range ( h ) ] <NEWLINE> <NL> dy = [ 1 , 0 ] <NEWLINE> dx = [ 0 , 1 ] <NEWLINE> <NL> print ( bfs ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> XYH_list = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> XYH_list = sorted ( XYH_list , key = lambda x : x [ 2 ] , reverse = True ) <NEWLINE> <NL> for xi in range ( 0 , 101 ) : <NEWLINE> <INDENT> for yi in range ( 0 , 101 ) : <NEWLINE> <INDENT> tmpH = 0 <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> x , y , h = XYH_list [ k ] <NEWLINE> if k == 0 : <NEWLINE> <INDENT> tmpH = h + abs ( x - xi ) + abs ( y - yi ) <NEWLINE> <DEDENT> if h == max ( ( tmpH - abs ( x - xi ) - abs ( y - yi ) ) , 0 ) : <NEWLINE> <INDENT> if k == N - 1 : <NEWLINE> <INDENT> ans = [ str ( xi ) , str ( yi ) , str ( tmpH ) ] <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> near_max = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> near_max [ a - 1 ] = max ( near_max [ a - 1 ] , H [ b - 1 ] ) <NEWLINE> near_max [ b - 1 ] = max ( near_max [ b - 1 ] , H [ a - 1 ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if near_max [ i ] < H [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , D , E , F = ( int ( T ) for T in input ( ) . split ( ) ) <NEWLINE> SugM = 0 <NEWLINE> WatM = 100 * A <NEWLINE> for TA in range ( 0 , ( F // 100 ) + 1 ) : <NEWLINE> <INDENT> for TB in range ( 0 , ( F // 100 ) + 1 ) : <NEWLINE> <INDENT> if TA == TB == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Water = TA * 100 * A + TB * 100 * B <NEWLINE> RestW = F - Water <NEWLINE> if RestW >= 0 : <NEWLINE> <INDENT> for TC in range ( 0 , RestW + 1 ) : <NEWLINE> <INDENT> for TD in range ( 0 , RestW + 1 ) : <NEWLINE> <INDENT> Suger = TC * C + TD * D <NEWLINE> RestS = RestW - Suger <NEWLINE> if RestS >= 0 and Water >= ( 100 * Suger ) / E : <NEWLINE> <INDENT> if Suger / ( Suger + Water ) > SugM / ( SugM + WatM ) : <NEWLINE> <INDENT> SugM = Suger <NEWLINE> WatM = Water <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . format ( WatM + SugM , SugM ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = np . array ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> mod_sum = 0 <NEWLINE> a_sum = sum ( a ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a_sum -= a [ i ] <NEWLINE> mod_sum += ( a [ i ] % mod ) * ( a_sum % mod ) % mod <NEWLINE> <NL> <DEDENT> print ( mod_sum % mod ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 + 1 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> V = [ i for i in range ( N ) ] <NEWLINE> E = [ [ ] for i in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> E [ a - 1 ] . append ( b - 1 ) <NEWLINE> E [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> visited = [ False for _ in range ( N ) ] <NEWLINE> def dfs ( v , parent , origin ) : <NEWLINE> <INDENT> visited [ v ] = True <NEWLINE> for e in E [ v ] : <NEWLINE> <INDENT> if e == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if visited [ e ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> V [ e ] = origin <NEWLINE> dfs ( e , v , origin ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if visited [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( i , - 1 , i ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i , v in enumerate ( V ) : <NEWLINE> <INDENT> if i == v : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count - 1 ) <NEWLINE> <NL> <NL> <NL>
def n0 ( ) : return int ( input ( ) ) <NEWLINE> def n1 ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def n2 ( n ) : return [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def n3 ( n ) : return [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( n ) ] <NEWLINE> <NL> from collections import defaultdict <NEWLINE> n = n0 ( ) <NEWLINE> a = [ 0 ] <NEWLINE> a . extend ( n1 ( ) ) <NEWLINE> <NL> m1 = [ i + a [ i ] for i in range ( n + 1 ) ] <NEWLINE> m2 = [ j - a [ j ] for j in range ( n + 1 ) ] <NEWLINE> <NL> d1 = defaultdict ( list ) <NEWLINE> d2 = defaultdict ( list ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> d1 [ m1 [ i ] ] . append ( i ) <NEWLINE> d2 [ m2 [ i ] ] . append ( i ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in d1 : <NEWLINE> <INDENT> ans += len ( d1 [ i ] ) * len ( d2 [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - x - y <= k : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r ** 2 * math . pi , r * 2 * math . pi ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import os <NEWLINE> from math import gcd <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> t = gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> result += gcd ( t , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> lResult = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> gain = list ( set ( lResult ) ) <NEWLINE> <NL> print ( len ( gain ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ input ( ) for i in range ( n ) ] <NEWLINE> print ( len ( set ( a ) ) ) <NEWLINE>
K , N = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dist = [ ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> dist . append ( a [ i + 1 ] - a [ i ] ) <NEWLINE> <DEDENT> dist . append ( a [ 0 ] + ( K - a [ - 1 ] ) ) <NEWLINE> <NL> ans = sum ( dist ) - max ( dist ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 1 <NEWLINE> flag = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> res *= i <NEWLINE> if i == 0 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> res = 0 <NEWLINE> <DEDENT> if ( res > 1000000000000000000 ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in l : <NEWLINE> <INDENT> if ( i == 0 ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> res = 0 <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( res ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def test ( ) : <NEWLINE> <INDENT> line = input ( ) . rstrip ( ) <NEWLINE> list = line . split ( <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> a = int ( list [ 0 ] ) <NEWLINE> b = int ( list [ 1 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return - 1 <NEWLINE> <NL> <DEDENT> if ( a > b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a < b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a == b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> test ( ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> import sys <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P . sort ( ) <NEWLINE> notP = [ i for i in range ( 0 , 102 ) if i not in P ] <NEWLINE> <NL> ans = notP [ 0 ] <NEWLINE> min_delta = abs ( x - ans ) <NEWLINE> <NL> for p in notP : <NEWLINE> <INDENT> delta = abs ( x - p ) <NEWLINE> if delta < min_delta : <NEWLINE> <INDENT> ans = p <NEWLINE> min_delta = abs ( x - ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> E = C * D // math . gcd ( C , D ) <NEWLINE> def num_mult ( fro , to , mult ) : <NEWLINE> <INDENT> goal = to // mult <NEWLINE> if fro % mult == 0 : <NEWLINE> <INDENT> start = fro // mult <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start = fro // mult + 1 <NEWLINE> <NL> <DEDENT> return goal - start + 1 <NEWLINE> <NL> <DEDENT> ans = B - A + 1 <NEWLINE> <COMMENT> <NL> ans -= num_mult ( A , B , C ) <NEWLINE> <COMMENT> <NL> ans -= num_mult ( A , B , D ) <NEWLINE> <COMMENT> <NL> ans += num_mult ( A , B , E ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> S1 = [ ] <COMMENT> <NEWLINE> S2 = [ ] <COMMENT> <NEWLINE> A = 0 <COMMENT> <NEWLINE> <NL> inp = input ( ) <NEWLINE> <COMMENT> <NL> for i in range ( len ( inp ) ) : <NEWLINE> <INDENT> if inp [ i ] == chr ( 0x5c ) : <COMMENT> <NEWLINE> <INDENT> S1 . append ( i ) <NEWLINE> S2 . append ( [ i , 0 ] ) <NEWLINE> <DEDENT> elif inp [ i ] == chr ( 0x2f ) : <COMMENT> <NEWLINE> <INDENT> if len ( S1 ) : <NEWLINE> <INDENT> j = S1 . pop ( ) <NEWLINE> d = i - j <NEWLINE> A += d <NEWLINE> k = d <NEWLINE> while len ( S2 ) : <NEWLINE> <INDENT> p = S2 . pop ( ) <NEWLINE> if p [ 1 ] > 0 : <NEWLINE> <INDENT> k += p [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S2 . append ( [ p [ 0 ] , k ] ) <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> L = [ ] <NEWLINE> for p in S2 : <NEWLINE> <INDENT> if p [ 1 ] > 0 : <NEWLINE> <INDENT> L . append ( p [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( A ) <NEWLINE> if A > 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( len ( L ) , <STRING> . join ( map ( str , L ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> Hs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> ans = [ True for _ in range ( N ) ] <NEWLINE> <NL> for a in arr : <NEWLINE> <INDENT> f , s = a <NEWLINE> H1 = Hs [ f - 1 ] <NEWLINE> H2 = Hs [ s - 1 ] <NEWLINE> if H1 == H2 : <NEWLINE> <INDENT> ans [ f - 1 ] = False <NEWLINE> ans [ s - 1 ] = False <NEWLINE> <DEDENT> elif H1 < H2 : <NEWLINE> <INDENT> ans [ f - 1 ] = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ s - 1 ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( list ( filter ( lambda x : x , ans ) ) ) ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LA = [ 0 ] <NEWLINE> LB = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> C = LA [ i ] + A [ i ] <NEWLINE> if C > K : <NEWLINE> <INDENT> N = i <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> LA . append ( C ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( M ) : <NEWLINE> <INDENT> C = LB [ j ] + B [ j ] <NEWLINE> if C > K : <NEWLINE> <INDENT> M = j <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> LB . append ( C ) <NEWLINE> <DEDENT> <DEDENT> r = N <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> u = 0 <NEWLINE> for j in range ( r - N + i , M + 1 ) : <NEWLINE> <INDENT> if LA [ N - i ] + LB [ j ] > K : <NEWLINE> <INDENT> r = max ( r , N - i + j - 1 ) <COMMENT> <NEWLINE> u = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if u == 0 : <NEWLINE> <INDENT> r = max ( r , N - i + M ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = sorted ( list ( input ( ) for i in range ( N ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if ( S [ i - 1 ] != S [ i ] ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ml = [ 0 ] * n <NEWLINE> pl = [ 0 ] * n <NEWLINE> <NL> out = 0 <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if ( i + a [ i ] < n ) : <NEWLINE> <INDENT> pl [ i + a [ i ] ] += 1 <NEWLINE> <DEDENT> if ( i - a [ i ] >= 0 ) : <NEWLINE> <INDENT> ml [ i - a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> out += pl [ i ] * ml [ i ] <NEWLINE> <NL> <DEDENT> print ( out ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , M = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> A = [ int ( input ( ) ) for i in range ( M ) ] <NEWLINE> isBroken = [ False ] * ( N + 1 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> isBroken [ i ] = True <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> if M >= 1 : <NEWLINE> <INDENT> temp = A [ 0 ] <NEWLINE> for a in A [ 1 : ] : <NEWLINE> <INDENT> if a - 1 == temp : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> temp = a <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> memo = [ 0 ] * ( N + 2 ) <NEWLINE> <NL> def rec ( i ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if i < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if isBroken [ i ] : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> if memo [ i ] == 0 : <NEWLINE> <INDENT> count1 = rec ( i - 1 ) % 1000000007 <NEWLINE> count2 = rec ( i - 2 ) % 1000000007 <NEWLINE> memo [ i ] = ( count1 + count2 ) % 1000000007 <NEWLINE> <DEDENT> return memo [ i ] <NEWLINE> <DEDENT> return rec ( N ) <NEWLINE> <NL> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> x = input ( ) . split ( <STRING> ) <NEWLINE> n = int ( x [ 0 ] ) <NEWLINE> m = int ( x [ 1 ] ) <NEWLINE> <NL> x = input ( ) . split ( <STRING> ) <NEWLINE> heights = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> heights [ i ] = int ( x [ i ] ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> ways = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> x = input ( ) . split ( <STRING> ) <NEWLINE> ways . append ( [ int ( x [ 0 ] ) - 1 , int ( x [ 1 ] ) - 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ways_dict = { } <NEWLINE> <NL> bool_array = [ 1 ] * n <NEWLINE> <NL> for way in ways : <NEWLINE> <INDENT> if heights [ way [ 0 ] ] > heights [ way [ 1 ] ] : <NEWLINE> <INDENT> bool_array [ way [ 1 ] ] = 0 <NEWLINE> <DEDENT> elif heights [ way [ 0 ] ] == heights [ way [ 1 ] ] : <NEWLINE> <INDENT> bool_array [ way [ 0 ] ] = 0 <NEWLINE> bool_array [ way [ 1 ] ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bool_array [ way [ 0 ] ] = 0 <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> for higher_idx , ways in ways_dict . items ( ) : <NEWLINE> <INDENT> for way in ways_dict [ higher_idx ] : <NEWLINE> <INDENT> bool_array [ way ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( np . array ( bool_array ) . sum ( ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> X = list ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> dic = { } <NEWLINE> bn00 = X . count ( <STRING> ) <NEWLINE> x00 = int ( <STRING> . join ( X ) , 2 ) <NEWLINE> aa = x00 % ( bn00 + 1 ) <NEWLINE> if bn00 - 1 == 0 : <NEWLINE> <INDENT> bb = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bb = x00 % ( bn00 - 1 ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> b = int ( X [ i ] ) & 1 <NEWLINE> bn = b ^ 1 <NEWLINE> if bn : <NEWLINE> <INDENT> bn0 = bn00 + 1 <NEWLINE> x0 = aa <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bn0 = bn00 - 1 <NEWLINE> x0 = bb <NEWLINE> <DEDENT> if bn0 == 0 : <COMMENT> <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> if b : <COMMENT> <NEWLINE> <INDENT> xi = x0 - b * pow ( 2 , N - 1 - i , bn0 ) <NEWLINE> <DEDENT> if bn : <NEWLINE> <INDENT> xi = x0 + bn * pow ( 2 , N - 1 - i , bn0 ) <NEWLINE> <DEDENT> xi %= bn0 <NEWLINE> num = xi <NEWLINE> count = 1 <NEWLINE> while num > 0 : <NEWLINE> <INDENT> p = format ( num , <STRING> ) . count ( <STRING> ) <COMMENT> <NEWLINE> num = num % p <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
<COMMENT> <NL> class UnionFind ( ) : <COMMENT> <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> bridges = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> answer_list = [ ] <NEWLINE> total = N * ( N - 1 ) // 2 <NEWLINE> answer_list . append ( total ) <NEWLINE> <COMMENT> <NL> union_find = UnionFind ( N ) <NEWLINE> for i in range ( M - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> A , B = bridges [ i ] <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> if not union_find . same ( A , B ) : <NEWLINE> <INDENT> total -= union_find . size ( A ) * union_find . size ( B ) <NEWLINE> union_find . union ( A , B ) <NEWLINE> <NL> <DEDENT> answer_list . append ( total ) <NEWLINE> <NL> <DEDENT> len_answer = len ( answer_list ) <NEWLINE> for i in range ( len_answer - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> print ( answer_list [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> <NL> n , m = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> a = [ [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] for _ in range ( n ) ] <NEWLINE> b = [ [ int ( stdin . readline ( ) . rstrip ( ) ) ] for _ in range ( m ) ] <NEWLINE> c = [ [ 0 ] for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> c [ i ] [ 0 ] += ( a [ i ] [ j ] * b [ j ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( * c [ i ] ) <NEWLINE> <DEDENT>
from heapq import heappush , heappop <NEWLINE> <NL> heap = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> l = input ( ) <NEWLINE> if l . startswith ( <STRING> ) : <NEWLINE> <INDENT> heappush ( heap , - int ( l . split ( ) [ 1 ] ) ) <NEWLINE> <DEDENT> elif l [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( - heappop ( heap ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> S = input ( ) [ : : - 1 ] <NEWLINE> MOD = 2019 <NEWLINE> <NL> X = [ 0 ] <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> X . append ( ( X [ - 1 ] + int ( s ) * pow ( 10 , i , MOD ) ) % MOD ) <NEWLINE> <NL> <DEDENT> C = Counter ( X ) <NEWLINE> ans = 0 <NEWLINE> for v in C . values ( ) : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num0 = 0 <NEWLINE> num1 = sum ( a ) <NEWLINE> <NL> ans = 10 ** 10 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> num0 += a [ i ] <NEWLINE> num1 -= a [ i ] <NEWLINE> if ans > abs ( num1 - num0 ) : <NEWLINE> <INDENT> ans = abs ( num1 - num0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math , itertools , fractions , heapq , collections , bisect , sys , queue , copy <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = LI ( ) <NEWLINE> l = LI ( ) <NEWLINE> <NL> ind = 0 <NEWLINE> nxt = k <NEWLINE> ans = [ ] <NEWLINE> for _ in range ( n - k ) : <NEWLINE> <INDENT> if l [ ind ] < l [ nxt ] : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> ind += 1 <NEWLINE> nxt += 1 <NEWLINE> <NL> <DEDENT> for x in ans : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE> <COMMENT> <NL>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> n = 0 <NEWLINE> m = 0 <NEWLINE> res = 0 <NEWLINE> List1 = [ <STRING> ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> n = math . gcd ( i , j ) <NEWLINE> if List1 [ n ] == <STRING> : <NEWLINE> <INDENT> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> m += math . gcd ( n , k ) <NEWLINE> <DEDENT> res += m <NEWLINE> List1 [ n ] = m <NEWLINE> m = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += List1 [ n ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> import numpy as np <NEWLINE> from collections import Counter <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , * a = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> if 1 in a : <NEWLINE> <INDENT> count1 = a . count ( 1 ) <NEWLINE> if count1 == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> a = np . array ( a ) <NEWLINE> maxa = a . max ( ) <NEWLINE> seq = np . zeros ( maxa + 1 , np . int32 ) <NEWLINE> u , cnt = np . unique ( a , return_counts = True ) <NEWLINE> for ue , cnte in zip ( u , cnt ) : <NEWLINE> <INDENT> if cnte == 1 : <NEWLINE> <INDENT> seq [ ue ] = 1 <NEWLINE> <DEDENT> <DEDENT> for ae in a : <NEWLINE> <INDENT> t = ae * 2 <NEWLINE> while t <= maxa : <NEWLINE> <INDENT> seq [ t ] = 0 <NEWLINE> t += ae <NEWLINE> <DEDENT> <DEDENT> r = seq . sum ( ) <NEWLINE> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = abs ( x ) <NEWLINE> <NL> if x > k * d : <NEWLINE> <INDENT> print ( x - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = int ( x / d ) <NEWLINE> x = x - f * d <NEWLINE> g = ( k - f ) % 2 <NEWLINE> if g == 1 : <NEWLINE> <INDENT> x = x - d <NEWLINE> <DEDENT> print ( abs ( x ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> money = 1000 <NEWLINE> stock = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> money += stock * A [ i ] <NEWLINE> break <NEWLINE> <DEDENT> if A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> tmp_stock = money // A [ i ] <NEWLINE> stock += tmp_stock <NEWLINE> money -= tmp_stock * A [ i ] <NEWLINE> <DEDENT> elif A [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> money += stock * A [ i ] <NEWLINE> stock = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> print ( money ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> y = X // D <NEWLINE> if K < y : <NEWLINE> <INDENT> y = K <NEWLINE> <DEDENT> X = X - ( D * y ) <NEWLINE> K = K - y <NEWLINE> <NL> if K % 2 == 1 : <NEWLINE> <INDENT> X = abs ( X - D ) <NEWLINE> <NL> <DEDENT> print ( X ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> health = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s_health = sorted ( health ) <NEWLINE> if n <= k : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( sum ( s_health [ : n - k ] ) ) <NEWLINE>
import array <NEWLINE> <NL> <NL> def is_prime_number ( num ) : <NEWLINE> <INDENT> limit = int ( num ** 0.5 ) <NEWLINE> <NL> for lp in range ( 3 , limit + 1 , 2 ) : <NEWLINE> <INDENT> if num % lp == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> LENGTH = 1000000 <NEWLINE> prime_number_list = array . array ( <STRING> , [ True ] * ( LENGTH + 1 ) ) <NEWLINE> <NL> prime_number_list [ 0 ] = False <NEWLINE> prime_number_list [ 1 ] = False <NEWLINE> <NL> for lp in range ( 4 , LENGTH + 1 , 2 ) : <NEWLINE> <INDENT> prime_number_list [ lp ] = False <NEWLINE> <NL> <DEDENT> limit = int ( ( LENGTH + 1 ) ** 0.5 ) <NEWLINE> <NL> for lp in range ( 3 , limit + 1 , 2 ) : <NEWLINE> <INDENT> if is_prime_number ( lp ) : <NEWLINE> <INDENT> for lp2 in range ( lp * 2 , LENGTH + 1 , lp ) : <NEWLINE> <INDENT> prime_number_list [ lp2 ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> input_num = int ( input ( ) ) <NEWLINE> <NL> if input_num == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> <NL> for lp in range ( 2 , input_num // 2 + 1 ) : <NEWLINE> <NL> <INDENT> if prime_number_list [ lp ] and prime_number_list [ input_num - lp ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> lenS = len ( S ) <NEWLINE> mod_list = [ 0 ] * 2019 <NEWLINE> x = 0 <NEWLINE> for i in range ( lenS ) : <NEWLINE> <INDENT> x = ( int ( S [ lenS - 1 - i ] ) * pow ( 10 , i , 2019 ) + x ) % 2019 <NEWLINE> mod_list [ x ] += 1 <NEWLINE> <NL> <DEDENT> result = 0 <NEWLINE> for i , ml in enumerate ( mod_list ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> result += ml <NEWLINE> <DEDENT> result += int ( ml * ( ml - 1 ) / 2 ) <NEWLINE> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for N in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if N % 3 == 0 or N % 10 == 3 or str ( N ) . find ( <STRING> ) != - 1 : <NEWLINE> <INDENT> print ( <STRING> . format ( N ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
<COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n [ 0 ] == 0 & n [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( n [ 0 ] ) : <NEWLINE> <INDENT> for j in range ( n [ 1 ] ) : <NEWLINE> <INDENT> if j == n [ 1 ] - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> K = ( int ( input ( ) ) + 1 ) <NEWLINE> gcd_list = [ gcd ( m , gcd ( k , l ) ) for k in range ( 1 , K ) for l in range ( 1 , K ) for m in range ( 1 , K ) ] <NEWLINE> print ( sum ( gcd_list ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import math <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def f ( a , l ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> ans += math . ceil ( a [ i ] / l ) - 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> l , r = 1 , max ( a ) <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> g = f ( a , mid ) <NEWLINE> if g > k : <NEWLINE> <INDENT> l = mid + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> <DEDENT> if f ( a , l ) <= k : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter as C <NEWLINE> <NL> _ = input ( ) <NEWLINE> a = C ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ ] <NEWLINE> for k , v in a . items ( ) : <NEWLINE> <INDENT> b . extend ( [ k ] * ( v // 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if 2 <= len ( b ) : <NEWLINE> <INDENT> b . sort ( ) <NEWLINE> print ( b [ - 1 ] * b [ - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
def fun ( a , k , n ) : <COMMENT> <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> dp = [ 0 ] * n <NEWLINE> dp [ 1 ] = dp [ 0 ] + abs ( a [ 0 ] - a [ 1 ] ) <NEWLINE> for i in range ( 2 , len ( a ) ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> min_ = float ( <STRING> ) <NEWLINE> for j in range ( i - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if t == k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if dp [ j ] + abs ( a [ i ] - a [ j ] ) < min_ : <NEWLINE> <INDENT> min_ = dp [ j ] + abs ( a [ i ] - a [ j ] ) <NEWLINE> <DEDENT> <DEDENT> dp [ i ] = min_ <NEWLINE> <DEDENT> return dp [ - 1 ] <NEWLINE> <DEDENT> from sys import stdin , stdout <NEWLINE> n , k = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> print ( fun ( a , k , n ) ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <NL> <NL> def divide_segment ( left , right ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> delta_x_quarter = ( right [ 0 ] - left [ 0 ] ) / 3.0 <NEWLINE> delta_y_quarter = ( right [ 1 ] - left [ 1 ] ) / 3.0 <NEWLINE> <NL> delta_x_quarter_rotated = ( delta_x_quarter - math . sqrt ( 3 ) * delta_y_quarter ) / 2.0 <NEWLINE> delta_y_quarter_rotated = ( math . sqrt ( 3 ) * delta_x_quarter + delta_y_quarter ) / 2.0 <NEWLINE> <NL> s = [ left [ 0 ] + delta_x_quarter , left [ 1 ] + delta_y_quarter ] <NEWLINE> t = [ left [ 0 ] + delta_x_quarter * 2.0 , left [ 1 ] + delta_y_quarter * 2.0 ] <NEWLINE> u = [ s [ 0 ] + delta_x_quarter_rotated , s [ 1 ] + delta_y_quarter_rotated ] <NEWLINE> <NL> return s , t , u <NEWLINE> <NL> <NL> <DEDENT> def make_coch_curve ( depth , left , right ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> . format ( left [ 0 ] , left [ 1 ] ) ) <NEWLINE> if depth == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( right [ 0 ] , right [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> make_coch_curve_recursively ( depth - 1 , left , right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def make_coch_curve_recursively ( depth , left , right ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> s , t , u = divide_segment ( left , right ) <NEWLINE> <NL> if depth == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( s [ 0 ] , s [ 1 ] ) ) <NEWLINE> print ( <STRING> . format ( u [ 0 ] , u [ 1 ] ) ) <NEWLINE> print ( <STRING> . format ( t [ 0 ] , t [ 1 ] ) ) <NEWLINE> print ( <STRING> . format ( right [ 0 ] , right [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> make_coch_curve_recursively ( depth - 1 , left , s ) <NEWLINE> make_coch_curve_recursively ( depth - 1 , s , u ) <NEWLINE> make_coch_curve_recursively ( depth - 1 , u , t ) <NEWLINE> make_coch_curve_recursively ( depth - 1 , t , right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> depth = int ( input ( ) . strip ( ) ) <NEWLINE> make_coch_curve ( depth , left = [ 0.0 , 0.0 ] , right = [ 100.0 , 0.0 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans += min ( A [ N - i ] , B [ N - 1 - i ] ) <NEWLINE> if B [ N - i - 1 ] > A [ N - i ] : <NEWLINE> <INDENT> ans += min ( A [ N - i - 1 ] , B [ N - 1 - i ] - A [ N - i ] ) <NEWLINE> A [ N - i - 1 ] -= min ( A [ N - i - 1 ] , B [ N - 1 - i ] - A [ N - i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if 10 ** 18 < ans : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] ; BB = [ 0 ] <NEWLINE> S = set ( [ ] ) ; S . add ( 0 ) <NEWLINE> now = 0 <NEWLINE> Flag = False <NEWLINE> loop_start = - 1 <NEWLINE> if K <= 2 * pow ( 10 , 5 ) + 10 : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> nxt = A [ now ] - 1 <NEWLINE> BB . append ( nxt ) <NEWLINE> now = nxt <NEWLINE> <COMMENT> <NL> <DEDENT> print ( BB [ K ] + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( N * 2 ) : <NEWLINE> <INDENT> nxt = A [ now ] - 1 <NEWLINE> <COMMENT> <NL> if nxt in S : <NEWLINE> <INDENT> if Flag : <NEWLINE> <INDENT> if nxt == loop_start : <NEWLINE> <COMMENT> <NL> <INDENT> loop_cycle = i - loop_num <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> loop_start = nxt <NEWLINE> loop_num = i <NEWLINE> B . append ( nxt ) <NEWLINE> <COMMENT> <NL> Flag = True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> B . append ( nxt ) ; S . add ( nxt ) <NEWLINE> <DEDENT> now = nxt <NEWLINE> <DEDENT> loop_num += 1 - loop_cycle <NEWLINE> <COMMENT> <NL> loc = ( K - loop_num ) % loop_cycle + loop_num <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( B [ loc ] + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> heights = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> dic = { } <NEWLINE> res = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if heights [ i ] - i not in dic : <NEWLINE> <INDENT> dic [ heights [ i ] - i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ heights [ i ] - i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> if - heights [ j ] - j in dic : <NEWLINE> <INDENT> res += dic [ - heights [ j ] - j ] <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> <NL> k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - ( x + y ) <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> x , y , X , Y = [ float ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( math . sqrt ( ( x - X ) ** 2 + ( y - Y ) ** 2 ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> class UnionFindTree : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . par = list ( range ( n ) ) <COMMENT> <NEWLINE> self . rank = [ 0 ] * n <COMMENT> <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x , y = self . find ( x ) , self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . rank [ x ] < self . rank [ y ] : <NEWLINE> <INDENT> self . par [ x ] = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ y ] = x <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> V , E = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFindTree ( V ) <NEWLINE> for _ in range ( E ) : <NEWLINE> <INDENT> uf . unite ( * map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> print ( <STRING> if uf . same ( * map ( int , input ( ) . split ( ) ) ) else <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> STR = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> ORDER = tuple ( tuple ( input ( ) . split ( ) ) for _ in range ( Q ) ) <NEWLINE> <NL> str_ = list ( STR ) <NEWLINE> for order in ORDER : <NEWLINE> <INDENT> s = int ( order [ 1 ] ) <NEWLINE> e = int ( order [ 2 ] ) + 1 <NEWLINE> a = str_ [ s : e ] <NEWLINE> if order [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> . join ( a ) ) <NEWLINE> <DEDENT> elif order [ 0 ] == <STRING> : <NEWLINE> <INDENT> a = a [ : : - 1 ] <NEWLINE> j = s <NEWLINE> for i in range ( s , e ) : <NEWLINE> <INDENT> str_ [ i ] = a [ i - j ] <NEWLINE> <DEDENT> <DEDENT> elif order [ 0 ] == <STRING> : <NEWLINE> <INDENT> j = s <NEWLINE> for i in range ( s , e ) : <NEWLINE> <INDENT> str_ [ i ] = order [ 3 ] [ i - j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> <NL> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def check_p ( p ) : <NEWLINE> <INDENT> global k , ws <NEWLINE> ct , nt = 0 , 1 <NEWLINE> for w in ws : <NEWLINE> <INDENT> if ct + w <= p : <NEWLINE> <INDENT> ct += w <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nt += 1 <NEWLINE> if nt > k : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> ct = w <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ws = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> l , r , p = max ( ws ) , sum ( ws ) , 0 <NEWLINE> <NL> while l < r : <NEWLINE> <INDENT> p = ( l + r ) // 2 <NEWLINE> if check_p ( p ) : <NEWLINE> <INDENT> r = p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = p = p + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
from itertools import combinations <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> work = lst [ 0 ] <NEWLINE> ini = [ x - work for x in lst ] <NEWLINE> ini_seen = [ 0 ] <NEWLINE> work = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if ini [ i ] > work : <NEWLINE> <INDENT> work = ini [ i ] <NEWLINE> ini_seen . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> mn = None <NEWLINE> for x in combinations ( range ( n - len ( ini_seen ) ) , k - len ( ini_seen ) ) : <NEWLINE> <INDENT> sm = 0 <NEWLINE> work = 0 <NEWLINE> xtoken = 0 <NEWLINE> count = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if i in ini_seen : <NEWLINE> <INDENT> count += 1 <NEWLINE> if work < ini [ i ] : work = ini [ i ] <NEWLINE> else : <NEWLINE> <INDENT> work += 1 <NEWLINE> sm += work - ini [ i ] <NEWLINE> <DEDENT> <DEDENT> elif xtoken < len ( x ) and i == x [ xtoken ] + count : <NEWLINE> <INDENT> work += 1 <NEWLINE> sm += work - ini [ i ] <NEWLINE> xtoken += 1 <NEWLINE> <DEDENT> <DEDENT> if not mn : mn = sm <NEWLINE> if mn > sm : mn = sm <NEWLINE> <DEDENT> print ( mn ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> from collections import deque <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> Node = [ set ( ) for _ in range ( N ) ] <NEWLINE> Edge = { } <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> if b < a : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> Edge [ ( a , b ) ] = i <NEWLINE> Node [ a ] . add ( b ) <NEWLINE> Node [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> K = 0 <NEWLINE> for i , x in enumerate ( Node ) : <NEWLINE> <INDENT> if len ( x ) > K : <NEWLINE> <INDENT> K = len ( x ) <NEWLINE> top = i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> q = deque ( ) <NEWLINE> seen = [ False ] * ( N - 1 ) <NEWLINE> used = [ set ( ) for _ in range ( N ) ] <NEWLINE> q . append ( top ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> cur = q . popleft ( ) <NEWLINE> col = 1 <NEWLINE> for i in Node [ cur ] : <NEWLINE> <INDENT> if cur > i : <NEWLINE> <INDENT> ed = ( i , cur ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ed = ( cur , i ) <NEWLINE> <DEDENT> if seen [ Edge [ ed ] ] == False : <NEWLINE> <INDENT> while col in used [ cur ] or col in used [ i ] : <NEWLINE> <INDENT> col += 1 <NEWLINE> <DEDENT> seen [ Edge [ ed ] ] = col <NEWLINE> used [ cur ] . add ( col ) <NEWLINE> used [ i ] . add ( col ) <NEWLINE> q . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( K ) <NEWLINE> print ( <STRING> . join ( map ( str , seen ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n % k == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = n % k <NEWLINE> <COMMENT> <NL> while ans > k // 2 : <NEWLINE> <INDENT> n = abs ( ans - k ) <NEWLINE> ans = min ( n , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
X , N = input ( ) . split ( ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Z = list ( range ( 0 , 102 ) ) <NEWLINE> <NL> q = [ i for i in Z if i not in p ] <NEWLINE> t = [ ] <NEWLINE> <NL> for i in range ( 0 , len ( q ) ) : <NEWLINE> <INDENT> t . append ( abs ( int ( X ) - q [ i ] ) ) <NEWLINE> <NL> <DEDENT> print ( q [ ( t . index ( min ( t ) ) ) ] ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> X = int ( input ( ) ) <NEWLINE> <NL> MAX = 10 ** 9 <NEWLINE> <NL> for b in range ( 0 , MAX + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> a = math . pow ( abs ( b ** 5 + X ) , 1 / 5 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if round ( a ) ** 5 == abs ( b ** 5 + X ) : <NEWLINE> <INDENT> if b ** 5 + X > 0 : <NEWLINE> <INDENT> print ( int ( a ) , b ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - int ( a ) , b ) <NEWLINE> return <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> a = math . pow ( abs ( - b ** 5 + X ) , 1 / 5 ) <NEWLINE> <COMMENT> <NL> if round ( a ) ** 5 == abs ( - b ** 5 + X ) : <NEWLINE> <INDENT> if - b ** 5 + X > 0 : <NEWLINE> <INDENT> print ( int ( a ) , - b ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - int ( a ) , - b ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> raise ValueError ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 2 , H + 2 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> for k in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for h in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if h % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> A . sort ( ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> for i in range ( 0 , N , 2 ) : <NEWLINE> <INDENT> if A [ i ] != A [ i + 1 ] or A [ i ] != i + 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = ans * 2 % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A [ 0 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( 1 , N , 2 ) : <NEWLINE> <INDENT> if A [ i ] != A [ i + 1 ] or A [ i ] != i + 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = ans * 2 % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> N_m1 = N - 1 <NEWLINE> counter = 0 <NEWLINE> for i in range ( 1 , N_m1 + 1 ) : <NEWLINE> <INDENT> counter += N_m1 // i <NEWLINE> <NL> <DEDENT> print ( counter ) <NEWLINE>
<COMMENT> <NL> <NL> import heapq <NEWLINE> import collections <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> arr1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt1 = collections . Counter ( arr1 ) <NEWLINE> cnt2 = collections . Counter ( arr2 ) <NEWLINE> tmp = [ [ key , cnt1 [ key ] ] for key in cnt1 . keys ( ) ] <NEWLINE> tmp = sorted ( tmp , reverse = True , key = lambda x : x [ 1 ] ) <NEWLINE> arr3 = [ ] <NEWLINE> for key , cnt in tmp : <NEWLINE> <INDENT> for _ in range ( cnt ) : <NEWLINE> <INDENT> arr3 . append ( key ) <NEWLINE> <DEDENT> <DEDENT> cnt3 = collections . Counter ( arr3 ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> acum = 0 <NEWLINE> pos = 0 <NEWLINE> head = [ ] <NEWLINE> tail = [ ] <NEWLINE> for key in cnt3 . keys ( ) : <NEWLINE> <INDENT> tcnt1 = cnt3 [ key ] <NEWLINE> tcnt2 = cnt2 [ key ] <NEWLINE> if tcnt1 + tcnt2 > n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> acum += tcnt1 <NEWLINE> tpos = max ( acum , pos ) <NEWLINE> remain = tcnt2 <NEWLINE> <COMMENT> <NL> for i in range ( tpos , n ) : <NEWLINE> <INDENT> if remain == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans [ i ] = key <NEWLINE> remain -= 1 <NEWLINE> cnt2 [ key ] -= 1 <NEWLINE> <DEDENT> for _ in range ( remain ) : <NEWLINE> <INDENT> if tpos != pos : <NEWLINE> <INDENT> head . append ( key ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tail . append ( key ) <NEWLINE> <DEDENT> cnt2 [ key ] -= 1 <NEWLINE> <DEDENT> pos = min ( tpos + tcnt2 , n ) <NEWLINE> <COMMENT> <NL> <DEDENT> for key in cnt2 . keys ( ) : <NEWLINE> <INDENT> if cnt2 [ key ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for _ in range ( cnt2 [ key ] ) : <NEWLINE> <INDENT> tail . append ( key ) <NEWLINE> <DEDENT> <DEDENT> pos = 0 <NEWLINE> head += tail <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ans [ i ] == 0 : <NEWLINE> <INDENT> ans [ i ] = head [ pos ] <NEWLINE> pos += 1 <NEWLINE> <DEDENT> <DEDENT> q = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> heapq . heappush ( q , ( arr3 [ i ] , ans [ i ] ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> _ , val = heapq . heappop ( q ) <NEWLINE> ans [ i ] = val <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * ans ) <NEWLINE>
<COMMENT> <NL> <NL> x = int ( input ( <STRING> ) ) <NEWLINE> <NL> y = x ** 3 <NEWLINE> <NL> print ( y ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> min = 0 <NEWLINE> max = 0 <NEWLINE> for i in range ( a [ 1 ] ) : <NEWLINE> <INDENT> min += i <NEWLINE> max += a [ 0 ] - i <NEWLINE> minx = i - 1 <NEWLINE> maxx = a [ 0 ] - i - 1 <NEWLINE> <DEDENT> ans = max - min + 1 <NEWLINE> for i in range ( a [ 1 ] + 1 , a [ 0 ] + 2 ) : <NEWLINE> <INDENT> minx += 1 <NEWLINE> min += minx <NEWLINE> maxx += - 1 <NEWLINE> max += maxx <NEWLINE> ans = ( ans + max - min + 1 ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from bisect import bisect_left <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> inf = 1 << 30 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> * a , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> g = tuple ( set ( ) for _ in range ( N ) ) <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = ( int ( x ) - 1 for x in input ( ) . split ( ) ) <NEWLINE> g [ u ] . add ( v ) <NEWLINE> g [ v ] . add ( u ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * N <NEWLINE> lis = [ inf ] * N <NEWLINE> lis [ 0 ] = a [ 0 ] <NEWLINE> <NL> def dfs ( v , p = - 1 ) : <NEWLINE> <INDENT> ans [ v ] = bisect_left ( lis , inf ) <NEWLINE> for u in g [ v ] : <NEWLINE> <INDENT> if p == u : continue <NEWLINE> i = bisect_left ( lis , a [ u ] ) <NEWLINE> prev_at_i = lis [ i ] <NEWLINE> lis [ i ] = a [ u ] <NEWLINE> dfs ( u , v ) <NEWLINE> lis [ i ] = prev_at_i <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> <NL> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> result = [ ] <NEWLINE> count = 0 <NEWLINE> cnt = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> cnt += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL>
def solve ( n ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for d in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> c = n // d <NEWLINE> ans += ( c + 1 ) * c // 2 * d <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( solve ( n ) ) <NEWLINE>
S = input ( ) <NEWLINE> from collections import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> before = 0 <NEWLINE> for i in range ( 1 , len ( S ) + 1 ) : <NEWLINE> <INDENT> now = ( int ( S [ - i ] ) * pow ( 10 , i , 2019 ) + before ) % 2019 <NEWLINE> d [ now ] += 1 <NEWLINE> before = now <NEWLINE> <DEDENT> d [ 0 ] += 1 <NEWLINE> ans = 0 <NEWLINE> for i in d . values ( ) : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , A = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maxX = max ( max ( x ) , A ) <NEWLINE> dp = [ [ [ 0 for _ in range ( N * maxX + 1 ) ] for _ in range ( N + 1 ) ] for _ in range ( N + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] [ 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N + 1 ) : <NEWLINE> <INDENT> for k in range ( N * A + 1 ) : <NEWLINE> <INDENT> if dp [ i ] [ j ] [ k ] == 0 : continue <NEWLINE> dp [ i + 1 ] [ j ] [ k ] += dp [ i ] [ j ] [ k ] <NEWLINE> dp [ i + 1 ] [ j + 1 ] [ k + x [ i ] ] += dp [ i ] [ j ] [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += dp [ N ] [ i ] [ A * i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> l = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> l = l ^ a [ i ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = l ^ a [ i ] <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , a ) ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> D = [ [ 0 ] * ( N + 1 ) for i in range ( M ) ] <NEWLINE> cnts = [ 0 ] * M <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> v = int ( input ( ) ) <NEWLINE> cnts [ v - 1 ] += 1 <NEWLINE> D [ v - 1 ] [ i + 1 ] = 1 <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> d = D [ i ] <NEWLINE> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> d [ j ] += d [ j - 1 ] <NEWLINE> <DEDENT> <DEDENT> memo = [ None ] * ( 2 ** M ) <NEWLINE> memo [ 2 ** M - 1 ] = 0 <NEWLINE> def dfs ( state , idx ) : <NEWLINE> <INDENT> if memo [ state ] is not None : <NEWLINE> <INDENT> return memo [ state ] <NEWLINE> <DEDENT> res = N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if state & ( 1 << i ) == 0 : <NEWLINE> <INDENT> need = cnts [ i ] - ( D [ i ] [ cnts [ i ] + idx ] - D [ i ] [ idx ] ) <NEWLINE> res = min ( res , need + dfs ( state | ( 1 << i ) , idx + cnts [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> memo [ state ] = res <NEWLINE> return res <NEWLINE> <DEDENT> print ( dfs ( 0 , 0 ) ) <NEWLINE>
while ( True ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> quit ( ) <NEWLINE> <DEDENT> data = [ ] <NEWLINE> emp = [ [ 0 , 10 ** 9 ] ] <NEWLINE> for _____ in range ( N ) : <NEWLINE> <INDENT> tmp = input ( ) . split ( ) <NEWLINE> if tmp [ 0 ] == <STRING> : <NEWLINE> <INDENT> c , k = int ( tmp [ 1 ] ) , int ( tmp [ 2 ] ) <NEWLINE> while ( k ) : <NEWLINE> <INDENT> if ( emp [ 0 ] [ 1 ] - emp [ 0 ] [ 0 ] ) > k : <NEWLINE> <INDENT> data . append ( [ c , [ emp [ 0 ] [ 0 ] , emp [ 0 ] [ 0 ] + k ] ] ) <NEWLINE> emp [ 0 ] = [ emp [ 0 ] [ 0 ] + k , emp [ 0 ] [ 1 ] ] <NEWLINE> break <NEWLINE> <DEDENT> elif ( emp [ 0 ] [ 1 ] - emp [ 0 ] [ 0 ] ) == k : <NEWLINE> <INDENT> data . append ( [ c , [ emp [ 0 ] [ 0 ] , emp [ 0 ] [ 0 ] + k ] ] ) <NEWLINE> del ( emp [ 0 ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> data . append ( [ c , emp [ 0 ] ] ) <NEWLINE> k -= ( emp [ 0 ] [ 1 ] - emp [ 0 ] [ 0 ] ) <NEWLINE> del ( emp [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif tmp [ 0 ] == <STRING> : <NEWLINE> <INDENT> emp += [ i [ 1 ] for i in data if i [ 0 ] == int ( tmp [ 1 ] ) ] <NEWLINE> data = [ i for i in data if i [ 0 ] != int ( tmp [ 1 ] ) ] <NEWLINE> emp . sort ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = True <NEWLINE> s = int ( tmp [ 1 ] ) <NEWLINE> for i in data : <NEWLINE> <INDENT> if i [ 1 ] [ 0 ] <= s < i [ 1 ] [ 1 ] : <NEWLINE> <INDENT> print ( i [ 0 ] ) <NEWLINE> ans = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
N , Q = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> S = input ( ) . rstrip ( ) <NEWLINE> a = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i > 1 : <NEWLINE> <INDENT> a [ i ] = a [ i - 1 ] <NEWLINE> <DEDENT> if i != 0 and S [ i - 1 ] == <STRING> and S [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> print ( a [ r - 1 ] - a [ l - 1 ] ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if X - i not in p : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> break <NEWLINE> <DEDENT> elif X + i not in p : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> from itertools import combinations_with_replacement <NEWLINE> input = stdin . readline <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> s = list ( range ( 1 , M + 1 ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> <NL> for s in combinations_with_replacement ( s , N ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = abcd [ q ] <NEWLINE> if s [ b - 1 ] - s [ a - 1 ] == c : <NEWLINE> <INDENT> num += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , num ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 = [ float ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = math . hypot ( x2 - x3 , y2 - y3 ) ** 2 <NEWLINE> B = math . hypot ( x1 - x3 , y1 - y3 ) ** 2 <NEWLINE> C = math . hypot ( x1 - x2 , y1 - y2 ) ** 2 <NEWLINE> t1 = A * ( B + C - A ) <NEWLINE> t2 = B * ( A + C - B ) <NEWLINE> t3 = C * ( A + B - C ) <NEWLINE> px = ( t1 * x1 + t2 * x2 + t3 * x3 ) / ( t1 + t2 + t3 ) <NEWLINE> py = ( t1 * y1 + t2 * y2 + t3 * y3 ) / ( t1 + t2 + t3 ) <NEWLINE> r = math . hypot ( px - x1 , py - y1 ) <NEWLINE> print ( <STRING> % ( round ( px , 3 ) , round ( py , 3 ) , round ( r , 3 ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = { } <NEWLINE> for d in D : <NEWLINE> <INDENT> if d not in p : <NEWLINE> <INDENT> p [ d ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p [ d ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for t in T : <NEWLINE> <INDENT> if t not in p : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if p [ t ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> p [ t ] -= 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
maxa = 0 <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ 0 ] * 100000 <NEWLINE> for i in L : <NEWLINE> <INDENT> c [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , 99999 ) : <NEWLINE> <INDENT> s = c [ i ] + c [ i - 1 ] + c [ i + 1 ] <NEWLINE> maxa = max ( maxa , s ) <NEWLINE> <DEDENT> print ( maxa ) <NEWLINE>
from sys import stdin <NEWLINE> from collections import defaultdict <NEWLINE> readline = stdin . readline <NEWLINE> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( readline ( ) ) <NEWLINE> g = defaultdict ( list ) <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> s , t , d = map ( int , readline ( ) . split ( ) ) <NEWLINE> g [ s ] . append ( [ d , t ] ) <NEWLINE> g [ t ] . append ( [ d , s ] ) <NEWLINE> <NL> <DEDENT> dp = defaultdict ( dict ) <NEWLINE> for i in postorder ( g , n ) : <NEWLINE> <INDENT> for di , ti in g [ i ] : <NEWLINE> <INDENT> dp [ i ] [ ti ] = di <NEWLINE> candidate = [ v for k , v in dp [ ti ] . items ( ) if k != i ] <NEWLINE> if candidate : <NEWLINE> <INDENT> dp [ i ] [ ti ] += max ( candidate ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> height = [ None ] * n <NEWLINE> for i in preorder ( g , n ) : <NEWLINE> <INDENT> import operator <NEWLINE> candidate = list ( dp [ i ] . items ( ) ) <NEWLINE> candidate . sort ( key = operator . itemgetter ( 1 ) ) <NEWLINE> height [ i ] = candidate [ - 1 ] [ 1 ] if candidate else 0 <NEWLINE> for d , t in g [ i ] : <NEWLINE> <INDENT> dp [ t ] [ i ] = d <NEWLINE> if 1 < len ( candidate ) : <NEWLINE> <INDENT> k = - 1 if candidate [ - 1 ] [ 0 ] != t else - 2 <NEWLINE> dp [ t ] [ i ] += candidate [ k ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , height ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def postorder ( g , n ) : <NEWLINE> <INDENT> visited = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i in visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> parent_stack = [ ] <NEWLINE> dfs_stack = [ ( i , None ) ] <NEWLINE> while dfs_stack : <NEWLINE> <INDENT> u , prev = dfs_stack . pop ( ) <NEWLINE> visited |= { u } <NEWLINE> dfs_stack . extend ( ( t , u ) for d , t in g [ u ] if t != prev ) <NEWLINE> while parent_stack and parent_stack [ - 1 ] != prev : <NEWLINE> <INDENT> yield parent_stack . pop ( ) <NEWLINE> <DEDENT> parent_stack . append ( u ) <NEWLINE> <DEDENT> while parent_stack : <NEWLINE> <INDENT> yield parent_stack . pop ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def preorder ( g , n ) : <NEWLINE> <INDENT> visited = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i in visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs_stack = [ ( i , None ) ] <NEWLINE> while dfs_stack : <NEWLINE> <INDENT> u , prev = dfs_stack . pop ( ) <NEWLINE> visited |= { u } <NEWLINE> yield ( u ) <NEWLINE> dfs_stack . extend ( ( t , u ) for d , t in g [ u ] if t != prev ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
com = int ( input ( ) ) <NEWLINE> if com == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( input ( ) ) ; b = int ( input ( ) ) <NEWLINE> print ( a + b ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> listcost = [ ] <NEWLINE> <NL> for i in range ( min ( a ) , max ( a ) + 1 ) : <NEWLINE> <INDENT> cost = 0 <NEWLINE> for j in a : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> cost += ( i - j ) ** 2 <NEWLINE> <DEDENT> <DEDENT> listcost . append ( cost ) <NEWLINE> <DEDENT> print ( min ( listcost ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> <NL> def nextLine ( ) : return next ( stdin ) <NEWLINE> def nextStrList ( ) : return nextLine ( ) . split ( ) <NEWLINE> def nextIntList ( ) : return [ int ( _ ) for _ in nextStrList ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def comp ( n , aList ) : <NEWLINE> <INDENT> num = n // 2 <NEWLINE> score = [ [ None for _ in range ( num ) ] for i in range ( 3 ) ] <NEWLINE> <COMMENT> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( max ( 0 , num - ( n - i ) // 2 - 1 ) , min ( i // 2 + 1 , num ) ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ns = aList [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ns = max ( aList [ i ] , score [ ( i - 1 ) % 3 ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> nextScore = [ ] <NEWLINE> if i >= 1 : <NEWLINE> <INDENT> s = score [ ( i - 1 ) % 3 ] [ j ] <NEWLINE> if s is not None : <NEWLINE> <INDENT> nextScore . append ( s ) <NEWLINE> <DEDENT> <DEDENT> if i >= 2 : <NEWLINE> <INDENT> s = score [ ( i - 2 ) % 3 ] [ j - 1 ] <NEWLINE> if s is not None : <NEWLINE> <INDENT> s += aList [ i ] <NEWLINE> nextScore . append ( s ) <NEWLINE> <DEDENT> <DEDENT> if len ( nextScore ) > 0 : <NEWLINE> <INDENT> ns = max ( nextScore ) <NEWLINE> <NL> <DEDENT> <DEDENT> score [ i % 3 ] [ j ] = ns <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( score [ ( n - 1 ) % 3 ] [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( nextLine ( ) ) <NEWLINE> aList = nextIntList ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> comp ( n , aList ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter as c <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( input ( ) . split ( ) ) <NEWLINE> if c ( A ) . most_common ( ) [ 0 ] [ 1 ] == 1 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> from math import gcd <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> S = set ( [ input ( ) for _ in range ( N ) ] ) <NEWLINE> <NL> print ( len ( S ) ) <NEWLINE>
a , b , n = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> f = int ( a * x / b ) - a * int ( x / b ) <NEWLINE> print ( f ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) -> int : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) -> None : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) -> int : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) -> bool : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) -> list : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) -> list : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) -> int : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) -> dict : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> a . union ( b - 1 , c - 1 ) <NEWLINE> <DEDENT> print ( a . group_count ( ) - 1 ) <NEWLINE>
from math import factorial <NEWLINE> N = factorial ( int ( input ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> i = 2 <NEWLINE> <NL> while i * i <= N : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> while N % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> N //= i <NEWLINE> <DEDENT> ans *= cnt <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> if N != 1 : <NEWLINE> <INDENT> ans *= 2 <NEWLINE> <DEDENT> print ( int ( ans % mod ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> e1 , e2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> h = [ ] <NEWLINE> for i in range ( e2 ) : <NEWLINE> <INDENT> h . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> L = [ ] <NEWLINE> R = [ ] <NEWLINE> for i in range ( len ( h ) ) : <NEWLINE> <INDENT> L . append ( h [ i ] [ 0 ] ) <NEWLINE> <DEDENT> for i in range ( len ( h ) ) : <NEWLINE> <INDENT> R . append ( h [ i ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> if min ( R ) >= max ( L ) : <NEWLINE> <INDENT> print ( min ( R ) - max ( L ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <DEDENT>
def square ( list ) : <NEWLINE> <INDENT> return [ i ** 2 for i in list ] <NEWLINE> <DEDENT> m = 1000000007 <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sq = square ( A ) <NEWLINE> s1 = sum ( A ) <NEWLINE> s2 = sum ( sq ) <NEWLINE> <NL> result = ( s1 ** 2 - s2 ) // 2 <NEWLINE> print ( result % m ) <NEWLINE>
import re <NEWLINE> <NL> s = re . split ( <STRING> , input ( ) ) <NEWLINE> sl = len ( s ) <NEWLINE> ans = list ( ) <NEWLINE> <NL> for i in range ( sl ) : <NEWLINE> <INDENT> if ( 2 < len ( s [ i ] ) and len ( s [ i ] ) < 7 ) : <NEWLINE> <INDENT> ans . append ( s [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> ansl = len ( ans ) <NEWLINE> <NL> for i in range ( ansl ) : <NEWLINE> <INDENT> if ( i == ansl - 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans [ i ] , end = ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> <NL> c = [ 0 for i in range ( 2019 ) ] <NEWLINE> c [ 0 ] = 1 <NEWLINE> mod = 2019 <NEWLINE> d = 1 <NEWLINE> x = 0 <NEWLINE> for i , j in enumerate ( s [ : : - 1 ] ) : <NEWLINE> <INDENT> x = ( x + int ( j ) * pow ( 10 , i , mod ) ) % mod <NEWLINE> c [ x ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> ans += ( c [ i ] * ( c [ i ] - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L , R = [ 0 ] * M , [ 0 ] * M <NEWLINE> A = set ( range ( N ) ) <NEWLINE> lm , rm = 0 , N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> L [ i ] , R [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> lm = max ( lm , L [ i ] ) <NEWLINE> rm = min ( rm , R [ i ] ) <NEWLINE> <DEDENT> if lm <= rm : <NEWLINE> <INDENT> print ( rm - lm + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> m = gcd ( A , B ) <NEWLINE> <COMMENT> <NL> <NL> num = int ( m ** 0.5 ) <COMMENT> <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( 2 , num + 1 ) : <NEWLINE> <INDENT> if m % i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += 1 <NEWLINE> while not m % i : <NEWLINE> <INDENT> m /= i <NEWLINE> <NL> <DEDENT> <DEDENT> if m > 1 : <NEWLINE> <INDENT> ans += 1 <COMMENT> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> I = list ( input ( ) ) <NEWLINE> <NL> A = 0 <NEWLINE> L = [ ] <NEWLINE> LH = [ ] <NEWLINE> k = 0 <NEWLINE> while len ( I ) > 0 : <NEWLINE> <INDENT> i = I . pop ( ) <NEWLINE> <NL> if i == <STRING> : <NEWLINE> <INDENT> d = 1 <NEWLINE> a = 0.5 <NEWLINE> tmp_I = [ <STRING> ] <NEWLINE> <NL> <COMMENT> <NL> <NL> while len ( I ) > 0 : <NEWLINE> <INDENT> i = I . pop ( ) <NEWLINE> <NL> tmp_I . append ( i ) <NEWLINE> <NL> if i == <STRING> : <NEWLINE> <INDENT> d += 1 <NEWLINE> a += 0.5 + d - 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a += 0.5 + d - 1 <NEWLINE> d -= 1 <NEWLINE> if d == 0 : <NEWLINE> <INDENT> A += a <NEWLINE> L . append ( a ) <NEWLINE> k += 1 <NEWLINE> tmp_I = [ ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a += d <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if len ( tmp_I ) > 0 : <NEWLINE> <INDENT> d = a = 0 <NEWLINE> while len ( tmp_I ) > 0 : <NEWLINE> <INDENT> i = tmp_I . pop ( ) <NEWLINE> <COMMENT> <NL> if i == <STRING> : <NEWLINE> <INDENT> d += 1 <NEWLINE> a += 0.5 + d - 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a += d <NEWLINE> <DEDENT> elif i == <STRING> and d > 0 : <NEWLINE> <INDENT> a += 0.5 + d - 1 <NEWLINE> d -= 1 <NEWLINE> <NL> if d == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> A += a <NEWLINE> LH . append ( a ) <NEWLINE> k += 1 <NEWLINE> a = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( int ( A ) ) <NEWLINE> sys . stdout . write ( str ( k ) ) <NEWLINE> for l in LH : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> . format ( int ( l ) ) ) <NEWLINE> <DEDENT> while len ( L ) > 0 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> . format ( int ( L . pop ( ) ) ) ) <NEWLINE> <DEDENT> sys . stdout . write ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 for _ in range ( m ) ] <NEWLINE> b = [ 0 for _ in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ i ] -= 1 <NEWLINE> b [ i ] -= 1 <NEWLINE> <NL> <DEDENT> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . par = [ i for i in range ( n ) ] <NEWLINE> self . rank = [ 0 for _ in range ( n ) ] <NEWLINE> self . sizes = [ 1 for _ in range ( n ) ] <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = self . root ( self . par [ x ] ) <COMMENT> <NEWLINE> return self . par [ x ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . root ( x ) == self . root ( y ) <NEWLINE> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> rx = self . root ( x ) <NEWLINE> ry = self . root ( y ) <NEWLINE> if rx == ry : <NEWLINE> <INDENT> return <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> if self . rank [ rx ] < self . rank [ ry ] : <NEWLINE> <INDENT> self . par [ rx ] = ry <NEWLINE> self . sizes [ ry ] += self . sizes [ rx ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ ry ] = rx <NEWLINE> self . sizes [ rx ] += self . sizes [ ry ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if self . rank [ rx ] == self . rank [ ry ] : <NEWLINE> <INDENT> self . rank [ rx ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . sizes [ self . root ( x ) ] <NEWLINE> <NL> <DEDENT> def connected ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return len ( set ( self . par ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> uf = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> uf . unite ( a [ i ] , b [ i ] ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> _ = uf . root ( i ) <NEWLINE> <NL> <DEDENT> ans = uf . connected ( ) - 1 <NEWLINE> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> mydict = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> print ( mydict [ S ] ) <NEWLINE>
import sys <NEWLINE> from typing import List , Optional <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> g = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> l , r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> l -= 1 <NEWLINE> r -= 1 <NEWLINE> g [ l ] . append ( ( r , d ) ) <NEWLINE> g [ r ] . append ( ( l , - d ) ) <NEWLINE> <NL> <NL> <DEDENT> def ok ( cur : int , ds : int , dists : List [ Optional [ int ] ] ) -> bool : <NEWLINE> <INDENT> dists [ cur ] = ds <NEWLINE> <NL> flag = True <NEWLINE> for nx , d in g [ cur ] : <NEWLINE> <INDENT> if dists [ nx ] != None : <NEWLINE> <INDENT> flag &= dists [ nx ] - dists [ cur ] == d <NEWLINE> <DEDENT> elif flag : <NEWLINE> <INDENT> flag &= ok ( nx , ds + d , dists ) <NEWLINE> <NL> <DEDENT> <DEDENT> return flag <NEWLINE> <NL> <NL> <DEDENT> dists = [ None ] * N <NEWLINE> ans = True <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ans and dists [ i ] == None : <NEWLINE> <INDENT> ans &= ok ( i , 0 , dists ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> if ans else <STRING> ) <NEWLINE>
X , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N != 0 : <NEWLINE> <INDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = 100 <NEWLINE> for i in range ( - 100 , 200 ) : <NEWLINE> <INDENT> if i not in P : <NEWLINE> <INDENT> if abs ( X - i ) < ab : <NEWLINE> <INDENT> ab = abs ( X - i ) <NEWLINE> ans = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ 0 ] * Q ; C = [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B [ i ] , C [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> D = collections . Counter ( A ) <NEWLINE> s = sum ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> s = s - B [ i ] * D [ B [ i ] ] <NEWLINE> D [ C [ i ] ] += D [ B [ i ] ] <NEWLINE> s = s + C [ i ] * D [ B [ i ] ] <NEWLINE> D [ B [ i ] ] = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( s ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> from operator import itemgetter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> P = [ tuple ( map ( int , input ( ) . split ( ) ) ) + ( i , ) <NEWLINE> <INDENT> for i in range ( int ( input ( ) ) ) ] <COMMENT> <NEWLINE> <DEDENT> P . sort ( ) <NEWLINE> root = int ( math . sqrt ( len ( P ) ) ) <NEWLINE> low = [ x for x , y , i in P [ : : root ] ] <NEWLINE> high = [ x for x , y , i in P [ root - 1 : : root ] ] + [ float ( <STRING> ) ] <NEWLINE> <NL> <COMMENT> <NL> P = [ sorted ( P [ i : i + root ] , key = itemgetter ( 1 ) ) <NEWLINE> <INDENT> for i in range ( 0 , len ( P ) , root ) ] <NEWLINE> <DEDENT> P = [ ( [ y for x , y , i in Pi ] , Pi ) <NEWLINE> <INDENT> for Pi in P ] <COMMENT> <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> Q = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> for sx , tx , sy , ty in Q : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> for i in range ( bisect_left ( high , sx ) , bisect_right ( low , tx ) ) : <NEWLINE> <INDENT> k , v = P [ i ] <NEWLINE> for i in range ( bisect_left ( k , sy ) , bisect_right ( k , ty ) ) : <NEWLINE> <INDENT> if sx <= v [ i ] [ 0 ] <= tx : <NEWLINE> <INDENT> ret . append ( v [ i ] [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ret : <NEWLINE> <INDENT> ret . sort ( ) <NEWLINE> print ( <STRING> . join ( map ( str , ret ) ) ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 1000000007 <NEWLINE> S = 0 <NEWLINE> Q = sum ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> Q -= a [ i ] <NEWLINE> S += a [ i ] * Q % m <NEWLINE> <DEDENT> print ( S % m ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = [ None ] * n <NEWLINE> for idx , ea in enumerate ( a ) : <NEWLINE> <INDENT> ans [ ea - 1 ] = idx + 1 <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> R = { } <NEWLINE> G = { } <NEWLINE> B = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R [ i ] = None <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> G [ i ] = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B [ i ] = None <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> <NL> cnt = len ( R ) * len ( G ) * len ( B ) <NEWLINE> <NL> for b in B : <NEWLINE> <INDENT> for g in G : <NEWLINE> <INDENT> if ( b + g ) / 2 in R : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for r in R : <NEWLINE> <INDENT> for b in B : <NEWLINE> <INDENT> if ( r + b ) / 2 in G : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for r in R : <NEWLINE> <INDENT> for g in G : <NEWLINE> <INDENT> if ( r + g ) / 2 in B : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ float ( <STRING> ) for i in range ( n ) ] <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for j in range ( 1 , min ( i + 1 , k + 1 ) ) : <NEWLINE> <INDENT> m = dp [ i - j ] + abs ( h [ i ] - h [ i - j ] ) <NEWLINE> if dp [ i ] > m : <NEWLINE> <INDENT> dp [ i ] = m <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 200000 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> edges = [ set ( ) for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ s ] . add ( t ) <NEWLINE> edges [ t ] . add ( s ) <NEWLINE> <NL> <DEDENT> prenum = [ None ] * n <NEWLINE> parent = [ None ] * n <NEWLINE> lowest = [ None ] * n <NEWLINE> counter = 0 <NEWLINE> bridges = set ( ) <NEWLINE> <NL> <NL> def dfs ( cur , prev ) : <NEWLINE> <INDENT> global counter <NEWLINE> prenum [ cur ] = lowest [ cur ] = counter <NEWLINE> counter += 1 <NEWLINE> for edge in edges [ cur ] : <NEWLINE> <INDENT> if prenum [ edge ] is not None : <NEWLINE> <INDENT> if edge != prev : <NEWLINE> <INDENT> lowest [ cur ] = min ( lowest [ cur ] , prenum [ edge ] ) <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> parent [ edge ] = cur <NEWLINE> dfs ( edge , cur ) <NEWLINE> lowest [ cur ] = min ( lowest [ cur ] , lowest [ edge ] ) <NEWLINE> <DEDENT> if prenum [ cur ] == lowest [ cur ] : <NEWLINE> <INDENT> bridges . add ( ( cur , prev ) if cur < prev else ( prev , cur ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> <NL> for bridge in sorted ( bridges ) [ 1 : ] : <NEWLINE> <INDENT> print ( * bridge ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( int ( n ) ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( int ( n ) ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> m = math . gcd ( i , j ) <NEWLINE> for h in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> l = math . gcd ( h , m ) <NEWLINE> a += l <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> i = j = 0 <NEWLINE> while i ** 5 - j ** 5 - x : i = - ~ i % 120 ; j = ( j + 99 ) % 217 - 98 <NEWLINE> print ( i , j ) <NEWLINE>
s = list ( map ( int , list ( input ( ) ) ) ) [ : : - 1 ] <NEWLINE> <NL> n = len ( s ) <NEWLINE> D = [ 0 ] * ( n + 1 ) <NEWLINE> c = [ 0 ] * ( n + 1 ) <NEWLINE> ans = 0 <NEWLINE> f = 0 <NEWLINE> dp = [ 0 ] * ( 2020 ) <NEWLINE> dp [ 0 ] += 1 <NEWLINE> tmp = 0 <NEWLINE> x = 1 <NEWLINE> for e , i in enumerate ( s ) : <NEWLINE> <INDENT> tmp = ( tmp + x * i ) % 2019 <NEWLINE> ans += dp [ tmp ] <NEWLINE> dp [ tmp ] += 1 <NEWLINE> x = x * 10 % 2019 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> height = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> d = defaultdict ( int ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x = i + height [ i ] <NEWLINE> d [ x ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> x = i - height [ i ] <NEWLINE> ans += d [ x ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> ans = 1000000 <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> U = S [ i : i + len ( T ) ] <COMMENT> <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if U [ j ] != T [ j ] : <NEWLINE> <INDENT> score += 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , score ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def gcd2 ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <NL> <DEDENT> return gcd2 ( b , a % b ) <NEWLINE> <NL> <DEDENT> def gcd3 ( a , b , c ) : <NEWLINE> <INDENT> return gcd2 ( gcd2 ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> if a == b and b == c and c == a : <NEWLINE> <INDENT> ans += gcd3 ( a , b , c ) <NEWLINE> <DEDENT> elif a == b or b == c or c == a : <NEWLINE> <INDENT> ans += gcd3 ( a , b , c ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd3 ( a , b , c ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 10050 ) ] <NEWLINE> for i in range ( 1 , 105 ) : <NEWLINE> <INDENT> for j in range ( 1 , 105 ) : <NEWLINE> <INDENT> for k in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = i * i + j * j + k * k + i * j + j * k + k * i ; <NEWLINE> if v < 10050 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> count = [ 0 for _ in range ( 101 ) ] <NEWLINE> mode = 0 <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <INDENT> x = int ( s ) <NEWLINE> count [ x ] += 1 <NEWLINE> mode = max ( mode , count [ x ] ) <NEWLINE> <NL> <DEDENT> for i in range ( 101 ) : <NEWLINE> <INDENT> if count [ i ] == mode : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> a_lst = ( [ i for i , x in enumerate ( S ) if x == <STRING> ] ) <NEWLINE> count = 0 <NEWLINE> for j in a_lst : <NEWLINE> <INDENT> if len ( S ) >= j + 3 : <NEWLINE> <INDENT> if S [ j + 1 ] == <STRING> and S [ j + 2 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> N , M = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> if M == 0 : <NEWLINE> <INDENT> if N == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = [ 0 ] * N <NEWLINE> ans [ 0 ] = 1 <NEWLINE> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <DEDENT> sys . exit ( ) <NEWLINE> <NL> <DEDENT> S , C = np . array ( [ [ int ( _ ) for _ in input ( ) . split ( ) ] for i in range ( M ) ] ) . T <NEWLINE> <NL> ans = [ - 1 ] * N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> j = int ( S [ i ] ) - 1 <NEWLINE> if ans [ j ] == - 1 or ans [ j ] == C [ i ] : <NEWLINE> <INDENT> ans [ j ] = C [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if N >= 2 and ans [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if N >= 2 and ans [ 0 ] == - 1 : <NEWLINE> <INDENT> ans [ 0 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if ans [ i ] == - 1 : <NEWLINE> <INDENT> ans [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> s = <STRING> . join ( map ( str , ans ) ) <NEWLINE> print ( s ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> s = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> Max = sum ( s ) <NEWLINE> s . sort ( ) <NEWLINE> <NL> if Max % 10 == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] % 10 != 0 : <NEWLINE> <INDENT> Max -= s [ i ] <NEWLINE> <DEDENT> if Max % 10 != 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if Max % 10 == 0 : <NEWLINE> <INDENT> Max = 0 <NEWLINE> <NL> <DEDENT> print ( Max ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> @ njit ( <STRING> ) <NEWLINE> def get_expv ( N , i , j , k , expv ) : <NEWLINE> <INDENT> result = 0.0 <NEWLINE> if expv [ i ] [ j ] [ k ] != - 1 : <NEWLINE> <INDENT> return expv [ i ] [ j ] [ k ] <NEWLINE> <DEDENT> nonlp = 1.0 - ( N - i - j - k ) / N <NEWLINE> result += 1 <NEWLINE> if i != 0 : <NEWLINE> <INDENT> result += get_expv ( N , i - 1 , j , k , expv ) * ( i / N ) <NEWLINE> <DEDENT> if j != 0 : <NEWLINE> <INDENT> result += get_expv ( N , i + 1 , j - 1 , k , expv ) * ( j / N ) <NEWLINE> <DEDENT> if k != 0 : <NEWLINE> <INDENT> result += get_expv ( N , i , j + 1 , k - 1 , expv ) * ( k / N ) <NEWLINE> <DEDENT> result /= nonlp <NEWLINE> expv [ i ] [ j ] [ k ] = result <NEWLINE> return result <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> sushi_count = { 1 : 0 , 2 : 0 , 3 : 0 } <NEWLINE> for a in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> sushi_count [ a ] += 1 <NEWLINE> <DEDENT> sh = ( N + 1 , N - sushi_count [ 1 ] + 1 , sushi_count [ 3 ] + 1 ) <NEWLINE> expv = np . full ( sh , - 1.0 ) <NEWLINE> <NL> expv [ 0 ] [ 0 ] [ 0 ] = 0.0 <NEWLINE> <NL> print ( get_expv ( N , sushi_count [ 1 ] , sushi_count [ 2 ] , sushi_count [ 3 ] , expv ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <COMMENT> <NL> a = [ ] <NEWLINE> for i , a_i in enumerate ( input ( ) . split ( <STRING> ) ) : <NEWLINE> <INDENT> a_i = int ( a_i ) <NEWLINE> a . append ( a_i ) <NEWLINE> if i < k : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> if a [ i - k ] < a_i : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( b - 1 , n ) <NEWLINE> <NL> print ( ( a * x ) // b ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> S = list ( input ( ) ) <NEWLINE> S = [ int ( i ) for i in S ] <NEWLINE> D = defaultdict ( int ) <NEWLINE> mod = 2019 <NEWLINE> <NL> N = len ( S ) <NEWLINE> Mlis = [ 0 ] * N <NEWLINE> Mlis [ - 1 ] = S [ - 1 ] % mod <NEWLINE> <NL> for i in range ( N - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> Mlis [ i ] = ( Mlis [ i + 1 ] + pow ( 10 , N - 1 - i , mod ) * S [ i ] ) % mod <NEWLINE> <NL> <DEDENT> for i in Mlis : <NEWLINE> <INDENT> D [ i ] += 1 <NEWLINE> <NL> <DEDENT> ans = D [ 0 ] + sum ( [ i * ( i - 1 ) // 2 for i in D . values ( ) ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
<COMMENT> <NL> from functools import reduce <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> <NL> while True : <NEWLINE> <NL> <INDENT> a = [ int ( x ) for x in list ( str ( i ) ) ] <NEWLINE> <NL> if 3 in a : <NEWLINE> <INDENT> print ( <STRING> . format ( int ( reduce ( lambda x , y : x + y , [ str ( x ) for x in a ] ) ) ) , end = <STRING> ) <NEWLINE> <DEDENT> elif sum ( a ) % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( int ( reduce ( lambda x , y : x + y , [ str ( x ) for x in a ] ) ) ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> if i > n : <NEWLINE> <INDENT> print ( ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT>
A = input ( ) <NEWLINE> <NL> Alphabet = list ( <STRING> ) <NEWLINE> <NL> N = len ( A ) <NEWLINE> ans = N * ( N - 1 ) / 2 + 1 <NEWLINE> <NL> for i in Alphabet : <NEWLINE> <INDENT> z = 0 <NEWLINE> for j in range ( len ( A ) ) : <NEWLINE> <INDENT> if i == A [ j ] : <NEWLINE> <INDENT> z += 1 <NEWLINE> <DEDENT> <DEDENT> if z > 1 : <NEWLINE> <INDENT> ans -= z * ( z - 1 ) / 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> p = 2019 <NEWLINE> <NL> <NL> <NL> digit_rm = [ 0 for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> digit_rm [ i ] = ( int ( s [ n - 1 - i ] ) * pow ( 10 , i , p ) ) % p <NEWLINE> <NL> <DEDENT> remain = [ 0 for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> remain [ i ] = digit_rm [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> remain [ i ] = ( remain [ i - 1 ] + digit_rm [ i ] ) % p <NEWLINE> <NL> <DEDENT> <DEDENT> pcnt = [ 0 for _ in range ( p ) ] <NEWLINE> <NL> for i in remain : <NEWLINE> <INDENT> pcnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> if 10 % p == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if int ( s [ n - 1 - i ] ) % p == 0 : <NEWLINE> <INDENT> ans += n - i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = pcnt [ 0 ] <NEWLINE> for num in pcnt : <NEWLINE> <INDENT> if num != 0 : <NEWLINE> <INDENT> ans += num * ( num - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> count = 0 <NEWLINE> max = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> max = count <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
L , R = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> if R - L >= 2018 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 2019 <NEWLINE> for i in range ( L , R ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> if ( i * j ) % 2019 < ans : <NEWLINE> <INDENT> ans = ( i * j ) % 2019 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> l = len ( s ) <NEWLINE> MOD = 2019 <NEWLINE> ans = 0 <NEWLINE> mods = [ 0 ] * 2019 <NEWLINE> mods [ 0 ] = 1 <NEWLINE> num = 0 <NEWLINE> cnt = 0 <NEWLINE> d = 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> num += int ( i ) * d <NEWLINE> num %= MOD <NEWLINE> mods [ num ] += 1 <NEWLINE> d *= 10 <NEWLINE> d %= MOD <NEWLINE> <NL> <DEDENT> for j in mods : <NEWLINE> <INDENT> ans += int ( j * ( j - 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> try : <NEWLINE> <INDENT> p = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = set ( range ( - 100 , 201 ) ) <NEWLINE> mem = [ ] <NEWLINE> <NL> ref = sorted ( list ( num - p ) ) <NEWLINE> <NL> for item in ref : <NEWLINE> <INDENT> mem . append ( abs ( item - X ) ) <NEWLINE> <NL> <DEDENT> print ( ref [ mem . index ( min ( mem ) ) ] ) <NEWLINE> <NL> <DEDENT> except EOFError : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a <= 0 and b >= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b < 0 : <NEWLINE> <INDENT> if ( b - a + 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <DEDENT> <DEDENT> uf = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in uf . roots ( ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> a [ i ] -= 1 <NEWLINE> <NL> <DEDENT> visited = [ - 1 ] * n <NEWLINE> now = 0 <NEWLINE> visited [ 0 ] = 0 <NEWLINE> pre_roop = 0 <NEWLINE> pos = 0 <NEWLINE> i = 1 <NEWLINE> r = 1 <NEWLINE> while i <= k : <NEWLINE> <INDENT> next = a [ now ] <NEWLINE> <COMMENT> <NL> if visited [ next ] >= 0 : <NEWLINE> <INDENT> r = i - visited [ next ] <NEWLINE> pre_roop = visited [ next ] <NEWLINE> pos = next <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited [ next ] = i <NEWLINE> now = next <NEWLINE> <COMMENT> <NL> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if i > k : <NEWLINE> <INDENT> print ( now + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = ( k - pre_roop ) % r <NEWLINE> <COMMENT> <NL> i = 0 <NEWLINE> p = pos <NEWLINE> while i < l : <NEWLINE> <INDENT> p = a [ p ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> print ( p + 1 ) <NEWLINE> <NL> <DEDENT>
import decimal <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> <NL> a = int ( a ) <NEWLINE> b = decimal . Decimal ( b ) * 100 <NEWLINE> <NL> print ( a * b // 100 ) <NEWLINE>
N = ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> num = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> num *= i <NEWLINE> if num > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> v = math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> return v <NEWLINE> <NL> <DEDENT> if N >= B - 1 : <NEWLINE> <INDENT> print ( f ( B - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( f ( N ) ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> p = a % k <NEWLINE> q = k - p <NEWLINE> if ( p == 0 ) or ( ( a + q ) <= b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
data = input ( ) <NEWLINE> <COMMENT> <NL> diff = { <STRING> : - 1 , <STRING> : 0 , <STRING> : 1 } <NEWLINE> height = [ 0 ] <NEWLINE> [ height . append ( height [ - 1 ] + diff [ i ] ) for i in data ] <NEWLINE> bottom = min ( height ) <NEWLINE> height = [ h - bottom for h in height ] <NEWLINE> <NL> m = max ( height ) <NEWLINE> water = [ m for h in height ] <NEWLINE> <NL> height00 = [ 0 ] + height + [ 0 ] <NEWLINE> water00 = [ 0 ] + water + [ 0 ] <NEWLINE> <NL> roop = True <NEWLINE> forward = 1 <NEWLINE> while roop : <NEWLINE> <INDENT> temp = water00 [ : ] <NEWLINE> for i in range ( 1 , len ( water00 ) - 1 ) [ : : forward ] : <NEWLINE> <INDENT> water00 [ i ] = max ( height00 [ i ] , min ( water00 [ i - 1 : i + 2 ] ) ) <NEWLINE> <DEDENT> roop = temp != water00 <NEWLINE> forward *= - 1 <NEWLINE> <NL> <DEDENT> water = water00 [ 1 : - 1 ] <NEWLINE> depth = [ w - h for w , h in zip ( water , height ) ] <NEWLINE> <NL> paddles = [ 0 ] <NEWLINE> for d1 , d2 in zip ( depth [ : - 1 ] , depth [ 1 : ] ) : <NEWLINE> <INDENT> if d1 == 0 and d2 > 0 : <NEWLINE> <INDENT> paddles . append ( 0 ) <NEWLINE> <DEDENT> paddles [ - 1 ] += min ( d1 , d2 ) + 0.5 * abs ( d1 - d2 ) <NEWLINE> <NL> <DEDENT> paddles = [ int ( p ) for p in paddles [ 1 : ] ] <NEWLINE> print ( sum ( paddles ) ) <NEWLINE> print ( len ( paddles ) , * paddles ) <NEWLINE>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> price = X * A + Y * B <NEWLINE> for a in [ 0 , abs ( X - Y ) , X ] : <NEWLINE> <INDENT> for b in [ 0 , abs ( X - Y ) , Y ] : <NEWLINE> <INDENT> c = max ( X - a , Y - b ) * 2 <NEWLINE> price = min ( price , a * A + b * B + c * C ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( price ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ i for i in map ( int , input ( ) . split ( ) ) ] <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> As = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> As *= A [ i ] <NEWLINE> if 10 ** 18 < As : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if As <= 10 ** 18 : <NEWLINE> <INDENT> print ( As ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> import bisect <NEWLINE> import copy <NEWLINE> import time <NEWLINE> from collections import Counter <NEWLINE> from itertools import combinations <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> d = { i : set ( ) for i in range ( 1 , n + 1 ) } <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> d [ x ] . add ( y ) <NEWLINE> d [ y ] . add ( x ) <NEWLINE> <NL> <NL> <DEDENT> vis = { i : False for i in range ( 1 , n + 1 ) } <NEWLINE> for u , v in d . items ( ) : <NEWLINE> <INDENT> d [ u ] = list ( v ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> que = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if not vis [ i ] : <NEWLINE> <INDENT> que = [ ] <NEWLINE> c = 1 <NEWLINE> vis [ i ] = True <NEWLINE> que . append ( i ) <NEWLINE> while len ( que ) != 0 : <NEWLINE> <INDENT> x = que . pop ( 0 ) <NEWLINE> for j in d [ x ] : <NEWLINE> <INDENT> if not vis [ j ] : <NEWLINE> <INDENT> vis [ j ] = True <NEWLINE> c += 1 <NEWLINE> que . append ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> count = max ( c , count ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
from math import ceil <NEWLINE> <NL> def BinarySearch ( x ) : <NEWLINE> <INDENT> ans = sum ( [ ceil ( a / x ) - 1 for a in A ] ) <NEWLINE> if ans <= K : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> r = max ( A ) <NEWLINE> l = 0 <NEWLINE> eps = 10 ** - 6 <NEWLINE> <NL> while abs ( r - l ) > eps : <NEWLINE> <NL> <INDENT> m = ( r + l ) / 2 <NEWLINE> <NL> if BinarySearch ( m ) : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = m <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ceil ( r ) ) <NEWLINE>
import sys <NEWLINE> import random <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> l = len ( S ) <NEWLINE> n = [ 0 , 1 , 2 ] <NEWLINE> out = S [ n [ 0 ] ] + S [ n [ 1 ] ] + S [ n [ 2 ] ] <NEWLINE> <NL> print ( out ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <COMMENT> <NL> def int1 ( x ) : return int ( x ) - 1 <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MI1 ( ) : return map ( int1 , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LI1 ( ) : return list ( map ( int1 , input ( ) . split ( ) ) ) <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def MS ( ) : return input ( ) . split ( ) <NEWLINE> def LS ( ) : return list ( input ( ) ) <NEWLINE> def LLS ( rows_number ) : return [ LS ( ) for _ in range ( rows_number ) ] <NEWLINE> def printlist ( lst , k = <STRING> ) : print ( k . join ( list ( map ( str , lst ) ) ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> from collections import deque , defaultdict <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> N = II ( ) <NEWLINE> X = [ 0 ] * N <NEWLINE> Y = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = MI ( ) <NEWLINE> X [ i ] , Y [ i ] = x , y <NEWLINE> <NL> <DEDENT> dct = defaultdict ( int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if i == j : continue <NEWLINE> xi , yi = X [ i ] , Y [ i ] <NEWLINE> xj , yj = X [ j ] , Y [ j ] <NEWLINE> <NL> dct [ ( xi - xj , yi - yj ) ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> mx = 0 <NEWLINE> for d in dct . values ( ) : <NEWLINE> <INDENT> mx = max ( mx , d ) <NEWLINE> <DEDENT> print ( N - mx ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <NL> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> M = 10 ** 9 + 7 <NEWLINE> lis = [ 1 ] + [ 0 ] * n <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> lis [ i ] = - 1 <NEWLINE> <DEDENT> lis [ 1 ] += 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if lis [ i + 2 ] < 0 : <NEWLINE> <INDENT> lis [ i + 2 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis [ i + 2 ] = ( lis [ i + 1 ] + lis [ i ] ) % M <NEWLINE> <DEDENT> <DEDENT> print ( lis [ n ] ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> from collections import defaultdict , deque , Counter <NEWLINE> from copy import deepcopy <NEWLINE> from bisect import bisect , bisect_right , bisect_left <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> def RD ( ) : return input ( ) . rstrip ( ) <NEWLINE> def F ( ) : return float ( input ( ) . rstrip ( ) ) <NEWLINE> def I ( ) : return int ( input ( ) . rstrip ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MF ( ) : return map ( float , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def TI ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LF ( ) : return list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> def Init ( H , W , num ) : return [ [ num for i in range ( W ) ] for j in range ( H ) ] <NEWLINE> <NL> class BIT ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . bit = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def add ( self , i , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> while i <= self . n : <NEWLINE> <INDENT> self . bit [ i ] += x <NEWLINE> i += ( i & - i ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> def sum ( self , i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> <COMMENT> <NL> while i > 0 : <NEWLINE> <INDENT> s += self . bit [ i ] <NEWLINE> i -= ( i & - i ) <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def rangesum ( self , i , k ) : <NEWLINE> <INDENT> return self . sum ( k ) - self . sum ( i ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def lower_bound ( self , x ) : <NEWLINE> <INDENT> if x <= 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 0 <NEWLINE> r = 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> while ( r < self . n ) : <NEWLINE> <INDENT> r = r << 1 <NEWLINE> <DEDENT> len = r <NEWLINE> while len > 0 : <NEWLINE> <INDENT> if ( i + len < self . n and self . bit [ i + len ] < x ) : <NEWLINE> <INDENT> x -= self . bit [ i + len ] <NEWLINE> i += len <NEWLINE> <DEDENT> len = len >> 1 <NEWLINE> <DEDENT> return i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , Q = MI ( ) <NEWLINE> X , Y = BIT ( N ) , BIT ( N ) <NEWLINE> xmin = N - 2 <NEWLINE> ymin = N - 2 <NEWLINE> X . add ( 1 , N - 2 ) <NEWLINE> X . add ( N - 1 , - ( N - 2 ) ) <NEWLINE> Y . add ( 1 , N - 2 ) <NEWLINE> Y . add ( N - 1 , - ( N - 2 ) ) <NEWLINE> <NL> res = ( N - 2 ) ** 2 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a , b = MI ( ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> x = X . sum ( b - 1 ) <NEWLINE> if ymin > b - 2 : <NEWLINE> <INDENT> temp = Y . sum ( 1 ) <NEWLINE> Y . add ( 1 , b - 2 - temp ) <NEWLINE> Y . add ( xmin + 1 , - ( b - 2 - temp ) ) <NEWLINE> ymin = b - 2 <NEWLINE> <DEDENT> res -= x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = Y . sum ( b - 1 ) <NEWLINE> if xmin > b - 2 : <NEWLINE> <INDENT> temp = X . sum ( 1 ) <NEWLINE> X . add ( 1 , b - 2 - temp ) <NEWLINE> X . add ( ymin + 1 , - ( b - 2 - temp ) ) <NEWLINE> xmin = b - 2 <NEWLINE> <DEDENT> res -= y <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = Counter ( lis ) <NEWLINE> <NL> slis = sorted ( set ( lis ) ) <NEWLINE> <NL> t1 = 0 <NEWLINE> t2 = 0 <NEWLINE> <NL> for k , v in a . items ( ) : <NEWLINE> <INDENT> if v >= 2 and k > t1 : <NEWLINE> <INDENT> t2 = t1 <NEWLINE> t1 = k <NEWLINE> <NL> <DEDENT> <DEDENT> if a [ t1 ] >= 4 : <NEWLINE> <INDENT> print ( t1 * t1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( t1 * t2 ) <NEWLINE> <NL>
import math <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> max_length = max ( alist ) <NEWLINE> cur_length = 0 <NEWLINE> <NL> while ( max_length - cur_length > 1 ) : <NEWLINE> <INDENT> next_length = ( max_length + cur_length ) // 2 <NEWLINE> <NL> test_k = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> test_k += math . ceil ( alist [ i ] / next_length ) - 1 <NEWLINE> <NL> <DEDENT> if test_k <= k : <NEWLINE> <INDENT> max_length = next_length <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cur_length = next_length <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( max_length ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> if a [ 0 ] == 1 : <NEWLINE> <INDENT> if len ( a ) == 1 or a [ 1 ] != 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a_max = a [ - 1 ] <NEWLINE> seive = [ True for _ in range ( a_max + 1 ) ] <NEWLINE> a += [ - 1 ] <NEWLINE> ret = 0 <NEWLINE> add = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] != a [ i + 1 ] : <NEWLINE> <INDENT> if seive [ a [ i ] ] : <NEWLINE> <INDENT> ret += add <NEWLINE> j = 2 * a [ i ] <NEWLINE> while j <= a_max : <NEWLINE> <INDENT> seive [ j ] = False <NEWLINE> j += a [ i ] <NEWLINE> <DEDENT> <DEDENT> add = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> add = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <DEDENT>
for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> q = float ( e ) <NEWLINE> x = q / 2 <NEWLINE> while abs ( x ** 3 - q ) >= q * 1e-5 : x -= ( x ** 3 - q ) / ( 3 * x * x ) <NEWLINE> print ( x ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> x = gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( x , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import numpy as np <NEWLINE> import sys <NEWLINE> <NL> def combinationlist ( n ) : <NEWLINE> <INDENT> p_sets = [ ] <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> lst = [ x + 1 for x in range ( i ) if 2 ** x & i ] <NEWLINE> if lst != [ ] : <NEWLINE> <INDENT> p_sets . append ( lst ) <NEWLINE> <DEDENT> <DEDENT> p_sets = sorted ( p_sets , key = lambda x : len ( x ) ) <NEWLINE> return p_sets <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> data = input ( ) . split ( ) <NEWLINE> h = int ( data [ 0 ] ) <NEWLINE> w = int ( data [ 1 ] ) <NEWLINE> k = int ( data [ 2 ] ) <NEWLINE> c = np . empty ( ( h , w ) , dtype = str ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> c [ i , : ] = np . array ( [ c for c in s ] ) <NEWLINE> <DEDENT> rowset = [ ] <NEWLINE> colset = [ ] <NEWLINE> all_black = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> data = c [ i , : ] <NEWLINE> count = len ( data [ data == <STRING> ] ) <NEWLINE> all_black += count <NEWLINE> rowset . append ( [ count , data ] ) <NEWLINE> <DEDENT> for j in range ( w ) : <NEWLINE> <INDENT> data = c [ : , j ] <NEWLINE> count = len ( data [ data == <STRING> ] ) <NEWLINE> colset . append ( [ count , data ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> if k == all_black : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> rowList = combinationlist ( h ) <NEWLINE> colList = combinationlist ( w ) <NEWLINE> for comb in rowList : <NEWLINE> <INDENT> if w * len ( comb ) > h * w - k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in comb : <NEWLINE> <INDENT> count += rowset [ i - 1 ] [ 0 ] <NEWLINE> <DEDENT> if count == all_black - k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> if count <= all_black - k : <NEWLINE> <INDENT> for comb_2 in colList : <NEWLINE> <INDENT> comb_count = count <NEWLINE> for j in comb_2 : <NEWLINE> <INDENT> comb_count += colset [ j - 1 ] [ 0 ] <NEWLINE> for s in comb : <NEWLINE> <INDENT> if <STRING> == colset [ j - 1 ] [ 1 ] [ s - 1 ] : <NEWLINE> <INDENT> comb_count = comb_count - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if comb_count == all_black - k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for comb in colList : <NEWLINE> <INDENT> if h * len ( comb ) > h * w - k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in comb : <NEWLINE> <INDENT> count += colset [ i - 1 ] [ 0 ] <NEWLINE> <DEDENT> if count == all_black - k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> dxdy = ( ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ) <COMMENT> <NEWLINE> <NL> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> mp = [ input ( ) for _ in range ( H ) ] <NEWLINE> INF = 10 ** 10 <NEWLINE> dist = [ [ INF ] * W for _ in range ( H ) ] <NEWLINE> dist [ x1 - 1 ] [ y1 - 1 ] = 0 <NEWLINE> q = deque ( ) <NEWLINE> q . append ( ( x1 - 1 , y1 - 1 ) ) <COMMENT> <NEWLINE> while ( q ) : <NEWLINE> <INDENT> x , y = q . popleft ( ) <NEWLINE> if x == x2 - 1 and y == y2 - 1 : <NEWLINE> <INDENT> print ( dist [ x2 - 1 ] [ y2 - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for dx , dy in dxdy : <NEWLINE> <INDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> nx = x + dx * i <NEWLINE> ny = y + dy * i <NEWLINE> if not ( 0 <= nx < H and 0 <= ny < W ) or mp [ nx ] [ ny ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if dist [ nx ] [ ny ] <= dist [ x ] [ y ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if dist [ nx ] [ ny ] == INF : <NEWLINE> <INDENT> q . append ( ( nx , ny ) ) <NEWLINE> dist [ nx ] [ ny ] = dist [ x ] [ y ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( i , x ) ) <NEWLINE> i = i + 1 <NEWLINE> <NL> <DEDENT>
l = int ( input ( ) ) <NEWLINE> for i in range ( 1 , 21 ) : <NEWLINE> <INDENT> if 2 ** i > l : <NEWLINE> <INDENT> r = i - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> ans . append ( ( i + 1 , i + 2 , 0 ) ) <NEWLINE> ans . append ( ( i + 1 , i + 2 , 2 ** i ) ) <NEWLINE> <DEDENT> now = 2 ** r - 1 <NEWLINE> for i in range ( r , 0 , - 1 ) : <NEWLINE> <INDENT> if 2 ** ( i - 1 ) + now <= l - 1 : <NEWLINE> <INDENT> ans . append ( ( i , r + 1 , now + 1 ) ) <NEWLINE> now += 2 ** ( i - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( r + 1 , len ( ans ) ) <NEWLINE> for x in ans : <NEWLINE> <INDENT> print ( * x ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> A = A % MOD <NEWLINE> <NL> AS = [ ] <NEWLINE> s = 0 <NEWLINE> for a in range ( len ( A ) ) : <NEWLINE> <INDENT> s = ( s + A [ a ] ) % MOD <NEWLINE> AS . append ( s ) <NEWLINE> <DEDENT> AS = np . array ( AS ) <NEWLINE> <NL> s = 0 <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> s = ( A [ i ] * ( ( AS [ N - 1 ] - AS [ i ] ) ) % MOD + s ) % MOD <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
import numpy as np <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if b == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( 1 , int ( n / b ) + 1 + 1 ) : <NEWLINE> <INDENT> if k * b - 1 <= n : <NEWLINE> <COMMENT> <NL> <INDENT> ans = max ( ans , np . floor ( a * ( k * b - 1 ) / b ) - a * ( k - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ans = max ( ans , np . floor ( a * n / b ) - a * ( k - 1 ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> while b != 0 : <NEWLINE> <INDENT> t = a % b <NEWLINE> a = b <NEWLINE> b = t <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> N = int ( input ( <STRING> ) ) <NEWLINE> for a in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> x = gcd ( a , b ) <NEWLINE> if x == 1 : <NEWLINE> <INDENT> sum = sum + N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for c in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> sum = sum + gcd ( x , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = [ 0 ] * ( n + 1 ) <NEWLINE> c = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c [ a ] . append ( b ) <NEWLINE> c [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> que = deque ( [ 1 ] ) <NEWLINE> check = [ 0 for i in range ( n + 1 ) ] <NEWLINE> check [ 1 ] = 1 <NEWLINE> while que : <NEWLINE> <INDENT> now = que . popleft ( ) <NEWLINE> nx = c [ now ] <NEWLINE> for i in nx : <NEWLINE> <INDENT> if check [ i ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> check [ i ] = 1 <NEWLINE> lis [ i ] = now <NEWLINE> que . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if 0 in lis [ 2 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in lis [ 2 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> gcds = [ ] <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gcds . append ( gcd ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> ans = { i : 0 for i in set ( gcds ) } <NEWLINE> for i in gcds : <NEWLINE> <INDENT> ans [ i ] += 1 <NEWLINE> <DEDENT> out = 0 <NEWLINE> for i , v in ans . items ( ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> out += gcd ( i , j ) * v <NEWLINE> <DEDENT> <DEDENT> print ( out ) <NEWLINE> <NL> <DEDENT> def gcd ( x , y ) : <NEWLINE> <INDENT> r = x % y <NEWLINE> while r : <NEWLINE> <INDENT> x , y , r = y , r , y % r <NEWLINE> <DEDENT> return y <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i - k ] < a [ i ] : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if b > n : <NEWLINE> <INDENT> max = ( math . floor ( a * n / b ) ) - a * ( math . floor ( n / b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max = ( math . floor ( a * ( b - 1 ) / b ) ) - a * ( math . floor ( ( b - 1 ) / b ) ) <NEWLINE> <DEDENT> print ( max ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> n = readInt ( ) <NEWLINE> a = readInts ( ) <NEWLINE> rate = [ 0 ] * 9 <NEWLINE> <NL> <NL> for i in a : <NEWLINE> <INDENT> rate [ min ( i // 400 , 8 ) ] += 1 <NEWLINE> <DEDENT> base = 8 - rate [ : - 1 ] . count ( 0 ) <NEWLINE> ma = base + rate [ - 1 ] <NEWLINE> print ( max ( base , 1 ) , ma ) <NEWLINE>
def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = [ ] <NEWLINE> count = 1 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> if ( count not in cnt ) : <NEWLINE> <INDENT> cnt . append ( count ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> count += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( len ( cnt ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( 1 ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( 1 ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> num = factorization ( n ) <NEWLINE> if ( n == 1 ) : <NEWLINE> <INDENT> num = [ 0 ] <NEWLINE> <NL> <DEDENT> print ( sum ( num ) ) <NEWLINE>
N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> C = Counter ( a ) <NEWLINE> s = sum ( a ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s = s - b * C [ b ] + c * C [ b ] <NEWLINE> C [ c ] += C [ b ] <NEWLINE> C [ b ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> la = 0 <NEWLINE> ra = n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> la = max ( la , l ) <NEWLINE> ra = min ( ra , r ) <NEWLINE> <DEDENT> print ( max ( 0 , ra - la + 1 ) ) <NEWLINE>
<COMMENT> <NL> <NL> def II ( ) : return int ( input ( ) ) <NEWLINE> def MII ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LII ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <INDENT> N = II ( ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> a = S . find ( str ( i ) ) <NEWLINE> if a != - 1 : <NEWLINE> <INDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> b = S . find ( str ( j ) , a + 1 ) <NEWLINE> if b != - 1 : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> c = S . find ( str ( k ) , b + 1 ) <NEWLINE> if c != - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> if k == 1 : <NEWLINE> <INDENT> print ( int ( s [ 0 ] ) ) <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while cnt < len ( s ) and s [ cnt ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if cnt >= k : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif cnt == len ( s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ cnt ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( s [ 0 ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> N , S = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> A = np . fromstring ( input ( ) . strip ( ) , dtype = np . int32 , sep = <STRING> ) <NEWLINE> return N , S , A <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def solve ( N , S , A , MOD = 998244353 ) : <NEWLINE> <INDENT> dp = np . zeros ( ( S + 1 ) , dtype = np . int32 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( S , - 1 , - 1 ) : <NEWLINE> <INDENT> v = 2 * dp [ j ] <NEWLINE> if j - A [ i ] >= 0 : <NEWLINE> <INDENT> v += dp [ j - A [ i ] ] <NEWLINE> <DEDENT> dp [ j ] = v % MOD <NEWLINE> <DEDENT> <DEDENT> return dp [ S ] <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> inputs = read ( ) <NEWLINE> outputs = solve ( * inputs ) <NEWLINE> if outputs is not None : <NEWLINE> <INDENT> print ( <STRING> % str ( outputs ) ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> list = [ a * c , a * d , b * c , b * d ] <NEWLINE> print ( max ( list ) ) <NEWLINE>
from itertools import accumulate <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> check = list ( accumulate ( A ) ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> result = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> result += ( A [ i ] * ( check [ N - 1 ] - check [ i ] ) ) <NEWLINE> result %= MOD <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> a_sum = [ 0 ] <NEWLINE> b_sum = [ 0 ] <NEWLINE> <NL> max_counter = 0 <NEWLINE> <NL> j = m <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a_sum . append ( a_sum [ i ] + a [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b_sum . append ( b_sum [ i ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a_sum [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> while k < a_sum [ i ] + b_sum [ j ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <DEDENT> max_counter = max ( max_counter , i + j ) <NEWLINE> <NL> <DEDENT> print ( max_counter ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = [ 0 ] * n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a [ i ] += a [ i - 1 ] <NEWLINE> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a [ r - 1 ] - a [ l - 1 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p1 , p2 , p3 , p4 = 0 , 0 , 0 , 0 <NEWLINE> hyp = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p1 += math . fabs ( a1 [ i ] - a2 [ i ] ) <NEWLINE> p2 += ( a1 [ i ] - a2 [ i ] ) ** 2 <NEWLINE> p3 += math . fabs ( ( a1 [ i ] - a2 [ i ] ) ** 3 ) <NEWLINE> hyp = math . fabs ( a1 [ i ] - a2 [ i ] ) <NEWLINE> if hyp > p4 : <NEWLINE> <INDENT> p4 = hyp <NEWLINE> <NL> <DEDENT> <DEDENT> p2 = math . sqrt ( p2 ) <NEWLINE> if p3 != 0 : <NEWLINE> <INDENT> p3 = math . exp ( math . log ( p3 ) / 3 ) <NEWLINE> <DEDENT> print ( p1 ) <NEWLINE> print ( p2 ) <NEWLINE> print ( p3 ) <NEWLINE> print ( p4 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> <NL> total_comb = r * g * b <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if S [ i ] == S [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> k = 2 * j - i <NEWLINE> <COMMENT> <NL> if k > N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> if S [ i ] == S [ k ] or S [ j ] == S [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total_comb - count ) <NEWLINE>
from sys import exit , stdin <NEWLINE> <NL> input = stdin . readline <NEWLINE> import copy <NEWLINE> from collections import deque , Counter <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> class BIT : <NEWLINE> <INDENT> def __init__ ( self , a = 0 ) : <NEWLINE> <INDENT> self . n = a <NEWLINE> self . d = [ 0 ] * ( a + 1 ) <NEWLINE> <NL> <DEDENT> def add ( self , i , x = 1 ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> while i <= self . n : <NEWLINE> <INDENT> self . d [ i ] += x <NEWLINE> i += i & ( - i ) <NEWLINE> <NL> <DEDENT> <DEDENT> def sum ( self , * i ) : <NEWLINE> <INDENT> if len ( i ) == 1 : <NEWLINE> <INDENT> x = 0 <NEWLINE> i += 1 <NEWLINE> while i : <NEWLINE> <INDENT> x += self . d [ i ] <NEWLINE> i -= i & ( - i ) <NEWLINE> <DEDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return sum ( self , i [ 1 ] - 1 ) - sum ( self , i [ 0 ] - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . n = N <NEWLINE> self . parents = [ - 1 ] * N <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> rx = self . find ( x ) <NEWLINE> ry = self . find ( y ) <NEWLINE> <NL> if rx == ry : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if - ( self . parents [ rx ] ) < - ( self . parents [ ry ] ) : <NEWLINE> <INDENT> rx , ry = ry , rx <NEWLINE> <DEDENT> self . parents [ rx ] += self . parents [ ry ] <NEWLINE> self . parents [ ry ] = rx <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> return - ( self . parents [ self . find ( x ) ] ) <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if M == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> D = UnionFind ( N ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> D . union ( a , b ) <NEWLINE> <NL> <DEDENT> num = [ D . size ( r ) for r in D . roots ( ) ] <NEWLINE> <NL> print ( max ( num ) ) <NEWLINE>
import functools <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> xs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def foldMulti ( acc , x ) : <NEWLINE> <INDENT> return acc * x <NEWLINE> <NL> <DEDENT> if 0 in xs : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif len ( [ x for x in xs if x > 1 ] ) >= 60 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = functools . reduce ( foldMulti , xs , 1 ) <NEWLINE> <NL> if res > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> Height = [ h_i for h_i in map ( int , input ( ) . split ( ) ) ] <NEWLINE> Roots = [ ] <NEWLINE> counter = [ 0 for i in range ( N ) ] <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> root = [ c_i - 1 for c_i in map ( int , input ( ) . split ( ) ) ] <NEWLINE> <COMMENT> <NL> if Height [ root [ 0 ] ] < Height [ root [ 1 ] ] : <NEWLINE> <INDENT> counter [ root [ 0 ] ] += 1 <NEWLINE> <DEDENT> elif Height [ root [ 0 ] ] == Height [ root [ 1 ] ] : <NEWLINE> <INDENT> counter [ root [ 0 ] ] += 1 <NEWLINE> counter [ root [ 1 ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counter [ root [ 1 ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> counter2 = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if counter [ i ] == 0 : <NEWLINE> <INDENT> counter2 += 1 <NEWLINE> <DEDENT> <DEDENT> print ( counter2 ) <NEWLINE>
import math <NEWLINE> A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> if A > B : <NEWLINE> <INDENT> K1 = math . ceil ( math . log ( A / B , 2 ) ) <NEWLINE> B = B * ( 2 ** K1 ) <NEWLINE> if A == B : <NEWLINE> <INDENT> B = B * 2 <NEWLINE> K1 = K1 + 1 <NEWLINE> <DEDENT> <DEDENT> elif A == B : <NEWLINE> <INDENT> B = B * 2 <NEWLINE> K1 = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K1 = 0 <NEWLINE> <NL> <DEDENT> if B > C : <NEWLINE> <INDENT> K2 = math . ceil ( math . log ( B / C , 2 ) ) <NEWLINE> C = C * ( 2 ** K2 ) <NEWLINE> if C == B : <NEWLINE> <INDENT> K2 = K2 + 1 <NEWLINE> <DEDENT> <DEDENT> elif B == C : <NEWLINE> <INDENT> K2 = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K2 = 0 <NEWLINE> <NL> <DEDENT> if K1 + K2 <= K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> b = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> import itertools <NEWLINE> a = range ( 1 , M + 1 ) <NEWLINE> for set_A in itertools . combinations_with_replacement ( a , N ) : <NEWLINE> <INDENT> A = list ( set_A ) <NEWLINE> n = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> if A [ b [ i ] [ 1 ] - 1 ] - A [ b [ i ] [ 0 ] - 1 ] == b [ i ] [ 2 ] : <NEWLINE> <INDENT> n += b [ i ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , n ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ 0 ] * Q <NEWLINE> C = [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B [ i ] , C [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> S = [ 0 ] * Q <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> cnt = [ 0 ] * 100005 <COMMENT> <NEWLINE> for i in A : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> tot = sum ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <COMMENT> <NL> <INDENT> tot -= B [ i ] * cnt [ B [ i ] ] <NEWLINE> tot -= C [ i ] * cnt [ C [ i ] ] <NEWLINE> <COMMENT> <NL> cnt [ C [ i ] ] += cnt [ B [ i ] ] <NEWLINE> cnt [ B [ i ] ] = 0 <NEWLINE> <COMMENT> <NL> tot += B [ i ] * cnt [ B [ i ] ] <NEWLINE> tot += C [ i ] * cnt [ C [ i ] ] <NEWLINE> print ( tot ) <NEWLINE> <NL> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + a <NEWLINE> check = [ 0 ] * ( n + 1 ) <NEWLINE> check [ 1 ] = 1 <NEWLINE> <NL> i = 0 <NEWLINE> nw = 1 <NEWLINE> path = [ 1 ] <NEWLINE> while 1 : <NEWLINE> <INDENT> nx = a [ nw ] <NEWLINE> i += 1 <NEWLINE> if i == k : <NEWLINE> <INDENT> print ( nx ) <NEWLINE> break <NEWLINE> <DEDENT> if check [ nx ] : <NEWLINE> <INDENT> j = path . index ( nx ) <NEWLINE> d = j + ( k - i ) % ( i - j ) <NEWLINE> print ( path [ d ] ) <NEWLINE> break <NEWLINE> <DEDENT> path . append ( nx ) <NEWLINE> check [ nx ] = 1 <NEWLINE> nw = nx <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from heapq import * <NEWLINE> i = input <NEWLINE> for _ in <STRING> * int ( i ( ) ) : <NEWLINE> <INDENT> n , s , x , * y = int ( i ( ) ) , 0 , [ ] <NEWLINE> for _ in <STRING> * n : k , l , r = t = [ * map ( int , i ( ) . split ( ) ) ] ; x += [ t ] * ( l > r ) ; y += [ [ n - k , r , l ] ] * ( l <= r ) <NEWLINE> for x in x , y : <NEWLINE> <INDENT> x . sort ( ) ; n , * h = len ( x ) , <NEWLINE> while n : <NEWLINE> <INDENT> while [ [ n , 0 , 0 ] ] < x [ - 1 : ] : k , l , r = x . pop ( ) ; heappush ( h , ( r - l , l , r ) ) <NEWLINE> if h : s += heappop ( h ) [ 1 ] <NEWLINE> n -= 1 <NEWLINE> <DEDENT> for * _ , r in x + h : s += r <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
from numba import njit <NEWLINE> <NL> @ njit ( cache = True ) <NEWLINE> def aaa ( n , k , a ) : <NEWLINE> <INDENT> for f in range ( k ) : <NEWLINE> <INDENT> a1 = [ 0 ] * ( n + 1 ) <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> y = max ( 0 , x - a [ x ] ) <NEWLINE> a1 [ y ] = a1 [ y ] + 1 <NEWLINE> z = min ( n - 1 , x + a [ x ] ) <NEWLINE> a1 [ z + 1 ] = a1 [ z + 1 ] - 1 <NEWLINE> <DEDENT> a [ 0 ] = a1 [ 0 ] <NEWLINE> for x in range ( 1 , n ) : <NEWLINE> <INDENT> a [ x ] = a [ x - 1 ] + a1 [ x ] <NEWLINE> <DEDENT> if a == [ n ] * n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return a <NEWLINE> <NL> <DEDENT> x = input ( ) <NEWLINE> x0 = x . split ( ) <NEWLINE> n = int ( x0 [ 0 ] ) <NEWLINE> k = int ( x0 [ 1 ] ) <NEWLINE> a0 = input ( ) <NEWLINE> a0 = a0 . split ( ) <NEWLINE> a = [ int ( s ) for s in a0 ] <NEWLINE> <NL> b = aaa ( n , k , a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( b [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> N , T , A = map ( int , input ( ) . split ( ) ) ; INF = float ( <STRING> ) <NEWLINE> T -= 1 ; A -= 1 <COMMENT> <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <COMMENT> <NEWLINE> G [ a ] . append ( b ) ; G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> disT = [ INF for _ in range ( N ) ] ; disT [ T ] = 0 <NEWLINE> disA = [ INF for _ in range ( N ) ] ; disA [ A ] = 0 <NEWLINE> <NL> def dfs ( v , L ) : <NEWLINE> <INDENT> for u in G [ v ] : <NEWLINE> <INDENT> if L [ u ] != INF : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> L [ u ] = L [ v ] + 1 <NEWLINE> dfs ( u , L ) <NEWLINE> <DEDENT> <DEDENT> dfs ( T , disT ) <NEWLINE> dfs ( A , disA ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if disT [ i ] < disA [ i ] : <NEWLINE> <INDENT> ans = max ( ans , disA [ i ] - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = [ [ int ( j ) for j in input ( ) . split ( ) ] for i in range ( n ) ] <NEWLINE> b = [ int ( input ( ) ) for i in range ( m ) ] <NEWLINE> <NL> ans = [ sum ( [ a [ j ] [ i ] * b [ i ] for i in range ( m ) ] ) for j in range ( n ) ] <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( sorted ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> R = [ [ None ] * 2000 for i in range ( n + 1 ) ] <NEWLINE> <NL> def solve ( A , i , m , n ) : <NEWLINE> <INDENT> if R [ i ] [ m ] != None : <NEWLINE> <INDENT> return R [ i ] [ m ] <NEWLINE> <DEDENT> if m == 0 : <NEWLINE> <INDENT> R [ i ] [ m ] = True <NEWLINE> return True <NEWLINE> <DEDENT> elif i >= n : <NEWLINE> <INDENT> R [ i ] [ m ] = False <NEWLINE> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = solve ( A , i + 1 , m , n ) or solve ( A , i + 1 , m - A [ i ] , n ) <NEWLINE> R [ i ] [ m ] = ans <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> <DEDENT> for i in M : <NEWLINE> <INDENT> if sum ( A ) < i : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif solve ( A , 0 , i , n ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
string = input ( ) <NEWLINE> index_of_A = string . index ( <STRING> ) <NEWLINE> index_of_Z = string . rfind ( <STRING> ) <NEWLINE> <NL> print ( index_of_Z - index_of_A + 1 ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> x = 2 <NEWLINE> <NL> def hantei ( x , a , b ) : <NEWLINE> <INDENT> rr = 0 <NEWLINE> rr = int ( a * x // b ) - a * int ( x // b ) <NEWLINE> return rr <NEWLINE> <NL> <NL> <NL> <DEDENT> mx = n // b <NEWLINE> ans = 0 <NEWLINE> ans_n = hantei ( n , a , b ) <NEWLINE> ans_0 = hantei ( 0 , a , b ) <NEWLINE> <NL> if ( mx == 0 ) : <NEWLINE> <INDENT> x = n <NEWLINE> ans = hantei ( x , a , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = 1 <NEWLINE> x = 2 * b - 1 <NEWLINE> ans = max ( ans , hantei ( x , a , b ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> asn = max ( ans , ans_n , ans_0 ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> u = - 1 - i <NEWLINE> b . append ( a [ u ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( b ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = list ( map ( int , input ( ) . split ( ) ) for _ in range ( q ) ) <NEWLINE> <NL> s = sum ( a ) <NEWLINE> <NL> num = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for x in a : <NEWLINE> <INDENT> num [ x ] += 1 <NEWLINE> <NL> <DEDENT> for b , c in bc : <NEWLINE> <INDENT> s += ( c - b ) * num [ b ] <NEWLINE> num [ c ] += num [ b ] <NEWLINE> num [ b ] = 0 <NEWLINE> <NL> print ( s ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ - 1 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> visit = [ False for i in range ( N + 1 ) ] <NEWLINE> now = 1 <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if visit [ now ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> visit [ now ] = True <NEWLINE> now = A [ now ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> cnt2 = 0 <NEWLINE> visit2 = [ False for i in range ( N + 1 ) ] <NEWLINE> while True : <NEWLINE> <INDENT> if visit2 [ now ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> visit2 [ now ] = True <NEWLINE> now = A [ now ] <NEWLINE> cnt2 += 1 <NEWLINE> <NL> <DEDENT> if cnt >= K : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans = A [ ans ] <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> K -= cnt <NEWLINE> K = K % cnt2 <NEWLINE> ans = now <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans = A [ ans ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> LI = list ( range ( 1 , n + 1 ) ) <NEWLINE> kari = n + 1 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if li . count ( x ) != 0 : <NEWLINE> <INDENT> if LI . count ( x ) != 0 : <NEWLINE> <INDENT> LI . remove ( x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( LI ) ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> <NL> s = 0 <NEWLINE> a = 1 <NEWLINE> b = 1 <NEWLINE> while a * b < n : <NEWLINE> <INDENT> while a * b < n and b <= a : <NEWLINE> <INDENT> if a == b : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += 2 <NEWLINE> <DEDENT> b += 1 <NEWLINE> <DEDENT> a += 1 <NEWLINE> b = 1 <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> sm = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gcdab = math . gcd ( i , l ) <NEWLINE> for m in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sm += math . gcd ( gcdab , m ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sm ) <NEWLINE>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> n , k = MAP ( ) <NEWLINE> s = input ( ) <NEWLINE> count = 0 <NEWLINE> flag = 1 <NEWLINE> que = deque ( [ 0 ] * ( 2 * k + 1 ) ) <NEWLINE> ans = 0 <NEWLINE> tmp = 0 <NEWLINE> for x in s : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> if flag == 1 : <NEWLINE> <INDENT> que . append ( count ) <NEWLINE> tmp += count - que . popleft ( ) <NEWLINE> ans = max ( ans , tmp ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> flag = 0 <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if flag == 0 : <NEWLINE> <INDENT> que . append ( count ) <NEWLINE> tmp += count - que . popleft ( ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> flag = 1 <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> que . append ( count ) <NEWLINE> tmp += count - que . popleft ( ) <NEWLINE> if s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> tmp -= que . popleft ( ) <NEWLINE> <DEDENT> ans = max ( ans , sum ( que ) ) <NEWLINE> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> check = list ( s ) <NEWLINE> n = len ( s ) <NEWLINE> cntb = 0 <NEWLINE> for i in check : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> cntb += 1 <NEWLINE> <DEDENT> <DEDENT> minus = sum ( [ i + 1 for i in range ( n ) if check [ i ] == <STRING> ] ) <NEWLINE> plus = sum ( range ( n - cntb + 1 , n + 1 ) ) <NEWLINE> print ( plus - minus ) <NEWLINE>
n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( min ( y // 10000 + 1 , n + 1 ) ) : <NEWLINE> <INDENT> for j in range ( min ( ( y - 10000 * i ) // 5000 + 1 , n - i + 1 ) ) : <NEWLINE> <INDENT> k = n - i - j <NEWLINE> if i * 10000 + j * 5000 + k * 1000 == y and i + j + k == n : <NEWLINE> <INDENT> print ( i , j , k ) ; exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> G = [ [ ] for _ in range ( N ) ] <NEWLINE> ins = [ 0 ] * N <NEWLINE> for x , y in xy : <NEWLINE> <INDENT> G [ x - 1 ] . append ( y - 1 ) <NEWLINE> ins [ y - 1 ] += 1 <NEWLINE> <NL> <DEDENT> DP = [ 0 ] * N <NEWLINE> queue = deque ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ins [ i ] == 0 : <NEWLINE> <INDENT> queue . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> while queue : <NEWLINE> <INDENT> v = queue . popleft ( ) <NEWLINE> for i in G [ v ] : <NEWLINE> <INDENT> ins [ i ] -= 1 <NEWLINE> if ins [ i ] == 0 : <NEWLINE> <INDENT> DP [ i ] = max ( DP [ i ] , DP [ v ] + 1 ) <NEWLINE> queue . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max ( DP ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT> exit ( ) <NEWLINE>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N >= B : <NEWLINE> <INDENT> N = B - 1 <NEWLINE> <DEDENT> ans = math . floor ( A * N / B ) <NEWLINE> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if ( N [ 0 ] == <STRING> ) or ( N [ 1 ] == <STRING> ) or ( N [ 2 ] == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_sum = [ 0 ] <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> a_sum . append ( a_sum [ len ( a_sum ) - 1 ] + a [ i ] ) <NEWLINE> <NL> <DEDENT> b_sum = [ 0 ] <NEWLINE> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> b_sum . append ( b_sum [ len ( b_sum ) - 1 ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> b_i = len ( b_sum ) - 1 <NEWLINE> <NL> for i in range ( len ( a_sum ) ) : <NEWLINE> <INDENT> if a_sum [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b_i > - 1 : <NEWLINE> <INDENT> while b_sum [ b_i ] + a_sum [ i ] > k and b_i > - 1 : <NEWLINE> <INDENT> b_i -= 1 <NEWLINE> <DEDENT> if b_i > - 1 and ans < i + b_i : <NEWLINE> <INDENT> ans = i + b_i <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a_i > ans : <NEWLINE> <INDENT> ans = a_i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> def gcd ( inta , intb ) : <NEWLINE> <INDENT> large = max ( inta , intb ) <NEWLINE> small = min ( inta , intb ) <NEWLINE> mod = large % small <NEWLINE> if mod == 0 : <NEWLINE> <INDENT> return small <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( small , mod ) <NEWLINE> <NL> <DEDENT> <DEDENT> def lcm ( inta , intb , intgcd ) : <NEWLINE> <INDENT> return ( inta * intb // intgcd ) <NEWLINE> <NL> <DEDENT> sets = sys . stdin . readlines ( ) <NEWLINE> for line in sets : <NEWLINE> <INDENT> a , b = map ( int , line . split ( ) ) <NEWLINE> c = gcd ( a , b ) <NEWLINE> print ( c , lcm ( a , b , c ) ) <NEWLINE> <DEDENT>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ls = [ False ] * M <NEWLINE> ls_mod = [ ] <NEWLINE> x = X <NEWLINE> for m in range ( M + 1 ) : <NEWLINE> <INDENT> if ls [ x ] == False : <NEWLINE> <INDENT> ls_mod . append ( x ) <NEWLINE> ls [ x ] = m <NEWLINE> x = ( x ** 2 ) % M <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> last = m <NEWLINE> fast = ls [ x ] <NEWLINE> diff = last - fast <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if M == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if last > N : <NEWLINE> <INDENT> print ( sum ( ls_mod [ : N ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> shou = ( N - fast ) // diff <NEWLINE> amari = ( N - fast ) % diff <NEWLINE> print ( sum ( ls_mod [ : fast ] ) + sum ( ls_mod [ fast : ] ) * shou + sum ( ls_mod [ fast : fast + amari ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if b > n : <NEWLINE> <INDENT> x = n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = n // b * b - 1 <NEWLINE> <DEDENT> answer = max ( 0 , ( a * x ) // b - a * ( x // b ) ) <NEWLINE> <NL> print ( answer ) <NEWLINE>
S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> lS = <STRING> <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> query = input ( ) . split ( ) <NEWLINE> if query [ 0 ] == <STRING> : <NEWLINE> <INDENT> lS , S = S , lS <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if query [ 1 ] == <STRING> : <NEWLINE> <INDENT> lS += query [ 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S += query [ 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( lS [ : : - 1 ] + S ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> lst = [ ] <NEWLINE> visit_now = 1 <NEWLINE> visit_list = [ - 1 ] * ( n + 1 ) <NEWLINE> cnt = 0 <NEWLINE> <NL> while visit_list [ visit_now - 1 ] == - 1 : <NEWLINE> <INDENT> visit_list [ visit_now - 1 ] = cnt <NEWLINE> lst . append ( visit_now ) <NEWLINE> visit_now = a [ visit_now - 1 ] <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> start = visit_list [ visit_now - 1 ] <NEWLINE> loop_num = cnt - start <NEWLINE> <NL> if k <= start : <NEWLINE> <INDENT> ans = lst [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= start <NEWLINE> k %= loop_num <NEWLINE> ans = lst [ start + k ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> r = math . gcd ( i + 1 , j + 1 ) <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> sum += math . gcd ( r , k + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> mod = 1000000007 <NEWLINE> <NL> memo = [ - 1 ] * ( n + 1 ) <NEWLINE> memo [ 0 ] = 0 <NEWLINE> <NL> for k in range ( m ) : <NEWLINE> <INDENT> memo [ a [ k ] ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if memo [ i ] != - 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif i <= 2 : <NEWLINE> <INDENT> memo [ i ] = memo [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memo [ i ] = memo [ i - 1 ] + memo [ i - 2 ] <NEWLINE> <DEDENT> <DEDENT> print ( memo [ - 1 ] % mod ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <NL> def g ( N : int ) -> int : <NEWLINE> <INDENT> return int ( N * ( N + 1 ) / 2 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += n * g ( N // n ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> r = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( L ) <NEWLINE> r . append ( R ) <NEWLINE> <NL> <DEDENT> ans = min ( r ) - max ( l ) + 1 <NEWLINE> <NL> print ( max ( ans , 0 ) ) <NEWLINE>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> b = l [ : i ] <NEWLINE> c = l [ i + 1 : ] <NEWLINE> for j in b : <NEWLINE> <INDENT> ans += bisect . bisect_left ( c , l [ i ] + j ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> a = 1000000007 <NEWLINE> <NL> m , n = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> pow_list = [ m ] <NEWLINE> x = int ( math . log2 ( n ) ) <NEWLINE> for i in range ( x + 1 ) : <NEWLINE> <INDENT> pow_list . append ( ( pow_list [ - 1 ] ** 2 ) % a ) <NEWLINE> <NL> <DEDENT> result = 1 <NEWLINE> for i in range ( x + 1 ) : <NEWLINE> <INDENT> if n >= 2 ** ( x - i ) : <NEWLINE> <INDENT> n -= 2 ** ( x - i ) <NEWLINE> result = ( result * pow_list [ x - i ] ) % a <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> yakusuu = [ ] <NEWLINE> for i in range ( 1 , int ( m ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if m % i == 0 : <NEWLINE> <INDENT> yakusuu . append ( m // i ) <NEWLINE> if m // i == i : continue <NEWLINE> yakusuu . append ( i ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for y in yakusuu : <NEWLINE> <INDENT> if y < n : continue <NEWLINE> if m % y == 0 : <NEWLINE> <INDENT> ans = max ( ans , m // y ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> ans [ a [ i - 1 ] ] += 1 <NEWLINE> <DEDENT> ans . pop ( 0 ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> print ( ans [ j ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> prize = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s = str ( input ( ) ) <NEWLINE> if s in prize : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prize [ s ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( prize ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> res = 0 <NEWLINE> sum_a = sum ( a ) <NEWLINE> b = 0 <NEWLINE> t = 0 <NEWLINE> for i in range ( 0 , len ( a ) - 1 ) : <NEWLINE> <INDENT> t = a [ i ] <NEWLINE> b += a [ i ] <NEWLINE> res += ( sum_a - b ) * t % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( res % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> ms = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> iter_ms = iter ( ms ) <NEWLINE> r = 1 <NEWLINE> if 0 in ms : <NEWLINE> <INDENT> r = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> x = next ( iter_ms ) <NEWLINE> r *= x <NEWLINE> if r > 10 ** 18 : <NEWLINE> <INDENT> r = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
import sys ; <NEWLINE> <NL> def putQueen ( i , row , col , dpos , dneq ) : <NEWLINE> <INDENT> global finding <NEWLINE> if ( finding == 0 ) : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if ( i == 8 ) : <NEWLINE> <INDENT> finding = 0 <NEWLINE> printBoard ( row [ 0 : ] ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> for j in range ( 8 ) : <NEWLINE> <INDENT> if i in myset : <NEWLINE> <INDENT> putQueen ( i + 1 , row [ 0 : ] , col [ 0 : ] , dpos [ 0 : ] , dneq [ 0 : ] ) <NEWLINE> continue <NEWLINE> <DEDENT> if ( col [ j ] == 1 or dpos [ i + j ] == 1 or dneq [ i - j + 7 ] == 1 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> row [ i ] = j <NEWLINE> col [ j ] = dpos [ i + j ] = dneq [ i - j + 7 ] = 1 <NEWLINE> putQueen ( i + 1 , row [ 0 : ] , col [ 0 : ] , dpos [ 0 : ] , dneq [ 0 : ] ) <NEWLINE> col [ j ] = dpos [ i + j ] = dneq [ i - j + 7 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> def printBoard ( row ) : <NEWLINE> <INDENT> for k in range ( 8 ) : <NEWLINE> <INDENT> if ( row [ k ] == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( row [ k ] == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( row [ k ] == 2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( row [ k ] == 3 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( row [ k ] == 4 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( row [ k ] == 5 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( row [ k ] == 6 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = ( int ) ( input ( ) ) ; <NEWLINE> row = [ 0 for i in range ( 8 ) ] <NEWLINE> col = [ 0 for i in range ( 8 ) ] <NEWLINE> dpos = [ 0 for i in range ( 15 ) ] <NEWLINE> dneq = [ 0 for i in range ( 15 ) ] <NEWLINE> <NL> myset = set ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> r , c = map ( int , input ( ) . split ( ) ) ; <NEWLINE> myset . add ( r ) <NEWLINE> row [ r ] = c <NEWLINE> col [ c ] = 1 <NEWLINE> dpos [ r + c ] = 1 <NEWLINE> dneq [ r - c + 7 ] = 1 <NEWLINE> <NL> <DEDENT> finding = 1 <NEWLINE> <NL> putQueen ( 0 , row , col , dpos , dneq ) <NEWLINE> <NL>
from itertools import permutations as p <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> P = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> j = 0 <NEWLINE> <NL> for i in p ( range ( 1 , N + 1 ) ) : <NEWLINE> <INDENT> j += 1 <NEWLINE> if i == P : a = j <NEWLINE> if i == Q : b = j <NEWLINE> <NL> <DEDENT> if a - b >= 0 : print ( a - b ) <NEWLINE> else : print ( b - a ) <NEWLINE>
from functools import reduce <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for k in range ( N - K ) : <NEWLINE> <INDENT> score1 = A [ k ] <NEWLINE> score2 = A [ K + k ] <NEWLINE> if score1 < score2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a = list ( input ( ) ) <NEWLINE> b = list ( input ( ) ) <NEWLINE> f = False <NEWLINE> x = [ ] <NEWLINE> if len ( a ) > len ( b ) : <NEWLINE> <INDENT> b . append ( 0 ) <NEWLINE> f = True <NEWLINE> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> x . append ( a [ i ] ) <NEWLINE> x . append ( b [ i ] ) <NEWLINE> <DEDENT> if f : <NEWLINE> <INDENT> x . pop ( ) <NEWLINE> <DEDENT> print ( <STRING> . join ( x ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> from math import gcd <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . append ( l ) <NEWLINE> <NL> <DEDENT> def kikaku ( a , b ) : <NEWLINE> <INDENT> g = gcd ( a , b ) <NEWLINE> a //= g <NEWLINE> b //= g <NEWLINE> if a < 0 : <NEWLINE> <INDENT> return - a , - b <NEWLINE> <DEDENT> return a , b <NEWLINE> <COMMENT> <NL> <DEDENT> Dpos = defaultdict ( int ) <NEWLINE> <COMMENT> <NL> Dneg = defaultdict ( int ) <NEWLINE> <NL> zerozero = 0 <NEWLINE> azero = 0 <NEWLINE> bzero = 0 <NEWLINE> <NL> for l in L : <NEWLINE> <INDENT> a = l [ 0 ] <NEWLINE> b = l [ 1 ] <NEWLINE> if a == b == 0 : <NEWLINE> <INDENT> zerozero += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if a == 0 : <NEWLINE> <INDENT> azero += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if b == 0 : <NEWLINE> <INDENT> bzero += 1 <NEWLINE> continue <NEWLINE> <DEDENT> a , b = kikaku ( a , b ) <NEWLINE> if b > 0 : <NEWLINE> <INDENT> Dpos [ ( a , b ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Dneg [ ( a , - b ) ] += 1 <NEWLINE> Dpos [ ( - b , a ) ] += 0 <NEWLINE> <NL> <DEDENT> <DEDENT> r = 1 <NEWLINE> for k , v in Dpos . items ( ) : <NEWLINE> <INDENT> a , b = k <NEWLINE> j = Dneg [ ( b , a ) ] <NEWLINE> r *= pow ( 2 , v , MOD ) + pow ( 2 , j , MOD ) - 1 <NEWLINE> <COMMENT> <NL> r %= MOD <NEWLINE> <NL> <DEDENT> r *= pow ( 2 , azero , MOD ) + pow ( 2 , bzero , MOD ) - 1 <NEWLINE> r %= MOD <NEWLINE> r -= 1 <NEWLINE> r %= MOD <NEWLINE> <NL> ans = r + zerozero <NEWLINE> ans %= MOD <NEWLINE> print ( ans ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> <NL> <NL> def lcs ( A , B ) : <NEWLINE> <INDENT> m , n = len ( A ) , len ( B ) <NEWLINE> count_list = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] <NEWLINE> <NL> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if A [ i - 1 ] == B [ j - 1 ] : <NEWLINE> <INDENT> count_list [ i ] [ j ] = count_list [ i - 1 ] [ j - 1 ] + 1 <NEWLINE> <DEDENT> elif count_list [ i - 1 ] [ j ] >= count_list [ i ] [ j - 1 ] : <NEWLINE> <INDENT> count_list [ i ] [ j ] = count_list [ i - 1 ] [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count_list [ i ] [ j ] = count_list [ i ] [ j - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return count_list [ m ] [ n ] <NEWLINE> <NL> <NL> <DEDENT> def lcs_better ( X , Y ) : <NEWLINE> <INDENT> costs = [ 0 ] <NEWLINE> for c in Y : <NEWLINE> <INDENT> for i in range ( len ( costs ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> tmp = X . find ( c , costs [ i ] ) <NEWLINE> if tmp + 1 : <NEWLINE> <INDENT> if i + 1 < len ( costs ) : <NEWLINE> <INDENT> costs [ i + 1 ] = min ( costs [ i + 1 ] , tmp + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> costs . append ( tmp + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return len ( costs ) - 1 <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> pair_num = int ( _input [ 0 ] ) <NEWLINE> <NL> word_list = _input [ 1 : ] <NEWLINE> <COMMENT> <NL> for k in range ( 0 , len ( word_list ) , 2 ) : <NEWLINE> <INDENT> print ( lcs_better ( word_list [ k ] . strip ( ) , word_list [ k + 1 ] . strip ( ) ) ) <NEWLINE> <DEDENT> <DEDENT>
from networkx import * <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> X = [ [ 0 if a == <STRING> else 1 if a == <STRING> else 2 for a in input ( ) ] for _ in range ( N ) ] <NEWLINE> cnt = sum ( sum ( [ 1 if a == 2 else 0 for a in x ] ) for x in X ) <NEWLINE> G = MultiDiGraph ( ) <NEWLINE> t = N * M <NEWLINE> G . add_node ( t , demand = cnt ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> if X [ i ] [ j ] == 0 : continue <NEWLINE> a = i * M + j <NEWLINE> G . add_node ( a , demand = 1 - X [ i ] [ j ] ) <NEWLINE> G . add_edge ( a , t , capacity = 1 , weight = 0 ) <NEWLINE> if i + 1 < N and X [ i + 1 ] [ j ] : <NEWLINE> <INDENT> b = a + M <NEWLINE> G . add_edge ( a , b , capacity = N * M , weight = - 1 ) <NEWLINE> <DEDENT> if j + 1 < M and X [ i ] [ j + 1 ] : <NEWLINE> <INDENT> b = a + 1 <NEWLINE> G . add_edge ( a , b , capacity = N * M , weight = - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( - min_cost_flow_cost ( G ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> m = n <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <INDENT> while n > 0 : <NEWLINE> <NL> <INDENT> a = a + n % 10 <NEWLINE> n = n // 10 <NEWLINE> <DEDENT> if m % a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> o = { } <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> o [ i ] = 0 <NEWLINE> <NL> <DEDENT> for p in m : <NEWLINE> <INDENT> o [ p ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( o [ i ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> target = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( target ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <DEDENT>
def partition ( A , p , r ) : <NEWLINE> <INDENT> x = A [ r ] <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if A [ j ] <= x : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> <DEDENT> <DEDENT> A [ i + 1 ] , A [ r ] = A [ r ] , A [ i + 1 ] <NEWLINE> <NL> return i + 1 <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> k = partition ( A , 0 , len ( A ) - 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if i == k : <NEWLINE> <INDENT> print ( <STRING> + str ( A [ i ] ) + <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> elif i == n - 1 : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def function ( S ) : <NEWLINE> <INDENT> S = S [ : : - 1 ] <NEWLINE> mods = [ 0 ] * 2019 <COMMENT> <NEWLINE> mods [ 0 ] += 1 <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> num = 0 <NEWLINE> digit = 1 <NEWLINE> for c in S : <NEWLINE> <INDENT> num = ( int ( c ) * digit + num ) % 2019 <NEWLINE> digit = ( digit * 10 ) % 2019 <NEWLINE> mods [ num ] += 1 <NEWLINE> <NL> <DEDENT> result = 0 <NEWLINE> for m in mods : <NEWLINE> <INDENT> result += m * ( m - 1 ) // 2 <NEWLINE> <NL> <DEDENT> return str ( result ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( function ( input ( ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans ^ a [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans ^ a [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> p = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> p [ a ] . append ( b ) <NEWLINE> p [ b ] . append ( a ) <NEWLINE> <COMMENT> <NL> <DEDENT> sirube = [ - 1 ] * N <NEWLINE> visited = [ True ] + [ False ] * ( N - 1 ) <NEWLINE> def bfs ( ) : <NEWLINE> <INDENT> global visited , sirube <NEWLINE> queue = [ 1 ] <NEWLINE> while queue : <NEWLINE> <INDENT> now = queue . pop ( 0 ) <NEWLINE> <COMMENT> <NL> for n in p [ now ] : <NEWLINE> <INDENT> if not visited [ n - 1 ] : <NEWLINE> <INDENT> queue . append ( n ) <NEWLINE> visited [ n - 1 ] = True <NEWLINE> sirube [ n - 1 ] = now <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return <NEWLINE> <DEDENT> bfs ( ) <NEWLINE> if - 1 in sirube [ 1 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for sir in sirube [ 1 : ] : <NEWLINE> <INDENT> print ( sir ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import numpy as np <NEWLINE> import sys <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> import heapq <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def zz ( ) : <NEWLINE> <INDENT> return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def z ( ) : <NEWLINE> <INDENT> return int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def S ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) <NEWLINE> <NL> <NL> <DEDENT> def C ( line ) : <NEWLINE> <INDENT> return [ sys . stdin . readline ( ) for _ in range ( line ) ] <NEWLINE> <NL> <NL> <DEDENT> N , K = zz ( ) <NEWLINE> A , B = [ 0 ] * N , [ 0 ] * N <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = zz ( ) <NEWLINE> <DEDENT> A , B = zip ( * sorted ( zip ( A , B ) ) ) <NEWLINE> all_num = 0 <NEWLINE> for i , b in enumerate ( B ) : <NEWLINE> <INDENT> all_num += b <NEWLINE> if ( all_num >= K ) : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
def CountingSort ( A , B , k ) : <NEWLINE> <INDENT> C = [ 0 ] * ( k + 1 ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> C [ i ] = 0 <NEWLINE> <COMMENT> <NL> <DEDENT> for j in range ( 0 , n ) : <NEWLINE> <INDENT> C [ A [ j ] ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> C [ i ] = C [ i ] + C [ i - 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> for j in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> B [ C [ A [ j ] ] ] = A [ j ] <NEWLINE> C [ A [ j ] ] -= 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] * ( n + 1 ) <NEWLINE> CountingSort ( A , B , 100000 ) <NEWLINE> print ( <STRING> . join ( map ( str , B [ 1 : ] ) ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 1 <NEWLINE> target = 10 ** 18 <NEWLINE> <NL> if a . count ( 0 ) >= 1 : <NEWLINE> <INDENT> result = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for an in a : <NEWLINE> <INDENT> result = an * result <NEWLINE> if result > target : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> b = list ( a ) <NEWLINE> c = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> c [ b [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> print ( c [ j ] ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p . sort ( ) <NEWLINE> y = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] <= x : <NEWLINE> <INDENT> y = i <NEWLINE> if i != n - 1 and x < p [ i + 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> i = 0 <NEWLINE> while 1 == 1 : <NEWLINE> <INDENT> if y - i < 0 : <NEWLINE> <INDENT> print ( p [ 0 ] - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif x - i != p [ y - i ] : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> break <NEWLINE> <DEDENT> if n <= y + i : <NEWLINE> <INDENT> print ( p [ n - 1 ] + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif x + i != p [ y + i ] : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> break <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> s = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s [ i ] = ( p [ i ] + 1 ) / 2 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> p = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> p [ i ] = p [ i - 1 ] + s [ i - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , p [ i + k ] - p [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> i = 1 <NEWLINE> while 1 : <NEWLINE> <COMMENT> <NL> <INDENT> if n <= 26 ** i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n -= 26 ** i <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> name = <STRING> <NEWLINE> n -= 1 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> name += chr ( ord ( <STRING> ) + n % 26 ) <NEWLINE> n //= 26 <NEWLINE> <NL> <DEDENT> print ( name [ : : - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> ans = A [ 0 ] <NEWLINE> cur = 1 <NEWLINE> count = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if count <= N - 3 : <NEWLINE> <INDENT> ans += A [ cur ] * 2 <NEWLINE> count += 2 <NEWLINE> cur += 1 <NEWLINE> <DEDENT> elif count == N - 2 : <NEWLINE> <INDENT> ans += A [ cur ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> elif count == N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = sorted ( x ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] <= y [ n // 2 - 1 ] : <NEWLINE> <INDENT> print ( y [ n // 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y [ n // 2 - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
h , w = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> dp = [ [ 0 for i in range ( w ) ] for j in range ( h ) ] <NEWLINE> mod = 1e9 + 7 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if i == 0 and j == 0 : <NEWLINE> <INDENT> dp [ 0 ] [ 0 ] = 1 if ( s [ j ] == <STRING> ) else 0 <NEWLINE> <DEDENT> elif i == 0 : <NEWLINE> <INDENT> dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] if ( s [ j ] == <STRING> ) else 0 <NEWLINE> <DEDENT> elif j == 0 : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] if ( s [ 0 ] == <STRING> ) else 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] % mod + dp [ i ] [ j - 1 ] % mod ) % mod if s [ j ] == <STRING> else 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( int ( dp [ h - 1 ] [ w - 1 ] % mod ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < n : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b . append ( i + 1 - a [ i ] ) <NEWLINE> c . append ( a [ i ] + i + 1 ) <NEWLINE> <DEDENT> x = max ( b ) <NEWLINE> if x <= 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> b_ = [ 0 ] * ( x + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if 0 <= b [ i ] <= x : <NEWLINE> <INDENT> b_ [ b [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if 0 <= c [ i ] <= x : <NEWLINE> <INDENT> ans += b_ [ c [ i ] ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> <NL> <NL> way = [ [ ] for i in range ( N ) ] <NEWLINE> depth = [ float ( <STRING> ) for i in range ( N ) ] <NEWLINE> visited = [ False for i in range ( N ) ] <NEWLINE> que = [ 0 ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> way [ x - 1 ] . append ( y - 1 ) <NEWLINE> way [ y - 1 ] . append ( x - 1 ) <NEWLINE> <NL> <DEDENT> for i in que : <NEWLINE> <INDENT> for j in way [ i ] : <NEWLINE> <INDENT> if visited [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> que . append ( j ) <NEWLINE> visited [ j ] = True <NEWLINE> depth [ j ] = min ( i + 1 , depth [ j ] ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( depth [ i ] ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max_a = 10 ** 6 + 1 <NEWLINE> a = sorted ( a ) <NEWLINE> dic = defaultdict ( lambda : False ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ai = a [ i ] <NEWLINE> if dic [ ai ] == True : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 1 , math . ceil ( max_a / ai ) ) : <NEWLINE> <INDENT> dic [ j * ai ] = True <NEWLINE> <DEDENT> if ( i + 1 ) < n and a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( n - count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> a_max = a [ - 1 ] <NEWLINE> ans_list = [ 0 ] * a_max <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <NL> <INDENT> p = a [ i ] <NEWLINE> <NL> if ans_list [ p - 1 ] == 0 : <NEWLINE> <INDENT> for q in range ( 1 , ( a_max // p ) + 1 ) : <NEWLINE> <INDENT> ans_list [ p * q - 1 ] = 1 <NEWLINE> <NL> <DEDENT> if a [ i ] != a [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans_list [ a_max - 1 ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ [ int ( input ( ) ) , i ] for i in range ( n ) ] <NEWLINE> a . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 != a [ i ] [ 1 ] % 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> aa = [ 0 ] <NEWLINE> bb = [ 0 ] <NEWLINE> <NL> for s in range ( n ) : <NEWLINE> <INDENT> aa . append ( aa [ s ] + a [ s ] ) <NEWLINE> <DEDENT> for s in range ( m ) : <NEWLINE> <INDENT> bb . append ( bb [ s ] + b [ s ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if aa [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while bb [ j ] > k - aa [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 10050 ) ] <NEWLINE> for i in range ( 1 , 105 ) : <NEWLINE> <INDENT> for j in range ( 1 , 105 ) : <NEWLINE> <INDENT> for k in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = i * i + j * j + k * k + i * j + j * k + k * i ; <NEWLINE> if v < 10050 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 + 5 ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Graph = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> is_good = [ False ] + [ True ] * N <NEWLINE> seen = [ True ] + [ False ] * N <NEWLINE> <NL> def dfs ( cur ) : <NEWLINE> <INDENT> global Graph , seen , H <NEWLINE> seen [ cur ] = True <NEWLINE> for nex in Graph [ cur ] : <NEWLINE> <INDENT> if H [ nex ] >= H [ cur ] : <NEWLINE> <INDENT> is_good [ cur ] = False <NEWLINE> <DEDENT> if seen [ nex ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( nex ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> Graph [ a ] . append ( b ) <NEWLINE> Graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if not seen [ i ] : <NEWLINE> <INDENT> dfs ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( is_good . count ( True ) ) <NEWLINE>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max_number = 10 ** 18 <NEWLINE> result = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> result = result * a <NEWLINE> if result > max_number : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> sorted_A = sorted ( A ) <NEWLINE> [ print ( sorted_A [ - 2 ] if sorted_A [ - 1 ] == A [ i ] else sorted_A [ - 1 ] ) for i in range ( N ) ] <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for c in range ( N ) ] <NEWLINE> A = sorted ( A ) <NEWLINE> <NL> tmp = 1 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i + 1 < N : <NEWLINE> <INDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += tmp % 2 <NEWLINE> tmp = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt += tmp % 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<NL> def method ( ) : <NEWLINE> <INDENT> a , v = input ( ) . split ( ) <NEWLINE> b , w = input ( ) . split ( ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> a = int ( a ) <COMMENT> <NEWLINE> v = int ( v ) <COMMENT> <NEWLINE> b = int ( b ) <COMMENT> <NEWLINE> w = int ( w ) <COMMENT> <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> distance = b - a <NEWLINE> relative_speed = v - w <NEWLINE> if relative_speed <= 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( distance / relative_speed ) > t : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> distance = a - b <NEWLINE> relative_speed = v - w <NEWLINE> if relative_speed <= 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( distance / relative_speed ) > t : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( method ( ) ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> table = [ ] <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> table . append ( [ a , i ] ) <NEWLINE> <DEDENT> table . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> DP = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> baby , pos = table . pop ( ) <NEWLINE> <NL> DP [ i ] [ 0 ] = DP [ i - 1 ] [ 0 ] + baby * abs ( pos - i + 1 ) <NEWLINE> DP [ 0 ] [ i ] = DP [ 0 ] [ i - 1 ] + baby * abs ( pos - ( N - i ) ) <NEWLINE> for x in range ( 1 , i ) : <NEWLINE> <INDENT> y = i - x <NEWLINE> <NL> <COMMENT> <NL> DP [ x ] [ y ] = max ( DP [ x - 1 ] [ y ] + baby * abs ( pos - x + 1 ) , DP [ x ] [ y - 1 ] + baby * abs ( pos - ( N - y ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , DP [ i ] [ N - i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> root = [ [ ] for i in range ( N ) ] <NEWLINE> ans = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> root [ a ] . append ( b ) <NEWLINE> root [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> visit = [ False ] * N <NEWLINE> def dfs ( n ) : <NEWLINE> <INDENT> visit [ n ] = True <NEWLINE> for go in root [ n ] : <NEWLINE> <INDENT> if visit [ go ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ go ] += ans [ n ] <NEWLINE> dfs ( go ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * ans ) <NEWLINE>
SA = input ( ) <NEWLINE> SB = input ( ) <NEWLINE> SC = input ( ) <NEWLINE> <NL> pointer = SA [ 0 ] <NEWLINE> SA = SA [ 1 : ] <NEWLINE> d = { <STRING> : SA , <STRING> : SB , <STRING> : SC } <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if d [ pointer ] == <STRING> : <NEWLINE> <INDENT> ans = pointer <NEWLINE> break <NEWLINE> <DEDENT> tmp = d [ pointer ] [ 0 ] <NEWLINE> d [ pointer ] = d [ pointer ] [ 1 : ] <NEWLINE> pointer = tmp <NEWLINE> <NL> <DEDENT> print ( ans . upper ( ) ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = collections . defaultdict ( int ) <NEWLINE> currSum = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> count [ a ] += 1 <NEWLINE> currSum += a <NEWLINE> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> currSum += ( count [ B ] * ( C - B ) ) <NEWLINE> count [ C ] += count [ B ] <NEWLINE> count [ B ] = 0 <NEWLINE> print ( currSum ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> cntB = 0 <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cntB += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += cntB <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from math import factorial <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = 10000000000 <NEWLINE> <NL> def binary_search_section ( list , min , max ) : <NEWLINE> <INDENT> low = 0 <NEWLINE> high = len ( list ) - 1 <NEWLINE> upper = len ( list ) <NEWLINE> lower = - 1 <NEWLINE> while low <= high : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> guess = list [ mid ] <NEWLINE> if guess >= min : <NEWLINE> <INDENT> high = mid - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid + 1 <NEWLINE> lower = mid <NEWLINE> <DEDENT> <DEDENT> low = 0 <NEWLINE> high = len ( list ) - 1 <NEWLINE> while low <= high : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> guess = list [ mid ] <NEWLINE> if guess > max : <NEWLINE> <INDENT> high = mid - 1 <NEWLINE> upper = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return [ lower , upper ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> n = int ( input ( ) ) <COMMENT> <NEWLINE> aList = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> bList = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> cList = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> aListSorted = sorted ( aList ) <NEWLINE> bListSorted = sorted ( bList ) <NEWLINE> cListSorted = sorted ( cList ) <NEWLINE> <NL> result = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for b in bListSorted : <NEWLINE> <INDENT> sec = binary_search_section ( aListSorted , aListSorted [ 0 ] , b - 1 ) <NEWLINE> sec2 = binary_search_section ( cListSorted , b + 1 , cListSorted [ - 1 ] ) <NEWLINE> result += ( sec [ 1 ] - sec [ 0 ] - 1 ) * ( sec2 [ 1 ] - sec2 [ 0 ] - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( <STRING> . format ( result ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> from numba import njit <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> readline = sys . stdin . buffer . readline <NEWLINE> <NL> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def f ( N , K , A ) : <NEWLINE> <INDENT> for i in range ( min ( K , 100 ) ) : <NEWLINE> <INDENT> C = np . zeros ( N + 1 , dtype = np . int64 ) <NEWLINE> <NL> for j , a in enumerate ( A ) : <NEWLINE> <INDENT> l = max ( 0 , j - a ) <NEWLINE> r = min ( j + a + 1 , N ) <NEWLINE> C [ l ] += 1 <NEWLINE> C [ r ] -= 1 <NEWLINE> <NL> <DEDENT> A = np . cumsum ( C ) <NEWLINE> <NL> <DEDENT> return A <NEWLINE> <NL> <NL> <DEDENT> def solver ( ) : <NEWLINE> <INDENT> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> A = f ( N , K , np . array ( A ) ) <NEWLINE> print ( * A [ : - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> solver ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A , reverse = True ) <NEWLINE> B = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> B *= i <NEWLINE> if B > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( B ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = [ ] <NEWLINE> R = [ ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> L . append ( i + A [ i ] ) <NEWLINE> R . append ( i - A [ i ] ) <NEWLINE> <NL> <DEDENT> r = collections . Counter ( R ) <NEWLINE> <NL> for l in L : <NEWLINE> <INDENT> ans += r [ l ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for X in range ( K + 1 ) : <NEWLINE> <INDENT> for Y in range ( K + 1 ) : <NEWLINE> <INDENT> Z = S - X - Y <NEWLINE> if 0 <= Z <= K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
queue = [ ] <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> name , time = input ( ) . split ( ) <NEWLINE> queue . append ( [ name , int ( time ) ] ) <NEWLINE> <NL> <DEDENT> t = 0 <NEWLINE> while len ( queue ) > 0 : <NEWLINE> <INDENT> entry = queue . pop ( 0 ) <NEWLINE> t += min ( entry [ 1 ] , q ) <NEWLINE> entry [ 1 ] -= q <NEWLINE> if entry [ 1 ] > 0 : <NEWLINE> <INDENT> queue . append ( entry ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( entry [ 0 ] , t ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> from bisect import bisect_left <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> from collections import defaultdict <NEWLINE> <NL> <NL> class Graph ( object ) : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . N = N <NEWLINE> self . E = defaultdict ( list ) <NEWLINE> <NL> <DEDENT> def add_edge ( self , f , t , w = 1 ) : <NEWLINE> <INDENT> self . E [ f ] . append ( ( t , w ) ) <NEWLINE> self . E [ t ] . append ( ( f , w ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solve ( N : int , a : <STRING> , u : <STRING> , v : <STRING> ) : <NEWLINE> <NL> <INDENT> g = Graph ( N ) <NEWLINE> for x , y in zip ( u , v ) : <NEWLINE> <INDENT> g . add_edge ( x - 1 , y - 1 ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * N <NEWLINE> <NL> dp = [ INF ] * N <NEWLINE> event = [ ] <NEWLINE> var = { <STRING> : 0 } <NEWLINE> <NL> def dfs ( curr , par ) : <NEWLINE> <INDENT> i = bisect_left ( dp , a [ curr ] ) <NEWLINE> if dp [ i ] > a [ curr ] : <NEWLINE> <INDENT> if dp [ i ] == INF : <NEWLINE> <INDENT> var [ <STRING> ] = i <NEWLINE> <DEDENT> event . append ( ( curr , i , dp [ i ] ) ) <NEWLINE> dp [ i ] = a [ curr ] <NEWLINE> <NL> <DEDENT> ans [ curr ] = var [ <STRING> ] + 1 <NEWLINE> <NL> for child , w in g . E [ curr ] : <NEWLINE> <INDENT> if child == par : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( child , curr ) <NEWLINE> <NL> <DEDENT> c , i , v = event [ - 1 ] <NEWLINE> if c == curr : <NEWLINE> <INDENT> dp [ i ] = v <NEWLINE> if v == INF : <NEWLINE> <INDENT> var [ <STRING> ] = i - 1 <NEWLINE> <DEDENT> event . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> return <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> a = [ int ( next ( tokens ) ) for _ in range ( N ) ] <COMMENT> <NEWLINE> u = [ int ( ) ] * ( N - 1 ) <COMMENT> <NEWLINE> v = [ int ( ) ] * ( N - 1 ) <COMMENT> <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u [ i ] = int ( next ( tokens ) ) <NEWLINE> v [ i ] = int ( next ( tokens ) ) <NEWLINE> <DEDENT> solve ( N , a , u , v ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> lst = [ ] <NEWLINE> if ( n == 1 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if ( h [ i ] >= h [ i + 1 ] ) : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst . append ( count ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> <DEDENT> if ( count != 0 ) : <NEWLINE> <INDENT> lst . append ( count ) <NEWLINE> <NL> <DEDENT> lst . sort ( ) <NEWLINE> lst . reverse ( ) <NEWLINE> <NL> print ( lst [ 0 ] ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> def fact ( n , p ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a = ( a * i ) % p <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> def bfact ( n , x , p ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> for i in range ( n - x + 1 , n + 1 ) : <NEWLINE> <INDENT> a = ( a * i ) % p <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> p = 10 ** 9 + 7 <NEWLINE> na = bfact ( n , a , p ) % p <NEWLINE> nb = bfact ( n , b , p ) % p <NEWLINE> aa = fact ( a , p ) % p <NEWLINE> bb = fact ( b , p ) % p <NEWLINE> aaa = pow ( aa , - 1 , p ) <NEWLINE> bbb = pow ( bb , - 1 , p ) <NEWLINE> ans = pow ( 2 , n , p ) - 1 <NEWLINE> ans -= ( na * aaa + nb * bbb ) <NEWLINE> print ( ans % p ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] / a [ i - k ] > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> import math <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> x = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( x , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = [ q for q in range ( - 1 , 102 ) if q not in P ] <NEWLINE> ans = min ( Q , key = lambda q : ( abs ( q - X ) , q ) ) <NEWLINE> print ( ans ) <NEWLINE>
def merge ( A , l , m , r ) : <NEWLINE> <INDENT> L = A [ l : m ] + [ 10 ** 9 + 1 ] <NEWLINE> R = A [ m : r ] + [ 10 ** 9 + 1 ] <NEWLINE> i , j = 0 , 0 <NEWLINE> for k in range ( l , r ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> global cnt <NEWLINE> cnt += r - l <NEWLINE> <NL> <DEDENT> def mergeSort ( A , l , r ) : <NEWLINE> <INDENT> if r - l > 1 : <NEWLINE> <INDENT> m = ( l + r ) // 2 <NEWLINE> mergeSort ( A , l , m ) <NEWLINE> mergeSort ( A , m , r ) <NEWLINE> merge ( A , l , m , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> mergeSort ( A , 0 , n ) <NEWLINE> print ( <STRING> . join ( list ( map ( str , A ) ) ) ) <NEWLINE> print ( cnt ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> n = 1 <NEWLINE> L = [ ] <NEWLINE> if a * b < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a + b > 0 or ( a - b ) % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> iim = lambda : map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( iim ( ) ) <NEWLINE> ans = 0 <NEWLINE> dp = [ 0 ] * N <NEWLINE> for i , ai in enumerate ( A ) : <NEWLINE> <INDENT> x = i + ai <NEWLINE> if x < N : <NEWLINE> <INDENT> dp [ x ] += 1 <NEWLINE> <DEDENT> x = i - ai <NEWLINE> if x >= 0 : <NEWLINE> <INDENT> ans += dp [ x ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
import math <NEWLINE> a , b = [ float ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 1000000000 <NEWLINE> flag = False <NEWLINE> <NL> for i in range ( 1 , 10000 ) : <NEWLINE> <INDENT> ans8 = int ( math . floor ( i * 0.08 ) ) <NEWLINE> ans10 = int ( math . floor ( i * 0.1 ) ) <NEWLINE> <COMMENT> <NL> if ans8 == a and ans10 == b : <NEWLINE> <INDENT> ans = min ( ans , i ) <NEWLINE> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> if flag is True : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> line = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if line [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= line [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> A = [ int ( i ) % mod for i in input ( ) . split ( ) ] <NEWLINE> <NL> S = [ 0 ] * N <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> S [ i ] = sum ( A ) - A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ i ] = ( S [ i - 1 ] - A [ i ] ) <NEWLINE> <DEDENT> ans += ( A [ i ] * S [ i ] ) % mod <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
import math <NEWLINE> <NL> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for x in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( tmp , x ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> <NL> def popcount ( n ) : <NEWLINE> <INDENT> return bin ( n ) . count ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> c = popcount ( n ) <NEWLINE> return 1 + solve ( n % c ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> c = X . count ( <STRING> ) <NEWLINE> if c == 0 : <NEWLINE> <INDENT> for _ in range ( N ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> a , b = 0 , 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if c == 1 and X [ - 1 - i ] == <STRING> : <NEWLINE> <INDENT> b = ( b + pow ( 2 , i , c + 1 ) ) % ( c + 1 ) <NEWLINE> <DEDENT> elif X [ - 1 - i ] == <STRING> : <NEWLINE> <INDENT> a = ( a + pow ( 2 , i , c - 1 ) ) % ( c - 1 ) <NEWLINE> b = ( b + pow ( 2 , i , c + 1 ) ) % ( c + 1 ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if c == 1 and X [ i ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> m = c - 1 <NEWLINE> w = ( a - pow ( 2 , N - 1 - i , m ) ) % m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = c + 1 <NEWLINE> w = ( b + pow ( 2 , N - 1 - i , m ) ) % m <NEWLINE> <DEDENT> ans = solve ( w ) + 1 <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> answer = 0 <NEWLINE> x = 0 <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> x += A [ i ] <NEWLINE> answer += ( x * A [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> print ( answer % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> mod = int ( 1e18 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > mod : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> cmb = { } <NEWLINE> cnt = 0 <NEWLINE> flag = 1 <NEWLINE> ma = [ 0 ] * N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cmb . setdefault ( i , [ ] ) <NEWLINE> cmb . setdefault ( a - 1 , [ ] ) . append ( b - 1 ) <NEWLINE> cmb . setdefault ( b - 1 , [ ] ) . append ( a - 1 ) <NEWLINE> <NL> ma [ a - 1 ] = max ( ma [ a - 1 ] , H [ b - 1 ] ) <NEWLINE> ma [ b - 1 ] = max ( ma [ b - 1 ] , H [ a - 1 ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for j in range ( N ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> if H [ j ] > ma [ j ] : <NEWLINE> <COMMENT> <NL> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> div_point = int ( ( N / 2 ) ) <NEWLINE> <COMMENT> <NL> if div_point % 2 == 0 : <NEWLINE> <INDENT> div_point -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> re_point = div_point + int ( ( N - div_point ) / 2 ) <NEWLINE> <NL> <COMMENT> <NL> i = 0 <COMMENT> <NEWLINE> while 1 < div_point - i * 2 and i < re_point and i < M : <COMMENT> <NEWLINE> <INDENT> ent1 = i + 1 <COMMENT> <NEWLINE> ent2 = div_point - i <COMMENT> <NEWLINE> print ( str ( ent1 ) + <STRING> + str ( ent2 ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> for j in range ( M - i ) : <COMMENT> <NEWLINE> <INDENT> ent1 = re_point - j <COMMENT> <NEWLINE> ent2 = re_point + j + 1 <COMMENT> <NEWLINE> print ( str ( ent1 ) + <STRING> + str ( ent2 ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = <STRING> . join ( [ <STRING> . join ( input ( ) . split ( ) ) for i in range ( n // 19 + ( n % 19 != 0 ) ) ] ) <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if d . find ( str ( i ) ) == - 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> ans = r * g * b <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if 2 * j - i < n : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ i ] != s [ 2 * j - i ] and s [ j ] != s [ 2 * j - i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for j in range ( N - i + 1 ) : <NEWLINE> <INDENT> k = N - i - j <NEWLINE> t = ( i , j , k ) <NEWLINE> if Y == i * 10000 + j * 5000 + k * 1000 : <NEWLINE> <INDENT> print ( * t ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , n ) : <NEWLINE> <INDENT> if A [ j ] < A [ minj ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> if minj != i : <NEWLINE> <INDENT> t = A [ i ] <NEWLINE> A [ i ] = A [ minj ] <NEWLINE> A [ minj ] = t <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> print ( c ) <NEWLINE>
<COMMENT> <NL> A = [ ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> LENGTH = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> N = 0 <NEWLINE> M = LENGTH - 1 <NEWLINE> CHANGE = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> while N <= LENGTH - 1 : <NEWLINE> <INDENT> M = LENGTH - 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> while M >= N + 1 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if int ( A [ M ] ) < int ( A [ M - 1 ] ) : <NEWLINE> <INDENT> tmp = A [ M - 1 ] <NEWLINE> A [ M - 1 ] = A [ M ] <NEWLINE> A [ M ] = tmp <NEWLINE> CHANGE += 1 <NEWLINE> <DEDENT> M -= 1 <NEWLINE> <DEDENT> N += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> print ( CHANGE ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> pushed = [ ] <NEWLINE> button = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> button [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> push_button = 1 <NEWLINE> for _ in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if push_button == 2 : <NEWLINE> <INDENT> print ( len ( pushed ) ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pushed . append ( push_button ) <NEWLINE> push_button = button [ push_button ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = pow ( 10 , 9 ) + 7 <NEWLINE> ans = 0 <NEWLINE> s = sum ( a ) % mod <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s -= a [ i ] % mod <NEWLINE> ans += ( a [ i ] * s ) % mod <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> N = int ( input ( ) ) <COMMENT> <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> Q = int ( input ( ) ) <COMMENT> <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> S = 0 <NEWLINE> num = [ 0 for i in range ( 100001 ) ] <NEWLINE> for i in A : <NEWLINE> <INDENT> S += i <COMMENT> <NEWLINE> num [ i ] += 1 <NEWLINE> <NL> <DEDENT> for B , C in BC : <NEWLINE> <INDENT> S = S + ( C - B ) * num [ B ] <NEWLINE> num [ C ] += num [ B ] <NEWLINE> num [ B ] = 0 <NEWLINE> print ( S ) <NEWLINE> <NL> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) + [ 10 ** 7 ] <NEWLINE> a . sort ( ) <NEWLINE> e = np . zeros ( 10 ** 6 + 1 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if e [ a [ i ] ] == 0 : <NEWLINE> <INDENT> e [ : : a [ i ] ] = 1 <NEWLINE> if a [ i ] != a [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> ln = len ( n ) + 1 <NEWLINE> <NL> dp = [ [ [ 0 ] * ( ln ) for _ in range ( 2 ) ] for i in range ( ln ) ] <NEWLINE> dp [ 0 ] [ 0 ] [ 0 ] = 1 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> for smaller in range ( 2 ) : <NEWLINE> <INDENT> x = int ( n [ i ] ) <NEWLINE> t = 9 if smaller else x <NEWLINE> for j in range ( t + 1 ) : <NEWLINE> <INDENT> for knum in range ( ln - 1 ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> dp [ i + 1 ] [ int ( smaller or j < x ) ] [ knum ] += dp [ i ] [ smaller ] [ knum ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] [ int ( smaller or j < x ) ] [ knum + 1 ] += dp [ i ] [ smaller ] [ knum ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> print ( dp [ - 1 ] [ 0 ] [ k ] + dp [ - 1 ] [ 1 ] [ k ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> ans = [ 0 ] * ( len ( S ) + 1 ) <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> ans [ i + 1 ] = max ( ans [ i + 1 ] , ans [ i ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> i = len ( S ) - 1 - i <NEWLINE> if S [ i ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] = max ( ans [ i ] , ans [ i + 1 ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> ans = [ 0 ] * ( n ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d [ a ] . append ( b ) <NEWLINE> d [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> q = deque ( [ 1 ] ) <NEWLINE> while not len ( q ) == 0 : <NEWLINE> <INDENT> x = q . popleft ( ) <NEWLINE> for i in d [ x ] : <NEWLINE> <INDENT> if ans [ i - 1 ] == 0 : <NEWLINE> <INDENT> ans [ i - 1 ] = x <NEWLINE> q . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if 0 in ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> s = <STRING> . join ( map ( str , ans [ 1 : ] ) ) <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
def prime_decomposition ( n ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> table = [ ] <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> n /= i <NEWLINE> table . append ( i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if n > 1 : <NEWLINE> <INDENT> table . append ( n ) <NEWLINE> <DEDENT> return table <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> return <NEWLINE> <DEDENT> t = prime_decomposition ( N ) <NEWLINE> if len ( t ) == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <DEDENT> dic = { } <NEWLINE> for a in t : <NEWLINE> <INDENT> if not a in dic . keys ( ) : <NEWLINE> <INDENT> dic [ a ] = 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ a ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in dic . keys ( ) : <NEWLINE> <INDENT> num = dic [ i ] <NEWLINE> tmp = 1 <NEWLINE> c = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if num >= c : <NEWLINE> <INDENT> num -= c <NEWLINE> c += 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import numpy as np <NEWLINE> from numpy . fft import rfft , irfft <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def ii ( ) : return int ( input ( ) ) <NEWLINE> def isp ( ) : return input ( ) . split ( ) <NEWLINE> def deb ( text ) : print ( <STRING> . format ( text ) ) <NEWLINE> <NL> INF = 10 ** 20 <NEWLINE> class Polynomial : <NEWLINE> <INDENT> def __init__ ( self , coefficient = None , dim = 0 , const = 1 ) : <NEWLINE> <INDENT> if coefficient == None : <NEWLINE> <INDENT> self . coefficient = np . zeros ( dim + 1 , np . int64 ) <NEWLINE> self . coefficient [ dim ] = const <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . coefficient = coefficient <NEWLINE> <NL> <DEDENT> <DEDENT> def __add__ ( self , other ) : <COMMENT> <NEWLINE> <INDENT> f , g = self . coefficient , other . coefficient <NEWLINE> if len ( f ) > len ( g ) : f , g = g , f <NEWLINE> <NL> h = Polynomial ( dim = len ( g ) - 1 , const = 0 ) <NEWLINE> h . coefficient [ len ( f ) : ] += g [ len ( f ) : ] <NEWLINE> h . coefficient [ : len ( f ) ] += f + g [ : len ( f ) ] <NEWLINE> return h <NEWLINE> <NL> <DEDENT> def __iadd__ ( self , other ) : <COMMENT> <NEWLINE> <INDENT> h = self . __add__ ( other ) <NEWLINE> self . coefficient = h . coefficient <NEWLINE> return self <NEWLINE> <NL> <DEDENT> def __mul__ ( self , other ) : <COMMENT> <NEWLINE> <INDENT> f = self . coefficient <NEWLINE> g = other . coefficient <NEWLINE> h = Polynomial ( ) <NEWLINE> h . coefficient = self . fft ( f , g ) [ : len ( f ) + len ( g ) - 1 ] <NEWLINE> return h <NEWLINE> <NL> <DEDENT> def __len__ ( self ) : <NEWLINE> <INDENT> return len ( self . coefficient ) <NEWLINE> <NL> <DEDENT> def __getitem__ ( self , key ) : <NEWLINE> <INDENT> return self . coefficient [ key ] <NEWLINE> <NL> <DEDENT> def get_coefficient ( self , x ) : <NEWLINE> <INDENT> return self . coefficient [ x ] <NEWLINE> <NL> <NL> <DEDENT> def fft ( self , A , B , fft_len = 1 << 18 ) : <NEWLINE> <INDENT> x = irfft ( rfft ( A , fft_len ) * rfft ( B , fft_len ) ) <NEWLINE> return np . rint ( x ) . astype ( np . int64 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = mi ( ) <NEWLINE> A = list ( mi ( ) ) <NEWLINE> <NL> coefficient = [ 0 ] * ( 2 * 10 ** 5 + 10 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> coefficient [ a ] += 1 <NEWLINE> <NL> <DEDENT> f = Polynomial ( coefficient = coefficient ) <NEWLINE> <NL> g = f * f <NEWLINE> ans = 0 <NEWLINE> handshake = M <NEWLINE> for x in range ( len ( g ) - 1 , 1 , - 1 ) : <NEWLINE> <INDENT> count = g [ x ] <NEWLINE> if count <= 0 : continue <NEWLINE> <NL> if count > handshake : <NEWLINE> <INDENT> ans += handshake * x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += count * x <NEWLINE> <NL> <DEDENT> handshake = max ( handshake - count , 0 ) <NEWLINE> if handshake == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * a - k + b ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> al = sorted ( a ) <NEWLINE> bl = sorted ( b ) <NEWLINE> cl = sorted ( c ) <NEWLINE> <NL> abl = [ 0 ] * n <NEWLINE> bcl = [ 0 ] * n <NEWLINE> i = n - 1 <NEWLINE> for j in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if i == - 1 : <NEWLINE> <INDENT> abl [ j ] = 0 <NEWLINE> continue <NEWLINE> <DEDENT> while al [ i ] >= bl [ j ] : <NEWLINE> <INDENT> i -= 1 <NEWLINE> if i == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if i == - 1 : <NEWLINE> <INDENT> abl [ j ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> abl [ j ] = i + 1 <NEWLINE> <DEDENT> <DEDENT> j = 0 <NEWLINE> bcl = [ 0 ] * n <NEWLINE> k = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if k == n : <NEWLINE> <INDENT> bcl [ j ] = 0 <NEWLINE> continue <NEWLINE> <DEDENT> while cl [ k ] <= bl [ j ] : <NEWLINE> <INDENT> k += 1 <NEWLINE> if k == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if k == n : <NEWLINE> <INDENT> bcl [ j ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bcl [ j ] = ( n - k ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for s in range ( n ) : <NEWLINE> <INDENT> ans += abl [ s ] * bcl [ s ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ input ( ) for _ in range ( n ) ] <NEWLINE> a = set ( l ) <NEWLINE> print ( len ( a ) ) <NEWLINE>
import math <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> score = 0 <NEWLINE> times = [ ] <NEWLINE> for i in range ( 1 , min ( n + 1 , k ) ) : <NEWLINE> <INDENT> times . append ( math . ceil ( math . log2 ( ( k / i ) ) ) ) <NEWLINE> <NL> <DEDENT> if len ( times ) : <NEWLINE> <INDENT> bottom_max = times [ 0 ] <NEWLINE> for t in times : <NEWLINE> <INDENT> score += 2 ** ( bottom_max - t ) <NEWLINE> <DEDENT> score /= 2 ** ( bottom_max ) * n <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> big = [ i for i in range ( k , max ( k , n + 1 ) ) ] <NEWLINE> score += len ( big ) / n <NEWLINE> print ( <STRING> . format ( score ) ) <NEWLINE>
n = <STRING> <NEWLINE> s = input ( ) <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> if n [ 0 ] == i : <COMMENT> <NEWLINE> <INDENT> n = n [ 1 : ] <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> n = n [ : : - 1 ] <NEWLINE> <NL> for i in s [ : : - 1 ] : <NEWLINE> <INDENT> if n == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif n [ 0 ] == i : <NEWLINE> <INDENT> n = n [ 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def numba_compile ( numba_config ) : <NEWLINE> <INDENT> import os , sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba import njit <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature ) ( func ) <NEWLINE> cc . export ( func . __name__ , signature ) ( func ) <NEWLINE> <DEDENT> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif os . name == <STRING> : <NEWLINE> <INDENT> exec ( <STRING> ) <NEWLINE> for func , _ in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = vars ( ) [ func . __name__ ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature , cache = True ) ( func ) <NEWLINE> <DEDENT> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> from bisect import bisect_left <NEWLINE> from operator import itemgetter <NEWLINE> <NL> <NL> import numpy as np <NEWLINE> <NL> def segment_tree_op ( a , b ) : <NEWLINE> <INDENT> return a if a [ 0 ] > b [ 0 ] else b <NEWLINE> <NL> <DEDENT> def segment_tree_get ( seg , l , r ) : <NEWLINE> <INDENT> elem_size , tree , result , _ = seg <NEWLINE> l += elem_size <NEWLINE> r += elem_size <NEWLINE> while l < r : <NEWLINE> <INDENT> if l & 1 : <NEWLINE> <INDENT> result = segment_tree_op ( tree [ l ] , result ) <NEWLINE> l += 1 <NEWLINE> <DEDENT> if r & 1 : <NEWLINE> <INDENT> r -= 1 <NEWLINE> result = segment_tree_op ( tree [ r ] , result ) <NEWLINE> <DEDENT> l , r = l >> 1 , r >> 1 <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> def segment_tree_set ( seg , i , value ) : <NEWLINE> <INDENT> elem_size , tree , _ , _ = seg <NEWLINE> k = elem_size + i <NEWLINE> tree [ k ] = value <NEWLINE> while k > 1 : <NEWLINE> <INDENT> k >>= 1 <NEWLINE> tree [ k ] = segment_tree_op ( tree [ k << 1 ] , tree [ k << 1 | 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def segment_tree_get_one ( seg , i ) : <NEWLINE> <INDENT> elem_size , tree , _ , _ = seg <NEWLINE> return tree [ i + elem_size ] <NEWLINE> <NL> <DEDENT> def segment_tree_construct ( arr ) : <NEWLINE> <INDENT> identity = np . array ( [ 0 ] , dtype = np . int64 ) <NEWLINE> real_size = len ( arr ) <NEWLINE> elem_size = 1 << int ( np . log2 ( real_size - 1 ) ) + 1 <NEWLINE> tree = np . empty ( ( elem_size * 2 , len ( identity ) ) , dtype = np . int64 ) <NEWLINE> tree [ elem_size : elem_size + real_size ] = arr <NEWLINE> tree [ elem_size + real_size : ] = identity <NEWLINE> for i in range ( elem_size - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> tree [ i ] = segment_tree_op ( tree [ i << 1 ] , tree [ i << 1 | 1 ] ) <NEWLINE> <DEDENT> return elem_size , tree , identity , real_size <NEWLINE> <NL> <DEDENT> class SegmentTree : <NEWLINE> <INDENT> element_type = <STRING> <NEWLINE> a_type = <STRING> <NEWLINE> numba_config = [ <NEWLINE> <INDENT> [ segment_tree_op , <STRING> ] , <NEWLINE> [ segment_tree_construct , <STRING> ] , <NEWLINE> [ segment_tree_get , <STRING> ] , <NEWLINE> [ segment_tree_set , <STRING> ] , <NEWLINE> [ segment_tree_get_one , <STRING> ] , <NEWLINE> <DEDENT> ] <NEWLINE> def __init__ ( self , arr ) : <NEWLINE> <INDENT> self . a = segment_tree_construct ( arr ) <NEWLINE> <NL> <DEDENT> def get ( self , l , r ) : <NEWLINE> <INDENT> return segment_tree_get ( self . a , l , r ) <NEWLINE> <NL> <DEDENT> def set ( self , i , value ) : <NEWLINE> <INDENT> return segment_tree_set ( self . a , i , value ) <NEWLINE> <NL> <DEDENT> def get_one ( self , i ) : <NEWLINE> <INDENT> return segment_tree_get_one ( self . a , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> numba_compile ( SegmentTree . numba_config ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> mod = 998244353 <NEWLINE> N = int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> m = map ( int , sys . stdin . buffer . read ( ) . split ( ) ) <NEWLINE> XD = list ( zip ( m , m ) ) <NEWLINE> XD . sort ( key = itemgetter ( 0 ) ) <NEWLINE> X , D = zip ( * XD ) <NEWLINE> seg = SegmentTree ( np . arange ( N , dtype = np . int64 ) . reshape ( N , 1 ) ) <NEWLINE> for i , ( x , d ) in zip ( range ( N - 1 , - 1 , - 1 ) , XD [ : : - 1 ] ) : <NEWLINE> <INDENT> r = bisect_left ( X , x + d , lo = i ) <NEWLINE> seg . set ( i , seg . get ( i , r ) ) <NEWLINE> <DEDENT> D2 = seg . a [ 1 ] [ seg . a [ 0 ] : seg . a [ 0 ] + seg . a [ 3 ] ] . ravel ( ) <NEWLINE> Q = [ 0 ] * N <NEWLINE> ans = 1 <NEWLINE> cnt = 1 <NEWLINE> for i , d in enumerate ( D2 ) : <NEWLINE> <INDENT> ans += cnt <NEWLINE> Q [ d ] += cnt <NEWLINE> cnt = ( cnt + Q [ i ] ) % mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if 10 ** 18 < ans : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> def pf ( N ) : <NEWLINE> <INDENT> ans = deque ( [ ] ) <NEWLINE> p = 2 <NEWLINE> while N > 1 : <NEWLINE> <INDENT> if N % p == 0 : <NEWLINE> <INDENT> k = 0 <NEWLINE> while N % p == 0 : <NEWLINE> <INDENT> N //= p <NEWLINE> k += 1 <NEWLINE> <DEDENT> ans . append ( k ) <NEWLINE> <DEDENT> p += 1 + ( p > 2 ) <NEWLINE> if p ** 2 > N : <NEWLINE> <INDENT> p = N <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def func ( a ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> while True : <NEWLINE> <INDENT> a -= tmp + 1 <NEWLINE> if a < 0 : <NEWLINE> <INDENT> return tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> l = pf ( N ) <NEWLINE> while len ( l ) > 0 : <NEWLINE> <INDENT> ans += func ( l . popleft ( ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> B = list ( set ( A ) ) <NEWLINE> <NL> total = 1 <NEWLINE> flag = 9 <NEWLINE> for i in range ( len ( B ) ) : <NEWLINE> <INDENT> total *= B [ i ] ** A . count ( B [ i ] ) <NEWLINE> if total > 10 ** 18 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> elif min ( A ) == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif flag == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( total ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> i_Ai = { } <NEWLINE> cnt = 0 <NEWLINE> <NL> for i , h in enumerate ( A ) : <NEWLINE> <INDENT> imh = i - h <NEWLINE> if imh in i_Ai : <NEWLINE> <INDENT> cnt += i_Ai [ imh ] <NEWLINE> <DEDENT> iph = i + h <NEWLINE> if iph in i_Ai : <NEWLINE> <INDENT> i_Ai [ iph ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i_Ai [ iph ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def calc ( ) : <NEWLINE> <INDENT> N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> print ( calc ( ) ) <NEWLINE>
def readinput ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> return n , l <NEWLINE> <NL> <DEDENT> def main ( n , a ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> hist = [ 0 ] * 61 <NEWLINE> bs = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> s = bin ( a [ i ] ) [ 2 : ] <NEWLINE> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> hist [ len ( s ) - j - 1 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> sum = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> b = 1 <NEWLINE> for j in range ( 61 ) : <NEWLINE> <INDENT> sum = ( sum + ( hist [ j ] * ( n - hist [ j ] ) * b ) % MOD ) % MOD <NEWLINE> b *= 2 <NEWLINE> <NL> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , l = readinput ( ) <NEWLINE> ans = main ( n , l ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = { } <NEWLINE> for i in range ( len ( h ) ) : <NEWLINE> <INDENT> dic [ i ] = 0 <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] > h [ b - 1 ] : <NEWLINE> <INDENT> dic [ b - 1 ] = 1 <NEWLINE> <DEDENT> elif h [ a - 1 ] < h [ b - 1 ] : <NEWLINE> <INDENT> dic [ a - 1 ] = 1 <NEWLINE> <DEDENT> elif h [ a - 1 ] == h [ b - 1 ] : <NEWLINE> <INDENT> dic [ b - 1 ] = 1 <NEWLINE> dic [ a - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( h ) ) : <NEWLINE> <INDENT> if dic [ i ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from copy import deepcopy <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ch , num = input ( ) . split ( ) <NEWLINE> A . append ( [ ch , int ( num ) ] ) <NEWLINE> <NL> <DEDENT> B = deepcopy ( A ) <NEWLINE> <NL> <NL> <NL> def Merge ( A , left , mid , right ) : <NEWLINE> <INDENT> L = A [ left : mid ] <NEWLINE> R = A [ mid : right ] <NEWLINE> L . append ( [ <STRING> , 2000000000 ] ) <NEWLINE> R . append ( [ <STRING> , 2000000000 ] ) <NEWLINE> i , j = 0 , 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] [ 1 ] <= R [ j ] [ 1 ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def MergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> MergeSort ( A , left , mid ) <NEWLINE> MergeSort ( A , mid , right ) <NEWLINE> Merge ( A , left , mid , right ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def partition ( A , p , r ) : <NEWLINE> <INDENT> x = A [ r - 1 ] [ 1 ] <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if A [ j ] [ 1 ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> <DEDENT> <DEDENT> return i <NEWLINE> <NL> <NL> <DEDENT> def quickSort ( A , p , r ) : <NEWLINE> <INDENT> if p < r : <NEWLINE> <INDENT> q = partition ( A , p , r ) <NEWLINE> quickSort ( A , p , q ) <NEWLINE> quickSort ( A , q + 1 , r ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> quickSort ( A , 0 , n ) <NEWLINE> MergeSort ( B , 0 , n ) <NEWLINE> <NL> if A == B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> a = <STRING> . join ( [ a [ 0 ] , str ( a [ 1 ] ) ] ) <NEWLINE> print ( a ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> coin = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> T = [ 0 ] + [ float ( <STRING> ) ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> for j in range ( coin [ i ] , n + 1 ) : <NEWLINE> <INDENT> T [ j ] = min ( T [ j ] , T [ j - coin [ i ] ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( T [ - 1 ] ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> if 400 <= X < 600 : <NEWLINE> <INDENT> result = 8 <NEWLINE> <DEDENT> elif X < 800 : <NEWLINE> <INDENT> result = 7 <NEWLINE> <DEDENT> elif X < 1000 : <NEWLINE> <INDENT> result = 6 <NEWLINE> <DEDENT> elif X < 1200 : <NEWLINE> <INDENT> result = 5 <NEWLINE> <DEDENT> elif X < 1400 : <NEWLINE> <INDENT> result = 4 <NEWLINE> <DEDENT> elif X < 1600 : <NEWLINE> <INDENT> result = 3 <NEWLINE> <DEDENT> elif X < 1800 : <NEWLINE> <INDENT> result = 2 <NEWLINE> <DEDENT> elif X < 2000 : <NEWLINE> <INDENT> result = 1 <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> print ( s // 3600 , ( s // 60 ) % 60 , s % 60 , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def ans ( ) : <NEWLINE> <INDENT> if 0 in A : <NEWLINE> <INDENT> return print ( 0 ) <NEWLINE> <DEDENT> product = 1 <NEWLINE> for num in A : <NEWLINE> <INDENT> product = product * num <NEWLINE> if product > 10 ** 18 : <NEWLINE> <INDENT> return print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( product ) <NEWLINE> <NL> <NL> <DEDENT> ans ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> from math import gcd <NEWLINE> <NL> y = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> y += gcd ( x , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( y ) <NEWLINE>
x , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n != 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> d = 0 <NEWLINE> t = 0 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> if n != 0 : <NEWLINE> <INDENT> while t == 0 : <NEWLINE> <INDENT> if ( x - d ) not in p : <NEWLINE> <INDENT> print ( x - d ) <NEWLINE> t = 1 <NEWLINE> <DEDENT> elif ( x + d ) not in p : <NEWLINE> <INDENT> print ( x + d ) <NEWLINE> t = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> n = A [ - 1 ] <NEWLINE> mid = bisect . bisect ( A , n / 2 ) <NEWLINE> <NL> if abs ( n / 2 - A [ mid - 1 ] ) > abs ( n / 2 - A [ mid ] ) : <NEWLINE> <INDENT> print ( n , A [ mid ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n , A [ mid - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> zero_pop = X . count ( <STRING> ) + 1 <NEWLINE> one_pop = X . count ( <STRING> ) - 1 <NEWLINE> one_mod , zero_mod = 0 , 0 <NEWLINE> <NL> for b in X : <NEWLINE> <INDENT> if one_pop != 0 : <NEWLINE> <INDENT> one_mod = ( one_mod * 2 + int ( b ) ) % one_pop <NEWLINE> <DEDENT> zero_mod = ( zero_mod * 2 + int ( b ) ) % zero_pop <NEWLINE> <NL> <DEDENT> pop = { 0 : 0 } <NEWLINE> def popcount ( n ) : <NEWLINE> <INDENT> if n in pop : <NEWLINE> <INDENT> return pop [ n ] <NEWLINE> <DEDENT> pop [ n ] = popcount ( n // 2 ) + n % 2 <NEWLINE> return pop [ n ] <NEWLINE> <DEDENT> memo = { 0 : 0 } <NEWLINE> def f_count ( n ) : <NEWLINE> <INDENT> if n in memo : <NEWLINE> <INDENT> return memo [ n ] <NEWLINE> <DEDENT> memo [ n ] = f_count ( n % popcount ( n ) ) + 1 <NEWLINE> return memo [ n ] <NEWLINE> <DEDENT> one_p = { 0 : 1 } <NEWLINE> def one_pow ( n ) : <NEWLINE> <INDENT> if n in one_p : <NEWLINE> <INDENT> return one_p [ n ] <NEWLINE> <DEDENT> one_p [ n ] = one_pow ( n - 1 ) * 2 % one_pop <NEWLINE> return one_p [ n ] <NEWLINE> <DEDENT> zero_p = { 0 : 1 } <NEWLINE> def zero_pow ( n ) : <NEWLINE> <INDENT> if n in zero_p : <NEWLINE> <INDENT> return zero_p [ n ] <NEWLINE> <DEDENT> zero_p [ n ] = zero_pow ( n - 1 ) * 2 % zero_pop <NEWLINE> return zero_p [ n ] <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> and one_pop == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> x = one_mod <NEWLINE> x -= one_pow ( N - 1 - i ) <NEWLINE> x %= one_pop <NEWLINE> <DEDENT> elif X [ i ] == <STRING> : <NEWLINE> <INDENT> x = zero_mod <NEWLINE> x += zero_pow ( N - 1 - i ) <NEWLINE> x %= zero_pop <NEWLINE> <NL> <DEDENT> print ( f_count ( x ) + 1 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> time = 0 <NEWLINE> i = 0 <NEWLINE> while ( time + A [ i ] <= K ) : <NEWLINE> <INDENT> time += A [ i ] <NEWLINE> i += 1 <NEWLINE> if i == N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> i2 = i - 1 <COMMENT> <NEWLINE> h = 0 <NEWLINE> while ( time + B [ h ] <= K ) : <NEWLINE> <INDENT> time += B [ h ] <NEWLINE> h += 1 <NEWLINE> i += 1 <NEWLINE> if h == M : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> max = i <NEWLINE> <COMMENT> <NL> <NL> i3 = i <COMMENT> <NEWLINE> <COMMENT> <NL> if h == M : <NEWLINE> <INDENT> return max <NEWLINE> <NL> <DEDENT> for j in range ( i2 + 1 ) : <NEWLINE> <INDENT> if i2 < 0 : <NEWLINE> <INDENT> return max <NEWLINE> <DEDENT> time -= A [ i2 ] <NEWLINE> i3 -= 1 <NEWLINE> while ( time + B [ h ] <= K ) : <NEWLINE> <INDENT> time += B [ h ] <NEWLINE> h += 1 <NEWLINE> i3 += 1 <NEWLINE> if h == M : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if i3 > max : <NEWLINE> <INDENT> max = i3 <NEWLINE> <NL> <DEDENT> i2 -= 1 <NEWLINE> if h == M : <NEWLINE> <INDENT> return max <NEWLINE> <NL> <DEDENT> <DEDENT> return max <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
import sys <NEWLINE> from math import gcd <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = gcd ( a [ 0 ] , a [ 1 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> b = gcd ( b , a [ i ] ) <NEWLINE> <DEDENT> if b != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = set ( ) <NEWLINE> num = max ( a ) <NEWLINE> m = 1000000 <NEWLINE> vals = [ 0 ] * ( m + 1 ) <NEWLINE> <NL> for i in range ( 2 , m ) : <NEWLINE> <INDENT> if vals [ i ] != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> j = 1 <NEWLINE> while True : <NEWLINE> <INDENT> t = i * j <NEWLINE> if t > m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if vals [ t ] == 0 : <NEWLINE> <INDENT> vals [ t ] = i <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> d = dict ( ) <NEWLINE> for i in a : <NEWLINE> <INDENT> p = i <NEWLINE> while p != 1 : <NEWLINE> <INDENT> if p in d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> d [ p ] = 1 <NEWLINE> p = int ( p / vals [ p ] ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> area = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> area . append ( ( L , R ) ) <NEWLINE> <NL> <DEDENT> area . sort ( ) <NEWLINE> d = [ 0 ] * N <NEWLINE> a = [ 0 ] * N <NEWLINE> <NL> <NL> def func ( pos ) : <NEWLINE> <INDENT> for l , r in area : <NEWLINE> <INDENT> if pos + l - 1 < N : <NEWLINE> <INDENT> a [ pos + l - 1 ] += d [ pos ] <NEWLINE> <DEDENT> if pos + r < N : <NEWLINE> <INDENT> a [ pos + r ] -= d [ pos ] <NEWLINE> <DEDENT> <DEDENT> d [ pos + 1 ] = ( d [ pos ] + a [ pos ] ) % 998244353 <NEWLINE> <NL> <NL> <DEDENT> d [ 0 ] = 1 <NEWLINE> a [ 0 ] = - 1 <NEWLINE> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> func ( i ) <NEWLINE> <NL> <DEDENT> print ( d [ N - 1 ] % 998244353 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if a [ i ] < a [ i - 1 ] : <NEWLINE> <INDENT> cnt = cnt + ( a [ i - 1 ] - a [ i ] ) <NEWLINE> a [ i ] = a [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 4100000 ) <NEWLINE> <NL> import math <NEWLINE> <NL> import logging <NEWLINE> <NL> logging . basicConfig ( level = logging . DEBUG ) <NEWLINE> <NL> logger = logging . getLogger ( __name__ ) <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] [ 0 ] <COMMENT> <NEWLINE> <COMMENT> <NL> a_list = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> logger . debug ( <STRING> . format ( [ ] ) ) <NEWLINE> <NL> MAX = 10 ** 6 <NEWLINE> count_list = np . array ( [ 0 for _ in range ( MAX + 1 ) ] ) <NEWLINE> for a in a_list : <NEWLINE> <INDENT> count_list [ a ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , MAX + 1 ) : <NEWLINE> <INDENT> if count_list [ i ] : <NEWLINE> <INDENT> count_list [ i * 2 : : i ] = 0 <NEWLINE> if count_list [ i ] >= 2 : <NEWLINE> <INDENT> count_list [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count_list . sum ( ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__4 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num = [ 0 ] * n <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> num [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( * num ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = 10 ** 9 + 7 <NEWLINE> <NL> def prod ( X ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for x in X : <NEWLINE> <INDENT> ans = ans * x % M <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> if N == K : <NEWLINE> <INDENT> return prod ( A ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if all ( a < 0 for a in A ) and K % 2 == 1 : <NEWLINE> <INDENT> return prod ( sorted ( A ) [ - K : ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> posA = np . int64 ( sorted ( [ a for a in A if a >= 0 ] ) ) <NEWLINE> negA = np . int64 ( sorted ( [ a for a in A if a < 0 ] ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if K % 2 == 1 : <COMMENT> <NEWLINE> <INDENT> ans = ans * posA [ - 1 ] % M <NEWLINE> posA = posA [ : - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if len ( posA ) % 2 == 1 : <COMMENT> <NEWLINE> <INDENT> posA = posA [ 1 : ] <NEWLINE> <DEDENT> if len ( negA ) % 2 == 1 : <COMMENT> <NEWLINE> <INDENT> negA = negA [ : - 1 ] <NEWLINE> <DEDENT> pos_pairs = posA [ 0 : : 2 ] * posA [ 1 : : 2 ] <NEWLINE> neg_pairs = negA [ 0 : : 2 ] * negA [ 1 : : 2 ] <NEWLINE> pairs = np . concatenate ( [ pos_pairs , neg_pairs ] , axis = 0 ) . tolist ( ) <NEWLINE> pairs = sorted ( pairs , reverse = True ) [ : K // 2 ] <NEWLINE> ans = ans * prod ( pairs ) % M <NEWLINE> <NL> return ans <NEWLINE> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> R = [ [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] ] <NEWLINE> count = 9 <NEWLINE> temp = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if count >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = [ ] <NEWLINE> for r in R [ i ] : <NEWLINE> <INDENT> if r [ - 1 ] == <STRING> : <NEWLINE> <INDENT> temp . append ( str ( r ) + str ( int ( r [ - 1 ] ) - 1 ) ) <NEWLINE> temp . append ( str ( r ) + str ( int ( r [ - 1 ] ) ) ) <NEWLINE> <DEDENT> elif r [ - 1 ] == <STRING> : <NEWLINE> <INDENT> temp . append ( str ( r ) + str ( int ( r [ - 1 ] ) ) ) <NEWLINE> temp . append ( str ( r ) + str ( int ( r [ - 1 ] ) + 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp . append ( str ( r ) + str ( int ( r [ - 1 ] ) - 1 ) ) <NEWLINE> temp . append ( str ( r ) + str ( int ( r [ - 1 ] ) ) ) <NEWLINE> temp . append ( str ( r ) + str ( int ( r [ - 1 ] ) + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> R . append ( temp ) <NEWLINE> count += len ( temp ) <NEWLINE> <DEDENT> <DEDENT> N = N - ( count - len ( temp ) ) <NEWLINE> print ( R [ - 1 ] [ N - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N < B - 1 : <NEWLINE> <INDENT> print ( ( A * N ) // B - A * ( N // B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( ( A * ( B - 1 ) ) // B ) - A * ( ( B - 1 ) // B ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> DP = defaultdict ( lambda : - 10 ** 18 ) <NEWLINE> <NL> DP [ ( 0 , 0 ) ] = A [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( ( i + 1 ) // 2 - 1 , ( i + 2 ) // 2 ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> DP [ ( i , 0 ) ] = max ( DP [ ( i - 1 , 0 ) ] , A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> DP [ ( i , j ) ] = max ( DP [ ( i - 1 , j ) ] , DP [ ( i - 2 , j - 1 ) ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( DP [ ( N - 1 , N // 2 - 1 ) ] ) <NEWLINE>
from bisect import bisect_left , bisect <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> def is_ok ( arg ) : <NEWLINE> <INDENT> L = bisect ( A , arg ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( L , N ) : <NEWLINE> <INDENT> p , q = divmod ( A [ i ] , arg ) <NEWLINE> if q == 0 : <NEWLINE> <INDENT> cnt += p - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += p <NEWLINE> <DEDENT> <DEDENT> return cnt <= K <NEWLINE> <NL> <DEDENT> ng = 0 <NEWLINE> ok = max ( A ) + 1 <NEWLINE> <NL> def m_bisect ( ng , ok ) : <NEWLINE> <INDENT> while ( abs ( ok - ng ) > 1 ) : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if is_ok ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <DEDENT> print ( m_bisect ( ng , ok ) ) <NEWLINE>
from bisect import bisect_left <NEWLINE> N = int ( input ( ) ) <NEWLINE> L_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L_list . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> a , b = L_list [ i ] , L_list [ j ] <NEWLINE> r = bisect_left ( L_list , a + b ) <NEWLINE> ans += max ( 0 , r - j - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <COMMENT> <NL> ab . sort ( ) <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> k = k - ab [ i ] [ 1 ] <NEWLINE> if k <= 0 : <NEWLINE> <INDENT> print ( ab [ i ] [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
def inp ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def iinp ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def inps ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <DEDENT> def miinps ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def linps ( ) : <NEWLINE> <INDENT> return list ( input ( ) . split ( ) ) <NEWLINE> <DEDENT> def lmiinps ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def lmiinpsf ( n ) : <NEWLINE> <INDENT> return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> <DEDENT> s = iinp ( ) <NEWLINE> z = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> <NL> dp = [ 0 ] * 2001 <NEWLINE> <NL> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = 0 <NEWLINE> dp [ 2 ] = 0 <NEWLINE> dp [ 3 ] = 1 <NEWLINE> dp [ 4 ] = 1 <NEWLINE> dp [ 5 ] = 1 <NEWLINE> dp [ 6 ] = dp [ 3 ] + 1 <NEWLINE> <NL> for i in range ( 7 , s + 1 ) : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] <NEWLINE> <NL> <DEDENT> ans = dp [ s ] % z <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> time = 600 // d <NEWLINE> S = 0 <NEWLINE> for i in range ( time ) : <NEWLINE> <INDENT> x = i * d <NEWLINE> y = x ** 2 <NEWLINE> S += y * d <NEWLINE> <DEDENT> print ( S ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> temp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( temp , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> total = 0 <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> total += int ( N [ i ] ) <NEWLINE> <DEDENT> if total % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
from itertools import accumulate <NEWLINE> from bisect import bisect_right <NEWLINE> <NL> R = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> * _ , k = R ( ) <NEWLINE> a = accumulate ( R ( ) ) <NEWLINE> b = list ( accumulate ( R ( ) ) ) <NEWLINE> r = bisect_right ( b , k ) <NEWLINE> for i , x in enumerate ( a , 1 ) : <NEWLINE> <INDENT> if x > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> j = bisect_right ( b , k - x ) <NEWLINE> r = max ( r , i + j ) <NEWLINE> <DEDENT> print ( r ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> total = sum ( alist ) <NEWLINE> sumlist = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( alist ) - 1 ) : <NEWLINE> <INDENT> total -= alist [ i ] <NEWLINE> ans += alist [ i ] * ( total ) <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
from numba import njit <NEWLINE> @ njit <NEWLINE> def solve ( n ) : <NEWLINE> <INDENT> fctrs = [ 0 ] * ( n + 1 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 , i ) : <NEWLINE> <INDENT> fctrs [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += ( i * fctrs [ i ] ) <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( solve ( n ) ) <NEWLINE>
from collections import deque <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> route = [ ] <NEWLINE> n_black = 0 <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> tmp_ls = input ( ) <NEWLINE> n_black += tmp_ls . count ( <STRING> ) <NEWLINE> route . append ( tmp_ls ) <NEWLINE> <DEDENT> visited = [ [ False ] * W for _ in range ( H ) ] <NEWLINE> dist = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> dist [ 0 ] [ 0 ] = 0 <NEWLINE> tmp = [ 0 , 0 ] <NEWLINE> goal = [ H - 1 , W - 1 ] <NEWLINE> kouho = deque ( ) <NEWLINE> def rinsetsu ( ls ) : <NEWLINE> <INDENT> x , y = ls [ 0 ] , ls [ 1 ] <NEWLINE> ans = [ ] <NEWLINE> if x - 1 >= 0 : <NEWLINE> <INDENT> ans . append ( [ x - 1 , y ] ) <NEWLINE> <DEDENT> if x + 1 <= H - 1 : <NEWLINE> <INDENT> ans . append ( [ x + 1 , y ] ) <NEWLINE> <DEDENT> if y - 1 >= 0 : <NEWLINE> <INDENT> ans . append ( [ x , y - 1 ] ) <NEWLINE> <DEDENT> if y + 1 <= W - 1 : <NEWLINE> <INDENT> ans . append ( [ x , y + 1 ] ) <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> for ls in rinsetsu ( [ 0 , 0 ] ) : <NEWLINE> <INDENT> if route [ ls [ 0 ] ] [ ls [ 1 ] ] == <STRING> : <NEWLINE> <INDENT> kouho . append ( [ ls [ 0 ] , ls [ 1 ] , 0 , 0 ] ) <NEWLINE> <DEDENT> <DEDENT> def bfs ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if len ( kouho ) == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> tmp = kouho . popleft ( ) <NEWLINE> if not visited [ tmp [ 0 ] ] [ tmp [ 1 ] ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> x , y = tmp [ 0 ] , tmp [ 1 ] <NEWLINE> visited [ x ] [ y ] = True <NEWLINE> dist [ x ] [ y ] = dist [ tmp [ 2 ] ] [ tmp [ 3 ] ] + 1 <NEWLINE> if [ x , y ] == goal : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for ls in rinsetsu ( [ x , y ] ) : <NEWLINE> <INDENT> if not visited [ ls [ 0 ] ] [ ls [ 1 ] ] and route [ ls [ 0 ] ] [ ls [ 1 ] ] == <STRING> : <NEWLINE> <INDENT> kouho . append ( ls + [ x , y ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> bfs ( ) <NEWLINE> if dist [ H - 1 ] [ W - 1 ] == - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> white = dist [ H - 1 ] [ W - 1 ] + 1 <NEWLINE> print ( H * W - white - n_black ) <NEWLINE> <NL> <DEDENT>
from math import sqrt <NEWLINE> n = int ( input ( ) ) <NEWLINE> sn = int ( sqrt ( n ) // 1 ) <NEWLINE> <NL> for i in range ( sn , 0 , - 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> s = n // i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( str ( s ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> if 0 in A : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> m = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> m *= a <NEWLINE> if m > 10 ** 18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return m <NEWLINE> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 998244353 <NEWLINE> <NL> comb = 1 <NEWLINE> res = 0 <NEWLINE> for n in range ( K + 1 ) : <NEWLINE> <INDENT> res = ( res + comb * M * pow ( M - 1 , N - 1 - n , p ) ) % p <NEWLINE> comb = ( comb * ( N - 1 - n ) * pow ( n + 1 , p - 2 , p ) ) % p <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> N = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( a , K + 1 ) : <NEWLINE> <INDENT> for c in range ( b , K + 1 ) : <NEWLINE> <INDENT> g = math . gcd ( a , b ) <NEWLINE> g = math . gcd ( g , c ) <NEWLINE> if ( a != b or a != c ) : <NEWLINE> <INDENT> if ( a != b and a != c and b != c ) : <NEWLINE> <INDENT> g *= 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g *= 3 <NEWLINE> <DEDENT> <DEDENT> N += g <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( N ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from collections import Counter , defaultdict <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> H , W , M = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> HW = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> HW . append ( ( h , w ) ) <NEWLINE> <DEDENT> return H , W , M , HW <NEWLINE> <NL> <NL> <DEDENT> def solve ( H , W , M , HW ) : <NEWLINE> <INDENT> hcount = Counter ( ) <NEWLINE> wcount = Counter ( ) <NEWLINE> for h , w in HW : <NEWLINE> <INDENT> hcount [ h ] += 1 <NEWLINE> wcount [ w ] += 1 <NEWLINE> <DEDENT> hm = hcount . most_common ( ) <NEWLINE> wm = wcount . most_common ( ) <NEWLINE> hmax = hm [ 0 ] [ 1 ] <NEWLINE> wmax = wm [ 0 ] [ 1 ] <NEWLINE> hn = len ( [ 1 for k , v in hcount . items ( ) if v == hmax ] ) <NEWLINE> wn = len ( [ 1 for k , v in wcount . items ( ) if v == wmax ] ) <NEWLINE> m = hn * wn <NEWLINE> for h , w in HW : <NEWLINE> <INDENT> if hcount [ h ] == hmax and wcount [ w ] == wmax : <NEWLINE> <INDENT> m -= 1 <NEWLINE> <DEDENT> <DEDENT> if m == 0 : <NEWLINE> <INDENT> return hmax + wmax - 1 <NEWLINE> <DEDENT> return hmax + wmax <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> inputs = read ( ) <NEWLINE> outputs = solve ( * inputs ) <NEWLINE> if outputs is not None : <NEWLINE> <INDENT> print ( <STRING> % str ( outputs ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> prod = 0 <NEWLINE> <NL> law = 10 ** 9 + 7 <NEWLINE> <NL> sumation = sum ( S ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> sumation = sumation - S [ i ] <NEWLINE> prod = prod + ( S [ i ] * sumation ) % law <NEWLINE> <NL> <DEDENT> print ( prod % law ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> if i == n or i == n - 1 or i == n - 2 : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif i % 10 == 3 : <NEWLINE> <INDENT> if i == n or i == n - 1 or i == n - 2 : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif str ( i ) . find ( <STRING> ) > - 1 : <NEWLINE> <INDENT> if i == n or i == n - 1 or i == n - 2 : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def input_int ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def one_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def one_str ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <NL> <DEDENT> def many_int ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> N , M , K = input_int ( ) <NEWLINE> A = many_int ( ) <NEWLINE> B = many_int ( ) <NEWLINE> <NL> <NL> import itertools as it <NEWLINE> import bisect <NEWLINE> <NL> def bins ( A , B , K ) : <NEWLINE> <INDENT> A_it = list ( it . accumulate ( A ) ) <NEWLINE> B_it = list ( it . accumulate ( B ) ) <NEWLINE> <NL> A_index = bisect . bisect_right ( A_it , K ) <NEWLINE> B_index = bisect . bisect_right ( B_it , K ) <NEWLINE> <NL> A_it = [ 0 ] + A_it [ : A_index ] <NEWLINE> B_it = B_it [ : B_index ] <NEWLINE> <NL> maxs = 0 <NEWLINE> count = 0 <NEWLINE> for i in A_it [ : : - 1 ] : <NEWLINE> <INDENT> if K - i < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> now = K - i <NEWLINE> B_index = bisect . bisect_right ( B_it , now ) <NEWLINE> <NL> maxs = max ( maxs , B_index + max ( A_index - count , 0 ) ) <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> return maxs <NEWLINE> <NL> <DEDENT> print ( bins ( A , B , K ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> h , w = map ( int , ( input ( ) . split ( ) ) ) <NEWLINE> s = [ list ( map ( str , input ( ) ) ) for i in range ( h ) ] <NEWLINE> l = [ [ 0 ] * ( w + 2 ) for i in range ( h + 2 ) ] <NEWLINE> <NL> <NL> def addFlag ( i , j ) : <NEWLINE> <INDENT> for x in range ( 3 ) : <NEWLINE> <INDENT> for y in range ( 3 ) : <NEWLINE> <INDENT> if l [ i + x ] [ j + y ] != <STRING> : <NEWLINE> <INDENT> l [ i + x ] [ j + y ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> l [ i + 1 ] [ j + 1 ] = <STRING> <NEWLINE> addFlag ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> l = np . delete ( l , [ 0 , h + 1 ] , 0 ) <NEWLINE> l = np . delete ( l , [ 0 , w + 1 ] , 1 ) <NEWLINE> <NL> <NL> for i in l : <NEWLINE> <INDENT> ans = <STRING> . join ( map ( str , i ) ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> a = prime_factorize ( N ) <NEWLINE> b = set ( a ) <NEWLINE> <NL> dic = { } <NEWLINE> for i in b : <NEWLINE> <INDENT> n = 0 <NEWLINE> while True : <NEWLINE> <INDENT> n += 1 <NEWLINE> if a == [ ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a . pop ( 0 ) <NEWLINE> if a == [ ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a [ 0 ] != i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> dic [ i ] = n <NEWLINE> <NL> <NL> <DEDENT> an = 0 <NEWLINE> for k , v in dic . items ( ) : <NEWLINE> <INDENT> num = int ( ( - 1 + ( 1 + 8 * v ) ** ( 1 / 2 ) ) / 2 ) <NEWLINE> an += num <NEWLINE> <NL> <DEDENT> print ( an ) <NEWLINE>
<COMMENT> <NL> <NL> def calc ( x ) : <NEWLINE> <INDENT> if x < D + 1 : <NEWLINE> <INDENT> mv [ x ] = 0 <NEWLINE> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = d [ x ] [ 0 ] <NEWLINE> q = d [ x ] [ 1 ] <NEWLINE> r = d [ x - D ] [ 0 ] <NEWLINE> s = d [ x - D ] [ 1 ] <NEWLINE> tmp = abs ( p - r ) + abs ( q - s ) <NEWLINE> ret = tmp + calc ( x - D ) <NEWLINE> mv [ x ] = ret <NEWLINE> return ret <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> H , W , D = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( H ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> d = dict ( ) <NEWLINE> z = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> for b in a : <NEWLINE> <INDENT> p = z // W <NEWLINE> q = z % W <NEWLINE> d [ b ] = ( p , q ) <NEWLINE> z += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> mv = [ 0 ] * ( H * W + 1 ) <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> calc ( H * W - i ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> L = [ 0 ] * Q <NEWLINE> R = [ 0 ] * Q <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( mv [ R ] - mv [ L ] ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> <NL> <NL> change = [ ] <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ - 1 * int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> change . append ( [ - c , b ] ) <NEWLINE> <NL> <DEDENT> l = [ ] <NEWLINE> heapq . heapify ( change ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> flg = False <NEWLINE> cnt = 0 <NEWLINE> while cnt < n : <NEWLINE> <INDENT> if change : <NEWLINE> <INDENT> atmp = - 1 * a [ 0 ] <NEWLINE> btmp = - 1 * change [ 0 ] [ 0 ] <NEWLINE> if atmp <= btmp : <NEWLINE> <INDENT> b , c = heapq . heappop ( change ) <NEWLINE> while c > 0 and cnt < n : <NEWLINE> <INDENT> l . append ( b ) <NEWLINE> c -= 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> aa = heapq . heappop ( a ) <NEWLINE> l . append ( aa ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> aa = heapq . heappop ( a ) <NEWLINE> l . append ( aa ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 * sum ( l ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> tel = [ int ( e ) - 1 for e in input ( ) . split ( ) ] <NEWLINE> <NL> pl = [ 0 ] <NEWLINE> for i in range ( 2 * n + 1000 ) : <NEWLINE> <INDENT> nxt = tel [ pl [ - 1 ] ] <NEWLINE> pl . append ( nxt ) <NEWLINE> <NL> <DEDENT> if k < n + 1 : <NEWLINE> <INDENT> print ( pl [ k ] + 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> loop_end = n <NEWLINE> loop_start = n - 1 <NEWLINE> while pl [ loop_start ] != pl [ loop_end ] : <NEWLINE> <INDENT> loop_start -= 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> period = loop_end - loop_start <NEWLINE> <NL> k %= period <NEWLINE> <NL> while k < n : <NEWLINE> <INDENT> k += period <NEWLINE> <NL> <DEDENT> print ( pl [ k ] + 1 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> oddcount = 0 <NEWLINE> mod40 = 0 <NEWLINE> other = 0 <NEWLINE> <NL> for a in alist : <NEWLINE> <INDENT> if a % 2 == 1 : <NEWLINE> <INDENT> oddcount += 1 <NEWLINE> <DEDENT> elif a % 4 == 0 : <NEWLINE> <INDENT> mod40 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> other += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if N == 1 : <NEWLINE> <INDENT> if mod40 == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if N == 2 or N == 3 : <NEWLINE> <INDENT> if mod40 > 0 or other == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if N % 2 == 1 : <COMMENT> <NEWLINE> <INDENT> if ( N - ( ( other // 2 ) * 2 ) ) // 2 <= mod40 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> if other % 2 == 1 : <COMMENT> <NEWLINE> <INDENT> if ( N - ( ( other // 2 ) * 2 ) ) // 2 <= mod40 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( N - ( ( other // 2 ) * 2 ) ) // 2 <= mod40 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> num = 0 <NEWLINE> if not k % 2 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> num = ( num * 10 + 7 ) % k <NEWLINE> if num == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> flag = False <NEWLINE> while count < n : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> count += 1 <NEWLINE> if a == b and count < n : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> count += 1 <NEWLINE> if a == b and count < n : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> count += 1 <NEWLINE> if a == b and count <= n : <NEWLINE> <INDENT> flag = True <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> list1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dic1 = Counter ( list1 ) <NEWLINE> <NL> def choose2 ( n ) : <NEWLINE> <INDENT> return n * ( n - 1 ) / 2 <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> for key in dic1 : <NEWLINE> <INDENT> sum += choose2 ( dic1 [ key ] ) <NEWLINE> <NL> <DEDENT> for i in list1 : <NEWLINE> <INDENT> print ( int ( sum - dic1 [ i ] + 1 ) ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> def SumOfProductParis ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> return A [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = 0 <NEWLINE> temp = sum ( A ) <NEWLINE> result = temp ** 2 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> result -= A [ i ] ** 2 <NEWLINE> <DEDENT> return ( result // 2 ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( SumOfProductParis ( N ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> result = 1 <NEWLINE> <NL> if A . count ( 0 ) == 0 : <NEWLINE> <INDENT> for x in range ( N ) : <NEWLINE> <INDENT> result = result * A [ x ] <NEWLINE> if result >= 10 ** 18 + 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> newA = sorted ( A ) <NEWLINE> ma = newA [ N - 1 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == ma : <NEWLINE> <INDENT> print ( newA [ N - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ma ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> s = list ( str ( input ( ) ) ) <NEWLINE> <NL> num_list = [ ] <NEWLINE> r , g , b = 0 , 0 , 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> num_list . append ( [ r , g , b ] ) <NEWLINE> <NL> <DEDENT> num_list . reverse ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += num_list [ i + 1 ] [ 1 ] * num_list [ i + 1 ] [ 2 ] <COMMENT> <NEWLINE> for j in range ( 0 , ( n - i - 1 ) // 2 ) : <NEWLINE> <INDENT> a , b , c = i , j + i + 1 , j + j + i + 2 <NEWLINE> <COMMENT> <NL> if { s [ b ] , s [ c ] } == { <STRING> , <STRING> } : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += num_list [ i + 1 ] [ 0 ] * num_list [ i + 1 ] [ 2 ] <COMMENT> <NEWLINE> for j in range ( 0 , ( n - i - 1 ) // 2 ) : <NEWLINE> <INDENT> a , b , c = i , j + i + 1 , j + j + i + 2 <NEWLINE> <COMMENT> <NL> if { s [ b ] , s [ c ] } == { <STRING> , <STRING> } : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += num_list [ i + 1 ] [ 0 ] * num_list [ i + 1 ] [ 1 ] <COMMENT> <NEWLINE> for j in range ( 0 , ( n - i - 1 ) // 2 ) : <NEWLINE> <INDENT> a , b , c = i , j + i + 1 , j + j + i + 2 <NEWLINE> <COMMENT> <NL> if { s [ b ] , s [ c ] } == { <STRING> , <STRING> } : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def power_func ( a , b , p ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if b % 2 == 0 : <NEWLINE> <INDENT> d = power_func ( a , b // 2 , p ) <NEWLINE> return d * d % p <NEWLINE> <DEDENT> if b % 2 == 1 : <NEWLINE> <INDENT> return ( a * power_func ( a , b - 1 , p ) ) % p <NEWLINE> <NL> <DEDENT> <DEDENT> S = input ( ) <NEWLINE> ansl = [ 0 ] * 2019 <NEWLINE> temp = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> temp = ( temp + int ( S [ - i - 1 ] ) * power_func ( 10 , i , 2019 ) ) % 2019 <NEWLINE> ansl [ temp ] += 1 <NEWLINE> <DEDENT> ans = ( ansl [ 0 ] + 1 ) * ansl [ 0 ] / 2 <NEWLINE> <NL> for i in range ( 1 , 2019 ) : <NEWLINE> <INDENT> ans += ansl [ i ] * ( ansl [ i ] - 1 ) / 2 <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( a > 0 and b < 0 ) or ( a < 0 and b > 0 ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif a == 0 or b == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif a > 0 and b > 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif a < 0 and b < 0 : <NEWLINE> <INDENT> if ( a % 2 == 0 and b % 2 == 0 ) or ( a % 2 != 0 and b % 2 != 0 ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> <NL> <NL> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // math . gcd ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> input = sys . stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LCM = 1 <NEWLINE> ans = 0 <NEWLINE> MOD = 1000000007 <NEWLINE> for x in A : <NEWLINE> <INDENT> LCM = lcm ( LCM , x ) <NEWLINE> <DEDENT> for x in A : <NEWLINE> <INDENT> ans += LCM // x <NEWLINE> <NL> <DEDENT> print ( ans % MOD ) <NEWLINE>
n = input ( ) <NEWLINE> def sumN ( n ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> sum += int ( n [ i ] ) <NEWLINE> <DEDENT> return sum <NEWLINE> <DEDENT> sum = sumN ( n ) <NEWLINE> if sum % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
cond = [ int ( n ) for n in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> case = [ ] <NEWLINE> cards = [ n for n in range ( 1 , cond [ 0 ] + 1 ) ] <NEWLINE> cards . sort ( reverse = True ) <NEWLINE> for c in range ( cond [ 1 ] ) : <NEWLINE> <INDENT> case = [ int ( n ) for n in input ( ) . split ( <STRING> ) ] <NEWLINE> case [ 0 ] -= 1 <NEWLINE> <COMMENT> <NL> disp = cards [ case [ 0 ] : case [ 0 ] + case [ 1 ] ] <NEWLINE> cards [ case [ 1 ] : case [ 0 ] + case [ 1 ] ] = cards [ 0 : case [ 0 ] ] <NEWLINE> cards [ 0 : case [ 1 ] ] = disp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cards [ 0 ] ) <NEWLINE> cond = [ int ( n ) for n in input ( ) . split ( <STRING> ) ] <NEWLINE> if cond [ 0 ] == 0 and cond [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ea = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ea . append ( ea [ i ] + a [ i ] ) <NEWLINE> <DEDENT> eb = [ 0 ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> eb . append ( eb [ i ] + b [ i ] ) <NEWLINE> <DEDENT> tb = m <NEWLINE> p = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> while ea [ i ] + eb [ tb ] > k : <NEWLINE> <INDENT> if tb == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> tb -= 1 <NEWLINE> <DEDENT> if ea [ i ] + eb [ tb ] <= k : <NEWLINE> <INDENT> p = max ( i + tb , p ) <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in l : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= l [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( a ) <NEWLINE> prime = [ True ] * ( 10 ** 6 + 10 ) <NEWLINE> <NL> b = sorted ( set ( a ) ) <NEWLINE> <NL> for i in b : <NEWLINE> <INDENT> num = i * 2 <NEWLINE> while True : <NEWLINE> <INDENT> if num >= 10 ** 6 + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> prime [ num ] = False <NEWLINE> num += i <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for s in a : <NEWLINE> <INDENT> if prime [ s ] == True and c [ s ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> aa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ca = collections . Counter ( aa ) <NEWLINE> la = sorted ( [ a for a in ca . items ( ) ] , key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> <NL> list1 = [ ] <NEWLINE> list2 = [ ] <NEWLINE> <NL> for a in la : <NEWLINE> <INDENT> if a [ 1 ] > 1 : <NEWLINE> <INDENT> list1 . append ( a ) <NEWLINE> <DEDENT> if a [ 1 ] > 3 : <NEWLINE> <INDENT> list2 . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( list1 ) > 1 : <NEWLINE> <INDENT> xr = list1 [ 0 ] [ 0 ] * list1 [ 1 ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xr = 0 <NEWLINE> <NL> <DEDENT> if len ( list2 ) > 0 : <NEWLINE> <INDENT> xs = list2 [ 0 ] [ 0 ] * list2 [ 0 ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xs = 0 <NEWLINE> <NL> <DEDENT> ans = max ( xr , xs ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
O = input ( ) <NEWLINE> E = input ( ) <NEWLINE> N = len ( E ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += O [ i ] + E [ i ] <NEWLINE> <DEDENT> if len ( O ) - len ( E ) == 1 : <NEWLINE> <INDENT> ans += O [ - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> file_input = sys . stdin <NEWLINE> <NL> n = file_input . readline ( ) <NEWLINE> <NL> EP = [ ] <NEWLINE> <NL> for line in file_input : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 = ( map ( int , line . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if y1 < y2 : <NEWLINE> <INDENT> p1 = ( x1 , y1 , 2 ) <NEWLINE> p2 = ( x2 , y2 , 3 ) <NEWLINE> <DEDENT> elif y1 > y2 : <NEWLINE> <INDENT> p1 = ( x1 , y1 , 3 ) <NEWLINE> p2 = ( x2 , y2 , 2 ) <NEWLINE> <DEDENT> elif x1 < x2 : <NEWLINE> <INDENT> p1 = ( x1 , y1 , 1 ) <NEWLINE> p2 = ( x2 , y2 , 4 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p1 = ( x1 , y1 , 4 ) <NEWLINE> p2 = ( x2 , y2 , 1 ) <NEWLINE> <DEDENT> EP += [ p1 , p2 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> import bisect <NEWLINE> <NL> def manhattan_intersection ( point_list ) : <NEWLINE> <INDENT> point_list . sort ( key = lambda p : ( p [ 1 ] , p [ 0 ] , p [ 2 ] ) ) <NEWLINE> T = [ ] <NEWLINE> cnt = 0 <NEWLINE> flag = False <NEWLINE> for p in point_list : <NEWLINE> <INDENT> position = p [ 2 ] <NEWLINE> if position == 3 : <NEWLINE> <INDENT> i = bisect . bisect_left ( T , p [ 0 ] ) <NEWLINE> T . pop ( i ) <NEWLINE> if flag : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> elif position == 2 : <NEWLINE> <INDENT> bisect . insort ( T , p [ 0 ] ) <NEWLINE> <DEDENT> elif position == 4 : <NEWLINE> <INDENT> cnt += bisect . bisect ( T , p [ 0 ] ) - left_end <NEWLINE> flag = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left_end = bisect . bisect_left ( T , p [ 0 ] ) <NEWLINE> flag = True <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> manhattan_intersection ( EP ) <NEWLINE>
import math <NEWLINE> <NL> def func ( A , B , x ) : <NEWLINE> <INDENT> return math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> <NL> <DEDENT> A , B , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> print ( func ( A , B , min ( B - 1 , N ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = [ 0 for a in range ( 11000 ) ] <NEWLINE> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> v = x * x + y * y + i * i + x * y + y * i + i * x <NEWLINE> if v <= N : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for b in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ b ] ) <NEWLINE> <DEDENT>
N = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> added = As [ 0 ] + As [ 1 ] <NEWLINE> xored = 0 <NEWLINE> for A in As [ 2 : ] : <NEWLINE> <INDENT> xored ^= A <NEWLINE> <NL> <DEDENT> anded = added - xored <NEWLINE> if anded % 2 == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> anded >>= 1 <NEWLINE> <NL> <DEDENT> left_stones_l_A0 = <STRING> <COMMENT> <NEWLINE> left_stones_e_A0 = <STRING> <COMMENT> <NEWLINE> for i , ( a , x ) in enumerate ( zip ( format ( anded , <STRING> ) , format ( xored , <STRING> ) ) ) : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> if a == <STRING> : <NEWLINE> <INDENT> left_stones_l_A0 += <STRING> <NEWLINE> left_stones_e_A0 += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left_stones_l_A0 += <STRING> <NEWLINE> left_stones_e_A0 += <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a == <STRING> : <NEWLINE> <INDENT> if int ( left_stones_l_A0 + <STRING> + <STRING> * ( 44 - i ) , base = 2 ) <= As [ 0 ] : <NEWLINE> <INDENT> left_stones_l_A0 += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left_stones_l_A0 += <STRING> <NEWLINE> <DEDENT> if int ( left_stones_e_A0 + <STRING> + <STRING> * ( 44 - i ) , base = 2 ) <= As [ 0 ] : <NEWLINE> <INDENT> left_stones_e_A0 += <STRING> <NEWLINE> left_stones_l_A0 = left_stones_e_A0 <NEWLINE> <DEDENT> elif int ( left_stones_e_A0 + <STRING> + <STRING> * ( 44 - i ) , base = 2 ) <= As [ 0 ] : <NEWLINE> <INDENT> left_stones_l_A0 = left_stones_e_A0 + <STRING> <NEWLINE> left_stones_e_A0 += <STRING> <NEWLINE> <DEDENT> elif int ( left_stones_e_A0 + <STRING> + <STRING> * ( 44 - i ) , base = 2 ) <= As [ 0 ] : <NEWLINE> <INDENT> left_stones_e_A0 += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left_stones_e_A0 = left_stones_l_A0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if int ( left_stones_e_A0 , base = 2 ) <= As [ 0 ] : <NEWLINE> <INDENT> ans = As [ 0 ] - int ( left_stones_e_A0 , base = 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = As [ 0 ] - int ( left_stones_l_A0 , base = 2 ) <NEWLINE> <NL> <DEDENT> if 0 <= ans < As [ 0 ] : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> left = [ ] <NEWLINE> right = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> left . append ( b ) <NEWLINE> <DEDENT> elif b == N : <NEWLINE> <INDENT> right . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> flag = False <NEWLINE> left = set ( left ) <NEWLINE> for r in right : <NEWLINE> <INDENT> if r in left : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> from collections import Counter <NEWLINE> count = Counter ( al ) <NEWLINE> <NL> als = sorted ( al ) <NEWLINE> dp = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> res = sum ( als ) <NEWLINE> <NL> for i in range ( 10 ** 5 + 1 ) : <NEWLINE> <INDENT> dp [ i ] = count [ i ] <NEWLINE> <NL> <DEDENT> for j in range ( q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> res += dp [ a ] * ( b - a ) <NEWLINE> dp [ b ] += dp [ a ] <NEWLINE> dp [ a ] = 0 <NEWLINE> print ( res ) <NEWLINE> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> a = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] <NEWLINE> <DEDENT> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a [ c - 1 ] - a [ b - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( sum ( ans ) - n ) <NEWLINE>
import itertools <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> a [ : 0 ] = [ 0 ] <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> a [ i ] += a [ i - 1 ] <NEWLINE> <DEDENT> print ( max ( map ( lambda x : x [ 1 ] - x [ 0 ] , itertools . combinations ( a , 2 ) ) ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , [ 0 ] + input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , [ 0 ] + input ( ) . split ( ) ) ) <NEWLINE> cost = 0 <NEWLINE> cumsum_a = np . cumsum ( A ) <NEWLINE> cumsum_b = np . cumsum ( B ) <NEWLINE> <NL> num_book = 0 <NEWLINE> max_a = 0 <NEWLINE> ind_b = 0 <NEWLINE> max_b = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if cumsum_a [ i ] <= K : <NEWLINE> <INDENT> max_a = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if cumsum_b [ i ] <= K : <NEWLINE> <INDENT> max_b = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( max_a , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( ind_b , max_b + 1 ) : <NEWLINE> <INDENT> if cumsum_b [ j ] + cumsum_a [ i ] <= K : <NEWLINE> <COMMENT> <NL> <INDENT> num_book = max ( i + j , num_book ) <NEWLINE> ind_b = j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( num_book ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> INF = 10 ** 6 + 1 <NEWLINE> lis = [ 1 ] * INF <NEWLINE> exist = [ 0 ] * INF <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> if lis [ a ] and exist [ a ] < 1 : <NEWLINE> <INDENT> q = 2 <NEWLINE> while a * q < INF : <NEWLINE> <INDENT> lis [ a * q ] = 0 <NEWLINE> q += 1 <NEWLINE> <DEDENT> <DEDENT> exist [ a ] += 1 <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if lis [ a ] and exist [ a ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for a in range ( 10 ) : <NEWLINE> <INDENT> s_index = s . find ( str ( a ) ) <NEWLINE> if s_index == - 1 : <NEWLINE> <INDENT> continue <COMMENT> <NEWLINE> <DEDENT> for b in range ( 10 ) : <NEWLINE> <INDENT> t_index = s . find ( str ( b ) , s_index + 1 ) <NEWLINE> if t_index == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for c in range ( 10 ) : <NEWLINE> <INDENT> u_index = s . find ( str ( c ) , t_index + 1 ) <NEWLINE> if u_index != - 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
cho , ei , don = 0 , 0 , 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmp . sort ( ) <NEWLINE> a , b , c = tmp [ 0 ] , tmp [ 1 ] , tmp [ 2 ] <NEWLINE> if a + b <= c : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a2 , b2 , c2 = a ** 2 , b ** 2 , c ** 2 <NEWLINE> if a2 + b2 == c2 : <NEWLINE> <INDENT> cho += 1 <NEWLINE> <DEDENT> elif a2 + b2 < c2 : <NEWLINE> <INDENT> don += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ei += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cho + ei + don , cho , ei , don ) <NEWLINE> <NL>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = 10 ** 9 + 7 <NEWLINE> s = sum ( a ) % N <NEWLINE> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> s -= i <NEWLINE> ans += s * i <NEWLINE> ans %= N <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n % m == 0 : <NEWLINE> <INDENT> print ( int ( n / m ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst = make_divisors ( m ) [ : : - 1 ] <NEWLINE> for i in lst : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if m - i * ( n - 1 ) > 0 : <NEWLINE> <INDENT> if ( m - i * ( n - 1 ) ) % i == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<NL> <COMMENT> <NL> <STRING> <NEWLINE> <STRING> <NEWLINE> <NL> import sys <NEWLINE> read = sys . stdin . buffer . read <COMMENT> <NEWLINE> readline = sys . stdin . buffer . readline <COMMENT> <NEWLINE> readlines = sys . stdin . buffer . readlines <COMMENT> <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <COMMENT> <NEWLINE> <NL> N = int ( readline ( ) . rstrip ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <NL> buka = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> buka [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> L = [ str ( a ) for a in buka ] <NEWLINE> L = <STRING> . join ( L ) <NEWLINE> print ( L ) <NEWLINE>
import math , itertools , fractions , heapq , collections , bisect , sys , queue , copy <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> <NL> n = 0 <NEWLINE> m = 0 <NEWLINE> ans = - inf <NEWLINE> l = [ ] <NEWLINE> <NL> def dfs ( s ) : <NEWLINE> <INDENT> global n <NEWLINE> global m <NEWLINE> global ans <NEWLINE> global l <NEWLINE> <NL> if len ( s ) == n : <NEWLINE> <INDENT> _ans = 0 <NEWLINE> for a , b , c , d in l : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> if s [ b ] - s [ a ] == c : <NEWLINE> <INDENT> _ans += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , _ans ) <NEWLINE> <NL> <DEDENT> if len ( s ) != n : <NEWLINE> <INDENT> x = s [ - 1 ] <NEWLINE> for i in range ( x , m + 1 ) : <NEWLINE> <INDENT> dfs ( s + [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> global n <NEWLINE> global m <NEWLINE> global ans <NEWLINE> global l <NEWLINE> <NL> n , m , q = LI ( ) <NEWLINE> l = [ LI ( ) for _ in range ( q ) ] <NEWLINE> <NL> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> dfs ( [ i ] ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ x - 1 ] <= h [ y - 1 ] : <NEWLINE> <INDENT> l [ x - 1 ] = 1 <NEWLINE> <DEDENT> if h [ x - 1 ] >= h [ y - 1 ] : <NEWLINE> <INDENT> l [ y - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if l [ i ] == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = n // k <NEWLINE> m = min ( ( n - s * k ) , ( ( s + 1 ) * k - n ) ) <NEWLINE> print ( m ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> from collections import deque , Counter , defaultdict <NEWLINE> <COMMENT> <NL> import bisect <NEWLINE> import heapq <NEWLINE> <COMMENT> <NL> import itertools <NEWLINE> import numpy as np <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> inf = 10 ** 18 <NEWLINE> MOD = 1000000007 <NEWLINE> ri = lambda : int ( input ( ) ) <NEWLINE> rs = lambda : input ( ) . strip ( ) <NEWLINE> rl = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> k = ri ( ) <NEWLINE> reses = [ ] <NEWLINE> cnt = 1 <NEWLINE> tmp = 7 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> res = tmp % k <NEWLINE> if res == 0 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> tmp = res * 10 + 7 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( - 1 ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> from math import gcd <NEWLINE> <NL> n = int ( sys . stdin . read ( ) ) <NEWLINE> print ( sum ( gcd ( gcd ( abc [ 0 ] , abc [ 1 ] ) , abc [ 2 ] ) for abc in itertools . product ( range ( 1 , n + 1 ) , repeat = 3 ) ) ) <NEWLINE>
t = int ( input ( ) ) <NEWLINE> arr = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> n = 1 <NEWLINE> flag = True <NEWLINE> if 0 in arr : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( t ) : <NEWLINE> <INDENT> n *= arr [ i ] <NEWLINE> if n > 10 ** 18 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> a = np . array ( a ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 61 ) : <NEWLINE> <INDENT> b = np . count_nonzero ( a >> i & 1 ) <NEWLINE> ans += b * ( n - b ) * 1 << i <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
a , b , k = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> if a > k : <NEWLINE> <INDENT> a -= k <NEWLINE> k = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> k -= a <NEWLINE> a = 0 <NEWLINE> <NL> <DEDENT> if b > k : <NEWLINE> <INDENT> b -= k <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> b = 0 <NEWLINE> <NL> <NL> <DEDENT> print ( <STRING> . format ( a , b ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> <NL> <NL> R = 0 <NEWLINE> G = 0 <NEWLINE> B = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s = S [ i ] <NEWLINE> if ( s == <STRING> ) : <NEWLINE> <INDENT> R += 1 <NEWLINE> <DEDENT> if ( s == <STRING> ) : <NEWLINE> <INDENT> G += 1 <NEWLINE> <DEDENT> if ( s == <STRING> ) : <NEWLINE> <INDENT> B += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = R * G * B <NEWLINE> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( 1 , N // 2 + 1 ) : <NEWLINE> <INDENT> if i + j * 2 >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ i + j ] and S [ i + j ] != S [ i + 2 * j ] and S [ i + 2 * j ] != S [ i ] : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> if len ( S ) < 4 : <NEWLINE> <INDENT> print ( int ( S [ 0 ] ) * int ( S [ - 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if A <= K : <NEWLINE> <INDENT> ans = ans + A <NEWLINE> K = K - A <NEWLINE> if B <= K : <NEWLINE> <INDENT> K = K - B <NEWLINE> if C >= K : <NEWLINE> <INDENT> ans = ans - K <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT>
<NL> n , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <NL> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> ans [ i + 1 ] = ans [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i + 1 ] = ans [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> print ( ans [ lr [ i ] [ 1 ] ] - ans [ lr [ i ] [ 0 ] ] ) <NEWLINE> <DEDENT>
N = 0 <NEWLINE> a = 0 <NEWLINE> <NL> try : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> a += i * ( i + 1 ) // 2 <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> line = input ( ) . split ( ) <NEWLINE> u = min ( int ( line [ 0 ] ) , int ( line [ 1 ] ) ) - 1 <NEWLINE> v = max ( int ( line [ 0 ] ) , int ( line [ 1 ] ) ) - 1 <NEWLINE> a -= ( u + 1 ) * ( N - v ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> print ( a ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> counter = Counter ( a ) <NEWLINE> sum_res = sum ( a ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> before , after = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> sum_res -= before * counter [ before ] <NEWLINE> sum_res += after * counter [ before ] <NEWLINE> <NL> <COMMENT> <NL> counter [ after ] += counter [ before ] <NEWLINE> counter [ before ] = 0 <NEWLINE> <NL> print ( sum_res ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> scores = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for k in range ( N - K ) : <NEWLINE> <INDENT> if scores [ k ] >= scores [ k + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> N , A , B , C = input ( ) . split ( ) <NEWLINE> D = dict ( ) <NEWLINE> D [ <STRING> ] = int ( A ) <NEWLINE> D [ <STRING> ] = int ( B ) <NEWLINE> D [ <STRING> ] = int ( C ) <NEWLINE> <NL> S = [ ] <NEWLINE> for i in range ( int ( N ) ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> F = [ ] <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if D [ s [ 0 ] ] == 0 and D [ s [ 1 ] ] == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> if D [ s [ 0 ] ] == 1 and D [ s [ 1 ] ] == 1 : <NEWLINE> <INDENT> if D [ <STRING> ] + D [ <STRING> ] + D [ <STRING> ] == 2 : <NEWLINE> <INDENT> if i != int ( N ) - 1 : <NEWLINE> <INDENT> if S [ i + 1 ] != s : <NEWLINE> <INDENT> s0 = S [ i + 1 ] [ 0 ] <NEWLINE> s1 = S [ i + 1 ] [ 1 ] <NEWLINE> if s [ 0 ] == s0 or s [ 0 ] == s1 : <NEWLINE> <INDENT> F . append ( s [ 0 ] ) <NEWLINE> <DEDENT> if s [ 1 ] == s0 or s [ 1 ] == s1 : <NEWLINE> <INDENT> F . append ( s [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if len ( F ) != i + 1 : <NEWLINE> <INDENT> if D [ s [ 0 ] ] < D [ s [ 1 ] ] : <NEWLINE> <INDENT> F . append ( s [ 0 ] ) <NEWLINE> <DEDENT> if D [ s [ 0 ] ] > D [ s [ 1 ] ] : <NEWLINE> <INDENT> F . append ( s [ 1 ] ) <NEWLINE> <DEDENT> if D [ s [ 0 ] ] == D [ s [ 1 ] ] : <NEWLINE> <INDENT> F . append ( s [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> D [ F [ - 1 ] ] += 1 <NEWLINE> if s [ 0 ] == F [ - 1 ] : D [ s [ 1 ] ] -= 1 <NEWLINE> if s [ 1 ] == F [ - 1 ] : D [ s [ 0 ] ] -= 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE> if ans == <STRING> : <NEWLINE> <INDENT> for f in F : <NEWLINE> <INDENT> print ( f ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in s : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> a = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> for i in S : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> a . remove ( i ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( a [ 0 ] if len ( a ) != 0 else <STRING> ) <NEWLINE>
from math import fabs <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= 0 and 0 <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( fabs ( b - a ) + 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> al = input ( ) <NEWLINE> print ( al , end = <STRING> ) <NEWLINE> AL = list ( map ( int , al . split ( ) ) ) <NEWLINE> S = sum ( AL ) <NEWLINE> print ( <STRING> + str ( S ) ) <NEWLINE> AL . append ( S ) <NEWLINE> L . append ( AL ) <NEWLINE> <NL> <DEDENT> for i in range ( c ) : <NEWLINE> <INDENT> S = 0 <NEWLINE> for j in range ( r ) : <NEWLINE> <INDENT> S += L [ j ] [ i ] <NEWLINE> <DEDENT> print ( str ( S ) + <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> S = 0 <NEWLINE> for j in range ( r ) : <NEWLINE> <INDENT> S += L [ j ] [ - 1 ] <NEWLINE> <DEDENT> print ( str ( S ) ) <NEWLINE>
<COMMENT> <NL> <NL> from functools import reduce <NEWLINE> from operator import mul <NEWLINE> from collections import defaultdict , Counter <NEWLINE> from heapq import heappush , heappop <NEWLINE> import sys <NEWLINE> from math import sqrt , floor <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> INF = 10 ** 9 + 1 <COMMENT> <NEWLINE> <NL> <NL> def debug ( * x ) : <NEWLINE> <INDENT> print ( * x ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( N ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> num = N // i <NEWLINE> end = num * i <NEWLINE> ret += ( i + end ) * num // 2 <NEWLINE> <DEDENT> print ( ret ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> solve ( N ) <NEWLINE> <NL> <NL> <DEDENT> def _test ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> <NL> <NL> <DEDENT> def as_input ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import io <NEWLINE> global read , input <NEWLINE> f = io . StringIO ( s . strip ( ) ) <NEWLINE> input = f . readline <NEWLINE> read = f . read <NEWLINE> <NL> <NL> <DEDENT> USE_NUMBA = False <NEWLINE> if ( USE_NUMBA and sys . argv [ - 1 ] == <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , solve . __doc__ . strip ( ) . split ( ) [ 0 ] ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <NL> if ( USE_NUMBA and sys . argv [ - 1 ] != <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> from my_module import solve <COMMENT> <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> _test ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] != <STRING> and len ( sys . argv ) == 2 : <NEWLINE> <COMMENT> <NL> <INDENT> input_as_file = open ( sys . argv [ 1 ] ) <NEWLINE> input = input_as_file . buffer . readline <NEWLINE> read = input_as_file . buffer . read <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> k += 1 <NEWLINE> ans = 0 <NEWLINE> <NL> ab = [ ] <NEWLINE> <NL> for a in range ( 1 , k ) : <NEWLINE> <INDENT> for b in range ( 1 , k ) : <NEWLINE> <INDENT> ab . append ( math . gcd ( a , b ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for a in ab : <NEWLINE> <INDENT> for c in range ( 1 , k ) : <NEWLINE> <INDENT> ans += math . gcd ( a , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , W = map ( int , input ( ) . split ( ) ) <NEWLINE> B , V = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> a = A + W * T <NEWLINE> b = B + V * T <NEWLINE> c = A - W * T <NEWLINE> d = B - V * T <NEWLINE> <NL> <NL> if A < B : <NEWLINE> <INDENT> if a >= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if c <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def pc ( x ) : <NEWLINE> <INDENT> return format ( x , <STRING> ) . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> Xn = int ( X , 2 ) <NEWLINE> p = pc ( Xn ) <NEWLINE> X = list ( X ) <NEWLINE> <NL> Xp = Xn % ( p + 1 ) <NEWLINE> if p == 1 : <NEWLINE> <INDENT> Xm = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Xm = Xn % ( p - 1 ) <NEWLINE> <NL> <DEDENT> def f ( i ) : <NEWLINE> <INDENT> if p == 1 and X [ i ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> ret = Xm - pow ( 2 , N - 1 - i , p - 1 ) <NEWLINE> ret %= p - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ret = Xp + pow ( 2 , N - 1 - i , p + 1 ) <NEWLINE> ret %= p + 1 <NEWLINE> <DEDENT> cnt = 1 <NEWLINE> while ret > 0 : <NEWLINE> <INDENT> ret %= pc ( ret ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ret = f ( i ) <NEWLINE> print ( ret ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ 0 ] + [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> cycle = [ A [ 1 ] ] <NEWLINE> i = A [ 1 ] <NEWLINE> visited = set ( cycle ) <NEWLINE> while A [ i ] not in visited : <NEWLINE> <INDENT> cycle . append ( A [ i ] ) <NEWLINE> visited . add ( A [ i ] ) <NEWLINE> i = A [ i ] <NEWLINE> <DEDENT> interest_ind = cycle . index ( A [ i ] ) <NEWLINE> second_part = cycle [ interest_ind : ] <NEWLINE> p = len ( cycle ) - interest_ind <NEWLINE> k -= 1 <NEWLINE> if k < interest_ind : <NEWLINE> <INDENT> print ( cycle [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= interest_ind <NEWLINE> k %= p <NEWLINE> print ( cycle [ interest_ind + k ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> string = input ( ) <NEWLINE> l = string . split ( <STRING> ) <NEWLINE> a = int ( l [ 0 ] ) <NEWLINE> b = int ( l [ 1 ] ) <NEWLINE> n = int ( l [ 2 ] ) <NEWLINE> ans = 0 <NEWLINE> ni = min ( n , b - 1 ) <NEWLINE> f = math . floor ( ( a * ( ni ) ) / b ) <NEWLINE> s = math . floor ( ( ni ) / b ) <NEWLINE> temp = int ( f ) - ( a * int ( s ) ) <NEWLINE> ans = temp <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> print ( ans ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = Counter ( A ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 0 <NEWLINE> max_A = max ( A ) <NEWLINE> dp = [ True ] * ( max_A + 1 ) <COMMENT> <NEWLINE> happend = set ( ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if C [ a ] >= 2 : <NEWLINE> <INDENT> if a in happend : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> x = a * 2 <NEWLINE> while x <= max_A : <NEWLINE> <INDENT> dp [ x ] = False <NEWLINE> x += a <NEWLINE> <DEDENT> happend . add ( a ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if dp [ a ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> x = a * 2 <NEWLINE> while x <= max_A : <NEWLINE> <INDENT> dp [ x ] = False <NEWLINE> x += a <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N >= B : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = N <NEWLINE> <DEDENT> MAX = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> ans = ( A * x ) // B - A * ( x // B ) <NEWLINE> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> import warnings <NEWLINE> warnings . filterwarnings ( <STRING> ) <NEWLINE> <NL> Mv = 10 ** 5 <NEWLINE> Mw = 10 ** 11 <NEWLINE> <NL> N , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> w = np . array ( [ 0 ] * ( N + 1 ) ) <NEWLINE> v = np . array ( [ 0 ] * ( N + 1 ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> w [ i + 1 ] , v [ i + 1 ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> V = np . max ( v ) <NEWLINE> <NL> <COMMENT> <NL> dp = np . array ( [ [ Mw ] * ( Mv + 1 ) ] * ( N + 1 ) ) <NEWLINE> dp [ 0 ] [ 0 ] = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> tmp_arr = np . full ( Mv + 1 , Mw , dtype = int ) <NEWLINE> tmp_arr [ v [ i ] : ] = dp [ i - 1 ] [ : - v [ i ] ] + w [ i ] <NEWLINE> dp [ i ] = np . minimum ( dp [ i - 1 ] , tmp_arr ) <NEWLINE> <NL> <DEDENT> print ( np . max ( np . where ( dp [ N ] <= W , dp [ N ] , 0 ) . nonzero ( ) ) ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K + 1 , N + 1 ) : <NEWLINE> <INDENT> if A [ i - 1 ] > A [ i - K - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> <COMMENT> <NL> B = ( int ( B [ 0 ] ) - 0 ) * 100 + ( int ( B [ 2 ] ) - 0 ) * 10 + ( int ( B [ 3 ] ) - 0 ) <NEWLINE> print ( A * B // 100 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> clo = True <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> b . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> c = int ( input ( ) ) <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> d = input ( ) <NEWLINE> for j in range ( a ) : <NEWLINE> <INDENT> if d == b [ j ] : <NEWLINE> <INDENT> know = True <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> know = False <NEWLINE> <DEDENT> <DEDENT> if know : <NEWLINE> <INDENT> if clo : <NEWLINE> <INDENT> clo = False <NEWLINE> print ( <STRING> + d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> clo = True <NEWLINE> print ( <STRING> + d ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + d ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = set ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> com = input ( ) . split ( ) <NEWLINE> if com [ 0 ] == <STRING> : <NEWLINE> <INDENT> d . add ( com [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> if com [ 1 ] in d else <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n , q = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for lp in range ( q ) : <NEWLINE> <INDENT> c , x , y = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> if c == 0 : <NEWLINE> <INDENT> uf . unite ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( 1 if uf . is_same ( x , y ) else 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> class UnionFind : <NEWLINE> <NL> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . ds = [ i for i in range ( n ) ] <NEWLINE> self . root = [ i for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> def find_root ( self , x ) : <NEWLINE> <INDENT> if x != self . root [ x ] : <NEWLINE> <INDENT> self . root [ x ] = self . find_root ( self . root [ x ] ) <NEWLINE> <NL> <DEDENT> return self . root [ x ] <NEWLINE> <NL> <DEDENT> def is_same ( self , x , y ) : <NEWLINE> <INDENT> return self . find_root ( x ) == self . find_root ( y ) <NEWLINE> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> p = self . find_root ( x ) <NEWLINE> q = self . find_root ( y ) <NEWLINE> self . root [ p ] = q <NEWLINE> <NL> <DEDENT> <DEDENT> def debug ( x , table ) : <NEWLINE> <INDENT> for name , val in table . items ( ) : <NEWLINE> <INDENT> if x is val : <NEWLINE> <INDENT> print ( <STRING> . format ( name , val ) , file = sys . stderr ) <NEWLINE> return None <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
from functools import reduce , lru_cache <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> N , a , b , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> c = reduce ( lambda a , b : a ^ b , A , 0 ) <NEWLINE> <NL> @ lru_cache ( None ) <NEWLINE> def solve ( a , b , c ) : <NEWLINE> <INDENT> if ( a % 2 ) ^ ( b % 2 ) != ( c % 2 ) : <NEWLINE> <INDENT> return INF <NEWLINE> <DEDENT> if c == 0 : <NEWLINE> <INDENT> return INF if a < b else ( a - b ) // 2 <NEWLINE> <NL> <DEDENT> return min ( <NEWLINE> <INDENT> 2 * solve ( a // 2 , b // 2 , c // 2 ) , <NEWLINE> 1 + 2 * solve ( ( a - 1 ) // 2 , ( b + 1 ) // 2 , c // 2 ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> print ( - 1 if ( res : = solve ( a , b , c ) ) >= a else res ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> res = sum ( [ math . gcd ( math . gcd ( a , b ) , c ) for a in range ( 1 , K + 1 ) for b in range ( 1 , K + 1 ) for c in range ( 1 , K + 1 ) ] ) <NEWLINE> print ( res ) <NEWLINE>
import sys <NEWLINE> import operator <NEWLINE> from itertools import repeat <NEWLINE> from functools import partial , reduce <NEWLINE> from typing import Iterable , Tuple , Union <NEWLINE> <NL> Indices = Union [ int , slice , Tuple [ Union [ int , slice ] ] ] <NEWLINE> <NL> ndgetter = ( <NEWLINE> <INDENT> lambda a , i : a , <NEWLINE> lambda a , i : a [ i [ 0 ] ] , <NEWLINE> lambda a , i : a [ i [ 0 ] ] [ i [ 1 ] ] , <NEWLINE> lambda a , i : a [ i [ 0 ] ] [ i [ 1 ] ] [ i [ 2 ] ] , <NEWLINE> lambda a , i : a [ i [ 0 ] ] [ i [ 1 ] ] [ i [ 2 ] ] [ i [ 3 ] ] , <NEWLINE> lambda a , i : a [ i [ 0 ] ] [ i [ 1 ] ] [ i [ 2 ] ] [ i [ 3 ] ] [ i [ 4 ] ] , <NEWLINE> lambda a , i : a [ i [ 0 ] ] [ i [ 1 ] ] [ i [ 2 ] ] [ i [ 3 ] ] [ i [ 4 ] ] [ i [ 5 ] ] , <NEWLINE> lambda a , i : a [ i [ 0 ] ] [ i [ 1 ] ] [ i [ 2 ] ] [ i [ 3 ] ] [ i [ 4 ] ] [ i [ 5 ] ] [ i [ 6 ] ] , <NEWLINE> lambda a , i : a [ i [ 0 ] ] [ i [ 1 ] ] [ i [ 2 ] ] [ i [ 3 ] ] [ i [ 4 ] ] [ i [ 5 ] ] [ i [ 6 ] ] [ i [ 7 ] ] , <NEWLINE> lambda a , i : a [ i [ 0 ] ] [ i [ 1 ] ] [ i [ 2 ] ] [ i [ 3 ] ] [ i [ 4 ] ] [ i [ 5 ] ] [ i [ 6 ] ] [ i [ 7 ] ] [ i [ 8 ] ] , <NEWLINE> lambda a , i : a [ i [ 0 ] ] [ i [ 1 ] ] [ i [ 2 ] ] [ i [ 3 ] ] [ i [ 4 ] ] [ i [ 5 ] ] [ i [ 6 ] ] [ i [ 7 ] ] [ i [ 8 ] ] [ i [ 9 ] ] , <NEWLINE> <DEDENT> ) <NEWLINE> <NL> class nd ( list ) : <NEWLINE> <INDENT> def at ( self , indices : Tuple [ int ] ) : <NEWLINE> <INDENT> return ndgetter [ len ( indices ) ] ( self , indices ) <NEWLINE> <NL> <DEDENT> def set_at ( self , indices : Tuple [ int ] , value ) : <NEWLINE> <INDENT> ndgetter [ len ( indices ) - 1 ] ( self , indices [ : - 1 ] ) [ indices [ - 1 ] ] = value <NEWLINE> <NL> <DEDENT> def fill ( self , value ) : <NEWLINE> <INDENT> for i in range ( len ( self ) ) : <NEWLINE> <INDENT> element = super ( ) . __getitem__ ( i ) <NEWLINE> if isinstance ( element , nd ) : <NEWLINE> <INDENT> element . apply_inplace ( value ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> super ( ) . __setitem__ ( i , value ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def apply ( self , func ) : <NEWLINE> <INDENT> return type ( self ) ( <NEWLINE> <INDENT> ( <NEWLINE> <INDENT> element . apply ( func ) <NEWLINE> if isinstance ( element , nd ) <NEWLINE> else func ( element ) <NEWLINE> <DEDENT> ) <NEWLINE> for element in self <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> def apply_inplace ( self , func ) : <NEWLINE> <INDENT> for i in range ( len ( self ) ) : <NEWLINE> <INDENT> element = super ( ) . __getitem__ ( i ) <NEWLINE> if isinstance ( element , nd ) : <NEWLINE> <INDENT> element . apply_inplace ( func ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> super ( ) . __setitem__ ( i , func ( element ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def operate ( self , other , operator ) : <NEWLINE> <INDENT> if not isinstance ( other , list ) : <NEWLINE> <INDENT> other = repeat ( other ) <NEWLINE> <DEDENT> return type ( self ) ( <NEWLINE> <INDENT> ( <NEWLINE> <INDENT> element . operate ( other_element , operator ) <NEWLINE> if isinstance ( element , nd ) <NEWLINE> else operator ( element , other_element ) <NEWLINE> <DEDENT> ) <NEWLINE> for element , other_element in zip ( self , other ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> def roperate ( self , other , operator ) : <NEWLINE> <INDENT> if not isinstance ( other , list ) : <NEWLINE> <INDENT> other = repeat ( other ) <NEWLINE> <DEDENT> return type ( self ) ( <NEWLINE> <INDENT> ( <NEWLINE> <INDENT> element . roperate ( other_element , operator ) <NEWLINE> if isinstance ( element , nd ) <NEWLINE> else operator ( other_element , element ) <NEWLINE> <DEDENT> ) <NEWLINE> for element , other_element in zip ( self , other ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> def ioperate ( self , other , operator ) : <NEWLINE> <INDENT> if not isinstance ( other , list ) : <NEWLINE> <INDENT> other = repeat ( other ) <NEWLINE> <DEDENT> for i , ( element , other_element ) in enumerate ( zip ( self , other ) ) : <NEWLINE> <INDENT> if isinstance ( element , nd ) : <NEWLINE> <INDENT> element . ioperate ( other_element , operator ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> super ( ) . __setitem__ ( i , operator ( element , other_element ) ) <NEWLINE> <DEDENT> <DEDENT> return self <NEWLINE> <DEDENT> def rioperate ( self , other , operator ) : <NEWLINE> <INDENT> if not isinstance ( other , list ) : <NEWLINE> <INDENT> other = repeat ( other ) <NEWLINE> <DEDENT> for i , ( element , other_element ) in enumerate ( zip ( self , other ) ) : <NEWLINE> <INDENT> if isinstance ( element , nd ) : <NEWLINE> <INDENT> element . rioperate ( other_element , operator ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> super ( ) . __setitem__ ( i , operator ( other_element , element ) ) <NEWLINE> <DEDENT> <DEDENT> return self <NEWLINE> <DEDENT> def __add__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . add ) <NEWLINE> <DEDENT> def __radd__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . add ) <NEWLINE> <DEDENT> def __iadd__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . add ) <NEWLINE> <DEDENT> def __sub__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . sub ) <NEWLINE> <DEDENT> def __rsub__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . sub ) <NEWLINE> <DEDENT> def __isub__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . sub ) <NEWLINE> <DEDENT> def __mul__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . mul ) <NEWLINE> <DEDENT> def __rmul__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . mul ) <NEWLINE> <DEDENT> def __imul__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . mul ) <NEWLINE> <DEDENT> def __matmul__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . matmul ) <NEWLINE> <DEDENT> def __rmatmul__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . matmul ) <NEWLINE> <DEDENT> def __imatmul__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . matmul ) <NEWLINE> <DEDENT> def __truediv__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . truediv ) <NEWLINE> <DEDENT> def __rtruediv__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . truediv ) <NEWLINE> <DEDENT> def __itruediv__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . truediv ) <NEWLINE> <DEDENT> def __floordiv__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . floordiv ) <NEWLINE> <DEDENT> def __rfloordiv__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . floordiv ) <NEWLINE> <DEDENT> def __ifloordiv__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . floordiv ) <NEWLINE> <DEDENT> def __mod__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . mod ) <NEWLINE> <DEDENT> def __rmod__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . mod ) <NEWLINE> <DEDENT> def __imod__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . mod ) <NEWLINE> <DEDENT> def __divmod__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . divmod ) <NEWLINE> <DEDENT> def __rdivmod__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . divmod ) <NEWLINE> <DEDENT> def __idivmod__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . divmod ) <NEWLINE> <DEDENT> def __pow__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . pow ) <NEWLINE> <DEDENT> def __rpow__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . pow ) <NEWLINE> <DEDENT> def __ipow__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . pow ) <NEWLINE> <DEDENT> def __lshift__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . lshift ) <NEWLINE> <DEDENT> def __rlshift__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . lshift ) <NEWLINE> <DEDENT> def __ilshift__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . lshift ) <NEWLINE> <DEDENT> def __rshift__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . rshift ) <NEWLINE> <DEDENT> def __rrshift__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . rshift ) <NEWLINE> <DEDENT> def __irshift__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . rshift ) <NEWLINE> <DEDENT> def __and__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . and_ ) <NEWLINE> <DEDENT> def __rand__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . and_ ) <NEWLINE> <DEDENT> def __iand__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . and_ ) <NEWLINE> <DEDENT> def __xor__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . xor ) <NEWLINE> <DEDENT> def __rxor__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . xor ) <NEWLINE> <DEDENT> def __ixor__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . xor ) <NEWLINE> <DEDENT> def __or__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . or_ ) <NEWLINE> <DEDENT> def __ror__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . or_ ) <NEWLINE> <DEDENT> def __ior__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . or_ ) <NEWLINE> <DEDENT> def __neg__ ( self , other ) : <NEWLINE> <INDENT> return self . apply ( other , operator . neg ) <NEWLINE> <DEDENT> def __pos__ ( self , other ) : <NEWLINE> <INDENT> return self . apply ( other , operator . pos ) <NEWLINE> <DEDENT> def __abs__ ( self , other ) : <NEWLINE> <INDENT> return self . apply ( other , operator . abs ) <NEWLINE> <DEDENT> def __invert__ ( self , other ) : <NEWLINE> <INDENT> return self . apply ( other , operator . invert ) <NEWLINE> <DEDENT> def __lt__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . lt ) <NEWLINE> <DEDENT> def __le__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . le ) <NEWLINE> <DEDENT> def __eq__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . eq ) <NEWLINE> <DEDENT> def __ne__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . ne ) <NEWLINE> <DEDENT> def __gt__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . gt ) <NEWLINE> <DEDENT> def __ge__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . ge ) <NEWLINE> <NL> <DEDENT> @ classmethod <NEWLINE> def full ( cls , fill_value , shape : Union [ int , Tuple [ int ] , Iterable [ int ] ] ) : <NEWLINE> <INDENT> if isinstance ( shape , int ) : <NEWLINE> <INDENT> return cls ( repeat ( fill_value , shape ) ) <NEWLINE> <DEDENT> elif not isinstance ( shape , tuple ) : <NEWLINE> <INDENT> shape = tuple ( shape ) <NEWLINE> <NL> <DEDENT> if len ( shape ) == 1 : <NEWLINE> <INDENT> return cls ( repeat ( fill_value , shape [ 0 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return cls ( <NEWLINE> <INDENT> map ( <NEWLINE> <INDENT> partial ( cls . full , fill_value ) , <NEWLINE> repeat ( shape [ 1 : ] , shape [ 0 ] ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> <DEDENT> @ classmethod <NEWLINE> def fromiter ( cls , iterable , ndim = 1 ) : <NEWLINE> <INDENT> if ndim == 1 : <NEWLINE> <INDENT> return cls ( iterable ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return cls ( <NEWLINE> <INDENT> cls . fromiter ( element , ndim - 1 ) <NEWLINE> for element in iterable <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> <DEDENT> @ classmethod <NEWLINE> def nones ( cls , shape : Union [ int , Tuple [ int ] , Iterable [ int ] ] ) : <NEWLINE> <INDENT> return cls . full ( None , shape ) <NEWLINE> <NL> <DEDENT> @ classmethod <NEWLINE> def zeros ( cls , shape : Union [ int , Tuple [ int ] , Iterable [ int ] ] , type = int ) : <NEWLINE> <INDENT> return cls . full ( type ( 0 ) , shape ) <NEWLINE> <NL> <DEDENT> @ classmethod <NEWLINE> def ones ( cls , shape : Union [ int , Tuple [ int ] , Iterable [ int ] ] , type = int ) : <NEWLINE> <INDENT> return cls . full ( type ( 1 ) , shape ) <NEWLINE> <NL> <DEDENT> @ classmethod <NEWLINE> def partial_map ( cls , func , * left_args , ** left_kwargs ) : <NEWLINE> <INDENT> def nd_func ( a , * right_args , ** right_kwargs ) : <NEWLINE> <INDENT> return cls . fromiter ( <NEWLINE> <INDENT> func ( * left_args , v , * right_args , ** left_kwargs , ** right_kwargs ) <NEWLINE> for v in a <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> return nd_func <NEWLINE> <NL> <DEDENT> @ classmethod <NEWLINE> def vectorize ( cls , func , * left_args , ** left_kwargs ) : <NEWLINE> <INDENT> def nd_func ( a : nd , * right_args , ** right_kwargs ) : <NEWLINE> <INDENT> return a . apply ( lambda v : func ( <NEWLINE> <INDENT> * left_args , v , * right_args , ** left_kwargs , ** right_kwargs <NEWLINE> <DEDENT> ) ) <NEWLINE> <DEDENT> return nd_func <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def bytes_to_str ( x : bytes ) : <NEWLINE> <INDENT> return x . decode ( <STRING> ) <NEWLINE> <NL> <DEDENT> def inputs ( func = bytes_to_str , sep = None , maxsplit = - 1 ) : <NEWLINE> <INDENT> return map ( func , sys . stdin . buffer . readline ( ) . split ( sep = sep , maxsplit = maxsplit ) ) <NEWLINE> <NL> <DEDENT> def inputs_1d ( func = bytes_to_str , ** kwargs ) : <NEWLINE> <INDENT> return nd ( inputs ( func , ** kwargs ) ) <NEWLINE> <NL> <DEDENT> def inputs_2d ( nrows : int , func = bytes_to_str , ** kwargs ) : <NEWLINE> <INDENT> return nd . fromiter ( <NEWLINE> <INDENT> ( inputs ( func , ** kwargs ) for _ in range ( nrows ) ) , <NEWLINE> ndim = 2 <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> def inputs_2d_T ( nrows : int , func = bytes_to_str , ** kwargs ) : <NEWLINE> <INDENT> return nd . fromiter ( <NEWLINE> <INDENT> zip ( * ( inputs ( func , ** kwargs ) for _ in range ( nrows ) ) ) , <NEWLINE> ndim = 2 <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> import operator <NEWLINE> from typing import Optional <NEWLINE> <NL> <NL> class BreadthFirstSearch ( object ) : <NEWLINE> <INDENT> def __init__ ( self , shape : Tuple [ int ] ) : <NEWLINE> <INDENT> self . shape = shape <NEWLINE> self . pushed = nd . zeros ( shape , type = bool ) <NEWLINE> self . _deque = deque ( ) <NEWLINE> <NL> <DEDENT> def push ( self , position : Tuple [ int ] ) : <NEWLINE> <INDENT> if not self . pushed . at ( position ) : <NEWLINE> <INDENT> self . pushed . set_at ( position , True ) <NEWLINE> self . _deque . append ( position ) <NEWLINE> <NL> <DEDENT> <DEDENT> def peek ( self ) -> Optional [ Tuple [ int ] ] : <NEWLINE> <INDENT> return self . _deque [ 0 ] if self . _deque else None <NEWLINE> <NL> <DEDENT> def pop ( self ) -> Optional [ Tuple [ int ] ] : <NEWLINE> <INDENT> return self . _deque . popleft ( ) if self . _deque else None <NEWLINE> <NL> <DEDENT> def __bool__ ( self ) : <NEWLINE> <INDENT> return bool ( self . _deque ) <NEWLINE> <NL> <DEDENT> <DEDENT> from bisect import bisect_left , bisect_right <NEWLINE> <NL> <NL> N , M = inputs ( int ) <NEWLINE> A , B , C = inputs_2d_T ( N , int ) <NEWLINE> D , E , F = inputs_2d_T ( M , int ) <NEWLINE> xs = sorted ( set ( C ) ) <NEWLINE> ys = sorted ( set ( D ) ) <NEWLINE> <NL> x_guard = nd . zeros ( ( len ( xs ) + 1 , len ( ys ) + 1 ) , type = bool ) <NEWLINE> y_guard = nd . zeros ( ( len ( xs ) + 1 , len ( ys ) + 1 ) , type = bool ) <NEWLINE> <NL> C = nd . partial_map ( bisect_right , xs ) ( C ) <NEWLINE> A = nd . partial_map ( bisect_left , ys ) ( A ) <NEWLINE> A += 1 <NEWLINE> B = nd . partial_map ( bisect_right , ys ) ( B ) <NEWLINE> <NL> D = nd . partial_map ( bisect_right , ys ) ( D ) <NEWLINE> E = nd . partial_map ( bisect_left , xs ) ( E ) <NEWLINE> E += 1 <NEWLINE> F = nd . partial_map ( bisect_right , xs ) ( F ) <NEWLINE> <NL> for a , b , c in zip ( A , B , C ) : <NEWLINE> <INDENT> for y in range ( a , b ) : <NEWLINE> <INDENT> x_guard [ c ] [ y ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> for d , e , f in zip ( D , E , F ) : <NEWLINE> <INDENT> for x in range ( e , f ) : <NEWLINE> <INDENT> y_guard [ x ] [ d ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> cow = ( <NEWLINE> <INDENT> bisect_right ( xs , 0 ) , <NEWLINE> bisect_right ( ys , 0 ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> bfs = BreadthFirstSearch ( shape = ( len ( xs ) + 1 , len ( ys ) + 1 ) ) <NEWLINE> bfs . push ( cow ) <NEWLINE> <NL> area = 0 <NEWLINE> while bfs : <NEWLINE> <INDENT> xi , yi = bfs . pop ( ) <NEWLINE> <NL> if 0 < xi < len ( xs ) and 0 < yi < len ( ys ) : <NEWLINE> <INDENT> area += ( xs [ xi ] - xs [ xi - 1 ] ) * ( ys [ yi ] - ys [ yi - 1 ] ) <NEWLINE> if not x_guard [ xi ] [ yi ] : <NEWLINE> <INDENT> bfs . push ( ( xi - 1 , yi ) ) <NEWLINE> <DEDENT> if not x_guard [ xi + 1 ] [ yi ] : <NEWLINE> <INDENT> bfs . push ( ( xi + 1 , yi ) ) <NEWLINE> <DEDENT> if not y_guard [ xi ] [ yi ] : <NEWLINE> <INDENT> bfs . push ( ( xi , yi - 1 ) ) <NEWLINE> <DEDENT> if not y_guard [ xi ] [ yi + 1 ] : <NEWLINE> <INDENT> bfs . push ( ( xi , yi + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> area = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( area ) <NEWLINE> <NL>
def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> a = make_divisors ( i ) <NEWLINE> <COMMENT> <NL> d_count = len ( a ) <NEWLINE> <COMMENT> <NL> if d_count == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> flg = 0 <NEWLINE> for c in range ( 1 , N ) : <NEWLINE> <INDENT> flg += ( N - 1 ) // c <NEWLINE> <NL> <DEDENT> print ( flg ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 + 2 * 10 ** 5 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> color = [ None ] * ( n + 1 ) <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> color [ i ] = i <NEWLINE> <NL> <DEDENT> def root ( x ) : <NEWLINE> <INDENT> global color <NEWLINE> <NL> if color [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> color [ x ] = root ( color [ x ] ) <NEWLINE> return color [ x ] <NEWLINE> <NL> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> rx = root ( x ) <NEWLINE> ry = root ( y ) <NEWLINE> if rx == ry : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> color [ rx ] = ry <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> unite ( a , b ) <NEWLINE> <NL> <DEDENT> cnt = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cnt [ root ( i + 1 ) ] += 1 <NEWLINE> <DEDENT> print ( max ( cnt . values ( ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> S = list ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> check = [ 0 ] * 2019 <NEWLINE> ten = 1 <NEWLINE> mod = 1 <NEWLINE> check [ mod ] += 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> mod = ( mod + int ( S [ N - i - 1 ] ) * ten ) % 2019 <NEWLINE> ten = ( ten * 10 ) % 2019 <NEWLINE> check [ mod ] += 1 <NEWLINE> <DEDENT> answer = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> answer += ( ( check [ i ] - 1 ) * check [ i ] ) // 2 <NEWLINE> <DEDENT> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import math <NEWLINE> <NL> <NL> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = [ np . asarray ( list ( map ( int , input ( ) . split ( ) ) ) ) for _ in range ( n ) ] <NEWLINE> lis = np . array ( lis ) <NEWLINE> <NL> res = [ ] <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> t = np . array ( [ 0 ] * ( m + 1 ) ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> t += lis [ j ] <NEWLINE> <DEDENT> <DEDENT> res . append ( t ) <NEWLINE> <NL> <DEDENT> res = np . array ( res ) <NEWLINE> <NL> z = math . inf <NEWLINE> <NL> for i in res : <NEWLINE> <INDENT> if np . amin ( i [ 1 : ] ) >= x and i [ 0 ] < z : <NEWLINE> <INDENT> z = i [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( z if z != math . inf else - 1 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> Jump = [ None ] * n <NEWLINE> Jump [ 0 ] = 1 <NEWLINE> Rireki = [ - 1 ] * ( n + 1 ) <NEWLINE> Rireki [ 0 ] = 0 <NEWLINE> next = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> to = A [ next ] <NEWLINE> <NL> if Rireki [ to ] >= 0 : <NEWLINE> <INDENT> start = Jump . index ( to ) <NEWLINE> end = i <NEWLINE> dis = end - start <NEWLINE> <NL> roop = ( k - start ) % dis <NEWLINE> print ( Jump [ start + roop ] ) <NEWLINE> break <NEWLINE> <DEDENT> Rireki [ to ] = i <NEWLINE> Jump [ i ] = to <NEWLINE> next = to - 1 <NEWLINE> if i == k : <NEWLINE> <INDENT> print ( to ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n , x = map ( int , [ _ for _ in input ( ) . split ( ) ] ) <NEWLINE> cnt = 0 <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for n1 in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for n2 in range ( n1 + 1 , n + 1 ) : <NEWLINE> <INDENT> for n3 in range ( n2 + 1 , n + 1 ) : <NEWLINE> <INDENT> if n1 != n2 and n2 != n3 and n3 != n1 : <NEWLINE> <INDENT> if n1 + n2 + n3 == x : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> INF = 10e17 <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> for a in A : <NEWLINE> <INDENT> ans = ans * a <NEWLINE> if ans > INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = [ int ( input ( ) ) for i in range ( 2 ) ] <NEWLINE> print ( i [ 0 ] + i [ 1 ] ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> par = [ - 1 ] * ( n + 1 ) <NEWLINE> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <COMMENT> <NEWLINE> return par [ x ] <NEWLINE> <DEDENT> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> return find ( x ) == find ( y ) <NEWLINE> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if par [ x ] > par [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> par [ x ] += par [ y ] <NEWLINE> par [ y ] = x <NEWLINE> <DEDENT> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> return - par [ find ( x ) ] <NEWLINE> <DEDENT> g = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> b = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> unite ( s , t ) <NEWLINE> g [ s ] . append ( t ) <NEWLINE> g [ t ] . append ( s ) <NEWLINE> <DEDENT> for _ in range ( k ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> b [ s ] . append ( t ) <NEWLINE> b [ t ] . append ( s ) <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans = size ( i ) - 1 - len ( g [ i ] ) <NEWLINE> for e in b [ i ] : <NEWLINE> <INDENT> if same ( i , e ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans , end = <STRING> ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> file_input = sys . stdin <NEWLINE> while True : <NEWLINE> <INDENT> N , Q = map ( int , file_input . readline ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> parent = [ None , None ] <NEWLINE> parent += [ int ( file_input . readline ( ) ) for _ in range ( N - 1 ) ] <NEWLINE> unmarked = [ True ] * ( N + 1 ) <NEWLINE> unmarked [ 1 ] = False <NEWLINE> ans = 0 <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> line = file_input . readline ( ) <NEWLINE> v = int ( line [ 2 : ] ) <NEWLINE> if line [ 0 ] == <STRING> : <NEWLINE> <INDENT> unmarked [ v ] = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while unmarked [ v ] : <NEWLINE> <INDENT> v = parent [ v ] <NEWLINE> <DEDENT> ans += v <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
h_numbers = [ ] <NEWLINE> w_numbers = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> numbers = [ ] <NEWLINE> numbers = input ( ) . split ( ) <NEWLINE> numbers [ 0 ] = int ( numbers [ 0 ] ) <NEWLINE> numbers [ 1 ] = int ( numbers [ 1 ] ) <NEWLINE> if numbers [ 0 ] == 0 and numbers [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> h_numbers . append ( numbers [ 0 ] ) <NEWLINE> w_numbers . append ( numbers [ 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( 0 , len ( h_numbers ) ) : <NEWLINE> <INDENT> for j in range ( 0 , h_numbers [ i ] ) : <NEWLINE> <INDENT> if j == 0 or j == ( h_numbers [ i ] - 1 ) : <NEWLINE> <INDENT> print ( <STRING> * w_numbers [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % ( ( w_numbers [ i ] - 2 ) * <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> <NL> N , M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> H = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> NG = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = [ int ( j ) for j in input ( ) . split ( ) ] <NEWLINE> if H [ a - 1 ] < H [ b - 1 ] : <NEWLINE> <INDENT> NG . append ( a ) <NEWLINE> <DEDENT> elif H [ a - 1 ] > H [ b - 1 ] : <NEWLINE> <INDENT> NG . append ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> NG . append ( a ) <NEWLINE> NG . append ( b ) <NEWLINE> <DEDENT> <DEDENT> NG = set ( NG ) <NEWLINE> <COMMENT> <NL> print ( N - len ( NG ) ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in uf . roots ( ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> sys . setrecursionlimit ( 1000000000 ) <NEWLINE> from heapq import heapify , heappop , heappush , heappushpop <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import copy <NEWLINE> import bisect <NEWLINE> INF = 10 ** 18 <NEWLINE> def judge ( li_tate , li_yoko , li2 ) : <NEWLINE> <INDENT> for i in range ( len ( li_tate ) ) : <NEWLINE> <INDENT> if li_tate [ i ] : <NEWLINE> <INDENT> for j in range ( len ( li2 [ i ] ) ) : <NEWLINE> <INDENT> li2 [ i ] [ j ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( li_yoko ) ) : <NEWLINE> <INDENT> if li_yoko [ i ] : <NEWLINE> <INDENT> for j in range ( h ) : <NEWLINE> <INDENT> li2 [ j ] [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in range ( len ( li_tate ) ) : <NEWLINE> <INDENT> for j in range ( len ( li_yoko ) ) : <NEWLINE> <INDENT> if li2 [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> li . append ( s ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2 ** h ) : <NEWLINE> <INDENT> li_tate = [ False ] * ( h ) <NEWLINE> for j in range ( h ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> li_tate [ h - j - 1 ] = True <NEWLINE> <DEDENT> <DEDENT> for j in range ( 2 ** w ) : <NEWLINE> <INDENT> li_yoko = [ False ] * ( w ) <NEWLINE> for l in range ( w ) : <NEWLINE> <INDENT> if ( j >> l ) & 1 : <NEWLINE> <INDENT> li_yoko [ w - l - 1 ] = True <NEWLINE> <DEDENT> <DEDENT> li2 = copy . deepcopy ( li ) <NEWLINE> a = judge ( li_tate , li_yoko , li2 ) <NEWLINE> if a == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> a = math . gcd ( j , k ) <NEWLINE> for l in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( a , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def solve ( N , K , A ) : <NEWLINE> <INDENT> idx = [ - 1 for _ in range ( len ( A ) ) ] <NEWLINE> now = 0 <NEWLINE> period = 0 <NEWLINE> bias = 0 <NEWLINE> tmp = [ ] <NEWLINE> found = False <NEWLINE> i = 0 <NEWLINE> while not found : <NEWLINE> <INDENT> tmp . append ( now + 1 ) <NEWLINE> if idx [ now ] == - 1 : <NEWLINE> <INDENT> idx [ now ] = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> period = i - idx [ now ] <NEWLINE> cycle = tmp [ - period - 1 : - 1 ] <NEWLINE> bias = i - period <NEWLINE> break <NEWLINE> <DEDENT> now = A [ now ] - 1 <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> if K <= bias : <NEWLINE> <INDENT> now = 0 <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> now = A [ now ] - 1 <NEWLINE> <DEDENT> print ( now + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= bias <NEWLINE> K = K % period <NEWLINE> print ( cycle [ K ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , K = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> solve ( N , K , A ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> file_input = sys . stdin <NEWLINE> <NL> NM = file_input . readline ( ) <NEWLINE> <NL> import itertools , bisect <NEWLINE> <NL> while NM != <STRING> : <NEWLINE> <INDENT> N , M = map ( int , NM . split ( ) ) <NEWLINE> P = [ int ( file_input . readline ( ) ) for i in range ( N ) ] <NEWLINE> P . append ( 0 ) <NEWLINE> scores = map ( sum , itertools . combinations_with_replacement ( P , 2 ) ) <NEWLINE> scores = list ( set ( scores ) ) <NEWLINE> scores . sort ( ) <NEWLINE> ans = [ ] <NEWLINE> for s1 in scores : <NEWLINE> <INDENT> rest = M - s1 <NEWLINE> i = bisect . bisect_right ( scores , rest ) <NEWLINE> if i : <NEWLINE> <INDENT> ans . append ( s1 + scores [ i - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE> NM = file_input . readline ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> c = s . count <NEWLINE> a = c ( <STRING> ) * c ( <STRING> ) * c ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 2 , n , 2 ) : <NEWLINE> <INDENT> if s [ i ] != s [ i + j >> 1 ] != s [ j ] != s [ i ] : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> num = 0 <NEWLINE> cnt = [ 0 ] * 2019 <NEWLINE> cnt [ 0 ] = 1 <NEWLINE> d = 1 <NEWLINE> <COMMENT> <NL> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> num += int ( S [ i ] ) * d <NEWLINE> num %= 2019 <NEWLINE> <COMMENT> <NL> cnt [ num ] += 1 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for c in cnt : <NEWLINE> <INDENT> ans += c * ( c - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = sorted ( [ ( val , pos ) for pos , val in enumerate ( A ) ] , reverse = True ) <NEWLINE> <NL> dp = [ 0 ] <NEWLINE> for i , ( val , pos ) in enumerate ( A ) : <NEWLINE> <INDENT> ldp = [ e + val * abs ( pos - ( i - r ) ) for r , e in enumerate ( dp ) ] <NEWLINE> rdp = [ e + val * abs ( N - 1 - r - pos ) for r , e in enumerate ( dp ) ] <NEWLINE> dp = [ max ( L , R ) for L , R in zip ( ldp + [ 0 ] , [ 0 ] + rdp ) ] <NEWLINE> <NL> <DEDENT> print ( max ( dp ) ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> print ( s ) <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> <NL> ans = math . floor ( ( a * x ) / b ) - a * ( math . floor ( x / b ) ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
def fx ( n ) : <NEWLINE> <INDENT> s = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , 10000 ) : <NEWLINE> <INDENT> if ( i + 1 + 1 ) ** 2 - i * 1 - 1 * 1 - 1 * i > n : break <NEWLINE> for j in range ( 1 , 10000 ) : <NEWLINE> <INDENT> if ( 1 + j + 1 ) ** 2 - 1 * j - j * 1 - 1 * 1 > n : break <NEWLINE> for k in range ( 1 , 10000 ) : <NEWLINE> <INDENT> if ( 1 + 1 + k ) ** 2 - 1 * 1 - 1 * k - k * 1 > n : break <NEWLINE> formula = ( i + j + k ) ** 2 - i * j - j * k - k * i <NEWLINE> if formula <= n and formula > 0 : <NEWLINE> <INDENT> s [ formula ] += 1 <NEWLINE> <DEDENT> if formula >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return s <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> s = fx ( n ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> * V , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> from collections import * <NEWLINE> C1 = Counter ( V [ : : 2 ] ) <NEWLINE> C1 = sorted ( C1 . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> C2 = Counter ( V [ 1 : : 2 ] ) <NEWLINE> C2 = sorted ( C2 . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> K1 = C1 [ - 1 ] [ 0 ] <NEWLINE> V1 = C1 [ - 1 ] [ 1 ] <NEWLINE> K2 = C2 [ - 1 ] [ 0 ] <NEWLINE> V2 = C2 [ - 1 ] [ 1 ] <NEWLINE> if V1 > V2 : <NEWLINE> <INDENT> if K1 == K2 : <NEWLINE> <INDENT> V2 = C2 [ - 2 ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> elif V2 > V1 : <NEWLINE> <INDENT> if K1 == K2 : <NEWLINE> <INDENT> V1 = C1 [ - 2 ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if K1 == K2 : <NEWLINE> <INDENT> if len ( set ( V ) ) == 1 : <NEWLINE> <INDENT> V2 = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> V2 = max ( C1 [ - 2 ] [ 1 ] , C2 [ - 2 ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( N - V1 - V2 ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> sevens = 0 <NEWLINE> count = 0 <NEWLINE> repeat = True <NEWLINE> <NL> if { K % 10 } & { 0 , 2 , 4 , 5 , 6 , 8 } : <NEWLINE> <INDENT> count = - 1 <NEWLINE> repeat = False <NEWLINE> <NL> <DEDENT> while repeat : <NEWLINE> <INDENT> sevens = sevens % K * 10 + 7 <NEWLINE> count += 1 <NEWLINE> if sevens % K == 0 : <NEWLINE> <INDENT> repeat = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( 10 ) : <NEWLINE> <INDENT> a = S . find ( str ( i ) ) <NEWLINE> if a == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> b = S . find ( str ( j ) , a + 1 ) <NEWLINE> if b == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> if S . find ( str ( k ) , b + 1 ) != - 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cum = [ 0 ] + list ( itertools . accumulate ( a ) ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans += a [ i ] * cum [ i ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
x = 10 ** 18 <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > x : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <NL> def check_condition ( S ) : <NEWLINE> <INDENT> N = len ( S ) <NEWLINE> ind = np . where ( S == <STRING> ) [ 0 ] <NEWLINE> if len ( ind ) == 0 or len ( ind ) == N : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> if np . max ( ind ) == len ( ind ) - 1 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def alter ( S ) : <NEWLINE> <INDENT> if check_condition ( S ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> ind = np . where ( S == <STRING> ) [ 0 ] <NEWLINE> num_r = len ( ind ) <NEWLINE> num_offset = np . sum ( ind > num_r - 1 ) <NEWLINE> return num_offset <NEWLINE> <NL> <DEDENT> S = np . array ( list ( S ) ) <NEWLINE> print ( alter ( S ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> count = 0 <NEWLINE> <NL> if <STRING> in c : <NEWLINE> <INDENT> x = c . count ( <STRING> ) <NEWLINE> y = c . count ( <STRING> , 0 , x ) <NEWLINE> count = x - y <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> . format ( math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ) ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> R , G , B , N = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> ans = [ ] <NEWLINE> <NL> r , g , b = 0 , 0 , 0 <NEWLINE> cnt = 0 <NEWLINE> <NL> max_r = N // R <NEWLINE> for r in range ( max_r + 1 ) : <NEWLINE> <INDENT> if R * r > N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> max_g = ( N - R * r ) // G <NEWLINE> <NL> for g in range ( max_g + 1 ) : <NEWLINE> <INDENT> if R * r + G * g > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x = ( N - ( R * r + G * g ) ) <NEWLINE> if x % B == 0 and x >= 0 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> cnt += 1 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> prod = 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> j = 0 <NEWLINE> for i in range ( k , n ) : <NEWLINE> <NL> <INDENT> if a [ i ] > a [ j ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> j += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> % ( r * r * math . pi ) , <STRING> % ( 2 * r * math . pi ) ) <NEWLINE>
import sys <NEWLINE> stdin = sys . stdin <NEWLINE> <NL> ns = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> ni = lambda : int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> nm = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> A , B , C , K = nm ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> ans += min ( A , K ) <NEWLINE> K -= min ( A , K ) <NEWLINE> <NL> if ( K > 0 ) : <NEWLINE> <INDENT> K -= min ( B , K ) <NEWLINE> <DEDENT> if ( K > 0 ) : <NEWLINE> <INDENT> ans -= min ( C , K ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a >= 0 and c >= 0 : <NEWLINE> <INDENT> print ( b * d ) <NEWLINE> <DEDENT> elif b <= 0 and d <= 0 : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> elif b <= 0 and c >= 0 : <NEWLINE> <INDENT> print ( b * c ) <NEWLINE> <DEDENT> elif a >= 0 and d <= 0 : <NEWLINE> <INDENT> print ( a * d ) <NEWLINE> <DEDENT> elif a <= 0 and b >= 0 and c <= 0 and d >= 0 : <NEWLINE> <INDENT> print ( max ( [ a * c , b * d ] ) ) <NEWLINE> <DEDENT> elif b <= 0 and c <= 0 and d >= 0 : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> elif a <= 0 and b >= 0 and d <= 0 : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> elif a <= 0 and b >= 0 and c >= 0 : <NEWLINE> <INDENT> print ( b * d ) <NEWLINE> <DEDENT> elif a >= 0 and c <= 0 and d >= 0 : <NEWLINE> <INDENT> print ( b * d ) <NEWLINE> <NL> <NL> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == 0 : <NEWLINE> <INDENT> lst = [ ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> nums = [ ] <NEWLINE> min_l = 1000 <NEWLINE> for i in range ( 103 ) : <NEWLINE> <INDENT> if i in lst : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> l = abs ( i - n ) <NEWLINE> if l < min_l : <NEWLINE> <INDENT> min_l = l <NEWLINE> min_num = i <NEWLINE> <DEDENT> elif l >= min_l : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( min_num ) <NEWLINE>
k , s = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> count = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - ( x + y ) <= k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> class UnionFind : <NEWLINE> <COMMENT> <NL> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . par = [ i for i in range ( n ) ] <NEWLINE> self . rank = [ 0 ] * n <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . rank [ x ] < self . rank [ y ] : <NEWLINE> <INDENT> self . par [ x ] = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ y ] = x <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ x ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , K , L = map ( int , input ( ) . split ( ) ) <NEWLINE> roads = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( K ) ] <NEWLINE> trains = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( L ) ] <NEWLINE> <NL> uf_road = UnionFind ( N ) <NEWLINE> uf_train = UnionFind ( N ) <NEWLINE> <NL> for road in roads : <NEWLINE> <INDENT> x , y = road <NEWLINE> uf_road . unite ( x - 1 , y - 1 ) <NEWLINE> <NL> <DEDENT> for train in trains : <NEWLINE> <INDENT> x , y = train <NEWLINE> uf_train . unite ( x - 1 , y - 1 ) <NEWLINE> <NL> <DEDENT> pairs = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> pairs . append ( ( uf_road . find ( i ) , uf_train . find ( i ) ) ) <NEWLINE> <NL> <DEDENT> cnt = Counter ( pairs ) <NEWLINE> <NL> ans = [ cnt [ pair ] for pair in pairs ] <NEWLINE> print ( * ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> sum_collection = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i , N ) : <NEWLINE> <COMMENT> <NL> <INDENT> k = j + ( j - i ) <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> if S [ i ] != S [ j ] != S [ k ] != S [ i ] : <NEWLINE> <INDENT> sum_collection -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum_collection ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> print ( <STRING> . format ( min ( a ) , max ( a ) , sum ( a ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> xyh = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y , h = map ( int , input ( ) . split ( ) ) <NEWLINE> xyh [ i ] . append ( x ) <NEWLINE> xyh [ i ] . append ( y ) <NEWLINE> xyh [ i ] . append ( h ) <NEWLINE> <DEDENT> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> f = 0 <NEWLINE> dis = [ [ i ] for i in range ( 205 ) ] <NEWLINE> for q in range ( n ) : <NEWLINE> <INDENT> x = xyh [ q ] [ 0 ] <NEWLINE> y = xyh [ q ] [ 1 ] <NEWLINE> h = xyh [ q ] [ 2 ] <NEWLINE> d = abs ( x - i ) + abs ( y - j ) <NEWLINE> <NL> if len ( dis [ d ] ) == 1 : <NEWLINE> <INDENT> dis [ d ] . append ( h ) <NEWLINE> <DEDENT> elif len ( dis [ d ] ) != 1 and dis [ d ] [ 1 ] != h : <NEWLINE> <INDENT> f = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> dis = [ dis [ e ] for e in range ( 205 ) if len ( dis [ e ] ) != 1 ] <NEWLINE> m = len ( dis ) <NEWLINE> if m == 1 and f == 0 : <NEWLINE> <INDENT> print ( i , j , dis [ 0 ] [ 0 ] + dis [ 0 ] [ 1 ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if all ( dis [ e ] [ 0 ] + dis [ e ] [ 1 ] == dis [ e + 1 ] [ 0 ] + dis [ e + 1 ] [ 1 ] for e in range ( m - 1 ) if dis [ e + 1 ] [ 1 ] != 0 ) and f == 0 : <NEWLINE> <INDENT> print ( i , j , dis [ 0 ] [ 0 ] + dis [ 0 ] [ 1 ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def pgcd ( a , b ) : <NEWLINE> <INDENT> while b != 0 : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def msum ( a , b , c ) : <NEWLINE> <INDENT> if ( a <= b ) and ( a <= c ) : <NEWLINE> <INDENT> return math . gcd ( a , math . gcd ( b , c ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> elif ( b <= a ) and ( b <= c ) : <NEWLINE> <INDENT> return ( math . gcd ( b , math . gcd ( a , c ) ) ) <NEWLINE> <DEDENT> elif ( c <= a ) and ( c <= b ) : <NEWLINE> <INDENT> return math . gcd ( c , math . gcd ( a , b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def zmek ( num ) : <NEWLINE> <INDENT> csum = 0 <NEWLINE> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , num + 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> csum += math . gcd ( i , math . gcd ( j , l ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return csum <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> print ( zmek ( K ) ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * A + B - K ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> n , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> a . append ( [ 2 ] ) <NEWLINE> <DEDENT> elif i == n : <NEWLINE> <INDENT> a . append ( [ n - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( [ i - 1 , i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> a [ x - 1 ] . append ( y ) <NEWLINE> a [ y - 1 ] . append ( x ) <NEWLINE> <NL> d = { } <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> d [ i + 1 ] = 0 <NEWLINE> <NL> <DEDENT> def solve ( s ) : <NEWLINE> <INDENT> queue = deque ( ) <NEWLINE> queue . append ( a [ s - 1 ] ) <NEWLINE> visit = set ( ) <NEWLINE> visit . add ( s ) <NEWLINE> depth = 0 <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> depth += 1 <NEWLINE> nn = queue . popleft ( ) <NEWLINE> adj = [ ] <NEWLINE> for i in nn : <NEWLINE> <INDENT> if i not in visit : <NEWLINE> <INDENT> d [ depth ] += 1 <NEWLINE> adj = adj + a [ i - 1 ] <NEWLINE> <DEDENT> visit . add ( i ) <NEWLINE> <DEDENT> if adj != [ ] : <NEWLINE> <INDENT> queue . append ( adj ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> solve ( i + 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( d [ i + 1 ] // 2 ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> box = [ ] <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( a , K + 1 ) : <NEWLINE> <INDENT> for c in range ( b , K + 1 ) : <NEWLINE> <INDENT> if a == b and b == c : <NEWLINE> <INDENT> box . append ( gcd ( a , b , c ) ) <NEWLINE> <DEDENT> elif a != b and b != c and c != a : <NEWLINE> <INDENT> box . append ( gcd ( a , b , c ) * 6 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> box . append ( gcd ( a , b , c ) * 3 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ( box ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( lambda x : x - 1 , map ( int , input ( ) . split ( ) ) ) <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> def dfs ( v , pre = - 1 ) : <NEWLINE> <INDENT> for nx in G [ v ] : <NEWLINE> <INDENT> if nx == pre : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ nx ] += ans [ v ] <NEWLINE> dfs ( nx , v ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> if d == 1 : <NEWLINE> <INDENT> a [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in tmp : <NEWLINE> <INDENT> a [ j - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import defaultdict , deque <NEWLINE> import math <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> return b if not a % b else gcd ( b , a % b ) <NEWLINE> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // gcd ( a , b ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> tmp = 0 <NEWLINE> res = [ ] <NEWLINE> ind = 0 <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> if ( a [ ind ] < a [ ind + k ] ) : <NEWLINE> <INDENT> res . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res . append ( 0 ) <NEWLINE> <DEDENT> ind += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 0 , len ( res ) ) : <NEWLINE> <INDENT> if ( res [ i ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans_list = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> A [ i - 1 ] %= m <NEWLINE> ans_list [ i ] = ( ans_list [ i - 1 ] + A [ i - 1 ] ) % m <NEWLINE> <DEDENT> ans_list . pop ( ans_list [ 0 ] ) <NEWLINE> ans_list = dict ( collections . Counter ( ans_list ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> count = 0 <NEWLINE> if 0 in ans_list : <NEWLINE> <INDENT> count = ans_list [ 0 ] <NEWLINE> <COMMENT> <NL> <DEDENT> for v in ans_list . values ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> if v != 1 : <NEWLINE> <INDENT> count += v * ( v - 1 ) / 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( count ) ) <NEWLINE> <NL> <NL>
<NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> d = set ( list ( range ( N ) ) ) <NEWLINE> <NL> v = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> if H [ S [ i ] [ 0 ] - 1 ] < H [ S [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> v . append ( S [ i ] [ 0 ] - 1 ) <NEWLINE> <DEDENT> elif H [ S [ i ] [ 0 ] - 1 ] > H [ S [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> v . append ( S [ i ] [ 1 ] - 1 ) <NEWLINE> <DEDENT> elif H [ S [ i ] [ 0 ] - 1 ] == H [ S [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> v . append ( S [ i ] [ 0 ] - 1 ) <NEWLINE> v . append ( S [ i ] [ 1 ] - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> u = set ( v ) <NEWLINE> <NL> d = d - u <NEWLINE> <NL> print ( len ( d ) ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ( ans > 1000000000000000000 ) : <NEWLINE> <INDENT> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( x ) <NEWLINE> b . append ( y ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> a [ i ] += ans <NEWLINE> mod = a [ i ] % b [ i ] <NEWLINE> if mod != 0 : <NEWLINE> <INDENT> if a [ i ] > b [ i ] : <NEWLINE> <INDENT> ans += b [ i ] - mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += b [ i ] - a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if sum ( A ) == 0 : <COMMENT> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if N % 3 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic = { } <NEWLINE> for x in A : <NEWLINE> <INDENT> if x in dic : <NEWLINE> <INDENT> dic [ x ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ x ] = 1 <NEWLINE> <DEDENT> <DEDENT> V = list ( dic . values ( ) ) <NEWLINE> if len ( V ) == 2 : <NEWLINE> <INDENT> K = list ( dic . keys ( ) ) <NEWLINE> if K [ 0 ] == 0 and dic [ K [ 1 ] ] == dic [ 0 ] * 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif K [ 1 ] == 0 and dic [ K [ 0 ] ] == dic [ 0 ] * 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> if len ( V ) != 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if V [ 0 ] == V [ 1 ] and V [ 1 ] == V [ 2 ] : <NEWLINE> <INDENT> K = list ( dic . keys ( ) ) <NEWLINE> if K [ 0 ] ^ K [ 1 ] == K [ 2 ] and K [ 1 ] ^ K [ 2 ] == K [ 0 ] and K [ 2 ] ^ K [ 0 ] == K [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> def substring ( S ) : <NEWLINE> <INDENT> N = len ( S ) <NEWLINE> ls = [ ] <NEWLINE> for i in range ( 1 , min ( 6 , N + 1 ) ) : <NEWLINE> <INDENT> for j in range ( 0 , N - i + 1 ) : <NEWLINE> <INDENT> ls . append ( S [ j : j + i ] ) <NEWLINE> <DEDENT> <DEDENT> setls = set ( ls ) <NEWLINE> ls = list ( setls ) <NEWLINE> ls . sort ( ) <NEWLINE> return ls <NEWLINE> <DEDENT> print ( substring ( s ) [ K - 1 ] ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> grid = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> visited = [ False ] * n <NEWLINE> visited [ 0 ] = True <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> grid [ s ] . append ( t ) <NEWLINE> grid [ t ] . append ( s ) <NEWLINE> <NL> <DEDENT> queue = deque ( [ 1 ] ) <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> node = queue . popleft ( ) <NEWLINE> for i in grid [ node ] : <NEWLINE> <INDENT> if visited [ i - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited [ i - 1 ] = True <NEWLINE> ans [ i - 1 ] = node <NEWLINE> queue . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in ans [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
<NL> def back_oturigation ( fee , coin_values , coin_nums ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> oturi = coin_values [ 0 ] * coin_nums [ 0 ] + coin_values [ 1 ] * coin_nums [ 1 ] + coin_values [ 2 ] * coin_nums [ 2 ] + coin_values [ 3 ] * coin_nums [ 3 ] - fee <NEWLINE> use_coins = [ 0 ] * len ( coin_values ) <NEWLINE> no_use_coins = [ 0 ] * len ( coin_values ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( len ( coin_values ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> no_use_coins [ i ] = int ( oturi / coin_values [ i ] ) <NEWLINE> oturi = oturi - ( coin_values [ i ] * no_use_coins [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( 0 , len ( use_coins ) , 1 ) : <NEWLINE> <INDENT> use_coins [ i ] = coin_nums [ i ] - no_use_coins [ i ] <NEWLINE> if use_coins [ i ] > 0 : <NEWLINE> <INDENT> print ( str ( coin_values [ i ] ) + <STRING> + str ( use_coins [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> first = True <NEWLINE> while ( True ) : <NEWLINE> <INDENT> total_fee = int ( input ( <STRING> ) ) <NEWLINE> if total_fee == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if first : <NEWLINE> <INDENT> first = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> coins = input ( <STRING> ) <NEWLINE> coins = coins . split ( <STRING> ) <COMMENT> <NEWLINE> coins = [ int ( coin ) for coin in coins ] <NEWLINE> coin_values = [ 10 , 50 , 100 , 500 ] <NEWLINE> back_oturigation ( total_fee , coin_values , coins ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( sum ( A [ : K ] ) ) <NEWLINE>
<COMMENT> <NL> doms = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = input ( ) . split ( ) <NEWLINE> doms [ int ( b ) - 1 ] [ int ( f ) - 1 ] [ int ( r ) - 1 ] += int ( v ) <NEWLINE> <NL> <DEDENT> for i , tou in enumerate ( doms ) : <NEWLINE> <INDENT> for floor in tou : <NEWLINE> <COMMENT> <NL> <INDENT> for room in floor : <NEWLINE> <INDENT> print ( <STRING> . format ( room ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> if i < 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
_ , * a = open ( 0 ) . read ( ) . split ( ) <NEWLINE> x = eval ( <STRING> . join ( a ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> print ( x ^ int ( i ) , end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> b [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( b [ i ] ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> <NL> def xnxn ( n = 0 , flag = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if n == 0 : <NEWLINE> <INDENT> temp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if len ( temp ) == 1 : <NEWLINE> <INDENT> if flag == <STRING> : <NEWLINE> <INDENT> return temp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return temp [ 0 ] <NEWLINE> <DEDENT> <DEDENT> elif len ( temp ) > 1 : <NEWLINE> <INDENT> return temp <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> temp = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> return temp <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m = xnxn ( ) <NEWLINE> a = xnxn ( m ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for g in a : <NEWLINE> <INDENT> graph [ g [ 0 ] ] . append ( g [ 1 ] ) <NEWLINE> graph [ g [ 1 ] ] . append ( g [ 0 ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> d = deque ( [ 1 ] ) <NEWLINE> rout = [ 0 ] * ( n + 1 ) <NEWLINE> while d != deque ( [ ] ) : <NEWLINE> <INDENT> pos = d . popleft ( ) <NEWLINE> for i in graph [ pos ] : <NEWLINE> <INDENT> if rout [ i ] == 0 : <NEWLINE> <INDENT> rout [ i ] = pos <NEWLINE> d . append ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if rout != [ 0 ] * ( n + 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in rout [ 2 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> loop_list = [ ] <NEWLINE> loop_set = set ( ) <NEWLINE> now = 0 <NEWLINE> <NL> if k > n : <NEWLINE> <INDENT> for _ in range ( k ) : <NEWLINE> <INDENT> now = a [ now ] - 1 <NEWLINE> <NL> if now + 1 in loop_set : <NEWLINE> <INDENT> s_index = loop_list . index ( now + 1 ) <NEWLINE> before_loop = s_index <NEWLINE> loop_list = loop_list [ s_index : ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop_list . append ( now + 1 ) <NEWLINE> loop_set . add ( now + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> l = len ( loop_list ) <NEWLINE> k -= before_loop <NEWLINE> <NL> <COMMENT> <NL> print ( loop_list [ k % l - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for _ in range ( k ) : <NEWLINE> <INDENT> now = a [ now ] - 1 <NEWLINE> <NL> <DEDENT> print ( now + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , k + 1 , 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , k + 1 , 1 ) : <NEWLINE> <INDENT> if 0 <= s - i - j <= k : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> maxpoint = 0 <NEWLINE> <NL> if b > n : <NEWLINE> <INDENT> tmp = int ( ( a * n ) / b ) - a * int ( n / b ) <NEWLINE> maxpoint = max ( tmp , maxpoint ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = int ( n / b ) * b - 1 <NEWLINE> maxpoint = int ( ( a * k ) / b ) - a * int ( k / b ) <NEWLINE> if b == 1 : <NEWLINE> <INDENT> maxpoint = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( maxpoint ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> import bisect <NEWLINE> l = [ [ ] for _ in range ( n ) ] <NEWLINE> l2 = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> p , y = map ( int , input ( ) . split ( ) ) <NEWLINE> bisect . insort_left ( l [ p - 1 ] , y ) <NEWLINE> l2 . append ( [ p , y ] ) <NEWLINE> <NL> <DEDENT> for m in l2 : <NEWLINE> <INDENT> print ( <STRING> . format ( m [ 0 ] ) + <STRING> . format ( bisect . bisect_left ( l [ m [ 0 ] - 1 ] , m [ 1 ] ) + 1 ) ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> l . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> MIN = 999999999999999999999999999999999999999 <NEWLINE> MAX = - 9999999999999999999999999999999999999 <NEWLINE> for i in l : <NEWLINE> <INDENT> if i - MIN > MAX : <NEWLINE> <INDENT> MAX = i - MIN <NEWLINE> <DEDENT> if i < MIN : <NEWLINE> <INDENT> MIN = i <NEWLINE> <DEDENT> <DEDENT> print ( MAX ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> <NL> def X ( x ) : <NEWLINE> <INDENT> return ( A * ( x % B ) - A * ( x % B ) % B ) / B <NEWLINE> <NL> <DEDENT> if N < B - 1 : <NEWLINE> <INDENT> print ( int ( X ( N ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( X ( B - 1 ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> si = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> [ x , k , d ] = [ int ( e ) for e in si ( ) . split ( ) ] <NEWLINE> if x == 0 : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( d ) ) <NEWLINE> <DEDENT> <DEDENT> elif x < 0 : <NEWLINE> <INDENT> mul = ( 0 - x ) // d <NEWLINE> if k <= mul : <NEWLINE> <INDENT> x += d * k <NEWLINE> print ( abs ( x ) ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x += d * mul <NEWLINE> k -= mul <NEWLINE> <DEDENT> while x < 0 and k : <NEWLINE> <INDENT> x += d <NEWLINE> k -= 1 <NEWLINE> <DEDENT> if k > 0 : <NEWLINE> <INDENT> if k % 2 : <NEWLINE> <INDENT> print ( abs ( x - d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> mul = ( x - 0 ) // d <NEWLINE> if k <= mul : <NEWLINE> <INDENT> x -= d * k <NEWLINE> print ( x ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x -= d * mul <NEWLINE> k -= mul <NEWLINE> <DEDENT> while x > 0 and k : <NEWLINE> <INDENT> x -= d <NEWLINE> k -= 1 <NEWLINE> <DEDENT> if k > 0 : <NEWLINE> <INDENT> if k % 2 : <NEWLINE> <INDENT> print ( x + d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> res = 1 <NEWLINE> for t in a : <NEWLINE> <INDENT> res *= t <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if res == 0 : <NEWLINE> <INDENT> print ( res ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = a * b <NEWLINE> d = ( a + b ) * 2 <NEWLINE> print ( c , d ) <NEWLINE> <NL>
from heapq import heappop , heappush <NEWLINE> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> while ( True ) : <NEWLINE> <INDENT> W , H = map ( int , input ( ) . split ( ) ) <NEWLINE> if not W : break <NEWLINE> B = float ( <STRING> ) <NEWLINE> Bi = - 1 <NEWLINE> consequNodes = [ ] <NEWLINE> monsterNodes = [ [ ] for _ in range ( 5 ) ] <NEWLINE> idx = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j , a in enumerate ( input ( ) ) : <NEWLINE> <INDENT> if a == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> consequNodes . append ( [ i , j , idx , 5 ] ) <NEWLINE> startNode = [ i , j , idx , 5 ] <NEWLINE> idx += 1 <NEWLINE> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> consequNodes . append ( [ i , j , idx , 6 ] ) <NEWLINE> goalNode = [ i , j , idx , 6 ] <NEWLINE> idx += 1 <NEWLINE> <DEDENT> elif a != <STRING> : <NEWLINE> <INDENT> consequNodes . append ( [ i , j , idx , int ( a ) - 1 ] ) <NEWLINE> monsterNodes [ int ( a ) - 1 ] . append ( [ i , j , idx ] ) <NEWLINE> idx += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for z in range ( 5 ) : <NEWLINE> <INDENT> consequNodes [ startNode [ 2 ] ] [ 3 ] = z <NEWLINE> dist = [ [ float ( <STRING> ) ] * idx for _ in range ( 6 ) ] <NEWLINE> dist [ 1 ] [ startNode [ 2 ] ] = 0 <NEWLINE> que = [ ( 0 , 1 , startNode [ 2 ] , 0 ) ] <NEWLINE> reached = False <NEWLINE> while que : <NEWLINE> <INDENT> cst , numrep , nid , huristicCost = heappop ( que ) <NEWLINE> cst = int ( cst ) - int ( huristicCost ) <NEWLINE> if numrep == 5 : <NEWLINE> <INDENT> reached = True <NEWLINE> cst += abs ( consequNodes [ nid ] [ 0 ] - goalNode [ 0 ] ) + abs ( consequNodes [ nid ] [ 1 ] - goalNode [ 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> nxtmonster = ( consequNodes [ nid ] [ 3 ] + 1 ) % 5 <NEWLINE> for nxty , nxtx , nxtid in monsterNodes [ nxtmonster ] : <NEWLINE> <INDENT> tmpCost = dist [ numrep ] [ nid ] + abs ( nxty - consequNodes [ nid ] [ 0 ] ) + abs ( nxtx - consequNodes [ nid ] [ 1 ] ) <NEWLINE> if tmpCost < dist [ numrep + 1 ] [ nxtid ] : <NEWLINE> <INDENT> dist [ numrep + 1 ] [ nxtid ] = tmpCost <NEWLINE> h = abs ( nxty - goalNode [ 0 ] ) + abs ( nxtx - goalNode [ 1 ] ) <NEWLINE> h *= 0.99 <NEWLINE> heappush ( que , ( tmpCost + h , numrep + 1 , nxtid , h ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if reached and cst < B : <NEWLINE> <INDENT> B = cst <NEWLINE> Bi = z + 1 <NEWLINE> <DEDENT> <DEDENT> if Bi == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Bi , B ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> def rest ( a ) : <NEWLINE> <INDENT> if a == <STRING> : <NEWLINE> <INDENT> return ( [ <STRING> , <STRING> ] ) <NEWLINE> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> return ( [ <STRING> , <STRING> ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( [ <STRING> , <STRING> ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n - 3 ) : <NEWLINE> <INDENT> rest1 = rest ( s [ i ] ) [ 0 ] <NEWLINE> rest2 = rest ( s [ i ] ) [ 1 ] <NEWLINE> ans = ans + s [ i + 1 : ] . count ( rest1 ) * s [ i + 1 : ] . count ( rest2 ) <NEWLINE> <NL> j = i + 1 <NEWLINE> k = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if ( s [ j ] == rest1 and s [ j + k ] == rest2 ) or ( s [ j ] == rest2 and s [ j + k ] == rest1 ) : <NEWLINE> <INDENT> ans = ans - 1 <NEWLINE> <DEDENT> k = k + 1 <NEWLINE> j = i + k <NEWLINE> if j + k > n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 10001 ) ] <NEWLINE> <NL> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> t = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if t <= 10000 : <NEWLINE> <INDENT> ans [ t ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> sr = s . replace ( <STRING> , <STRING> ) <NEWLINE> if sr == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> elif sr != sr [ : : - 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> cur_l = 0 <NEWLINE> cur_r = n - 1 <NEWLINE> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> while cur_l < cur_r : <NEWLINE> <INDENT> while s [ cur_l ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> cur_l += 1 <NEWLINE> <DEDENT> while s [ cur_r ] != s [ cur_l ] : <NEWLINE> <INDENT> cur_r -= 1 <NEWLINE> cnt -= 1 <NEWLINE> <DEDENT> ans += abs ( cnt ) <NEWLINE> cur_l += 1 <NEWLINE> cur_r -= 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> mods = [ 0 ] * 2019 <NEWLINE> mods [ 0 ] = 1 <NEWLINE> accu = 0 <NEWLINE> for i , j in enumerate ( reversed ( s ) ) : <NEWLINE> <INDENT> accu += int ( j ) * pow ( 10 , i , 2019 ) <NEWLINE> accu %= 2019 <NEWLINE> mods [ accu ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in mods : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
for _ in [ 0 ] * int ( input ( ) ) : <NEWLINE> <INDENT> X , Y , z = input ( ) , input ( ) , [ ] <NEWLINE> for y in Y : <NEWLINE> <INDENT> s = 0 <NEWLINE> for i , k in enumerate ( z ) : <NEWLINE> <INDENT> t = X . find ( y , s ) + 1 <NEWLINE> if t < 1 : break <NEWLINE> if t < k : z [ i ] = t <NEWLINE> s = k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = X . find ( y , s ) + 1 <NEWLINE> if t : z += [ t ] <NEWLINE> <DEDENT> <DEDENT> print ( len ( z ) ) <NEWLINE> <DEDENT>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ca = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> jud = [ 0 ] * m <NEWLINE> money = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> money += ca [ j ] [ 0 ] <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> jud [ k ] += ca [ j ] [ k + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if min ( jud ) >= x : <NEWLINE> <INDENT> ans . append ( money ) <NEWLINE> <NL> <DEDENT> <DEDENT> if not ans : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> Tree = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> Counter = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> AB = ( tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ) <NEWLINE> PX = ( tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ) <NEWLINE> <NL> for a , b in AB : <NEWLINE> <INDENT> Tree [ a ] . append ( b ) <NEWLINE> Tree [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for p , x in PX : <NEWLINE> <INDENT> Counter [ p ] += x <NEWLINE> <NL> <DEDENT> P = [ - 1 ] * ( n + 1 ) <NEWLINE> <NL> nodes = [ 1 ] <NEWLINE> while nodes : <NEWLINE> <INDENT> parent = nodes . pop ( ) <NEWLINE> for node_i in Tree [ parent ] : <NEWLINE> <INDENT> if P [ parent ] == node_i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> P [ node_i ] = parent <NEWLINE> nodes . append ( node_i ) <NEWLINE> Counter [ node_i ] += Counter [ parent ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * Counter [ 1 : ] ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> <NL> INF = 10 ** 10 <NEWLINE> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> uv = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N - 1 ) ] <NEWLINE> <NL> <COMMENT> <NL> link = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for u , v in uv : <NEWLINE> <INDENT> link [ u ] . append ( v ) <NEWLINE> link [ v ] . append ( u ) <NEWLINE> <NL> <NL> <DEDENT> def dfs ( l , dp , pre , v ) : <NEWLINE> <COMMENT> <NL> <INDENT> idx = np . searchsorted ( dp , A [ v - 1 ] ) <NEWLINE> l [ v ] = max ( idx , l [ pre ] ) <NEWLINE> bef = dp [ idx ] <NEWLINE> dp [ idx ] = A [ v - 1 ] <NEWLINE> <NL> for x in link [ v ] : <NEWLINE> <INDENT> if x != pre : <NEWLINE> <INDENT> dfs ( l , dp , v , x ) <NEWLINE> <NL> <DEDENT> <DEDENT> dp [ idx ] = bef <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> l = [ 0 ] * ( N + 1 ) <NEWLINE> dp = np . full ( N + 1 , INF ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dfs ( l , dp , 0 , 1 ) <NEWLINE> for ans in l [ 1 : ] : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> import collections <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> count = collections . Counter ( A ) <NEWLINE> numsum = 0 <NEWLINE> for i in count . values ( ) : <NEWLINE> <INDENT> numsum += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <INDENT> print ( numsum - ( count [ i ] - 1 ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = max ( a ) + 1 <NEWLINE> t = [ True ] * M <NEWLINE> a . sort ( ) <NEWLINE> s = set ( a ) <NEWLINE> pre = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if t [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if pre == i : <NEWLINE> <INDENT> t [ i ] = False <NEWLINE> <DEDENT> for j in range ( 2 * i , M , i ) : <NEWLINE> <INDENT> t [ j ] = False <NEWLINE> <DEDENT> pre = i <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for k in a : <NEWLINE> <INDENT> if t [ k ] == True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> counter = Counter ( a ) <NEWLINE> ini_sum = sum ( a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> s = [ ini_sum ] + [ 0 ] * q <NEWLINE> <NL> for i in range ( 1 , q + 1 ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> x = c - b <NEWLINE> s [ i ] = s [ i - 1 ] + x * counter [ b ] <NEWLINE> counter [ c ] += counter [ b ] <NEWLINE> counter [ b ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , q + 1 ) : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> <NL> sub_list = [ 0 ] * n <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> sub_list [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( sub_list [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> def solve ( * args : str ) -> str : <NEWLINE> <INDENT> n , m , q = map ( int , args [ 0 ] . split ( ) ) <NEWLINE> ABCD = [ tuple ( map ( int , abcd . split ( ) ) ) for abcd in args [ 1 : ] ] <NEWLINE> <NL> ret = 0 <NEWLINE> stack = [ ( i , <STRING> ) for i in range ( 10 ) ] <NEWLINE> while stack : <NEWLINE> <INDENT> t , s = stack . pop ( ) <NEWLINE> S = s + str ( t ) <NEWLINE> if len ( S ) == n : <NEWLINE> <INDENT> ret = max ( <NEWLINE> <INDENT> ret , <NEWLINE> sum ( [ d for a , b , c , d in ABCD if int ( S [ b - 1 ] ) - int ( S [ a - 1 ] ) == c ] ) <NEWLINE> <DEDENT> ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> for i in range ( t , m ) : <NEWLINE> <INDENT> stack . append ( ( i , S ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> return str ( ret ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( solve ( * ( open ( 0 ) . read ( ) . splitlines ( ) ) ) ) <NEWLINE> <DEDENT>
N , A , B , C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> u = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> ss = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> t = [ A , B , C ] <NEWLINE> trace = [ ] <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> idx = ss . index ( s [ i ] ) <NEWLINE> if t [ ( idx + 1 ) % 3 ] == 0 and t [ ( idx + 2 ) % 3 ] == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> elif t [ ( idx + 2 ) % 3 ] == 0 : <NEWLINE> <INDENT> t [ ( idx + 1 ) % 3 ] -= 1 <NEWLINE> t [ ( idx + 2 ) % 3 ] += 1 <NEWLINE> trace . append ( u [ ( idx + 2 ) % 3 ] ) <NEWLINE> <DEDENT> elif t [ ( idx + 1 ) % 3 ] == 0 : <NEWLINE> <INDENT> t [ ( idx + 1 ) % 3 ] += 1 <NEWLINE> t [ ( idx + 2 ) % 3 ] -= 1 <NEWLINE> trace . append ( u [ ( idx + 1 ) % 3 ] ) <NEWLINE> <DEDENT> elif i + 1 < N and s [ i + 1 ] == ss [ ( idx + 1 ) % 3 ] : <NEWLINE> <INDENT> t [ ( idx + 1 ) % 3 ] -= 1 <NEWLINE> t [ ( idx + 2 ) % 3 ] += 1 <NEWLINE> trace . append ( u [ ( idx + 2 ) % 3 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ ( idx + 1 ) % 3 ] += 1 <NEWLINE> t [ ( idx + 2 ) % 3 ] -= 1 <NEWLINE> trace . append ( u [ ( idx + 1 ) % 3 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> if ans == <STRING> : <NEWLINE> <INDENT> for v in trace : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> P = P - X <NEWLINE> <NL> for i in range ( 0 , X + 1 ) : <NEWLINE> <INDENT> if i not in P or - i not in P : <NEWLINE> <INDENT> if - i not in P : <NEWLINE> <INDENT> ans = X - i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = X + i <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> am = a [ - 1 ] + 1 <NEWLINE> b = [ 0 ] * am <NEWLINE> for i in a : <NEWLINE> <INDENT> b [ i ] += 1 <NEWLINE> if b [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( i * 2 , am , i ) : <NEWLINE> <INDENT> b [ j ] = 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( b . count ( 1 ) ) <NEWLINE>
dict = { } <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> query , * val = input ( ) . split ( <STRING> ) <NEWLINE> if query == <STRING> : <NEWLINE> <INDENT> dict [ val [ 0 ] ] = int ( val [ 1 ] ) <NEWLINE> <DEDENT> elif query == <STRING> : <NEWLINE> <INDENT> print ( dict . get ( val [ 0 ] , 0 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if val [ 0 ] in dict : <NEWLINE> <INDENT> dict . pop ( val [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if K >= A + B : <NEWLINE> <INDENT> ans = A - ( K - A - B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = K <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - ( a + b ) ) ) <NEWLINE> <NL> <DEDENT>
n = 26 <NEWLINE> d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ [ ] for i in range ( d ) ] <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> a = 0 <NEWLINE> last = [ 0 ] * n <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> t = int ( input ( ) ) - 1 <NEWLINE> a += s [ i ] [ t ] <NEWLINE> last [ t ] = i + 1 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> a -= c [ j ] * ( i - last [ j ] + 1 ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> R = 0 <NEWLINE> G = 0 <NEWLINE> B = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> G += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += 1 <NEWLINE> <DEDENT> <DEDENT> ans = R * G * B <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ac = set ( ) <NEWLINE> pena = 0 <NEWLINE> walen = [ 0 ] * N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> p , S = map ( str , input ( ) . split ( ) ) <NEWLINE> p = int ( p ) - 1 <NEWLINE> if p in ac : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> ac . add ( p ) <NEWLINE> pena += walen [ p ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> walen [ p ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( ac ) , pena ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> h , w , m = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> hw = [ list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> tate = [ 0 ] * ( h + 1 ) <NEWLINE> yoko = [ 0 ] * ( w + 1 ) <NEWLINE> bombpoint = set ( ) <NEWLINE> <NL> for x , y in hw : <NEWLINE> <INDENT> tate [ x ] += 1 <NEWLINE> yoko [ y ] += 1 <NEWLINE> bombpoint . add ( ( x , y ) ) <NEWLINE> <NL> <DEDENT> ans_x = [ ] <NEWLINE> ans_y = [ ] <NEWLINE> x_max = max ( tate ) <NEWLINE> y_max = max ( yoko ) <NEWLINE> for i in range ( len ( tate ) ) : <NEWLINE> <INDENT> if tate [ i ] == x_max : <NEWLINE> <INDENT> ans_x . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( yoko ) ) : <NEWLINE> <INDENT> if yoko [ i ] == y_max : <NEWLINE> <INDENT> ans_y . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = x_max + y_max <NEWLINE> for x in ans_x : <NEWLINE> <INDENT> for y in ans_y : <NEWLINE> <INDENT> if ( x , y ) not in bombpoint : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> if arr [ 0 ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if arr [ 0 ] != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> sum_arr = [ 0 ] * N <NEWLINE> sum_arr [ 0 ] = arr [ - 1 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> sum_arr [ i ] = sum_arr [ i - 1 ] + arr [ N - i ] <NEWLINE> <DEDENT> sum_arr = sum_arr [ : : - 1 ] <NEWLINE> ans = [ 0 ] * ( N + 1 ) <NEWLINE> ans [ 0 ] = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if ans [ i - 1 ] - arr [ i - 1 ] < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> tmp = min ( ( ans [ i - 1 ] - arr [ i - 1 ] ) * 2 , sum_arr [ i - 1 ] ) <NEWLINE> ans [ i ] = tmp <NEWLINE> <DEDENT> for i in range ( min ( 25 , N + 1 ) ) : <NEWLINE> <INDENT> if ans [ i ] > 2 ** i : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if ans [ N ] != arr [ - 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = Counter ( lis ) <NEWLINE> d = [ 0 ] + [ l [ i + 1 ] for i in range ( 10 ** 5 ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> s = sum ( lis ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if d [ a ] != 0 : <NEWLINE> <INDENT> temp = d [ a ] <NEWLINE> d [ a ] = 0 <NEWLINE> d [ b ] += temp <NEWLINE> s += temp * ( b - a ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
from collections import defaultdict , deque <NEWLINE> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = defaultdict ( set ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <NL> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d [ a ] . add ( b ) <NEWLINE> d [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> visited = set ( ) <NEWLINE> <NL> def dfs ( node ) : <NEWLINE> <NL> <INDENT> c = 0 <NEWLINE> stack = deque ( [ node ] ) <NEWLINE> visited . add ( node ) <NEWLINE> while stack : <NEWLINE> <INDENT> n = stack . popleft ( ) <NEWLINE> c += 1 <NEWLINE> for i in d [ n ] : <NEWLINE> <INDENT> if i not in visited : <NEWLINE> <INDENT> visited . add ( i ) <NEWLINE> stack . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return c <NEWLINE> <NL> <NL> <DEDENT> ans = 1 <NEWLINE> <NL> for key in list ( d . keys ( ) ) : <NEWLINE> <INDENT> if key not in visited : <NEWLINE> <NL> <INDENT> c = dfs ( key ) <NEWLINE> ans = max ( ans , c ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h_cnt = [ 0 ] * h <NEWLINE> w_cnt = [ 0 ] * w <NEWLINE> <NL> bomb_set = set ( ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> h_ , w_ = map ( int , input ( ) . split ( ) ) <NEWLINE> h_ -= 1 <NEWLINE> w_ -= 1 <NEWLINE> h_cnt [ h_ ] += 1 <NEWLINE> w_cnt [ w_ ] += 1 <NEWLINE> bomb_set . add ( ( h_ , w_ ) ) <NEWLINE> <NL> <DEDENT> max_h = max ( h_cnt ) <NEWLINE> max_h_idx = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if h_cnt [ i ] == max_h : <NEWLINE> <INDENT> max_h_idx . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> max_w = max ( w_cnt ) <NEWLINE> max_w_idx = [ ] <NEWLINE> for i in range ( w ) : <NEWLINE> <INDENT> if w_cnt [ i ] == max_w : <NEWLINE> <INDENT> max_w_idx . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> minus = - 1 <NEWLINE> for i in max_h_idx : <NEWLINE> <INDENT> for j in max_w_idx : <NEWLINE> <INDENT> if ( i , j ) not in bomb_set : <NEWLINE> <INDENT> print ( max_h + max_w ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max_h + max_w - 1 ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> scores = [ ] <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ K + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
S = list ( input ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> b = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += b <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans [ a [ i ] ] += 1 <NEWLINE> <DEDENT> ans . pop ( 0 ) <NEWLINE> for j in ans : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> <COMMENT> <NL> ans = 1 <NEWLINE> if a . count ( 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( a * min ( b - 1 , n ) // b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> temp = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> result += math . gcd ( temp , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> prev = a [ i - k ] <NEWLINE> next = a [ i ] <NEWLINE> if next > prev : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = np . array ( [ 0 ] * n , dtype = <STRING> ) <NEWLINE> a [ 0 ] += n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> c = n // ( 1 + i ) <NEWLINE> d = n % ( 1 + i ) <NEWLINE> a [ 1 : i + 1 ] += c <NEWLINE> a [ 0 ] += c <NEWLINE> if d > 0 : <NEWLINE> <INDENT> a [ 1 : d + 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( np . sum ( a [ k : ] ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> mymap = [ [ ] for n in range ( N ) ] <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> mymap [ a - 1 ] . append ( b - 1 ) <NEWLINE> mymap [ b - 1 ] . append ( a - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> myans = 0 <NEWLINE> check_list = [ 0 for n in range ( N ) ] <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> mylist = mymap [ n ] <NEWLINE> <COMMENT> <NL> myd = deque ( ) <NEWLINE> for mm in mylist : <NEWLINE> <INDENT> myd . append ( mm ) <NEWLINE> <COMMENT> <NL> <DEDENT> mycnt = 1 <NEWLINE> check_list [ n ] = 1 <NEWLINE> while myd : <NEWLINE> <INDENT> tgt = myd . popleft ( ) <NEWLINE> <COMMENT> <NL> if check_list [ tgt ] == 0 : <NEWLINE> <INDENT> for e in mymap [ tgt ] : <NEWLINE> <INDENT> if e > n : <NEWLINE> <INDENT> myd . append ( e ) <NEWLINE> <DEDENT> <DEDENT> mycnt += 1 <NEWLINE> check_list [ tgt ] = 1 <NEWLINE> <DEDENT> <DEDENT> if myans < mycnt : <NEWLINE> <INDENT> myans = mycnt <NEWLINE> <DEDENT> <DEDENT> print ( myans ) <NEWLINE>
a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> per = 0.0 <NEWLINE> ans = salt = w = s = 0 <NEWLINE> for i in range ( 0 , f + 1 , 100 * a ) : <NEWLINE> <INDENT> for j in range ( 0 , f + 1 , 100 * b ) : <NEWLINE> <INDENT> w = i + j <NEWLINE> if w > f : break <NEWLINE> for k in range ( 0 , f + 1 , c ) : <NEWLINE> <INDENT> if w + k > f : break <NEWLINE> for l in range ( 0 , f + 1 , d ) : <NEWLINE> <INDENT> w = i + j <NEWLINE> s = k + l <NEWLINE> if w + s > f : break <NEWLINE> if s <= ( w // 100 ) * e : <NEWLINE> <INDENT> if 0 < s + w <= f : <NEWLINE> <INDENT> if per < s / ( s + w ) : <NEWLINE> <INDENT> per = s / ( s + w ) <NEWLINE> ans = w + s <NEWLINE> salt = s <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( 100 * a , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans , salt ) <NEWLINE> <DEDENT>
T = str ( input ( ) ) <NEWLINE> T = list ( T ) <NEWLINE> if not T [ 0 ] == <STRING> : <NEWLINE> <INDENT> for i in range ( 1 , len ( T ) - 1 ) : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> if T [ i - 1 ] == <STRING> and T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if T [ len ( T ) - 1 ] == <STRING> : <NEWLINE> <INDENT> T [ len ( T ) - 1 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> T [ 0 ] = <STRING> <NEWLINE> for i in range ( 1 , len ( T ) - 1 ) : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> if T [ i - 1 ] == <STRING> and T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if T [ len ( T ) - 1 ] == <STRING> : <NEWLINE> <INDENT> T [ len ( T ) - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( T ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> ans = np . zeros ( N , dtype = np . int ) <NEWLINE> <NL> j = 0 <NEWLINE> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> if j != 0 : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> if j == 0 : <NEWLINE> <INDENT> while S [ i + j ] == <STRING> : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> if j != 0 : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> ans [ i + j ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i + j - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> j = 0 <NEWLINE> for i in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if j != 0 : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> if j == 0 : <NEWLINE> <INDENT> while S [ i - j ] == <STRING> : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> if j != 0 : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> ans [ i - j ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i - j + 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> count = H * W // 2 <NEWLINE> if H % 2 == 1 and W % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if H == 1 or W == 1 : <NEWLINE> <INDENT> count = 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . strip ( ) . split ( ) ) <NEWLINE> x = x1 - x2 <NEWLINE> y = y1 - y2 <NEWLINE> <NL> distance = math . sqrt ( x * x + y * y ) <NEWLINE> <NL> print ( distance ) <NEWLINE>
import sys <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> <NL> <NL> def inputs ( func = lambda x : x , sep = None , maxsplit = - 1 ) : <NEWLINE> <INDENT> return map ( func , sys . stdin . buffer . readline ( ) . split ( sep = sep , maxsplit = maxsplit ) ) <NEWLINE> <NL> <DEDENT> def input_2d_T ( nrows : int , ncols : int , type = int , ** kwargs ) : <NEWLINE> <INDENT> data = [ [ None ] * nrows for _ in range ( ncols ) ] <NEWLINE> for i in range ( nrows ) : <NEWLINE> <INDENT> for j , v in enumerate ( inputs ( type ) ) : <NEWLINE> <INDENT> data [ j ] [ i ] = v <NEWLINE> <DEDENT> <DEDENT> return data <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> <NL> N , M = inputs ( int ) <NEWLINE> A , B , C = input_2d_T ( N , 3 ) <NEWLINE> D , E , F = input_2d_T ( M , 3 ) <NEWLINE> xs = sorted ( set ( C ) ) <NEWLINE> ys = sorted ( set ( D ) ) <NEWLINE> <NL> x_guard = [ [ False for _ in range ( len ( ys ) + 1 ) ] for _ in range ( len ( xs ) + 1 ) ] <NEWLINE> y_guard = [ [ False for _ in range ( len ( ys ) + 1 ) ] for _ in range ( len ( xs ) + 1 ) ] <NEWLINE> <NL> for a , b , c in zip ( A , B , C ) : <NEWLINE> <INDENT> c = bisect_right ( xs , c ) <NEWLINE> a = bisect_left ( ys , a ) + 1 <NEWLINE> b = bisect_right ( ys , b ) <NEWLINE> for i in range ( a , b ) : <NEWLINE> <INDENT> x_guard [ c ] [ i ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> for d , e , f in zip ( D , E , F ) : <NEWLINE> <INDENT> d = bisect_right ( ys , d ) <NEWLINE> e = bisect_left ( xs , e ) + 1 <NEWLINE> f = bisect_right ( xs , f ) <NEWLINE> for i in range ( e , f ) : <NEWLINE> <INDENT> y_guard [ i ] [ d ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> cow = ( <NEWLINE> <INDENT> bisect_right ( xs , 0 ) , <NEWLINE> bisect_right ( ys , 0 ) <NEWLINE> <DEDENT> ) <NEWLINE> nexts = deque ( [ cow ] ) <NEWLINE> visited = [ [ 0 for _ in range ( len ( ys ) + 1 ) ] for _ in range ( len ( xs ) + 1 ) ] <NEWLINE> visited [ cow [ 0 ] ] [ cow [ 1 ] ] = True <NEWLINE> <NL> area = 0 <NEWLINE> <NL> while nexts : <NEWLINE> <INDENT> xi , yi = nexts . popleft ( ) <NEWLINE> <NL> if 0 < xi < len ( xs ) and 0 < yi < len ( ys ) : <NEWLINE> <INDENT> area += ( xs [ xi ] - xs [ xi - 1 ] ) * ( ys [ yi ] - ys [ yi - 1 ] ) <NEWLINE> if not visited [ xi - 1 ] [ yi ] and not x_guard [ xi ] [ yi ] : <NEWLINE> <INDENT> visited [ xi - 1 ] [ yi ] = True <NEWLINE> nexts . append ( ( xi - 1 , yi ) ) <NEWLINE> <DEDENT> if not visited [ xi + 1 ] [ yi ] and not x_guard [ xi + 1 ] [ yi ] : <NEWLINE> <INDENT> visited [ xi + 1 ] [ yi ] = True <NEWLINE> nexts . append ( ( xi + 1 , yi ) ) <NEWLINE> <DEDENT> if not visited [ xi ] [ yi - 1 ] and not y_guard [ xi ] [ yi ] : <NEWLINE> <INDENT> visited [ xi ] [ yi - 1 ] = True <NEWLINE> nexts . append ( ( xi , yi - 1 ) ) <NEWLINE> <DEDENT> if not visited [ xi ] [ yi + 1 ] and not y_guard [ xi ] [ yi + 1 ] : <NEWLINE> <INDENT> visited [ xi ] [ yi + 1 ] = True <NEWLINE> nexts . append ( ( xi , yi + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> area = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( area ) <NEWLINE> <NL>
anum , bnum , acc = map ( int , input ( ) . split ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> blist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> asum = [ 0 ] <NEWLINE> bsum = [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( anum ) : <NEWLINE> <INDENT> asum . append ( asum [ i ] + alist [ i ] ) <NEWLINE> <DEDENT> for i in range ( bnum ) : <NEWLINE> <INDENT> bsum . append ( bsum [ i ] + blist [ i ] ) <NEWLINE> <NL> <DEDENT> b = bnum <NEWLINE> for a in range ( anum + 1 ) : <NEWLINE> <INDENT> if asum [ a ] > acc : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while asum [ a ] + bsum [ b ] > acc : <NEWLINE> <INDENT> b -= 1 <NEWLINE> <DEDENT> ans = max ( ans , a + b ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> max_a = max ( a ) <NEWLINE> cnt_d = [ 0 ] * ( max_a + 1 ) <NEWLINE> <NL> for ai in a : <NEWLINE> <INDENT> for multi in range ( ai , max_a + 1 , ai ) : <NEWLINE> <INDENT> cnt_d [ multi ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( cnt_d [ ai ] == 1 for ai in a ) ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> from collections import deque <NEWLINE> <NL> H , W , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> x1 , y1 , x2 , y2 = map ( int , readline ( ) . split ( ) ) <NEWLINE> x1 -= 1 ; y1 -= 1 ; x2 -= 1 ; y2 -= 1 <NEWLINE> C = read ( ) . split ( ) <NEWLINE> <NL> dist = [ [ - 1 ] * W for i in range ( H ) ] <NEWLINE> dist [ x1 ] [ y1 ] = 0 <NEWLINE> d = deque ( [ [ x1 , y1 ] ] ) <NEWLINE> dxy = [ [ 1 , 0 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] <NEWLINE> while d : <NEWLINE> <INDENT> x , y = d . popleft ( ) <NEWLINE> if ( x , y ) == ( x2 , y2 ) : <NEWLINE> <INDENT> print ( dist [ x ] [ y ] ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> for dx , dy in dxy : <NEWLINE> <INDENT> xx = x ; yy = y <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> xx += dx ; yy += dy <NEWLINE> if 0 <= xx < H and 0 <= yy < W and C [ xx ] [ yy ] != <STRING> : <NEWLINE> <INDENT> if 0 <= dist [ xx ] [ yy ] <= dist [ x ] [ y ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if dist [ xx ] [ yy ] == - 1 : <NEWLINE> <INDENT> d . append ( [ xx , yy ] ) <NEWLINE> <DEDENT> dist [ xx ] [ yy ] = dist [ x ] [ y ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> e = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> e . append ( p [ i ] + 1 ) <NEWLINE> <NL> <DEDENT> sum_e = [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> sum_e . append ( sum_e [ i - 1 ] + e [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> <NL> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans . append ( sum_e [ i + k ] - sum_e [ i ] ) <NEWLINE> <NL> <DEDENT> print ( max ( ans ) / 2 ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( A , min ( A + K , B + 1 ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for j in range ( max ( A + K , B - K + 1 ) , B + 1 ) : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> An = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> An . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> ans = ans * An [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> if An [ i ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from sys import setrecursionlimit <NEWLINE> <NL> setrecursionlimit ( 1000000 ) <NEWLINE> <NL> H = int ( input ( ) ) <NEWLINE> <NL> <NL> def f ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 + f ( n // 2 ) * 2 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( f ( H ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> <NL> count = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> count [ int ( A [ i ] ) ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( count [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 for i in range ( n ) ] <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> b [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in b : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> Mi = map ( int , input ( ) . split ( ) ) <NEWLINE> PS = { } <NEWLINE> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if ( i , m ) in PS : <NEWLINE> <INDENT> return PS [ ( i , m ) ] <NEWLINE> <DEDENT> if i >= n : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - A [ i ] ) <NEWLINE> PS [ ( i , m ) ] = res <NEWLINE> return res <NEWLINE> <NL> <DEDENT> for m in Mi : <NEWLINE> <INDENT> if solve ( 0 , m ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> mod = int ( 1e9 + 7 ) <NEWLINE> INF = 1 << 29 <NEWLINE> lINF = 1 << 35 <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> a , b , n = readInt ( ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> ans = a * x // b - a * ( x // b ) <NEWLINE> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> n %= k <NEWLINE> <NL> n = abs ( n ) <NEWLINE> <NL> print ( min ( n , abs ( n - k ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in l : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if As [ i ] / As [ i - K ] > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = [ 2 , 1 ] <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> L . append ( L [ i - 1 ] + L [ i - 2 ] ) <NEWLINE> <DEDENT> print ( L [ N ] ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ [ ] for i in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab [ a - 1 ] . append ( b - 1 ) <NEWLINE> ab [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> q = deque ( ) <NEWLINE> q . append ( 0 ) <NEWLINE> ans = [ - 1 ] * n <NEWLINE> ans [ 0 ] = 0 <NEWLINE> while q : <NEWLINE> <INDENT> now = q . popleft ( ) <NEWLINE> for i , next in enumerate ( ab [ now ] ) : <NEWLINE> <INDENT> if ans [ next ] == - 1 : <NEWLINE> <INDENT> ans [ next ] = now + 1 <NEWLINE> q . append ( next ) <NEWLINE> <DEDENT> <DEDENT> if len ( q ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , l = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( [ x - l , x + l ] ) <NEWLINE> <DEDENT> L . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> L = deque ( L ) <NEWLINE> s , ans = - 10 ** 8 , 0 <NEWLINE> while L : <NEWLINE> <INDENT> l = deque . popleft ( L ) <NEWLINE> if s <= l [ 0 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> s = l [ 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> <NL> <COMMENT> <NL> def II ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def MI1 ( ) : return map ( int1 , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def SR ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> ascii_lowercase = <STRING> <NEWLINE> ascii_uppercase = <STRING> <NEWLINE> ascii_uppercase2 = <STRING> <NEWLINE> <NL> <COMMENT> <NL> p2D = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> p2E = lambda x : print ( <STRING> . join ( x ) ) <NEWLINE> p2S = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> <NL> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> a , b = map ( int , s . split ( <STRING> ) ) <NEWLINE> if ( int ( b ) == 0 ) : <NEWLINE> <INDENT> c = a <NEWLINE> d = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = a * pow ( 10 , len ( s ) - s . find ( <STRING> ) - 1 ) + b <NEWLINE> d = pow ( 10 , len ( s ) - s . find ( <STRING> ) - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> c = int ( s ) <NEWLINE> d = 1 <NEWLINE> <DEDENT> e = 0 <NEWLINE> f = 0 <NEWLINE> while ( c != 0 and c % 2 == 0 ) : <NEWLINE> <INDENT> e += 1 <NEWLINE> c //= 2 <NEWLINE> <DEDENT> while ( c != 0 and c % 5 == 0 ) : <NEWLINE> <INDENT> f += 1 <NEWLINE> c //= 5 <NEWLINE> <DEDENT> while ( d % 2 == 0 ) : <NEWLINE> <INDENT> e -= 1 <NEWLINE> d //= 2 <NEWLINE> <DEDENT> while ( d % 5 == 0 ) : <NEWLINE> <INDENT> f -= 1 <NEWLINE> d //= 5 <NEWLINE> <DEDENT> A . append ( [ e , f ] ) <NEWLINE> <NL> <DEDENT> tm = max ( max ( [ a [ 0 ] for a in A ] ) , - 1 * min ( [ a [ 0 ] for a in A ] ) ) + 1 <NEWLINE> fm = max ( max ( [ a [ 1 ] for a in A ] ) , - 1 * min ( [ a [ 1 ] for a in A ] ) ) + 1 <NEWLINE> <NL> B = [ [ 0 ] * ( tm * 2 ) for _ in range ( fm * 2 ) ] <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> B [ a [ 1 ] + fm ] [ a [ 0 ] + tm ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( fm * 2 ) : <NEWLINE> <INDENT> for j in range ( tm * 2 ) : <NEWLINE> <INDENT> if ( i > 0 ) : <NEWLINE> <INDENT> B [ i ] [ j ] += B [ i - 1 ] [ j ] <NEWLINE> <DEDENT> if ( j > 0 ) : <NEWLINE> <INDENT> B [ i ] [ j ] += B [ i ] [ j - 1 ] <NEWLINE> <DEDENT> if ( i > 0 and j > 0 ) : <NEWLINE> <INDENT> B [ i ] [ j ] -= B [ i - 1 ] [ j - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> i = - 1 * a [ 1 ] + fm <NEWLINE> j = - 1 * a [ 0 ] + tm <NEWLINE> ans += B [ fm * 2 - 1 ] [ tm * 2 - 1 ] - B [ fm * 2 - 1 ] [ j - 1 ] - B [ i - 1 ] [ tm * 2 - 1 ] + B [ i - 1 ] [ j - 1 ] <NEWLINE> if a [ 1 ] >= 0 and a [ 0 ] >= 0 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
import numpy as np <NEWLINE> X , N = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> p = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> if X in p : <NEWLINE> <INDENT> s = p . index ( X ) <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if ( s - i ) < 0 : <NEWLINE> <INDENT> print ( p [ 0 ] - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif p [ s - i ] != ( X - i ) : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( s + i ) >= N : <NEWLINE> <INDENT> print ( p [ N - 1 ] + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif p [ s + i ] != ( X + i ) : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> b . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> if ( len ( b ) != 0 ) : <NEWLINE> <INDENT> a . append ( b ) <NEWLINE> b = [ ] <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <NL> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> b . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> if ( len ( b ) != 0 ) : <NEWLINE> <INDENT> a . append ( b ) <NEWLINE> b = [ ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( len ( b ) != 0 ) : <NEWLINE> <INDENT> a . append ( b ) <NEWLINE> b = [ ] <NEWLINE> <DEDENT> if ( len ( a ) != 0 ) : <NEWLINE> <INDENT> if ( n == a [ len ( a ) - 1 ] [ 0 ] ) : <NEWLINE> <INDENT> a [ len ( a ) - 1 ] . append ( n ) <NEWLINE> n = 1 <NEWLINE> <DEDENT> <DEDENT> if ( n != 1 ) : <NEWLINE> <INDENT> b . append ( n ) <NEWLINE> a . append ( b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> ans += int ( ( - 1 + math . sqrt ( 1 + 8 * len ( a [ i ] ) ) ) / 2 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 18 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> xmax = - inf <NEWLINE> xmin = inf <NEWLINE> ymax = - inf <NEWLINE> ymin = inf <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x = a + b <NEWLINE> y = a - b <NEWLINE> xmax = max ( xmax , x ) <NEWLINE> xmin = min ( xmin , x ) <NEWLINE> ymax = max ( ymax , y ) <NEWLINE> ymin = min ( ymin , y ) <NEWLINE> <NL> <DEDENT> print ( max ( xmax - xmin , ymax - ymin ) ) <NEWLINE>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> num = [ 0 ] * 2019 <NEWLINE> num [ 0 ] = 1 <NEWLINE> now , ans = 0 , 0 <NEWLINE> _10 = 1 <NEWLINE> <NL> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> now = ( now + int ( S [ i ] ) * _10 ) % 2019 <NEWLINE> _10 *= 10 <NEWLINE> _10 %= 2019 <NEWLINE> ans += num [ now ] <NEWLINE> num [ now ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = 1 <NEWLINE> arr . sort ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t *= arr [ i ] <NEWLINE> if arr [ i ] == 0 : <NEWLINE> <INDENT> t = 0 <NEWLINE> break <NEWLINE> <DEDENT> elif t > 10 ** 18 : <NEWLINE> <INDENT> t = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> while i <= n : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while 0 < x : <NEWLINE> <INDENT> f = 0 <NEWLINE> x = x // 10 <NEWLINE> if x >= 1 : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> f = 1 <NEWLINE> <DEDENT> <DEDENT> if f == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> i = i + 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
history = set ( [ ] ) <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> def func ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> l = make_divisors ( n ) <NEWLINE> for i in sorted ( l [ 1 : ] ) : <NEWLINE> <INDENT> if i in history : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if len ( factorization ( i ) ) > 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> history . add ( i ) <NEWLINE> _ = n // i <NEWLINE> func ( _ ) <NEWLINE> break <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> func ( N ) <NEWLINE> print ( len ( history ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) ; a = list ( map ( int , input ( ) . split ( ) ) ) ; f , b , c = 0 , sum ( a ) , float ( <STRING> ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> f , b = f + a [ i ] , b - a [ i ] <NEWLINE> c = min ( c , abs ( f - b ) ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
import sys <NEWLINE> import bisect <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> in_n = lambda : int ( readline ( ) ) <NEWLINE> in_nn = lambda : map ( int , readline ( ) . split ( ) ) <NEWLINE> in_s = lambda : readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> in_nl = lambda : list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> in_nl2 = lambda H : [ in_nl ( ) for _ in range ( H ) ] <NEWLINE> in_map = lambda : [ s == ord ( <STRING> ) for s in readline ( ) if s != ord ( <STRING> ) ] <NEWLINE> in_map2 = lambda H : [ in_map ( ) for _ in range ( H ) ] <NEWLINE> in_all = lambda : map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> <NL> class Bit : <NEWLINE> <NL> <INDENT> def __init__ ( self , a ) : <NEWLINE> <INDENT> if hasattr ( a , <STRING> ) : <NEWLINE> <INDENT> le = len ( a ) <NEWLINE> self . n = 1 << le . bit_length ( ) <COMMENT> <NEWLINE> self . values = values = [ 0 ] * ( self . n + 1 ) <NEWLINE> values [ 1 : le + 1 ] = a [ : ] <NEWLINE> for i in range ( 1 , self . n ) : <NEWLINE> <INDENT> values [ i + ( i & - i ) ] += values [ i ] <NEWLINE> <DEDENT> <DEDENT> elif isinstance ( a , int ) : <NEWLINE> <INDENT> self . n = 1 << a . bit_length ( ) <NEWLINE> self . values = [ 0 ] * ( self . n + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise TypeError <NEWLINE> <NL> <DEDENT> <DEDENT> def add ( self , i , val ) : <NEWLINE> <INDENT> n , values = self . n , self . values <NEWLINE> while i <= n : <NEWLINE> <INDENT> values [ i ] += val <NEWLINE> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> def sum ( self , i ) : <COMMENT> <NEWLINE> <INDENT> values = self . values <NEWLINE> res = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> res += values [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def bisect_left ( self , v ) : <COMMENT> <NEWLINE> <INDENT> n , values = self . n , self . values <NEWLINE> if v > values [ n ] : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> i , step = 0 , n >> 1 <NEWLINE> while step : <NEWLINE> <INDENT> if values [ i + step ] < v : <NEWLINE> <INDENT> i += step <NEWLINE> v -= values [ i ] <NEWLINE> <DEDENT> step >>= 1 <NEWLINE> <DEDENT> return i + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> N , D , A = in_nn ( ) <NEWLINE> XH = sorted ( in_nl2 ( N ) ) <NEWLINE> X = [ 0 ] * N <NEWLINE> H = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x , h = XH [ i ] <NEWLINE> X [ i ] = x <NEWLINE> H [ i ] = h <NEWLINE> <NL> <DEDENT> bit = Bit ( N ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <NL> <INDENT> x , h = X [ i ] , H [ i ] <NEWLINE> j = bisect . bisect_right ( X , x + 2 * D ) <NEWLINE> cnt_bomb = bit . sum ( i + 1 ) <NEWLINE> <NL> h -= A * cnt_bomb <NEWLINE> if h <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> cnt = - ( - h // A ) <NEWLINE> ans += cnt <NEWLINE> bit . add ( i + 1 , cnt ) <NEWLINE> bit . add ( j + 1 , - cnt ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
inf = 0x10101010 <NEWLINE> def solve ( A , strt ) : <NEWLINE> <INDENT> cost = [ inf ] * m <NEWLINE> visited = [ False ] * m <NEWLINE> cost [ strt ] = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> min = inf <NEWLINE> next = - 1 <NEWLINE> visited [ strt ] = True <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if visited [ i ] : continue <NEWLINE> if A [ strt ] [ i ] : <NEWLINE> <INDENT> d = cost [ strt ] + A [ strt ] [ i ] <NEWLINE> if d < cost [ i ] : <NEWLINE> <INDENT> cost [ i ] = d <NEWLINE> <DEDENT> <DEDENT> if min > cost [ i ] : <NEWLINE> <INDENT> min = cost [ i ] <NEWLINE> next = i <NEWLINE> <DEDENT> <DEDENT> strt = next <NEWLINE> if next == - 1 : break <NEWLINE> <DEDENT> return cost <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> T = [ [ 0 ] * m for i in range ( m ) ] <NEWLINE> C = [ [ 0 ] * m for i in range ( m ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b , c , t = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> T [ a - 1 ] [ b - 1 ] = T [ b - 1 ] [ a - 1 ] = t <NEWLINE> C [ a - 1 ] [ b - 1 ] = C [ b - 1 ] [ a - 1 ] = c <NEWLINE> <DEDENT> TS = [ solve ( T , i ) for i in range ( m ) ] <NEWLINE> CS = [ solve ( C , i ) for i in range ( m ) ] <NEWLINE> for i in range ( input ( ) ) : <NEWLINE> <INDENT> a , b , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if q == 0 : <NEWLINE> <INDENT> print CS [ a - 1 ] [ b - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print TS [ a - 1 ] [ b - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> visited = [ - 1 for _ in range ( N ) ] <NEWLINE> visited [ 0 ] = 0 <NEWLINE> <NL> current = 0 <NEWLINE> th = - 1 <NEWLINE> per_loop = - 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> current = A [ current ] - 1 <NEWLINE> <NL> if visited [ current ] >= 0 : <NEWLINE> <COMMENT> <NL> <INDENT> per_loop = i - visited [ current ] <NEWLINE> th = visited [ current ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited [ current ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> current = 0 <NEWLINE> <COMMENT> <NL> <NL> if K < th : <NEWLINE> <INDENT> num_rep = K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num_rep = th + ( K - th ) % per_loop <NEWLINE> <NL> <DEDENT> for i in range ( num_rep ) : <NEWLINE> <INDENT> current = A [ current ] - 1 <NEWLINE> <NL> <DEDENT> print ( current + 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> max_l = 0 <NEWLINE> min_r = n <NEWLINE> ans = n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if ans != 0 : <NEWLINE> <INDENT> if l <= min_r or r <= max_l : <NEWLINE> <INDENT> max_l = max ( max_l , l ) <NEWLINE> min_r = min ( min_r , r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans != 0 : <NEWLINE> <INDENT> ans = min_r - max_l + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <DEDENT> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , j + 1 ) : <NEWLINE> <INDENT> if i == j and j == k : <NEWLINE> <INDENT> sum += gcd ( i , j , k ) <NEWLINE> <DEDENT> elif i == j or j == k or k == i : <NEWLINE> <INDENT> sum += 3 * gcd ( i , j , k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += 6 * gcd ( i , j , k ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = 1000 <NEWLINE> k = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> m += k * A [ i ] <NEWLINE> k = 0 <NEWLINE> <DEDENT> elif A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> m += k * A [ i ] <NEWLINE> k = m // A [ i ] <NEWLINE> m -= k * A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> m += ( k * A [ - 1 ] ) <NEWLINE> print ( m ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> MOD = 998244353 <NEWLINE> <NL> ans = 0 <NEWLINE> temp2 = 1 <NEWLINE> <COMMENT> <NL> <NL> def getInvs ( n , MOD ) : <NEWLINE> <INDENT> invs = [ 1 ] * ( n + 1 ) <NEWLINE> for x in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> invs [ x ] = ( - ( MOD // x ) * invs [ MOD % x ] ) % MOD <NEWLINE> <DEDENT> return invs <NEWLINE> <NL> <DEDENT> invs = getInvs ( max ( N + 3 , M - 1 ) , MOD ) <NEWLINE> <NL> Vec = [ 0 ] * N <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> temp1 = M <NEWLINE> Vec [ N - i - 1 ] = temp1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp1 *= ( M - 1 ) * ( N - i ) <NEWLINE> temp1 *= invs [ i ] <NEWLINE> temp1 %= MOD <NEWLINE> Vec [ N - i - 1 ] = temp1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = sum ( Vec [ : K + 1 ] ) <NEWLINE> <NL> print ( ans % MOD ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> flag = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> w = input ( ) <NEWLINE> l . append ( w ) <NEWLINE> <DEDENT> for k in range ( 1 , n ) : <NEWLINE> <INDENT> if l [ k - 1 ] [ - 1 ] != l [ k ] [ 0 ] : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> for j in range ( k ) : <NEWLINE> <INDENT> if l [ k ] == l [ j ] : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( flag == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> <NL> count = 0 <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> k = 2 * j - i <NEWLINE> if k >= n : break <NEWLINE> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ i ] != s [ k ] : count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ( r * g * b ) - count ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> flag = False <NEWLINE> for i in range ( 150 ) : <NEWLINE> <INDENT> for j in range ( 150 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> if ( - i ) ** 5 - j ** 5 == X : <NEWLINE> <INDENT> print ( - i , j ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> if i ** 5 - ( - j ) ** 5 == X : <NEWLINE> <INDENT> print ( i , - j ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> if ( - i ) ** 5 - ( - j ) ** 5 == X : <NEWLINE> <INDENT> print ( - i , - j ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> if a == 1 or b == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif a == 0 or b == 0 : <NEWLINE> <INDENT> return max ( a , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> return gcd ( a % b , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( a , b % a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> x = gcd ( i , j ) <NEWLINE> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> s = s + 6 * gcd ( x , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> s = s + 6 * gcd ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> s = s + i <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> i = 1 <NEWLINE> count1 = 0 <NEWLINE> while i < len ( S ) : <NEWLINE> <INDENT> if S [ i ] == S [ i - 1 ] : <NEWLINE> <INDENT> count1 += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> ss = S * 2 <NEWLINE> i = 1 <NEWLINE> count2 = 0 <NEWLINE> while i < len ( ss ) : <NEWLINE> <INDENT> if ss [ i ] == ss [ i - 1 ] : <NEWLINE> <INDENT> count2 += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> if 2 * count1 + 1 == count2 and len ( set ( S ) ) != 1 : <NEWLINE> <INDENT> print ( K * count1 + ( K - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( K * count2 // 2 ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> i = B - A <NEWLINE> c = 0 <NEWLINE> <NL> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> c = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if c == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
