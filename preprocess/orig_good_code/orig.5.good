t = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> t . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> s = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> s . append ( t [ i ] % 10 ) <NEWLINE> <NL> <DEDENT> o = 5 <NEWLINE> p = 10 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if s [ i ] > 0 : <NEWLINE> <INDENT> if p > s [ i ] : <NEWLINE> <INDENT> o = i <NEWLINE> p = s [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> m = 0 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if i != o : <NEWLINE> <INDENT> if s [ i ] == 0 : <NEWLINE> <INDENT> m += t [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m += t [ i ] - t [ i ] % 10 + 10 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if o != 5 : <NEWLINE> <INDENT> m += t [ o ] <NEWLINE> <DEDENT> print ( m ) <NEWLINE>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( w == h == 0 ) : break <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
import heapq <NEWLINE> import sys <NEWLINE> from collections import defaultdict <NEWLINE> <NL> def dijkstra ( graph , size , start ) : <NEWLINE> <INDENT> d = [ float ( <STRING> ) ] * size <NEWLINE> d [ start ] = 0 <NEWLINE> q = [ ( 0 , start ) ] <NEWLINE> while len ( q ) : <NEWLINE> <INDENT> du , u = heapq . heappop ( q ) <NEWLINE> for length , v in graph [ u ] : <NEWLINE> <INDENT> if d [ v ] > du + length : <NEWLINE> <INDENT> d [ v ] = du + length <NEWLINE> heapq . heappush ( q , ( d [ v ] , v ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> f = sys . stdin <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n , m = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> abct = [ map ( int , f . readline ( ) . split ( ) ) for _ in range ( n ) ] <NEWLINE> d = [ defaultdict ( list ) , defaultdict ( list ) ] <NEWLINE> <NL> for ai , bi , ci , ti in abct : <NEWLINE> <INDENT> ai -= 1 <NEWLINE> bi -= 1 <NEWLINE> d [ 0 ] [ ai ] . append ( ( ci , bi ) ) <NEWLINE> d [ 0 ] [ bi ] . append ( ( ci , ai ) ) <NEWLINE> d [ 1 ] [ ai ] . append ( ( ti , bi ) ) <NEWLINE> d [ 1 ] [ bi ] . append ( ( ti , ai ) ) <NEWLINE> <NL> <DEDENT> dist = { } <NEWLINE> for i in range ( int ( f . readline ( ) ) ) : <NEWLINE> <INDENT> p , q , r = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> p -= 1 <NEWLINE> q -= 1 <NEWLINE> try : <NEWLINE> <INDENT> print ( dist [ ( q , r ) ] [ p ] ) <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> print ( dist [ ( p , r ) ] [ q ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> dist [ ( p , r ) ] = dijkstra ( d [ r ] , m , p ) <NEWLINE> print ( dist [ ( p , r ) ] [ q ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> import heapq as hq <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> <NL> def make_grid ( h , w , num ) : return [ [ int ( num ) ] * w for _ in range ( h ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> T = NI ( ) <NEWLINE> for _ in range ( T ) : <NEWLINE> <INDENT> N = NI ( ) <NEWLINE> camels = [ NLI ( ) for _ in range ( N ) ] <NEWLINE> base = 0 <NEWLINE> camels_L = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> camels_R = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> <COMMENT> <NL> for camel in camels : <NEWLINE> <INDENT> if camel [ 1 ] >= camel [ 2 ] : <NEWLINE> <INDENT> camels_L [ camel [ 0 ] ] . append ( camel [ 1 ] - camel [ 2 ] ) <NEWLINE> base += camel [ 2 ] <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> camels_R [ N - camel [ 0 ] ] . append ( camel [ 2 ] - camel [ 1 ] ) <NEWLINE> base += camel [ 1 ] <COMMENT> <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> heap_camels = [ ] <NEWLINE> hq . heapify ( heap_camels ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for camel in camels_L [ i ] : <NEWLINE> <INDENT> hq . heappush ( heap_camels , camel ) <NEWLINE> <DEDENT> while len ( heap_camels ) > i : <NEWLINE> <INDENT> hq . heappop ( heap_camels ) <NEWLINE> <DEDENT> <DEDENT> if heap_camels : <NEWLINE> <INDENT> ans += sum ( heap_camels ) <NEWLINE> <NL> <DEDENT> heap_camels = [ ] <NEWLINE> hq . heapify ( heap_camels ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for camel in camels_R [ i ] : <NEWLINE> <INDENT> hq . heappush ( heap_camels , camel ) <NEWLINE> <DEDENT> while len ( heap_camels ) > i : <NEWLINE> <INDENT> hq . heappop ( heap_camels ) <NEWLINE> <DEDENT> <DEDENT> if heap_camels : <NEWLINE> <INDENT> ans += sum ( heap_camels ) <NEWLINE> <DEDENT> print ( ans + base ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = 1 <NEWLINE> r = max ( A ) <NEWLINE> while l != r : <NEWLINE> <INDENT> mid = ( r + l ) // 2 <NEWLINE> count = 0 <NEWLINE> for log in A : <NEWLINE> <INDENT> count += ( log - 1 ) // mid <NEWLINE> <DEDENT> if count <= K : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> i = 0 <NEWLINE> j = n - 1 <NEWLINE> while i < j : <NEWLINE> <INDENT> while c [ i ] == <STRING> and i < j : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> while c [ j ] == <STRING> and i < j : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> if c [ i ] != <STRING> or c [ j ] != <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> j -= 1 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ** 0.5 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> a = list ( ) <NEWLINE> def mkArray ( in_list , sav_val , cnt ) : <NEWLINE> <INDENT> if cnt >= n : <NEWLINE> <INDENT> a . append ( in_list ) <NEWLINE> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in range ( sav_val , m + 1 ) : <NEWLINE> <INDENT> wk_list = list ( ) <NEWLINE> wk_list . extend ( in_list ) <NEWLINE> wk_list . append ( x ) <NEWLINE> mkArray ( wk_list , x , cnt + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = list ( ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> w_abcd = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> abcd . append ( w_abcd ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> w_a = list ( ) <NEWLINE> mkArray ( w_a , 1 , 0 ) <NEWLINE> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> wans = 0 <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> if a [ i ] [ abcd [ j ] [ 1 ] - 1 ] - a [ i ] [ abcd [ j ] [ 0 ] - 1 ] == abcd [ j ] [ 2 ] : <NEWLINE> <INDENT> wans = wans + abcd [ j ] [ 3 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if wans > ans : <NEWLINE> <INDENT> ans = wans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> ans = r * b * g <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for d in range ( N ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k > N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> input = stdin . buffer . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> tmp = 0 <NEWLINE> <NL> for a in range ( 1 , N ) : <NEWLINE> <INDENT> tmp = tmp + ( N - 1 ) // a <NEWLINE> <NL> <DEDENT> print ( tmp ) <NEWLINE>
a , b , n = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> n = int ( n ) <NEWLINE> p = min ( b , n ) <NEWLINE> if p % b == 0 : <NEWLINE> <INDENT> print ( int ( a * ( p - 1 ) / b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( a * p / b ) ) <NEWLINE> <DEDENT>
h , w , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> t = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s . append ( H ) <NEWLINE> t . append ( W ) <NEWLINE> <NL> <DEDENT> from collections import Counter <NEWLINE> u = Counter ( s ) <NEWLINE> v = Counter ( t ) <NEWLINE> max_u = max ( u . values ( ) ) <NEWLINE> max_u_set = set ( [ kv [ 0 ] for kv in u . items ( ) if kv [ 1 ] == max_u ] ) <NEWLINE> max_v = max ( v . values ( ) ) <NEWLINE> max_v_set = set ( [ kv [ 0 ] for kv in v . items ( ) if kv [ 1 ] == max_v ] ) <NEWLINE> check = len ( max_u_set ) * len ( max_v_set ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if u [ s [ i ] ] == max_u and v [ t [ i ] ] == max_v : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if check - ans == 0 : <NEWLINE> <INDENT> print ( max_u + max_v - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max_u + max_v ) <NEWLINE> <DEDENT>
n , quantum = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> queue = [ ] <NEWLINE> sumOfTime = 0 <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> name , time = input ( ) . split ( ) <NEWLINE> queue . append ( [ name , int ( time ) ] ) <NEWLINE> <NL> <DEDENT> while len ( queue ) > 0 : <NEWLINE> <INDENT> name , time = queue . pop ( 0 ) <NEWLINE> if time > quantum : <NEWLINE> <INDENT> sumOfTime += quantum <NEWLINE> queue . append ( [ name , time - quantum ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sumOfTime += time <NEWLINE> print ( name , sumOfTime ) <NEWLINE> <NL> <DEDENT> <DEDENT>
m = input ( ) ; n = int ( m ) ; s = n ** .5 ; a = [ ] ; i = 6 <NEWLINE> while n % 2 == 0 : a += [ 2 ] ; n //= 2 <NEWLINE> while n % 3 == 0 : a += [ 3 ] ; n //= 3 <NEWLINE> while i < s : <NEWLINE> <INDENT> if n % ( i - 1 ) == 0 : a += [ i - 1 ] ; n //= i - 1 <NEWLINE> elif n % ( i + 1 ) == 0 : a += [ i + 1 ] ; n //= i + 1 <NEWLINE> else : i += 6 <NEWLINE> <DEDENT> if n > 1 : a += [ n ] <NEWLINE> elif n == int ( m ) : a += [ m ] <NEWLINE> print ( m + <STRING> , * a ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> <NL> pos = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> x = abs ( pos [ 2 ] - pos [ 0 ] ) <NEWLINE> y = abs ( pos [ 3 ] - pos [ 1 ] ) <NEWLINE> <NL> print ( math . sqrt ( x ** 2 + y ** 2 ) ) <NEWLINE> <NL>
from math import ceil <NEWLINE> <NL> def check ( x ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> cnt += ceil ( a / x ) - 1 <NEWLINE> <DEDENT> return cnt <= K <NEWLINE> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> left = 0 <NEWLINE> right = max ( A ) <NEWLINE> while left < right - 1 : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if check ( mid ) : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid <NEWLINE> <DEDENT> <DEDENT> print ( right ) <NEWLINE>
O = input ( ) <NEWLINE> E = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( O ) ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ans += O [ i ] + E [ i ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> ans += O [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if ( a > b ) : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <NL> <DEDENT> while ( b > 0 ) : <NEWLINE> <INDENT> r = a % b <NEWLINE> a = b <NEWLINE> b = r <NEWLINE> <NL> <DEDENT> return a <NEWLINE> <NL> <DEDENT> dp = [ [ 0 for i in range ( K + 1 ) ] for j in range ( K + 1 ) ] <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if ( dp [ a ] [ b ] == 0 ) : <NEWLINE> <INDENT> dp [ a ] [ b ] = gcd ( a , b ) <NEWLINE> <NL> <DEDENT> res = dp [ a ] [ b ] <NEWLINE> <NL> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if ( dp [ res ] [ c ] == 0 ) : <NEWLINE> <INDENT> dp [ res ] [ c ] = gcd ( res , c ) <NEWLINE> <NL> <DEDENT> total += dp [ res ] [ c ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // a <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> from scipy . sparse . csgraph import connected_components <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> import collections <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = np . array ( [ input ( ) . split ( ) for _ in range ( M ) ] , dtype = np . int64 ) . T <NEWLINE> <NL> if M == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = np . ones ( M , dtype = np . int64 ) . T <NEWLINE> graph = csr_matrix ( ( tmp , ( edge [ : ] - 1 ) ) , ( N , N ) ) <NEWLINE> <NL> n , labels = connected_components ( graph ) <NEWLINE> <NL> c = collections . Counter ( labels ) <NEWLINE> <NL> print ( max ( c . values ( ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> if ans != - 1 : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> <DEDENT> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
r = input ( ) <NEWLINE> r = float ( r ) <NEWLINE> <NL> a = 3.14159265359 * r * r <NEWLINE> c = 2 * 3.14159265359 * r <NEWLINE> <NL> print ( <STRING> % ( a , c ) ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import numpy as np <NEWLINE> A0 = [ 0 ] + A <NEWLINE> B0 = [ 0 ] + B <NEWLINE> AA = np . cumsum ( A0 ) <NEWLINE> BB = np . cumsum ( B0 ) <NEWLINE> <NL> ans = 0 <NEWLINE> jmax = M <NEWLINE> for i in range ( 0 , N + 1 ) : <NEWLINE> <INDENT> a = AA [ i ] <NEWLINE> if a > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( jmax , - 1 , - 1 ) : <NEWLINE> <INDENT> b = BB [ j ] <NEWLINE> <COMMENT> <NL> if a + b <= K : <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> <COMMENT> <NL> break <NEWLINE> <DEDENT> <DEDENT> jmax = j <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> while A >= B : <NEWLINE> <INDENT> B = B * 2 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> while B >= C : <NEWLINE> <INDENT> C = C * 2 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> if cnt <= K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE> <NL>
s = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if len ( s ) <= 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ 0 ] == s [ - 1 ] : <NEWLINE> <INDENT> del s [ 0 ] <NEWLINE> del s [ - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> del s [ 0 ] <NEWLINE> <DEDENT> elif s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> del s [ - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if min ( A ) == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> d = [ 0 ] * 100001 <NEWLINE> for i in a : <NEWLINE> <INDENT> d [ i - 1 ] += 1 <NEWLINE> <DEDENT> s = 0 <NEWLINE> for num , i in enumerate ( d ) : <NEWLINE> <INDENT> s += i * ( num + 1 ) <NEWLINE> <NL> <DEDENT> bb = [ ] <NEWLINE> cc = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> bb . append ( b ) <NEWLINE> cc . append ( c ) <NEWLINE> <NL> <DEDENT> for b , c in zip ( bb , cc ) : <NEWLINE> <INDENT> k = d [ b - 1 ] <NEWLINE> s += ( c - b ) * k <NEWLINE> d [ b - 1 ] = 0 <NEWLINE> d [ c - 1 ] += k <NEWLINE> <NL> print ( s ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ch = list ( itertools . combinations_with_replacement ( range ( 1 , m + 1 ) , n ) ) <NEWLINE> lch = len ( ch ) <NEWLINE> rel = [ 0 ] * lch <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> for k in range ( lch ) : <NEWLINE> <INDENT> for i in range ( q ) : <NEWLINE> <INDENT> if ch [ k ] [ l [ i ] [ 1 ] - 1 ] - ch [ k ] [ l [ i ] [ 0 ] - 1 ] == l [ i ] [ 2 ] : <NEWLINE> <INDENT> rel [ k ] += l [ i ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( rel ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lis = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> lis [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( lis [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if len ( set ( a ) ) == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> Plot = [ tuple ( int ( x ) for x in input ( ) . split ( ) ) for _ in range ( N ) ] <NEWLINE> X = [ p [ 0 ] for p in Plot ] <NEWLINE> Y = [ p [ 1 ] for p in Plot ] <NEWLINE> X . sort ( ) <NEWLINE> Y . sort ( ) <NEWLINE> <COMMENT> <NL> ans = 10e20 <NEWLINE> from itertools import combinations <NEWLINE> for x1 , x2 in combinations ( X , 2 ) : <NEWLINE> <INDENT> for y1 in Y : <NEWLINE> <INDENT> y2 = [ y for x , y in Plot if x1 <= x <= x2 and y1 <= y ] <NEWLINE> if len ( y2 ) < K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> y2 . sort ( ) <NEWLINE> S = ( x2 - x1 ) * ( y2 [ K - 1 ] - y1 ) <NEWLINE> ans = min ( ans , S ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> path_list = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> z = [ ] <NEWLINE> path_list . append ( z ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> path_list [ A - 1 ] . append ( B ) <NEWLINE> path_list [ B - 1 ] . append ( A ) <NEWLINE> <DEDENT> chk = [ 0 ] * N <NEWLINE> <NL> def bfs ( a , chk , path ) : <NEWLINE> <INDENT> queue = [ a ] <NEWLINE> while queue : <NEWLINE> <INDENT> b = queue . pop ( 0 ) <NEWLINE> for i in range ( len ( path [ b - 1 ] ) ) : <NEWLINE> <INDENT> if chk [ path [ b - 1 ] [ i ] - 1 ] == 0 : <NEWLINE> <INDENT> queue . append ( path [ b - 1 ] [ i ] ) <NEWLINE> chk [ path [ b - 1 ] [ i ] - 1 ] = b <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return chk <NEWLINE> <DEDENT> bfs ( 1 , chk , path_list ) <NEWLINE> print ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( chk [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> kl = [ i for i in range ( 1 , k + 1 ) ] <NEWLINE> <NL> <NL> total = 0 <NEWLINE> dp = { } <NEWLINE> for i in kl : <NEWLINE> <INDENT> for j in kl : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for k in kl : <NEWLINE> <INDENT> total += math . gcd ( tmp , k ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
def eval_pair ( A , B , x ) : <NEWLINE> <INDENT> return A ** 5 - B ** 5 == x <NEWLINE> <NL> <DEDENT> def get_pair ( x ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> A = int ( round ( x ** ( 1 / 5 ) ) ) <NEWLINE> if A ** 5 == x : return ( A , 0 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> valid = [ ( A , B ) for A in range ( 1 , 120 ) for B in range ( 1 , 119 ) if eval_pair ( A , B , x ) ] <NEWLINE> if valid : return valid . pop ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> valid = [ ( A , B ) for A in range ( 1 , 64 ) for B in range ( - 1 , - 64 , - 1 ) if eval_pair ( A , B , x ) ] <NEWLINE> if valid : return valid . pop ( ) <NEWLINE> <NL> <DEDENT> x = int ( input ( ) ) <NEWLINE> valid_pair = get_pair ( x ) <NEWLINE> print ( * valid_pair ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> z = 10 ** 18 <NEWLINE> ret = 1 <NEWLINE> for i in arr : <NEWLINE> <COMMENT> <NL> <INDENT> if ( ret != - 1 ) : <NEWLINE> <INDENT> ret *= i <NEWLINE> <DEDENT> elif ret == - 1 and i == 0 : <NEWLINE> <INDENT> ret = 0 <NEWLINE> <DEDENT> if ( ret > z ) : <NEWLINE> <INDENT> ret = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in A_list : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if ans != 0 : <NEWLINE> <INDENT> for i in A_list : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = Counter ( a ) . most_common ( ) <NEWLINE> num = 0 <NEWLINE> for i , j in a : <NEWLINE> <INDENT> if i < j : <NEWLINE> <INDENT> num += ( j - i ) <NEWLINE> <DEDENT> elif j < i : <NEWLINE> <INDENT> num += j <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> i = min ( A , B ) + 1 <NEWLINE> while count < K : <NEWLINE> <INDENT> i -= 1 <NEWLINE> if A % i == 0 and B % i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> countl = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if countl == H : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif countl % 2 == 0 : <NEWLINE> <INDENT> countll = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if countll % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> countll += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> countll += 1 <NEWLINE> <DEDENT> if countll == W : <NEWLINE> <INDENT> print ( ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif countl % 2 == 1 : <NEWLINE> <INDENT> countll = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if countll % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> countll += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> countll += 1 <NEWLINE> <DEDENT> if countll == W : <NEWLINE> <INDENT> print ( ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> countl += 1 <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> S = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( collections . Counter ( S ) ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h . insert ( 0 , 0 ) <NEWLINE> ans = [ True for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( h [ a ] > h [ b ] ) : <NEWLINE> <INDENT> ans [ b ] = False <NEWLINE> <DEDENT> elif ( h [ a ] < h [ b ] ) : <NEWLINE> <INDENT> ans [ a ] = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ a ] = ans [ b ] = False <NEWLINE> <DEDENT> <DEDENT> print ( ans . count ( True ) - 1 ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> kk = a // k <NEWLINE> kk = k * kk <NEWLINE> <NL> while ( kk <= 1000 ) : <NEWLINE> <INDENT> if ( kk <= b and kk >= a ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> kk = kk + k <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> p = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> p . append ( ( x , y ) ) <NEWLINE> <DEDENT> p = sorted ( p , key = lambda i : i [ 0 ] + i [ 1 ] ) <NEWLINE> x1 , y1 = p [ 0 ] <NEWLINE> x2 , y2 = p [ - 1 ] <NEWLINE> res = abs ( ( x1 + y1 ) - ( x2 + y2 ) ) <NEWLINE> p = sorted ( p , key = lambda i : i [ 0 ] - i [ 1 ] ) <NEWLINE> x1 , y1 = p [ 0 ] <NEWLINE> x2 , y2 = p [ - 1 ] <NEWLINE> res = max ( abs ( ( x1 - y1 ) - ( x2 - y2 ) ) , res ) <NEWLINE> print ( res ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> positive = [ ] <NEWLINE> negative = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if x [ i ] < 0 : <NEWLINE> <INDENT> negative . append ( - x [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> positive . append ( x [ i ] ) <NEWLINE> <DEDENT> <DEDENT> negative . sort ( ) <NEWLINE> n = len ( negative ) <NEWLINE> m = len ( positive ) <NEWLINE> ans = 1000000000 <NEWLINE> if n >= K : <NEWLINE> <INDENT> ans = min ( ans , negative [ K - 1 ] ) <NEWLINE> <DEDENT> if m >= K : <NEWLINE> <INDENT> ans = min ( ans , positive [ K - 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> j = K - ( i + 1 ) <NEWLINE> if j > m : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if j <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans = min ( ans , negative [ i ] + positive [ j - 1 ] + min ( negative [ i ] , positive [ j - 1 ] ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> m = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> p = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p1 , p2 = map ( int , input ( ) . split ( ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> p . append ( p1 ) <NEWLINE> <DEDENT> p . append ( p2 ) <NEWLINE> <NL> <DEDENT> def matrixChainMultiplication ( ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> m [ i ] [ i ] = 0 <NEWLINE> <NL> <DEDENT> for l in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for i in range ( 0 , n - l + 1 ) : <NEWLINE> <INDENT> j = i + l - 1 <NEWLINE> m [ i ] [ j ] = 1000000 <NEWLINE> for k in range ( i , j ) : <NEWLINE> <INDENT> m [ i ] [ j ] = min ( m [ i ] [ j ] , m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i ] * p [ k + 1 ] * p [ j + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> matrixChainMultiplication ( ) <NEWLINE> print ( m [ 0 ] [ n - 1 ] ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> lis = [ 0 ] * N <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> ans = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x - 1 <NEWLINE> if ans >= N : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis [ ans ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( lis [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> def can_load ( w , k , p ) : <NEWLINE> <INDENT> n = len ( w ) <NEWLINE> m = 0 <NEWLINE> tk = 0 <NEWLINE> i = 0 <NEWLINE> while tk < k : <NEWLINE> <INDENT> if m + w [ i ] <= p : <NEWLINE> <INDENT> m += w [ i ] <NEWLINE> i += 1 <NEWLINE> if i >= n : <NEWLINE> <INDENT> return n + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> m = 0 <NEWLINE> tk += 1 <NEWLINE> <DEDENT> <DEDENT> return i <NEWLINE> <NL> <NL> <DEDENT> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> w = [ ] <NEWLINE> tr = [ 0 for _ in range ( k ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> w . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> maxw = max ( w ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> right = maxw * n <NEWLINE> left = maxw <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = ( right + left ) // 2 <NEWLINE> cl = can_load ( w , k , mid ) <NEWLINE> if cl == n : <NEWLINE> <INDENT> print ( mid ) <NEWLINE> break <NEWLINE> <DEDENT> elif cl < n : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> <DEDENT> print ( right ) <NEWLINE> <NL> <NL> <NL> <NL> <NL>
<NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> <NL> ans = r * g * b <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 1 , n // 2 + 1 ) : <NEWLINE> <INDENT> if i - j < 0 or i + j > n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ i - j ] and s [ i ] != s [ i + j ] and s [ i - j ] != s [ i + j ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
count = 0 <NEWLINE> W = input ( ) . lower ( ) <NEWLINE> T = [ 0 ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if T [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for t in T : <NEWLINE> <INDENT> if W == t : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> T = [ x . lower ( ) for x in input ( ) . split ( ) ] <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> <NL> n = input ( ) <NEWLINE> answer = len ( n ) <NEWLINE> number = int ( n ) <NEWLINE> for a in range ( int ( math . sqrt ( int ( n ) ) ) , 1 , - 1 ) : <NEWLINE> <INDENT> if number % a != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> b = number // a <NEWLINE> answer = min ( answer , max ( len ( str ( a ) ) , len ( str ( b ) ) ) ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
import copy <NEWLINE> <NL> <COMMENT> <NL> def get_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def get_string ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def get_int_list ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def get_string_list ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def get_int_multi ( ) : <COMMENT> <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def get_string_char_list ( ) : <NEWLINE> <INDENT> return list ( str ( input ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <STRING> <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> n , k = get_int_multi ( ) <NEWLINE> a_list = get_int_list ( ) <NEWLINE> <NL> p_list = [ ] <NEWLINE> m_list = [ ] <NEWLINE> for num in a_list : <NEWLINE> <INDENT> if num > 0 : <NEWLINE> <INDENT> p_list . append ( num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m_list . append ( num ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> p_list . sort ( ) <NEWLINE> m_list . sort ( reverse = True ) <NEWLINE> <NL> <NL> if k % 2 == 1 : <NEWLINE> <INDENT> if ( len ( p_list ) > 0 ) : <NEWLINE> <INDENT> ans = p_list . pop ( ) <NEWLINE> k -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m_list . sort ( ) <NEWLINE> ans = m_list . pop ( ) <NEWLINE> k -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <NL> <DEDENT> nokori = k <NEWLINE> while nokori > 0 : <NEWLINE> <INDENT> if len ( p_list ) == 1 and len ( m_list ) == 1 : <NEWLINE> <INDENT> ans = ans * p_list . pop ( ) * m_list [ 0 ] <NEWLINE> del m_list [ 0 ] <NEWLINE> nokori -= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( p_list ) >= 2 : <NEWLINE> <INDENT> pval = p_list [ - 1 ] * p_list [ - 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pval = 0 <NEWLINE> <NL> <DEDENT> if len ( m_list ) >= 2 : <NEWLINE> <INDENT> mval = m_list [ - 1 ] * m_list [ - 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mval = 0 <NEWLINE> <NL> <DEDENT> if pval > mval : <NEWLINE> <INDENT> p_list . pop ( ) <NEWLINE> p_list . pop ( ) <NEWLINE> ans = ans * pval % 1000000007 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m_list . pop ( ) <NEWLINE> m_list . pop ( ) <NEWLINE> ans = ans * mval % 1000000007 <NEWLINE> <DEDENT> nokori -= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans % 1000000007 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ab . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> node = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> node [ ab [ i ] [ 0 ] - 1 ] . append ( ab [ i ] [ 1 ] ) <NEWLINE> node [ ab [ i ] [ 1 ] - 1 ] . append ( ab [ i ] [ 0 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> node_dic = [ [ ] for i in range ( n ) ] <NEWLINE> now = [ 1 ] <NEWLINE> while True : <NEWLINE> <COMMENT> <NL> <INDENT> flag = True <NEWLINE> next_node = [ ] <NEWLINE> for i in range ( len ( now ) ) : <NEWLINE> <INDENT> next_node_element = node [ now [ i ] - 1 ] <NEWLINE> <NL> for j in range ( len ( next_node_element ) ) : <NEWLINE> <INDENT> if not node_dic [ next_node_element [ j ] - 1 ] : <NEWLINE> <INDENT> next_node . append ( next_node_element [ j ] ) <NEWLINE> node_dic [ next_node_element [ j ] - 1 ] . append ( now [ i ] ) <NEWLINE> flag = False <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> now = [ ] <NEWLINE> now = next_node <NEWLINE> if flag : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> print ( node_dic [ i ] [ 0 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> B = [ A [ 0 ] ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if B [ i - 1 ] < A [ i ] : <NEWLINE> <INDENT> B . append ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( B [ i - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += B [ i ] - A [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> lp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lp . sort ( ) <NEWLINE> <NL> distance = 0 <NEWLINE> try : <NEWLINE> <INDENT> idx = lp . index ( x ) <NEWLINE> while True : <NEWLINE> <INDENT> distance += 1 <NEWLINE> dmin = x - distance <NEWLINE> dmax = x + distance <NEWLINE> if ( idx - distance ) < 0 or dmin != lp [ idx - distance ] : <NEWLINE> <INDENT> print ( dmin ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ( idx + distance ) >= len ( lp ) or dmax != lp [ idx + distance ] : <NEWLINE> <INDENT> print ( dmax ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except ValueError : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT>
def solve_L ( ) : <NEWLINE> <INDENT> X = input ( ) <NEWLINE> Y = input ( ) <NEWLINE> <NL> a = len ( X ) <NEWLINE> b = len ( Y ) <NEWLINE> c1 = [ 0 for i in range ( b + 1 ) ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> e1 = X [ i ] <NEWLINE> c2 = c1 + [ ] <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> if e1 == Y [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c2 [ j ] + 1 <NEWLINE> <DEDENT> elif c1 [ j + 1 ] < c1 [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c1 [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return c1 [ - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> ans = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ i ] = solve_L ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> while x != 0 : <NEWLINE> <INDENT> print ( <STRING> % ( i , x ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = i <NEWLINE> while x != 0 : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> x = int ( x / 10 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> <NL> <NL> stdin = sys . stdin <NEWLINE> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def nm ( ) : return map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> def nl ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , q = nm ( ) <NEWLINE> S = input ( ) <NEWLINE> ans = [ ] <NEWLINE> A_pos = [ ] <NEWLINE> C_pos = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> A_pos += [ i + 1 ] <NEWLINE> C_pos += [ i + 2 ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = nm ( ) <NEWLINE> ans += [ bisect_right ( C_pos , r ) - bisect_left ( A_pos , l ) ] <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = 10 ** 9 + 7 <NEWLINE> d = ( sum ( l ) ) ** 2 <NEWLINE> c = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c = c + l [ i ] ** 2 <NEWLINE> <DEDENT> print ( ( d - c ) // 2 % b ) <NEWLINE>
a , b = open ( 0 ) ; c = 1 ; <NEWLINE> for i in sorted ( b . split ( ) ) : <NEWLINE> <INDENT> c *= int ( i ) <NEWLINE> if c > 10 ** 18 : print ( - 1 ) ; exit ( ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
import fractions <NEWLINE> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst = [ 0 ] * N <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> lst [ i ] = x [ i ] - X <NEWLINE> <NL> <DEDENT> a = 0 <NEWLINE> for e in lst : <NEWLINE> <INDENT> a = fractions . gcd ( a , e ) <NEWLINE> <DEDENT> print ( abs ( a ) ) <NEWLINE>
n , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> r = [ A , B , C ] <NEWLINE> g = list ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> g . append ( str ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> def re ( string ) : <NEWLINE> <INDENT> if string == <STRING> : <NEWLINE> <INDENT> return ( 0 , 1 ) <NEWLINE> <DEDENT> elif string == <STRING> : <NEWLINE> <INDENT> return ( 0 , 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( 1 , 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def al ( num ) : <NEWLINE> <INDENT> if num == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif num == 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> flag = 0 <NEWLINE> result = list ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = re ( g [ i ] ) <NEWLINE> if r [ a ] == 0 and r [ b ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif r [ a ] > r [ b ] : <NEWLINE> <INDENT> r [ a ] -= 1 <NEWLINE> r [ b ] += 1 <NEWLINE> result . append ( al ( b ) ) <NEWLINE> <DEDENT> elif r [ a ] < r [ b ] : <NEWLINE> <INDENT> r [ a ] += 1 <NEWLINE> r [ b ] -= 1 <NEWLINE> result . append ( al ( a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i + 1 == n : <NEWLINE> <INDENT> r [ a ] += 1 <NEWLINE> r [ b ] -= 1 <NEWLINE> result . append ( al ( a ) ) <NEWLINE> break <NEWLINE> <DEDENT> x , y = re ( g [ i + 1 ] ) <NEWLINE> if ( x , y ) == ( a , b ) : <NEWLINE> <INDENT> r [ a ] += 1 <NEWLINE> r [ b ] -= 1 <NEWLINE> result . append ( al ( a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x in ( a , b ) : <NEWLINE> <INDENT> r [ x ] += 2 <NEWLINE> r [ a ] -= 1 ; r [ b ] -= 1 <NEWLINE> result . append ( al ( x ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r [ y ] += 2 <NEWLINE> r [ a ] -= 1 ; r [ b ] -= 1 <NEWLINE> result . append ( al ( y ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for item in result : <NEWLINE> <INDENT> print ( item ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> s = s [ : : - 1 ] <NEWLINE> l = len ( s ) <NEWLINE> count = [ 0 ] * 2019 <NEWLINE> res = 0 <NEWLINE> count [ res ] = 1 <NEWLINE> d = 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> res += int ( i ) * d <NEWLINE> res %= 2019 <NEWLINE> count [ res ] += 1 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> <DEDENT> print ( int ( sum ( [ m * ( m - 1 ) / 2 for m in count ] ) ) ) <NEWLINE>
from collections import deque <NEWLINE> def main ( ) : <NEWLINE> <INDENT> from sys import stdin <NEWLINE> readline = stdin . readline <NEWLINE> <NL> from builtins import max , min , range <NEWLINE> <NL> INF = 10 ** 6 <NEWLINE> <NL> H , W = map ( int , readline ( ) . split ( ) ) <NEWLINE> C1 , C2 = map ( lambda x : int ( x ) - 1 , readline ( ) . split ( ) ) <NEWLINE> D1 , D2 = map ( lambda x : int ( x ) - 1 , readline ( ) . split ( ) ) <NEWLINE> S = [ readline ( ) [ : - 1 ] for _ in range ( H ) ] <NEWLINE> <NL> <NL> <NL> t = [ [ INF ] * W for _ in range ( H ) ] <NEWLINE> <NL> <NL> for h in range ( H ) : <NEWLINE> <INDENT> Sh = S [ h ] <NEWLINE> th = t [ h ] <NEWLINE> for w in range ( W ) : <NEWLINE> <INDENT> if Sh [ w ] == <STRING> : <NEWLINE> <INDENT> th [ w ] = - 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> q = deque ( [ ( C1 , C2 ) ] ) <NEWLINE> a = 0 <NEWLINE> t [ C1 ] [ C2 ] = a <NEWLINE> <NL> while q : <NEWLINE> <INDENT> warpq = [ ] <NEWLINE> while q : <NEWLINE> <INDENT> h , w = q . popleft ( ) <NEWLINE> warpq . append ( ( h , w ) ) <NEWLINE> if 0 < h and t [ h - 1 ] [ w ] > a : <NEWLINE> <INDENT> t [ h - 1 ] [ w ] = a <NEWLINE> q . append ( ( h - 1 , w ) ) <NEWLINE> <DEDENT> if H - 1 > h and t [ h + 1 ] [ w ] > a : <NEWLINE> <INDENT> t [ h + 1 ] [ w ] = a <NEWLINE> q . append ( ( h + 1 , w ) ) <NEWLINE> <DEDENT> if 0 < w and t [ h ] [ w - 1 ] > a : <NEWLINE> <INDENT> t [ h ] [ w - 1 ] = a <NEWLINE> q . append ( ( h , w - 1 ) ) <NEWLINE> <DEDENT> if w < W - 1 and t [ h ] [ w + 1 ] > a : <NEWLINE> <INDENT> t [ h ] [ w + 1 ] = a <NEWLINE> q . append ( ( h , w + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if t [ D1 ] [ D2 ] != INF : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> a += 1 <NEWLINE> <NL> for h , w in warpq : <NEWLINE> <INDENT> for i in range ( max ( 0 , h - 2 ) , min ( H , h + 3 ) ) : <NEWLINE> <INDENT> ti = t [ i ] <NEWLINE> for j in range ( max ( 0 , w - 2 ) , min ( W , w + 3 ) ) : <NEWLINE> <INDENT> if ti [ j ] > a : <NEWLINE> <INDENT> ti [ j ] = a <NEWLINE> q . append ( ( i , j ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if t [ D1 ] [ D2 ] == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t [ D1 ] [ D2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> maxV = ( 10 ** 6 ) ** 2 <NEWLINE> <NL> i = 0 <NEWLINE> sevens = 0 <NEWLINE> while i < 10 ** 6 + 1 : <NEWLINE> <INDENT> sevens = sevens * 10 + 7 <NEWLINE> sevens = sevens % k <NEWLINE> i += 1 <NEWLINE> if sevens % k == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
s = input ( ) <NEWLINE> from collections import Counter <NEWLINE> x = 1 <NEWLINE> mod = 2019 <NEWLINE> total = 0 <NEWLINE> ans = 0 <NEWLINE> cnt = Counter ( ) <NEWLINE> for i in range ( len ( s ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> cnt [ total ] += 1 <NEWLINE> total = total + int ( s [ i ] ) * x <NEWLINE> total %= mod <NEWLINE> ans += cnt [ total ] <NEWLINE> x = x * 10 % 2019 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ai = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( ai ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> maxi = [ 0 for i in range ( m ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> maxi [ j ] += a [ i ] [ j + 1 ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if maxi [ i ] < x : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> mini = 100000000 <NEWLINE> <COMMENT> <NL> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> d = [ ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> d . append ( j ) <NEWLINE> <DEDENT> <DEDENT> b = [ 0 for j in range ( m ) ] <NEWLINE> <COMMENT> <NL> c = 0 <NEWLINE> <COMMENT> <NL> for j in d : <NEWLINE> <INDENT> c += a [ j ] [ 0 ] <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> b [ k ] += a [ j ] [ k + 1 ] <NEWLINE> <DEDENT> <DEDENT> l = 0 <NEWLINE> for j in b : <NEWLINE> <INDENT> if j < x : <NEWLINE> <INDENT> l = 1 <NEWLINE> <DEDENT> <DEDENT> if l == 0 : <NEWLINE> <INDENT> mini = min ( mini , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mini ) <NEWLINE>
<COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n = n // k <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def multipleSum ( A , n ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum += A [ i ] <NEWLINE> <DEDENT> mulsum = sum * sum <NEWLINE> insum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> insum += A [ i ] * A [ i ] <NEWLINE> <DEDENT> return ( mulsum - insum ) // 2 <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = len ( A ) <NEWLINE> print ( multipleSum ( A , n ) % 1000000007 ) <NEWLINE> <NL> <NL> <NL>
<COMMENT> <NL> H , W = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> while H != 0 or W != 0 : <NEWLINE> <INDENT> for i in range ( H - 1 ) : <NEWLINE> <INDENT> S = <STRING> <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> S += <STRING> <NEWLINE> <DEDENT> print ( S ) <NEWLINE> <DEDENT> S = <STRING> <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> S += <STRING> <NEWLINE> <DEDENT> print ( S , end = <STRING> ) <NEWLINE> H , W = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> print ( <STRING> ) <NEWLINE> <DEDENT>
MOD = 10 ** 9 + 7 <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> alst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> alst . sort ( ) <NEWLINE> <NL> if n == k : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for num in alst : <NEWLINE> <INDENT> ans *= num <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if k == 1 : <NEWLINE> <INDENT> print ( alst [ - 1 ] % MOD ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if alst [ 0 ] >= 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> alst . sort ( reverse = True ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= alst [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if alst [ - 1 ] <= 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> if k % 2 == 1 : <NEWLINE> <INDENT> alst = alst [ : : - 1 ] <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> ans *= alst [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> blst = [ ] <NEWLINE> for num in alst : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> blst . append ( [ abs ( num ) , abs ( num ) // num ] ) <NEWLINE> <DEDENT> except ZeroDivisionError : <NEWLINE> <INDENT> blst . append ( [ abs ( num ) , 0 ] ) <NEWLINE> <DEDENT> <DEDENT> blst . sort ( reverse = True , key = lambda x : x [ 0 ] ) <NEWLINE> if blst [ k - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> minus = 0 <NEWLINE> last_minus = 0 <NEWLINE> last_plus = 0 <NEWLINE> ans_lst = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if blst [ i ] [ 1 ] == - 1 : <NEWLINE> <INDENT> minus += 1 <NEWLINE> last_minus = blst [ i ] [ 0 ] <NEWLINE> <DEDENT> elif blst [ i ] [ 1 ] == 1 : <NEWLINE> <INDENT> last_plus = blst [ i ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans_lst . append ( blst [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> next_minus = 0 <NEWLINE> next_plus = 0 <NEWLINE> flg_minus = False <NEWLINE> flg_plus = False <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if blst [ i ] [ 1 ] == - 1 and ( not flg_minus ) : <NEWLINE> <INDENT> next_minus = blst [ i ] [ 0 ] <NEWLINE> flg_minus = True <NEWLINE> <DEDENT> if blst [ i ] [ 1 ] == 1 and ( not flg_plus ) : <NEWLINE> <INDENT> next_plus = blst [ i ] [ 0 ] <NEWLINE> flg_plus = True <NEWLINE> <DEDENT> if ( flg_plus and flg_minus ) or blst [ i ] [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if minus % 2 == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for num in ans_lst : <NEWLINE> <INDENT> ans *= num <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> minus_s = last_minus * next_minus <NEWLINE> plus_s = last_plus * next_plus <NEWLINE> ans = 1 <NEWLINE> if minus == k : <NEWLINE> <INDENT> ans_lst . remove ( last_minus ) <NEWLINE> ans_lst . append ( next_plus ) <NEWLINE> <DEDENT> elif minus_s == plus_s == 0 : <NEWLINE> <INDENT> if next_minus == 0 : <NEWLINE> <INDENT> ans_lst . remove ( last_minus ) <NEWLINE> ans_lst . append ( next_plus ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif minus_s > plus_s : <NEWLINE> <INDENT> ans_lst . remove ( last_plus ) <NEWLINE> ans_lst . append ( next_minus ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_lst . remove ( last_minus ) <NEWLINE> ans_lst . append ( next_plus ) <NEWLINE> <DEDENT> for num in ans_lst : <NEWLINE> <INDENT> ans *= num <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> count = [ 0 ] * ( K + 1 ) <NEWLINE> ans = 0 <NEWLINE> mod = 1000000007 <NEWLINE> for i in range ( K , 0 , - 1 ) : <NEWLINE> <INDENT> kosuu = pow ( K // i , N , mod ) <NEWLINE> if K // i >= 2 : <NEWLINE> <INDENT> for j in range ( K // i , 1 , - 1 ) : <NEWLINE> <INDENT> kosuu -= count [ j * i ] <NEWLINE> <DEDENT> <DEDENT> ans += i * kosuu <NEWLINE> count [ i ] = kosuu <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> totalPattern = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k > N - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if not S [ i ] == S [ j ] and not S [ i ] == S [ k ] and not S [ j ] == S [ k ] : <NEWLINE> <INDENT> totalPattern -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( totalPattern ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = sum ( A ) <NEWLINE> n = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> n += A [ i ] * ( B - A [ i ] ) <NEWLINE> B = B - A [ i ] <NEWLINE> <DEDENT> print ( n % ( 10 ** 9 + 7 ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] -= 1 <NEWLINE> <NL> <DEDENT> cnt = [ 0 ] * ( 2 * 10 ** 5 ) <COMMENT> <NEWLINE> cnt2 = [ 0 ] * ( 2 * 10 ** 5 ) <COMMENT> <NEWLINE> t = [ ] <NEWLINE> nxt = 0 <NEWLINE> loop = 0 <NEWLINE> <NL> for i in range ( 2 * 10 ** 5 ) : <NEWLINE> <INDENT> cnt [ nxt ] += 1 <NEWLINE> if cnt [ nxt ] >= 2 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> loop = i - cnt2 [ nxt ] <NEWLINE> modC = cnt2 [ nxt ] <NEWLINE> break <NEWLINE> <DEDENT> cnt2 [ nxt ] = i <NEWLINE> t . append ( nxt ) <NEWLINE> nxt = a [ nxt ] <NEWLINE> <NL> <DEDENT> modK = ( k - modC ) % loop <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if k < modC : <NEWLINE> <INDENT> print ( t [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t [ modC + modK ] + 1 ) <NEWLINE> <NL> <DEDENT> <STRING> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> <NL> <NL> count = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = j * 2 - i <NEWLINE> if 0 <= k < n : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - count ) <NEWLINE> <NL> <NL>
import math <NEWLINE> a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> saidai = 1 <NEWLINE> <NL> def yakusuu ( x , y ) : <NEWLINE> <INDENT> return ( y , x % y ) <NEWLINE> <NL> <DEDENT> def cont ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> saidai = math . gcd ( a , b ) <NEWLINE> <NL> <NL> d = cont ( saidai ) <NEWLINE> if d [ 0 ] == [ 1 , 1 ] : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( len ( d ) + 1 ) <NEWLINE>
s = input ( ) <NEWLINE> x = list ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> or s [ i ] == <STRING> or s [ i ] == <STRING> or s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if i == len ( s ) - 1 : <NEWLINE> <INDENT> x . append ( cnt ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> x . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max ( x ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> limit = 10 ** 18 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > limit : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> ab = 4 <NEWLINE> af = 3 <NEWLINE> ar = 10 <NEWLINE> <NL> data = [ [ [ 0 for i in range ( ar ) ] for j in range ( af ) ] for k in range ( ab ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> instr = input ( ) . split ( ) <NEWLINE> b = int ( instr [ 0 ] ) <NEWLINE> f = int ( instr [ 1 ] ) <NEWLINE> r = int ( instr [ 2 ] ) <NEWLINE> v = int ( instr [ 3 ] ) <NEWLINE> <NL> data [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for i in range ( ab ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> for j in range ( af ) : <NEWLINE> <INDENT> print ( <STRING> , * data [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N = input ( ) <NEWLINE> a = [ int ( n ) for n in N ] <NEWLINE> if int ( N ) % 9 == 0 and sum ( a ) % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> if A [ 0 ] == 0 : <NEWLINE> <INDENT> A . remove ( 0 ) <NEWLINE> <NL> <DEDENT> l = len ( A ) <NEWLINE> k = 0 <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> m = max ( A ) <NEWLINE> <NL> for i in range ( l - 1 ) : <NEWLINE> <INDENT> if A [ i + 1 ] > A [ i ] : <NEWLINE> <INDENT> k = A [ i ] <NEWLINE> print ( ans ) <NEWLINE> while A [ i + 1 ] != k + 1 : <NEWLINE> <INDENT> k = k + 1 <NEWLINE> print ( 0 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <DEDENT> <DEDENT> if A [ l - 1 ] == A [ l - 2 ] : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> for j in range ( m + 1 , N + 1 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> L = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> <NL> print ( sum ( L [ : K ] ) ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> import bisect <NEWLINE> from functools import lru_cache <NEWLINE> from collections import defaultdict <NEWLINE> inf = float ( <STRING> ) <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def read ( ) : <NEWLINE> <INDENT> return int ( readline ( ) ) <NEWLINE> <DEDENT> def reads ( ) : <NEWLINE> <INDENT> return map ( int , readline ( ) . split ( ) ) <NEWLINE> <DEDENT> n = read ( ) <NEWLINE> a = list ( reads ( ) ) <NEWLINE> num = 0 <NEWLINE> l = len ( a ) <NEWLINE> ls = [ ] <NEWLINE> k = 0 <NEWLINE> for i in range ( l - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> k += a [ i ] <NEWLINE> ls . append ( k ) <NEWLINE> <DEDENT> for i in range ( l - 1 ) : <NEWLINE> <INDENT> num += a [ i ] * ls [ - i - 1 ] <NEWLINE> <DEDENT> num %= 10 ** 9 + 7 <NEWLINE> print ( num ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> c = input ( ) <NEWLINE> c = c [ : len ( c ) - 1 ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> num = len ( c ) <NEWLINE> c_mae = <STRING> <NEWLINE> c_ato = <STRING> <NEWLINE> <NL> hantei = 1 <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> q_i = list ( input ( ) ) <NEWLINE> <COMMENT> <NL> if q_i [ 0 ] == <STRING> : <NEWLINE> <INDENT> hantei *= - 1 <NEWLINE> <DEDENT> elif ( q_i [ 2 ] == <STRING> and hantei == 1 ) or ( q_i [ 2 ] == <STRING> and hantei == - 1 ) : <NEWLINE> <INDENT> c_mae = q_i [ 4 ] + c_mae <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c_ato += q_i [ 4 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c_mae + c + c_ato if hantei == 1 else ( c_mae + c + c_ato ) [ : : - 1 ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> ans_num = 0 <NEWLINE> ans_list = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = N - i <NEWLINE> s = 0 <NEWLINE> for j in range ( tmp , N + 1 , tmp ) : <NEWLINE> <INDENT> s += ans [ j - 1 ] <NEWLINE> <NL> <DEDENT> if s % 2 != A [ tmp - 1 ] : <NEWLINE> <INDENT> ans [ tmp - 1 ] = 1 <NEWLINE> ans_num += 1 <NEWLINE> ans_list += str ( tmp ) <NEWLINE> ans_list += <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans_num ) <NEWLINE> print ( ans_list [ : - 1 ] ) <NEWLINE>
T = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> i = 0 <NEWLINE> N = len ( T ) <NEWLINE> if N == 1 and T == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> while i < N : <NEWLINE> <INDENT> if T [ i ] != <STRING> : <NEWLINE> <INDENT> ans = ans + T [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i > 0 and i < N - 1 : <NEWLINE> <INDENT> if ans [ - 1 ] == <STRING> : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> elif ans [ - 1 ] == <STRING> and T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> elif ans [ - 1 ] == <STRING> and T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> elif ans [ - 1 ] == <STRING> and T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> elif i == 0 : <NEWLINE> <INDENT> if T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> elif T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> <DEDENT> elif i == N - 1 : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from __future__ import division , print_function <NEWLINE> from sys import stdin <NEWLINE> <NL> FORMAT = ( <STRING> <NEWLINE> <INDENT> <STRING> ) . format <NEWLINE> <NL> <NL> <DEDENT> class Node ( object ) : <NEWLINE> <INDENT> def __init__ ( self , node ) : <NEWLINE> <INDENT> self . depth = 0 <NEWLINE> self . parent = - 1 <NEWLINE> self . id = node [ 0 ] <NEWLINE> self . degree = node [ 1 ] <NEWLINE> self . kind = <STRING> if node [ 1 ] else <STRING> <NEWLINE> self . childs = node [ 2 : ] <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return FORMAT ( self ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def calc_depth ( tree , i ) : <NEWLINE> <INDENT> for j in tree [ i ] . childs : <NEWLINE> <INDENT> tree [ j ] . depth += 1 <NEWLINE> calc_depth ( tree , j ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( stdin . readline ( ) ) <NEWLINE> tree = [ - 1 ] * n <NEWLINE> <COMMENT> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> node = Node ( [ int ( s ) for s in stdin . readline ( ) . split ( ) ] ) <NEWLINE> i = node . id <NEWLINE> node . parent = tree [ i ] <NEWLINE> for j in node . childs : <NEWLINE> <INDENT> if isinstance ( tree [ j ] , int ) : <NEWLINE> <INDENT> tree [ j ] = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree [ j ] . parent = i <NEWLINE> <DEDENT> <DEDENT> tree [ i ] = node <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> calc_depth ( tree , i ) <NEWLINE> <NL> <DEDENT> for i , node in enumerate ( tree ) : <NEWLINE> <INDENT> if node . parent == - 1 : <NEWLINE> <INDENT> node . kind = <STRING> <NEWLINE> <DEDENT> print ( node ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> count_array = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> count_array [ As [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> for i in range ( len ( As ) ) : <NEWLINE> <INDENT> sum += As [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> sum += count_array [ x ] * ( y - x ) <NEWLINE> print ( sum ) <NEWLINE> count_array [ y ] += count_array [ x ] <NEWLINE> count_array [ x ] = 0 <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( a , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = a + b <NEWLINE> c = n % d <NEWLINE> e = n // d <NEWLINE> <NL> if c <= a : <NEWLINE> <INDENT> print ( e * a + c ) <NEWLINE> <DEDENT> if c > a : <NEWLINE> <INDENT> print ( ( e + 1 ) * a ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <NL> print ( n * ( n - 1 ) // 2 ) <NEWLINE>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> S = list ( input ( ) ) <NEWLINE> n = len ( S ) <NEWLINE> <NL> dp = [ 0 ] * 2019 <NEWLINE> dp [ 0 ] = 1 <NEWLINE> tmp = 0 <NEWLINE> ten = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp += int ( S [ n - 1 - i ] ) * ten <NEWLINE> tmp %= 2019 <NEWLINE> ten *= 10 <NEWLINE> ten %= 2019 <NEWLINE> dp [ tmp % 2019 ] += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for i in dp : <NEWLINE> <INDENT> if i >= 2 : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = n // 2 <NEWLINE> INF = 10 ** 18 <NEWLINE> dp = [ defaultdict ( lambda : - INF ) for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i // 2 - 1 , ( i + 1 ) // 2 + 1 ) : <NEWLINE> <INDENT> if j == 1 : <NEWLINE> <INDENT> dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , A [ i - 1 ] ) <NEWLINE> <DEDENT> elif 0 <= i - 2 and 0 <= j <= m : <NEWLINE> <INDENT> dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i - 2 ] [ j - 1 ] + A [ i - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] [ m ] ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if X > 0 : <NEWLINE> <INDENT> S = int ( abs ( X ) / D ) <NEWLINE> aX = X - D * S <NEWLINE> if S >= K : <NEWLINE> <INDENT> print ( X - D * K ) <NEWLINE> <DEDENT> elif ( K - S ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( aX ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( aX - D ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> S = int ( abs ( X ) / D ) <NEWLINE> aX = X + D * S <NEWLINE> if S >= K : <NEWLINE> <INDENT> print ( abs ( X + D * K ) ) <NEWLINE> <DEDENT> elif ( K - S ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( aX ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( aX + D ) ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> from itertools import product <NEWLINE> n , s = int ( input ( ) ) , input ( ) <NEWLINE> <NL> r , g , b = 0 , 0 , 0 <NEWLINE> for x in s : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = r * g * b <NEWLINE> rgb = { <STRING> , <STRING> , <STRING> } <NEWLINE> for i in range ( 1 , n // 2 + 1 ) : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> x = s [ j : : i ] <NEWLINE> for a , b , c in zip ( x , x [ 1 : ] , x [ 2 : ] ) : <NEWLINE> <INDENT> g = { a , b , c } <NEWLINE> if g == rgb : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> r , c = [ int ( a ) for a in input ( ) . split ( <STRING> ) ] <NEWLINE> arr = [ ] <NEWLINE> Hsum = 0 <NEWLINE> for x in range ( r ) : <NEWLINE> <INDENT> i = [ int ( a ) for a in input ( ) . split ( <STRING> ) ] <NEWLINE> i . append ( sum ( i ) ) <NEWLINE> arr . append ( i ) <NEWLINE> <DEDENT> arr2 = [ ] <NEWLINE> for y in range ( c + 1 ) : <NEWLINE> <INDENT> for z in range ( r ) : <NEWLINE> <INDENT> Hsum += arr [ z ] [ y ] <NEWLINE> <DEDENT> arr2 . append ( Hsum ) <NEWLINE> Hsum = 0 <NEWLINE> <DEDENT> arr . append ( arr2 ) <NEWLINE> <NL> for y in range ( r + 1 ) : <NEWLINE> <INDENT> for z in range ( c + 1 ) : <NEWLINE> <INDENT> if z == c : <NEWLINE> <INDENT> print ( arr [ y ] [ z ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( arr [ y ] [ z ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> ans = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if dp [ i ] == 0 : <NEWLINE> <INDENT> for j in range ( i , 10 ** 6 + 1 , i ) : <NEWLINE> <INDENT> dp [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in A : <NEWLINE> <INDENT> if dp [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> N = sum ( N ) <NEWLINE> <NL> if N % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> data = [ 0 ] * n <NEWLINE> data [ 0 ] = 1 <NEWLINE> <NL> li = [ 0 ] <NEWLINE> <NL> while k > 0 : <NEWLINE> <INDENT> b = a [ li [ - 1 ] ] - 1 <NEWLINE> if data [ b ] == 0 : <NEWLINE> <INDENT> data [ b ] = 1 <NEWLINE> li . append ( b ) <NEWLINE> k -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if k != 0 : <NEWLINE> <INDENT> for i in range ( len ( li ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if li [ i ] == b : <NEWLINE> <INDENT> s = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> newli = li [ s : ] <NEWLINE> l = ( k - 1 ) % len ( newli ) <NEWLINE> print ( newli [ l ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( li [ - 1 ] + 1 ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> L , R = [ 0 ] * N , [ 0 ] * N <NEWLINE> for i , a in enumerate ( input ( ) . split ( ) ) : <NEWLINE> <INDENT> L [ i ] , R [ i ] = i + int ( a ) + 1 , i + 1 - int ( a ) <NEWLINE> <NL> <DEDENT> l = collections . Counter ( L ) <NEWLINE> r = collections . Counter ( R ) <NEWLINE> t = 0 <NEWLINE> for i in l . keys ( ) : <NEWLINE> <INDENT> t += l [ i ] * r [ i ] <NEWLINE> <NL> <DEDENT> print ( t ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a_list [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> p *= a_list [ i ] <NEWLINE> if p > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = 0 <NEWLINE> for i in range ( 0 , len ( L ) - 1 ) : <NEWLINE> <INDENT> if L [ i ] > L [ i + 1 ] : <NEWLINE> <INDENT> x = x + ( L [ i ] - L [ i + 1 ] ) <NEWLINE> L [ i + 1 ] = L [ i + 1 ] + ( L [ i ] - L [ i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE> <NL> <NL> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> min_p = abs ( x ) // d <NEWLINE> min_n = min_p + 1 <NEWLINE> rest_p = abs ( x ) - d * min_p <NEWLINE> rest_n = rest_p - d <NEWLINE> <NL> if k < min_p : <NEWLINE> <INDENT> print ( abs ( x ) - k * d ) <NEWLINE> <DEDENT> elif ( k - min_p ) % 2 == 0 : <NEWLINE> <INDENT> print ( rest_p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( rest_n ) ) <NEWLINE> <NL> <NL> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = dict ( ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> dic [ i ] = 0 <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> dic [ a ] += 1 <NEWLINE> <NL> <DEDENT> for v in dic . values ( ) : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( k , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> def better ( l , ans ) : <NEWLINE> <INDENT> for i in range ( 2 , n ) : <NEWLINE> <INDENT> ans [ i ] = min ( ans [ i - 1 ] + abs ( l [ i ] - l [ i - 1 ] ) , ans [ i - 2 ] + abs ( l [ i ] - l [ i - 2 ] ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> ans [ 1 ] = abs ( l [ 1 ] - l [ 0 ] ) <NEWLINE> print ( better ( l , ans ) [ len ( ans ) - 1 ] ) <NEWLINE>
ans = 1 <NEWLINE> n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n < b : <NEWLINE> <INDENT> ans = a * n // b <NEWLINE> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif n == b : <NEWLINE> <INDENT> ans = a * ( b - 1 ) // b <NEWLINE> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> r = n // b <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> t = r * b - 1 <NEWLINE> ans_t = a * t // b - ( a * ( r - 1 ) ) <NEWLINE> ans = max ( ans , ans_t ) <NEWLINE> <NL> ans_t = a * n // b - ( a * ( n // b ) ) <NEWLINE> ans = max ( ans , ans_t ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
from math import floor <NEWLINE> <NL> A , B , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> x = None <NEWLINE> if N < B : <NEWLINE> <INDENT> x = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = B <NEWLINE> x = B - 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> answer = floor ( A * x / B ) - A * floor ( x / B ) <NEWLINE> <NL> print ( answer ) <NEWLINE>
import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ARR2 = np . zeros ( ( H , W ) ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> ARR2 [ i ] [ j ] == 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ARR2 [ i ] [ j ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def calclulate ( h , w , k , arr ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> hIndex = [ i for i in range ( h ) ] <NEWLINE> wIndex = [ i for i in range ( w ) ] <NEWLINE> <NL> for hChooseNum in range ( h + 1 ) : <NEWLINE> <INDENT> for wChooseNum in range ( w + 1 ) : <NEWLINE> <INDENT> for m in itertools . combinations ( hIndex , hChooseNum ) : <NEWLINE> <INDENT> for n in itertools . combinations ( wIndex , wChooseNum ) : <NEWLINE> <NL> <INDENT> tmpArr = arr . copy ( ) <NEWLINE> <NL> for _m in m : <NEWLINE> <INDENT> tmpArr [ _m , : ] = 0 <NEWLINE> <DEDENT> for _n in n : <NEWLINE> <INDENT> tmpArr [ : , _n ] = 0 <NEWLINE> <NL> <DEDENT> if np . sum ( tmpArr == 1 ) == k : <NEWLINE> <INDENT> result += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> calclulate ( H , W , K , ARR2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> p = N <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if p >= P [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> p = P [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> _ , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> LIM = 10 ** 18 <NEWLINE> for i in A : <NEWLINE> <INDENT> prod *= i <NEWLINE> if prod > LIM : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> dp = [ 0 ] * ( 10 ** 5 + 10 ) <NEWLINE> <NL> bc = [ input ( ) for _ in range ( q ) ] <NEWLINE> <NL> for ai in a : <NEWLINE> <INDENT> dp [ ai ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , len ( dp ) ) : <NEWLINE> <INDENT> ans += dp [ i ] * i <NEWLINE> <NL> <DEDENT> for bci in bc : <NEWLINE> <INDENT> b , c = map ( int , bci . split ( ) ) <NEWLINE> ans += ( dp [ b ] * c ) - ( dp [ b ] * b ) <NEWLINE> print ( ans ) <NEWLINE> dp [ c ] += dp [ b ] <NEWLINE> dp [ b ] = 0 <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> p = 100 <NEWLINE> t , si = 0 , 0 <NEWLINE> while ( p < x ) : <NEWLINE> <INDENT> si = p // 100 <NEWLINE> p += si <NEWLINE> t += 1 <NEWLINE> <DEDENT> print ( t ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> save = [ ] <NEWLINE> isSaved = [ False ] * ( n + 1 ) <NEWLINE> s_queue = [ [ 1 , 0 ] ] <NEWLINE> while ( len ( s_queue ) > 0 ) : <NEWLINE> <INDENT> i , cnt = s_queue . pop ( ) <NEWLINE> if ( cnt == k ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( isSaved [ i ] ) : <NEWLINE> <INDENT> last = mp [ i - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> nexti = mp [ i - 1 ] <NEWLINE> isSaved [ i ] = True <NEWLINE> save . append ( nexti ) <NEWLINE> s_queue . append ( [ nexti , cnt + 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> ls = len ( save ) <NEWLINE> <NL> if ( k <= ls ) : <NEWLINE> <INDENT> print ( save [ k - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( ls ) : <NEWLINE> <INDENT> if ( save [ i ] == last ) : <NEWLINE> <INDENT> si = i <NEWLINE> <DEDENT> <DEDENT> k -= si <NEWLINE> save = save [ si : ] <NEWLINE> ls = len ( save ) <NEWLINE> amari = k % ls <NEWLINE> print ( save [ amari - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> check = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if check [ a ] != 0 : <NEWLINE> <INDENT> check [ a ] += 1 <NEWLINE> continue <NEWLINE> <DEDENT> for i in range ( 10 ** 6 + 1 ) [ a : : a ] : <NEWLINE> <INDENT> check [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if check [ a ] == 1 : cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans_list = [ 0 for _ in range ( N - 1 ) ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <COMMENT> <NEWLINE> <INDENT> for j in range ( i + 1 , N + 1 ) : <COMMENT> <NEWLINE> <INDENT> ans1 = j - i <NEWLINE> ans2 = abs ( i - X ) + 1 + abs ( j - Y ) <NEWLINE> ans_list [ min ( ans1 , ans2 ) - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( * ans_list , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += i * ( ( N // i ) * ( ( N // i ) + 1 ) ) / 2 <NEWLINE> <NL> <DEDENT> print ( ( int ) ( ans ) ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> word = sys . stdin . read ( ) . lower ( ) <NEWLINE> for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( chr ( i ) , word . count ( chr ( i ) ) ) ) <NEWLINE> <NL> <DEDENT>
import random <NEWLINE> <NL> def down_score ( d , c , last_d , score ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> sum = sum + c [ i ] * ( d - last_d [ i ] ) <NEWLINE> <NL> <DEDENT> return int ( score - sum ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> D = int ( input ( ) ) <NEWLINE> <NL> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( D ) ] <NEWLINE> <NL> sche = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> sche . append ( x ) <NEWLINE> <NL> <DEDENT> last_d = [ 0 for i in range ( 26 ) ] <NEWLINE> score = 0 <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> score += s [ i ] [ sche [ i ] - 1 ] <NEWLINE> last_d [ sche [ i ] - 1 ] = i + 1 <NEWLINE> score = down_score ( i + 1 , c , last_d , score ) <NEWLINE> print ( score ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s in dic : <NEWLINE> <INDENT> dic [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ s ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> sai = max ( dic . values ( ) ) <NEWLINE> <NL> for j in sorted ( k for k in dic if dic [ k ] == sai ) : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
bitcount = [ bin ( i ) . count ( <STRING> ) for i in range ( 0x10000 ) ] <NEWLINE> def solve ( a , b ) : <NEWLINE> <INDENT> global bitcount <NEWLINE> b = [ 65535 ^ bi for bi in b ] <NEWLINE> pdp = { a [ 0 ] : 0 } <NEWLINE> ndp = { } <NEWLINE> for ai in a [ 1 : ] + [ 0 ] : <NEWLINE> <INDENT> for k , v in pdp . items ( ) : <NEWLINE> <INDENT> v += bitcount [ k ] <NEWLINE> for bi in b : <NEWLINE> <INDENT> bi &= k <NEWLINE> vb = v - bitcount [ bi ] <NEWLINE> bi |= ai <NEWLINE> try : <NEWLINE> <INDENT> if ndp [ bi ] < vb : <NEWLINE> <INDENT> ndp [ bi ] = vb <NEWLINE> <DEDENT> <DEDENT> except KeyError : <NEWLINE> <INDENT> ndp [ bi ] = vb <NEWLINE> <DEDENT> <DEDENT> <DEDENT> pdp , ndp = ndp , { } <NEWLINE> <NL> <DEDENT> return max ( pdp . values ( ) ) <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> <NL> while True : <NEWLINE> <INDENT> n , c = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> if n == c == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = [ int ( <STRING> . join ( f . readline ( ) . split ( ) ) , 2 ) for i in range ( n ) ] <NEWLINE> b = [ int ( <STRING> . join ( f . readline ( ) . split ( ) ) , 2 ) for i in range ( c ) ] <NEWLINE> print ( solve ( a , b ) ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N >= B : <NEWLINE> <INDENT> print ( int ( A * ( B - 1 ) / B ) - A * int ( ( B - 1 ) / B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( A * ( N ) / B ) - A * int ( N / B ) ) <NEWLINE> <DEDENT>
from functools import reduce <NEWLINE> import numpy as np <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> def mat ( list ) : <NEWLINE> <INDENT> return reduce ( lambda a , b : a * b % mod , list ) <NEWLINE> <NL> <NL> <DEDENT> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = np . array ( sorted ( A , key = abs , reverse = True ) ) <NEWLINE> A_pn = A < 0 <NEWLINE> if N == np . count_nonzero ( A_pn ) : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> print ( mat ( A [ : K ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mat ( A [ - K : ] ) ) <NEWLINE> <DEDENT> <DEDENT> elif np . count_nonzero ( A_pn [ : K ] ) % 2 == 0 : <NEWLINE> <INDENT> print ( mat ( A [ : K ] ) ) <NEWLINE> <DEDENT> elif N == K : <NEWLINE> <INDENT> print ( mat ( A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> negative_all = np . where ( A_pn ) [ 0 ] <NEWLINE> negative_rest = np . count_nonzero ( negative_all >= K ) <NEWLINE> if negative_rest == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> A [ negative_all [ - 1 ] ] = A [ K ] <NEWLINE> print ( mat ( A [ : K ] ) ) <NEWLINE> <DEDENT> elif negative_rest == N - K : <NEWLINE> <COMMENT> <NL> <INDENT> last_positive = np . where ( A_pn [ : K ] == False ) [ 0 ] [ - 1 ] <NEWLINE> A [ last_positive ] = A [ K ] <NEWLINE> print ( mat ( A [ : K ] ) ) <NEWLINE> <DEDENT> elif len ( negative_all ) - negative_rest == K : <NEWLINE> <COMMENT> <NL> <INDENT> last_negative = negative_all [ negative_all < K ] [ - 1 ] <NEWLINE> next_positive = np . where ( A_pn == False ) [ 0 ] [ 0 ] <NEWLINE> A [ last_negative ] = A [ next_positive ] <NEWLINE> print ( mat ( A [ : K ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> last_negative = negative_all [ negative_all < K ] [ - 1 ] <NEWLINE> next_negative = negative_all [ negative_all >= K ] [ 0 ] <NEWLINE> positive_all = np . where ( A_pn == False ) [ 0 ] <NEWLINE> last_positive = positive_all [ positive_all < K ] [ - 1 ] <NEWLINE> next_positive = positive_all [ positive_all >= K ] [ 0 ] <NEWLINE> if A [ last_negative ] * A [ next_negative ] > A [ last_positive ] * A [ next_positive ] : <NEWLINE> <INDENT> A [ last_positive ] = A [ next_negative ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ last_negative ] = A [ next_positive ] <NEWLINE> <DEDENT> print ( mat ( A [ : K ] ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = int ( input ( ) , 2 ) <NEWLINE> <NL> def popcount ( n ) : <NEWLINE> <INDENT> return bin ( n ) . count ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def f ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> count = 1 <NEWLINE> while n != 0 : <NEWLINE> <INDENT> n = n % popcount ( n ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> return count <NEWLINE> <NL> <NL> <DEDENT> X_popcount = popcount ( X ) <NEWLINE> X_mod_p = X % ( X_popcount + 1 ) <NEWLINE> if X_popcount != 1 : <NEWLINE> <INDENT> X_mod_m = X % ( X_popcount - 1 ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> X_i = X ^ ( 1 << ( N - i - 1 ) ) <NEWLINE> if X_i == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif X >> ( N - i - 1 ) & 1 == 1 : <NEWLINE> <INDENT> if X_popcount == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = f ( ( X_mod_m - pow ( 2 , N - i - 1 , X_popcount - 1 ) ) % ( X_popcount - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = f ( ( X_mod_p + pow ( 2 , N - i - 1 , X_popcount + 1 ) ) % ( X_popcount + 1 ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> ans = 1 <NEWLINE> <NL> if a . count ( <STRING> ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * int ( a [ i ] ) <NEWLINE> if ans > ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans_ = gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( ans_ , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) - 1 ) <NEWLINE> <DEDENT> flag = True <NEWLINE> step = [ ] <NEWLINE> pivot = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> step . append ( pivot ) <NEWLINE> if a [ pivot ] == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> pivot = a [ pivot ] <NEWLINE> <NL> <DEDENT> if len ( step ) > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( step ) ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> print ( x // 3600 , x % 3600 // 60 , x % 60 , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> from collections import deque <NEWLINE> <NL> s = deque ( s ) <NEWLINE> <NL> rev = 1 <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> Q = list ( input ( ) . split ( ) ) <NEWLINE> if Q [ 0 ] == <STRING> : <NEWLINE> <INDENT> rev *= - 1 <NEWLINE> <DEDENT> elif Q [ 0 ] == <STRING> : <NEWLINE> <INDENT> if ( Q [ 1 ] == <STRING> and rev == 1 ) or ( Q [ 1 ] == <STRING> and rev == - 1 ) : <NEWLINE> <INDENT> s . appendleft ( Q [ 2 ] ) <NEWLINE> <DEDENT> elif ( Q [ 1 ] == <STRING> and rev == 1 ) or ( Q [ 1 ] == <STRING> and rev == - 1 ) : <NEWLINE> <INDENT> s . append ( Q [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> s = <STRING> . join ( s ) <NEWLINE> <NL> if rev == - 1 : <NEWLINE> <INDENT> s = s [ : : - 1 ] <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> a = [ 0 ] * 1000 <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> tmp = i ** 5 <NEWLINE> a [ i ] = tmp <NEWLINE> <DEDENT> for i in range ( 1000 ) : <NEWLINE> <INDENT> for j in range ( 1000 ) : <NEWLINE> <INDENT> if ( ( a [ i ] - x ) == ( a [ j ] ) ) : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif ( x - a [ i ] == a [ j ] ) : <NEWLINE> <INDENT> print ( i , - j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> <COMMENT> <NL> ans = A [ 0 ] <NEWLINE> if N >= 3 : <NEWLINE> <INDENT> a = ( N - 2 ) // 2 <NEWLINE> b = ( N - 2 ) % 2 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if b == 0 : <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> ans += ( A [ i + 1 ] * 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> ans += ( A [ i + 1 ] * 2 ) <NEWLINE> <DEDENT> ans += A [ a + 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> leg = 0 <NEWLINE> for i in range ( 0 , a + 1 ) : <NEWLINE> <INDENT> if 2 * i + 4 * ( a - i ) == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> <NL> m = 360 * M / 60 <NEWLINE> h = 360 * H / 12 + 30 * M / 60 <NEWLINE> <NL> if m >= h : <NEWLINE> <INDENT> p = m - h <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <INDENT> p = h - m <NEWLINE> <NL> <NL> <DEDENT> if p == 0 : <NEWLINE> <INDENT> print ( abs ( A - B ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <INDENT> l = math . radians ( p ) <NEWLINE> <NL> ans = ( A ** 2 + B ** 2 - 2 * A * B * math . cos ( l ) ) ** ( 1 / 2 ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> rootList = [ - 1 for i in range ( n ) ] <NEWLINE> <NL> def getRoot ( x ) : <NEWLINE> <INDENT> r = rootList [ x ] <NEWLINE> if r < 0 : <NEWLINE> <INDENT> rootList [ x ] = x <NEWLINE> <DEDENT> elif r != x : <NEWLINE> <INDENT> rootList [ x ] = getRoot ( r ) <NEWLINE> <DEDENT> return rootList [ x ] <NEWLINE> <NL> <NL> <DEDENT> def setSameRoot ( x , y ) : <NEWLINE> <INDENT> x = getRoot ( x ) <NEWLINE> y = getRoot ( y ) <NEWLINE> if x != y : <NEWLINE> <INDENT> rootList [ x ] = rootList [ y ] = min ( x , y ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> setSameRoot ( s , t ) <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if getRoot ( s ) == getRoot ( t ) else <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> from itertools import accumulate <NEWLINE> from itertools import permutations <NEWLINE> from itertools import combinations <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> import fractions <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> from bisect import bisect_left <NEWLINE> from bisect import bisect_right <NEWLINE> from bisect import insort_left <NEWLINE> import itertools <NEWLINE> from heapq import heapify <NEWLINE> from heapq import heappop <NEWLINE> from heapq import heappush <NEWLINE> import heapq <NEWLINE> from copy import deepcopy <NEWLINE> from decimal import Decimal <NEWLINE> alf = list ( <STRING> ) <NEWLINE> ALF = list ( <STRING> ) <NEWLINE> <COMMENT> <NL> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> table = [ 0 ] * ( N + 5 ) <NEWLINE> table [ 1 ] = 1 <NEWLINE> for i in range ( 2 , N + 3 ) : <NEWLINE> <INDENT> num = i <NEWLINE> cnt = 0 <NEWLINE> while num != 0 : <NEWLINE> <INDENT> a = num % 2 <NEWLINE> num = num // 2 <NEWLINE> cnt += a <NEWLINE> <DEDENT> p = i % cnt <NEWLINE> table [ i ] = table [ p ] + 1 <NEWLINE> <DEDENT> c = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> p = 0 <NEWLINE> q = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ss = S [ N - 1 - i ] <NEWLINE> p += int ( ss ) * pow ( 2 , i , c + 1 ) <NEWLINE> if c != 1 : <NEWLINE> <INDENT> q += int ( ss ) * pow ( 2 , i , c - 1 ) <NEWLINE> <DEDENT> p %= ( c + 1 ) <NEWLINE> if c != 1 : <NEWLINE> <INDENT> q %= ( c - 1 ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ss = S [ i ] <NEWLINE> if ss == <STRING> : <NEWLINE> <INDENT> ans = ( p + pow ( 2 , N - 1 - i , c + 1 ) ) % ( c + 1 ) <NEWLINE> print ( table [ ans ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if c == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if c != 1 : <NEWLINE> <INDENT> ans = ( q - pow ( 2 , N - 1 - i , c - 1 ) ) % ( c - 1 ) <NEWLINE> print ( table [ ans ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
s = input ( ) [ : : - 1 ] <COMMENT> <NEWLINE> <NL> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> <NL> num , d = 0 , 1 <NEWLINE> <NL> for char in s : <NEWLINE> <INDENT> num += int ( char ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> counts [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in counts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <COMMENT> <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) + 1 <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , k ) : <NEWLINE> <INDENT> for b in range ( 1 , k ) : <NEWLINE> <INDENT> d = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k ) : <NEWLINE> <INDENT> ans += math . gcd ( d , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
try : <NEWLINE> <INDENT> age , money = map ( int , input ( ) . split ( ) ) <NEWLINE> assert 0 <= age <= 100 and 2 <= money <= 1000 and money % 2 == 0 <NEWLINE> if age <= 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 6 <= age <= 12 : <NEWLINE> <INDENT> print ( money // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( money ) <NEWLINE> <DEDENT> <DEDENT> except AssertionError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> for a in range ( - 120 , 120 ) : <NEWLINE> <INDENT> f_a = a ** 5 <NEWLINE> r_b = ( x - f_a ) ** ( 1 / 5 ) . real <NEWLINE> b = round ( r_b . real ) <NEWLINE> if f_a - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> b *= - 1 <NEWLINE> if f_a - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = Counter ( a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> b = [ 0 for _ in range ( q ) ] <NEWLINE> c = [ 0 for _ in range ( q ) ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b [ i ] , c [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> ans = sum ( a ) <NEWLINE> for num , rep in zip ( b , c ) : <NEWLINE> <INDENT> ans += ( rep * X [ num ] - num * X [ num ] ) <NEWLINE> X [ rep ] += X [ num ] <NEWLINE> del ( X [ num ] ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if ( 0 in an ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in an : <NEWLINE> <NL> <INDENT> ans *= i <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> <NL> inv = [ 0 , 1 ] <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> inv . append ( ( - inv [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> <NL> <DEDENT> if N == 1 : <NEWLINE> <INDENT> print ( M ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> m = [ 1 ] <NEWLINE> s = 1 <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> s = s * ( M - 1 ) % mod <NEWLINE> m . append ( s ) <NEWLINE> <NL> <DEDENT> ncombi = [ 1 ] <NEWLINE> c = 1 <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> c = c * ( N - 1 - k ) * inv [ k + 1 ] <NEWLINE> c %= mod <NEWLINE> ncombi . append ( c ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for k in range ( K + 1 ) : <NEWLINE> <INDENT> ans = ans + m [ - k - 1 ] * ncombi [ k ] <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> ans = ans * M % mod <NEWLINE> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] * ( N + 1 ) <NEWLINE> b = [ 0 ] * ( M + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> a [ i ] = a [ i - 1 ] + A [ i - 1 ] <NEWLINE> <DEDENT> for j in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> b [ j ] = b [ j - 1 ] + B [ j - 1 ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if K - a [ i ] < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> w , h = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if w == h == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> field = [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( h ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for x in range ( w ) : <NEWLINE> <INDENT> for y in range ( h ) : <NEWLINE> <INDENT> if field [ y ] [ x ] > 0 : <NEWLINE> <INDENT> stack = [ ] <NEWLINE> mark ( field , w , h , x , y , stack ) <NEWLINE> while stack : <NEWLINE> <INDENT> p , q = stack . pop ( ) <NEWLINE> mark ( field , w , h , p , q , stack ) <NEWLINE> <NL> <DEDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return True <NEWLINE> <NL> <NL> <NL> <DEDENT> def mark ( field , w , h , x , y , stack ) : <NEWLINE> <INDENT> if x < 0 or x >= w or y < 0 or y >= h : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if field [ y ] [ x ] != 1 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> field [ y ] [ x ] = - 1 <NEWLINE> <NL> stack . append ( ( x + 1 , y + 1 ) ) <NEWLINE> stack . append ( ( x + 1 , y ) ) <NEWLINE> stack . append ( ( x + 1 , y - 1 ) ) <NEWLINE> stack . append ( ( x , y + 1 ) ) <NEWLINE> stack . append ( ( x , y ) ) <NEWLINE> stack . append ( ( x , y - 1 ) ) <NEWLINE> stack . append ( ( x - 1 , y + 1 ) ) <NEWLINE> stack . append ( ( x - 1 , y ) ) <NEWLINE> stack . append ( ( x - 1 , y - 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> while solve ( ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i , j in enumerate ( a ) : <NEWLINE> <INDENT> ans [ j - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
def abc175_c_1 ( ) : <NEWLINE> <INDENT> x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def solve ( x , k , d ) : <NEWLINE> <COMMENT> <NL> <INDENT> x = abs ( x ) <NEWLINE> <NL> <COMMENT> <NL> if k < ( x // d ) : <NEWLINE> <INDENT> return x - ( k * d ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> current_x = x - d * ( x // d ) <NEWLINE> k = k - ( x // d ) <NEWLINE> <NL> <COMMENT> <NL> <NL> if ( k % 2 ) == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> return current_x <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> return abs ( current_x - d ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = solve ( x , k , d ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> abc175_c_1 ( ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> a = S // ( 60 * 60 ) <NEWLINE> b = ( S - ( a * 60 * 60 ) ) // 60 <NEWLINE> c = S - ( a * 60 * 60 + b * 60 ) <NEWLINE> print ( a , <STRING> , b , <STRING> , c , sep = <STRING> ) <NEWLINE>
H , W , M , * HW = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> HW = list ( zip ( * [ iter ( HW ) ] * 2 ) ) <NEWLINE> <NL> A = [ 0 ] * ( H + 1 ) <NEWLINE> B = [ 0 ] * ( W + 1 ) <NEWLINE> for h , w in HW : <NEWLINE> <INDENT> A [ h ] += 1 <NEWLINE> B [ w ] += 1 <NEWLINE> <NL> <DEDENT> a = max ( A ) <NEWLINE> b = max ( B ) <NEWLINE> <NL> cnt = A . count ( a ) * B . count ( b ) - len ( [ 0 for h , w in HW if A [ h ] == a and B [ w ] == b ] ) <NEWLINE> <NL> print ( a + b - ( cnt == 0 ) ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> section = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( K ) ] <NEWLINE> MOD = 998244353 <NEWLINE> <NL> dp = np . zeros ( N + 1 , dtype = np . int64 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> cumsum = np . zeros ( N + 1 , dtype = np . int64 ) <NEWLINE> cumsum [ 1 ] = 1 <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> for left_section , right_section in section : <NEWLINE> <INDENT> left = max ( i - right_section - 1 , 0 ) <NEWLINE> right = i - left_section <NEWLINE> if right < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] += cumsum [ right ] - cumsum [ left ] <NEWLINE> <DEDENT> cumsum [ i ] = cumsum [ i - 1 ] + dp [ i ] <NEWLINE> dp [ i ] %= MOD <NEWLINE> cumsum [ i ] %= MOD <NEWLINE> <DEDENT> print ( dp [ N ] % MOD ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> an = [ int ( num ) for num in input ( ) . split ( ) ] <NEWLINE> <NL> if 0 in an : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> answer = 1 <NEWLINE> check = 10 ** 18 <NEWLINE> for i in range ( len ( an ) ) : <NEWLINE> <INDENT> answer *= an [ i ] <NEWLINE> if answer > check : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> if 0 in S : <NEWLINE> <INDENT> l = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = 1 <NEWLINE> for s in S : <NEWLINE> <INDENT> l = l * s <NEWLINE> if l > 10 ** 18 : <NEWLINE> <INDENT> l = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> import itertools <NEWLINE> from math import gcd <NEWLINE> from math import sqrt <NEWLINE> from sys import stdin <NEWLINE> def input ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def mips ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def ii ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , K = mips ( ) <NEWLINE> ans = 0 <NEWLINE> P = [ p for p in mips ( ) ] <NEWLINE> P . sort ( ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans += P [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> B [ i ] = A [ i - 1 ] + B [ i - 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += A [ i ] * ( B [ N ] - B [ i + 1 ] ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> a = <STRING> <NEWLINE> ans = 0 <NEWLINE> amari = 10 <NEWLINE> <NL> if K % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if K % 7 == 0 : <NEWLINE> <INDENT> L = 9 * K // 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = 9 * K <NEWLINE> <NL> <DEDENT> for p in range ( 10 ** 6 ) : <NEWLINE> <INDENT> if amari % L == 1 : <NEWLINE> <INDENT> print ( p + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> amari = ( amari * 10 ) % L <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> <NL> if ( ( k % 2 == 0 ) or ( k % 5 == 0 ) ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if k % 7 == 0 : <NEWLINE> <INDENT> d = ( 9 * k ) // 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = 9 * k <NEWLINE> <NL> <DEDENT> res = 10 <NEWLINE> <NL> for i in range ( 1 , 100000000 ) : <NEWLINE> <INDENT> if res % d == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = ( res % d ) * 10 <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mul = 1 <NEWLINE> if 0 in A : print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> mul *= A [ i ] <NEWLINE> if mul > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif i == N - 1 : print ( mul ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <DEDENT> print ( 0 ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> g = math . gcd ( a , b ) <NEWLINE> if g == 1 : <NEWLINE> <INDENT> total += n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for c in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> total += math . gcd ( g , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if K == 1 : <NEWLINE> <INDENT> for a , b in zip ( A [ : - 1 ] , A [ 1 : ] ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if not ( 0 in l ) : <NEWLINE> <INDENT> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> a = a * l [ i ] <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> a = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( a ) <NEWLINE> ans = 0 <NEWLINE> <NL> for k , v in c . items ( ) : <NEWLINE> <INDENT> if k > v : <NEWLINE> <INDENT> ans += v <NEWLINE> <DEDENT> if k < v : <NEWLINE> <INDENT> ans += v - k <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> wa = sum ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> wa -= a [ i ] <NEWLINE> ans = ( ans + ( wa * a [ i ] ) ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = [ 0 ] * n <NEWLINE> for x in range ( 1 , n ) : <NEWLINE> <INDENT> a [ x ] += a [ x - 1 ] <NEWLINE> if s [ x - 1 ] == <STRING> and s [ x ] == <STRING> : <NEWLINE> <INDENT> a [ x ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for y in range ( q ) : <NEWLINE> <NL> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = a [ r - 1 ] - a [ l - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> R = [ ] <NEWLINE> G = [ ] <NEWLINE> B = [ ] <NEWLINE> lr = 0 <NEWLINE> lg = 0 <NEWLINE> lb = 0 <NEWLINE> ncount = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R . append ( i ) <NEWLINE> lr += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> G . append ( i ) <NEWLINE> lg += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( i ) <NEWLINE> lb += 1 <NEWLINE> <DEDENT> if i < N / 2 : <NEWLINE> <INDENT> for j in range ( i + 1 ) : <NEWLINE> <INDENT> if S [ i - j ] != S [ i ] : <NEWLINE> <INDENT> if S [ i - j ] != S [ i + j ] : <NEWLINE> <INDENT> if S [ i + j ] != S [ i ] : <NEWLINE> <INDENT> ncount += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( N - i ) : <NEWLINE> <INDENT> if S [ i - j ] != S [ i ] : <NEWLINE> <INDENT> if S [ i - j ] != S [ i + j ] : <NEWLINE> <INDENT> if S [ i + j ] != S [ i ] : <NEWLINE> <INDENT> ncount += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( lr * lg * lb - ncount ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> b = [ True for i in range ( a [ - 1 ] + 1 ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i , j in enumerate ( a ) : <NEWLINE> <INDENT> if b [ j ] : <NEWLINE> <INDENT> t = 1 <NEWLINE> while j * t < len ( b ) : <NEWLINE> <INDENT> b [ j * t ] = False <NEWLINE> t += 1 <NEWLINE> <NL> <DEDENT> if i == n - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif j != a [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> K = [ 0 ] * N <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> K [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in K : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = i - A [ i ] <NEWLINE> y = i + A [ i ] <NEWLINE> if x in dic : <NEWLINE> <INDENT> ans += dic [ x ] <NEWLINE> <DEDENT> if y in dic : <NEWLINE> <INDENT> dic [ y ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ y ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def insertionSort ( A , n , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> G = [ int ( pow ( 4 , i ) + 3 * pow ( 2 , i - 1 ) + 1 ) for i in range ( 10 ) [ : : - 1 ] ] + [ 1 ] <NEWLINE> G = [ v for v in G if v <= n ] <NEWLINE> m = len ( G ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> insertionSort ( A , n , G [ i ] ) <NEWLINE> <DEDENT> print ( m ) <NEWLINE> print ( * G ) <NEWLINE> print ( cnt ) <NEWLINE> print ( * A , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ 0 ] * 30 <NEWLINE> t = [ 1 ] * 30 <NEWLINE> for i in range ( 29 ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] * 2 <NEWLINE> <DEDENT> ss = a [ 0 ] <NEWLINE> for j in range ( N - 1 ) : <NEWLINE> <INDENT> ss = ss ^ a [ j + 1 ] <NEWLINE> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> print ( a [ j ] ^ ss , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab [ a - 1 ] = max ( ab [ a - 1 ] , H [ b - 1 ] ) <NEWLINE> ab [ b - 1 ] = max ( ab [ b - 1 ] , H [ a - 1 ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ab [ i ] < H [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit , b1 , i4 , i8 , f8 <NEWLINE> <NL> @ njit ( ( i8 [ : ] , i8 , i8 , i8 ) , cache = True ) <NEWLINE> def solve ( items , R , C , K ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> grid = np . zeros ( ( R , C ) , np . int64 ) <NEWLINE> <NL> for i in range ( 0 , 3 * K , 3 ) : <NEWLINE> <INDENT> x , y , v = items [ i : i + 3 ] <NEWLINE> grid [ x - 1 , y - 1 ] = v <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> dp = np . zeros ( ( R , C , 4 ) , np . int64 ) <NEWLINE> maxx = np . zeros ( ( R , C ) , np . int64 ) <NEWLINE> <NL> if grid [ 0 , 0 ] > 0 : <NEWLINE> <INDENT> dp [ 0 ] [ 0 ] [ 1 ] = dp [ 0 ] [ 0 ] [ 0 ] + grid [ 0 ] [ 0 ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , R ) : <NEWLINE> <INDENT> dp [ i ] [ 0 ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] [ 0 ] , dp [ i - 1 ] [ 0 ] [ 1 ] ) <NEWLINE> if grid [ i ] [ 0 ] > 0 : <NEWLINE> <INDENT> dp [ i ] [ 0 ] [ 1 ] = dp [ i ] [ 0 ] [ 0 ] + grid [ i ] [ 0 ] <NEWLINE> <DEDENT> maxx [ i ] [ 0 ] = max ( dp [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> for j in range ( 1 , C ) : <NEWLINE> <INDENT> for k in range ( 1 , 4 ) : <NEWLINE> <INDENT> dp [ 0 ] [ j ] [ k ] = max ( dp [ 0 ] [ j - 1 ] [ k ] , dp [ 0 ] [ j - 1 ] [ k - 1 ] + grid [ 0 ] [ j ] ) <NEWLINE> <DEDENT> maxx [ 0 ] [ j ] = max ( dp [ 0 ] [ j ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( 1 , R ) : <NEWLINE> <INDENT> j_1 = 0 <NEWLINE> for j in range ( 1 , C ) : <NEWLINE> <INDENT> dp [ i ] [ j ] [ 0 ] = max ( maxx [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] [ 0 ] ) <NEWLINE> if grid [ i ] [ j ] > 0 : <NEWLINE> <INDENT> dp [ i ] [ j ] [ 1 ] = max ( dp [ i ] [ j - 1 ] [ 1 ] , dp [ i ] [ j ] [ 0 ] + grid [ i ] [ j ] ) <NEWLINE> for k in range ( 2 , 4 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] [ k ] = max ( dp [ i ] [ j - 1 ] [ k ] , dp [ i ] [ j - 1 ] [ k - 1 ] + grid [ i ] [ j ] ) <NEWLINE> <DEDENT> j_1 = j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( 1 , 4 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] [ k ] = dp [ i ] [ j - 1 ] [ k ] <NEWLINE> <DEDENT> <DEDENT> maxx [ i ] [ j ] = max ( dp [ i ] [ j ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> return dp . max ( ) <NEWLINE> <NL> <NL> <DEDENT> def console ( * args ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> return <NEWLINE> <NL> <DEDENT> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> H , W , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> XYV = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> print ( solve ( XYV , H , W , K ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from collections import defaultdict <NEWLINE> cnt = defaultdict ( int ) <NEWLINE> for i in A : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> xa = min ( a , k ) <NEWLINE> k1 = k - xa <NEWLINE> xb = min ( b , k1 ) <NEWLINE> k2 = k1 - xb <NEWLINE> xc = k2 <NEWLINE> <NL> print ( xa - xc ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> m = n // i <COMMENT> <NEWLINE> j = ( 1 + m ) * m // 2 <NEWLINE> ans += j * i <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def fft_convolve ( f , g ) : <NEWLINE> <INDENT> Lf , Lg = f . shape [ - 1 ] , g . shape [ - 1 ] <NEWLINE> L = Lf + Lg - 1 <NEWLINE> fft_len = 1 << L . bit_length ( ) <NEWLINE> fh , fl = f >> 15 , f & ( 1 << 15 ) - 1 <NEWLINE> gh , gl = g >> 15 , g & ( 1 << 15 ) - 1 <NEWLINE> def conv ( f , g ) : <NEWLINE> <INDENT> Ff = np . fft . rfft ( f , fft_len ) <NEWLINE> Fg = np . fft . rfft ( g , fft_len ) <NEWLINE> h = np . fft . irfft ( Ff * Fg ) <NEWLINE> return np . rint ( h ) [ ... , : L ] . astype ( np . int64 ) % MOD <NEWLINE> <DEDENT> x = conv ( fl , gl ) <NEWLINE> z = conv ( fh , gh ) <NEWLINE> y = conv ( fl + fh , gl + gh ) - x - z <NEWLINE> return ( x + ( y << 15 ) + ( z << 30 ) ) % MOD <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Rob = list ( s . split ( <STRING> ) ) <NEWLINE> <NL> X = [ len ( r ) for r in Rob [ : : 2 ] ] <NEWLINE> Y = [ len ( r ) for r in Rob [ 1 : : 2 ] ] <NEWLINE> <NL> if x < 0 : <NEWLINE> <INDENT> y = abs ( y ) <NEWLINE> Xst = X [ 0 ] <NEWLINE> X = sorted ( X [ 1 : ] ) <NEWLINE> if abs ( x - Xst ) <= sum ( X ) and y <= sum ( Y ) : <NEWLINE> <INDENT> f = np . array ( [ 1 ] , np . int64 ) <NEWLINE> for i in X : <NEWLINE> <INDENT> L = [ 0 ] * ( 2 * i + 1 ) <NEWLINE> L [ 0 ] , L [ - 1 ] = 1 , 1 <NEWLINE> f = np . convolve ( f , np . array ( L , np . int64 ) ) <NEWLINE> <DEDENT> FlagX = f [ abs ( x - Xst ) + sum ( X ) ] <NEWLINE> g = np . array ( [ 1 ] , np . int64 ) <NEWLINE> for j in Y : <NEWLINE> <INDENT> L = [ 0 ] * ( 2 * j + 1 ) <NEWLINE> L [ 0 ] , L [ - 1 ] = 1 , 1 <NEWLINE> g = np . convolve ( g , np . array ( L , np . int64 ) ) <NEWLINE> <DEDENT> FlagY = g [ y + sum ( Y ) ] <NEWLINE> if FlagX and FlagY : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> x , y = abs ( x ) , abs ( y ) <NEWLINE> if x <= sum ( X ) and y <= sum ( Y ) : <NEWLINE> <INDENT> f = np . array ( [ 1 ] , np . int64 ) <NEWLINE> for i in X : <NEWLINE> <INDENT> L = [ 0 ] * ( 2 * i + 1 ) <NEWLINE> L [ 0 ] , L [ - 1 ] = 1 , 1 <NEWLINE> f = np . convolve ( f , np . array ( L , np . int64 ) ) <NEWLINE> <DEDENT> FlagX = f [ x + sum ( X ) ] <NEWLINE> g = np . array ( [ 1 ] , np . int64 ) <NEWLINE> for j in Y : <NEWLINE> <INDENT> L = [ 0 ] * ( 2 * j + 1 ) <NEWLINE> L [ 0 ] , L [ - 1 ] = 1 , 1 <NEWLINE> g = np . convolve ( g , np . array ( L , np . int64 ) ) <NEWLINE> <DEDENT> FlagY = g [ y + sum ( Y ) ] <NEWLINE> if FlagX and FlagY : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<NL> <NL> def cal ( ) : <NEWLINE> <INDENT> number = int ( input ( ) ) <NEWLINE> strList = [ ] <NEWLINE> for i in range ( number ) : <NEWLINE> <INDENT> temp = input ( ) <NEWLINE> strList . append ( temp ) <NEWLINE> <NL> <DEDENT> count = { } <NEWLINE> <NL> for item in strList : <NEWLINE> <INDENT> count [ item ] = count . get ( item , 0 ) + 1 <NEWLINE> <DEDENT> print ( len ( count ) ) <NEWLINE> <NL> <NL> <DEDENT> cal ( ) <NEWLINE> <NL> <NL>
S = sorted ( list ( set ( input ( ) ) ) ) <NEWLINE> <NL> alphabet = list ( <STRING> ) <NEWLINE> <NL> for i in range ( len ( alphabet ) ) : <NEWLINE> <INDENT> if alphabet [ i ] not in S : <NEWLINE> <INDENT> print ( alphabet [ i ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> def dfs ( i , a , value ) : <NEWLINE> <INDENT> global ans <NEWLINE> if i == n : <NEWLINE> <INDENT> if all ( a [ i ] >= x for i in range ( m ) ) : <NEWLINE> <INDENT> ans = min ( ans , value ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dfs ( i + 1 , a , value ) <NEWLINE> dfs ( i + 1 , a + np . array ( pc [ i ] [ 1 : ] ) , value + pc [ i ] [ 0 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = float ( <STRING> ) <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> pc = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pc . append ( s ) <NEWLINE> <NL> <DEDENT> dfs ( 0 , np . array ( [ 0 ] * ( m ) ) , 0 ) <NEWLINE> if ans == float ( <STRING> ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> i = 1 <NEWLINE> x = abs ( x ) <NEWLINE> <NL> if k * d <= x : <NEWLINE> <INDENT> print ( x - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = x // d + 1 <NEWLINE> <COMMENT> <NL> if ( k - i ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( x - d * i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x - d * i + d ) <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , node ) : <NEWLINE> <INDENT> self . parent = [ - 1 for _ in range ( node ) ] <NEWLINE> self . node = node <NEWLINE> <NL> <DEDENT> def find ( self , target ) : <NEWLINE> <INDENT> if self . parent [ target ] < 0 : <NEWLINE> <INDENT> return target <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ target ] = self . find ( self . parent [ target ] ) <NEWLINE> return self . parent [ target ] <NEWLINE> <NL> <DEDENT> <DEDENT> def is_same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> root_x = self . find ( x ) <NEWLINE> root_y = self . find ( y ) <NEWLINE> if root_x == root_y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parent [ root_x ] > self . parent [ root_y ] : <NEWLINE> <INDENT> root_x , root_y = root_y , root_x <NEWLINE> <DEDENT> self . parent [ root_x ] += self . parent [ root_y ] <NEWLINE> self . parent [ root_y ] = root_x <NEWLINE> <NL> <DEDENT> def get_size ( self , x ) : <NEWLINE> <INDENT> return - self . parent [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def get_root ( self ) : <NEWLINE> <INDENT> return [ i for i , root in enumerate ( self . parent ) if root < 0 ] <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . node ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . get_root ( ) } <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ [ <STRING> for _ in range ( w + 2 ) ] ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> grid . append ( [ <STRING> ] + list ( input ( ) ) + [ <STRING> ] ) <NEWLINE> <DEDENT> grid . append ( grid [ 0 ] ) <NEWLINE> uf = UnionFind ( h * w ) <NEWLINE> all_black = [ ] <NEWLINE> <NL> def grid_num ( i , j ) : <NEWLINE> <INDENT> return w * ( i - 1 ) + j - 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> for di , dj in [ [ 0 , 1 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ - 1 , 0 ] ] : <NEWLINE> <INDENT> ni = i + di <NEWLINE> nj = j + dj <NEWLINE> if grid [ ni ] [ nj ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif grid [ i ] [ j ] != grid [ ni ] [ nj ] : <NEWLINE> <INDENT> uf . union ( grid_num ( i , j ) , grid_num ( ni , nj ) ) <NEWLINE> <DEDENT> <DEDENT> if grid [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> all_black . append ( [ i , j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> black = defaultdict ( int ) <NEWLINE> for i , j in all_black : <NEWLINE> <INDENT> black [ uf . find ( grid_num ( i , j ) ) ] += 1 <NEWLINE> <DEDENT> for i , r in enumerate ( uf . parent ) : <NEWLINE> <INDENT> if r < 0 : <NEWLINE> <INDENT> ans += black [ i ] * ( - r - black [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] + A <NEWLINE> B = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> k = N - i <NEWLINE> c = 0 <NEWLINE> for j in range ( k , N + 1 , k ) : <NEWLINE> <INDENT> c += B [ j ] <NEWLINE> c %= 2 <NEWLINE> <DEDENT> if A [ k ] != c : <NEWLINE> <INDENT> B [ k ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( B ) ) <NEWLINE> for i in range ( len ( B ) ) : <NEWLINE> <INDENT> if B [ i ] == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = { 1 : 0 } <NEWLINE> point = 1 <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> next_point = A [ point - 1 ] <NEWLINE> count += 1 <NEWLINE> if next_point in x : <NEWLINE> <INDENT> flag = next_point <NEWLINE> break <NEWLINE> <DEDENT> x [ next_point ] = count <NEWLINE> point = next_point <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> c = count - x [ flag ] <NEWLINE> f = x [ flag ] <NEWLINE> <COMMENT> <NL> if K < f : <NEWLINE> <INDENT> print ( [ i for i in x if x [ i ] == K ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic = { j - f : i for i , j in x . items ( ) } <NEWLINE> print ( dic [ ( K - f ) % c ] ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( i + h [ i ] ) <NEWLINE> b . append ( i - h [ i ] ) <NEWLINE> <NL> <DEDENT> x = Counter ( a ) <NEWLINE> y = Counter ( b ) <NEWLINE> <NL> z = set ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in z : <NEWLINE> <INDENT> ans += x [ i ] * y [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
class Node : <NEWLINE> <INDENT> def __init__ ( self , key , pri ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . pri = pri <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def rRotate ( t ) : <NEWLINE> <INDENT> s = t . left <NEWLINE> t . left = s . right <NEWLINE> s . right = t <NEWLINE> <NL> return s <NEWLINE> <NL> <NL> <DEDENT> def lRotate ( t ) : <NEWLINE> <INDENT> s = t . right <NEWLINE> t . right = s . left <NEWLINE> s . left = t <NEWLINE> <NL> return s <NEWLINE> <NL> <NL> <DEDENT> def insert ( t , key , pri ) : <NEWLINE> <INDENT> if t == None : return Node ( key , pri ) <NEWLINE> <NL> if key == t . key : return t <NEWLINE> <NL> if key < t . key : <NEWLINE> <INDENT> t . left = insert ( t . left , key , pri ) <NEWLINE> if t . pri < t . left . pri : t = rRotate ( t ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> t . right = insert ( t . right , key , pri ) <NEWLINE> if t . pri < t . right . pri : t = lRotate ( t ) <NEWLINE> <NL> <DEDENT> return t <NEWLINE> <NL> <NL> <DEDENT> def delete ( t , key ) : <NEWLINE> <INDENT> if t == None : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> if key < t . key : <NEWLINE> <INDENT> t . left = delete ( t . left , key ) <NEWLINE> <DEDENT> elif key > t . key : <NEWLINE> <INDENT> t . right = delete ( t . right , key ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return _delete ( t , key ) <NEWLINE> <DEDENT> return t <NEWLINE> <NL> <NL> <DEDENT> def _delete ( t , key ) : <NEWLINE> <INDENT> if t . left == None and t . right == None : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> elif t . left == None : <NEWLINE> <INDENT> t = lRotate ( t ) <NEWLINE> <DEDENT> elif t . right == None : <NEWLINE> <INDENT> t = rRotate ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t . left . pri > t . right . pri : <NEWLINE> <INDENT> t = rRotate ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = lRotate ( t ) <NEWLINE> <DEDENT> <DEDENT> return delete ( t , key ) <NEWLINE> <NL> <NL> <DEDENT> def find ( t , key ) : <NEWLINE> <INDENT> if ( t == None ) : return False <NEWLINE> if ( t . key == key ) : return True <NEWLINE> if ( t . key > key ) : return find ( t . left , key ) <NEWLINE> else : return find ( t . right , key ) <NEWLINE> <NL> <DEDENT> def preorder ( t ) : <NEWLINE> <INDENT> if ( t == None ) : return <NEWLINE> <NL> print ( <STRING> , t . key , end = <STRING> ) <NEWLINE> preorder ( t . left ) <NEWLINE> preorder ( t . right ) <NEWLINE> <NL> <NL> <DEDENT> def inorder ( t ) : <NEWLINE> <INDENT> if ( t == None ) : return <NEWLINE> <NL> inorder ( t . left ) <NEWLINE> print ( <STRING> , t . key , end = <STRING> ) <NEWLINE> inorder ( t . right ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> top = None <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> strs = input ( ) . split ( ) <NEWLINE> <NL> op = strs [ 0 ] <NEWLINE> if op != <STRING> : <NEWLINE> <INDENT> key = int ( strs [ 1 ] ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> pri = int ( strs [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if op == <STRING> : top = insert ( top , key , pri ) <NEWLINE> if op == <STRING> : top = delete ( top , key ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> if find ( top , key ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> inorder ( top ) <NEWLINE> print ( ) <NEWLINE> preorder ( top ) <NEWLINE> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> f1 = 1 <NEWLINE> f2 = 2 <NEWLINE> cnt = 0 <NEWLINE> st = <STRING> <NEWLINE> se = <STRING> <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> q = input ( ) . split ( ) <NEWLINE> if int ( q [ 0 ] ) == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> elif int ( q [ 0 ] ) == 2 : <NEWLINE> <INDENT> if cnt % 2 == 0 : <NEWLINE> <INDENT> if int ( q [ 1 ] ) == 1 : <NEWLINE> <INDENT> st = q [ 2 ] + st <NEWLINE> <DEDENT> elif int ( q [ 1 ] ) == 2 : <NEWLINE> <INDENT> se += q [ 2 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if int ( q [ 1 ] ) == 1 : <NEWLINE> <INDENT> se += q [ 2 ] <NEWLINE> <DEDENT> elif int ( q [ 1 ] ) == 2 : <NEWLINE> <INDENT> st = q [ 2 ] + st <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = st + s + se <NEWLINE> if cnt % 2 == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = list ( ans ) <NEWLINE> ans . reverse ( ) <NEWLINE> ans = <STRING> . join ( ans ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> from_ = 1 <NEWLINE> way = [ ] <NEWLINE> way . append ( 1 ) <NEWLINE> way_set = set ( [ 1 ] ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> s = A [ from_ - 1 ] <NEWLINE> if ( s in way_set ) : <NEWLINE> <INDENT> way . append ( s ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> way . append ( s ) <NEWLINE> way_set . add ( s ) <NEWLINE> from_ = s <NEWLINE> <NL> <DEDENT> <DEDENT> key_from = way . index ( way [ len ( way ) - 1 ] ) <NEWLINE> key_to = len ( way ) - 1 <NEWLINE> <NL> <NL> <NL> if ( K > key_from ) : <NEWLINE> <INDENT> ans_loop = ( K - key_from ) % ( key_to - key_from ) <NEWLINE> ans_num = key_from + ans_loop <NEWLINE> <NL> print ( way [ ans_num ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( way [ K ] ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mi = 0 <NEWLINE> le = len ( a ) <NEWLINE> cost = 0 <NEWLINE> for i in range ( le - 1 ) : <NEWLINE> <INDENT> if mi > a [ i + 1 ] or a [ i ] > a [ i + 1 ] : <NEWLINE> <INDENT> mi = max ( a [ i ] , mi ) <NEWLINE> cost += mi - a [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( cost ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
u , s , e , w , n , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> insts = input ( ) <NEWLINE> for inst in insts : <NEWLINE> <INDENT> if inst == <STRING> : <NEWLINE> <INDENT> u , s , n , d = s , d , u , n <NEWLINE> <DEDENT> elif inst == <STRING> : <NEWLINE> <INDENT> u , e , w , d = w , u , d , e <NEWLINE> <DEDENT> elif inst == <STRING> : <NEWLINE> <INDENT> u , s , n , d = n , u , d , s <NEWLINE> <DEDENT> elif inst == <STRING> : <NEWLINE> <INDENT> u , e , w , d = e , d , u , w <NEWLINE> <DEDENT> <DEDENT> print ( u ) <NEWLINE>
from scipy . sparse import coo_matrix <NEWLINE> from scipy . sparse . csgraph import dijkstra <NEWLINE> import numpy as np <NEWLINE> <NL> N , M , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Us = [ 0 ] * M <NEWLINE> Vs = [ 0 ] * M <NEWLINE> As = [ 0 ] * M <NEWLINE> Bs = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> Us [ i ] , Vs [ i ] , As [ i ] , Bs [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> Us [ i ] -= 1 <NEWLINE> Vs [ i ] -= 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> V = { } <NEWLINE> Ns = max ( As ) * N <NEWLINE> Nv = N * ( Ns + 1 ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for ns in range ( Ns + 1 ) : <NEWLINE> <INDENT> V [ ( i , ns ) ] = cnt <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> row = [ ] <NEWLINE> col = [ ] <NEWLINE> data = [ ] <NEWLINE> <NL> if S > Ns : <NEWLINE> <INDENT> S = Ns <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for _ in range ( M ) : <NEWLINE> <INDENT> u = Us . pop ( ) <NEWLINE> v = Vs . pop ( ) <NEWLINE> a = As . pop ( ) <NEWLINE> b = Bs . pop ( ) <NEWLINE> <COMMENT> <NL> for i in range ( Ns + 1 ) : <COMMENT> <NEWLINE> <INDENT> ns_s = Ns - i <NEWLINE> ns_g = ns_s - a <NEWLINE> if ns_g >= 0 : <NEWLINE> <COMMENT> <NL> <INDENT> row . append ( V [ ( u , ns_s ) ] ) <NEWLINE> col . append ( V [ ( v , ns_g ) ] ) <NEWLINE> data . append ( b ) <NEWLINE> <COMMENT> <NL> row . append ( V [ ( v , ns_s ) ] ) <NEWLINE> col . append ( V [ ( u , ns_g ) ] ) <NEWLINE> data . append ( b ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( Ns ) : <COMMENT> <NEWLINE> <INDENT> ns_s = j <NEWLINE> ns_g = j + c <NEWLINE> if ns_g > Ns : <NEWLINE> <INDENT> ns_g = Ns <NEWLINE> <DEDENT> row . append ( V [ ( i , ns_s ) ] ) <NEWLINE> col . append ( V [ ( i , ns_g ) ] ) <NEWLINE> data . append ( d ) <NEWLINE> <NL> <DEDENT> <DEDENT> graph = coo_matrix ( ( data , ( row , col ) ) , shape = ( Nv , Nv ) ) <NEWLINE> <NL> s = V [ ( 0 , S ) ] <NEWLINE> dist_matrix = dijkstra ( csgraph = graph , directed = True , indices = s ) <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans = min ( [ dist_matrix [ i * ( Ns + 1 ) + v ] for v in range ( Ns + 1 ) ] ) <NEWLINE> print ( int ( ans ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> boss = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for b in boss : <NEWLINE> <INDENT> ans [ int ( b ) - 1 ] += 1 <NEWLINE> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 1 <NEWLINE> overflow = False <NEWLINE> for i in a : <NEWLINE> <INDENT> result *= i <NEWLINE> if result > 1e18 : <NEWLINE> <INDENT> result = 1 <NEWLINE> overflow = True <NEWLINE> <DEDENT> <DEDENT> if result != 0 and overflow : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) [ : : - 1 ] <COMMENT> <NEWLINE> n = len ( s ) <NEWLINE> amari_lis = [ 0 ] * 2019 <COMMENT> <NEWLINE> amari_lis [ 0 ] = 1 <COMMENT> <NEWLINE> <NL> num = 0 <NEWLINE> kurai = 1 <NEWLINE> for keta in s : <NEWLINE> <INDENT> num += int ( keta ) * kurai <NEWLINE> num %= 2019 <NEWLINE> amari_lis [ num ] += 1 <NEWLINE> kurai *= 10 <NEWLINE> kurai %= 2019 <COMMENT> <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in amari_lis : <NEWLINE> <INDENT> ans += i * ( i - 1 ) / 2 <COMMENT> <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
s = input ( ) <NEWLINE> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] += 1 <NEWLINE> num = 0 <NEWLINE> d = 1 <NEWLINE> for c in reversed ( s ) : <NEWLINE> <INDENT> d %= 2019 <NEWLINE> num += int ( c ) % 2019 * d <NEWLINE> counts [ num % 2019 ] += 1 <NEWLINE> d *= 10 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for count in counts : <NEWLINE> <INDENT> ans += count * ( count - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> Y = 100 <NEWLINE> i = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if X <= Y : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> Y += Y // 100 <NEWLINE> i += 1 <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> S = list ( map ( int , input ( ) ) ) <NEWLINE> P = 2019 <NEWLINE> <NL> def solve ( S , P ) : <NEWLINE> <INDENT> S = S [ : : - 1 ] <NEWLINE> T = [ 0 ] * len ( S ) <NEWLINE> T [ 0 ] = S [ 0 ] % P <NEWLINE> power = 1 <NEWLINE> for i in range ( 1 , len ( S ) ) : <NEWLINE> <INDENT> power *= 10 <NEWLINE> power %= P <NEWLINE> T [ i ] = T [ i - 1 ] + power * S [ i ] <NEWLINE> T [ i ] %= P <NEWLINE> <DEDENT> counter = Counter ( T ) <NEWLINE> return sum ( x * ( x - 1 ) // 2 for x in counter . values ( ) ) + counter [ 0 ] <NEWLINE> <DEDENT> print ( solve ( S , P ) ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> a . sort ( ) <NEWLINE> if a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> import time <NEWLINE> st = time . time ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> hq = [ ] <NEWLINE> for i , ai in enumerate ( a ) : <NEWLINE> <INDENT> heapq . heappush ( hq , ( - ai , i ) ) <NEWLINE> <DEDENT> dp = [ [ 0 for i in range ( j + 1 ) ] for j in range ( n + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 0 <NEWLINE> ai , hi = heapq . heappop ( hq ) <NEWLINE> dp [ 1 ] [ 0 ] = - ai * ( n - 1 - hi ) <NEWLINE> dp [ 1 ] [ 1 ] = - ai * hi <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> ai , hi = heapq . heappop ( hq ) <NEWLINE> dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] - ai * abs ( n - i - hi ) <NEWLINE> dp [ i ] [ i ] = dp [ i - 1 ] [ i - 1 ] - ai * abs ( hi - i + 1 ) <NEWLINE> for j in range ( 1 , i ) : <NEWLINE> <INDENT> dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] - ai * abs ( hi - j + 1 ) , dp [ i - 1 ] [ j ] - ai * abs ( n - i + j - hi ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( dp [ n ] ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from collections import Counter <NEWLINE> n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = Counter ( a ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = sum ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += b [ x ] * ( y - x ) <NEWLINE> print ( ans ) <NEWLINE> b [ y ] += b [ x ] <NEWLINE> b [ x ] = 0 <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> k = int ( input ( ) ) + 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k ) : <NEWLINE> <INDENT> for j in range ( 1 , k ) : <NEWLINE> <INDENT> for l in range ( 1 , k ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( h [ 0 ] ) <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> print ( max ( h ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h . append ( 0 ) <NEWLINE> h . insert ( 0 , 0 ) <NEWLINE> <NL> ans = 0 <NEWLINE> f = [ 0 for i in range ( n + 2 ) ] <NEWLINE> <NL> for i in range ( 10010 ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> x = [ ] <NEWLINE> for j in range ( n + 2 ) : <NEWLINE> <INDENT> if h [ j ] <= f [ j ] : <NEWLINE> <INDENT> x . append ( j ) <NEWLINE> <DEDENT> <DEDENT> m = len ( x ) <NEWLINE> if m == n + 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = m - 1 <NEWLINE> for j in range ( m - 1 ) : <NEWLINE> <INDENT> if x [ j ] + 1 == x [ j + 1 ] : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> <DEDENT> ans += a <NEWLINE> for j in range ( n + 2 ) : <NEWLINE> <INDENT> f [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
s = sorted ( x for x in input ( ) ) <NEWLINE> t = sorted ( [ x for x in input ( ) ] , reverse = True ) <NEWLINE> print ( <STRING> if s < t else <STRING> ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt_blue = 0 <NEWLINE> total_tmp = 0 <NEWLINE> <NL> try : <NEWLINE> <INDENT> pre_cnt = N // ( A + B ) <NEWLINE> total_tmp = pre_cnt * ( A + B ) <NEWLINE> total_tmp += A <NEWLINE> if N <= total_tmp : <NEWLINE> <INDENT> cnt_blue = N - ( pre_cnt * B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt_blue = ( pre_cnt * A ) + A <NEWLINE> <DEDENT> print ( cnt_blue ) <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def RD ( ) : return input ( ) . rstrip ( ) . decode ( ) <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> def FI ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MF ( ) : return map ( float , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LF ( ) : return list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> def TI ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = II ( ) <NEWLINE> A = [ II ( ) for _ in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> now = 0 <NEWLINE> cnt = 1 <NEWLINE> ans = - 1 <NEWLINE> for i in range ( n + 5 ) : <NEWLINE> <INDENT> now = A [ now ] - 1 <NEWLINE> if now == 1 : <NEWLINE> <INDENT> ans = cnt <NEWLINE> break <NEWLINE> <DEDENT> elif now == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> main = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> total = sum ( main ) <NEWLINE> beg = 0 <NEWLINE> final = float ( <STRING> ) <NEWLINE> for i in range ( len ( main ) - 1 ) : <NEWLINE> <INDENT> beg += main [ i ] <NEWLINE> total -= main [ i ] <NEWLINE> final = min ( final , abs ( beg - total ) ) <NEWLINE> <NL> <DEDENT> print ( final ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> count += ( N // i ) * ( i + i * ( N // i ) ) // 2 <NEWLINE> <NL> <NL> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( r * r * math . pi , 2 * r * math . pi ) <NEWLINE>
<COMMENT> <NL> <NL> n , k = list ( map ( int , list ( input ( ) . split ( ) ) ) ) <NEWLINE> scores = list ( map ( int , list ( input ( ) . split ( ) ) ) ) <NEWLINE> <NL> for i in range ( k + 1 , n + 1 ) : <NEWLINE> <INDENT> remove = scores [ i - k - 1 ] <NEWLINE> add = scores [ i - 1 ] <NEWLINE> <NL> if remove < add : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> L = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> L [ A [ i ] ] += 1 <NEWLINE> <DEDENT> for l in L [ 1 : ] : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> j = 0 <NEWLINE> L = list ( ) <NEWLINE> R = list ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S = <STRING> . join ( sorted ( list ( input ( ) ) ) ) <NEWLINE> L . append ( S ) <NEWLINE> <DEDENT> c = collections . Counter ( L ) <NEWLINE> counts = c . values ( ) <NEWLINE> counts = list ( counts ) <NEWLINE> A = [ i * ( i - 1 ) // 2 for i in counts ] <NEWLINE> print ( sum ( A ) ) <NEWLINE>
import sys <NEWLINE> <NL> a , b = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> if a == b : <NEWLINE> <INDENT> opr = <STRING> <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> opr = <STRING> <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> opr = <STRING> <NEWLINE> <NL> <DEDENT> print ( <STRING> + opr + <STRING> ) <NEWLINE>
a , b , x = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print ( ( b // x ) - ( ( a - 1 ) // x ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> R = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> R . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> maxv = R [ 1 ] - R [ 0 ] <NEWLINE> minv = R [ 0 ] <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> maxv = max ( R [ j ] - minv , maxv ) <NEWLINE> minv = min ( R [ j ] , minv ) <NEWLINE> <DEDENT> print ( maxv ) <NEWLINE>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> last_list = [ 0 ] * ( c + 1 ) <NEWLINE> for _ in range ( r ) : <NEWLINE> <INDENT> n = 0 <NEWLINE> x = input ( ) <NEWLINE> sum_list = list ( map ( int , x . split ( ) ) ) <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> last_list [ i ] += sum_list [ i ] <NEWLINE> n += sum_list [ i ] <NEWLINE> <DEDENT> print ( x , n ) <NEWLINE> <NL> <DEDENT> last_list [ - 1 ] = sum ( last_list ) <NEWLINE> print ( * last_list ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if ( A [ i ] / A [ i - K ] ) > 1 : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = set ( [ int ( input ( ) ) for _ in range ( M ) ] ) <NEWLINE> MOD = 1000000007 <NEWLINE> memo = [ 0 ] * ( N + 1 ) <NEWLINE> memo [ 0 ] = 1 <NEWLINE> if 1 not in A : <NEWLINE> <INDENT> memo [ 1 ] = 1 <NEWLINE> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if i not in A : <NEWLINE> <INDENT> memo [ i ] = ( memo [ i - 2 ] + memo [ i - 1 ] ) % MOD <NEWLINE> <DEDENT> <DEDENT> print ( memo [ N ] ) <NEWLINE>
import sys <NEWLINE> <NL> inf = int ( 1e12 ) <NEWLINE> <NL> def shortestPath ( graph ) : <NEWLINE> <INDENT> n = len ( graph ) <NEWLINE> dist = [ [ inf for _ in range ( n ) ] for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dist [ i ] [ i ] = 0 <NEWLINE> <NL> <DEDENT> for v in range ( n ) : <NEWLINE> <INDENT> for u , cost in graph [ v ] : <NEWLINE> <INDENT> dist [ v ] [ u ] = cost <NEWLINE> <NL> <DEDENT> <DEDENT> for k in range ( n ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if dist [ i ] [ k ] != inf and dist [ k ] [ j ] != inf : <NEWLINE> <INDENT> dist [ i ] [ j ] = min ( dist [ i ] [ j ] , dist [ i ] [ k ] + dist [ k ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return dist <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> v , e = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( v ) ] <NEWLINE> <NL> for i in range ( e ) : <NEWLINE> <INDENT> a , b , cost = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( ( b , cost ) ) <NEWLINE> <NL> <DEDENT> dist_mat = shortestPath ( graph ) <NEWLINE> <NL> for i in range ( v ) : <NEWLINE> <INDENT> if dist_mat [ i ] [ i ] < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( v ) : <NEWLINE> <INDENT> output = [ ] <NEWLINE> for j in range ( v ) : <NEWLINE> <INDENT> if dist_mat [ i ] [ j ] >= inf : <NEWLINE> <INDENT> output . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> output . append ( str ( dist_mat [ i ] [ j ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( output ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return [ set ( self . members ( r ) ) for r in self . roots ( ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> uf . union ( x , y ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i , p in enumerate ( P ) : <NEWLINE> <INDENT> if uf . same ( i , p ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> return math . gcd ( a , b ) <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for m in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> d = math . gcd ( i , m ) <NEWLINE> for u in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> cnt += math . gcd ( d , u ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if k <= a : <NEWLINE> <INDENT> ans = k <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a - ( k - a - b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> x3 = ( 10 ** 9 - s % 10 ** 9 ) % 10 ** 9 <NEWLINE> y3 = ( s + x3 ) // 10 ** 9 <NEWLINE> print ( 0 , 0 , 10 ** 9 , 1 , x3 , y3 ) <NEWLINE>
a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) <NEWLINE> ws = [ ] <NEWLINE> for i in range ( f // 100 // a + 1 ) : <NEWLINE> <INDENT> for j in range ( f // 100 // b + 1 ) : <NEWLINE> <INDENT> w = 100 * ( a * i + b * j ) <NEWLINE> if 0 < w <= f : <NEWLINE> <INDENT> ws . append ( w ) <NEWLINE> <DEDENT> if w >= f : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ss = [ ] <NEWLINE> for i in range ( f * e // ( 100 + e ) // c + 1 ) : <NEWLINE> <INDENT> for j in range ( f * e // ( 100 + e ) // d + 1 ) : <NEWLINE> <INDENT> s = c * i + d * j <NEWLINE> if 0 <= s <= f * e // ( 100 + e ) : <NEWLINE> <INDENT> ss . append ( s ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> n = [ ] <NEWLINE> for w in ws : <NEWLINE> <INDENT> for s in ss : <NEWLINE> <INDENT> if w + s > f : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s > e * w // 100 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> n . append ( ( s / ( w + s ) , w + s , s ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> nmax = max ( n , key = lambda x : x [ 0 ] ) <NEWLINE> print ( nmax [ 1 ] , nmax [ 2 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> c = ( N + 1 ) // 2 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N - c + 1 ) : <NEWLINE> <INDENT> ans += i * ( 1 + N // i ) * ( N // i ) / 2 <NEWLINE> <DEDENT> ans += N * c - ( c - 1 ) * c / 2 <NEWLINE> print ( int ( ans ) ) <NEWLINE>
def insertionSort ( A , n , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> <NL> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> def shellSort ( A , n ) : <NEWLINE> <INDENT> global cnt <NEWLINE> cnt = 0 <NEWLINE> g = 1 <NEWLINE> G = [ 1 ] <NEWLINE> m = 1 <NEWLINE> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> tmp = G [ i - 1 ] + ( 3 ) ** i <NEWLINE> if tmp <= n : <NEWLINE> <INDENT> m = i + 1 <NEWLINE> G . append ( tmp ) <NEWLINE> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> G . reverse ( ) <NEWLINE> print ( m ) <COMMENT> <NEWLINE> print ( <STRING> . join ( list ( map ( str , G ) ) ) ) <COMMENT> <NEWLINE> <NL> for i in range ( 0 , m ) : <NEWLINE> <INDENT> insertionSort ( A , n , G [ i ] ) <NEWLINE> <DEDENT> print ( cnt ) <COMMENT> <NEWLINE> for i in range ( 0 , len ( A ) ) : <NEWLINE> <INDENT> print ( A [ i ] ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> shellSort ( A , n ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A , B = [ ] , [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( x + y ) <NEWLINE> B . append ( x - y ) <NEWLINE> <NL> <DEDENT> A = sorted ( A ) <NEWLINE> B = sorted ( B ) <NEWLINE> print ( max ( abs ( A [ 0 ] - A [ - 1 ] ) , abs ( B [ 0 ] - B [ - 1 ] ) ) ) <NEWLINE>
n = input ( ) <NEWLINE> sum_digit = 0 <NEWLINE> l = len ( n ) <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> sum_digit += int ( n [ i ] ) <NEWLINE> <DEDENT> if sum_digit % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> numbers = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = [ 0 ] * N <NEWLINE> for i in numbers : <NEWLINE> <INDENT> result [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> print ( result [ i ] ) <NEWLINE> <DEDENT> print ( 0 ) <NEWLINE>
from bisect import bisect_left <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> py = [ ] <NEWLINE> l = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> p , y = map ( int , input ( ) . split ( ) ) <NEWLINE> l [ p ] . append ( y ) <NEWLINE> py . append ( ( p , y ) ) <NEWLINE> <NL> <DEDENT> for i in l : i . sort ( ) <NEWLINE> <NL> for p , y in py : <NEWLINE> <INDENT> s = str ( p ) <NEWLINE> t = str ( bisect_left ( l [ p ] , y ) + 1 ) <NEWLINE> ans = <STRING> * ( 6 - len ( s ) ) + s + <STRING> * ( 6 - len ( t ) ) + t <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
def memolize ( f ) : <NEWLINE> <INDENT> cache = { } <NEWLINE> <NL> def helper ( x ) : <NEWLINE> <INDENT> if x not in cache : <NEWLINE> <INDENT> cache [ x ] = f ( x ) <NEWLINE> <DEDENT> return cache [ x ] <NEWLINE> <DEDENT> return helper <NEWLINE> <NL> <DEDENT> @ memolize <NEWLINE> def fib ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> return fib ( n - 1 ) + fib ( n - 2 ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( fib ( n ) ) <NEWLINE> <NL>
from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> aa = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = { 0 : 1000 } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> xx = defaultdict ( int ) <NEWLINE> for stock , money in x . items ( ) : <NEWLINE> <INDENT> xx [ 0 ] = max ( xx [ 0 ] , money + stock * aa [ i ] ) <NEWLINE> ns = money // aa [ i ] <NEWLINE> xx [ stock + ns ] = max ( xx [ stock + ns ] , money - ns * aa [ i ] ) <NEWLINE> <DEDENT> x = xx <NEWLINE> <DEDENT> print ( x [ 0 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> i = 1 <NEWLINE> while i <= n : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while x : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> x = x // 10 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> s = <STRING> . format ( r * r * math . pi ) <NEWLINE> l = <STRING> . format ( 2 * r * math . pi ) <NEWLINE> print ( s , l ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> r = [ 0 ] * ( 10 ** 5 + 10 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> r [ a [ i ] ] += 1 <NEWLINE> <DEDENT> b = [ 0 ] * q <NEWLINE> c = [ 0 ] * q <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b [ i ] , c [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> s = 0 <NEWLINE> for m in range ( n ) : <NEWLINE> <INDENT> s += a [ m ] <NEWLINE> <DEDENT> for ii in range ( q ) : <NEWLINE> <INDENT> s = s + ( c [ ii ] - b [ ii ] ) * r [ b [ ii ] ] <NEWLINE> r [ c [ ii ] ] += r [ b [ ii ] ] <NEWLINE> r [ b [ ii ] ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <COMMENT> <NL> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <COMMENT> <NL> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> u = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> u . unite ( a , b ) <NEWLINE> <DEDENT> ans = u . roots ( ) <NEWLINE> print ( len ( ans ) - 1 ) <NEWLINE>
from functools import reduce <NEWLINE> <NL> def problem ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> xs = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> t = reduce ( lambda acc , elem : acc ^ elem , xs ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> yield ( t ^ xs [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * problem ( ) ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def gcd ( x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> if x < y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> while y > 0 : <NEWLINE> <INDENT> r = x % y <NEWLINE> x = y <NEWLINE> y = r <NEWLINE> <NL> <DEDENT> print ( x ) <NEWLINE> <NL> <NL> <DEDENT> def to_xy ( v ) : <NEWLINE> <INDENT> return [ int ( c ) for c in v . split ( ) ] <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> x , y = to_xy ( input ( ) ) <NEWLINE> gcd ( x , y ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from random import randint <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( 10 ** 6 ) : <NEWLINE> <INDENT> x = randint ( - 200 , 200 ) <NEWLINE> y = randint ( - 200 , 200 ) <NEWLINE> if x ** 5 - y ** 5 == n : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> break ; <NEWLINE> <NL> <DEDENT> <DEDENT>
<NL> <NL> SENTINEL = 10 ** 9 + 1 <NEWLINE> <NL> <NL> def merge_sort ( alist ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def _sort ( left , right ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> count += _sort ( left , mid ) <NEWLINE> count += _sort ( mid , right ) <NEWLINE> count += merge ( left , mid , right ) <NEWLINE> <NL> <DEDENT> return count <NEWLINE> <NL> <DEDENT> def merge ( left , mid , right ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> ll = alist [ left : mid ] + [ SENTINEL ] <NEWLINE> rl = alist [ mid : right ] + [ SENTINEL ] <NEWLINE> <NL> i = j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if ll [ i ] <= rl [ j ] : <NEWLINE> <INDENT> alist [ k ] = ll [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> alist [ k ] = rl [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> comp = _sort ( 0 , len ( alist ) ) <NEWLINE> return ( comp , alist ) <NEWLINE> <NL> <NL> <DEDENT> def min_cost ( li1 , li2 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def find_moves ( i , j ) : <NEWLINE> <INDENT> start = i <NEWLINE> elems = [ i ] <NEWLINE> mincost = li1 [ i ] <NEWLINE> minidx = 0 <NEWLINE> <NL> while j != start : <NEWLINE> <INDENT> if mincost > li1 [ j ] : <NEWLINE> <INDENT> mincost = li1 [ j ] <NEWLINE> minidx = len ( elems ) <NEWLINE> <DEDENT> elems . append ( j ) <NEWLINE> j = li2 . index ( li1 [ j ] ) <NEWLINE> <NL> <DEDENT> elems = elems [ minidx + 1 : ] + elems [ : minidx + 1 ] <NEWLINE> if 2 * ( mincost + li1 [ mini ] ) < ( len ( elems ) - 1 ) * ( mincost - li1 [ mini ] ) : <NEWLINE> <INDENT> elems . append ( mini ) <NEWLINE> elems . insert ( 0 , mini ) <NEWLINE> <NL> <DEDENT> q = elems . pop ( ) <NEWLINE> p = elems . pop ( ) <NEWLINE> yield ( p , q ) <NEWLINE> while len ( elems ) > 0 : <NEWLINE> <INDENT> q = p <NEWLINE> p = elems . pop ( ) <NEWLINE> yield ( p , q ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def move ( i , j ) : <NEWLINE> <INDENT> cost = 0 <NEWLINE> for p , q in find_moves ( i , j ) : <NEWLINE> <INDENT> li1 [ p ] , li1 [ q ] = li1 [ q ] , li1 [ p ] <NEWLINE> cost += li1 [ p ] + li1 [ q ] <NEWLINE> <NL> <DEDENT> return cost <NEWLINE> <NL> <DEDENT> assert len ( li1 ) == len ( li2 ) <NEWLINE> size = len ( li1 ) <NEWLINE> totalcost = 0 <NEWLINE> <NL> for i in reversed ( range ( size ) ) : <NEWLINE> <INDENT> if li1 [ i ] != li2 [ i ] : <NEWLINE> <INDENT> mini = li1 . index ( li2 [ 0 ] ) <NEWLINE> totalcost += move ( li1 . index ( li2 [ i ] ) , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> return totalcost <NEWLINE> <NL> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> _ = int ( input ( ) ) <COMMENT> <NEWLINE> li = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> sli = li [ : ] <NEWLINE> ( _ , sli ) = merge_sort ( sli ) <NEWLINE> <NL> print ( min_cost ( li , sli ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
import re <NEWLINE> string = input ( ) <NEWLINE> string = re . split ( <STRING> , string ) <NEWLINE> words = [ ] <NEWLINE> for i in string : <NEWLINE> <INDENT> if 3 <= len ( i ) <= 6 : <NEWLINE> <INDENT> words . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( words ) ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import math <NEWLINE> <NL> from collections import deque <NEWLINE> from functools import reduce <NEWLINE> from functools import lru_cache <NEWLINE> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> gcd_num = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> g = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> gcd_num += math . gcd ( g , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( gcd_num ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if ( x - i ) not in p : <NEWLINE> <INDENT> ans = x - i <NEWLINE> break <NEWLINE> <DEDENT> elif ( x + i ) not in p : <NEWLINE> <INDENT> ans = x + i <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( <STRING> ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from math import ceil <NEWLINE> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> B . append ( arr [ i ] - ( i + 1 ) ) <NEWLINE> <DEDENT> B . sort ( ) <NEWLINE> b1 = B [ n // 2 ] <NEWLINE> b2 = B [ n // 2 ] <NEWLINE> if n > 1 : <NEWLINE> <INDENT> b2 = B [ int ( ceil ( n / 2 ) ) ] <NEWLINE> <DEDENT> ans1 , ans2 = 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans1 += abs ( arr [ i ] - ( b1 + i + 1 ) ) <NEWLINE> ans2 += abs ( arr [ i ] - ( b2 + i + 1 ) ) <NEWLINE> <DEDENT> print ( min ( ans1 , ans2 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> TA = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> T , A = 0 , 0 <NEWLINE> for t , a in TA : <NEWLINE> <INDENT> if T == 0 and A == 0 : <NEWLINE> <INDENT> T = t <NEWLINE> A = a <NEWLINE> continue <NEWLINE> <DEDENT> if t == a : <NEWLINE> <INDENT> M = max ( T , A ) <NEWLINE> T = M <NEWLINE> A = M <NEWLINE> <DEDENT> elif t < a : <NEWLINE> <INDENT> n = max ( ( T // t ) * t , ( A // a ) * t ) <NEWLINE> while n < T or a * ( n // t ) < A : <NEWLINE> <INDENT> n += t <NEWLINE> <DEDENT> T = n <NEWLINE> A = a * ( T // t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = max ( ( A // a ) * a , ( T // t ) * a ) <NEWLINE> while n < A or t * ( n // a ) < T : <NEWLINE> <INDENT> n += a <NEWLINE> <DEDENT> A = n <NEWLINE> T = t * ( A // a ) <NEWLINE> <DEDENT> <DEDENT> print ( A + T ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = sum ( a ) <NEWLINE> <NL> S2 = sum ( map ( lambda x : x * x , a ) ) <NEWLINE> <NL> ans = ( S * S - S2 ) // 2 % 1000000007 <NEWLINE> print ( ans ) <NEWLINE> <NL>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> ans = 0 <NEWLINE> t = sum ( A ) <NEWLINE> temp = 0 <NEWLINE> if t <= K : <NEWLINE> <INDENT> ans = N <NEWLINE> <DEDENT> j = 0 <NEWLINE> ans2 = 0 <NEWLINE> for i in range ( 0 , N + 1 ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> t -= A [ - i ] <NEWLINE> <DEDENT> while t < K and j < len ( B ) : <NEWLINE> <INDENT> if t + B [ j ] <= K : <NEWLINE> <INDENT> ans2 += 1 <NEWLINE> t += B [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if t <= K : <NEWLINE> <INDENT> ans = max ( ans , len ( A ) - i + ans2 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> tmp = 1 <NEWLINE> for i in range ( 1 , int ( x ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for j in range ( 2 , x ) : <NEWLINE> <INDENT> tmp = pow ( i , j ) <NEWLINE> if tmp > x : <NEWLINE> <INDENT> tmp = pow ( i , j - 1 ) <NEWLINE> <COMMENT> <NL> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( tmp , ans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> a = [ ] <NEWLINE> a . append ( str ( n [ : len ( n ) : 2 ] ) ) <NEWLINE> print ( * a ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> <NL> def merge ( array ) : <COMMENT> <NEWLINE> <INDENT> mid = len ( array ) <COMMENT> <NEWLINE> if mid > 1 : <COMMENT> <NEWLINE> <INDENT> left = merge ( array [ : ( mid // 2 ) ] ) <COMMENT> <NEWLINE> right = merge ( array [ ( mid // 2 ) : ] ) <COMMENT> <NEWLINE> array = [ ] <COMMENT> <NEWLINE> while len ( left ) != 0 and len ( right ) != 0 : <COMMENT> <NEWLINE> <INDENT> if left [ 0 ] < right [ 0 ] : <COMMENT> <NEWLINE> <INDENT> array . append ( left . pop ( 0 ) ) <COMMENT> <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> array . append ( right . pop ( 0 ) ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> if len ( left ) != 0 : <COMMENT> <NEWLINE> <INDENT> array . extend ( left ) <COMMENT> <NEWLINE> <DEDENT> elif len ( right ) != 0 : <COMMENT> <NEWLINE> <INDENT> array . extend ( right ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> return array <NEWLINE> <NL> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> S . append ( a ) <NEWLINE> <DEDENT> L = merge ( S ) <NEWLINE> <NL> ans = - L [ 0 ] + L [ n - 1 ] <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> if - L [ i ] + L [ i + k - 1 ] < ans : <NEWLINE> <INDENT> ans = - L [ i ] + L [ i + k - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
( n , m ) , h , * r = [ [ * map ( int , i . split ( ) ) ] for i in open ( 0 ) ] <NEWLINE> g = [ ] + h <NEWLINE> <NL> for i in r : <NEWLINE> <INDENT> g [ i [ 0 ] - 1 ] *= h [ i [ 0 ] - 1 ] > h [ i [ 1 ] - 1 ] <NEWLINE> g [ i [ 1 ] - 1 ] *= h [ i [ 1 ] - 1 ] > h [ i [ 0 ] - 1 ] <NEWLINE> <DEDENT> print ( len ( [ i for i in g if i != 0 ] ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> eastNumber = S . count ( <STRING> ) <NEWLINE> westNumber = 0 <NEWLINE> minimum = N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> eastNumber -= 1 <NEWLINE> number = eastNumber + westNumber <NEWLINE> if minimum > number : <NEWLINE> <INDENT> minimum = number <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> number = eastNumber + westNumber <NEWLINE> if minimum > number : <NEWLINE> <INDENT> minimum = number <NEWLINE> <DEDENT> westNumber += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( minimum ) <NEWLINE>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> if <STRING> in line : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a , op , b = line . split ( <STRING> ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) + int ( b ) ) <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) - int ( b ) ) <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) * int ( b ) ) <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( int ( float ( a ) / float ( b ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> pair = [ ] <NEWLINE> unpair = set ( ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if a in unpair : <NEWLINE> <INDENT> pair . append ( a ) <NEWLINE> unpair . remove ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> unpair . add ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> pair . sort ( ) <NEWLINE> pair . reverse ( ) <NEWLINE> if len ( pair ) <= 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = pair [ 0 ] * pair [ 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = set ( int ( input ( ) ) for m in range ( M ) ) <NEWLINE> dp = ( N + 1 ) * [ 0 ] <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if n not in A : <NEWLINE> <INDENT> dp [ n ] = ( dp [ n - 2 ] + dp [ n - 1 ] ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
from itertools import accumulate <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P = list ( map ( lambda x : int ( x ) + 1 , input ( ) . split ( ) ) ) <NEWLINE> P_cumsum = [ 0 ] + list ( accumulate ( P ) ) <NEWLINE> print ( max ( [ P_cumsum [ i + K ] - P_cumsum [ i ] for i in range ( N - K + 1 ) ] ) / 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> self_front = [ 0 ] * ( 2 * ( 10 ** 5 ) + 3 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( i - A [ i ] >= 0 ) : <NEWLINE> <INDENT> self_front [ i - A [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( i + A [ i ] < 2 * ( 10 ** 5 ) + 3 ) : <NEWLINE> <INDENT> cnt += self_front [ i + A [ i ] ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> <NL> <NL> <NL> class MagicSquare ( ) : <NEWLINE> <INDENT> def __init__ ( self , size ) : <NEWLINE> <INDENT> self . size = size <NEWLINE> self . data = [ [ <STRING> ] * self . size for _ in range ( self . size ) ] <NEWLINE> self . fill_data ( ) <NEWLINE> <NL> <DEDENT> def fill_data ( self ) : <NEWLINE> <INDENT> num = 1 <NEWLINE> x = self . size // 2 <NEWLINE> y = x + 1 <NEWLINE> self . data [ y ] [ x ] = num <NEWLINE> <NL> while num < self . size ** 2 : <NEWLINE> <INDENT> x += 1 <NEWLINE> if x >= self . size : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> y += 1 <NEWLINE> if y >= self . size : <NEWLINE> <INDENT> y = 0 <NEWLINE> <DEDENT> if self . data [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> num += 1 <NEWLINE> self . data [ y ] [ x ] = num <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while self . data [ y ] [ x ] != <STRING> : <NEWLINE> <INDENT> x -= 1 <NEWLINE> if x < 0 : <NEWLINE> <INDENT> x = self . size - 1 <NEWLINE> <DEDENT> y += 1 <NEWLINE> if y >= self . size : <NEWLINE> <INDENT> y = 0 <NEWLINE> <DEDENT> <DEDENT> num += 1 <NEWLINE> self . data [ y ] [ x ] = num <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def print_data ( self ) : <NEWLINE> <INDENT> for row in self . data : <NEWLINE> <INDENT> temp = <STRING> <NEWLINE> for d in row : <NEWLINE> <INDENT> temp += str ( d ) . rjust ( 4 ) <NEWLINE> <DEDENT> print ( temp ) <NEWLINE> temp = <STRING> <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( args ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> size = int ( input ( ) ) <NEWLINE> if size < 3 or size % 2 == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ms = MagicSquare ( size ) <NEWLINE> ms . print_data ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import product <NEWLINE> import heapq <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> list_N = list ( range ( 1 , int ( ( N + 1 ) ** 0.5 ) ) ) <NEWLINE> <NL> list_xyz = list ( product ( list_N , repeat = 3 ) ) <NEWLINE> <NL> ans_list = [ x ** 2 + y ** 2 + z ** 2 + x * y + y * z + x * z for x , y , z in list_xyz ] <NEWLINE> heapq . heapify ( ans_list ) <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if len ( ans_list ) < 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> tmp = heapq . heappop ( ans_list ) <NEWLINE> if tmp == n : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif tmp > n : <NEWLINE> <INDENT> heapq . heappush ( ans_list , tmp ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> max = ( i * ( n + n - i + 1 ) ) // 2 <NEWLINE> min = ( i * ( i - 1 ) ) // 2 <NEWLINE> ans += max - min + 1 <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> rec = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> rec = rec * i <NEWLINE> if rec > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( rec ) <NEWLINE>
import sys <NEWLINE> from operator import mul <NEWLINE> from functools import reduce <NEWLINE> from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> c = Counter ( s ) <NEWLINE> if len ( c ) != 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = reduce ( mul , c . values ( ) ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> x , y , z = i , i + 1 , i + 2 <NEWLINE> while z <= n - 1 : <NEWLINE> <INDENT> if s [ x ] != s [ y ] and s [ x ] != s [ z ] and s [ y ] != s [ z ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> y += 1 <NEWLINE> z += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) . strip ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> def mod ( x ) : <NEWLINE> <INDENT> return x % 1000000007 <NEWLINE> <NL> <DEDENT> sa = sum ( A [ 1 : ] ) <NEWLINE> s = mod ( A [ 0 ] * sa ) <NEWLINE> <NL> for a in A [ 1 : - 1 ] : <NEWLINE> <INDENT> sa -= a <NEWLINE> s = mod ( s + a * sa ) <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> MAX = 10 ** 6 + 1 <NEWLINE> cnt = [ 0 ] * MAX <NEWLINE> <NL> for x in A : <NEWLINE> <INDENT> if cnt [ x ] != 0 : <NEWLINE> <INDENT> cnt [ x ] = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( x , MAX , x ) : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for x in A : <NEWLINE> <COMMENT> <NL> <INDENT> if cnt [ x ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> a = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif b == 1 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s . count ( <STRING> ) > 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
from math import sqrt <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 1 : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> elif x != 2 and x % 2 == 0 : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> elif x == 2 or x == 3 or x == 5 : <NEWLINE> <INDENT> count = count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 2 , int ( sqrt ( x ) ) + 1 ) : <NEWLINE> <INDENT> if x % j == 0 : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( n - count ) <NEWLINE> <NL> <NL>
<COMMENT> <NL> from collections import deque <NEWLINE> from operator import itemgetter <NEWLINE> from bisect import bisect_left , bisect <NEWLINE> import itertools <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import numpy as np <NEWLINE> import time <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def ev ( n ) : <NEWLINE> <INDENT> return 0.5 * ( n + 1 ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p_ev = list ( map ( ev , p ) ) <NEWLINE> <NL> s = np . cumsum ( p_ev ) <NEWLINE> s = np . insert ( s , 0 , 0 ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans . append ( s [ i + k ] - s [ i ] ) <NEWLINE> <NL> <DEDENT> print ( max ( ans ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> print ( math . floor ( a * ( x % b ) / b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or str ( i ) . find ( <STRING> ) != - 1 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> dp = [ 0 ] * 20001 <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + b for a , b in ab ) <NEWLINE> <DEDENT> print ( dp [ h - 1 ] ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> fb = b // x + 1 <NEWLINE> if a != 0 : <NEWLINE> <INDENT> fa = ( a - 1 ) // x + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fa = 0 <NEWLINE> <DEDENT> print ( fb - fa ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = min ( B - 1 , N ) <NEWLINE> result = int ( A * cnt / B ) - A * int ( cnt / B ) <NEWLINE> <NL> print ( result ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( 1 , n // 2 + 1 ) : <NEWLINE> <INDENT> res += ( int ( n / i ) * ( i + int ( n / i ) * i ) ) // 2 <NEWLINE> <DEDENT> res += ( n + n // 2 + 1 ) * ( n - n // 2 ) // 2 <NEWLINE> print ( res ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> path = [ set ( ) for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> path [ a ] . add ( b ) <NEWLINE> path [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> ans = [ n * ( n + 1 ) // 2 ] * n <NEWLINE> size = [ 0 ] * n <NEWLINE> cparent = [ [ ] for _ in range ( n ) ] <NEWLINE> reached = [ False ] * n <NEWLINE> root_size = [ n ] * n <NEWLINE> <NL> def dfs ( p ) : <NEWLINE> <INDENT> c = C [ p ] - 1 <NEWLINE> cparent [ c ] . append ( p ) <NEWLINE> s = 1 <NEWLINE> for nxt in path [ p ] : <NEWLINE> <COMMENT> <NL> <NL> <INDENT> if reached [ nxt ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> size [ p ] = 0 <NEWLINE> reached [ nxt ] = True <NEWLINE> ret = dfs ( nxt ) <NEWLINE> s += ret <NEWLINE> size [ p ] += ret <NEWLINE> ans [ c ] -= size [ p ] * ( size [ p ] + 1 ) // 2 <NEWLINE> <DEDENT> cparent [ c ] . pop ( ) <NEWLINE> if cparent [ c ] : <NEWLINE> <INDENT> size [ cparent [ c ] [ - 1 ] ] -= s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root_size [ c ] -= s <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> reached [ 0 ] = True <NEWLINE> dfs ( 0 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] - root_size [ i ] * ( root_size [ i ] + 1 ) // 2 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> from heapq import heappush , heappop , heapify <NEWLINE> import math <NEWLINE> from math import gcd <NEWLINE> import itertools as it <NEWLINE> import collections <NEWLINE> from collections import deque <NEWLINE> <NL> def inp ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def inpl ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def _debug ( obj ) : <NEWLINE> <INDENT> print ( obj , file = sys . stderr ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> N , M = inpl ( ) <NEWLINE> graph = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> x , y = inpl ( ) <NEWLINE> graph [ x ] . append ( y ) <NEWLINE> <NL> <DEDENT> flag = [ False ] * ( N + 1 ) <NEWLINE> dp = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> <NL> def f ( x ) : <NEWLINE> <INDENT> if flag [ x ] : <NEWLINE> <INDENT> return dp [ x ] <NEWLINE> <DEDENT> flag [ x ] = True <NEWLINE> fans = 0 <NEWLINE> for y in graph [ x ] : <NEWLINE> <INDENT> fans = max ( fans , f ( y ) + 1 ) <NEWLINE> <DEDENT> dp [ x ] = fans <NEWLINE> return dp [ x ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , f ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 13 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> <NL> def f ( n ) : <NEWLINE> <INDENT> h = [ I ( ) for _ in range ( n ) ] <NEWLINE> hm = max ( h ) <NEWLINE> m = I ( ) <NEWLINE> ms = [ ] <NEWLINE> ma = [ ] <NEWLINE> zf = False <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> nama , mp , target , damege = LS ( ) <NEWLINE> mp = int ( mp ) <NEWLINE> damege = int ( damege ) <NEWLINE> if damege == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if mp == 0 : <NEWLINE> <INDENT> zf = True <NEWLINE> continue <NEWLINE> <DEDENT> if target == <STRING> : <NEWLINE> <INDENT> ma . append ( ( mp , damege ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ms . append ( ( mp , damege ) ) <NEWLINE> <DEDENT> <DEDENT> if zf : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> ds = [ inf ] * ( hm + 1 ) <NEWLINE> ds [ 0 ] = 0 <NEWLINE> for mp , dm in ms : <NEWLINE> <INDENT> for i in range ( dm , hm + 1 ) : <NEWLINE> <INDENT> if ds [ i ] > mp + ds [ i - dm ] : <NEWLINE> <INDENT> ds [ i ] = mp + ds [ i - dm ] <NEWLINE> <DEDENT> <DEDENT> if dm < 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> t = min ( ds [ - dm + 1 : ] ) <NEWLINE> if ds [ - 1 ] > t + mp : <NEWLINE> <INDENT> ds [ - 1 ] = t + mp <NEWLINE> <NL> <DEDENT> <DEDENT> da = [ inf ] * ( hm + 1 ) <NEWLINE> da [ 0 ] = 0 <NEWLINE> for mp , dm in ma : <NEWLINE> <INDENT> for i in range ( dm , hm + 1 ) : <NEWLINE> <INDENT> if da [ i ] > mp + da [ i - dm ] : <NEWLINE> <INDENT> da [ i ] = mp + da [ i - dm ] <NEWLINE> <DEDENT> <DEDENT> if dm < 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> t = min ( da [ - dm + 1 : ] ) <NEWLINE> if da [ - 1 ] > t + mp : <NEWLINE> <INDENT> da [ - 1 ] = t + mp <NEWLINE> <DEDENT> <DEDENT> for i in range ( hm - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if ds [ i ] > ds [ i + 1 ] : <NEWLINE> <INDENT> ds [ i ] = ds [ i + 1 ] <NEWLINE> <DEDENT> if da [ i ] > da [ i + 1 ] : <NEWLINE> <INDENT> da [ i ] = da [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> mm = r = inf <NEWLINE> for i in range ( hm , - 1 , - 1 ) : <NEWLINE> <INDENT> if mm <= da [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> mm = tp = da [ i ] <NEWLINE> for hi in h : <NEWLINE> <INDENT> if hi > i : <NEWLINE> <INDENT> tp += ds [ hi - i ] <NEWLINE> <DEDENT> <DEDENT> if r > tp : <NEWLINE> <INDENT> r = tp <NEWLINE> <DEDENT> <DEDENT> return r <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rr . append ( f ( n ) ) <NEWLINE> <NL> <DEDENT> return <STRING> . join ( map ( str , rr ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> dp = [ [ 0 ] * 3 ] * N <NEWLINE> <NL> dp [ 0 ] [ 0 ] = 0 <COMMENT> <NEWLINE> dp [ 0 ] [ 1 ] = 0 <COMMENT> <NEWLINE> dp [ 0 ] [ 2 ] = A [ 0 ] <COMMENT> <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <NL> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + A [ i ] <NEWLINE> dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] ) <NEWLINE> dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] + A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) <NEWLINE> dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] + A [ i ] <NEWLINE> dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if N % 2 == 0 : <NEWLINE> <INDENT> print ( max ( dp [ N - 1 ] [ 1 ] , dp [ N - 1 ] [ 2 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ) <NEWLINE> <DEDENT>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ABs = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> par = [ i for i in range ( N + 1 ) ] <NEWLINE> size = [ 1 for _ in range ( N + 1 ) ] <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <COMMENT> <NEWLINE> return par [ x ] <NEWLINE> <DEDENT> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> return find ( x ) == find ( y ) <NEWLINE> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> par [ x ] = y <NEWLINE> size [ y ] = size [ x ] + size [ y ] <NEWLINE> size [ x ] = 0 <NEWLINE> <NL> <DEDENT> for AB in ABs : <NEWLINE> <INDENT> unite ( AB [ 0 ] , AB [ 1 ] ) <NEWLINE> <DEDENT> print ( max ( size ) ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def list2d ( a , b , c ) : return [ [ c ] * b for i in range ( a ) ] <NEWLINE> def list3d ( a , b , c , d ) : return [ [ [ d ] * c for j in range ( b ) ] for i in range ( a ) ] <NEWLINE> def list4d ( a , b , c , d , e ) : return [ [ [ [ e ] * d for j in range ( c ) ] for j in range ( b ) ] for i in range ( a ) ] <NEWLINE> def ceil ( x , y = 1 ) : return int ( - ( - x // y ) ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( N = None ) : return list ( MAP ( ) ) if N is None else [ INT ( ) for i in range ( N ) ] <NEWLINE> def Yes ( ) : print ( <STRING> ) <NEWLINE> def No ( ) : print ( <STRING> ) <NEWLINE> def YES ( ) : print ( <STRING> ) <NEWLINE> def NO ( ) : print ( <STRING> ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> N = INT ( ) <NEWLINE> A = LIST ( ) <NEWLINE> <NL> dp0 = list2d ( N + 1 , 4 , - INF ) <NEWLINE> dp1 = list2d ( N + 1 , 4 , - INF ) <NEWLINE> dp0 [ 0 ] [ 2 ] = 0 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> if j != 0 : <NEWLINE> <INDENT> dp0 [ i + 1 ] [ j - 1 ] = max ( dp0 [ i + 1 ] [ j - 1 ] , dp0 [ i ] [ j ] ) <NEWLINE> dp0 [ i + 1 ] [ j - 1 ] = max ( dp0 [ i + 1 ] [ j - 1 ] , dp1 [ i ] [ j ] ) <NEWLINE> <DEDENT> if j != 3 : <NEWLINE> <INDENT> dp1 [ i + 1 ] [ j + 1 ] = max ( dp1 [ i + 1 ] [ j + 1 ] , dp0 [ i ] [ j ] + a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if N % 2 == 0 : <NEWLINE> <INDENT> ans = max ( dp0 [ N ] [ 2 ] , dp1 [ N ] [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( dp0 [ N ] [ 1 ] , dp1 [ N ] [ 1 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> R = [ 0 ] * H <NEWLINE> C = [ 0 ] * W <NEWLINE> S = set ( ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> S . add ( ( h - 1 , w - 1 ) ) <NEWLINE> R [ h - 1 ] += 1 <NEWLINE> C [ w - 1 ] += 1 <NEWLINE> <NL> <DEDENT> r = max ( R ) <NEWLINE> c = max ( C ) <NEWLINE> <NL> HL = [ i for i in range ( H ) if R [ i ] == r ] <NEWLINE> WL = [ i for i in range ( W ) if C [ i ] == c ] <NEWLINE> <NL> for h in HL : <NEWLINE> <INDENT> for w in WL : <NEWLINE> <INDENT> if not ( h , w ) in S : <NEWLINE> <INDENT> print ( r + c ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( r + c - 1 ) <NEWLINE>
from math import pi <NEWLINE> a = float ( input ( ) ) <NEWLINE> print ( a * a * pi , 2 * a * pi ) <NEWLINE>
from collections import defaultdict <NEWLINE> from bisect import bisect_right <NEWLINE> <NL> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> n = len ( s ) <NEWLINE> <NL> mp = [ [ ] for _ in range ( 26 ) ] <NEWLINE> s += s <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> mp [ ord ( s [ i ] ) - ord ( <STRING> ) ] . append ( i ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> now = - 1 <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> a = ord ( t [ i ] ) - ord ( <STRING> ) <NEWLINE> nxt = bisect_right ( mp [ a ] , now ) <NEWLINE> if len ( mp [ a ] ) == nxt : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> now = mp [ a ] [ nxt ] <NEWLINE> if now >= n : <NEWLINE> <INDENT> ans += n <NEWLINE> now -= n <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans + now + 1 ) <NEWLINE>
import math <NEWLINE> A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> <NL> B_i = int ( B [ : - 3 ] ) <NEWLINE> B_f = int ( B [ - 2 : ] ) <NEWLINE> <NL> <NL> f = str ( A * B_f ) <NEWLINE> if ( len ( f ) >= 3 ) : <NEWLINE> <INDENT> f_i = int ( f [ : - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f_i = 0 <NEWLINE> <NL> <DEDENT> print ( A * B_i + f_i ) <NEWLINE>
ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = str ( input ( ) ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> re += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> , <STRING> , ac ) <NEWLINE> print ( <STRING> , <STRING> , wa ) <NEWLINE> print ( <STRING> , <STRING> , tle ) <NEWLINE> print ( <STRING> , <STRING> , re ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( input ( ) ) <NEWLINE> wcnt , ecnt , ans , box = 0 , 0 , 0 , [ ] <NEWLINE> W = a . count ( <STRING> ) <NEWLINE> E = a . count ( <STRING> ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] == <STRING> : <NEWLINE> <INDENT> box . append ( E + wcnt ) <NEWLINE> wcnt += 1 <NEWLINE> W -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> box . append ( E + wcnt ) <NEWLINE> ecnt += 1 <NEWLINE> E -= 1 <NEWLINE> <DEDENT> <DEDENT> if a [ n - 1 ] == <STRING> : <NEWLINE> <INDENT> W -= 1 <NEWLINE> box . append ( E + wcnt ) <NEWLINE> wcnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> E -= 1 <NEWLINE> box . append ( E + wcnt ) <NEWLINE> ecnt += 1 <NEWLINE> <DEDENT> print ( min ( box ) ) <NEWLINE>
<NL> W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if x - r >= 0 and x + r <= W : <NEWLINE> <INDENT> if y - r >= 0 and y + r <= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from operator import itemgetter <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> yp = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p_ , y_ = map ( int , input ( ) . split ( ) ) <NEWLINE> yp . append ( [ y_ , p_ , i + 1 ] ) <NEWLINE> <DEDENT> py = sorted ( yp ) <NEWLINE> ken = [ 0 ] * n <NEWLINE> res = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ken [ py [ i ] [ 1 ] - 1 ] += 1 <NEWLINE> p , q , r = py [ i ] [ 1 ] , ken [ py [ i ] [ 1 ] - 1 ] , py [ i ] [ 2 ] <NEWLINE> res . append ( [ p , q , r ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> res . sort ( key = itemgetter ( 2 ) ) <NEWLINE> <COMMENT> <NL> for i in range ( m ) : <NEWLINE> <INDENT> ans1 = [ 0 ] * ( 6 - len ( str ( res [ i ] [ 0 ] ) ) ) <NEWLINE> ans1 . append ( res [ i ] [ 0 ] ) <NEWLINE> ans2 = [ 0 ] * ( 6 - len ( str ( res [ i ] [ 1 ] ) ) ) <NEWLINE> ans2 . append ( res [ i ] [ 1 ] ) <NEWLINE> print ( * ans1 , * ans2 , sep = <STRING> ) <NEWLINE> <DEDENT>
import re <NEWLINE> <NL> N , Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = input ( ) <NEWLINE> lis = [ 0 ] <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> lis . append ( count ) <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( lis [ r - 1 ] - lis [ l - 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def f ( A ) : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> v = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> v *= a <NEWLINE> if v > int ( 1e+18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( v ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> f ( A ) <NEWLINE>
def move ( position ) : <NEWLINE> <INDENT> x = position [ 0 ] <NEWLINE> y = position [ 1 ] <NEWLINE> d = position [ 2 ] <NEWLINE> if d == <STRING> : <NEWLINE> <INDENT> p = <STRING> <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> p = <STRING> <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> p = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = <STRING> <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if p [ i ] in grid [ y ] [ x ] : <NEWLINE> <INDENT> d = p [ i ] <NEWLINE> if d == <STRING> : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> x -= 1 <NEWLINE> break <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> x += 1 <NEWLINE> break <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> y -= 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> y += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return [ x , y , d ] <NEWLINE> <NL> <DEDENT> pos = [ 1 , 1 , <STRING> ] <NEWLINE> grid = [ [ <STRING> for i in range ( 6 ) ] for j in range ( 6 ) ] <NEWLINE> for i in range ( 9 ) : <NEWLINE> <INDENT> inp = input ( ) <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> if inp [ j ] == <STRING> : <NEWLINE> <INDENT> grid [ i // 2 + 1 ] [ j + 1 ] += <STRING> <NEWLINE> grid [ i // 2 + 1 ] [ j + 2 ] += <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 5 ) : <NEWLINE> <INDENT> if inp [ j ] == <STRING> : <NEWLINE> <INDENT> grid [ i // 2 + 1 ] [ j + 1 ] += <STRING> <NEWLINE> grid [ i // 2 + 2 ] [ j + 1 ] += <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> pos = move ( pos ) <NEWLINE> if pos [ 0 ] == 1 and pos [ 1 ] == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import heapq <NEWLINE> <NL> <COMMENT> <NL> q = [ ] <NEWLINE> S = sys . stdin . readlines ( ) <NEWLINE> for line in S : <NEWLINE> <INDENT> if line [ 0 ] . startswith ( <STRING> ) : <NEWLINE> <INDENT> heapq . heappush ( q , - int ( line . split ( ) [ 1 ] ) ) <NEWLINE> <DEDENT> elif line [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( - heapq . heappop ( q ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> P_n = [ i for i in range ( 110 ) if i not in P ] <NEWLINE> abs_value = [ abs ( X - P_n [ j ] ) for j in range ( len ( P_n ) ) ] <NEWLINE> <NL> import sys <NEWLINE> <NL> min_abs = min ( abs_value ) <NEWLINE> for k in range ( len ( abs_value ) ) : <NEWLINE> <INDENT> if abs_value [ k ] == min_abs : <NEWLINE> <INDENT> print ( P_n [ k ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def check ( l ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cnt += a [ i ] // mid <NEWLINE> if a [ i ] % mid != 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> cnt -= 1 <NEWLINE> <NL> <DEDENT> return cnt <= k <NEWLINE> <NL> <NL> <DEDENT> lb , ub = 0 , max ( a ) <NEWLINE> while ub - lb > 1 : <NEWLINE> <INDENT> mid = ( ub + lb ) // 2 <NEWLINE> <NL> if check ( mid ) : <NEWLINE> <INDENT> ub = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lb = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ub ) <NEWLINE>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> num , a , b = 0 , 0 , 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> t , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> num , a , b = abs ( t - num ) , abs ( x - a ) , abs ( y - b ) <NEWLINE> su = a + b <NEWLINE> if num >= su and num % 2 == su % 2 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
m = int ( input ( ) ) <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , key , left , right ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class BinaryTree ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def getRoot ( self ) : <NEWLINE> <INDENT> return self . root <NEWLINE> <DEDENT> def setRoot ( self , v ) : <NEWLINE> <INDENT> self . root = v <NEWLINE> <NL> <DEDENT> def inorder ( self , v = None ) : <NEWLINE> <INDENT> if v is None : <NEWLINE> <INDENT> v = self . root <NEWLINE> <DEDENT> if v . left is not None : <NEWLINE> <INDENT> self . inorder ( v . left ) <NEWLINE> <DEDENT> print ( <STRING> + str ( v . key ) , end = <STRING> ) <NEWLINE> if v . right is not None : <NEWLINE> <INDENT> self . inorder ( v . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def preorder ( self , v = None ) : <NEWLINE> <INDENT> if v is None : <NEWLINE> <INDENT> v = self . root <NEWLINE> <DEDENT> print ( <STRING> + str ( v . key ) , end = <STRING> ) <NEWLINE> if v . left is not None : <NEWLINE> <INDENT> self . preorder ( v . left ) <NEWLINE> <DEDENT> if v . right is not None : <NEWLINE> <INDENT> self . preorder ( v . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def insert ( T , z ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = T . getRoot ( ) <NEWLINE> while x is not None : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . p = y <NEWLINE> <NL> if y is None : <NEWLINE> <INDENT> T . setRoot ( z ) <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( T , k ) : <NEWLINE> <INDENT> x = T . getRoot ( ) <NEWLINE> while x is not None : <NEWLINE> <INDENT> if x . key == k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> elif x . key < k : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> T = BinaryTree ( ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> inp = input ( ) . split ( ) <NEWLINE> if inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> T . inorder ( ) <NEWLINE> print ( ) <NEWLINE> T . preorder ( ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> elif inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> find ( T , int ( inp [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v = Node ( int ( inp [ 1 ] ) , None , None ) <NEWLINE> insert ( T , v ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INT = lambda : int ( input ( ) ) <NEWLINE> INTM = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> STRM = lambda : map ( str , input ( ) . split ( ) ) <NEWLINE> STR = lambda : str ( input ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LISTS = lambda : list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> def do ( ) : <NEWLINE> <INDENT> h , w = INTM ( ) <NEWLINE> ban = np . zeros ( ( h , w ) , dtype = np . int16 ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s = STR ( ) <NEWLINE> for i1 in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i1 ] == <STRING> : <NEWLINE> <INDENT> ban [ i ] [ i1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> left = np . zeros ( ( h , w ) , dtype = np . int16 ) <NEWLINE> right = np . zeros ( ( h , w ) , dtype = np . int16 ) <NEWLINE> up = np . zeros ( ( h , w ) , dtype = np . int16 ) <NEWLINE> down = np . zeros ( ( h , w ) , dtype = np . int16 ) <NEWLINE> <COMMENT> <NL> for i in range ( w ) : <NEWLINE> <INDENT> i2 = w - 1 - i <NEWLINE> if i == 0 : <NEWLINE> <INDENT> left [ : , i ] = ban [ : , i ] <NEWLINE> right [ : , i2 ] = ban [ : , i2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left [ : , i ] = ban [ : , i ] * ( left [ : , i - 1 ] + 1 ) <NEWLINE> right [ : , i2 ] = ban [ : , i2 ] * ( right [ : , i2 + 1 ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> i2 = h - 1 - i <NEWLINE> if i == 0 : <NEWLINE> <INDENT> up [ i , : ] = ban [ i , : ] <NEWLINE> down [ i2 , : ] = ban [ i2 , : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> up [ i , : ] = ban [ i , : ] * ( up [ i - 1 , : ] + 1 ) <NEWLINE> down [ i2 , : ] = ban [ i2 , : ] * ( down [ i2 + 1 , : ] + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> anslist = down + up + right + left <NEWLINE> ans = 0 <NEWLINE> for i in anslist : <NEWLINE> <INDENT> ans = max ( ans , max ( i ) ) <NEWLINE> <DEDENT> print ( ans - 3 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> do ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> stdin = sys . stdin <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import math <NEWLINE> <NL> i_i = lambda : int ( i_s ( ) ) <NEWLINE> i_l = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> i_s = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> K = i_i ( ) <NEWLINE> <NL> res = sum ( [ math . gcd ( math . gcd ( a , b ) , c ) for a in range ( 1 , K + 1 ) for b in range ( 1 , K + 1 ) for c in range ( 1 , K + 1 ) ] ) <NEWLINE> print ( res ) <NEWLINE>
def solve ( n , xs ) : <NEWLINE> <NL> <INDENT> ans = 0 <NEWLINE> tmp = { } <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> l = i + 1 + xs [ i ] <NEWLINE> r = i + 1 - xs [ i ] <NEWLINE> <NL> if l in tmp : <NEWLINE> <INDENT> ans += tmp [ l ] <NEWLINE> <NL> <DEDENT> if r in tmp : <NEWLINE> <INDENT> tmp [ r ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp [ r ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> xs = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( solve ( n , xs ) ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from itertools import accumulate <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def acc ( li , n ) : <NEWLINE> <INDENT> res = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if li [ i ] == <STRING> : <NEWLINE> <INDENT> res [ i + 1 ] = 1 <NEWLINE> <DEDENT> elif li [ i ] == <STRING> : <NEWLINE> <INDENT> res [ i + 1 ] = 2 <NEWLINE> <DEDENT> <DEDENT> return list ( accumulate ( res ) ) <NEWLINE> <NL> <NL> <DEDENT> def restore ( x , y , li ) : <NEWLINE> <INDENT> return ( li [ y ] - li [ x - 1 ] ) % 3 <NEWLINE> <NL> <NL> <DEDENT> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> M = len ( T ) <NEWLINE> <NL> acc_S = acc ( S , N ) <NEWLINE> acc_T = acc ( T , M ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> v_S = restore ( a , b , acc_S ) <NEWLINE> v_T = restore ( c , d , acc_T ) <NEWLINE> print ( <STRING> ) if v_S == v_T else print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> l = list ( map ( int , N ) ) <NEWLINE> i = 0 <NEWLINE> <COMMENT> <NL> <NL> if int ( N ) < 9 : <NEWLINE> <INDENT> ans = int ( N ) <NEWLINE> <NL> <DEDENT> elif l . count ( 9 ) >= len ( l ) - 1 : <NEWLINE> <INDENT> if l [ len ( l ) - 1 ] != 9 : <NEWLINE> <INDENT> spot = 8 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> spot = min ( l ) <NEWLINE> <DEDENT> ans = spot + ( len ( l ) - 1 ) * 9 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if l [ i ] < 9 and i < len ( l ) - 1 : <NEWLINE> <INDENT> spot = l [ i ] - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> ans = spot + ( len ( l ) - 1 ) * 9 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> lr . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <COMMENT> <NL> r0 = 0 <NEWLINE> tmpr = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> l0 = 0 <NEWLINE> tmpl = 0 <NEWLINE> for i , x in enumerate ( lr ) : <NEWLINE> <INDENT> l , r = x <NEWLINE> if tmpl < l : <NEWLINE> <INDENT> l0 = i <NEWLINE> tmpl = l <NEWLINE> <DEDENT> if tmpr > r : <NEWLINE> <INDENT> r0 = i <NEWLINE> tmpr = r <NEWLINE> <DEDENT> <DEDENT> if l0 == r0 : <NEWLINE> <INDENT> ans = lr [ r0 ] [ 1 ] - lr [ l0 ] [ 0 ] + 1 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == l0 : continue <NEWLINE> l , r = lr [ i ] <NEWLINE> tmp = max ( tmp , r - l + 1 ) <NEWLINE> <DEDENT> ans += tmp <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans0 = max ( 0 , lr [ r0 ] [ 1 ] - lr [ l0 ] [ 0 ] + 1 ) <NEWLINE> tmp = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == l0 or i == r0 : continue <NEWLINE> l , r = lr [ i ] <NEWLINE> tmp = max ( tmp , r - l + 1 ) <NEWLINE> <DEDENT> ans0 += tmp <NEWLINE> <NL> <NL> import heapq <NEWLINE> class pqheap : <NEWLINE> <INDENT> def __init__ ( self , key = None ) : <NEWLINE> <INDENT> self . p = list ( ) <NEWLINE> self . q = list ( ) <NEWLINE> <DEDENT> def insert ( self , x ) : <NEWLINE> <INDENT> heapq . heappush ( self . p , x ) <NEWLINE> return <NEWLINE> <DEDENT> def erase ( self , x ) : <NEWLINE> <INDENT> heapq . heappush ( self . q , x ) <NEWLINE> return <NEWLINE> <DEDENT> def minimum ( self ) : <NEWLINE> <INDENT> while self . q and self . p [ 0 ] == self . q [ 0 ] : <NEWLINE> <INDENT> heapq . heappop ( self . p ) <NEWLINE> heapq . heappop ( self . q ) <NEWLINE> <DEDENT> return self . p [ 0 ] if len ( self . p ) > 0 else None <NEWLINE> <DEDENT> <DEDENT> pq = pqheap ( ) <NEWLINE> <NL> [ pq . insert ( x [ 1 ] ) for i , x in enumerate ( lr ) if i != l0 and i != r0 ] <NEWLINE> l1 , r1 = lr [ r0 ] <NEWLINE> l2 , r2 = lr [ l0 ] <NEWLINE> if pq . minimum ( ) : r2 = min ( r2 , pq . minimum ( ) ) <NEWLINE> ans1 = max ( r1 - l1 + 1 , 0 ) <NEWLINE> ans1 += max ( r2 - l2 + 1 , 0 ) <NEWLINE> for i , [ l , r ] in enumerate ( lr ) : <NEWLINE> <INDENT> if i == l0 or i == r0 : continue <NEWLINE> tmp = 0 <NEWLINE> l1 = max ( l1 , l ) <NEWLINE> pq . erase ( r ) <NEWLINE> tmp = max ( r1 - l1 + 1 , 0 ) <NEWLINE> if pq . minimum ( ) : <NEWLINE> <INDENT> r2 = min ( lr [ l0 ] [ 1 ] , pq . minimum ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l2 , r2 = lr [ l0 ] <NEWLINE> <DEDENT> tmp += max ( r2 - l2 + 1 , 0 ) <NEWLINE> ans1 = max ( ans1 , tmp ) <NEWLINE> <DEDENT> print ( max ( ans1 , ans0 ) ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> ans = [ 0 ] * n <NEWLINE> ans [ 0 ] = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i == 2 : <NEWLINE> <INDENT> ans [ i - 1 ] = abs ( li [ 1 ] - li [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i - 1 ] = min ( abs ( li [ i - 1 ] - li [ i - 2 ] ) + ans [ i - 2 ] , abs ( li [ i - 1 ] - li [ i - 3 ] ) + ans [ i - 3 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans [ - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> an = map ( int , input ( ) . split ( ) ) <NEWLINE> num = 1 <NEWLINE> max = 10 ** 18 <NEWLINE> for i in an : <NEWLINE> <INDENT> if num < max : <NEWLINE> <INDENT> num *= i <NEWLINE> <DEDENT> if ( i == 0 ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if num > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > pow ( 10 , 18 ) or ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
s = input ( ) [ : : - 1 ] <NEWLINE> <NL> count = [ 0 ] * 2019 <NEWLINE> count [ 0 ] = 1 <COMMENT> <NEWLINE> <NL> num , d = 0 , 1 <COMMENT> <NEWLINE> <NL> for char in s : <NEWLINE> <INDENT> num += int ( char ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> count [ num ] += 1 <COMMENT> <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for c in count : <NEWLINE> <INDENT> ans += c * ( c - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from functools import reduce <NEWLINE> import math <NEWLINE> import sys <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> def gcd ( * args ) : <NEWLINE> <INDENT> return reduce ( math . gcd , args ) <NEWLINE> <NL> <DEDENT> if K == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif K == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = K * ( K + 1 ) // 2 <NEWLINE> for i in range ( 1 , K ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> ans += 6 * math . gcd ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , K - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K ) : <NEWLINE> <INDENT> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> ans += 6 * gcd ( i , j , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ex = [ 0 for i in range ( n ) ] <NEWLINE> fri = { } <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ex [ a - 1 ] == 0 and ex [ b - 1 ] == 0 : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> ex [ a - 1 ] = a <NEWLINE> ex [ b - 1 ] = a <NEWLINE> fri [ a ] = [ a , b ] <NEWLINE> <DEDENT> elif ex [ a - 1 ] == 0 : <NEWLINE> <INDENT> ex [ a - 1 ] = ex [ b - 1 ] <NEWLINE> fri [ ex [ b - 1 ] ] . append ( a ) <NEWLINE> <DEDENT> elif ex [ b - 1 ] == 0 : <NEWLINE> <INDENT> ex [ b - 1 ] = ex [ a - 1 ] <NEWLINE> fri [ ex [ a - 1 ] ] . append ( b ) <NEWLINE> <DEDENT> elif ex [ a - 1 ] == ex [ b - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> shozoku = min ( ex [ a - 1 ] , ex [ b - 1 ] ) <NEWLINE> mu = max ( ex [ a - 1 ] , ex [ b - 1 ] ) <NEWLINE> for j in range ( len ( fri [ mu ] ) ) : <NEWLINE> <INDENT> ex [ fri [ mu ] [ j ] - 1 ] = shozoku <NEWLINE> <DEDENT> fri [ shozoku ] . extend ( fri . pop ( mu ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for key in fri : <NEWLINE> <INDENT> ans = max ( ans , len ( fri [ key ] ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> amax = max ( a ) <NEWLINE> dp = [ True ] * ( amax + 1 ) <NEWLINE> <NL> import collections <NEWLINE> c = collections . Counter ( a ) <NEWLINE> <NL> d = [ ] <NEWLINE> for ck , cv in c . items ( ) : <NEWLINE> <INDENT> if cv >= 2 : <NEWLINE> <INDENT> d . append ( ck ) <NEWLINE> <DEDENT> <DEDENT> dset = set ( d ) <NEWLINE> <NL> aa = set ( ) <NEWLINE> for ai in a : <NEWLINE> <INDENT> if dp [ ai ] : <NEWLINE> <INDENT> aa . add ( ai ) <NEWLINE> for aj in range ( ai * 2 , amax + 1 , ai ) : <NEWLINE> <INDENT> dp [ aj ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> aa = aa - dset <NEWLINE> print ( len ( aa ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ [ 0 for i in range ( m ) ] for j in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> A [ i ] [ j ] = d [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> b = [ 0 for i in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> c += A [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from sys import stdin , setrecursionlimit <NEWLINE> <NL> setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> t = 1 <NEWLINE> tpass = [ 1 ] <NEWLINE> k = 0 <NEWLINE> j = 1 <NEWLINE> temp3 = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> temp = A [ t - 1 ] <NEWLINE> if i == K - 1 : <NEWLINE> <INDENT> print ( temp ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if temp3 [ temp - 1 ] != 0 : <NEWLINE> <INDENT> idx = tpass . index ( temp ) <NEWLINE> l = len ( tpass ) <NEWLINE> j = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> t = temp <NEWLINE> temp3 [ t - 1 ] = 1 <NEWLINE> tpass . append ( temp ) <NEWLINE> k += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> a = K - k <NEWLINE> loop = l - idx <NEWLINE> b = a % loop <NEWLINE> temp2 = tpass [ idx : ] <NEWLINE> ans = temp2 [ b - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
from itertools import permutations <NEWLINE> <NL> import numpy as np <NEWLINE> from numba import njit , i8 <NEWLINE> <NL> <NL> @ njit ( i8 [ : , : ] ( i8 , i8 , i8 [ : , : ] , i8 [ : , : ] ) , cache = True ) <NEWLINE> def calc_cost ( N , C , D , c ) : <NEWLINE> <INDENT> cost = np . zeros ( ( C , 3 ) , dtype = np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> for k in range ( C ) : <NEWLINE> <INDENT> cost [ k ] [ ( i + j ) % 3 ] += D [ c [ i ] [ j ] - 1 ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return cost <NEWLINE> <NL> <NL> <DEDENT> N , C , * Dc = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> D = np . array ( Dc [ : C * C ] , dtype = np . int64 ) . reshape ( C , C ) <NEWLINE> c = np . array ( Dc [ C * C : ] , dtype = np . int64 ) . reshape ( N , N ) <NEWLINE> cost = calc_cost ( N , C , D , c ) <NEWLINE> <NL> ans = min ( <NEWLINE> <INDENT> sum ( cost [ c ] [ i ] for i , c in enumerate ( colors ) ) <NEWLINE> for colors in permutations ( range ( C ) , 3 ) <NEWLINE> <DEDENT> ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> strX = input ( ) <NEWLINE> <NL> <COMMENT> <NL> decX = int ( strX , 2 ) <NEWLINE> <NL> <COMMENT> <NL> pop_c = strX . count ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> f_p = decX % ( pop_c + 1 ) <NEWLINE> <NL> <COMMENT> <NL> if pop_c == 1 : <NEWLINE> <INDENT> f_m = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f_m = decX % ( pop_c - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( 0 , N ) : <NEWLINE> <INDENT> if strX [ i ] == <STRING> : <NEWLINE> <INDENT> pop_a = ( f_p + pow ( 2 , ( N - 1 - i ) , ( pop_c + 1 ) ) ) % ( pop_c + 1 ) <NEWLINE> Ans = 1 <NEWLINE> <NL> <DEDENT> elif pop_c == 1 : <NEWLINE> <INDENT> pop_a = 0 <NEWLINE> Ans = 0 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> pop_a = f_m - ( pow ( 2 , ( N - 1 - i ) , ( pop_c - 1 ) ) ) <NEWLINE> if pop_a < 0 : <NEWLINE> <INDENT> pop_a = pop_a + pop_c - 1 <NEWLINE> <DEDENT> Ans = 1 <NEWLINE> <NL> <DEDENT> while pop_a > 0 : <NEWLINE> <INDENT> wkpop = bin ( pop_a ) . count ( <STRING> ) <NEWLINE> pop_a = pop_a % wkpop <NEWLINE> Ans += 1 <NEWLINE> <NL> <DEDENT> print ( Ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> from bisect import bisect_left <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> a = bisect_left ( l , l [ i ] + l [ j ] ) <NEWLINE> ans += a - 1 - j <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> <NL> inputLine = input ( ) <NEWLINE> N = int ( inputLine . split ( <STRING> ) [ 0 ] ) <NEWLINE> M = int ( inputLine . split ( <STRING> ) [ 1 ] ) <NEWLINE> <NL> inputLine = input ( ) <NEWLINE> H = inputLine . split ( <STRING> ) <NEWLINE> for i in range ( len ( H ) ) : <NEWLINE> <INDENT> H [ i ] = int ( H [ i ] ) <NEWLINE> <NL> <DEDENT> root = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> inputLine = input ( ) <NEWLINE> A = int ( inputLine . split ( <STRING> ) [ 0 ] ) <NEWLINE> B = int ( inputLine . split ( <STRING> ) [ 1 ] ) <NEWLINE> <NL> root . append ( [ A , B ] ) <NEWLINE> root . append ( [ B , A ] ) <NEWLINE> <NL> <DEDENT> root . sort ( ) <NEWLINE> <NL> root2 = [ ] <NEWLINE> for i in range ( len ( root ) ) : <NEWLINE> <INDENT> root2 . append ( root [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> allObservatoryCheck = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> allObservatoryCheck . append ( True ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <NL> <INDENT> startPoint = bisect . bisect_left ( root2 , i + 1 ) <NEWLINE> <NL> for j in range ( startPoint , len ( root ) ) : <NEWLINE> <NL> <INDENT> if root [ j ] [ 0 ] == i + 1 : <NEWLINE> <INDENT> if H [ i ] <= H [ root [ j ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> allObservatoryCheck [ i ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> if root [ j ] [ 0 ] > i + 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> result = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if allObservatoryCheck [ i ] == True : <NEWLINE> <INDENT> result += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL>
import math <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> N = math . factorial ( n ) <NEWLINE> if abs ( n - m ) > 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif abs ( n - m ) == 0 : <NEWLINE> <INDENT> print ( 2 * N * N % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT> elif n > m : <NEWLINE> <INDENT> print ( ( N * N // n ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N * N * m % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT>
def fib ( n , fib_table ) : <NEWLINE> <INDENT> if n == 0 or n == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if fib_table [ n ] != None : <NEWLINE> <INDENT> return fib_table [ n ] <NEWLINE> <DEDENT> fib_table [ n ] = fib ( n - 1 , fib_table ) + fib ( n - 2 , fib_table ) <NEWLINE> return fib_table [ n ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> fib_table = [ None ] * ( n + 1 ) <NEWLINE> fib_table [ 0 ] = 1 <NEWLINE> fib_table [ 1 ] = 1 <NEWLINE> <NL> print ( fib ( n , fib_table ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . insert ( 0 , 0 ) <NEWLINE> list = [ ] <NEWLINE> replist = [ ] <NEWLINE> judge = [ True ] * ( 2 * 10 ** 5 + 1 ) <NEWLINE> pos = 1 <NEWLINE> owari = True <NEWLINE> while owari : <NEWLINE> <INDENT> judge [ pos ] = False <NEWLINE> list . append ( pos ) <NEWLINE> pos = A [ pos ] <NEWLINE> if not judge [ pos ] : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> replist . append ( pos ) <NEWLINE> judge [ pos ] = True <NEWLINE> pos = A [ pos ] <NEWLINE> if judge [ pos ] : <NEWLINE> <INDENT> owari = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if K <= len ( list ) - 1 : <NEWLINE> <INDENT> print ( list [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = K - len ( list ) + 1 <NEWLINE> print ( replist [ ( K % len ( replist ) ) - 1 ] ) <NEWLINE> <NL> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp = k <NEWLINE> <NL> ans = abs ( x ) % d <NEWLINE> k = k - int ( abs ( x ) / d ) <NEWLINE> <NL> if k < 0 : <NEWLINE> <INDENT> ans = abs ( x ) <NEWLINE> ans = ans - ( tmp * d ) <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> if abs ( ans ) <= d and ( k - i ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( ans ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif ans >= 0 : <NEWLINE> <INDENT> ans = ans - d <NEWLINE> <DEDENT> elif ans < 0 : <NEWLINE> <INDENT> ans = ans + d <NEWLINE> <NL> <DEDENT> <DEDENT> print ( abs ( ans ) ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> d = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> c += math . gcd ( d , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = sum ( a ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> s -= a [ i ] <NEWLINE> ans += a [ i ] * s <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n : int ) -> None : <NEWLINE> <INDENT> self . forest = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def union ( self , x : int , y : int ) -> None : <NEWLINE> <INDENT> x = self . findRoot ( x ) <NEWLINE> y = self . findRoot ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . forest [ x ] > self . forest [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . forest [ x ] += self . forest [ y ] <NEWLINE> self . forest [ y ] = x <NEWLINE> return <NEWLINE> <NL> <DEDENT> def findRoot ( self , x : int ) -> int : <NEWLINE> <INDENT> if self . forest [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . forest [ x ] = self . findRoot ( self . forest [ x ] ) <NEWLINE> return self . forest [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def issame ( self , x : int , y : int ) -> bool : <NEWLINE> <INDENT> return self . findRoot ( x ) == self . findRoot ( y ) <NEWLINE> <NL> <DEDENT> def size ( self , x : int ) -> int : <NEWLINE> <INDENT> return - self . forest [ self . findRoot ( x ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> s = set ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ai , bi = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( ai - 1 , bi - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> s . add ( uf . findRoot ( i ) ) <NEWLINE> <DEDENT> print ( len ( s ) - 1 ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <NL> print ( <STRING> ) if N % 9 == 0 else print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> layers = [ 1 ] <NEWLINE> patties = [ 1 ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> layer_i = 2 * layers [ i - 1 ] + 3 <NEWLINE> patty_i = 2 * patties [ i - 1 ] + 1 <NEWLINE> layers . append ( layer_i ) <NEWLINE> patties . append ( patty_i ) <NEWLINE> <NL> <DEDENT> def f ( n , x ) : <NEWLINE> <INDENT> if x == 1 : <NEWLINE> <INDENT> return 1 if n == 0 else 0 <NEWLINE> <NL> <DEDENT> elif 1 < x <= 1 + layers [ n - 1 ] : <NEWLINE> <INDENT> return f ( n - 1 , x - 1 ) <NEWLINE> <NL> <DEDENT> elif x == 2 + layers [ n - 1 ] : <NEWLINE> <INDENT> return patties [ n - 1 ] + 1 <NEWLINE> <NL> <DEDENT> elif 2 + layers [ n - 1 ] < x <= 2 + 2 * layers [ n - 1 ] : <NEWLINE> <INDENT> return patties [ n - 1 ] + 1 + f ( n - 1 , x - 2 - layers [ n - 1 ] ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> return 2 * patties [ n - 1 ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( f ( N , X ) ) <NEWLINE>
comp = 0 <NEWLINE> def m ( L , R ) : <NEWLINE> <INDENT> global comp <NEWLINE> j = 0 <NEWLINE> for l in L : <NEWLINE> <INDENT> while j < len ( R ) and R [ j ] < l : <NEWLINE> <INDENT> yield R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> yield l <NEWLINE> <DEDENT> while j < len ( R ) : <NEWLINE> <INDENT> yield R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> comp += len ( L ) + len ( R ) <NEWLINE> <DEDENT> def merge ( A ) : <NEWLINE> <INDENT> global comp <NEWLINE> if len ( A ) == 1 : <NEWLINE> <INDENT> return A <NEWLINE> <DEDENT> if len ( A ) == 2 : <NEWLINE> <INDENT> comp += 2 <NEWLINE> a , b = A <NEWLINE> return A if a < b else ( b , a ) <NEWLINE> <DEDENT> mid = len ( A ) // 2 <NEWLINE> A [ : ] = m ( merge ( A [ : mid ] ) , merge ( A [ mid : ] ) ) <NEWLINE> return A <NEWLINE> <NL> <DEDENT> n , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> B = merge ( A ) <NEWLINE> print ( * B ) <NEWLINE> print ( comp ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> C = np . array ( A ) <NEWLINE> D = np . array ( B ) <NEWLINE> <NL> m_inf = np . median ( C ) <NEWLINE> m_sup = np . median ( D ) <NEWLINE> <NL> if N % 2 == 0 : <NEWLINE> <INDENT> ans = 2 * m_sup - 2 * m_inf + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = m_sup - m_inf + 1 <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> comb = list ( itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) ) <NEWLINE> <NL> ans = [ 0 ] * len ( comb ) <NEWLINE> if ans == [ ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( len ( comb ) ) : <NEWLINE> <INDENT> if comb [ j ] [ b - 1 ] - comb [ j ] [ a - 1 ] == c : <NEWLINE> <INDENT> ans [ j ] += d <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ab_lst = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> ba_lst = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = ab_lst [ i ] [ 0 ] <NEWLINE> b = ab_lst [ i ] [ 1 ] <NEWLINE> ba = [ b , a ] <NEWLINE> ba_lst [ i ] = ba <NEWLINE> <DEDENT> ba_lst . sort ( ) <NEWLINE> <NL> lst = [ ] <NEWLINE> b = ba_lst [ 0 ] [ 0 ] <NEWLINE> a = ba_lst [ 0 ] [ 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b_tmp = ba_lst [ i ] [ 0 ] <NEWLINE> a_tmp = ba_lst [ i ] [ 1 ] <NEWLINE> <NL> if b == b_tmp : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> a += a_tmp <NEWLINE> <DEDENT> if i == n - 1 : <NEWLINE> <INDENT> lst . append ( [ b , a ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> lst . append ( [ b , a ] ) <NEWLINE> b = b_tmp <NEWLINE> a = a_tmp <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( lst ) > 1 : <NEWLINE> <INDENT> if ba_lst [ - 1 ] [ 0 ] != ba_lst [ - 2 ] [ 0 ] : <NEWLINE> <INDENT> lst . append ( [ ba_lst [ - 1 ] [ 0 ] , ba_lst [ - 1 ] [ 1 ] ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> accumulate = 0 <NEWLINE> flag = True <NEWLINE> for i in range ( len ( lst ) ) : <NEWLINE> <INDENT> accumulate += lst [ i ] [ 1 ] <NEWLINE> if accumulate > lst [ i ] [ 0 ] : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> import math <NEWLINE> <NL> m = int ( input ( ) ) <NEWLINE> g = list ( range ( 1 , m + 1 ) ) <NEWLINE> res = 0 <NEWLINE> for c in itertools . combinations_with_replacement ( g , 3 ) : <NEWLINE> <INDENT> set_c = set ( c ) <NEWLINE> set_list_c = list ( set_c ) <NEWLINE> if len ( set_c ) == 3 : <NEWLINE> <INDENT> n = 6 <NEWLINE> tmp_res = math . gcd ( set_list_c [ 0 ] , set_list_c [ 1 ] ) <NEWLINE> tmp_res = math . gcd ( tmp_res , set_list_c [ 2 ] ) <NEWLINE> <DEDENT> elif len ( set_c ) == 2 : <NEWLINE> <INDENT> n = 3 <NEWLINE> tmp_res = math . gcd ( set_list_c [ 0 ] , set_list_c [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = 1 <NEWLINE> tmp_res = set_list_c [ 0 ] <NEWLINE> <DEDENT> res += tmp_res * n <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> stdin = sys . stdin <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> MIN = - 10 ** 9 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> IINF = 10 ** 18 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> s = str ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = n <NEWLINE> dp = [ 0 for j in range ( n + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> dp [ i + 1 ] = dp [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] = dp [ i ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = min ( ans , dp [ i ] + ( ( n - i - 1 ) - ( dp [ n ] - dp [ i + 1 ] ) ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
from itertools import combinations <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mn = 10 ** 18 <NEWLINE> for B in combinations ( range ( 1 , N ) , K - 1 ) : <COMMENT> <NEWLINE> <INDENT> mx = A [ 0 ] <COMMENT> <NEWLINE> score = 0 <NEWLINE> for n in range ( 1 , N ) : <NEWLINE> <INDENT> if n in B : <COMMENT> <NEWLINE> <INDENT> if A [ n ] <= mx : <COMMENT> <NEWLINE> <INDENT> mx += 1 <NEWLINE> score += ( mx - A [ n ] ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> mx = A [ n ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> mx = max ( mx , A [ n ] ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> mn = min ( mn , score ) <NEWLINE> <DEDENT> print ( mn ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> ans = 10 ** 9 + 7 <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> miss = 0 <NEWLINE> tmp = s [ i : i + len ( t ) ] <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if tmp [ j ] != t [ j ] : <NEWLINE> <INDENT> miss += 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , miss ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 998244353 <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> s = S ( ) <NEWLINE> t = S ( ) <NEWLINE> l = len ( t ) <NEWLINE> def f ( s ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> for c in s : <NEWLINE> <INDENT> while i < l and t [ i ] != c : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> if i == l : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if f ( s [ 0 : : 2 ] ) or f ( s [ 1 : : 2 ] ) : <NEWLINE> <INDENT> rr . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rr . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> break <NEWLINE> <NL> <NL> <NL> <DEDENT> return <STRING> . join ( map ( str , rr ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL> <NL>
def f ( x ) : <NEWLINE> <INDENT> return int ( x ) - 1 <NEWLINE> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( f , input ( ) . split ( ) ) ) <NEWLINE> town = 0 <NEWLINE> i = 0 <NEWLINE> l = [ - 1 ] * n <NEWLINE> while True : <NEWLINE> <INDENT> if l [ town ] != - 1 : <NEWLINE> <INDENT> j = l [ town ] <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> l [ town ] += i <NEWLINE> town = a [ town ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if k >= i : <NEWLINE> <INDENT> k = ( k - j ) % ( i - j ) + j <NEWLINE> <DEDENT> print ( l . index ( k ) + 1 ) <NEWLINE>
def gcd ( x , y ) : <NEWLINE> <INDENT> while y : <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> res = [ 0 ] * ( k + 1 ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> res [ gcd ( i , j ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for n in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for r in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( r , n ) * res [ r ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] != ( i - ans ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans if ans != n else - 1 ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> trans = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> townOrder = [ - 1 for _ in range ( N + 1 ) ] <NEWLINE> townOrder [ 1 ] = 1 <NEWLINE> nextTown = 1 <NEWLINE> cicleStart = 0 <NEWLINE> cicleEnd = 0 <NEWLINE> <NL> for order in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> nextTown = trans [ nextTown - 1 ] <NEWLINE> if townOrder [ nextTown ] == - 1 : <NEWLINE> <INDENT> townOrder [ nextTown ] = order + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cicleStart = townOrder [ nextTown ] <NEWLINE> cicleEnd = order + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> exc = cicleStart - 1 <NEWLINE> cicle = cicleEnd - cicleStart <NEWLINE> <NL> if K > exc : <NEWLINE> <INDENT> K -= exc <NEWLINE> rest = K % cicle <NEWLINE> for _ in range ( rest ) : <NEWLINE> <INDENT> nextTown = trans [ nextTown - 1 ] <NEWLINE> <DEDENT> print ( nextTown ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nextTown = 1 <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> nextTown = trans [ nextTown - 1 ] <NEWLINE> <DEDENT> print ( nextTown ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> while i <= n : <NEWLINE> <INDENT> x = i <NEWLINE> if ( x % 3 == 0 or x % 10 == 3 ) : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = int ( x / 10 ) <NEWLINE> while x > 0 : <NEWLINE> <INDENT> if ( x % 10 == 3 ) : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> x = int ( x / 10 ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( ) <NEWLINE>
from itertools import accumulate <NEWLINE> from bisect import bisect_right <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_accumulate = list ( accumulate ( [ 0 ] + A ) ) <NEWLINE> B_accumulate = list ( accumulate ( [ 0 ] + B ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> remain = k - A_accumulate [ i ] <NEWLINE> <NL> if remain < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> j = bisect_right ( B_accumulate , remain ) <NEWLINE> <NL> ans = max ( ans , i + j - 1 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , M , K , * AB = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> A = AB [ : N ] <NEWLINE> B = AB [ N : ] <NEWLINE> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> for i in range ( N ) : a . append ( a [ i ] + A [ i ] ) <NEWLINE> for i in range ( M ) : b . append ( b [ i ] + B [ i ] ) <NEWLINE> ans = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> num_list = [ ] <NEWLINE> <NL> def leg_num ( c , t ) : <NEWLINE> <INDENT> return 2 * c + 4 * t <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> leg_num_list = [ ] <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> if leg_num ( j , i - j ) <= 100 : <NEWLINE> <INDENT> leg_num_list . append ( leg_num ( j , i - j ) ) <NEWLINE> <DEDENT> if leg_num ( i - j , j ) <= 100 : <NEWLINE> <INDENT> leg_num_list . append ( leg_num ( i - j , j ) ) <NEWLINE> <DEDENT> <DEDENT> num_list . append ( leg_num_list ) <NEWLINE> <NL> <DEDENT> x , y = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if y in num_list [ x - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dpt = [ 0 ] * ( W + 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( W , w - 1 , - 1 ) : <NEWLINE> <INDENT> a = dpt [ j ] <NEWLINE> b = dpt [ j - w ] + v <NEWLINE> if a > b : <NEWLINE> <INDENT> dpt [ j ] = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dpt [ j ] = b <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dpt [ W ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ [ 0 for j in range ( m ) ] for i in range ( n ) ] <NEWLINE> B = [ [ 0 for j in range ( 1 ) ] for i in range ( m ) ] <NEWLINE> C = [ [ 0 for j in range ( 1 ) ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> A [ i ] [ j ] = D [ j ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B [ i ] [ 0 ] = int ( input ( ) ) <NEWLINE> <DEDENT> S = int ( 0 ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> S = S + ( A [ j ] [ i ] * B [ i ] [ 0 ] ) <NEWLINE> <DEDENT> C [ j ] [ 0 ] = S <NEWLINE> S = 0 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( C [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> color = [ - 1 ] * N <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> def steps ( v , col = 0 ) : <NEWLINE> <INDENT> color [ v ] = col <NEWLINE> for nv in graph [ v ] : <NEWLINE> <INDENT> if color [ nv ] != - 1 : <NEWLINE> <INDENT> if color [ nv ] == col : return False <NEWLINE> continue <NEWLINE> <DEDENT> if not steps ( nv , 1 - col ) : return False <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> flag = True <NEWLINE> for v in range ( N ) : <NEWLINE> <INDENT> if color [ v ] != - 1 : continue <NEWLINE> if not steps ( v ) : flag = False <NEWLINE> <NL> <DEDENT> if flag : <NEWLINE> <INDENT> tmp = color . count ( 0 ) <NEWLINE> print ( tmp * ( N - tmp ) - M ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N * ( N - 1 ) // 2 - M ) <NEWLINE> <DEDENT>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> not_good = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if h [ a - 1 ] <= h [ b - 1 ] : <NEWLINE> <INDENT> not_good . append ( a ) <NEWLINE> <DEDENT> if h [ a - 1 ] >= h [ b - 1 ] : <NEWLINE> <INDENT> not_good . append ( b ) <NEWLINE> <DEDENT> <DEDENT> print ( n - len ( set ( not_good ) ) ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> row = [ 0 for i in range ( h ) ] <NEWLINE> col = [ 0 for i in range ( w ) ] <NEWLINE> a = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> r , c = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> a . append ( [ r , c ] ) <NEWLINE> row [ r ] += 1 <NEWLINE> col [ c ] += 1 <NEWLINE> <DEDENT> rmax = max ( row ) <NEWLINE> cmax = max ( col ) <NEWLINE> ans = rmax + cmax <NEWLINE> flag = row . count ( rmax ) * col . count ( cmax ) <NEWLINE> for i , j in a : <NEWLINE> <INDENT> if ( row [ i ] == rmax and col [ j ] == cmax ) : <NEWLINE> <INDENT> flag -= 1 <NEWLINE> <DEDENT> <DEDENT> if ( flag == 0 ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( K - A ) <= 0 : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( K - A - B ) <= 0 : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = ( K - A - B ) <NEWLINE> print ( A - c ) <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> T = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> flag1 = True <NEWLINE> ans = - 1 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> flag = True <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> if T [ j ] [ k + 1 ] < x : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == True and flag1 == True : <NEWLINE> <INDENT> ans = T [ j ] [ 0 ] <NEWLINE> flag1 = False <NEWLINE> <DEDENT> elif flag == True : <NEWLINE> <INDENT> ans = min ( ans , T [ j ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tmp = list ( itertools . combinations ( range ( 1 , n + 1 ) , i ) ) <NEWLINE> for j in range ( len ( tmp ) ) : <NEWLINE> <INDENT> flag = True <NEWLINE> M = [ 0 ] * m <NEWLINE> tmp1 = 0 <NEWLINE> for k in range ( len ( tmp [ j ] ) ) : <NEWLINE> <INDENT> for l in range ( m ) : <NEWLINE> <INDENT> M [ l ] = M [ l ] + T [ tmp [ j ] [ k ] - 1 ] [ l + 1 ] <NEWLINE> <DEDENT> tmp1 = tmp1 + T [ tmp [ j ] [ k ] - 1 ] [ 0 ] <NEWLINE> <NL> <DEDENT> for k in range ( m ) : <NEWLINE> <INDENT> if M [ k ] < x : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == True and flag1 == True : <NEWLINE> <INDENT> ans = tmp1 <NEWLINE> flag1 = False <NEWLINE> <DEDENT> elif flag == True : <NEWLINE> <INDENT> ans = min ( ans , tmp1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> temp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li . append ( temp ) <NEWLINE> <COMMENT> <NL> <DEDENT> li . sort ( ) <NEWLINE> <COMMENT> <NL> total = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> print ( li [ i ] [ 0 ] ) <NEWLINE> break <NEWLINE> <DEDENT> total += li [ i ] [ 1 ] <NEWLINE> if total < k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( li [ i ] [ 0 ] ) <NEWLINE> break <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> all_l = [ i for i in range ( 0 , 101 ) ] <NEWLINE> for p in P : <NEWLINE> <INDENT> all_l . remove ( p ) <NEWLINE> <NL> <DEDENT> kouho = x <NEWLINE> for i in range ( 200 ) : <NEWLINE> <INDENT> kouho1 = x - i <NEWLINE> kouho2 = x + i <NEWLINE> if kouho1 not in P : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> break <NEWLINE> <DEDENT> elif kouho2 not in P : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> <NL> class Graph : <NEWLINE> <INDENT> def __init__ ( self , n , adj_matrix ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . adj_matrix = adj_matrix <NEWLINE> <NL> <DEDENT> def show ( self ) : <NEWLINE> <INDENT> for _ in self . adj_matrix : <NEWLINE> <INDENT> print ( * _ ) <NEWLINE> <NL> <DEDENT> <DEDENT> def dfs ( self ) : <NEWLINE> <INDENT> self . states = [ 2 ] * self . n <NEWLINE> self . d = [ None ] * self . n <NEWLINE> self . f = [ None ] * self . n <NEWLINE> self . time = 0 <NEWLINE> <NL> for u in range ( self . n ) : <NEWLINE> <INDENT> if self . states [ u ] == 2 : <NEWLINE> <INDENT> self . dfs_visit ( u ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def dfs_visit ( self , u ) : <NEWLINE> <INDENT> self . states [ u ] = 1 <NEWLINE> self . time += 1 <NEWLINE> self . d [ u ] = self . time <NEWLINE> <NL> for v , edge in [ ( v , edge ) for v , edge in enumerate ( self . adj_matrix [ u ] ) <NEWLINE> <INDENT> if edge ] : <NEWLINE> if self . states [ v ] == 2 : <NEWLINE> self . dfs_visit ( v ) <NEWLINE> <NL> <DEDENT> self . states [ u ] = 0 <NEWLINE> self . time += 1 <NEWLINE> self . f [ u ] = self . time <NEWLINE> <NL> <DEDENT> def show_dfs ( self , start = 0 ) : <NEWLINE> <INDENT> self . dfs ( ) <NEWLINE> for i , ( d , f ) in enumerate ( zip ( self . d , self . f ) ) : <NEWLINE> <INDENT> print ( i + 1 , d , f ) <NEWLINE> <NL> <DEDENT> <DEDENT> def bfs ( self , start ) : <NEWLINE> <INDENT> self . states = [ 0 ] * self . n <NEWLINE> self . dists = [ float ( <STRING> ) ] * self . n <NEWLINE> <NL> queue = deque ( [ start ] ) <NEWLINE> self . dists [ start ] = 0 <NEWLINE> while queue : <NEWLINE> <INDENT> u = queue . popleft ( ) <NEWLINE> edges = self . adj_matrix [ u ] <NEWLINE> <NL> for v , edge in [ ( v , edge ) for v , edge in enumerate ( edges ) if edge ] : <NEWLINE> <INDENT> if self . states [ v ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if self . dists [ v ] > self . dists [ u ] + 1 : <NEWLINE> <INDENT> self . dists [ v ] = self . dists [ u ] + 1 <NEWLINE> <DEDENT> queue . append ( v ) <NEWLINE> <NL> self . states [ v ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> self . dists = [ <NEWLINE> <INDENT> - 1 if dist == float ( <STRING> ) else dist for dist in self . dists <NEWLINE> <DEDENT> ] <NEWLINE> <NL> <DEDENT> def show_bfs ( self , start = 0 ) : <NEWLINE> <INDENT> self . bfs ( start = start ) <NEWLINE> for i , dist in enumerate ( self . dists ) : <NEWLINE> <INDENT> print ( i + 1 , dist ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> adj_matrix = [ [ 0 ] * n for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for v in input ( ) . split ( ) [ 2 : ] : <NEWLINE> <INDENT> adj_matrix [ i ] [ int ( v ) - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> g = Graph ( n , adj_matrix ) <NEWLINE> g . show_bfs ( ) <NEWLINE> <NL> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> <NL> aaa = collections . Counter ( s ) <NEWLINE> s_r = aaa [ <STRING> ] <NEWLINE> s_g = aaa [ <STRING> ] <NEWLINE> s_b = aaa [ <STRING> ] <NEWLINE> <NL> def noteq ( a , b , c ) : <NEWLINE> <INDENT> if a != b and b != c and c != a : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> ans = s_r * s_g * s_b <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for d in range ( n ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= n : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = s [ i ] <NEWLINE> b = s [ j ] <NEWLINE> c = s [ k ] <NEWLINE> if noteq ( a , b , c ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> R , S , P = map ( int , input ( ) . split ( ) ) <NEWLINE> T = input ( ) <NEWLINE> score = { <STRING> : P , <STRING> : R , <STRING> : S } <NEWLINE> m = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> command = [ ] <NEWLINE> mm = [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> <NL> for i , t in enumerate ( T ) : <NEWLINE> <INDENT> if t == <STRING> : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> point = P <NEWLINE> <DEDENT> elif t == <STRING> : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> point = R <NEWLINE> <DEDENT> elif t == <STRING> : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> point = S <NEWLINE> <NL> <DEDENT> if ( i - K >= 0 ) and ( command [ i - K ] == c ) : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> point = 0 <NEWLINE> <NL> <DEDENT> ans += point <NEWLINE> command . append ( c ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( i , N + 1 ) : <NEWLINE> <INDENT> for k in range ( j , N + 1 ) : <NEWLINE> <INDENT> if i == j and j == k : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> elif i < j and j < k : <NEWLINE> <INDENT> ans += 6 * math . gcd ( i , math . gcd ( j , k ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 3 * math . gcd ( i , math . gcd ( j , k ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> url = <STRING> <NEWLINE> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = 10000000000000000 <NEWLINE> ns = make_divisors ( n ) <NEWLINE> for i in range ( 0 , ( len ( ns ) // 2 ) + 1 ) : <NEWLINE> <INDENT> tmp = max ( len ( str ( ns [ i ] ) ) , len ( str ( ns [ len ( ns ) - i - 1 ] ) ) ) <NEWLINE> ans = tmp if tmp < ans else ans <NEWLINE> <DEDENT> if len ( ns ) % 2 != 0 : <NEWLINE> <INDENT> tmp = len ( str ( ns [ len ( ns ) // 2 ] ) ) <NEWLINE> ans = tmp if tmp < ans else ans <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , M = [ int ( n ) for n in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> if abs ( N - M ) >= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif abs ( N - M ) == 1 : <NEWLINE> <INDENT> print ( ( factorial ( N ) * factorial ( M ) ) % 1000000007 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( factorial ( N ) * factorial ( M ) * 2 ) % 1000000007 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def factorial ( n ) : <NEWLINE> <INDENT> ret = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ret = ( ret * i ) % 1000000007 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> uf = UnionFind ( N + 1 ) <NEWLINE> <NL> for m in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> print ( len ( uf . roots ( ) ) - 1 - 1 ) <NEWLINE>
S = input ( ) [ : : - 1 ] <NEWLINE> n = len ( S ) <NEWLINE> dp = [ 0 ] * 2019 <NEWLINE> dp [ 0 ] = 1 <NEWLINE> X = 0 <NEWLINE> Y = 1 <NEWLINE> for s in S : <NEWLINE> <INDENT> Z = ( int ( s ) * Y ) % 2019 <NEWLINE> X = ( X + Z ) % 2019 <NEWLINE> dp [ X ] += 1 <NEWLINE> Y = ( 10 * Y ) % 2019 <NEWLINE> <DEDENT> answer = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> answer += dp [ i ] * ( dp [ i ] - 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( answer ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> from itertools import chain <NEWLINE> <NL> nv , ne , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> in_edges = defaultdict ( set ) <NEWLINE> out_edges = defaultdict ( set ) <NEWLINE> while ne : <NEWLINE> <INDENT> s , t , w = map ( int , input ( ) . split ( ) ) <NEWLINE> in_edges [ t ] . add ( ( w , s ) ) <NEWLINE> out_edges [ s ] . add ( ( w , t ) ) <NEWLINE> ne -= 1 <NEWLINE> <NL> <NL> <DEDENT> def chu_liu_edmond ( vertices , cycle_cost ) : <NEWLINE> <INDENT> global in_edges , out_edges , nv , r <NEWLINE> <NL> total_cost = cycle_cost <NEWLINE> prev_v = { v : None for v in vertices } <NEWLINE> next_vs = { v : set ( ) for v in vertices } <NEWLINE> <NL> for t in vertices : <NEWLINE> <INDENT> if t == r : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> min_in_w , min_in_s = min ( in_edges [ t ] ) <NEWLINE> total_cost += min_in_w <NEWLINE> prev_v [ t ] = min_in_s <NEWLINE> next_vs [ min_in_s ] . add ( t ) <NEWLINE> <NL> <DEDENT> visited = { r } <NEWLINE> queue = set ( next_vs [ r ] ) <NEWLINE> while queue : <NEWLINE> <INDENT> t = queue . pop ( ) <NEWLINE> visited . add ( t ) <NEWLINE> queue . update ( next_vs [ t ] ) <NEWLINE> <NL> <DEDENT> cycles = [ ] <NEWLINE> for i in vertices : <NEWLINE> <INDENT> if i in visited : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> cycle_vertices = set ( ) <NEWLINE> while i not in visited : <NEWLINE> <INDENT> visited . add ( i ) <NEWLINE> cycle_vertices . add ( i ) <NEWLINE> i = prev_v [ i ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if i not in cycle_vertices : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> cycle_vertices , j = { i } , prev_v [ i ] <NEWLINE> while j != i : <NEWLINE> <INDENT> cycle_vertices . add ( j ) <NEWLINE> j = prev_v [ j ] <NEWLINE> <NL> <DEDENT> cycles . append ( cycle_vertices ) <NEWLINE> <NL> <DEDENT> if not cycles : <NEWLINE> <INDENT> return total_cost <NEWLINE> <NL> <DEDENT> for cycle in cycles : <NEWLINE> <INDENT> vertices . difference_update ( cycle ) <NEWLINE> vertices . add ( nv ) <NEWLINE> <NL> for v in cycle : <NEWLINE> <INDENT> prev_e_cost = min ( in_edges [ v ] ) [ 0 ] <NEWLINE> cycle_cost += prev_e_cost <NEWLINE> for w , t in out_edges [ v ] : <NEWLINE> <INDENT> if t in vertices : <NEWLINE> <INDENT> out_edges [ nv ] . add ( ( w , t ) ) <NEWLINE> in_edges [ t ] . remove ( ( w , v ) ) <NEWLINE> in_edges [ t ] . add ( ( w , nv ) ) <NEWLINE> <DEDENT> <DEDENT> for w , s in in_edges [ v ] : <NEWLINE> <INDENT> if s in vertices : <NEWLINE> <INDENT> new_w = w - prev_e_cost <NEWLINE> in_edges [ nv ] . add ( ( new_w , s ) ) <NEWLINE> out_edges [ s ] . remove ( ( w , v ) ) <NEWLINE> out_edges [ s ] . add ( ( new_w , nv ) ) <NEWLINE> <DEDENT> <DEDENT> del in_edges [ v ] <NEWLINE> del out_edges [ v ] <NEWLINE> <NL> <DEDENT> nv += 1 <NEWLINE> <NL> <DEDENT> return chu_liu_edmond ( vertices , cycle_cost ) <NEWLINE> <NL> <NL> <DEDENT> print ( chu_liu_edmond ( set ( range ( nv ) ) , 0 ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( enumerate ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> a . sort ( key = lambda x : - x [ 1 ] ) <NEWLINE> dp = [ np . zeros ( i + 1 , dtype = np . int64 ) for i in range ( n + 1 ) ] <NEWLINE> dp [ 0 ] = np . zeros ( 1 , dtype = np . int64 ) <NEWLINE> r = np . arange ( n + 1 , dtype = np . int64 ) <NEWLINE> for time , ix in enumerate ( a ) : <NEWLINE> <INDENT> i , x = ix <NEWLINE> dp [ time + 1 ] [ 1 : ] = dp [ time ] [ : time + 1 ] + ( i - r [ : time + 1 ] ) * x <NEWLINE> dp [ time + 1 ] [ : - 1 ] = np . maximum ( dp [ time + 1 ] [ : - 1 ] , dp [ time ] + ( ( n - 1 - ( time - r [ : time + 1 ] ) ) - i ) * x ) <NEWLINE> <DEDENT> print ( np . max ( dp [ n ] ) ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> town = [ 0 for i in range ( N + 1 ) ] <NEWLINE> <NL> def next ( A , now ) : <NEWLINE> <INDENT> return ( A [ now - 1 ] ) <NEWLINE> <NL> <DEDENT> now = 1 <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if town [ now ] != 0 : <NEWLINE> <INDENT> roop_start = town [ now ] <NEWLINE> roop_end = i <NEWLINE> break <NEWLINE> <DEDENT> town [ now ] = i + 1 <NEWLINE> now = next ( A , now ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> roop = roop_end - roop_start + 1 <NEWLINE> teleport = min ( roop_start + ( K - roop_start ) % roop , K ) <NEWLINE> <NL> now = 1 <NEWLINE> for i in range ( teleport ) : <NEWLINE> <INDENT> now = next ( A , now ) <NEWLINE> <NL> <DEDENT> print ( now ) <NEWLINE>
<NL> <NL> array_first = [ ] <NEWLINE> array_second = [ ] <NEWLINE> array_turns = [ ] <NEWLINE> <NL> input_str = input ( ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> turns = int ( input_str ) <NEWLINE> <NL> if turns == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> array_turns . append ( turns ) <NEWLINE> <NL> for turn in range ( turns ) : <NEWLINE> <INDENT> input_str = input ( ) <NEWLINE> <NL> first = <STRING> <NEWLINE> second = <STRING> <NEWLINE> <NL> flag_space = False <NEWLINE> for i in range ( len ( input_str ) ) : <NEWLINE> <INDENT> if input_str [ i ] == <STRING> : <NEWLINE> <INDENT> flag_space = True <NEWLINE> continue <NEWLINE> <DEDENT> if not flag_space : <NEWLINE> <INDENT> first += ( input_str [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> second += ( input_str [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> array_first . append ( int ( first ) ) <NEWLINE> array_second . append ( int ( second ) ) <NEWLINE> <NL> <DEDENT> input_str = input ( ) <NEWLINE> <NL> <DEDENT> scores_first = [ ] <NEWLINE> scores_second = [ ] <NEWLINE> passed_turns = 0 <NEWLINE> <NL> for turns in array_turns : <NEWLINE> <INDENT> score_first = 0 <NEWLINE> score_second = 0 <NEWLINE> <NL> for turn in range ( turns ) : <NEWLINE> <INDENT> if array_first [ turn + passed_turns ] > array_second [ turn + passed_turns ] : <NEWLINE> <INDENT> score_first += array_first [ turn + passed_turns ] + array_second [ turn + passed_turns ] <NEWLINE> <DEDENT> elif array_first [ turn + passed_turns ] < array_second [ turn + passed_turns ] : <NEWLINE> <INDENT> score_second += array_first [ turn + passed_turns ] + array_second [ turn + passed_turns ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score_first += array_first [ turn + passed_turns ] <NEWLINE> score_second += array_second [ turn + passed_turns ] <NEWLINE> <NL> <DEDENT> <DEDENT> scores_first . append ( score_first ) <NEWLINE> scores_second . append ( score_second ) <NEWLINE> passed_turns += turns <NEWLINE> <NL> <DEDENT> for idx , score in enumerate ( zip ( scores_first , scores_second ) ) : <NEWLINE> <INDENT> print ( score [ 0 ] , score [ 1 ] ) <NEWLINE> <NL> <DEDENT>
def solve ( N , A ) : <NEWLINE> <INDENT> a = [ ( i , ai ) for i , ai in enumerate ( A ) ] <NEWLINE> a . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> dp = [ [ 0 ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> <NL> dp [ 0 ] [ 0 ] = 0 <NEWLINE> for i , ai in enumerate ( a ) : <NEWLINE> <INDENT> for l in range ( i + 1 ) : <NEWLINE> <INDENT> r = i - l <NEWLINE> dp [ i + 1 ] [ l ] = max ( dp [ i + 1 ] [ l ] , dp [ i ] [ l ] + ai [ 1 ] * ( ( N - 1 - r ) - ai [ 0 ] ) ) <NEWLINE> dp [ i + 1 ] [ l + 1 ] = max ( dp [ i + 1 ] [ l + 1 ] , dp [ i ] [ l ] + ai [ 1 ] * ( ai [ 0 ] - l ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( dp [ N ] ) ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> solve ( N , A ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> w , h = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> if w == h == 0 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> room = [ [ int ( j ) for j in sys . stdin . readline ( ) . split ( ) ] for i in range ( h ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if room [ i ] [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> dfs ( w , h , room , i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> def dfs ( w , h , room , i , j ) : <NEWLINE> <INDENT> if i < 0 or i >= h or j < 0 or j >= w or ( not room [ i ] [ j ] ) : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> room [ i ] [ j ] = 0 <NEWLINE> <NL> dfs ( w , h , room , i + 1 , j ) <NEWLINE> dfs ( w , h , room , i - 1 , j ) <NEWLINE> dfs ( w , h , room , i , j + 1 ) <NEWLINE> dfs ( w , h , room , i , j - 1 ) <NEWLINE> dfs ( w , h , room , i + 1 , j + 1 ) <NEWLINE> dfs ( w , h , room , i + 1 , j - 1 ) <NEWLINE> dfs ( w , h , room , i - 1 , j + 1 ) <NEWLINE> dfs ( w , h , room , i - 1 , j - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
xn = input ( ) <NEWLINE> x , n = xn . split ( ) <NEWLINE> if n == <STRING> : <NEWLINE> <INDENT> print ( int ( x ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = input ( ) <NEWLINE> p = { int ( i ) for i in p . split ( ) } <NEWLINE> s = { i for i in range ( - 150 , 150 ) } <NEWLINE> s_p = list ( s - p ) <NEWLINE> d = [ abs ( i - int ( x ) ) for i in s_p ] <NEWLINE> print ( s_p [ d . index ( min ( d ) ) ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> s = sum ( a ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> s -= i <NEWLINE> s %= mod <NEWLINE> ans += s * i <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
sent = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ex = input ( ) . lower ( ) <NEWLINE> sent += ex <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) : <NEWLINE> <INDENT> x = sent . count ( chr ( i ) ) <NEWLINE> print ( chr ( i ) , <STRING> , x ) <NEWLINE> <DEDENT>
N , M = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> edges = { i : [ ] for i in range ( 1 , N + 1 ) } <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> edges [ a ] . append ( b ) <NEWLINE> edges [ b ] . append ( a ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def search ( lst ) : <NEWLINE> <COMMENT> <NL> <INDENT> if len ( lst ) == N : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = lst [ - 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> next = [ n for n in edges [ a ] if n not in lst ] <NEWLINE> <COMMENT> <NL> if len ( next ) == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> tot = 0 <NEWLINE> <COMMENT> <NL> for n in next : <NEWLINE> <INDENT> tot += search ( lst + [ n ] ) <NEWLINE> <NL> <DEDENT> return tot <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = search ( [ 1 ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ikisaki = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ikisaki [ a ] . append ( b ) <NEWLINE> ikisaki [ b ] . append ( a ) <NEWLINE> <DEDENT> ans = [ 0 ] + [ 1 ] + [ 0 ] * ( n - 1 ) <NEWLINE> tansakuheya = deque ( [ 1 ] ) <NEWLINE> tmp = deque ( ) <NEWLINE> <NL> for _ in range ( 1000009 ) : <NEWLINE> <NL> <INDENT> for bangou in tansakuheya : <NEWLINE> <NL> <INDENT> for heya in ikisaki [ bangou ] : <NEWLINE> <INDENT> if ans [ heya ] == 0 : <NEWLINE> <INDENT> ans [ heya ] = bangou <NEWLINE> tmp . append ( heya ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> tansakuheya = tmp . copy ( ) <NEWLINE> tmp = deque ( ) <NEWLINE> <NL> <NL> if not tansakuheya : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> ls = len ( s ) <NEWLINE> lt = len ( t ) <NEWLINE> ans = [ <STRING> ] <NEWLINE> <NL> if <STRING> not in set ( s ) : <NEWLINE> <INDENT> print ( <STRING> . join ( s ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( ls - lt + 1 ) : <NEWLINE> <INDENT> f = True <NEWLINE> for j in range ( lt ) : <NEWLINE> <INDENT> f &= ( s [ i + j ] == <STRING> or s [ i + j ] == t [ j ] ) <NEWLINE> <NL> <DEDENT> if f : <NEWLINE> <INDENT> ans = s . copy ( ) <NEWLINE> for j in range ( lt ) : <NEWLINE> <INDENT> ans [ i + j ] = t [ j ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) . replace ( <STRING> , <STRING> ) ) <NEWLINE>
M = 10 ** 9 + 7 <NEWLINE> n , k , * a = map ( int , open ( y : = 0 ) . read ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> x = s = 1 <NEWLINE> r = k <NEWLINE> while r > 1 : <NEWLINE> <INDENT> if ( t : = a [ y ] * a [ y + 1 ] ) > a [ - x ] * a [ ~ x ] : s = s * t % M ; y += 2 ; r -= 2 <NEWLINE> else : s = s * a [ - x ] % M ; x += 1 ; r -= 1 <NEWLINE> <DEDENT> if r : s *= a [ - x ] <NEWLINE> if a [ - 1 ] < 0 < k % 2 : <NEWLINE> <INDENT> s = 1 <NEWLINE> for i in a [ - k : ] : s = s * i % M <NEWLINE> <DEDENT> print ( s % M ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if a . count ( 0 ) > 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> now = 1 <NEWLINE> flg = 0 <NEWLINE> path = [ 1 ] <NEWLINE> pathcheck = { 1 } <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> now = a [ now - 1 ] <NEWLINE> if now in pathcheck : <NEWLINE> <INDENT> flg = - 1 <NEWLINE> path . append ( now ) <NEWLINE> break <NEWLINE> <DEDENT> path . append ( now ) <NEWLINE> pathcheck . add ( now ) <NEWLINE> <NL> <NL> <DEDENT> if flg == 0 : <NEWLINE> <INDENT> print ( now ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> x1 = path . index ( now ) <NEWLINE> x2 = len ( path ) - 1 <NEWLINE> x3 = ( k - x1 ) % ( x2 - x1 ) <NEWLINE> print ( path [ x1 + x3 ] ) <NEWLINE>
max_R = - 10 ** 9 <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> min_R = int ( input ( ) ) <NEWLINE> continue <NEWLINE> <DEDENT> R = int ( input ( ) ) <NEWLINE> if R - min_R > max_R : <NEWLINE> <INDENT> max_R = R - min_R <NEWLINE> <DEDENT> if R < min_R : <NEWLINE> <INDENT> min_R = R <NEWLINE> <DEDENT> <DEDENT> print ( max_R ) <NEWLINE> <NL>
from collections import Counter <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> balls = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> hist = Counter ( balls ) <NEWLINE> diff_counts = set ( hist . values ( ) ) <NEWLINE> combos1 = { ct : 0 if ct == 1 else ( ct - 1 ) * ( ct - 2 ) // 2 for ct in <NEWLINE> <INDENT> diff_counts } <NEWLINE> <DEDENT> combos = { ct : ct * ( ct - 1 ) // 2 for ct in diff_counts } <NEWLINE> <NL> tot = sum ( combos [ hist [ v2 ] ] for v2 in hist . keys ( ) ) <NEWLINE> <NL> for b in range ( n ) : <NEWLINE> <INDENT> v = balls [ b ] <NEWLINE> ct = hist [ v ] <NEWLINE> print ( tot - combos [ ct ] + combos1 [ ct ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> point = [ 0 ] * N <NEWLINE> count_X = 0 <NEWLINE> count_Y = 0 <NEWLINE> i = 0 <NEWLINE> while point [ i ] != 3 : <NEWLINE> <INDENT> if point [ i ] < 2 : <NEWLINE> <INDENT> count_X += 1 <NEWLINE> <DEDENT> point [ i ] += 1 <NEWLINE> i = A [ i ] - 1 <NEWLINE> if point [ i ] > 1 : <NEWLINE> <INDENT> count_Y += 1 <NEWLINE> <DEDENT> <DEDENT> count_Y -= 1 <NEWLINE> <NL> if K >= count_X : <NEWLINE> <INDENT> Z = count_X + ( K - count_X ) % count_Y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Z = K <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> ans = 1 <NEWLINE> while i < Z : <NEWLINE> <INDENT> ans = A [ ans - 1 ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <DEDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> point = [ 0 ] * N <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a = a - 1 <NEWLINE> point [ a ] += b <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def dfs ( now , prev = - 1 ) : <NEWLINE> <INDENT> for next in graph [ now ] : <NEWLINE> <COMMENT> <NL> <INDENT> if next == prev : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> point [ next ] += point [ now ] <NEWLINE> <COMMENT> <NL> dfs ( next , now ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * point ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> c = ( a * b ) <NEWLINE> d = ( a + b ) * 2 <NEWLINE> <NL> print ( c , d ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> count_dict = collections . Counter ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> count = count_dict [ str ( i + 1 ) ] <NEWLINE> print ( count ) <NEWLINE> <DEDENT>
n = [ int ( input ( ) ) for i in range ( 1 ) ] [ 0 ] <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if 0 in li : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> for num in li : <NEWLINE> <INDENT> a = a * num <NEWLINE> if a <= 10 ** 18 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if a > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if a <= 10 ** 18 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> break <NEWLINE> <DEDENT> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( sum ( [ i % 2 == 1 for i in a [ : : 2 ] ] ) ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = abs ( min ( p ) - x ) + 1 <NEWLINE> u = min ( p ) - 1 <NEWLINE> for i in range ( min ( x - 1 , min ( p ) - 1 ) , max ( x + 1 , max ( p ) + 2 ) ) : <NEWLINE> <INDENT> if not ( i in p ) : <NEWLINE> <INDENT> if abs ( i - x ) < t : <NEWLINE> <INDENT> t = abs ( i - x ) <NEWLINE> u = i <NEWLINE> <DEDENT> elif abs ( i - x ) == t : <NEWLINE> <INDENT> if i < u : <NEWLINE> <INDENT> u = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( u ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = int ( input ( ) ) <NEWLINE> h . append ( tmp ) <NEWLINE> <DEDENT> h . sort ( ) <NEWLINE> <NL> ans = h [ N - 1 ] <NEWLINE> for i in range ( 0 , N - K + 1 ) : <NEWLINE> <INDENT> tmp = h [ i + K - 1 ] - h [ i ] <NEWLINE> ans = min ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> xlist = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> ylist = sorted ( xlist ) <NEWLINE> max1 = ylist [ - 1 ] <NEWLINE> max2 = ylist [ - 2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if xlist [ i ] != max1 : <NEWLINE> <INDENT> print ( max1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max2 ) <NEWLINE> <DEDENT> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x = int ( n / ( a + b ) ) <NEWLINE> y = n - ( ( a + b ) * x ) <NEWLINE> if y >= a : <NEWLINE> <INDENT> z = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = y <NEWLINE> <DEDENT> print ( int ( ( a * x ) + z ) ) <NEWLINE>
from collections import deque , defaultdict <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> directs = ( ( - 1 , 0 , 1 , 0 ) , ( 1 , 0 , - 1 , 0 ) , ( 0 , 1 , 0 , 1 ) , ( 0 , - 1 , 0 , - 1 ) ) <NEWLINE> while True : <NEWLINE> <INDENT> w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> mp_l = [ <STRING> * ( w + 2 ) ] <NEWLINE> mp_r = [ <STRING> * ( w + 2 ) ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> l , r = input ( ) . split ( ) <NEWLINE> l = <STRING> + l + <STRING> <NEWLINE> r = <STRING> + r + <STRING> <NEWLINE> mp_l . append ( l ) <NEWLINE> mp_r . append ( r ) <NEWLINE> <DEDENT> mp_l . append ( <STRING> * ( w + 2 ) ) <NEWLINE> mp_r . append ( <STRING> * ( w + 2 ) ) <NEWLINE> <NL> for y in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> for x in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> if mp_l [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> start_l = ( x , y ) <NEWLINE> <DEDENT> if mp_r [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> start_r = ( x , y ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dic = [ [ [ [ None ] * ( h + 2 ) for _ in range ( w + 2 ) ] for _ in range ( h + 2 ) ] for _ in range ( w + 2 ) ] <NEWLINE> def search ( ) : <NEWLINE> <INDENT> que = deque ( ) <NEWLINE> app = que . append <NEWLINE> pop = que . popleft <NEWLINE> app ( ( start_l [ 0 ] , start_l [ 1 ] , start_r [ 0 ] , start_r [ 1 ] ) ) <NEWLINE> dic [ start_l [ 0 ] ] [ start_l [ 1 ] ] [ start_r [ 0 ] ] [ start_r [ 1 ] ] = True <NEWLINE> while que : <NEWLINE> <INDENT> lx , ly , rx , ry = pop ( ) <NEWLINE> for ldx , ldy , rdx , rdy in directs : <NEWLINE> <INDENT> ltx , lty , rtx , rty = lx + ldx , ly + ldy , rx + rdx , ry + rdy <NEWLINE> if mp_l [ lty ] [ ltx ] != <STRING> : <NEWLINE> <INDENT> lnx , lny = ltx , lty <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lnx , lny = lx , ly <NEWLINE> <DEDENT> if mp_r [ rty ] [ rtx ] != <STRING> : <NEWLINE> <INDENT> rnx , rny = rtx , rty <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rnx , rny = rx , ry <NEWLINE> <DEDENT> tmp = dic [ lnx ] [ lny ] [ rnx ] <NEWLINE> if not tmp [ rny ] : <NEWLINE> <INDENT> tmp [ rny ] = True <NEWLINE> lsym , rsym = mp_l [ lny ] [ lnx ] , mp_r [ rny ] [ rnx ] <NEWLINE> if lsym == <STRING> : <NEWLINE> <INDENT> if rsym == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> elif rsym != <STRING> : <NEWLINE> <INDENT> app ( ( ( lnx , lny , rnx , rny ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> search ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) + 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k ) : <NEWLINE> <INDENT> for j in range ( 1 , k ) : <NEWLINE> <INDENT> for l in range ( 1 , k ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> def make_connected_group ( G ) : <NEWLINE> <INDENT> C = [ None ] * len ( G ) <NEWLINE> group = 0 <NEWLINE> for i , p in enumerate ( C ) : <NEWLINE> <INDENT> if p != None : continue <NEWLINE> friends = [ i ] <NEWLINE> while len ( friends ) > 0 : <NEWLINE> <INDENT> f = friends . pop ( ) <NEWLINE> if C [ f ] == None : <NEWLINE> <INDENT> C [ f ] = group <NEWLINE> friends += G [ f ] <NEWLINE> <DEDENT> <DEDENT> group += 1 <NEWLINE> <DEDENT> return C <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> G = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> s , t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> G [ s ] . append ( t ) <NEWLINE> G [ t ] . append ( s ) <NEWLINE> <DEDENT> C = make_connected_group ( G ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for j , line in enumerate ( sys . stdin ) : <NEWLINE> <INDENT> if not j < q : break <NEWLINE> s , t = list ( map ( int , line . split ( ) ) ) <NEWLINE> print ( <STRING> if C [ s ] == C [ t ] else <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> idx = 0 <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ idx ] < A [ i ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> idx += 1 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> res = sum ( a ) <NEWLINE> temp = [ 0 ] * 100001 <NEWLINE> for x in a : <NEWLINE> <INDENT> temp [ x ] += 1 <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> res -= b * temp [ b ] <NEWLINE> temp [ c ] += temp [ b ] <NEWLINE> res += c * temp [ b ] <NEWLINE> temp [ b ] = 0 <NEWLINE> print ( res ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ - 1 ] * ( n + 1 ) <NEWLINE> B = [ ] <NEWLINE> f = 1 <NEWLINE> c = 0 <NEWLINE> ans = n <NEWLINE> bal = 0 <NEWLINE> while dp [ f - 1 ] == - 1 : <NEWLINE> <INDENT> dp [ f - 1 ] = c <NEWLINE> B . append ( f ) <NEWLINE> f = A [ f - 1 ] <NEWLINE> c += 1 <NEWLINE> <DEDENT> t = B . index ( f ) <NEWLINE> if k > t : <NEWLINE> <INDENT> k -= t <NEWLINE> B = B [ B . index ( f ) : ] <NEWLINE> k %= len ( B ) <NEWLINE> print ( B [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B [ k ] ) <NEWLINE> <DEDENT>
<NL> K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if len ( S ) > K : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <NL> <DEDENT>
r = float ( input ( ) ) <NEWLINE> p = 3.141592653589 <NEWLINE> a = r * r * p <NEWLINE> b = 2 * r * p <NEWLINE> print ( <STRING> . format ( a , b ) ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> <NL> asize = len ( a ) <NEWLINE> for i in range ( asize ) : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( b [ i ] ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> result = [ 0 , 0 ] <NEWLINE> powers = [ x ** 5 for x in range ( 1001 ) ] <NEWLINE> <NL> end_flag = False <NEWLINE> for i in range ( 1001 ) : <NEWLINE> <INDENT> a5 = powers [ i ] <NEWLINE> for j in range ( i , 1001 ) : <NEWLINE> <INDENT> b5 = powers [ j ] <NEWLINE> x = a5 - b5 <NEWLINE> if ( x == X ) : <NEWLINE> <INDENT> result [ 0 ] = i <NEWLINE> result [ 1 ] = j <NEWLINE> end_flag = True <NEWLINE> break <NEWLINE> <DEDENT> elif ( - x == X ) : <NEWLINE> <INDENT> result [ 0 ] = - i <NEWLINE> result [ 1 ] = - j <NEWLINE> end_flag = True <NEWLINE> break <NEWLINE> <DEDENT> x = a5 + b5 <NEWLINE> if ( x == X ) : <NEWLINE> <INDENT> result [ 0 ] = i <NEWLINE> result [ 1 ] = - j <NEWLINE> end_flag = True <NEWLINE> break <NEWLINE> <DEDENT> elif ( - x == X ) : <NEWLINE> <INDENT> result [ 0 ] = - i <NEWLINE> result [ 1 ] = j <NEWLINE> end_flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if end_flag : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> A , B = result <NEWLINE> print ( <STRING> ) <NEWLINE>
def u ( a , b ) : <NEWLINE> <INDENT> if ( a < b ) : <NEWLINE> <INDENT> z = b <NEWLINE> b = a <NEWLINE> a = z <NEWLINE> <DEDENT> r = a % b <NEWLINE> while ( r != 0 ) : <NEWLINE> <INDENT> a = b <NEWLINE> b = r <NEWLINE> r = a % b <NEWLINE> <DEDENT> return b <NEWLINE> <NL> <DEDENT> l = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , l + 1 ) : <NEWLINE> <INDENT> for i2 in range ( 1 , l + 1 ) : <NEWLINE> <INDENT> z = u ( i , i2 ) <NEWLINE> for i3 in range ( 1 , l + 1 ) : <NEWLINE> <INDENT> z2 = u ( i3 , z ) <NEWLINE> s += z2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
INF = float ( <STRING> ) <NEWLINE> <NL> <NL> def trace_back ( sink , predecessors ) : <NEWLINE> <INDENT> p = predecessors [ sink ] <NEWLINE> while p is not None : <NEWLINE> <INDENT> v , i = p <NEWLINE> yield edges [ v ] [ i ] <NEWLINE> p = predecessors [ v ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def min_cost_flow ( source , sink , required_flow ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> while required_flow : <NEWLINE> <INDENT> dist = [ INF ] * n <NEWLINE> dist [ source ] = 0 <NEWLINE> predecessors = [ None ] * n <NEWLINE> <NL> while True : <NEWLINE> <INDENT> updated = False <NEWLINE> for v in range ( n ) : <NEWLINE> <INDENT> if dist [ v ] == INF : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for i , ( remain , target , cost , _ ) in enumerate ( edges [ v ] ) : <NEWLINE> <INDENT> new_dist = dist [ v ] + cost <NEWLINE> if remain and dist [ target ] > new_dist : <NEWLINE> <INDENT> dist [ target ] = new_dist <NEWLINE> predecessors [ target ] = ( v , i ) <NEWLINE> updated = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if not updated : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if dist [ sink ] == INF : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> aug = min ( required_flow , min ( e [ 0 ] for e in trace_back ( sink , predecessors ) ) ) <NEWLINE> required_flow -= aug <NEWLINE> res += aug * dist [ sink ] <NEWLINE> for e in trace_back ( sink , predecessors ) : <NEWLINE> <INDENT> remain , target , cost , idx = e <NEWLINE> e [ 0 ] -= aug <NEWLINE> edges [ target ] [ idx ] [ 0 ] += aug <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> n , m , f = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> s , t , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> es , et = edges [ s ] , edges [ t ] <NEWLINE> ls , lt = len ( es ) , len ( et ) <NEWLINE> es . append ( [ c , t , d , lt ] ) <NEWLINE> et . append ( [ 0 , s , - d , ls ] ) <NEWLINE> <NL> <DEDENT> print ( min_cost_flow ( 0 , n - 1 , f ) ) <NEWLINE>
n , k = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> r = [ 0 for i in range ( n ) ] <NEWLINE> l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> wazap = [ ] <NEWLINE> count = 1 <NEWLINE> saver = None <NEWLINE> temp = 0 <NEWLINE> while r [ temp ] == 0 : <NEWLINE> <INDENT> r [ temp ] = count <NEWLINE> wazap . append ( temp ) <NEWLINE> temp = l [ temp ] - 1 <NEWLINE> <DEDENT> start = l [ wazap [ - 1 ] ] <NEWLINE> left = None <NEWLINE> for i in range ( len ( wazap ) ) : <NEWLINE> <INDENT> if wazap [ i ] == start - 1 : <NEWLINE> <INDENT> left = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> loop = len ( wazap ) - left <NEWLINE> if k < left : <NEWLINE> <INDENT> print ( wazap [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( wazap [ ( k - left ) % loop + left ] + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> adj = [ [ 100001 for j in range ( n ) ] for i in range ( n ) ] <NEWLINE> <NL> for u in range ( n ) : <NEWLINE> <INDENT> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for v , c in zip ( x [ 2 : : 2 ] , x [ 3 : : 2 ] ) : <NEWLINE> <INDENT> adj [ u ] [ v ] = c <NEWLINE> <NL> <DEDENT> <DEDENT> isVisited = [ False ] * n <NEWLINE> <NL> distance = [ 9900001 ] * n <NEWLINE> <NL> <NL> def dijkstra ( s ) : <NEWLINE> <INDENT> distance [ s ] = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> mincost = 9900001 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( not isVisited [ i ] ) and ( distance [ i ] < mincost ) : <NEWLINE> <INDENT> mincost = distance [ i ] <NEWLINE> u = i <NEWLINE> <NL> <DEDENT> <DEDENT> if mincost == 9900001 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> isVisited [ u ] = True <NEWLINE> <NL> for v in range ( n ) : <NEWLINE> <INDENT> weight_uv = adj [ u ] [ v ] <NEWLINE> if ( not isVisited [ v ] ) and ( weight_uv != 100001 ) : <NEWLINE> <INDENT> t_d = distance [ u ] + weight_uv <NEWLINE> if t_d < distance [ v ] : <NEWLINE> <INDENT> distance [ v ] = t_d <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dijkstra ( 0 ) <NEWLINE> <NL> for v , d in enumerate ( distance ) : <NEWLINE> <INDENT> print ( v , d ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> U = 10 ** 18 <NEWLINE> ret = 1 <NEWLINE> <NL> for x in A : <NEWLINE> <INDENT> ret *= x <NEWLINE> if ret > U : <NEWLINE> <INDENT> ret = U + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ret > U : <NEWLINE> <INDENT> ret = - 1 <NEWLINE> <NL> <DEDENT> print ( ret ) <NEWLINE>
from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> from collections import deque <NEWLINE> <NL> N , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> next = [ set ( ) for _ in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> next [ A ] . add ( B ) <NEWLINE> next [ B ] . add ( A ) <NEWLINE> <NL> <DEDENT> opened = deque ( ) <NEWLINE> opened . append ( 1 ) <NEWLINE> <NL> prev = [ - 1 ] * ( N + 1 ) <NEWLINE> prev [ 1 ] = 1 <NEWLINE> <NL> while len ( opened ) != 0 : <NEWLINE> <INDENT> target = opened . popleft ( ) <NEWLINE> for n in next [ target ] : <NEWLINE> <INDENT> if prev [ n ] == - 1 : <NEWLINE> <INDENT> opened . append ( n ) <NEWLINE> prev [ n ] = target <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( <STRING> . join ( [ str ( x ) for x in prev [ 2 : ] ] ) ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> tanget_num = range ( 1 , K + 1 ) <NEWLINE> sum_ = sum ( [ math . gcd ( i , math . gcd ( j , k ) ) for i in tanget_num for j in tanget_num for k in tanget_num ] ) <NEWLINE> <NL> print ( str ( sum_ ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> C = [ ] <NEWLINE> for c in list ( input ( ) ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> C . append ( a ) <NEWLINE> <DEDENT> L = - 1 <NEWLINE> R = N <NEWLINE> cnt = 0 <NEWLINE> while L < R : <NEWLINE> <COMMENT> <NL> <INDENT> L += 1 <NEWLINE> if L >= R : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if C [ L ] != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> while L < R : <NEWLINE> <INDENT> R -= 1 <NEWLINE> if L >= R : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if C [ R ] != 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> result *= i <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 0 <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> j = m <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> if a [ i ] + b [ j ] <= k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> j -= 1 <NEWLINE> <DEDENT> res = max ( res , i + j ) <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ( a , i ) for i , a in enumerate ( map ( int , input ( ) . split ( ) ) , start = 1 ) ] <NEWLINE> A . sort ( reverse = True ) <NEWLINE> <NL> dp = [ [ 0 ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> <NL> for s , ( a , i ) in enumerate ( A ) : <NEWLINE> <INDENT> for l in range ( s + 1 ) : <NEWLINE> <INDENT> r = s - l <NEWLINE> L = dp [ l ] [ r ] + a * ( i - ( l + 1 ) ) <NEWLINE> R = dp [ l ] [ r ] + a * ( N - r - i ) <NEWLINE> <NL> if dp [ l + 1 ] [ r ] < L : <NEWLINE> <INDENT> dp [ l + 1 ] [ r ] = L <NEWLINE> <DEDENT> if dp [ l ] [ r + 1 ] < R : <NEWLINE> <INDENT> dp [ l ] [ r + 1 ] = R <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , dp [ i ] [ N - i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> import random <NEWLINE> <NL> def gcd ( x , y ) : <NEWLINE> <INDENT> if y == 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> return gcd ( y , x % y ) <NEWLINE> <NL> <DEDENT> input = sys . stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def sieve_of_erastosthenes ( num ) : <NEWLINE> <INDENT> input_list = [ False if i % 2 == 0 or i % 3 == 0 or i % 5 == 0 else True for i in range ( num ) ] <NEWLINE> input_list [ 0 ] = input_list [ 1 ] = False <NEWLINE> input_list [ 2 ] = input_list [ 3 ] = input_list [ 5 ] = True <NEWLINE> sqrt = math . sqrt ( num ) <NEWLINE> <NL> for serial in range ( 3 , num , 2 ) : <NEWLINE> <NL> <INDENT> if serial >= sqrt : <NEWLINE> <INDENT> return input_list <NEWLINE> <NL> <DEDENT> for s in range ( serial ** 2 , num , serial ) : <NEWLINE> <INDENT> input_list [ s ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> input_list = sieve_of_erastosthenes ( 10 ** 6 + 1 ) <NEWLINE> prime_list = [ i for i , b in enumerate ( input_list ) if b == True ] <NEWLINE> <NL> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in prime_list : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( temp ) <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( n ) <NEWLINE> <DEDENT> return arr <NEWLINE> <DEDENT> random . shuffle ( a ) <NEWLINE> g = a [ 0 ] <NEWLINE> arr = factorization ( a [ 0 ] ) <NEWLINE> used = set ( ) <NEWLINE> for i in arr : <NEWLINE> <INDENT> if i == 1 : continue <NEWLINE> used . add ( i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> g = gcd ( g , a [ i + 1 ] ) <NEWLINE> <DEDENT> if g > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> used = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> pair = True <NEWLINE> for _a in a : <NEWLINE> <INDENT> if _a == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if used [ _a ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> used [ _a ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> for p in prime_list : <NEWLINE> <INDENT> v = p <NEWLINE> cnt = 0 <NEWLINE> while v < 10 ** 6 + 1 : <NEWLINE> <INDENT> if used [ v ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> v += p <NEWLINE> <DEDENT> if cnt > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> OKlist = [ 0 ] * ( 10 ** 6 + 100 ) <NEWLINE> A . sort ( ) <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> if A [ i ] == A [ i + 1 ] and OKlist [ A [ i ] ] == 0 : <NEWLINE> <INDENT> OKlist [ A [ i ] ] += 2 <NEWLINE> for j in range ( 1 , 10 ** 6 + 10 ) : <NEWLINE> <INDENT> if A [ i ] * j > 10 ** 6 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> OKlist [ A [ i ] * j ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif OKlist [ A [ i ] ] == 0 : <NEWLINE> <INDENT> for j in range ( 1 , 10 ** 6 + 10 ) : <NEWLINE> <INDENT> if A [ i ] * j > 10 ** 6 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> OKlist [ A [ i ] * j ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> OKlist [ A [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> OKlist [ max ( A ) ] += 1 <NEWLINE> cnt = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if OKlist [ i ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list = [ ] <NEWLINE> b_list = [ ] <NEWLINE> h_list = [ 0 for _ in range ( h ) ] <NEWLINE> w_list = [ 0 for _ in range ( w ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list . append ( [ a , b ] ) <NEWLINE> h_list [ a - 1 ] += 1 <NEWLINE> w_list [ b - 1 ] += 1 <NEWLINE> <DEDENT> h_max = max ( h_list ) <NEWLINE> w_max = max ( w_list ) <NEWLINE> w_flag = [ 0 for _ in range ( w ) ] <NEWLINE> for i in range ( w ) : <NEWLINE> <INDENT> if w_list [ i ] == w_max : <NEWLINE> <INDENT> w_flag [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> h_flag = [ 0 for _ in range ( h ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if h_list [ i ] == h_max : <NEWLINE> <INDENT> h_flag [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> flag = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if h_flag [ a_list [ i ] [ 0 ] - 1 ] == 1 and w_flag [ a_list [ i ] [ 1 ] - 1 ] == 1 : <NEWLINE> <INDENT> flag += 1 <NEWLINE> <DEDENT> <DEDENT> s = sum ( h_flag ) * sum ( w_flag ) <NEWLINE> print ( h_max + w_max - 1 if flag == s else h_max + w_max ) <NEWLINE>
import numpy as np <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> import itertools <NEWLINE> from collections import Counter <NEWLINE> <NL> suf_xor_dict = { } <NEWLINE> pre_xor_dict = { } <NEWLINE> <NL> <NL> def suf_xor ( N , p ) : <NEWLINE> <COMMENT> <NL> <INDENT> global xor_dict <NEWLINE> if N - len ( p ) + 1 in suf_xor_dict : <NEWLINE> <INDENT> return suf_xor_dict [ N - len ( p ) + 1 ] <NEWLINE> <NL> <DEDENT> if len ( p ) == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if len ( p ) == 1 : <NEWLINE> <INDENT> suf_xor_dict [ N ] = p [ 0 ] <NEWLINE> return p [ 0 ] <NEWLINE> <DEDENT> if len ( p ) == 2 : <NEWLINE> <INDENT> suf_xor_dict [ N ] = p [ 1 ] <NEWLINE> suf_xor_dict [ N - 1 ] = p [ 0 ] ^ p [ 1 ] <NEWLINE> return ( p [ 0 ] ^ p [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = p [ 0 ] ^ suf_xor ( N , p [ 1 : ] ) <NEWLINE> suf_xor_dict [ N - len ( p ) + 1 ] = ret <NEWLINE> return ret <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def pre_xor ( N , p ) : <NEWLINE> <INDENT> global pre_xor_dict <NEWLINE> if len ( p ) in pre_xor_dict : <NEWLINE> <INDENT> return pre_xor_dict [ len ( p ) ] <NEWLINE> <NL> <DEDENT> if len ( p ) == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if len ( p ) == 1 : <NEWLINE> <INDENT> pre_xor_dict [ 1 ] = p [ 0 ] <NEWLINE> return p [ 0 ] <NEWLINE> <DEDENT> if len ( p ) == 2 : <NEWLINE> <INDENT> pre_xor_dict [ 1 ] = p [ 0 ] <NEWLINE> pre_xor_dict [ 2 ] = p [ 0 ] ^ p [ 1 ] <NEWLINE> return ( p [ 0 ] ^ p [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = p [ - 1 ] ^ pre_xor ( N , p [ : - 1 ] ) <NEWLINE> pre_xor_dict [ len ( p ) ] = ret <NEWLINE> return ret <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> pre_xor_list = [ 0 ] <NEWLINE> suf_xor_list = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> pre_xor_list . append ( pre_xor_list [ i ] ^ a [ i ] ) <NEWLINE> suf_xor_list . append ( suf_xor_list [ i ] ^ a [ N - i - 1 ] ) <NEWLINE> <NL> <DEDENT> pre_xor_list = pre_xor_list [ 1 : ] <NEWLINE> suf_xor_list = suf_xor_list [ 1 : ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans . append ( ( 0 if i - 1 < 0 else pre_xor_list [ i - 1 ] ) ^ ( 0 if i >= N - 1 else suf_xor_list [ N - i - 2 ] ) ) <NEWLINE> <NL> <DEDENT> for item in ans : <NEWLINE> <INDENT> print ( item , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
inputs = list ( map ( lambda x : int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> <NL> max = 0 <NEWLINE> v = 1 <NEWLINE> <NL> for i in inputs [ 0 : 3 ] : <NEWLINE> <INDENT> if i > inputs [ 3 ] : <NEWLINE> <INDENT> i = inputs [ 3 ] <NEWLINE> <DEDENT> max += v * i <NEWLINE> inputs [ 3 ] -= i <NEWLINE> v -= 1 <NEWLINE> if inputs [ 3 ] <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
from sys import exit <NEWLINE> import math <NEWLINE> ii = lambda : int ( input ( ) ) <NEWLINE> mi = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> li = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = ii ( ) <NEWLINE> a = li ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> a . sort ( ) <NEWLINE> a . reverse ( ) <NEWLINE> <NL> if a [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif a [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> times = [ 0 ] * ( n + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> times [ i ] += 1 <NEWLINE> <DEDENT> times . sort ( ) <NEWLINE> <NL> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if times [ i ] != 0 : <NEWLINE> <INDENT> j = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> if len ( times ) > k - j : <NEWLINE> <INDENT> for i in range ( j , len ( times ) - k ) : <NEWLINE> <INDENT> ans += times [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = [ ] <NEWLINE> L . append ( 1 ) <NEWLINE> f = 1 <NEWLINE> memo = [ - 1 ] * N <NEWLINE> memo [ 0 ] = 0 <NEWLINE> cnt = 1 <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> L . append ( A [ f - 1 ] ) <NEWLINE> f = A [ f - 1 ] <NEWLINE> if memo [ f - 1 ] != - 1 : <NEWLINE> <INDENT> loop = cnt - memo [ f - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> memo [ f - 1 ] = cnt <NEWLINE> cnt += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> NL = L [ - ( loop + 1 ) : - 1 ] <NEWLINE> <COMMENT> <NL> <NL> if K <= ( len ( L ) - 1 ) - loop : <NEWLINE> <INDENT> print ( L [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= ( len ( L ) - 1 ) - loop <NEWLINE> a = K % len ( NL ) <NEWLINE> print ( NL [ a ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Y = sorted ( X ) <NEWLINE> <NL> m1 = Y [ N // 2 - 1 ] <NEWLINE> m2 = Y [ N // 2 ] <NEWLINE> <NL> medians = [ m2 if x < m2 else m1 for x in X ] <NEWLINE> print ( <STRING> . join ( map ( str , medians ) ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import fileinput <NEWLINE> <NL> for line in fileinput . input ( ) : <NEWLINE> <INDENT> ( hight , width ) = map ( int , line . split ( <STRING> ) ) <NEWLINE> <NL> if hight == 0 and width == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for a in range ( hight ) : <NEWLINE> <INDENT> for b in range ( width ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num = int ( input ( ) ) <NEWLINE> <NL> k = input ( ) . split ( ) <NEWLINE> <NL> for i in range ( len ( k ) ) : <NEWLINE> <INDENT> k [ i ] = int ( k [ i ] ) <NEWLINE> <NL> <DEDENT> k . sort ( ) <NEWLINE> <NL> mul = 1 <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <INDENT> mul *= int ( k [ i ] ) <NEWLINE> if mul > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if mul > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( mul ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> colors = input ( ) <NEWLINE> data = [ int ( c == <STRING> ) for c in colors ] <NEWLINE> <NL> lm = 0 <NEWLINE> rm = sum ( data ) <NEWLINE> min_move = rm <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if data [ i ] : <NEWLINE> <INDENT> rm -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lm += 1 <NEWLINE> <DEDENT> move = min ( lm , rm ) + abs ( lm - rm ) <NEWLINE> min_move = min ( min_move , move ) <NEWLINE> <NL> <DEDENT> print ( min_move ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from itertools import accumulate <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( accumulate ( A ) ) <NEWLINE> B = list ( accumulate ( B ) ) <NEWLINE> ans = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> while ( j >= 0 ) : <NEWLINE> <INDENT> if A [ i ] + B [ j ] <= K : <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> break <NEWLINE> <DEDENT> j -= 1 <NEWLINE> <DEDENT> <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> stones = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> inf = 10 ** 9 <NEWLINE> dp = [ inf ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for t in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> step = i + t <NEWLINE> if step < n : <NEWLINE> <INDENT> v = dp [ i ] + abs ( stones [ i ] - stones [ step ] ) <NEWLINE> if v < dp [ step ] : <NEWLINE> <INDENT> dp [ step ] = v <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> <NL> def get_result ( data ) : <NEWLINE> <INDENT> N = data [ 0 ] [ 0 ] <NEWLINE> A = data [ 1 : ] <NEWLINE> tmp = set ( ) <NEWLINE> for i in range ( int ( N ) ) : <NEWLINE> <INDENT> tmp . add ( A [ i ] [ 0 ] ) <NEWLINE> <DEDENT> return len ( tmp ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> raw_data = [ val . rstrip ( ) for val in stdin . readlines ( ) ] <NEWLINE> data = [ list ( map ( str , val . split ( <STRING> ) ) ) for val in raw_data ] <NEWLINE> result = get_result ( data ) <NEWLINE> print ( result ) <NEWLINE> <DEDENT>
n , m , q = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> k = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> k . append ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <NL> <DEDENT> max_score = 0 <NEWLINE> import itertools <NEWLINE> for a in itertools . combinations_with_replacement ( range ( 1 , m + 1 ) , n ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if a [ k [ i ] [ 1 ] - 1 ] - a [ k [ i ] [ 0 ] - 1 ] == k [ i ] [ 2 ] : <NEWLINE> <INDENT> score += k [ i ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if score > max_score : <NEWLINE> <INDENT> max_score = score <NEWLINE> <DEDENT> <DEDENT> print ( max_score ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> from collections import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> for k in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> d [ k ] += 1 <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> d [ c ] += b <NEWLINE> <DEDENT> sm = 0 <NEWLINE> c = 0 <NEWLINE> <NL> for k , v in sorted ( d . items ( ) , reverse = True ) : <NEWLINE> <INDENT> if c + v < n : <NEWLINE> <INDENT> sm += k * v <NEWLINE> c += v <NEWLINE> <DEDENT> elif c + v == n : <NEWLINE> <INDENT> sm += k * v <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sm += k * ( n - c ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( sm ) <NEWLINE> <NL>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> v = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c1 = Counter ( v [ : : 2 ] ) <NEWLINE> c2 = Counter ( v [ 1 : : 2 ] ) <NEWLINE> if len ( set ( v ) ) == 1 : <NEWLINE> <INDENT> print ( n // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c1m = c1 . most_common ( 2 ) <NEWLINE> c2m = c2 . most_common ( 2 ) <NEWLINE> if c1m [ 0 ] [ 0 ] == c2m [ 0 ] [ 0 ] : <NEWLINE> <INDENT> print ( min ( n - c1m [ 0 ] [ 1 ] - c2m [ 1 ] [ 1 ] , n - c1m [ 1 ] [ 1 ] - c2m [ 0 ] [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - c1m [ 0 ] [ 1 ] - c2m [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> expo = 0 <NEWLINE> while n % i == 0 : <NEWLINE> <INDENT> n //= i <NEWLINE> expo += 1 <NEWLINE> <DEDENT> j = 1 <NEWLINE> while expo - j >= 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> expo -= j <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if n > 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL>
import bisect <NEWLINE> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> pN = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> pN . sort ( ) <NEWLINE> <NL> diff = 0 <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while ( 1 ) : <NEWLINE> <INDENT> if x - diff not in pN : <NEWLINE> <INDENT> print ( x - diff ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif x + diff not in pN : <NEWLINE> <INDENT> print ( x + diff ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> diff += 1 <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> m = n // k <NEWLINE> a = n - ( k * m ) <NEWLINE> <NL> print ( min ( a , abs ( a - k ) ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> li_A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = li_A [ 0 ] <NEWLINE> <NL> if 0 in li_A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if ans * li_A [ i ] > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= li_A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
from collections import Counter <NEWLINE> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num_list = list ( range ( - 200 , 201 ) ) <NEWLINE> y = ( num_list + p ) <NEWLINE> <NL> counter = Counter ( y ) <NEWLINE> result = [ elem for elem in y if counter [ elem ] < 2 ] <NEWLINE> <NL> <NL> ans = 10 * 100000000000 <NEWLINE> <NL> for i in result : <NEWLINE> <INDENT> temp = abs ( i - x ) <NEWLINE> if ans > temp : <NEWLINE> <INDENT> ans = temp <NEWLINE> res = i <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
q = int ( input ( ) ) <NEWLINE> n = 10 ** 5 <NEWLINE> <NL> work = [ 1 if i % 2 == 1 else 0 for i in range ( n + 1 ) ] <NEWLINE> primes = [ 2 ] <NEWLINE> lst = [ 0 ] * ( n + 1 ) <NEWLINE> work [ 1 ] == 0 <NEWLINE> <NL> for i in range ( 3 , n , 2 ) : <NEWLINE> <INDENT> if not work [ i ] : continue <NEWLINE> primes . append ( i ) <NEWLINE> index = 1 <NEWLINE> while i * index <= n : <NEWLINE> <INDENT> work [ i * index ] = 0 <NEWLINE> index += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in primes [ 1 : ] : <NEWLINE> <INDENT> if ( i + 1 ) // 2 in primes : <NEWLINE> <INDENT> lst [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> lst [ i ] += lst [ i - 1 ] <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> left , right = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( lst [ right ] - lst [ left - 1 ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for _ in range ( m ) ] ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> ans [ 0 ] = 1 <NEWLINE> if 1 not in a : ans [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i in a : continue <NEWLINE> ans [ i ] = ans [ i - 1 ] + ans [ i - 2 ] <NEWLINE> <DEDENT> print ( ans [ - 1 ] % mod ) <NEWLINE>
A = input ( ) <NEWLINE> A = A [ : : - 1 ] <NEWLINE> divide = [ i [ : : - 1 ] for i in [ <STRING> , <STRING> , <STRING> , <STRING> ] ] <NEWLINE> <NL> flag = 1 <NEWLINE> while flag and A : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for word in divide : <NEWLINE> <INDENT> if A . startswith ( word ) : <NEWLINE> <INDENT> A = A [ len ( word ) : ] <NEWLINE> flag = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if len ( A ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> arr = [ ] <NEWLINE> arr = sorted ( A , reverse = True ) <NEWLINE> <NL> Friend_min_max_wa = 0 <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if i % 2 != 0 : j = j + 1 <NEWLINE> Friend_min_max_wa = Friend_min_max_wa + arr [ j ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( Friend_min_max_wa ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> YES = <STRING> <NEWLINE> NO = <STRING> <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> scores = [ 0 ] * K <NEWLINE> scores [ 0 ] = A [ 0 ] <NEWLINE> i = 1 <NEWLINE> while i < K : <NEWLINE> <INDENT> scores [ i ] = A [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> while i < N : <NEWLINE> <INDENT> if A [ i ] > scores [ i % K ] : <NEWLINE> <INDENT> print ( YES ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( NO ) <NEWLINE> <DEDENT> scores [ i % K ] = A [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> import numpy as np <NEWLINE> import itertools <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> ll = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ll . sort ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a *= ll [ i ] <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> p = set ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> if s [ i ] in p : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . add ( s [ i ] ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> nn = n <NEWLINE> i = 1 <NEWLINE> while nn > 26 ** i : <NEWLINE> <INDENT> nn -= 26 ** i <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> an = [ <STRING> ] * i <NEWLINE> j = 0 <NEWLINE> while n : <NEWLINE> <INDENT> n -= 1 <NEWLINE> wk = n % 26 <NEWLINE> an [ j ] = ( chr ( ord ( <STRING> ) + wk ) ) <NEWLINE> n = n // 26 <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> an . reverse ( ) <NEWLINE> print ( <STRING> . join ( an ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> p = 1 <NEWLINE> ov = False <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if not ov : <NEWLINE> <INDENT> np = p * A [ i ] <NEWLINE> <DEDENT> if np > 10 ** 18 : <NEWLINE> <INDENT> ov = True <NEWLINE> <DEDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> p = np <NEWLINE> <DEDENT> if ov : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( np ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> while b != 0 : <NEWLINE> <INDENT> r = a % b <NEWLINE> a = b <NEWLINE> b = r <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> count = 0 <NEWLINE> temp = list ( ) <NEWLINE> for n in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for m in range ( 1 , n ) : <NEWLINE> <INDENT> temp . append ( gcd ( n , m ) ) <NEWLINE> <DEDENT> <DEDENT> for l in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( len ( temp ) ) : <NEWLINE> <INDENT> p = gcd ( l , temp [ j ] ) <NEWLINE> count += 2 * p <NEWLINE> <DEDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> q = gcd ( l , k ) <NEWLINE> count += q <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> add = [ ] <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> skill = [ 0 ] * ( m + 1 ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> skill = list ( map ( sum , zip ( skill , l [ j ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> if min ( skill [ 1 : ] ) >= x : <NEWLINE> <INDENT> add . append ( skill ) <NEWLINE> <DEDENT> <DEDENT> if add : <NEWLINE> <INDENT> add . sort ( ) <NEWLINE> print ( add [ 0 ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = np . array ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> I = np . array ( [ 1 ] * N ) <NEWLINE> <NL> L = np . max ( A ) <NEWLINE> <NL> ans = L <NEWLINE> low = 1 <NEWLINE> high = L <NEWLINE> while 1 : <NEWLINE> <INDENT> if low == high : <NEWLINE> <INDENT> ans = low <NEWLINE> break <NEWLINE> <NL> <DEDENT> mid = ( low + high ) // 2 <NEWLINE> if np . sum ( ( A - I ) // mid ) <= K : <NEWLINE> <INDENT> high = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) . split ( ) [ 0 ] ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> sum_a = sum ( a_list ) <NEWLINE> total = 0 <NEWLINE> for i , a in enumerate ( a_list ) : <NEWLINE> <INDENT> total += ( a * ( sum_a - a ) ) % mod <NEWLINE> sum_a -= a <NEWLINE> <DEDENT> total = total % mod <NEWLINE> ans = total <NEWLINE> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> class SieveOfEratosthenes : <NEWLINE> <INDENT> def __init__ ( self , V ) : <NEWLINE> <INDENT> self . is_prime = np . ones ( V + 1 , dtype = bool ) <NEWLINE> self . is_prime [ 2 : : 2 ] = False <NEWLINE> self . is_prime [ 3 : : 3 ] = False <NEWLINE> self . is_prime [ 5 : : 5 ] = False <NEWLINE> self . primes = [ 2 , 3 , 5 ] <NEWLINE> for i in range ( 7 , V + 1 , 2 ) : <NEWLINE> <INDENT> if self . is_prime [ i ] : <NEWLINE> <INDENT> self . primes . append ( i ) <NEWLINE> if i * i < V + 1 : <NEWLINE> <INDENT> self . is_prime [ i * i : : i ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def factorize ( self , x , return_dict = False ) : <NEWLINE> <INDENT> if x == 1 : <NEWLINE> <INDENT> return { 1 : 1 } if return_dict else [ ( 1 , 1 ) ] <NEWLINE> <DEDENT> result = [ ] <NEWLINE> for p in self . primes : <NEWLINE> <INDENT> exp = 0 <NEWLINE> while x % p == 0 : <NEWLINE> <INDENT> exp += 1 <NEWLINE> x = x // p <NEWLINE> <DEDENT> if exp > 0 : <NEWLINE> <INDENT> result . append ( ( p , exp ) ) <NEWLINE> <DEDENT> if p * p > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if x > 1 : <NEWLINE> <INDENT> result . append ( ( x , 1 ) ) <NEWLINE> <DEDENT> if return_dict : <NEWLINE> <INDENT> result = { p : e for p , e in result } <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> M = 10 ** 9 + 7 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sieve = SieveOfEratosthenes ( 10 ** 3 ) <NEWLINE> F = [ sieve . factorize ( a , return_dict = True ) for a in A ] <NEWLINE> <NL> lcm = F [ 0 ] <NEWLINE> for i in range ( 1 , len ( F ) ) : <NEWLINE> <INDENT> for p , e in F [ i ] . items ( ) : <NEWLINE> <INDENT> if p in lcm : <NEWLINE> <INDENT> lcm [ p ] = max ( lcm [ p ] , e ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lcm [ p ] = e <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> val = 1 <NEWLINE> for p , e in lcm . items ( ) : <NEWLINE> <INDENT> val = val * pow ( p , e , M ) % M <NEWLINE> <NL> <DEDENT> B = [ val * pow ( a , M - 2 , M ) % M for a in A ] <NEWLINE> print ( sum ( B ) % M ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> dic = collections . Counter ( a ) <NEWLINE> <NL> ans = sum ( a ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> B = dic [ b ] <NEWLINE> ans = ans + ( c - b ) * B <NEWLINE> print ( ans ) <NEWLINE> dic [ b ] = 0 <NEWLINE> dic [ c ] = dic [ c ] + B <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if N < abs ( N - K ) : <NEWLINE> <INDENT> ans = N <NEWLINE> <DEDENT> elif N % K == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = abs ( N % K - K ) <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> pw = list ( <STRING> . format ( i ) ) <NEWLINE> <NL> if pw [ 0 ] in S : <NEWLINE> <INDENT> w1 = S . index ( pw [ 0 ] ) <NEWLINE> if pw [ 1 ] in S [ w1 + 1 : ] : <NEWLINE> <INDENT> w2 = w1 + 1 + S [ w1 + 1 : ] . index ( pw [ 1 ] ) <NEWLINE> if pw [ 2 ] in S [ w2 + 1 : ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) . strip ( ) ) <NEWLINE> <NL> x , y , z = 1 , 1 , 1 <NEWLINE> <NL> f = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> <COMMENT> <NL> def calc ( x , y , z , f , axis = <STRING> ) : <NEWLINE> <COMMENT> <NL> <INDENT> n = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + x * z <NEWLINE> <NL> if n <= N : <NEWLINE> <INDENT> f [ n ] += 1 <NEWLINE> if axis == <STRING> : <NEWLINE> <INDENT> f = calc ( x + 1 , y , z , f , axis = <STRING> ) <NEWLINE> f = calc ( x , y + 1 , z , f , axis = <STRING> ) <NEWLINE> f = calc ( x , y , z + 1 , f , axis = <STRING> ) <NEWLINE> <DEDENT> elif axis == <STRING> : <NEWLINE> <INDENT> f = calc ( x , y + 1 , z , f , axis = <STRING> ) <NEWLINE> f = calc ( x , y , z + 1 , f , axis = <STRING> ) <NEWLINE> <DEDENT> elif axis == <STRING> : <NEWLINE> <INDENT> f = calc ( x , y , z + 1 , f , axis = <STRING> ) <NEWLINE> <DEDENT> return f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return f <NEWLINE> <NL> <DEDENT> <DEDENT> f = calc ( x , y , z , f ) <NEWLINE> <NL> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( f [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> limit = 10 ** 18 <NEWLINE> length = 0 <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A0 = set ( A ) <NEWLINE> if 0 in A0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ n ] <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ans > limit : <NEWLINE> <INDENT> length = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> if length == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> F = S [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> F = math . gcd ( F , S [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> print ( F ) <NEWLINE>
def multiplication ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> if 0 in A : <NEWLINE> <INDENT> return 0 <NEWLINE> <COMMENT> <NL> <DEDENT> multi = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> multi = multi * A [ i ] <NEWLINE> <COMMENT> <NL> if multi > 10 ** 18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return multi <NEWLINE> <NL> <DEDENT> result = multiplication ( ) <NEWLINE> print ( result ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = - 1 <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> for i in range ( x // 2 + 1 ) : <NEWLINE> <INDENT> if i + 2 * ( x - 2 * i ) == y : <NEWLINE> <INDENT> a = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if a == - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gyaku = [ 0 , 1 ] <NEWLINE> for i in range ( 2 , a + 1 ) : <NEWLINE> <INDENT> gyaku . append ( ( ( p // i ) * - gyaku [ p % i ] ) % p ) <NEWLINE> <DEDENT> com = [ 1 ] <NEWLINE> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> com . append ( com [ - 1 ] * gyaku [ i ] * ( x - a + 1 - i ) % p ) <NEWLINE> <DEDENT> <DEDENT> print ( com [ - 1 ] ) <NEWLINE>
N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> ABC = [ A , B , C ] <NEWLINE> <NL> s = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s [ i ] = str ( input ( ) ) <NEWLINE> <NL> <DEDENT> d = { <STRING> : ( 0 , 1 , 2 ) , <STRING> : ( 2 , 1 , 0 ) , <STRING> : ( 0 , 2 , 1 ) } <NEWLINE> dl = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> if ABC == [ 0 , 0 , 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * N <NEWLINE> if A + B + C == 1 : <NEWLINE> <INDENT> for n in range ( N ) : <NEWLINE> <INDENT> i , j , k = d [ s [ n ] ] <NEWLINE> <COMMENT> <NL> if ABC [ i ] == 1 : <NEWLINE> <INDENT> ABC [ i ] = 0 <NEWLINE> ABC [ j ] = 1 <NEWLINE> ans [ n ] = dl [ j ] <NEWLINE> <DEDENT> elif ABC [ j ] == 1 : <NEWLINE> <INDENT> ABC [ i ] = 1 <NEWLINE> ABC [ j ] = 0 <NEWLINE> ans [ n ] = dl [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for n in range ( N ) : <NEWLINE> <INDENT> i , j , k = d [ s [ n ] ] <NEWLINE> <COMMENT> <NL> if ABC [ i ] == 0 : <NEWLINE> <INDENT> if ABC [ j ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ABC [ i ] += 1 <NEWLINE> ABC [ j ] -= 1 <NEWLINE> ans [ n ] = dl [ i ] <NEWLINE> <DEDENT> <DEDENT> elif ABC [ j ] == 0 : <NEWLINE> <INDENT> ABC [ i ] -= 1 <NEWLINE> ABC [ j ] += 1 <NEWLINE> ans [ n ] = dl [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n < N - 1 : <NEWLINE> <INDENT> if ( ABC [ i ] == 1 ) or ( ABC [ j ] == 1 ) : <NEWLINE> <INDENT> if s [ n ] != s [ n + 1 ] : <NEWLINE> <INDENT> n1 , n2 , n3 = d [ s [ n + 1 ] ] <NEWLINE> if ( i == n1 ) or ( i == n2 ) : <NEWLINE> <INDENT> ABC [ i ] += 1 <NEWLINE> ABC [ j ] -= 1 <NEWLINE> ans [ n ] = dl [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ABC [ i ] -= 1 <NEWLINE> ABC [ j ] += 1 <NEWLINE> ans [ n ] = dl [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ABC [ i ] -= 1 <NEWLINE> ABC [ j ] += 1 <NEWLINE> ans [ n ] = dl [ j ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ABC [ i ] -= 1 <NEWLINE> ABC [ j ] += 1 <NEWLINE> ans [ n ] = dl [ j ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ABC [ i ] -= 1 <NEWLINE> ABC [ j ] += 1 <NEWLINE> ans [ n ] = dl [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> c = Counter ( a ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( 1 , 1 + n ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> s = [ 0 ] * ( n + 1 ) <NEWLINE> L = 0 <NEWLINE> R = 10 ** 5 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> L = max ( l , L ) <NEWLINE> R = min ( r , R ) <NEWLINE> <NL> <DEDENT> if ( R - L + 1 ) >= 0 : <NEWLINE> <INDENT> print ( R - L + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> @ njit <NEWLINE> def op ( A , n ) : <NEWLINE> <INDENT> B = np . zeros_like ( A ) <NEWLINE> for i , a in enumerate ( A [ : n ] ) : <NEWLINE> <INDENT> B [ max ( i - a , 0 ) ] += 1 <NEWLINE> B [ min ( n - 1 , a + i ) + 1 ] -= 1 <NEWLINE> <DEDENT> return np . cumsum ( B ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) + [ 0 , ] , dtype = np . int ) <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> A_new = op ( A , n ) <NEWLINE> if all ( A [ : n ] == A_new [ : n ] ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> A = A_new <NEWLINE> <DEDENT> print ( <STRING> . join ( list ( map ( str , A [ : n ] ) ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans_len = 10 ** 6 + 10 <NEWLINE> is_ans = [ 0 ] * ( ans_len ) <NEWLINE> <NL> for a in a_list : <NEWLINE> <INDENT> is_ans [ a ] += 1 <NEWLINE> if is_ans [ a ] == 1 : <NEWLINE> <INDENT> b = 2 * a <NEWLINE> while b < ans_len : <NEWLINE> <INDENT> is_ans [ b ] += 2 <NEWLINE> b += a <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in a_list : <NEWLINE> <COMMENT> <NL> <INDENT> ans += ( is_ans [ a ] == 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N , A , B , C = map ( int , readline ( ) . split ( ) ) <NEWLINE> S = [ readline ( ) . strip ( ) for i in range ( N ) ] <NEWLINE> <NL> AB , AC , BC = <STRING> , <STRING> , <STRING> <NEWLINE> <NL> n0 = [ A , B , C ] . count ( 0 ) <NEWLINE> <NL> F = [ A , B , C ] <NEWLINE> H = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> G = { AB : ( 0 , 1 ) , BC : ( 1 , 2 ) , AC : ( 0 , 2 ) } <NEWLINE> <NL> if n0 == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n0 == 2 and sum ( [ A , B , C ] ) == 1 : <NEWLINE> <INDENT> path = [ ] <NEWLINE> for com in S : <NEWLINE> <INDENT> a , b = G [ com ] <NEWLINE> if F [ a ] == F [ b ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if F [ a ] == 1 : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> path . append ( H [ a ] ) <NEWLINE> F [ a ] += 1 <NEWLINE> F [ b ] -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for p in path : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( S [ 0 ] == AB and A == 0 and B == 0 ) or ( S [ 0 ] == AC and A == 0 and C == 0 ) or ( S [ 0 ] == BC and B == 0 and C == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> path = [ ] <NEWLINE> for i , com in enumerate ( S ) : <NEWLINE> <INDENT> a , b = G [ com ] <NEWLINE> if F [ a ] == 0 or F [ b ] == 0 : <NEWLINE> <INDENT> if F [ b ] == 0 : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> path . append ( H [ a ] ) <NEWLINE> F [ a ] += 1 <NEWLINE> F [ b ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i < len ( S ) - 1 and F [ a ] == F [ b ] : <NEWLINE> <INDENT> if b in G [ S [ i + 1 ] ] : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> path . append ( H [ a ] ) <NEWLINE> F [ a ] += 1 <NEWLINE> F [ b ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if F [ a ] > F [ b ] : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> path . append ( H [ a ] ) <NEWLINE> F [ a ] += 1 <NEWLINE> F [ b ] -= 1 <NEWLINE> <DEDENT> <DEDENT> assert all ( v >= 0 for v in F ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for p in path : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> t = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> t += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = [ 0 ] * n <NEWLINE> li1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> li [ li1 [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( li [ i ] ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s [ i ] . sort ( ) <NEWLINE> s [ i ] = <STRING> . join ( s [ i ] ) <NEWLINE> <DEDENT> counter = Counter ( s ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> for val in counter . values ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += val * ( val - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> s = <STRING> <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if ( <STRING> in line ) or ( <STRING> in line ) or ( <STRING> in line ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = [ i for i in line ] <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> if l [ i ] in s : <NEWLINE> <INDENT> a = s . index ( l [ i ] ) <NEWLINE> l [ i ] = l [ i ] . replace ( l [ i ] , s [ ( a + 1 ) % 26 ] ) <NEWLINE> <DEDENT> <DEDENT> line = <STRING> . join ( l ) <NEWLINE> <DEDENT> <DEDENT> print ( line . rstrip ( ) ) <NEWLINE> <DEDENT>
import collections as c <NEWLINE> print ( sum ( [ 1 for i in c . Counter ( [ int ( input ( ) ) for _ in range ( int ( input ( ) ) ) ] ) . values ( ) if i % 2 != 0 ] ) ) <NEWLINE>
def LCS ( str1 , str2 ) : <NEWLINE> <INDENT> A = [ 0 for _ in range ( len ( str2 ) + 1 ) ] <NEWLINE> for i in range ( len ( str1 ) ) : <NEWLINE> <INDENT> A_copy = A [ : ] <NEWLINE> for j in range ( len ( str2 ) ) : <NEWLINE> <INDENT> if ( str1 [ i ] == str2 [ j ] ) : <NEWLINE> <INDENT> A [ j + 1 ] = A_copy [ j ] + 1 <NEWLINE> <DEDENT> elif ( A [ j ] > A [ j + 1 ] ) : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( A [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> m = int ( input ( ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> str1 = input ( ) <NEWLINE> str2 = input ( ) <NEWLINE> LCS ( str1 , str2 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M , K = NMI ( ) <NEWLINE> A = NLI ( ) <NEWLINE> B = NLI ( ) <NEWLINE> <NL> cumsum_A = [ 0 for _ in range ( len ( A ) + 1 ) ] <NEWLINE> cumsum_B = [ 0 for _ in range ( len ( B ) + 1 ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> cnt += A [ n ] <NEWLINE> cumsum_A [ n + 1 ] = cnt <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> <NL> for m in range ( M ) : <NEWLINE> <INDENT> cnt += B [ m ] <NEWLINE> cumsum_B [ m + 1 ] = cnt <NEWLINE> <NL> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> b = M <NEWLINE> <NL> for n in range ( N + 1 ) : <NEWLINE> <INDENT> remain_K = K - cumsum_A [ n ] <NEWLINE> if remain_K < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for m in range ( b , - 1 , - 1 ) : <NEWLINE> <INDENT> if cumsum_B [ m ] > remain_K : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = m <NEWLINE> ans = max ( ans , n + m ) <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> N = int ( readline ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> A = [ ( A [ i ] , i ) for i in range ( N ) ] <NEWLINE> A_sort = sorted ( A , reverse = True ) <NEWLINE> <NL> dp = [ - float ( <STRING> ) ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> dp_new = [ - float ( <STRING> ) ] * ( N + 1 ) <NEWLINE> pi = A_sort [ i ] [ 1 ] <COMMENT> <NEWLINE> for l in range ( i + 1 ) : <NEWLINE> <INDENT> r = i - l <COMMENT> <NEWLINE> dp_new [ l + 1 ] = max ( dp_new [ l + 1 ] , dp [ l ] + A_sort [ i ] [ 0 ] * ( pi - l ) ) <NEWLINE> dp_new [ l ] = max ( dp_new [ l ] , dp [ l ] + A_sort [ i ] [ 0 ] * ( ( N - r - 1 ) - pi ) ) <NEWLINE> <DEDENT> dp = dp_new <NEWLINE> <DEDENT> print ( max ( dp ) ) <NEWLINE>
from math import factorial <NEWLINE> from collections import Counter <NEWLINE> <NL> <NL> def combinations_count ( n , r ) : <NEWLINE> <INDENT> if n >= r : <NEWLINE> <INDENT> return factorial ( n ) // ( factorial ( n - r ) * factorial ( r ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> c = Counter ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in A : <NEWLINE> <INDENT> c [ i ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for k , v in c . items ( ) : <NEWLINE> <INDENT> ans += combinations_count ( v , 2 ) <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <INDENT> print ( ans - c [ i ] + 1 ) <NEWLINE> <DEDENT>
N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> dest = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> route = [ 1 ] <NEWLINE> flag = [ 1 ] + [ 0 ] * ( N - 1 ) <NEWLINE> t = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if flag [ dest [ t - 1 ] - 1 ] == 0 : <NEWLINE> <INDENT> t = dest [ t - 1 ] <NEWLINE> route . append ( t ) <NEWLINE> flag [ t - 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop = route . index ( dest [ t - 1 ] ) <NEWLINE> L_loop = len ( route ) - loop <NEWLINE> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> if K < len ( route ) : <NEWLINE> <INDENT> ans = route [ K ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = K - len ( route ) <NEWLINE> ans = route [ loop + ( K % L_loop ) ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] >= a [ k + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> def gcd ( x , y ) : <NEWLINE> <INDENT> if y == 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( y , x % y ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> MOD = 1000000007 <NEWLINE> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> C = defaultdict ( int ) <NEWLINE> n00 = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if a == 0 and b == 0 : <NEWLINE> <INDENT> n00 += 1 <NEWLINE> continue <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if b == 0 : <NEWLINE> <INDENT> C [ ( - 1 , 0 ) ] += 1 <NEWLINE> continue <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> C [ ( 0 , 1 ) ] += 1 <NEWLINE> continue <NEWLINE> <DEDENT> _gcd = gcd ( a , b ) <NEWLINE> a = a // _gcd <NEWLINE> b = b // _gcd <NEWLINE> <COMMENT> <NL> if b < 0 : <NEWLINE> <INDENT> b = - b <NEWLINE> a = - a <NEWLINE> <DEDENT> C [ ( a , b ) ] += 1 <NEWLINE> <NL> <DEDENT> C = dict ( C ) <NEWLINE> flag = { k : False for k in C . keys ( ) } <NEWLINE> <NL> groups = [ ] <NEWLINE> for c , nc in C . items ( ) : <NEWLINE> <INDENT> a , b = c <NEWLINE> <COMMENT> <NL> bad_a , bad_b = - b , a <NEWLINE> if bad_b < 0 : <NEWLINE> <INDENT> bad_b = - bad_b <NEWLINE> bad_a = - bad_a <NEWLINE> <DEDENT> nBad = C . get ( ( bad_a , bad_b ) , 0 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if nBad == 0 : <NEWLINE> <INDENT> groups . append ( 2 ** nc ) <NEWLINE> continue <NEWLINE> <COMMENT> <NL> <DEDENT> elif flag [ ( bad_a , bad_b ) ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> groups . append ( ( 2 ** nc ) + ( 2 ** nBad ) - 1 ) <NEWLINE> flag [ ( a , b ) ] = True <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans = 1 <NEWLINE> for g in groups : <NEWLINE> <INDENT> ans = ( ans * g ) % MOD <NEWLINE> <COMMENT> <NL> <DEDENT> ans = ( ans + n00 - 1 ) % MOD <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import copy <NEWLINE> class Dice2 : <NEWLINE> <INDENT> def __init__ ( self , nums ) : <NEWLINE> <INDENT> self . nums = nums <NEWLINE> self . dic = { ( 1 , 2 ) : 3 , ( 1 , 3 ) : 5 , ( 1 , 4 ) : 2 , ( 1 , 5 ) : 4 , ( 2 , 3 ) : 1 , ( 2 , 4 ) : 6 , ( 2 , 6 ) : 3 , ( 3 , 5 ) : 1 , ( 3 , 6 ) : 5 , ( 4 , 5 ) : 6 , ( 4 , 6 ) : 2 , ( 5 , 6 ) : 4 } <NEWLINE> <DEDENT> def output_right ( self , x ) : <NEWLINE> <INDENT> x [ 0 ] = self . nums . index ( x [ 0 ] ) + 1 <NEWLINE> x [ 1 ] = self . nums . index ( x [ 1 ] ) + 1 <NEWLINE> nums = self . nums <NEWLINE> y = copy . deepcopy ( x ) <NEWLINE> x . sort ( ) <NEWLINE> key = tuple ( x ) <NEWLINE> if tuple ( y ) == key : <NEWLINE> <INDENT> return nums [ self . dic [ key ] - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return nums [ 6 - self . dic [ key ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dice = Dice2 ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> print ( dice . output_right ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> from scipy . sparse . csgraph import bellman_ford , connected_components <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m , p = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = np . zeros ( ( n , n ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> c = p - c <NEWLINE> if c == 0 : <NEWLINE> <INDENT> c = 10 ** ( - 7.9 ) <NEWLINE> <DEDENT> if l [ a - 1 ] [ b - 1 ] == 0 : <NEWLINE> <INDENT> l [ a - 1 ] [ b - 1 ] = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ a - 1 ] [ b - 1 ] = min ( l [ a - 1 ] [ b - 1 ] , c ) <NEWLINE> <DEDENT> <DEDENT> x = l [ - 1 , 0 ] <NEWLINE> l [ - 1 ] [ 0 ] = 10 ** ( - 7.9 ) <NEWLINE> n , labels = connected_components ( l , connection = <STRING> ) <NEWLINE> l = l [ labels == labels [ 0 ] ] [ : , labels == labels [ 0 ] ] <NEWLINE> l [ - 1 , 0 ] = x <NEWLINE> <NL> try : <NEWLINE> <INDENT> print ( max ( 0 , int ( round ( bellman_ford ( l , indices = 0 ) [ - 1 ] ) ) * ( - 1 ) ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def bin_tree ( pri , li_pri , len_li ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> lo = 0 <NEWLINE> hi = len_li - 1 <NEWLINE> while hi - lo > 1 : <NEWLINE> <INDENT> mid = lo + ( hi - lo ) // 2 <NEWLINE> guess = li_pri [ mid ] <NEWLINE> if guess >= pri : <NEWLINE> <INDENT> hi = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lo = mid <NEWLINE> <DEDENT> <DEDENT> return lo <NEWLINE> <NL> <DEDENT> I = input ( ) . split ( ) <NEWLINE> N = int ( I [ 0 ] ) <NEWLINE> M = int ( I [ 1 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> while M > 0 : <NEWLINE> <INDENT> M -= 1 <NEWLINE> pri = A . pop ( N - 1 ) <NEWLINE> pri = pri // 2 <NEWLINE> if len ( A ) == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif ( pri < A [ 0 ] ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = bin_tree ( pri , A , N - 1 ) + 1 <NEWLINE> <COMMENT> <NL> <DEDENT> A [ ans : ans ] = [ pri ] <NEWLINE> <NL> <DEDENT> F_pri = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> F_pri += A [ i ] <NEWLINE> <DEDENT> print ( F_pri ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> sum_A = sum ( A ) <NEWLINE> memo = [ 0 ] * 100001 <NEWLINE> for a in A : <NEWLINE> <INDENT> memo [ a ] += 1 <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> sum_A += ( C - B ) * memo [ B ] <NEWLINE> memo [ C ] += memo [ B ] <NEWLINE> memo [ B ] = 0 <NEWLINE> print ( sum_A ) <NEWLINE> <NL> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Map = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Visited = [ - 1 ] * N <NEWLINE> now = 1 <NEWLINE> Order = [ 0 ] * N <NEWLINE> <NL> loopcount = 1 <NEWLINE> Order [ 0 ] = 1 <NEWLINE> Visited [ 0 ] = 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> nt = Map [ now - 1 ] <NEWLINE> Order [ i ] = nt <NEWLINE> loopcount += 1 <NEWLINE> if Visited [ nt - 1 ] == - 1 : <NEWLINE> <INDENT> Visited [ nt - 1 ] = loopcount <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> now = nt <NEWLINE> <NL> <NL> <DEDENT> ns = Visited [ nt - 1 ] <NEWLINE> period = loopcount - ns <NEWLINE> <NL> if period == 0 : <NEWLINE> <INDENT> period = loopcount <NEWLINE> ns = 0 <NEWLINE> <NL> <DEDENT> Kmod = K - ns <NEWLINE> if Kmod > 0 : <NEWLINE> <INDENT> Kmod %= period <NEWLINE> <NL> <DEDENT> print ( Order [ ns + Kmod ] ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> if abs ( ( p [ 3 ] - p [ 1 ] ) * ( p [ 6 ] - p [ 4 ] ) - ( p [ 7 ] - p [ 5 ] ) * ( p [ 2 ] - p [ 0 ] ) ) < 1e-10 else <STRING> ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> a1 = int ( a ) <NEWLINE> bs = list ( b ) <NEWLINE> b1 = int ( bs [ 0 ] ) <NEWLINE> b2 = 0 <NEWLINE> if len ( b ) == 3 : <NEWLINE> <INDENT> b2 = int ( bs [ 2 ] ) * 10 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b2 = int ( bs [ 2 ] + bs [ 3 ] ) <NEWLINE> <DEDENT> b1 = b1 * 100 + b2 <NEWLINE> ans = list ( str ( a1 * b1 ) ) <NEWLINE> del ans [ - 1 ] <NEWLINE> if ans : <NEWLINE> <INDENT> del ans [ - 1 ] <NEWLINE> <DEDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> . join ( ans ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import math <NEWLINE> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> Longdegree = H * 30 + M * 0.5 <NEWLINE> Shortdegree = M * 6 <NEWLINE> LSdegree = abs ( Longdegree - Shortdegree ) <NEWLINE> print ( math . sqrt ( A ** 2 + B ** 2 - 2 * A * B * math . cos ( math . radians ( LSdegree ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> A . sort ( ) <NEWLINE> A . append ( - 1 ) <NEWLINE> <NL> dat = { i : False for i in range ( 10 ** 6 + 10 ) } <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> if dat [ A [ i ] ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A [ i ] != A [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> for i in range ( A [ i ] , 10 ** 6 + 10 , A [ i ] ) : <NEWLINE> <INDENT> dat [ i ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict , deque <NEWLINE> import math <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> tmp = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> tmp += int ( n [ i ] ) <NEWLINE> tmp %= 9 <NEWLINE> <DEDENT> if ( tmp % 9 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> t = [ ] <NEWLINE> ans = [ 0 ] * ( 10 ** 4 + 5 ) <NEWLINE> def calc ( x , y , z ) : <NEWLINE> <INDENT> return x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> <NL> <DEDENT> for x in range ( 1 , 10 ** 2 ) : <NEWLINE> <INDENT> for y in range ( 1 , 10 ** 2 ) : <NEWLINE> <INDENT> for z in range ( 1 , 10 ** 2 ) : <NEWLINE> <INDENT> t . append ( calc ( x , y , z ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in t : <NEWLINE> <INDENT> if i < 10 ** 4 + 5 : <NEWLINE> <INDENT> ans [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> if A [ - 1 ] < 0 and k % 2 == 1 : <NEWLINE> <INDENT> now = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> now *= A [ - i - 1 ] % mod <NEWLINE> now %= mod <NEWLINE> <DEDENT> print ( now ) ; exit ( ) <NEWLINE> <NL> <DEDENT> l = 0 ; r = n - 1 <NEWLINE> ans = 1 <NEWLINE> if k % 2 == 1 : <NEWLINE> <INDENT> ans = A [ - 1 ] <NEWLINE> r -= 1 <NEWLINE> <NL> <DEDENT> for i in range ( k // 2 ) : <NEWLINE> <INDENT> mi = A [ l ] * A [ l + 1 ] <NEWLINE> pl = A [ r ] * A [ r - 1 ] <NEWLINE> if mi > pl : <NEWLINE> <INDENT> ans *= mi % mod <NEWLINE> ans %= mod <NEWLINE> l += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= pl % mod <NEWLINE> ans %= mod <NEWLINE> r -= 2 <NEWLINE> <DEDENT> <DEDENT> print ( ans % mod ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> z = 0 <NEWLINE> for a in range ( N ) : <NEWLINE> <INDENT> for b in range ( min ( a , math . floor ( N / ( a + 1 ) ) ) ) : <NEWLINE> <INDENT> if N - ( a + 1 ) * ( b + 1 ) > 0 : <NEWLINE> <INDENT> z = z + 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> if N - ( a + 1 ) * ( a + 1 ) > 0 : <NEWLINE> <INDENT> z = z + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( z ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> h . sort ( ) <NEWLINE> h . reverse ( ) <NEWLINE> <NL> en = deque ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i , j in enumerate ( h ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> en . append ( ( j , j ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> maxtmp , mintmp = en . popleft ( ) <NEWLINE> ans += mintmp <NEWLINE> en . append ( ( maxtmp , j ) ) <NEWLINE> en . append ( ( mintmp , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> <NL> for i in As : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in ans : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
import math <NEWLINE> import heapq <NEWLINE> <NL> A = [ ] <NEWLINE> inp = input ( ) <NEWLINE> while True : <NEWLINE> <INDENT> if inp == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( - heapq . heappop ( A ) ) <NEWLINE> <DEDENT> elif inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> heapq . heappush ( A , - int ( inp [ 7 : ] ) ) <NEWLINE> <DEDENT> inp = input ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def calc_power ( p ) : <NEWLINE> <INDENT> P = list ( map ( lambda x : ( x - p ) ** 2 , X ) ) <NEWLINE> return sum ( P ) <NEWLINE> <NL> <DEDENT> power = [ ] <NEWLINE> _min = min ( X ) <NEWLINE> _max = max ( X ) <NEWLINE> <NL> if _min != _max : <NEWLINE> <INDENT> for p in range ( _min , _max ) : <NEWLINE> <INDENT> power . append ( calc_power ( p ) ) <NEWLINE> <DEDENT> print ( min ( power ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> power = calc_power ( _min ) <NEWLINE> print ( power ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> d = s . split ( ) <NEWLINE> n = int ( d [ 0 ] ) <NEWLINE> q = int ( d [ 1 ] ) <NEWLINE> end_t = 0 <NEWLINE> processes = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> processes . append ( [ ] ) <NEWLINE> s = input ( ) <NEWLINE> d = s . split ( ) <NEWLINE> processes [ i ] . append ( d [ 0 ] ) <NEWLINE> processes [ i ] . append ( int ( d [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if processes [ 0 ] [ 1 ] <= q : <NEWLINE> <INDENT> end_t += processes [ 0 ] [ 1 ] <NEWLINE> print ( processes [ 0 ] [ 0 ] , end_t ) <NEWLINE> processes . pop ( 0 ) <NEWLINE> cnt += 1 <NEWLINE> if cnt == n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> processes [ 0 ] [ 1 ] -= q <NEWLINE> end_t += q <NEWLINE> processes . append ( processes [ 0 ] ) <NEWLINE> processes . pop ( 0 ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> trs = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> cum = [ ] <NEWLINE> cannot = False <NEWLINE> <NL> acc = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> acc = max ( acc , i + trs [ i ] // 10 ) <NEWLINE> acc = min ( acc , n - 1 ) <NEWLINE> cum . append ( acc ) <NEWLINE> <NL> <DEDENT> rev = [ ] <NEWLINE> acc = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> acc = max ( acc , i + trs [ n - 1 - i ] // 10 ) <NEWLINE> acc = min ( acc , n - 1 ) <NEWLINE> rev . append ( acc ) <NEWLINE> <NL> <DEDENT> ind = 0 <NEWLINE> tmp = 0 <NEWLINE> while True : <NEWLINE> <INDENT> ind = cum [ ind ] <NEWLINE> if ind == n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ind == tmp : <NEWLINE> <INDENT> cannot = True <NEWLINE> break <NEWLINE> <DEDENT> tmp = ind <NEWLINE> <NL> <DEDENT> ind = 0 <NEWLINE> tmp = 0 <NEWLINE> while True : <NEWLINE> <INDENT> ind = rev [ ind ] <NEWLINE> if ind == n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ind == tmp : <NEWLINE> <INDENT> cannot = True <NEWLINE> break <NEWLINE> <DEDENT> tmp = ind <NEWLINE> <NL> <DEDENT> if cannot : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def SL ( ) : return map ( str , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def IL ( ) : return map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <NL> def Main ( ) : <NEWLINE> <INDENT> a , b , c , k = IL ( ) <NEWLINE> ta = min ( k , a ) <NEWLINE> tb = min ( k - ta , b ) <NEWLINE> if tb < 0 : tb = 0 <NEWLINE> tc = k - ta - tb <NEWLINE> print ( ta - tc ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Main ( ) <NEWLINE> <DEDENT>
N , Y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for y in range ( N + 1 ) : <NEWLINE> <INDENT> for w in range ( N + 1 ) : <NEWLINE> <INDENT> if y * 10000 + w * 5000 + ( N - y - w ) * 1000 == Y and N - y - w >= 0 : <NEWLINE> <INDENT> ans = str ( y ) + <STRING> + str ( w ) + <STRING> + str ( N - y - w ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import numpy as np <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> warps = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> warps = [ 0 ] + warps <NEWLINE> warps = np . array ( warps , dtype = int ) <NEWLINE> <NL> dp = np . zeros ( ( k . bit_length ( ) + 1 , n + 1 ) , dtype = int ) <NEWLINE> <NL> dp [ 0 , : ] = warps <NEWLINE> <NL> for h in range ( 1 , len ( dp ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ h ] = np . take ( dp [ h - 1 ] , dp [ h - 1 ] ) <NEWLINE> <NL> <DEDENT> node = 1 <NEWLINE> <COMMENT> <NL> for i in range ( k . bit_length ( ) , - 1 , - 1 ) : <NEWLINE> <INDENT> if k >> i & 1 : <NEWLINE> <INDENT> node = dp [ i ] [ node ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( node ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> if <STRING> in globals ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> n , k = 4 , 5 <NEWLINE> A = [ 3 , 2 , 4 , 1 ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> Town = [ ] <NEWLINE> rec = [ - 1 ] * ( n + 1 ) <COMMENT> <NEWLINE> idx = 1 <NEWLINE> <NL> <COMMENT> <NL> while ( rec [ idx ] == - 1 ) : <NEWLINE> <INDENT> rec [ idx ] = len ( Town ) <NEWLINE> Town . append ( idx ) <NEWLINE> idx = A [ idx - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> Exce = rec [ idx ] <NEWLINE> <COMMENT> <NL> Cycl = len ( Town ) - Exce <NEWLINE> <NL> if Exce > k : <NEWLINE> <INDENT> print ( Town [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Warp = ( k - Exce ) % Cycl <NEWLINE> print ( Town [ Exce + Warp ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import bisect <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> a = bisect . bisect_left ( A , b ) <NEWLINE> c = N - bisect . bisect_right ( C , b ) <NEWLINE> ans += a * c <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import itertools <NEWLINE> from itertools import combinations_with_replacement <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> data = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> arr = combinations_with_replacement ( range ( 1 , M + 1 ) , N ) <NEWLINE> ans = 0 <NEWLINE> for a in arr : <NEWLINE> <COMMENT> <NL> <INDENT> s = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for d in data : <NEWLINE> <INDENT> if a [ d [ 1 ] - 1 ] - a [ d [ 0 ] - 1 ] == d [ 2 ] : <NEWLINE> <INDENT> s += d [ 3 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if s > ans : <NEWLINE> <INDENT> ans = s <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> X = str ( input ( ) ) <NEWLINE> ones = X . count ( <STRING> ) <NEWLINE> intX = int ( X , 2 ) <NEWLINE> def check ( n , r ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return print ( r ) <NEWLINE> <DEDENT> d = str ( bin ( n ) ) . count ( <STRING> ) <NEWLINE> check ( n % d , r + 1 ) <NEWLINE> <NL> <DEDENT> if ones > 1 : <NEWLINE> <INDENT> Xplus = intX % ( ones + 1 ) <NEWLINE> Xminus = intX % ( ones - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Xplus = intX % ( ones + 1 ) <NEWLINE> Xminus = intX <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> e = 1 <NEWLINE> if X [ i ] == <STRING> : <NEWLINE> <INDENT> num = ( Xplus + pow ( 2 , N - 1 - i , ones + 1 ) ) % ( ones + 1 ) <NEWLINE> <DEDENT> elif X [ i ] == <STRING> and ones > 1 : <NEWLINE> <INDENT> num = ( Xminus - pow ( 2 , N - 1 - i , ones - 1 ) ) % ( ones - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = ( Xminus - pow ( 2 , N - 1 - i ) ) <NEWLINE> e = 0 <NEWLINE> <DEDENT> check ( num , e ) <NEWLINE> <DEDENT>
H = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> while H != 1 : <NEWLINE> <INDENT> H //= 2 <NEWLINE> count += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( count + 1 ) : <NEWLINE> <INDENT> ans += 2 ** i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import random <NEWLINE> import sys <NEWLINE> import os <NEWLINE> <NL> <NL> class Tree : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> if self . root == None : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def print_inorder ( self ) : <NEWLINE> <INDENT> self . inorder_list = [ ] <NEWLINE> self . __inorder ( self . root ) <NEWLINE> return self . inorder_list <NEWLINE> <NL> <DEDENT> def __inorder ( self , node ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if node is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . __inorder ( node . left ) <NEWLINE> self . inorder_list . append ( node . key ) <NEWLINE> self . __inorder ( node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def print_preorder ( self ) : <NEWLINE> <INDENT> self . preorder_list = [ ] <NEWLINE> self . __preorder ( self . root ) <NEWLINE> return self . preorder_list <NEWLINE> <NL> <DEDENT> def __preorder ( self , node ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if node is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . preorder_list . append ( node . key ) <NEWLINE> self . __preorder ( node . left ) <NEWLINE> self . __preorder ( node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def insert ( self , node ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . root is None : <NEWLINE> <INDENT> self . root = node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = self . root <NEWLINE> parent_candidate = x <NEWLINE> <NL> while x is not None : <NEWLINE> <INDENT> parent_candidate = x <NEWLINE> if x . key > node . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> x = node <NEWLINE> x . parent = parent_candidate <NEWLINE> <NL> <COMMENT> <NL> if x . key < x . parent . key : <NEWLINE> <INDENT> x . parent . left = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x . parent . right = x <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def find ( self , value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> x = self . root <NEWLINE> while x is not None and x . key != value : <NEWLINE> <INDENT> if x . key > value : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def delete ( self , value ) : <NEWLINE> <INDENT> found_node = self . find ( value ) <NEWLINE> if found_node is None : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if found_node . is_leaf ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> if found_node . parent . left is not None and found_node . parent . left . key == found_node . key : <NEWLINE> <INDENT> found_node . parent . left = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> found_node . parent . right = None <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if found_node . has_one_child ( ) : <NEWLINE> <INDENT> one_child = found_node . get_one_child ( ) <NEWLINE> <NL> <COMMENT> <NL> one_child . parent = found_node . parent <NEWLINE> <NL> <COMMENT> <NL> if found_node . parent . left == found_node : <NEWLINE> <INDENT> found_node . parent . left = one_child <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> found_node . parent . right = one_child <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> next_section_point = found_node . get_next_section_point ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> key = next_section_point . key <NEWLINE> self . delete ( next_section_point . key ) <NEWLINE> found_node . key = key <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> class Node : <NEWLINE> <INDENT> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . parent = None <COMMENT> <NEWLINE> self . left = None <COMMENT> <NEWLINE> self . right = None <COMMENT> <NEWLINE> self . key = key <COMMENT> <NEWLINE> <NL> <DEDENT> def has_one_child ( self ) : <NEWLINE> <INDENT> if self . left is None and self . right is not None : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif self . left is not None and self . right is None : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def get_one_child ( self ) : <NEWLINE> <INDENT> if not self . has_one_child ( ) : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . left is not None : <NEWLINE> <INDENT> return self . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . right <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def get_next_section_point ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> <COMMENT> <NL> if self . right is not None : <NEWLINE> <INDENT> return self . right . get_minimum ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> return self . parent <NEWLINE> <NL> <DEDENT> <DEDENT> def is_leaf ( self ) : <NEWLINE> <INDENT> if self . left is None and self . right is None : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def get_minimum ( self ) : <NEWLINE> <INDENT> if self . left is None : <NEWLINE> <INDENT> return self <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . left . get_minimum ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> tree = Tree ( ) <NEWLINE> s = input ( ) <NEWLINE> n = int ( s ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> value = int ( s . split ( <STRING> ) [ - 1 ] ) <NEWLINE> node = Node ( value ) <NEWLINE> tree . insert ( node ) <NEWLINE> <NL> <DEDENT> if <STRING> in s : <NEWLINE> <INDENT> in_list = tree . print_inorder ( ) <NEWLINE> in_list = map ( str , in_list ) <NEWLINE> print ( <STRING> + <STRING> . join ( in_list ) ) <NEWLINE> <NL> pre_list = tree . print_preorder ( ) <NEWLINE> pre_list = map ( str , pre_list ) <NEWLINE> print ( <STRING> + <STRING> . join ( pre_list ) ) <NEWLINE> <NL> <DEDENT> if <STRING> in s : <NEWLINE> <INDENT> value = int ( s . split ( <STRING> ) [ - 1 ] ) <NEWLINE> node = tree . find ( value ) <NEWLINE> if node is None : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if <STRING> in s : <NEWLINE> <INDENT> value = int ( s . split ( <STRING> ) [ - 1 ] ) <NEWLINE> tree . delete ( value ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter , defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ca = Counter ( a ) <NEWLINE> cb = Counter ( b ) <NEWLINE> <NL> for ka , va in ca . items ( ) : <NEWLINE> <INDENT> vb = cb [ ka ] <NEWLINE> if va + vb > n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> end = defaultdict ( int ) <NEWLINE> for i , e in enumerate ( a ) : <NEWLINE> <INDENT> end [ e ] = i <NEWLINE> <NL> <DEDENT> mx = 0 <NEWLINE> for i , e in enumerate ( b ) : <NEWLINE> <INDENT> diff = end [ e ] - i + 1 <NEWLINE> mx = max ( mx , diff ) <NEWLINE> <NL> <DEDENT> ans = b [ - mx : ] + b [ : - mx ] <NEWLINE> print ( * ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> s = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> ans += s * a [ i ] <NEWLINE> s += a [ i ] <NEWLINE> <DEDENT> print ( ans % c ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> x = max ( 0 , N // B * B - 1 ) <NEWLINE> cur1 = A * x / B // 1 - A * ( x / B // 1 ) <NEWLINE> cur2 = A * N / B // 1 - A * ( N / B // 1 ) <NEWLINE> print ( int ( max ( cur1 , cur2 ) ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> words = [ ] <NEWLINE> scores = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> word , score = input ( ) . split ( ) <NEWLINE> words . append ( word ) <NEWLINE> scores . append ( int ( score ) ) <NEWLINE> <DEDENT> mp = [ <STRING> * 6 ] + [ <STRING> + input ( ) + <STRING> for _ in range ( 4 ) ] + [ <STRING> * 6 ] <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> def search ( word ) : <NEWLINE> <INDENT> used = [ [ False ] * 6 for _ in range ( 6 ) ] <NEWLINE> vec = ( ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) , ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) ) <NEWLINE> <NL> def _search ( word , pos , x , y ) : <NEWLINE> <INDENT> if pos == len ( word ) - 1 : return 1 <NEWLINE> used [ y ] [ x ] = True <NEWLINE> ret = 0 <NEWLINE> for dx , dy in vec : <NEWLINE> <INDENT> nx , ny = x + dx , y + dy <NEWLINE> if not used [ ny ] [ nx ] and mp [ ny ] [ nx ] == word [ pos + 1 ] : <NEWLINE> <INDENT> ret += _search ( word , pos + 1 , nx , ny ) <NEWLINE> <DEDENT> <DEDENT> used [ y ] [ x ] = False <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> for y in range ( 1 , 5 ) : <NEWLINE> <INDENT> for x in range ( 1 , 5 ) : <NEWLINE> <INDENT> if mp [ y ] [ x ] == word [ 0 ] : ret += _search ( word , 0 , x , y ) <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> values = [ ] <NEWLINE> weights = [ ] <NEWLINE> for word , score in zip ( words , scores ) : <NEWLINE> <INDENT> cnt = search ( word ) <NEWLINE> acc = 1 <NEWLINE> while cnt >= acc : <NEWLINE> <INDENT> cnt -= acc <NEWLINE> values . append ( score * acc ) <NEWLINE> weights . append ( len ( word ) * acc ) <NEWLINE> acc *= 2 <NEWLINE> <DEDENT> if cnt : <NEWLINE> <INDENT> values . append ( score * cnt ) <NEWLINE> weights . append ( len ( word ) * cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> dp = [ 0 ] * ( t + 1 ) <NEWLINE> for v , w in zip ( values , weights ) : <NEWLINE> <INDENT> for x in range ( max ( - 1 , t - w ) , - 1 , - 1 ) : <NEWLINE> <INDENT> dp [ x + w ] = max ( dp [ x + w ] , dp [ x ] + v ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( dp ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> x = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( x , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
H = int ( input ( ) ) <NEWLINE> L = len ( bin ( H ) ) - 2 <NEWLINE> ans = 0 <NEWLINE> for j in range ( L ) : <NEWLINE> <INDENT> ans += 2 ** j <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> c = Counter ( [ <STRING> . join ( sorted ( input ( ) ) ) for i in range ( n ) ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> for k , cnt in c . items ( ) : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += ( N // i ) * i * ( N // i + 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 0 <NEWLINE> s = [ ] <NEWLINE> for i in A : <NEWLINE> <INDENT> if i < a : <NEWLINE> <INDENT> s . append ( a - i ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> a = i <NEWLINE> <DEDENT> <DEDENT> print ( sum ( s ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import itertools <NEWLINE> <NL> <COMMENT> <NL> X = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def get_value ( A : int , B : int ) -> int : <NEWLINE> <INDENT> return A ** 5 - B ** 5 <NEWLINE> <NL> <NL> <DEDENT> A_min , A_max = - 118 , 119 <NEWLINE> B_min , B_max = - 119 , 118 <NEWLINE> result = <STRING> <NEWLINE> for A , B in itertools . product ( range ( A_min , A_max + 1 ) , range ( B_min , B_max + 1 ) ) : <NEWLINE> <INDENT> value = get_value ( A , B ) <NEWLINE> if value == X : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
def lcs_len ( x , y ) : <NEWLINE> <INDENT> indices = [ 0 ] <NEWLINE> for y_i in y : <NEWLINE> <INDENT> t_index = c_index = 0 <NEWLINE> for i in range ( 1 , len ( indices ) + 1 ) : <NEWLINE> <INDENT> c_index = x . find ( y_i , t_index ) + 1 <NEWLINE> if c_index : <NEWLINE> <INDENT> if i < len ( indices ) : <NEWLINE> <INDENT> t_index = indices [ i ] <NEWLINE> indices [ i ] = min ( c_index , t_index ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> indices . append ( c_index ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( indices ) - 1 ) <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lcs_len ( input ( ) , input ( ) ) <NEWLINE> <DEDENT>
<NL> <STRING> <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> S = int ( input ( ) ) <NEWLINE> <NL> dp = [ 1 ] * 2001 <NEWLINE> dp [ 0 ] = dp [ 1 ] = dp [ 2 ] = 0 <NEWLINE> <STRING> <NEWLINE> <NL> for i in range ( 3 , S + 1 ) : <NEWLINE> <INDENT> for l in range ( i + 1 - 3 ) : <NEWLINE> <INDENT> dp [ i ] += dp [ l ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( dp [ S ] % MOD ) <NEWLINE> <NL>
S = input ( ) <NEWLINE> <NL> ACGT = <STRING> <NEWLINE> <NL> count = [ ] <NEWLINE> tmp_num = 0 <NEWLINE> for i in S : <NEWLINE> <INDENT> if i in ACGT : <NEWLINE> <INDENT> tmp_num += 1 <NEWLINE> <DEDENT> elif i not in ACGT : <NEWLINE> <INDENT> count . append ( tmp_num ) <NEWLINE> tmp_num = 0 <NEWLINE> <DEDENT> <DEDENT> count . append ( tmp_num ) <NEWLINE> <NL> print ( max ( count ) ) <NEWLINE>
import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> for v in itertools . product ( list ( range ( 1 , 101 ) ) , repeat = 3 ) : <NEWLINE> <INDENT> x , y , z = v [ 0 ] , v [ 1 ] , v [ 2 ] <NEWLINE> a = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if a <= n : ans [ a - 1 ] += 1 <NEWLINE> else : continue <NEWLINE> <DEDENT> for i in ans : print ( i ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mini = 1000 <NEWLINE> for i in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if not i in p : <NEWLINE> <INDENT> if mini > abs ( x - i ) : <NEWLINE> <INDENT> ans = i <NEWLINE> mini = abs ( x - i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> for i in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for j in range ( - 200 , 200 ) : <NEWLINE> <INDENT> j *= - 1 <NEWLINE> if X == ( i ** 5 - j ** 5 ) : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def Replacing ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lis = [ 0 for i in range ( 10 ** 5 ) ] <NEWLINE> res = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> lis [ i - 1 ] += 1 <NEWLINE> res += i <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> num = lis [ b - 1 ] <NEWLINE> res += ( c - b ) * num <NEWLINE> lis [ b - 1 ] = 0 <NEWLINE> lis [ c - 1 ] += num <NEWLINE> print ( res ) <NEWLINE> <NL> <DEDENT> <DEDENT> Replacing ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ai = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> for i in range ( len ( ai ) ) : <NEWLINE> <INDENT> ans [ ai [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> np_ab = np . array ( ab ) <NEWLINE> max_a = max ( np_ab [ : , 0 ] ) <NEWLINE> dp = [ 0 ] * ( h + max_a ) <NEWLINE> for i in range ( 1 , h + max_a ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + b for a , b in ab ) <NEWLINE> <DEDENT> print ( dp [ h ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> B , C = [ ] , [ ] <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <DEDENT> ans = sum ( A ) <NEWLINE> <NL> d = { } <NEWLINE> for a in A : <NEWLINE> <INDENT> d . setdefault ( a , 0 ) <NEWLINE> d [ a ] += 1 <NEWLINE> <NL> <DEDENT> for b , c in zip ( B , C ) : <NEWLINE> <INDENT> d . setdefault ( b , 0 ) <NEWLINE> d . setdefault ( c , 0 ) <NEWLINE> ans -= d [ c ] * c <NEWLINE> ans -= d [ b ] * b <NEWLINE> d [ c ] += d [ b ] <NEWLINE> d [ b ] = 0 <NEWLINE> ans += d [ c ] * c <NEWLINE> ans += d [ b ] * b <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> l = [ 0 ] * 10 ** 5 <NEWLINE> sm = 0 <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> for a in A : <NEWLINE> <INDENT> l [ a - 1 ] += 1 <NEWLINE> sm += a <NEWLINE> <DEDENT> Q = int ( input ( ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> for bc in BC : <NEWLINE> <INDENT> cnt = l [ bc [ 0 ] - 1 ] <NEWLINE> l [ bc [ 0 ] - 1 ] = 0 <NEWLINE> l [ bc [ 1 ] - 1 ] += cnt <NEWLINE> sm = sm - bc [ 0 ] * cnt + bc [ 1 ] * cnt <NEWLINE> print ( sm ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> M = A [ - 1 ] <NEWLINE> b = [ True ] * ( M + 1 ) <NEWLINE> <NL> count = 0 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if not b [ a ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( a , M + 1 , a ) : <NEWLINE> <INDENT> b [ j ] = False <NEWLINE> <DEDENT> if i < N - 1 and A [ i + 1 ] == a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> count += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
from math import floor <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if B <= N : <NEWLINE> <INDENT> ans = floor ( A * ( B - 1 ) / B ) - A * floor ( ( B - 1 ) / B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = floor ( ( A * N ) / B ) - A * floor ( N / B ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if B != 1 : <NEWLINE> <INDENT> p = ( N + 1 ) // B <NEWLINE> result = 0 <NEWLINE> if p != 0 : <NEWLINE> <INDENT> for a in range ( 1 , p + 1 ) : <NEWLINE> <INDENT> x = a * B - 1 <NEWLINE> s = ( A * x ) // B - A * ( a - 1 ) <NEWLINE> if result < s : <NEWLINE> <INDENT> result = s <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> result = A * N // B - A * ( N // B ) <NEWLINE> <DEDENT> print ( result ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math as mas <NEWLINE> <NL> li = <STRING> <NEWLINE> for t in sys . stdin : <NEWLINE> <INDENT> for i in range ( 30 ) : <NEWLINE> <INDENT> a = t [ : - 1 ] . translate ( str . maketrans ( li , li [ i : ] + li [ : i ] ) ) <NEWLINE> if 1 + a . find ( <STRING> ) or 1 + a . find ( <STRING> ) or 1 + a . find ( <STRING> ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from itertools import accumulate <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = tuple ( accumulate ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = P [ K - 1 ] <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> ans = max ( P [ i + K ] - P [ i ] , ans ) <NEWLINE> <DEDENT> print ( ( ans + K ) / 2 ) <NEWLINE>
mods = [ 0 ] * 2019 <NEWLINE> mods [ 0 ] = 1 <NEWLINE> s = input ( ) <NEWLINE> t = 0 <NEWLINE> u = 1 <NEWLINE> for i in range ( 1 , len ( s ) + 1 ) : <NEWLINE> <INDENT> t = ( t + int ( s [ - i ] ) * u ) % 2019 <NEWLINE> u = u * 10 % 2019 <NEWLINE> mods [ t ] += 1 <NEWLINE> <NL> <NL> <DEDENT> cnt = 0 <NEWLINE> for x in mods : <NEWLINE> <INDENT> if x >= 2 : <NEWLINE> <INDENT> cnt += x * ( x - 1 ) / 2 <NEWLINE> <DEDENT> <DEDENT> print ( int ( cnt ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Ai = [ 0 ] * N <NEWLINE> Ai = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Ai . sort ( ) <NEWLINE> Ans = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if Ai [ i ] == 0 : <NEWLINE> <INDENT> Ans = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> Ans = Ans * Ai [ i ] <NEWLINE> <NL> if Ans > 10 ** 18 : <NEWLINE> <INDENT> Ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if Ans <= 10 ** 18 : <NEWLINE> <INDENT> print ( Ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in a : <NEWLINE> <INDENT> res = res * x <NEWLINE> if ( res > 1000000000000000000 ) : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> abc = { <STRING> : a , <STRING> : b , <STRING> : c } <NEWLINE> <NL> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> ans = [ None ] * n <NEWLINE> i = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> x = s [ i ] [ 0 ] <NEWLINE> y = s [ i ] [ 1 ] <NEWLINE> if abc [ x ] == 0 and abc [ y ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif abc [ x ] == 1 and abc [ y ] == 1 and i < n - 1 : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> ans [ i ] = x <NEWLINE> ans [ i + 1 ] = y <NEWLINE> i += 1 <NEWLINE> <DEDENT> elif x in s [ i + 1 ] : <NEWLINE> <INDENT> ans [ i ] = x <NEWLINE> abc [ x ] += 1 <NEWLINE> abc [ y ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = y <NEWLINE> abc [ x ] -= 1 <NEWLINE> abc [ y ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if abc [ x ] <= abc [ y ] : <NEWLINE> <INDENT> ans [ i ] = x <NEWLINE> abc [ x ] += 1 <NEWLINE> abc [ y ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = y <NEWLINE> abc [ x ] -= 1 <NEWLINE> abc [ y ] += 1 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> from collections import deque <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> edges [ a ] . append ( ( b , i ) ) <NEWLINE> edges [ b ] . append ( ( a , i ) ) <NEWLINE> <NL> <DEDENT> color = [ None ] * ( N - 1 ) <NEWLINE> SIZE = 1 <NEWLINE> q = deque ( [ ( 0 , None ) ] ) <NEWLINE> while q : <NEWLINE> <INDENT> v , prev_color = q . popleft ( ) <NEWLINE> c = 1 <NEWLINE> for w , i in edges [ v ] : <NEWLINE> <INDENT> if not color [ i ] : <NEWLINE> <INDENT> if c == prev_color : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> color [ i ] = c <NEWLINE> c += 1 <NEWLINE> q . append ( ( w , color [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> SIZE = max ( SIZE , c - 1 ) <NEWLINE> <DEDENT> print ( SIZE ) <NEWLINE> for n in range ( N - 1 ) : <NEWLINE> <INDENT> print ( color [ n ] ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = 0 <NEWLINE> B = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> S += i <NEWLINE> B [ i ] += 1 <COMMENT> <NEWLINE> <DEDENT> Q = int ( input ( ) ) <NEWLINE> C = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> S = S + ( C [ i ] [ 1 ] - C [ i ] [ 0 ] ) * B [ C [ i ] [ 0 ] ] <NEWLINE> B [ C [ i ] [ 1 ] ] = B [ C [ i ] [ 0 ] ] + B [ C [ i ] [ 1 ] ] <NEWLINE> B [ C [ i ] [ 0 ] ] = 0 <NEWLINE> print ( S ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import numpy as np <NEWLINE> <NL> rl = sys . stdin . readline <NEWLINE> <NL> t = rl ( ) <NEWLINE> li = [ ] <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> li . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li . append ( t [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( li ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> <NL> sr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> ir = lambda : int ( sr ( ) ) <NEWLINE> lr = lambda : list ( map ( int , sr ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> N , M , S = lr ( ) <NEWLINE> UVAB = [ lr ( ) for _ in range ( M ) ] <NEWLINE> CD = [ lr ( ) for _ in range ( N ) ] <COMMENT> <NEWLINE> Amax = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a = UVAB [ i ] [ 2 ] <NEWLINE> if a > Amax : <NEWLINE> <INDENT> Amax = a <NEWLINE> <NL> <DEDENT> <DEDENT> limit = Amax * ( N - 1 ) <NEWLINE> S = min ( S , limit ) <NEWLINE> graph = [ [ ] for _ in range ( N + 1 ) ] <COMMENT> <NEWLINE> for u , v , a , b in UVAB : <NEWLINE> <INDENT> graph [ u ] . append ( ( v , a , b ) ) <NEWLINE> graph [ v ] . append ( ( u , a , b ) ) <NEWLINE> <NL> <DEDENT> def dijkstra ( start ) : <NEWLINE> <COMMENT> <NL> <INDENT> INF = 10 ** 15 <NEWLINE> dist = [ [ INF for _ in range ( limit + 1 ) ] for _ in range ( N + 1 ) ] <NEWLINE> dist [ 1 ] [ S ] = 0 <NEWLINE> que = [ ( 0 , S , 1 ) ] <NEWLINE> while que : <NEWLINE> <INDENT> time , silver , prev = heappop ( que ) <NEWLINE> if dist [ prev ] [ silver ] < time : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for next , a , b in graph [ prev ] : <NEWLINE> <INDENT> t = time + b <NEWLINE> si = silver - a <NEWLINE> if si < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if dist [ next ] [ si ] > t : <NEWLINE> <INDENT> dist [ next ] [ si ] = t <NEWLINE> heappush ( que , ( t , si , next ) ) <NEWLINE> <DEDENT> <DEDENT> c , d = CD [ prev - 1 ] <NEWLINE> si = min ( limit , silver + c ) <NEWLINE> while dist [ prev ] [ si ] > time + d : <NEWLINE> <INDENT> dist [ prev ] [ si ] = time + d <NEWLINE> heappush ( que , ( time + d , si , prev ) ) <NEWLINE> si += c ; si = min ( limit , si ) <NEWLINE> time += d <NEWLINE> <NL> <DEDENT> <DEDENT> return dist <NEWLINE> <NL> <DEDENT> dist = dijkstra ( 1 ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> d = dist [ i ] <NEWLINE> answer = min ( d ) <NEWLINE> print ( answer ) <NEWLINE> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> tot = 0 <NEWLINE> <NL> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for m in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for n in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tot += gcd ( gcd ( l , m ) , n ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( tot ) <NEWLINE>
a = list ( input ( ) ) <NEWLINE> b = list ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ptr = <STRING> <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if ptr == <STRING> : <NEWLINE> <INDENT> if a == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> ptr = a . pop ( 0 ) <NEWLINE> <DEDENT> if ptr == <STRING> : <NEWLINE> <INDENT> if b == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> ptr = b . pop ( 0 ) <NEWLINE> <DEDENT> if ptr == <STRING> : <NEWLINE> <INDENT> if c == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> ptr = c . pop ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> dices = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list = [ ] <NEWLINE> check = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> check += dices [ i ] <NEWLINE> <DEDENT> list . append ( check ) <NEWLINE> for j in range ( N - K ) : <NEWLINE> <INDENT> check -= dices [ j ] <NEWLINE> check += dices [ j + K ] <NEWLINE> list . append ( check ) <NEWLINE> <DEDENT> print ( ( max ( list ) + K ) / 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <INDENT> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n , k = nums [ 0 ] , nums [ 1 ] <NEWLINE> graph = { } <NEWLINE> out = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> graph [ i + 1 ] = out [ i ] <NEWLINE> <NL> <DEDENT> cycle_length = None <NEWLINE> visited = { } <NEWLINE> ans = None <NEWLINE> <NL> def go ( x , rem ) : <NEWLINE> <INDENT> while rem : <NEWLINE> <INDENT> x = graph [ x ] <NEWLINE> rem -= 1 <NEWLINE> <NL> <DEDENT> nonlocal ans <NEWLINE> ans = x <NEWLINE> return x <NEWLINE> <NL> <DEDENT> def dfs ( i , rem ) : <NEWLINE> <INDENT> j = i <NEWLINE> while rem : <NEWLINE> <INDENT> if j in visited : <NEWLINE> <INDENT> nonlocal cycle_length <NEWLINE> cycle_length = visited [ j ] - rem <NEWLINE> steps = rem % cycle_length <NEWLINE> go ( j , steps ) <NEWLINE> return <NEWLINE> <DEDENT> visited [ j ] = rem <NEWLINE> rem -= 1 <NEWLINE> j = graph [ j ] <NEWLINE> <NL> <DEDENT> nonlocal ans <NEWLINE> if not ans : <NEWLINE> <INDENT> ans = j <NEWLINE> <DEDENT> return j <NEWLINE> <NL> <DEDENT> dfs ( 1 , k ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> <COMMENT> <NL> import sys <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <COMMENT> <NL> <INDENT> H , W = map ( int , line . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> print ( <STRING> * W ) <NEWLINE> for a in range ( H - 2 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> @ njit ( cache = True ) <NEWLINE> def loop ( n , k , A ) : <NEWLINE> <INDENT> for _ in [ 0 ] * k : <NEWLINE> <INDENT> B = np . zeros ( n + 1 , dtype = np . int64 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> left = max ( 0 , i - A [ i ] ) <NEWLINE> right = min ( n , i + A [ i ] + 1 ) <NEWLINE> B [ left ] += 1 <NEWLINE> B [ right ] -= 1 <NEWLINE> <DEDENT> A = np . cumsum ( B ) [ : - 1 ] <NEWLINE> <COMMENT> <NL> if np . all ( A == n ) : <NEWLINE> <INDENT> return A <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> return A <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = np . array ( a , dtype = np . int64 ) <NEWLINE> A = loop ( n , k , A ) <NEWLINE> print ( * A ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> dn = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> tn = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num_dict = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if str ( dn [ i ] ) in num_dict . keys ( ) : <NEWLINE> <INDENT> num_dict [ str ( dn [ i ] ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num_dict [ str ( dn [ i ] ) ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if str ( tn [ i ] ) in num_dict . keys ( ) : <NEWLINE> <INDENT> num_dict [ str ( tn [ i ] ) ] += - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> result_list = list ( num_dict . values ( ) ) <NEWLINE> for i in range ( len ( result_list ) ) : <NEWLINE> <INDENT> if result_list [ i ] < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( ) <NEWLINE> G = [ 1 ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def insertion_sort ( A , n , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def shell_sort ( ) : <NEWLINE> <INDENT> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> h = 3 * G [ 0 ] + 1 <NEWLINE> if h > n : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> G . insert ( 0 , h ) <NEWLINE> <DEDENT> <DEDENT> for g in G : <NEWLINE> <INDENT> insertion_sort ( A , n , g ) <NEWLINE> <NL> <DEDENT> <DEDENT> shell_sort ( ) <NEWLINE> print ( len ( G ) ) <NEWLINE> print ( <STRING> . join ( str ( x ) for x in G ) ) <NEWLINE> print ( cnt ) <NEWLINE> print ( <STRING> . join ( str ( x ) for x in A ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> play_day = a - sum ( C ) <NEWLINE> if play_day >= 0 : <NEWLINE> <INDENT> print ( play_day ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if ( a [ i ] == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> c *= a [ i ] <NEWLINE> if ( c > ( 10 ** 18 ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <NL> <NL> <NL>
from heapq import heappush , heappop <NEWLINE> INF = 10 ** 20 <NEWLINE> <NL> def search ( item_lst , d ) : <NEWLINE> <INDENT> visited = { } <NEWLINE> visited [ ( 0 , 0 ) ] = True <NEWLINE> que = [ ] <NEWLINE> heappush ( que , ( 0 , 0 , 0 ) ) <NEWLINE> while que : <NEWLINE> <INDENT> score , a , e = heappop ( que ) <NEWLINE> for da , de in item_lst [ e ] : <NEWLINE> <INDENT> na = a + da <NEWLINE> if na >= d : <NEWLINE> <INDENT> print ( score + 1 ) <NEWLINE> return True <NEWLINE> <DEDENT> ne = e + de <NEWLINE> if ne > 100 : <NEWLINE> <INDENT> ne = 100 <NEWLINE> <NL> <DEDENT> if ( na , ne ) not in visited : <NEWLINE> <INDENT> visited [ ( na , ne ) ] = True <NEWLINE> heappush ( que , ( score + 1 , na , ne ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> return False <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> d , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if d == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> item_lst = [ [ ] for _ in range ( 101 ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , e , r = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( r , 101 ) : <NEWLINE> <INDENT> item_lst [ i ] . append ( ( a , e ) ) <NEWLINE> <DEDENT> <DEDENT> search ( item_lst , d ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
from math import ceil <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ceil ( n / i ) - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
hyou = [ 0 ] * 100001 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a_data = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> b_data = [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( Q ) ] <NEWLINE> <NL> <COMMENT> <NL> for x in a_data : <NEWLINE> <INDENT> hyou [ x ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> total = 0 <NEWLINE> for i , x in enumerate ( hyou ) : <NEWLINE> <INDENT> total += i * x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for before_value , after_value in b_data : <NEWLINE> <INDENT> total += ( after_value - before_value ) * hyou [ before_value ] <NEWLINE> <COMMENT> <NL> hyou [ after_value ] = hyou [ before_value ] + hyou [ after_value ] <NEWLINE> hyou [ before_value ] = 0 <NEWLINE> <NL> <COMMENT> <NL> print ( total ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> d = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> com = input ( ) . split ( ) <NEWLINE> if com [ 0 ] == <STRING> : <NEWLINE> <INDENT> d . add ( com [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> if com [ 1 ] in d else <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
p = 10 ** 9 + 7 <NEWLINE> <NL> def modpow ( a , n , p ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> ans = a % p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n % 2 == 0 : <NEWLINE> <INDENT> ans = ( modpow ( a , n // 2 , p ) ** 2 ) % p <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> ans = ( a * ( modpow ( a , n // 2 , p ) ** 2 ) ) % p <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> Fact = [ [ 1 , 1 ] for _ in range ( 10 ** 5 + 1 ) ] <NEWLINE> for i in range ( 1 , 10 ** 5 + 1 ) : <NEWLINE> <INDENT> Fact [ i ] [ 0 ] = ( Fact [ i - 1 ] [ 0 ] * i ) % p <NEWLINE> Fact [ i ] [ 1 ] = modpow ( Fact [ i ] [ 0 ] , p - 2 , p ) <NEWLINE> <NL> <DEDENT> def C ( a , b , p , Fact ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = Fact [ a ] [ 0 ] * Fact [ b ] [ 1 ] * Fact [ a - b ] [ 1 ] % p <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> <DEDENT> N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> maxS = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> maxS = ( maxS + A [ i ] * C ( i , K - 1 , p , Fact ) ) % p <NEWLINE> <NL> <DEDENT> minS = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> minS = ( minS + A [ i ] * C ( N - i - 1 , K - 1 , p , Fact ) ) % p <NEWLINE> <NL> <DEDENT> ans = ( maxS - minS ) % p <NEWLINE> <NL> print ( ans ) <NEWLINE>
import functools <NEWLINE> import operator <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> v = sum ( A ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> v -= A [ i ] <NEWLINE> ans += A [ i ] * v <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> from math import factorial <NEWLINE> <NL> <COMMENT> <NL> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if k > N - K + 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> c1 = factorial ( K - 1 ) // ( factorial ( K - k ) * factorial ( k - 1 ) ) <NEWLINE> c1 = int ( c1 ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> c2 = factorial ( N - K + 1 ) // ( factorial ( N - K - k + 1 ) * factorial ( k ) ) <NEWLINE> c2 = int ( c2 ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> ans = c1 * c2 % ( 10 ** 9 + 7 ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> f_xyz = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if f_xyz in dic : <NEWLINE> <INDENT> dic [ f_xyz ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ f_xyz ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i in dic : <NEWLINE> <INDENT> print ( dic [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> dp = [ 0 ] * n <NEWLINE> <NL> for i in alist : <NEWLINE> <INDENT> dp [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in dp : <NEWLINE> <INDENT> print ( int ( i ) ) <NEWLINE> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> if abs ( B - A ) <= ( V - W ) * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ [ ] for _ in range ( N ) ] <NEWLINE> ans = [ 0 ] * N <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> AB [ a - 1 ] . append ( b - 1 ) <NEWLINE> AB [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> <NL> node = 0 <NEWLINE> q = deque ( [ 0 ] ) <NEWLINE> <NL> check = [ 0 ] * N <NEWLINE> check [ 0 ] = 1 <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> node = q . popleft ( ) <NEWLINE> for i in AB [ node ] : <NEWLINE> <INDENT> if check [ i ] == 0 : <NEWLINE> <INDENT> q . append ( i ) <NEWLINE> check [ i ] = 1 <NEWLINE> ans [ i ] = node <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( ans [ i ] + 1 ) <NEWLINE> <DEDENT>
import math <NEWLINE> import collections <NEWLINE> import fractions <NEWLINE> import itertools <NEWLINE> import functools <NEWLINE> import operator <NEWLINE> import bisect <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ruia , ruib = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : ruia . append ( a [ i ] + ruia [ i ] ) <NEWLINE> for i in range ( m ) : ruib . append ( b [ i ] + ruib [ i ] ) <NEWLINE> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if ruia [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while ( ruib [ j ] > k - ruia [ i ] ) : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> <STRING> <NEWLINE> tot = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] %= mod <NEWLINE> tot += A [ i ] <NEWLINE> tot %= mod <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> tot -= A [ i ] <NEWLINE> ans += ( A [ i ] * tot ) % mod <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from functools import reduce <NEWLINE> import math <NEWLINE> def xgcd ( a , b ) : <NEWLINE> <INDENT> x0 , y0 , x1 , y1 = 1 , 0 , 0 , 1 <NEWLINE> while b != 0 : <NEWLINE> <INDENT> q , a , b = a // b , b , a % b <NEWLINE> x0 , x1 = x1 , x0 - q * x1 <NEWLINE> y0 , y1 = y1 , y0 - q * y1 <NEWLINE> <DEDENT> return a , x0 , y0 <NEWLINE> <DEDENT> def modinv ( a , m ) : <NEWLINE> <INDENT> g , x , y = xgcd ( a , m ) <NEWLINE> return x % m <NEWLINE> <DEDENT> def modmul ( a , b ) : <NEWLINE> <INDENT> return a * b % 998244353 <NEWLINE> <DEDENT> def comb ( n , r , m ) : <NEWLINE> <INDENT> if r == 0 : return 1 <NEWLINE> return memf [ n ] * pow ( memf [ r ] , m - 2 , m ) * pow ( memf [ n - r ] , m - 2 , m ) <NEWLINE> <DEDENT> def mempow ( a , b ) : <NEWLINE> <INDENT> temp = 1 <NEWLINE> yield temp <NEWLINE> for i in range ( b ) : <NEWLINE> <INDENT> temp = temp * a % 998244353 <NEWLINE> yield temp <NEWLINE> <DEDENT> <DEDENT> def memfact ( a ) : <NEWLINE> <INDENT> temp = 1 <NEWLINE> yield temp <NEWLINE> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> temp = temp * i % 998244353 <NEWLINE> yield temp <NEWLINE> <NL> <DEDENT> <DEDENT> N , M , K = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> memp = [ ] <NEWLINE> memf = [ ] <NEWLINE> mpappend = memp . append <NEWLINE> mfappend = memf . append <NEWLINE> for x in mempow ( M - 1 , N - 1 ) : <NEWLINE> <INDENT> mpappend ( x ) <NEWLINE> <DEDENT> for x in memfact ( N - 1 ) : <NEWLINE> <INDENT> mfappend ( x ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> if M == 1 : <NEWLINE> <INDENT> if K + 1 < N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> ans = ( ans + ( comb ( N - 1 , i , 998244353 ) * M * memp [ N - i - 1 ] ) ) % 998244353 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = a [ 0 ] <NEWLINE> <NL> <NL> if 0 in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> sum = sum * a [ i ] <NEWLINE> if sum > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <NL>
<COMMENT> <NL> <COMMENT> <NL> <NL> from sys import setrecursionlimit <NEWLINE> <NL> setrecursionlimit ( 21 ) <NEWLINE> <NL> <NL> class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , parent = - 1 , child = [ ] ) : <NEWLINE> <INDENT> self . parent = parent <NEWLINE> self . child = child <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def node_depth ( u , id ) : <NEWLINE> <INDENT> if u [ id ] . parent == - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return node_depth ( u , u [ id ] . parent ) + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def node_type ( u , id ) : <NEWLINE> <INDENT> if u [ id ] . parent == - 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif u [ id ] . child == [ ] : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> u = [ Node ( ) for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> id , _ , * child = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> u [ id ] . child = child <NEWLINE> for c in child : <NEWLINE> <INDENT> u [ c ] . parent = id <NEWLINE> <NL> <DEDENT> <DEDENT> for id in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . <NEWLINE> <INDENT> format ( id , u [ id ] . parent , <NEWLINE> <INDENT> node_depth ( u , id ) , node_type ( u , id ) , <NEWLINE> u [ id ] . child ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sq = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> sq *= A [ i ] <NEWLINE> <NL> if sq > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sq ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> import sys <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> import functools <NEWLINE> import itertools <NEWLINE> from collections import deque <NEWLINE> <NL> s = deque ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> n = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> flag = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> q = [ x for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> if len ( q ) == 1 : <NEWLINE> <INDENT> flag = 1 - flag <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( q [ 1 ] == <STRING> and flag == 0 ) or ( q [ 1 ] == <STRING> and flag == 1 ) : <NEWLINE> <INDENT> s . appendleft ( q [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( q [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> s = <STRING> . join ( s ) [ : : - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = <STRING> . join ( s ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> ans = - 1 <NEWLINE> t = [ 0 ] * ( m + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> for lnd , l in enumerate ( a [ j ] ) : <NEWLINE> <INDENT> t [ lnd ] += l <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans == - 1 or ans > t [ 0 ] : <NEWLINE> <INDENT> if min ( t [ 1 : m + 1 ] ) >= x : <NEWLINE> <INDENT> ans = t [ 0 ] <NEWLINE> <DEDENT> <DEDENT> t = [ 0 ] * ( m + 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> A = 0 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( K ) : <NEWLINE> <INDENT> A += i + 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> if i > j : <NEWLINE> <INDENT> A += 6 * math . gcd ( i + 1 , j + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> for k in range ( K ) : <NEWLINE> <INDENT> if i > j and j > k : <NEWLINE> <INDENT> A += 6 * math . gcd ( math . gcd ( i + 1 , j + 1 ) , k + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( A ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> import math <NEWLINE> if k == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s1 = k * ( k + 1 ) // 2 <NEWLINE> s2 = k - 1 <NEWLINE> for i in range ( 2 , k ) : <NEWLINE> <INDENT> for j in range ( i + 1 , k + 1 ) : <NEWLINE> <INDENT> s2 += math . gcd ( i , j ) <NEWLINE> <DEDENT> <DEDENT> s2 = s2 * 6 <NEWLINE> s3 = 0 <NEWLINE> if k > 2 : <NEWLINE> <INDENT> for a in range ( 1 , k - 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , k ) : <NEWLINE> <INDENT> for c in range ( b + 1 , k + 1 ) : <NEWLINE> <INDENT> s3 += math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> s3 = s3 * 6 <NEWLINE> <DEDENT> print ( s1 + s2 + s3 ) <NEWLINE> <DEDENT>
A , B , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> price_list = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> x , y , c = map ( int , input ( ) . split ( ) ) <NEWLINE> price = a [ x - 1 ] + b [ y - 1 ] - c <NEWLINE> price_list . append ( price ) <NEWLINE> <NL> <NL> <DEDENT> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> price_list . append ( a [ 0 ] + b [ 0 ] ) <NEWLINE> min_price = price_list [ 0 ] <NEWLINE> <NL> for n in price_list : <NEWLINE> <INDENT> if min_price >= n : <NEWLINE> <INDENT> min_price = n <NEWLINE> <DEDENT> elif min_price < n : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( min_price ) <NEWLINE>
S = [ ] <NEWLINE> T = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = input ( ) . split ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> S . append ( s [ i ] ) <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> t = input ( ) . split ( ) <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> T . append ( t [ j ] ) <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if T [ i ] == S [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = [ str ( c ) for c in s ] <NEWLINE> ans = 0 <NEWLINE> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> er = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> ans = ans + g * b <NEWLINE> <DEDENT> elif a [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> ans = ans + r * b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> ans = ans + g * r <NEWLINE> <DEDENT> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k < n : <NEWLINE> <INDENT> if a [ i ] != a [ j ] and a [ j ] != a [ k ] and a [ k ] != a [ i ] : <NEWLINE> <INDENT> er += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans - er ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> if a < b < c : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> <NL> <NL> k = int ( input ( ) ) <NEWLINE> sum_c = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum_c += gcd ( gcd ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum_c ) <NEWLINE>
li1 = [ ] <NEWLINE> li2 = [ ] <NEWLINE> for i , s in enumerate ( input ( ) ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> li1 . append ( i ) <NEWLINE> <DEDENT> elif s == <STRING> and li1 : <NEWLINE> <INDENT> j = li1 . pop ( ) <NEWLINE> c = i - j <NEWLINE> while li2 and li2 [ - 1 ] [ 0 ] > j : <NEWLINE> <INDENT> c += li2 [ - 1 ] [ 1 ] <NEWLINE> li2 . pop ( ) <NEWLINE> <DEDENT> li2 . append ( ( j , c ) ) <NEWLINE> <DEDENT> <DEDENT> if li2 : <NEWLINE> <INDENT> li3 = list ( zip ( * li2 ) ) [ 1 ] <NEWLINE> print ( sum ( li3 ) ) <NEWLINE> print ( len ( li3 ) , * li3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 , sep = <STRING> ) <NEWLINE> <NL> <DEDENT>
a = input ( ) <NEWLINE> if a [ 0 ] == <STRING> or a [ 1 ] == <STRING> or a [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> Sl = len ( S ) <NEWLINE> if Sl <= K : <NEWLINE> <INDENT> ans = S <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> newS = S [ 0 : K ] <NEWLINE> ans = ( newS + <STRING> ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <COMMENT> <NL> int1 = lambda x : int ( x ) - 1 <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> <NL> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MI1 ( ) : return map ( int1 , input ( ) . split ( ) ) <NEWLINE> <NL> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LI1 ( ) : return list ( map ( int1 , input ( ) . split ( ) ) ) <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> def printlist ( lst , k = <STRING> ) : print ( k . join ( list ( map ( str , lst ) ) ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n = II ( ) <NEWLINE> A = LI ( ) <NEWLINE> <NL> memo = { } <NEWLINE> ans = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> sa = j - A [ j ] <NEWLINE> ans += memo . get ( sa , 0 ) <NEWLINE> wa = j + A [ j ] <NEWLINE> memo [ wa ] = memo . get ( wa , 0 ) + 1 <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
<NL> <NL> <NL> a , b , c , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> price = a * x + b * y <NEWLINE> <NL> <NL> for i in range ( max ( x , y ) + 1 ) : <NEWLINE> <INDENT> ab = 2 * i <NEWLINE> cand = ab * c + a * max ( 0 , x - i ) + b * max ( 0 , y - i ) <NEWLINE> <NL> price = min ( price , cand ) <NEWLINE> <NL> <DEDENT> print ( price ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> L1 , L2 = [ ] , [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L1 . append ( l [ 0 ] - l [ 1 ] ) <NEWLINE> L2 . append ( l [ 0 ] + l [ 1 ] ) <NEWLINE> <NL> <DEDENT> ans = max ( max ( L1 ) - min ( L1 ) , max ( L2 ) - min ( L2 ) ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> stdin = sys . stdin <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> MIN = - 10 ** 9 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> IINF = 10 ** 18 <NEWLINE> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> x = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> p = factorization ( x ) <NEWLINE> num = [ ] <NEWLINE> if x == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in p : <NEWLINE> <INDENT> for j in range ( i [ 1 ] ) : <NEWLINE> <INDENT> if x % ( i [ 0 ] ** ( j + 1 ) ) == 0 : <NEWLINE> <INDENT> num . append ( i [ 0 ] ** ( j + 1 ) ) <NEWLINE> x = x / ( i [ 0 ] ** ( j + 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( num ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
def multiplyList ( myList ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> result = 1 <NEWLINE> for x in myList : <NEWLINE> <INDENT> result = result * x <NEWLINE> if result == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if result > 10 ** 18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> res = multiplyList ( l ) <NEWLINE> print ( res ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <COMMENT> <NEWLINE> Ken_n , City_n = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> city = { i : [ ] for i in range ( 1 , Ken_n + 1 ) } <NEWLINE> for i in range ( 1 , City_n + 1 ) : <NEWLINE> <INDENT> p , y = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> city [ p ] . append ( ( y , i ) ) <NEWLINE> <NL> <DEDENT> city_ID = { i : 0 for i in range ( 1 , City_n + 1 ) } <NEWLINE> for i in range ( 1 , Ken_n + 1 ) : <NEWLINE> <INDENT> city [ i ] . sort ( ) <NEWLINE> <NL> for j in range ( len ( city [ i ] ) ) : <NEWLINE> <INDENT> city_ID [ city [ i ] [ j ] [ 1 ] ] = <STRING> . format ( i ) + <STRING> . format ( j + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , City_n + 1 ) : <NEWLINE> <INDENT> print ( city_ID [ i ] ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> s = input ( ) <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if i < len ( s ) - 1 and s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> print ( i + 1 , i + 2 ) <NEWLINE> break <NEWLINE> <DEDENT> elif i < len ( s ) - 2 and s [ i ] == s [ i + 2 ] : <NEWLINE> <INDENT> print ( i + 1 , i + 3 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 , - 1 ) <NEWLINE> <DEDENT>
H , W , N = map ( int , input ( ) . split ( ) ) <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> h -= 1 <NEWLINE> w -= 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if w - 1 < W - w - 1 : <NEWLINE> <INDENT> w -= 1 <NEWLINE> <DEDENT> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> if w > W - w - 2 : <NEWLINE> <INDENT> w += 1 <NEWLINE> <DEDENT> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> if h - 1 < H - h - 1 : <NEWLINE> <INDENT> h -= 1 <NEWLINE> <DEDENT> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> if h > H - h - 2 : <NEWLINE> <INDENT> h += 1 <NEWLINE> <DEDENT> <DEDENT> if w == 0 or h == 0 or h == H or w == W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> if w - 1 > W - w - 1 : <NEWLINE> <INDENT> w -= 1 <NEWLINE> <DEDENT> <DEDENT> elif T [ i ] == <STRING> : <NEWLINE> <INDENT> if w < W - w - 2 : <NEWLINE> <INDENT> w += 1 <NEWLINE> <DEDENT> <DEDENT> elif T [ i ] == <STRING> : <NEWLINE> <INDENT> if h - 1 > H - h - 1 : <NEWLINE> <INDENT> h -= 1 <NEWLINE> <DEDENT> <DEDENT> elif T [ i ] == <STRING> : <NEWLINE> <INDENT> if h < H - h - 2 : <NEWLINE> <INDENT> h += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> o = [ a [ i ] for i in range ( 2 , n , 2 ) ] <NEWLINE> e = [ a [ h ] for h in range ( 1 , n , 2 ) ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> e . reverse ( ) <NEWLINE> l = e + [ a [ 0 ] ] + o <NEWLINE> print ( * l ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> o . reverse ( ) <NEWLINE> l = o + [ a [ 0 ] ] + e <NEWLINE> print ( * l ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> x = 1 <NEWLINE> <NL> while x <= N : <NEWLINE> <INDENT> x *= 2 <NEWLINE> <NL> <NL> <DEDENT> print ( x // 2 ) <NEWLINE> <NL> <NL>
import itertools as itr <NEWLINE> <NL> a = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> sum_list = list ( itr . accumulate ( p ) ) <NEWLINE> for i in range ( len ( p ) - 1 ) : <NEWLINE> <INDENT> o = p [ i + 1 ] <NEWLINE> w = sum_list [ i ] <NEWLINE> ans = ( ans + o * w % mod ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
R = [ int ( input ( ) ) for i in range ( int ( input ( ) ) ) ] <NEWLINE> maxp = R [ 1 ] - R [ 0 ] <NEWLINE> minv = R [ 0 ] <NEWLINE> for r in R [ 1 : ] : <NEWLINE> <INDENT> maxp = max ( maxp , r - minv ) <NEWLINE> minv = min ( minv , r ) <NEWLINE> <DEDENT> print ( maxp ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> if A [ i ] < A [ i + K ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import copy <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> R = set ( ) <NEWLINE> G = set ( ) <NEWLINE> B = set ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R . add ( i ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> G . add ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . add ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = len ( R ) * len ( G ) * len ( B ) <NEWLINE> <NL> for r in R : <NEWLINE> <INDENT> for g in G : <NEWLINE> <INDENT> L = g - r <NEWLINE> if g + L in B : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if r - L in B : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if L % 2 == 0 and L // 2 + r in B : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> d = collections . Counter ( l ) <NEWLINE> ans = 0 <NEWLINE> for v in d . values ( ) : <NEWLINE> <INDENT> if v % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> from sys import stdin <NEWLINE> from operator import itemgetter <NEWLINE> from collections import deque , Counter <NEWLINE> import math <NEWLINE> import pprint <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> import random <NEWLINE> import bisect <NEWLINE> import copy <NEWLINE> <COMMENT> <NL> <NL> <NL> MOD = 1000000007 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> alpha = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> def keta ( kazu ) : <COMMENT> <NEWLINE> <INDENT> kazu_str = str ( kazu ) <NEWLINE> kazu_list = [ int ( kazu_str [ i ] ) for i in range ( 0 , len ( kazu_str ) ) ] <NEWLINE> return kazu_list <NEWLINE> <NL> <DEDENT> def gcd ( * numbers ) : <COMMENT> <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> def combination ( m , n ) : <COMMENT> <NEWLINE> <NL> <INDENT> if n > m : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return math . factorial ( m ) // ( math . factorial ( m - n ) * math . factorial ( n ) ) <NEWLINE> <NL> <DEDENT> def pow_k ( x , n ) : <COMMENT> <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> K = 1 <NEWLINE> while n > 1 : <NEWLINE> <INDENT> if n % 2 != 0 : <NEWLINE> <INDENT> K *= x <NEWLINE> <DEDENT> x *= x <NEWLINE> n //= 2 <NEWLINE> <DEDENT> return K * x <NEWLINE> <NL> <DEDENT> def fact ( n ) : <COMMENT> <NEWLINE> <INDENT> arr = { } <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr [ i ] = cnt <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr [ temp ] = 1 <NEWLINE> <DEDENT> if arr == { } : <NEWLINE> <INDENT> arr [ n ] = 1 <NEWLINE> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> K = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> L = 0 <NEWLINE> amari = 10 <NEWLINE> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if K % 7 == 0 : <NEWLINE> <INDENT> L = 9 * K // 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = 9 * K <NEWLINE> <DEDENT> for i in range ( 1 , 1000000 ) : <NEWLINE> <INDENT> if amari % L == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> amari = ( amari % L ) * 10 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ct = Counter ( As ) <NEWLINE> As = sorted ( As ) <NEWLINE> max_dp = As [ - 1 ] + 1 <NEWLINE> dp = [ True ] * max_dp <NEWLINE> for key , count in ct . items ( ) : <NEWLINE> <INDENT> if count > 1 : <NEWLINE> <INDENT> dp [ key ] = False <NEWLINE> i = 2 <NEWLINE> while key * i < max_dp : <NEWLINE> <INDENT> dp [ key * i ] = False <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for A in As : <NEWLINE> <INDENT> if dp [ A ] == True : <NEWLINE> <INDENT> i = 2 <NEWLINE> while A * i < max_dp : <NEWLINE> <INDENT> dp [ A * i ] = False <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for A in As : <NEWLINE> <COMMENT> <NL> <INDENT> if dp [ A ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> <STRING> <NEWLINE> import math <NEWLINE> C = 10 ** 6 <NEWLINE> N = int ( input ( ) ) <NEWLINE> judge = [ False ] * ( C + 1 ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> f = True <NEWLINE> for a in A : <NEWLINE> <INDENT> if judge [ a ] == True and a != 1 : <NEWLINE> <INDENT> f = False <NEWLINE> <DEDENT> judge [ int ( a ) ] = True <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def solve ( f ) : <NEWLINE> <NL> <INDENT> ans = A [ 0 ] <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans = math . gcd ( ans , A [ i ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> if ans != 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> flag = True <NEWLINE> <COMMENT> <NL> for i in range ( 2 , C + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> <COMMENT> <NL> for j in range ( i , C + 1 , i ) : <NEWLINE> <INDENT> if judge [ j ] == True : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if count == 2 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if not flag : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == True and f == True : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> print ( solve ( f ) ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = 7 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if b % a == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> b = 10 * b % a + 7 <NEWLINE> if i == a - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> ran = list ( range ( 400 , 2200 , 200 ) ) <NEWLINE> pointer = 0 <NEWLINE> while x >= ran [ pointer ] : <NEWLINE> <INDENT> pointer += 1 <NEWLINE> <DEDENT> print ( 9 - pointer ) <NEWLINE>
n , m , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> import itertools <NEWLINE> anses = [ ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> def f ( A ) : <NEWLINE> <INDENT> for ai in range ( A [ - 1 ] , m + 1 ) : <NEWLINE> <INDENT> if len ( A ) < n : <NEWLINE> <INDENT> f ( A + [ ai ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = 0 <NEWLINE> for a , b , c , d in abcd : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> if A [ b ] - A [ a ] == c : <NEWLINE> <INDENT> p += d <NEWLINE> <DEDENT> <DEDENT> anses . append ( p ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> f ( [ 1 ] ) <NEWLINE> print ( max ( anses ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> <NL> cnt = 0 <NEWLINE> if k > 6 : <NEWLINE> <INDENT> for i in range ( 7 , k ) : <NEWLINE> <INDENT> for j in range ( 1 , k ) : <NEWLINE> <NL> <NL> <INDENT> if i * j < k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt + k - 1 + ( ( k - 1 ) // 2 ) + ( ( k - 1 ) // 3 ) + ( ( k - 1 ) // 4 ) + ( ( k - 1 ) // 5 ) + ( ( k - 1 ) // 6 ) ) <NEWLINE>
dxdy = ( ( 0 , 1 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( - 1 , 0 ) ) <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> <NL> S . append ( <STRING> * ( W + 2 ) ) <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> S . append ( <STRING> + s + <STRING> ) <NEWLINE> <DEDENT> S . append ( <STRING> * ( W + 2 ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> for h in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for w in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if S [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ok = False <NEWLINE> for dx , dy in dxdy : <NEWLINE> <INDENT> if S [ h + dx ] [ w + dy ] == <STRING> : <NEWLINE> <INDENT> ok = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ok == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def mergeSort ( A , left , right , n ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = int ( ( right + left ) / 2 ) <NEWLINE> mergeSort ( A , left , mid , n ) <NEWLINE> mergeSort ( A , mid , right , n ) <NEWLINE> return ( merge ( A , left , mid , right , n ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def merge ( A , left , mid , right , n ) : <NEWLINE> <INDENT> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> L = A [ left : mid ] + [ 10 ** 9 + 1 ] <NEWLINE> R = A [ mid : right ] + [ 10 ** 9 + 1 ] <NEWLINE> L . append ( 1000000001 ) <NEWLINE> R . append ( 1000000001 ) <NEWLINE> i = j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> A [ n ] += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> key = L [ i ] <NEWLINE> A [ k ] = key <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> key = R [ j ] <NEWLINE> A [ k ] = key <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> return A <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . append ( 0 ) <NEWLINE> S = mergeSort ( A , 0 , len ( A ) - 1 , n ) <NEWLINE> print ( <STRING> . join ( list ( map ( str , S [ : n ] ) ) ) ) <NEWLINE> print ( S [ n ] ) <NEWLINE>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> for m in range ( N ) : <NEWLINE> <INDENT> A . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> ans = 10 ** 10 <NEWLINE> import numpy as np <NEWLINE> from itertools import product , compress <NEWLINE> for i in list ( product ( [ True , False ] , repeat = N ) ) : <NEWLINE> <INDENT> tmp = np . sum ( list ( compress ( A , i ) ) , axis = 0 ) <NEWLINE> if type ( tmp ) != np . float64 : <NEWLINE> <INDENT> if tmp [ 0 ] < ans and min ( tmp [ 1 : ] ) >= X : <NEWLINE> <INDENT> ans = tmp [ 0 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans == 10 ** 10 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A_temp = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> B_temp = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> A , B = [ 0 ] * ( N + 1 ) , [ 0 ] * ( M + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> A [ i ] = A [ i - 1 ] + A_temp [ i - 1 ] <NEWLINE> <NL> <DEDENT> for j in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> B [ j ] = B [ j - 1 ] + B_temp [ j - 1 ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for a in range ( N + 1 ) : <NEWLINE> <INDENT> if A [ a ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for b in range ( ans - a + 1 , M + 1 ) : <NEWLINE> <INDENT> if A [ a ] + B [ b ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = max ( ans , a + b ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import copy <NEWLINE> <NL> <NL> def parse_stdin ( input_lines : int ) : <NEWLINE> <INDENT> data_list = [ ] <NEWLINE> for i in range ( input_lines ) : <NEWLINE> <INDENT> data_list . append ( input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <DEDENT> return data_list <NEWLINE> <NL> <NL> <DEDENT> def insertion_sort_with_print ( values ) : <NEWLINE> <INDENT> print_now_state ( values ) <NEWLINE> for i , value in enumerate ( values [ 1 : ] ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and values [ j ] > value : <NEWLINE> <INDENT> values [ j + 1 ] = copy . copy ( values [ j ] ) <NEWLINE> j -= 1 <NEWLINE> <DEDENT> values [ j + 1 ] = copy . copy ( value ) <NEWLINE> print_now_state ( values ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def print_now_state ( values ) : <NEWLINE> <INDENT> for val_print in values [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> . format ( val_print ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> . format ( values [ - 1 ] ) , end = <STRING> ) <NEWLINE> print ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> input ( ) <NEWLINE> input_lists = parse_stdin ( 1 ) <NEWLINE> values = list ( map ( int , input_lists [ 0 ] ) ) <NEWLINE> insertion_sort_with_print ( values ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> shelfA = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> shelfB = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> prodA = [ 0 ] * ( n + 1 ) <NEWLINE> prodB = [ 0 ] * ( m + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> prodA [ i ] = prodA [ i - 1 ] + shelfA [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> prodB [ i ] = prodB [ i - 1 ] + shelfB [ i - 1 ] <NEWLINE> <NL> <DEDENT> ans = - 1 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if ( prodA [ i ] > k ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while ( prodB [ j ] > k - prodA [ i ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> j -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , R = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N <= 10 : <NEWLINE> <INDENT> print ( 100 * ( 10 - N ) + R ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( R ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> z = n * m // gcd ( n , m ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> n = z // n <NEWLINE> m = z // m <NEWLINE> x = 0 <NEWLINE> y = 0 <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> while x < z and y < z : <NEWLINE> <INDENT> if x > y : <NEWLINE> <INDENT> y += m <NEWLINE> j += 1 <NEWLINE> <DEDENT> elif x < y : <NEWLINE> <INDENT> x += n <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] != t [ j ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> x += n <NEWLINE> y += m <NEWLINE> i += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> print ( z ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> ans = 0 ; <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> p = input ( ) . split ( ) ; <NEWLINE> if len ( p ) == 1 : ms = [ ] <NEWLINE> else : ms = list ( p [ 1 ] ) <NEWLINE> s = 0 <NEWLINE> for m in ms : <NEWLINE> <INDENT> if m . isdigit ( ) : s += int ( m ) <NEWLINE> elif m . isupper ( ) : s += ord ( m ) - ord ( <STRING> ) + 10 <NEWLINE> else : s += ord ( m ) - ord ( <STRING> ) + 36 <NEWLINE> <DEDENT> ans ^= s <NEWLINE> <DEDENT> print ( <STRING> if ans else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> if 0 in A : <NEWLINE> <INDENT> sum = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum *= A [ i ] <NEWLINE> if sum > ( 10 ** 18 ) : <NEWLINE> <INDENT> sum = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( int ( sum ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> la = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sa = sum ( la ) <NEWLINE> l_cnt = [ 0 ] * 100001 <NEWLINE> for i in la : <NEWLINE> <INDENT> l_cnt [ i ] += 1 <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> sa += ( c - b ) * l_cnt [ b ] <NEWLINE> print ( sa ) <NEWLINE> l_cnt [ c ] += l_cnt [ b ] <NEWLINE> l_cnt [ b ] = 0 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = 1 <NEWLINE> flag = False <NEWLINE> INF = 10 ** 18 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if flag == False : <NEWLINE> <INDENT> x *= a [ i ] <NEWLINE> <DEDENT> if x > INF : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT>
input ( ) <NEWLINE> numbers = input ( ) . split ( ) <NEWLINE> <COMMENT> <NL> r_numbers = reversed ( numbers ) <NEWLINE> <COMMENT> <NL> print ( <STRING> . join ( r_numbers ) ) <NEWLINE>
import sys <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> input = sys . stdin . readline <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> bom_list = [ ] <NEWLINE> h_list = [ 0 ] * h <NEWLINE> w_list = [ 0 ] * w <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> bom_list . append ( [ a - 1 , b - 1 ] ) <NEWLINE> h_list [ a - 1 ] += 1 <NEWLINE> w_list [ b - 1 ] += 1 <NEWLINE> <NL> <DEDENT> max_h = max ( h_list ) <NEWLINE> max_w = max ( w_list ) <NEWLINE> ans = max_h + max_w <NEWLINE> count = 0 <NEWLINE> <NL> for bom in bom_list : <NEWLINE> <INDENT> if h_list [ bom [ 0 ] ] == max_h and w_list [ bom [ 1 ] ] == max_w : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if h_list . count ( max_h ) * w_list . count ( max_w ) == count : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def f_knapsack_for_all_subsets_power_series ( MOD = 998244353 , MAX = 3010 ) : <NEWLINE> <COMMENT> <NL> <INDENT> import numpy as np <NEWLINE> N , S = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> f = np . zeros ( MAX + 1 , np . int64 ) <COMMENT> <NEWLINE> f [ 0 ] = 1 <COMMENT> <NEWLINE> for a in A : <NEWLINE> <COMMENT> <NL> <INDENT> f_next = 2 * f <COMMENT> <NEWLINE> f_next [ a : ] += f [ : - a ] <COMMENT> <NEWLINE> f_next %= MOD <NEWLINE> f = f_next <NEWLINE> <DEDENT> return f [ S ] <NEWLINE> <NL> <DEDENT> print ( f_knapsack_for_all_subsets_power_series ( ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> m = 0 <NEWLINE> if B <= N : <NEWLINE> <INDENT> m = int ( A * ( B - 1 ) / B ) <NEWLINE> print ( m ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> m = int ( A * N / B ) <NEWLINE> print ( m ) <NEWLINE> <DEDENT>
import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> <NL> for A in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for B in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if ( A ** 5 - B ** 5 == X ) : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 100 ) : <NEWLINE> <INDENT> if not ( ( x - i ) in p ) : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif not ( ( x + i ) in p ) : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> from collections import Counter <NEWLINE> def func ( x ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> y = x <NEWLINE> while x > 0 : <NEWLINE> <INDENT> if x % 2 == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> x //= 2 <NEWLINE> <DEDENT> return y % cnt <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> base_plus = 0 <NEWLINE> base_minus = 0 <NEWLINE> r = 1 <NEWLINE> one = Counter ( X ) [ 1 ] <NEWLINE> for x in X [ : : - 1 ] : <NEWLINE> <INDENT> base_plus += r * x <NEWLINE> base_plus %= one + 1 <NEWLINE> r *= 2 <NEWLINE> r %= one + 1 <NEWLINE> <DEDENT> r = 1 <NEWLINE> if one > 1 : <NEWLINE> <INDENT> for x in X [ : : - 1 ] : <NEWLINE> <INDENT> base_minus += r * x <NEWLINE> base_minus %= one - 1 <NEWLINE> r *= 2 <NEWLINE> r %= one - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ANS = [ 0 ] * N <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if one == 1 : <NEWLINE> <INDENT> if X [ i ] == 1 : <NEWLINE> <INDENT> ANS [ i ] = 0 <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> if X [ i ] == 1 : <NEWLINE> <INDENT> xi = ( base_minus - pow ( 2 , N - 1 - i , one - 1 ) ) % ( one - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> xi = ( base_plus + pow ( 2 , N - 1 - i , one + 1 ) ) % ( one + 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if xi == 0 : <NEWLINE> <INDENT> ANS [ i ] = 1 <NEWLINE> continue <NEWLINE> <DEDENT> ans = 1 <NEWLINE> while xi > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> xi = func ( xi ) <NEWLINE> <DEDENT> ANS [ i ] = ans <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , ANS ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> now = 1 <NEWLINE> check = [ - 1 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> if check [ now ] == - 1 : <NEWLINE> <INDENT> check [ now ] = i <NEWLINE> now = a [ now ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop = i - check [ now ] <NEWLINE> afterloop = ( k - ( i - loop ) ) % loop <NEWLINE> print ( check . index ( ( i - loop ) + afterloop ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( now ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> import bisect <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( readline ( ) . rstrip ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> k = 0 <NEWLINE> <NL> if A . count ( 1 ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] == k + 1 : <NEWLINE> <INDENT> k += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - k ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
( h , n ) , * m = [ [ * map ( int , i . split ( ) ) ] for i in open ( 0 ) ] <NEWLINE> dp = [ 0 ] * 20001 <NEWLINE> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + b for a , b in m ) <NEWLINE> <DEDENT> print ( dp [ h ] ) <NEWLINE>
<NL> from enum import Enum <NEWLINE> import math <NEWLINE> <NL> <NL> class Color ( Enum ) : <NEWLINE> <INDENT> BLACK = 0 <NEWLINE> RED = 1 <NEWLINE> <NL> @ staticmethod <NEWLINE> def flip ( c ) : <NEWLINE> <INDENT> return [ Color . RED , Color . BLACK ] [ c . value ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class RedBlackBinarySearchTree : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> __slots__ = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> <NL> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> self . count = 0 <NEWLINE> self . color = Color . RED <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> if self . color == Color . RED : <NEWLINE> <INDENT> key = <STRING> . format ( self . key ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> key = <STRING> . format ( self . key ) <NEWLINE> <DEDENT> return <STRING> . format ( key , self . count , <NEWLINE> <INDENT> self . left , self . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def put ( self , key ) : <NEWLINE> <INDENT> def _put ( node ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> node = self . Node ( key ) <NEWLINE> <DEDENT> if node . key > key : <NEWLINE> <INDENT> node . left = _put ( node . left ) <NEWLINE> <DEDENT> elif node . key < key : <NEWLINE> <INDENT> node . right = _put ( node . right ) <NEWLINE> <NL> <DEDENT> node = self . _restore ( node ) <NEWLINE> <NL> node . count = self . _size ( node . left ) + self . _size ( node . right ) + 1 <NEWLINE> return node <NEWLINE> <NL> <DEDENT> self . root = _put ( self . root ) <NEWLINE> self . root . color = Color . BLACK <NEWLINE> <NL> <DEDENT> def _is_red ( self , node ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return node . color == Color . RED <NEWLINE> <NL> <DEDENT> <DEDENT> def _is_black ( self , node ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return node . color == Color . BLACK <NEWLINE> <NL> <DEDENT> <DEDENT> def _is_2node ( self , node ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif self . _is_red ( node ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( self . _is_black ( node ) and <NEWLINE> <INDENT> not self . _is_red ( node . left ) and <NEWLINE> not self . _is_red ( node . right ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def _is_34node ( self , node ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif self . _is_red ( node ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( self . _is_black ( node ) and <NEWLINE> <INDENT> self . _is_red ( node . left ) and <NEWLINE> not self . _is_red ( node . right ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def _rotate_left ( self , node ) : <NEWLINE> <INDENT> x = node . right <NEWLINE> node . right = x . left <NEWLINE> x . left = node <NEWLINE> x . color = node . color <NEWLINE> node . color = Color . RED <NEWLINE> node . count = self . _size ( node . left ) + self . _size ( node . right ) + 1 <NEWLINE> return x <NEWLINE> <NL> <DEDENT> def _rotate_right ( self , node ) : <NEWLINE> <INDENT> x = node . left <NEWLINE> node . left = x . right <NEWLINE> x . right = node <NEWLINE> x . color = node . color <NEWLINE> node . color = Color . RED <NEWLINE> node . count = self . _size ( node . left ) + self . _size ( node . right ) + 1 <NEWLINE> return x <NEWLINE> <NL> <DEDENT> def _flip_colors ( self , node ) : <NEWLINE> <INDENT> node . color = Color . flip ( node . color ) <NEWLINE> node . left . color = Color . flip ( node . left . color ) <NEWLINE> node . right . color = Color . flip ( node . right . color ) <NEWLINE> return node <NEWLINE> <NL> <DEDENT> def __contains__ ( self , key ) : <NEWLINE> <INDENT> def _contains ( node ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if node . key > key : <NEWLINE> <INDENT> return _contains ( node . left ) <NEWLINE> <DEDENT> elif node . key < key : <NEWLINE> <INDENT> return _contains ( node . right ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return _contains ( self . root ) <NEWLINE> <NL> <DEDENT> def delete ( self , key ) : <NEWLINE> <INDENT> def _delete_from ( node ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> assert not self . _is_2node ( node ) <NEWLINE> <NL> if node . key > key : <NEWLINE> <INDENT> node = self . _convert_left ( node ) <NEWLINE> <COMMENT> <NL> node . left = _delete_from ( node . left ) <NEWLINE> node = self . _restore ( node ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif node . key < key : <NEWLINE> <INDENT> node = self . _convert_right ( node ) <NEWLINE> <COMMENT> <NL> node . right = _delete_from ( node . right ) <NEWLINE> node = self . _restore ( node ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> node = _remove ( node ) <NEWLINE> <NL> <DEDENT> <DEDENT> if node is not None : <NEWLINE> <INDENT> node . count = self . _size ( node . right ) + self . _size ( node . left ) + 1 <NEWLINE> <DEDENT> return node <NEWLINE> <NL> <DEDENT> def _remove ( node ) : <NEWLINE> <INDENT> if node . left is None : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> elif node . right is None : <NEWLINE> <INDENT> if self . _is_red ( node . left ) : <NEWLINE> <INDENT> node . left . color = Color . BLACK <NEWLINE> <DEDENT> return node . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node = self . _convert_right ( node ) <NEWLINE> if node . key == key : <NEWLINE> <INDENT> x = self . _find_min ( node . right ) <NEWLINE> node . key = x . key <NEWLINE> node . right = self . _delete_min ( node . right ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> node . right = _delete_from ( node . right ) <NEWLINE> <DEDENT> node = self . _restore ( node ) <NEWLINE> <COMMENT> <NL> return node <NEWLINE> <NL> <DEDENT> <DEDENT> if self . root is None : <NEWLINE> <INDENT> return <NEWLINE> <COMMENT> <NL> <DEDENT> if not self . _is_red ( self . root . left ) : <NEWLINE> <INDENT> self . root . color = Color . RED <NEWLINE> <DEDENT> self . root = _delete_from ( self . root ) <NEWLINE> if self . root is not None : <NEWLINE> <INDENT> self . root . color = Color . BLACK <NEWLINE> <NL> <DEDENT> <DEDENT> def delete_max ( self ) : <NEWLINE> <INDENT> if self . root is None : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> if self . root . left is None : <NEWLINE> <INDENT> self . root = None <NEWLINE> return <NEWLINE> <DEDENT> if not self . _is_red ( self . root . left ) : <NEWLINE> <INDENT> self . root . color = Color . RED <NEWLINE> <DEDENT> self . root = self . _delete_max ( self . root ) <NEWLINE> self . root . color = Color . BLACK <NEWLINE> <NL> <DEDENT> def _delete_max ( self , node ) : <NEWLINE> <INDENT> if node . right is None : <NEWLINE> <INDENT> if self . _is_red ( node . left ) : <NEWLINE> <INDENT> node . left . color = Color . BLACK <NEWLINE> <DEDENT> return node . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> assert not self . _is_2node ( node ) <NEWLINE> node = self . _convert_right ( node ) <NEWLINE> node . right = self . _delete_max ( node . right ) <NEWLINE> node = self . _restore ( node ) <NEWLINE> return node <NEWLINE> <NL> <DEDENT> <DEDENT> def _convert_right ( self , node ) : <NEWLINE> <INDENT> if self . _is_2node ( node . right ) : <NEWLINE> <INDENT> if self . _is_2node ( node . left ) : <NEWLINE> <INDENT> self . _flip_colors ( node ) <NEWLINE> <DEDENT> elif self . _is_red ( node . left ) and self . _is_2node ( node . left . right ) : <NEWLINE> <INDENT> node = self . _rotate_right ( node ) <NEWLINE> self . _flip_colors ( node . right ) <NEWLINE> <DEDENT> elif self . _is_red ( node . left ) : <NEWLINE> <INDENT> x = node . left . right <NEWLINE> node . left . right = x . left <NEWLINE> node . left , node . right , x . left , x . right = x . right , node . right . left , node . left , node . right <NEWLINE> x . right . left = node <NEWLINE> x . color = Color . BLACK <NEWLINE> node . color = Color . RED <NEWLINE> if self . _is_red ( x . left . right ) : <NEWLINE> <INDENT> x . left . right . color = Color . BLACK <NEWLINE> <DEDENT> node . count = ( self . _size ( node . left ) + <NEWLINE> <INDENT> self . _size ( node . right ) + 1 ) <NEWLINE> <DEDENT> x . left . count = ( self . _size ( x . left . left ) + <NEWLINE> <INDENT> self . _size ( x . left . right ) + 1 ) <NEWLINE> <DEDENT> node = x <NEWLINE> <DEDENT> elif self . _is_34node ( node . left ) : <NEWLINE> <INDENT> x = node . left <NEWLINE> node . left , node . right , x . right = x . right , node . right . left , node . right <NEWLINE> x . right . left = node <NEWLINE> x . color = node . color <NEWLINE> if self . _is_red ( x . left ) : <NEWLINE> <INDENT> x . left . color = Color . BLACK <NEWLINE> <DEDENT> if self . _is_black ( x . right . left ) : <NEWLINE> <INDENT> x . right . left . color = Color . RED <NEWLINE> <DEDENT> node . count = ( self . _size ( node . left ) + <NEWLINE> <INDENT> self . _size ( node . right ) + 1 ) <NEWLINE> <DEDENT> x . left . count = ( self . _size ( x . left . left ) + <NEWLINE> <INDENT> self . _size ( x . left . right ) + 1 ) <NEWLINE> <DEDENT> node = x <NEWLINE> <DEDENT> <DEDENT> return node <NEWLINE> <NL> <DEDENT> def delete_min ( self ) : <NEWLINE> <INDENT> if self . root is None : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> if self . root . left is None : <NEWLINE> <INDENT> self . root = None <NEWLINE> return <NEWLINE> <DEDENT> if not self . _is_red ( self . root . left ) : <NEWLINE> <INDENT> self . root . color = Color . RED <NEWLINE> <DEDENT> self . root = self . _delete_min ( self . root ) <NEWLINE> self . root . color = Color . BLACK <NEWLINE> <NL> <DEDENT> def _delete_min ( self , node ) : <NEWLINE> <INDENT> if node . left is None : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node = self . _convert_left ( node ) <NEWLINE> node . left = self . _delete_min ( node . left ) <NEWLINE> node = self . _restore ( node ) <NEWLINE> return node <NEWLINE> <NL> <DEDENT> <DEDENT> def _convert_left ( self , node ) : <NEWLINE> <INDENT> if self . _is_2node ( node . left ) : <NEWLINE> <INDENT> if self . _is_2node ( node . right ) : <NEWLINE> <INDENT> self . _flip_colors ( node ) <NEWLINE> <DEDENT> elif self . _is_34node ( node . right ) : <NEWLINE> <INDENT> x = node . right . left <NEWLINE> node . right . left = x . right <NEWLINE> x . left , x . right , node . right = node , node . right , x . left <NEWLINE> x . color = node . color <NEWLINE> node . color = Color . BLACK <NEWLINE> node . left . color = Color . RED <NEWLINE> x . right . count = ( self . _size ( x . right . left ) + <NEWLINE> <INDENT> self . _size ( x . right . right ) + 1 ) <NEWLINE> <DEDENT> node = x <NEWLINE> <DEDENT> <DEDENT> return node <NEWLINE> <NL> <DEDENT> def _restore ( self , node ) : <NEWLINE> <INDENT> if self . _is_red ( node . right ) and not self . _is_red ( node . left ) : <NEWLINE> <INDENT> node = self . _rotate_left ( node ) <NEWLINE> <DEDENT> if self . _is_red ( node . left ) and self . _is_red ( node . left . left ) : <NEWLINE> <INDENT> node = self . _rotate_right ( node ) <NEWLINE> <DEDENT> if self . _is_red ( node . left ) and self . _is_red ( node . right ) : <NEWLINE> <INDENT> node = self . _flip_colors ( node ) <NEWLINE> <NL> <DEDENT> node . count = self . _size ( node . left ) + self . _size ( node . right ) + 1 <NEWLINE> return node <NEWLINE> <NL> <DEDENT> def _is_balanced ( self , node ) : <NEWLINE> <INDENT> def depth ( node ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> left = depth ( node . left ) <NEWLINE> right = depth ( node . right ) <NEWLINE> if left != right : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> if self . _is_black ( node ) : <NEWLINE> <INDENT> return 1 + left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return left <NEWLINE> <NL> <DEDENT> <DEDENT> if node is None : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> try : <NEWLINE> <INDENT> left = depth ( node . left ) <NEWLINE> right = depth ( node . right ) <NEWLINE> return left == right <NEWLINE> <DEDENT> except Exception : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> @ property <NEWLINE> def size ( self ) : <NEWLINE> <INDENT> return self . _size ( self . root ) <NEWLINE> <NL> <DEDENT> def _size ( self , node ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return node . count <NEWLINE> <NL> <DEDENT> <DEDENT> @ property <NEWLINE> def max ( self ) : <NEWLINE> <INDENT> if self . root is None : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> return self . _max ( self . root ) <NEWLINE> <NL> <DEDENT> def _max ( self , node ) : <NEWLINE> <INDENT> x = self . _find_max ( node ) <NEWLINE> return x . key <NEWLINE> <NL> <DEDENT> def _find_max ( self , node ) : <NEWLINE> <INDENT> if node . right is None : <NEWLINE> <INDENT> return node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . _find_max ( node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> @ property <NEWLINE> def min ( self ) : <NEWLINE> <INDENT> if self . root is None : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> return self . _min ( self . root ) <NEWLINE> <NL> <DEDENT> def _min ( self , node ) : <NEWLINE> <INDENT> x = self . _find_min ( node ) <NEWLINE> return x . key <NEWLINE> <NL> <DEDENT> def _find_min ( self , node ) : <NEWLINE> <INDENT> if node . left is None : <NEWLINE> <INDENT> return node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . _find_min ( node . left ) <NEWLINE> <NL> <DEDENT> <DEDENT> def range ( self , min_ , max_ ) : <NEWLINE> <INDENT> def _range ( node ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if node . key > max_ : <NEWLINE> <INDENT> yield from _range ( node . left ) <NEWLINE> <DEDENT> elif node . key < min_ : <NEWLINE> <INDENT> yield from _range ( node . right ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> yield from _range ( node . left ) <NEWLINE> yield node . key <NEWLINE> yield from _range ( node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> if min_ > max_ : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> yield from _range ( self . root ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class BalancedBstSet : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . bst = RedBlackBinarySearchTree ( ) <NEWLINE> <NL> <DEDENT> def add ( self , key ) : <NEWLINE> <INDENT> self . bst . put ( key ) <NEWLINE> <NL> <DEDENT> def __contains__ ( self , key ) : <NEWLINE> <INDENT> return key in self . bst <NEWLINE> <NL> <DEDENT> def delete ( self , key ) : <NEWLINE> <INDENT> self . bst . delete ( key ) <NEWLINE> <NL> <DEDENT> def range ( self , a , b ) : <NEWLINE> <INDENT> for k in self . bst . range ( a , b ) : <NEWLINE> <INDENT> yield k <NEWLINE> <NL> <DEDENT> <DEDENT> @ property <NEWLINE> def count ( self ) : <NEWLINE> <INDENT> return self . bst . size <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return str ( self . bst . root ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> q = int ( input ( ) ) <NEWLINE> s = BalancedBstSet ( ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> command , * value = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if command == 0 : <NEWLINE> <INDENT> s . add ( value [ 0 ] ) <NEWLINE> print ( s . count ) <NEWLINE> <DEDENT> elif command == 1 : <NEWLINE> <INDENT> if value [ 0 ] in s : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> elif command == 2 : <NEWLINE> <INDENT> s . delete ( value [ 0 ] ) <NEWLINE> <DEDENT> elif command == 3 : <NEWLINE> <INDENT> for i in s . range ( * value ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> num = collections . Counter ( A ) <NEWLINE> <NL> S = sum ( A ) <NEWLINE> slist = [ ] <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> numb = num [ B ] <NEWLINE> S += ( C - B ) * numb <NEWLINE> num [ C ] += numb <NEWLINE> num [ B ] = 0 <NEWLINE> slist . append ( S ) <NEWLINE> <NL> <DEDENT> [ print ( i ) for i in slist ] <NEWLINE>
from collections import Counter <NEWLINE> def get_sum ( count ) : <NEWLINE> <INDENT> return sum ( [ key * count [ key ] for key in count . keys ( ) ] ) <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> count = Counter ( a ) <NEWLINE> s = sum ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count [ c ] += count [ b ] <NEWLINE> s -= count [ b ] * b <NEWLINE> s += count [ b ] * c <NEWLINE> count [ b ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> l [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , int ( n ** 0.7 ) + 3 ) : <NEWLINE> <INDENT> if n > cnt : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> cnt += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if cnt - n in ans : <NEWLINE> <INDENT> ans . remove ( cnt - n ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s . sort ( ) <NEWLINE> print ( sum ( s [ : K ] ) ) <NEWLINE>
s = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> rev_count = 0 <NEWLINE> sbf = <STRING> <NEWLINE> saf = <STRING> <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> que = input ( ) <NEWLINE> if que [ 0 ] == <STRING> : <NEWLINE> <INDENT> rev_count += 1 <NEWLINE> <DEDENT> elif que [ 0 ] == <STRING> : <NEWLINE> <INDENT> if ( rev_count + int ( que [ 2 ] ) ) % 2 == 0 : <NEWLINE> <INDENT> saf = saf + que [ 4 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sbf = que [ 4 ] + sbf <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sbf + s + saf if rev_count % 2 == 0 else ( sbf + s + saf ) [ - 1 : : - 1 ] ) <NEWLINE>
import heapq <NEWLINE> <NL> N , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = list ( [ int ( x ) * - 1 for x in input ( ) . split ( ) ] ) <NEWLINE> heapq . heapify ( A ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> target = heapq . heappop ( A ) * - 1 <NEWLINE> heapq . heappush ( A , ( target // 2 ) * - 1 ) <NEWLINE> <NL> <DEDENT> print ( sum ( A ) * - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans_al = [ 0 ] * n <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for a in al : <NEWLINE> <INDENT> ans_al [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for ans in ans_al : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ja1 = [ ] <NEWLINE> ja2 = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ja1 . append ( i - a [ i - 1 ] ) <NEWLINE> ja2 . append ( i + a [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> s = Counter ( ja1 ) <NEWLINE> t = Counter ( ja2 ) <NEWLINE> <NL> su = 0 <NEWLINE> for i in s . keys ( ) : <NEWLINE> <INDENT> su += s [ i ] * t [ i ] <NEWLINE> <DEDENT> print ( su ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import sys <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> <COMMENT> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <COMMENT> <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> point = [ 0 ] * N <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> point [ a - 1 ] += b <COMMENT> <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def dfs ( now , prev = - 1 ) : <COMMENT> <NEWLINE> <INDENT> for next in graph [ now ] : <COMMENT> <NEWLINE> <INDENT> if next == prev : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> point [ next ] += point [ now ] <COMMENT> <NEWLINE> dfs ( next , now ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 ) <COMMENT> <NEWLINE> print ( * point ) <NEWLINE>
def rolling_hash ( S , base , MOD ) : <NEWLINE> <INDENT> l = len ( S ) <NEWLINE> h = [ 0 ] * ( l + 1 ) <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> h [ i + 1 ] = ( h [ i ] * base + ord ( S [ i ] ) ) % MOD <NEWLINE> <DEDENT> return h <NEWLINE> <NL> <NL> <DEDENT> C = open ( 0 ) . read ( ) . split ( ) <NEWLINE> MOD = 358976445361682909 <NEWLINE> base = 31 <NEWLINE> for t in range ( len ( C ) // 2 ) : <NEWLINE> <INDENT> S = C [ 2 * t ] ; T = C [ 2 * t + 1 ] <NEWLINE> rhs = rolling_hash ( S , base , MOD ) <NEWLINE> rht = rolling_hash ( T , base , MOD ) <NEWLINE> L = len ( S ) ; M = len ( T ) <NEWLINE> def solve ( l ) : <NEWLINE> <INDENT> v = pow ( base , l , MOD ) <NEWLINE> hs = set ( ) <NEWLINE> for i in range ( L - l + 1 ) : <NEWLINE> <INDENT> hs . add ( ( rhs [ i + l ] - rhs [ i ] * v ) % MOD ) <NEWLINE> <DEDENT> for i in range ( M - l + 1 ) : <NEWLINE> <INDENT> if ( rht [ i + l ] - rht [ i ] * v ) % MOD in hs : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <DEDENT> left = 0 ; right = min ( L , M ) + 1 <NEWLINE> while left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if solve ( mid ) : <NEWLINE> <INDENT> left = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> <DEDENT> print ( left ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( 1 , math . floor ( math . sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> ans . append ( i + N // i - 2 ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
memo = { } <NEWLINE> def solve ( p , t ) : <NEWLINE> <INDENT> key = <STRING> . format ( p , t ) <NEWLINE> if key in memo : return memo [ key ] <NEWLINE> if p >= len ( A ) : return False <NEWLINE> if t == A [ p ] : return True <NEWLINE> if t <= 0 : return False <NEWLINE> <COMMENT> <NL> <NL> if solve ( p + 1 , t ) : <NEWLINE> <INDENT> memo [ <STRING> . format ( p + 1 , t ) ] = True <NEWLINE> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memo [ <STRING> . format ( p + 1 , t ) ] = False <NEWLINE> return solve ( p + 1 , t - A [ p ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for t in M : <NEWLINE> <INDENT> if solve ( 0 , t ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> <NL> def dfs ( current , node_vals , seen , to ) : <NEWLINE> <INDENT> for next in to [ current ] : <NEWLINE> <INDENT> if not seen [ next ] : <NEWLINE> <INDENT> node_vals [ next ] += node_vals [ current ] <NEWLINE> seen [ next ] = 1 <NEWLINE> dfs ( next , node_vals , seen , to ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> N , Q = map ( int , sysread ( ) . split ( ) ) <NEWLINE> to = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , sysread ( ) . split ( ) ) <NEWLINE> to [ a ] . append ( b ) <NEWLINE> to [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> node_vals = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , sysread ( ) . split ( ) ) <NEWLINE> node_vals [ p ] += x <NEWLINE> <NL> <DEDENT> seen = [ 0 ] * ( N + 1 ) <NEWLINE> seen [ 1 ] = 1 <NEWLINE> dfs ( 1 , node_vals , seen , to ) <NEWLINE> <NL> node_vals = [ str ( v ) for v in node_vals ] <NEWLINE> print ( <STRING> . join ( node_vals [ 1 : ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> counter = Counter ( A ) <NEWLINE> <NL> <COMMENT> <NL> A_max = max ( A ) <NEWLINE> dp = { a : False for a in A } <NEWLINE> <NL> for a in A : <NEWLINE> <COMMENT> <NL> <INDENT> if counter [ a ] > 0 : <NEWLINE> <INDENT> t = 2 <NEWLINE> while a * t <= A_max : <NEWLINE> <INDENT> dp [ a * t ] = True <NEWLINE> t += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if counter [ a ] == 1 and dp [ a ] is False : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = [ True ] * n <COMMENT> <NEWLINE> c = [ 1 ] <COMMENT> <NEWLINE> now = 0 <COMMENT> <NEWLINE> while s [ now ] : <NEWLINE> <INDENT> s [ now ] = False <COMMENT> <NEWLINE> now = a [ now ] - 1 <NEWLINE> c . append ( now + 1 ) <NEWLINE> <NL> <DEDENT> start_cycle = c . index ( c [ - 1 ] ) <COMMENT> <NEWLINE> loop = c [ start_cycle : - 1 ] <COMMENT> <NEWLINE> cycle = len ( loop ) <NEWLINE> <NL> if k < start_cycle : <COMMENT> <NEWLINE> <INDENT> print ( c [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= start_cycle <NEWLINE> k %= cycle <NEWLINE> print ( loop [ k ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <COMMENT> <NL> t = [ ] <NEWLINE> t . append ( s [ 0 ] ) <NEWLINE> x = s [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if x != s [ i ] : <NEWLINE> <INDENT> t . append ( s [ i ] ) <NEWLINE> x = s [ i ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> j = 0 <NEWLINE> t = deque ( t ) <NEWLINE> while j < k : <NEWLINE> <INDENT> if len ( t ) <= 2 : <NEWLINE> <INDENT> print ( n - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> t . popleft ( ) <NEWLINE> t . popleft ( ) <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> print ( n - 1 - ( len ( t ) - 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , x , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> is_used = [ 0 ] * ( m + 1 ) <NEWLINE> <NL> count = x <NEWLINE> pre_an = x <NEWLINE> his = [ x ] <NEWLINE> for ni in range ( 2 , n + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> an = pow ( pre_an , 2 , m ) <NEWLINE> if is_used [ an ] == 1 : <NEWLINE> <INDENT> leftnum = n - ni + 1 <NEWLINE> start = his . index ( an ) <NEWLINE> end = leftnum % ( len ( his ) - start ) + start <NEWLINE> loopnum = leftnum // ( len ( his ) - start ) <NEWLINE> count = count + sum ( his [ start : end ] ) <NEWLINE> count = count + sum ( his [ start : ] ) * loopnum <NEWLINE> break <NEWLINE> <DEDENT> his . append ( an ) <NEWLINE> is_used [ an ] = 1 <NEWLINE> count = count + an <NEWLINE> pre_an = an <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> l = len ( s ) <NEWLINE> f = 0 <NEWLINE> if l <= 9 : <NEWLINE> <INDENT> for i in range ( 1 << l + 1 ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> for j in range ( l + 1 ) : <NEWLINE> <INDENT> if i >> j & 1 : ans += <STRING> <NEWLINE> if j < l : ans += s [ j ] <NEWLINE> <DEDENT> if ans == <STRING> : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : f = 0 <NEWLINE> <NL> if f : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> a = 7 % K <NEWLINE> ans = - 1 <NEWLINE> for i in range ( 1 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> a = ( a * 10 + 7 ) % K <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num [ a_list [ i ] ] += 1 <NEWLINE> sum += a_list [ i ] <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> sum += ( c - b ) * num [ b ] <NEWLINE> num [ c ] += num [ b ] <NEWLINE> num [ b ] = 0 <NEWLINE> print ( sum ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b * 2 >= a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - b * 2 ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = collections . Counter ( A ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> arr = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> cnt = bin ( i ) . count ( <STRING> ) <NEWLINE> arr [ i ] = arr [ i % cnt ] + 1 <NEWLINE> <NL> <DEDENT> x = int ( X , 2 ) <NEWLINE> pop = X . count ( <STRING> ) <NEWLINE> plu = x % ( pop + 1 ) <NEWLINE> mai = x % ( pop - 1 ) if pop > 1 else 0 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> res = ( plu + pow ( 2 , N - 1 - i , pop + 1 ) ) % ( pop + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if pop == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <COMMENT> <NL> <DEDENT> res = ( mai - pow ( 2 , N - 1 - i , pop - 1 ) ) % ( pop - 1 ) <NEWLINE> <DEDENT> print ( arr [ res ] + 1 ) <NEWLINE> <DEDENT>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf , comb <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> from functools import reduce <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> def dfs ( m ) : <NEWLINE> <INDENT> if m == 1 : <NEWLINE> <INDENT> ans . append ( 1 ) <NEWLINE> return 0 <NEWLINE> <DEDENT> elif m == 2 : <NEWLINE> <INDENT> ans . append ( 2 ) <NEWLINE> return 0 <NEWLINE> <DEDENT> elif m == 3 : <NEWLINE> <INDENT> ans . append ( 2 ) <NEWLINE> ans . append ( 1 ) <NEWLINE> return 0 <NEWLINE> <DEDENT> elif m == 4 : <NEWLINE> <INDENT> ans . append ( 3 ) <NEWLINE> ans . append ( 1 ) <NEWLINE> return 0 <NEWLINE> <DEDENT> elif m == 5 : <NEWLINE> <INDENT> ans . append ( 3 ) <NEWLINE> ans . append ( 2 ) <NEWLINE> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = ceil ( sqrt ( 1 + 8 * m ) ) // 2 <NEWLINE> ans . append ( k ) <NEWLINE> dfs ( m - k ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = INT ( ) <NEWLINE> dfs ( n ) <NEWLINE> for x in ans : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> flag = [ False ] * 8 <NEWLINE> t = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i < 400 : flag [ 0 ] = True <NEWLINE> elif i < 800 : flag [ 1 ] = True <NEWLINE> elif i < 1200 : flag [ 2 ] = True <NEWLINE> elif i < 1600 : flag [ 3 ] = True <NEWLINE> elif i < 2000 : flag [ 4 ] = True <NEWLINE> elif i < 2400 : flag [ 5 ] = True <NEWLINE> elif i < 2800 : flag [ 6 ] = True <NEWLINE> elif i < 3200 : flag [ 7 ] = True <NEWLINE> elif 3200 <= i : t += 1 <NEWLINE> <NL> <DEDENT> minNum = 0 <NEWLINE> p = flag . count ( True ) <NEWLINE> if p > 0 : minNum = p <NEWLINE> elif p == 0 and t > 0 : <NEWLINE> <INDENT> minNum = 1 <NEWLINE> <NL> <DEDENT> maxNum = p + t <NEWLINE> <NL> print ( minNum , maxNum ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> k = [ ] <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> k . append ( s [ i ] ) <NEWLINE> k . append ( t [ i ] ) <NEWLINE> <DEDENT> if len ( s ) > len ( t ) : <NEWLINE> <INDENT> k . append ( s [ len ( s ) - 1 ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( k ) ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = [ 0 , 0 ] <NEWLINE> for l in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ l - 1 ] == <STRING> and s [ l ] == <STRING> : <NEWLINE> <INDENT> a . append ( a [ l ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( a [ l ] ) <NEWLINE> <DEDENT> <DEDENT> for k in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a [ y ] - a [ x ] ) <NEWLINE> <DEDENT>
def maxHeapify ( i , node_list ) : <NEWLINE> <INDENT> n = len ( node_list ) <NEWLINE> if 2 * i + 1 < n and node_list [ 2 * i + 1 ] > node_list [ i ] : <NEWLINE> <INDENT> i_largest = 2 * i + 1 <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> i_largest = i <NEWLINE> <DEDENT> if 2 * i + 2 < n and node_list [ 2 * i + 2 ] > node_list [ i_largest ] : <NEWLINE> <INDENT> i_largest = 2 * i + 2 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> if i_largest != i : <NEWLINE> <INDENT> node_list [ i ] , node_list [ i_largest ] = node_list [ i_largest ] , node_list [ i ] <NEWLINE> maxHeapify ( i_largest , node_list ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> node_list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in range ( n // 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> maxHeapify ( i , node_list ) <NEWLINE> <DEDENT> print ( <STRING> + <STRING> . join ( [ str ( node ) for node in node_list ] ) ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> Hs = input ( ) . split ( ) <NEWLINE> Hs = [ int ( ele ) for ele in Hs ] <NEWLINE> <NL> res = [ 1 for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> con = input ( ) . split ( ) <NEWLINE> con = [ int ( ele ) for ele in con ] <NEWLINE> <NL> id1 = con [ 0 ] - 1 <NEWLINE> id2 = con [ 1 ] - 1 <NEWLINE> <NL> if res [ id1 ] == 1 : <NEWLINE> <INDENT> res [ id1 ] = int ( Hs [ id2 ] < Hs [ id1 ] ) <NEWLINE> <DEDENT> if res [ id2 ] == 1 : <NEWLINE> <INDENT> res [ id2 ] = int ( Hs [ id1 ] < Hs [ id2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( res ) ) <NEWLINE>
S = input ( ) <NEWLINE> print ( S . rfind ( <STRING> ) - S . find ( <STRING> ) + 1 ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cum_a = [ 0 ] * ( n + 1 ) <NEWLINE> for i , v in enumerate ( a ) : <NEWLINE> <INDENT> cum_a [ i + 1 ] = cum_a [ i ] + a [ i ] <NEWLINE> <DEDENT> cum_b = [ 0 ] * ( m + 1 ) <NEWLINE> for i , v in enumerate ( b ) : <NEWLINE> <INDENT> cum_b [ i + 1 ] = cum_b [ i ] + b [ i ] <NEWLINE> <NL> <DEDENT> a_idx = n <NEWLINE> b_idx = 0 <NEWLINE> res = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> current_a_idx = a_idx - i <NEWLINE> sum_a = cum_a [ current_a_idx ] <NEWLINE> if sum_a > k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> sum_b = cum_b [ b_idx ] <NEWLINE> while sum_a + sum_b <= k and b_idx < m : <NEWLINE> <INDENT> b_idx += 1 <NEWLINE> sum_b = cum_b [ b_idx ] <NEWLINE> if sum_a + sum_b > k : <NEWLINE> <INDENT> b_idx -= 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> res = max ( b_idx + current_a_idx , res ) <NEWLINE> <DEDENT> a_idx = 0 <NEWLINE> b_idx = m <NEWLINE> for i in range ( m + 1 ) : <NEWLINE> <INDENT> current_b_idx = b_idx - i <NEWLINE> sum_b = cum_b [ current_b_idx ] <NEWLINE> if sum_b > k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> sum_a = cum_a [ a_idx ] <NEWLINE> while sum_a + sum_b <= k and a_idx < n : <NEWLINE> <INDENT> a_idx += 1 <NEWLINE> sum_a = cum_a [ a_idx ] <NEWLINE> if sum_a + sum_b > k : <NEWLINE> <INDENT> a_idx -= 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> res = max ( current_b_idx + a_idx , res ) <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> from itertools import accumulate <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , k , * p = map ( int , read ( ) . split ( ) ) <NEWLINE> p2 = [ ( 1 + pe ) / 2 for pe in p ] <NEWLINE> p2a = tuple ( accumulate ( p2 ) ) <NEWLINE> r = p2a [ k - 1 ] <NEWLINE> for i1 in range ( k , n ) : <NEWLINE> <INDENT> r = max ( r , p2a [ i1 ] - p2a [ i1 - k ] ) <NEWLINE> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> b = [ k - q ] * n <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> ai = int ( input ( ) ) <NEWLINE> b [ ai - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> if b [ j ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> li = [ 1 , 9 , 30 , 76 , 141 , 267 , 400 , 624 , 885 , 1249 , 1590 , 2208 , 2689 , 3411 , 4248 , 5248 , 6081 , 7485 , 8530 , 10248 , 11889 , 13687 , 15228 , 17988 , 20053 , 22569 , 25242 , 28588 , 31053 , 35463 , 38284 , 42540 , 46581 , 50893 , 55362 , 61824 , 65857 , 71247 , 76884 , 84388 , 89349 , 97881 , 103342 , 111528 , 120141 , 128047 , 134580 , 146316 , 154177 , 164817 , 174438 , 185836 , 194157 , 207927 , 218812 , 233268 , 245277 , 257857 , 268182 , 288216 , 299257 , 313635 , 330204 , 347836 , 362973 , 383709 , 397042 , 416448 , 434025 , 456967 , 471948 , 499740 , 515581 , 536073 , 559758 , 583960 , 604833 , 633651 , 652216 , 683712 , 709065 , 734233 , 754734 , 793188 , 818917 , 846603 , 874512 , 909496 , 933081 , 977145 , 1006126 , 1041504 , 1073385 , 1106467 , 1138536 , 1187112 , 1215145 , 1255101 , 1295142 , 1342852 , 1373253 , 1422195 , 1453816 , 1502376 , 1553361 , 1595437 , 1629570 , 1691292 , 1726717 , 1782111 , 1827492 , 1887772 , 1925853 , 1986837 , 2033674 , 2089776 , 2145333 , 2197483 , 2246640 , 2332104 , 2379085 , 2434833 , 2490534 , 2554600 , 2609625 , 2693919 , 2742052 , 2813988 , 2875245 , 2952085 , 3003306 , 3096024 , 3157249 , 3224511 , 3306240 , 3388576 , 3444609 , 3533637 , 3591322 , 3693924 , 3767085 , 3842623 , 3912324 , 4027884 , 4102093 , 4181949 , 4270422 , 4361548 , 4427853 , 4548003 , 4616104 , 4718640 , 4812789 , 4918561 , 5003286 , 5131848 , 5205481 , 5299011 , 5392008 , 5521384 , 5610705 , 5739009 , 5818390 , 5930196 , 6052893 , 6156139 , 6239472 , 6402720 , 6493681 , 6623853 , 6741078 , 6864016 , 6953457 , 7094451 , 7215016 , 7359936 , 7475145 , 7593865 , 7689630 , 7886244 , 7984165 , 8130747 , 8253888 , 8403448 , 8523897 , 8684853 , 8802826 , 8949612 , 9105537 , 9267595 , 9376656 , 9574704 , 9686065 , 9827097 , 9997134 , 10174780 , 10290813 , 10493367 , 10611772 , 10813692 ] <NEWLINE> print ( li [ k - 1 ] ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> class Combination : <NEWLINE> <INDENT> def __init__ ( self , n_max , mod = 10 ** 9 + 7 ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . mod = mod <NEWLINE> f = 1 <NEWLINE> self . fac = fac = [ f ] <NEWLINE> for i in range ( 1 , n_max + 1 ) : <NEWLINE> <INDENT> f = f * i % mod <NEWLINE> fac . append ( f ) <NEWLINE> <DEDENT> f = pow ( f , mod - 2 , mod ) <NEWLINE> self . facinv = facinv = [ f ] <NEWLINE> for i in range ( n_max , 0 , - 1 ) : <NEWLINE> <INDENT> f = f * i % mod <NEWLINE> facinv . append ( f ) <NEWLINE> <DEDENT> facinv . reverse ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> def __call__ ( self , n , r ) : <COMMENT> <NEWLINE> <INDENT> return self . fac [ n ] * self . facinv [ r ] % self . mod * self . facinv [ n - r ] % self . mod <NEWLINE> <NL> <DEDENT> def C ( self , n , r ) : <NEWLINE> <INDENT> if not 0 <= r <= n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return self . fac [ n ] * self . facinv [ r ] % self . mod * self . facinv [ n - r ] % self . mod <NEWLINE> <NL> <DEDENT> def P ( self , n , r ) : <NEWLINE> <INDENT> if not 0 <= r <= n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return self . fac [ n ] * self . facinv [ n - r ] % self . mod <NEWLINE> <NL> <DEDENT> def H ( self , n , r ) : <NEWLINE> <INDENT> if ( n == 0 and r > 0 ) or r < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return self . fac [ n + r - 1 ] * self . facinv [ r ] % self . mod * self . facinv [ n - 1 ] % self . mod <NEWLINE> <NL> <DEDENT> def rising_factorial ( self , n , r ) : <COMMENT> <NEWLINE> <INDENT> return self . fac [ n + r - 1 ] * self . facinv [ n - 1 ] % self . mod <NEWLINE> <NL> <DEDENT> def stirling_first ( self , n , k ) : <COMMENT> <NEWLINE> <INDENT> if n == k : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if k == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return ( self . stirling_first ( n - 1 , k - 1 ) + ( n - 1 ) * self . stirling_first ( n - 1 , k ) ) % self . mod <NEWLINE> <NL> <DEDENT> def stirling_second ( self , n , k ) : <COMMENT> <NEWLINE> <INDENT> if n == k : <NEWLINE> <INDENT> return 1 <COMMENT> <NEWLINE> <DEDENT> return self . facinv [ k ] * sum ( ( - 1 ) ** ( k - m ) * self . C ( k , m ) * pow ( m , n , self . mod ) for m in range ( 1 , k + 1 ) ) % self . mod <NEWLINE> <NL> <DEDENT> def balls_and_boxes_3 ( self , n , k ) : <COMMENT> <NEWLINE> <INDENT> return sum ( ( - 1 ) ** ( k - m ) * self . C ( k , m ) * pow ( m , n , self . mod ) for m in range ( 1 , k + 1 ) ) % self . mod <NEWLINE> <NL> <DEDENT> def bernoulli ( self , n ) : <COMMENT> <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if n % 2 and n >= 3 : <NEWLINE> <INDENT> return 0 <COMMENT> <NEWLINE> <DEDENT> return ( - pow ( n + 1 , self . mod - 2 , self . mod ) * sum ( self . C ( n + 1 , k ) * self . bernoulli ( k ) % self . mod for k in range ( n ) ) ) % self . mod <NEWLINE> <NL> <DEDENT> def faulhaber ( self , k , n ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> return pow ( k + 1 , self . mod - 2 , self . mod ) * sum ( self . C ( k + 1 , j ) * self . bernoulli ( j ) % self . mod * pow ( n , k - j + 1 , self . mod ) % self . mod for j in range ( k + 1 ) ) % self . mod <NEWLINE> <NL> <DEDENT> def lah ( self , n , k ) : <COMMENT> <NEWLINE> <INDENT> return self . C ( n - 1 , k - 1 ) * self . fac [ n ] % self . mod * self . facinv [ k ] % self . mod <NEWLINE> <NL> <DEDENT> def bell ( self , n , k ) : <COMMENT> <NEWLINE> <INDENT> return sum ( self . stirling_second ( n , j ) for j in range ( 1 , k + 1 ) ) % self . mod <NEWLINE> <NL> <DEDENT> <DEDENT> k = int ( readline ( ) ) <NEWLINE> s = readline ( ) . rstrip ( ) . decode ( ) <NEWLINE> n = len ( s ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> comb = Combination ( n + k ) <NEWLINE> v = 1 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> ans += comb ( n + k , i ) * v <NEWLINE> ans %= mod <NEWLINE> v *= 25 <NEWLINE> v %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <STRING> <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> baig = [ 0 for i in range ( 10 ** 5 + 1 ) ] <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> baig [ i ] = pow ( k // i , n , MOD ) <NEWLINE> <NL> <DEDENT> for j in range ( k , 0 , - 1 ) : <NEWLINE> <INDENT> for jj in range ( 2 * j , k + 1 , j ) : <NEWLINE> <INDENT> baig [ j ] -= baig [ jj ] <NEWLINE> <DEDENT> baig [ j ] %= MOD <NEWLINE> ans += baig [ j ] * j <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> zumi_hash = { } <NEWLINE> zumi = [ - 1 ] * ( 2 * ( 10 ** 5 ) ) <NEWLINE> ima = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ima in zumi_hash : <NEWLINE> <INDENT> zumi [ i ] = ima <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> if ima == A [ ima - 1 ] : <NEWLINE> <INDENT> print ( ima ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> zumi_hash [ ima ] = True <NEWLINE> zumi [ i ] = ima <NEWLINE> ima = A [ ima - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ima ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> loop_e = zumi . index ( - 1 ) <NEWLINE> loop_s = zumi . index ( zumi [ loop_e - 1 ] ) <NEWLINE> zan_loop = K - loop_s <NEWLINE> loop = zumi [ loop_s : loop_e - 1 ] <NEWLINE> amari = zan_loop % ( len ( loop ) ) <NEWLINE> print ( loop [ amari ] ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> bound = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 1 <NEWLINE> pos = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> pos += bound [ i ] <NEWLINE> if pos <= x : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if pos > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = list ( map ( lambda x : ( 1 + x ) / 2 , p ) ) <NEWLINE> s = [ 0 ] <NEWLINE> num = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num += p [ i ] <NEWLINE> s . append ( num ) <NEWLINE> <DEDENT> l = [ ] <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> l . append ( s [ i + k ] - s [ i ] ) <NEWLINE> <NL> <DEDENT> print ( max ( l ) ) <NEWLINE>
def is_prime ( n ) : <NEWLINE> <INDENT> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : return False <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> if is_prime ( int ( input ( ) ) ) : count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> remain = 0 <NEWLINE> i = 0 <NEWLINE> <NL> answer = - 1 <NEWLINE> <NL> for i in range ( 1 , K + 5 ) : <NEWLINE> <INDENT> number = remain * 10 + 7 <NEWLINE> <NL> remain = number % K <NEWLINE> <NL> if remain == 0 : <NEWLINE> <INDENT> answer = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N - 1 ) ] <NEWLINE> <NL> path = [ list ( ) for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = ab [ i ] [ 0 ] , ab [ i ] [ 1 ] <NEWLINE> path [ a ] . append ( [ b , i ] ) <NEWLINE> path [ b ] . append ( [ a , i ] ) <NEWLINE> <NL> <DEDENT> color_max = 0 <NEWLINE> color_list = [ 0 ] * ( N - 1 ) <NEWLINE> visit = [ False ] * ( N + 1 ) <NEWLINE> visit [ 1 ] = True <NEWLINE> def dfs ( node , color , used_path ) : <NEWLINE> <INDENT> global visit <NEWLINE> nxt_color = 0 <NEWLINE> for nxt in path [ node ] : <NEWLINE> <INDENT> nxt_node = nxt [ 0 ] <NEWLINE> use_path = nxt [ 1 ] <NEWLINE> if visit [ nxt_node ] == False : <NEWLINE> <INDENT> visit [ nxt_node ] = True <NEWLINE> nxt_color += 1 <NEWLINE> if nxt_color == color : <NEWLINE> <INDENT> nxt_color += 1 <NEWLINE> <DEDENT> dfs ( nxt_node , nxt_color , use_path ) <NEWLINE> <NL> <DEDENT> <DEDENT> global color_list <NEWLINE> if used_path != - 1 : <NEWLINE> <INDENT> color_list [ used_path ] = color <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 1 , 0 , - 1 ) <NEWLINE> <NL> <NL> for c in color_list : <NEWLINE> <INDENT> color_max = max ( c , color_max ) <NEWLINE> <DEDENT> print ( color_max ) <NEWLINE> print ( <STRING> . join ( map ( str , color_list ) ) ) <NEWLINE>
class BinaryIndexedTree : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . a = [ 0 ] * ( n + 1 ) <NEWLINE> self . n = n <NEWLINE> <NL> <DEDENT> def add ( self , i , x ) : <NEWLINE> <INDENT> while i <= self . n : <NEWLINE> <INDENT> self . a [ i ] += x <NEWLINE> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> def sum ( self , i ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> ret += self . a [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Solve : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . p = BinaryIndexedTree ( n + 1 ) <NEWLINE> self . q = BinaryIndexedTree ( n + 1 ) <NEWLINE> <NL> <DEDENT> def add ( self , s , t , x ) : <NEWLINE> <INDENT> t += 1 <NEWLINE> self . p . add ( s , - x * s ) <NEWLINE> self . p . add ( t , x * t ) <NEWLINE> self . q . add ( s , x ) <NEWLINE> self . q . add ( t , - x ) <NEWLINE> <NL> <DEDENT> def get_sum ( self , s , t ) : <NEWLINE> <INDENT> t += 1 <NEWLINE> return self . p . sum ( t ) + self . q . sum ( t ) * t - self . p . sum ( s ) - self . q . sum ( s ) * s <NEWLINE> <NL> <DEDENT> def dump ( self ) : <NEWLINE> <INDENT> print ( * ( self . get_sum ( i , i ) for i in range ( self . n + 1 ) ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> st = Solve ( n ) <NEWLINE> buf = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> query = input ( ) . split ( ) <NEWLINE> if query [ 0 ] == <STRING> : <NEWLINE> <INDENT> st . add ( * map ( int , query [ 1 : ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> buf . append ( st . get_sum ( * map ( int , query [ 1 : ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , buf ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> b [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in b : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> dic = { } <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> x = i - A [ i ] <NEWLINE> if x < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x in dic : <NEWLINE> <INDENT> dic [ x ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ x ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if A [ 0 ] in dic : <NEWLINE> <INDENT> ans += dic [ A [ 0 ] ] <NEWLINE> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> x = i + A [ i ] <NEWLINE> <NL> if i - A [ i ] in dic : <NEWLINE> <INDENT> dic [ i - A [ i ] ] -= 1 <NEWLINE> <NL> <DEDENT> if x in dic : <NEWLINE> <INDENT> ans += dic [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * Q <NEWLINE> b = [ 0 ] * Q <NEWLINE> c = [ 0 ] * Q <NEWLINE> d = [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> from copy import deepcopy <NEWLINE> <NL> ans_list = [ ] <NEWLINE> def dfs ( x , M , N , ans ) : <NEWLINE> <INDENT> if len ( ans ) <= N - 1 : <NEWLINE> <INDENT> for j in range ( x , M + 1 ) : <NEWLINE> <INDENT> tmp = deepcopy ( ans ) <NEWLINE> tmp . append ( j ) <NEWLINE> if len ( tmp ) == N : <NEWLINE> <INDENT> ans_list . append ( tmp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dfs ( j , M , N , tmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> q = dfs ( 1 , M , N , [ ] ) <NEWLINE> <NL> <NL> f = 0 <NEWLINE> for A in ans_list : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> if A [ b [ i ] - 1 ] - A [ a [ i ] - 1 ] == c [ i ] : <NEWLINE> <INDENT> cnt += d [ i ] <NEWLINE> <DEDENT> <DEDENT> f = max ( f , cnt ) <NEWLINE> <NL> <DEDENT> print ( f ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> if ( k % 2 == 0 or k % 5 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> if k % 7 == 0 : <NEWLINE> <INDENT> L = 9 * k // 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = 9 * k <NEWLINE> <DEDENT> i = 1 <NEWLINE> for n in range ( 1 , L + 1 ) : <NEWLINE> <INDENT> i = ( 10 * i ) % L <NEWLINE> if i == 1 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> c += ( n - 1 ) // i <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> ans = [ ] <NEWLINE> mon = [ 0 ] * ( 2 ** n ) <NEWLINE> <NL> def ok ( anss , x ) : <NEWLINE> <INDENT> for i in range ( len ( anss ) ) : <NEWLINE> <INDENT> if anss [ i ] < x : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> for i in range ( 2 ** n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> anss = [ 0 ] * m <NEWLINE> for j in range ( n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> mon [ i ] += l [ j ] [ 0 ] <NEWLINE> for k in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> anss [ k - 1 ] += l [ j ] [ k ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if ok ( anss , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans . append ( mon [ i ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if ans != [ ] : <NEWLINE> <INDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import math <NEWLINE> def comb ( n , r ) : <NEWLINE> <INDENT> if n - r >= 0 : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> print ( comb ( n - k + 1 , i ) * comb ( k - 1 , i - 1 ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT>
n , h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cut = 0 <NEWLINE> throw = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cut = max ( cut , a ) <NEWLINE> throw . append ( b ) <NEWLINE> <NL> <DEDENT> throw . sort ( reverse = True ) <NEWLINE> throw_cam = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if cut > throw [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i == 0 : <NEWLINE> <INDENT> throw_cam . append ( throw [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> throw_cam . append ( throw [ i ] + throw_cam [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if throw_cam [ len ( throw_cam ) - 1 ] < h : <NEWLINE> <INDENT> rh = h - throw_cam [ len ( throw_cam ) - 1 ] <NEWLINE> if rh % cut == 0 : <NEWLINE> <INDENT> print ( len ( throw_cam ) + rh // cut ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( throw_cam ) + rh // cut + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( throw_cam ) ) : <NEWLINE> <INDENT> d = throw_cam [ i ] <NEWLINE> if d >= h : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> def rs ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def ri ( ) : return int ( rs ( ) ) <NEWLINE> def rs_ ( ) : return [ _ for _ in rs ( ) . split ( ) ] <NEWLINE> def ri_ ( ) : return [ int ( _ ) for _ in rs ( ) . split ( ) ] <NEWLINE> <NL> o = rs ( ) <NEWLINE> e = rs ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( o ) ) : <NEWLINE> <INDENT> ans += o [ i ] <NEWLINE> if i < len ( e ) : <NEWLINE> <INDENT> ans += e [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> m = a [ - 1 ] <NEWLINE> b = [ True ] * ( m + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i > 0 and a [ i ] == a [ i - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( 2 , m // a [ i ] + 1 ) : <NEWLINE> <INDENT> b [ j * a [ i ] ] = False <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if 0 < i and a [ i ] == a [ i - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i < n - 1 and a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if b [ a [ i ] ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if min ( X ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> Y = X [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> Y = X [ i ] * Y <NEWLINE> if Y > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( Y ) <NEWLINE> <NL>
from math import gcd <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt_l = [ 0 ] * n <NEWLINE> from collections import deque <NEWLINE> def bfs ( start ) : <NEWLINE> <INDENT> queue = deque ( ) <NEWLINE> queue . append ( start ) <NEWLINE> isSearched = [ - 1 ] * ( n + 1 ) <NEWLINE> isSearched [ start ] = 0 <NEWLINE> while ( len ( queue ) > 0 ) : <NEWLINE> <INDENT> i = queue . popleft ( ) <NEWLINE> cnt = isSearched [ i ] <NEWLINE> if ( i == x ) : <NEWLINE> <INDENT> nex_l = ( i - 1 , y , i + 1 ) <NEWLINE> <DEDENT> elif ( i == y ) : <NEWLINE> <INDENT> nex_l = ( i - 1 , x , i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nex_l = ( i - 1 , i + 1 ) <NEWLINE> <NL> <DEDENT> cnt += 1 <NEWLINE> for j in nex_l : <NEWLINE> <INDENT> if ( j < 1 or n < j ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( isSearched [ j ] != - 1 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> queue . append ( j ) <NEWLINE> isSearched [ j ] = cnt <NEWLINE> cnt_l [ cnt ] += 1 <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> bfs ( i ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( cnt_l [ i ] // 2 ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> def stdinput ( ) : <NEWLINE> <INDENT> return stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> altitutes = load_data ( ) <NEWLINE> <NL> edges = create_edges ( altitutes ) <NEWLINE> <NL> <COMMENT> <NL> <NL> areas = calc_areas ( altitutes , edges ) <NEWLINE> <NL> print ( int ( sum ( areas ) ) ) <NEWLINE> print ( * ( [ len ( areas ) ] + [ * map ( int , areas ) ] ) ) <NEWLINE> <NL> <DEDENT> def load_data ( ) : <NEWLINE> <INDENT> A = [ 0 ] <NEWLINE> for s in stdinput ( ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> A . append ( A [ - 1 ] - 1 ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> A . append ( A [ - 1 ] ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> A . append ( A [ - 1 ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> return A <NEWLINE> <NL> <DEDENT> def create_edges ( A ) : <NEWLINE> <INDENT> st = [ ( 0 , None , 0 ) ] <NEWLINE> highest = 0 <NEWLINE> for i , a in enumerate ( A [ 1 : ] , 1 ) : <NEWLINE> <INDENT> if st [ - 1 ] [ 0 ] >= a : <NEWLINE> <INDENT> st . append ( ( a , st [ - 1 ] [ 2 ] , i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> begin = i - 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> while st [ - 1 ] [ 1 ] != None and st [ - 1 ] [ 0 ] == a - 1 and highest >= a : <NEWLINE> <INDENT> lev , begin , j = st . pop ( ) <NEWLINE> <DEDENT> highest = max ( highest , a ) <NEWLINE> st . append ( ( a , begin , i ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> return [ * map ( lambda e : e [ 1 : ] , st [ 1 : ] ) ] <NEWLINE> <NL> <DEDENT> def calc_areas ( A , edges ) : <NEWLINE> <INDENT> areas = [ ] <NEWLINE> for begin , end in edges : <NEWLINE> <INDENT> area = calc_area ( A , begin , end ) <NEWLINE> if area > 0 : <NEWLINE> <INDENT> areas . append ( area ) <NEWLINE> <DEDENT> <DEDENT> return areas <NEWLINE> <NL> <DEDENT> def calc_area ( A , begin , end ) : <NEWLINE> <INDENT> if A [ begin ] != A [ end ] : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> b_level = A [ begin ] <NEWLINE> area = 0 <NEWLINE> for l1 , l2 in zip ( range ( begin , end ) , range ( begin + 1 , end + 1 ) ) : <NEWLINE> <INDENT> a1 = A [ l1 ] <NEWLINE> a2 = A [ l2 ] <NEWLINE> area += ( b_level - a1 + b_level - a2 ) * 1 / 2 <NEWLINE> <DEDENT> return area <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 0 , N , 2 ) : <NEWLINE> <INDENT> if a [ i ] % 2 != 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def amari ( x ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 2 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 3 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 4 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 5 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 6 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 7 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 8 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 9 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 10 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 11 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 12 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 13 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 14 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 15 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 16 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 17 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 18 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 19 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 20 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 21 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 22 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 23 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 24 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif x == 25 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> K = 0 <NEWLINE> k = 0 <NEWLINE> i = 0 <NEWLINE> my_str = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> if k <= N <= K : <NEWLINE> <INDENT> N = N - k <COMMENT> <NEWLINE> for j in range ( i ) : <COMMENT> <NEWLINE> <INDENT> my_str . append ( amari ( N % 26 ) ) <NEWLINE> N = N // 26 <NEWLINE> <DEDENT> strA = <STRING> . join ( my_str [ : : - 1 ] ) <NEWLINE> print ( strA ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> k = K + 1 <NEWLINE> K += 26 ** i <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ 0 ] * N <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> l [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> ans = <STRING> . join ( [ str ( x ) for x in l ] ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a . reverse ( ) <NEWLINE> lists = [ ] <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] <= a [ i + k ] : <NEWLINE> <INDENT> lists . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lists . append ( 1 ) <NEWLINE> <DEDENT> <DEDENT> lists . reverse ( ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if lists [ i ] == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> k = 0 <NEWLINE> b = [ 0 ] * len ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( a ) - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> k += a [ i ] <NEWLINE> k %= mod <NEWLINE> b [ i ] = k <NEWLINE> <DEDENT> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> ans += a [ i ] * b [ i + 1 ] <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> ai , bi = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( ai ) <NEWLINE> b . append ( bi ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> a [ i ] += ans <NEWLINE> t = ( b [ i ] - a [ i ] ) % b [ i ] <NEWLINE> ans += t <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
num = input ( ) . split ( ) <NEWLINE> if int ( num [ 0 ] ) < int ( num [ 1 ] ) : <NEWLINE> <INDENT> x = int ( num [ 1 ] ) <NEWLINE> y = int ( num [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = int ( num [ 0 ] ) <NEWLINE> y = int ( num [ 1 ] ) <NEWLINE> <NL> <DEDENT> end = 0 <NEWLINE> <NL> z = x % y <NEWLINE> if z == 0 : <NEWLINE> <INDENT> print ( y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> z1 = y % z <NEWLINE> y1 = z <NEWLINE> if z1 == 0 : <NEWLINE> <INDENT> print ( z ) <NEWLINE> break <NEWLINE> <DEDENT> z = z1 <NEWLINE> y = y1 <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> def input_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def int1 ( x ) : <NEWLINE> <INDENT> return int ( x ) - 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def input_to_int_map ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def input_to_int_tuple ( ) : <NEWLINE> <INDENT> return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def input_to_int_tuple_minus1 ( ) : <NEWLINE> <INDENT> return tuple ( map ( int1 , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = input_int ( ) <NEWLINE> a_list = input_to_int_tuple ( ) <NEWLINE> <NL> a_sorted = list ( sorted ( a_list ) ) <NEWLINE> <NL> max_val = a_sorted [ - 1 ] <NEWLINE> cands = [ 0 ] * max_val <NEWLINE> <NL> for num in a_sorted : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> for i in range ( num , max_val + 1 , num ) : <NEWLINE> <INDENT> cands [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for num in a_sorted : <NEWLINE> <INDENT> if cands [ num - 1 ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> print ( math . factorial ( int ( input ( ) ) ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
import networkx as nx <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> UVW = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N - 1 ) ] <NEWLINE> <NL> G = nx . Graph ( ) <NEWLINE> <NL> color = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> for u , v , w in UVW : <NEWLINE> <INDENT> G . add_edge ( u - 1 , v - 1 , weight = w ) <NEWLINE> <NL> <DEDENT> color [ 0 ] = - 1 <NEWLINE> <NL> pred , dist = nx . dijkstra_predecessor_and_distance ( G , 0 ) <NEWLINE> <NL> c = [ dist [ i ] for i in range ( N ) ] <NEWLINE> ans = [ 1 if i % 2 == 0 else 0 for i in c ] <NEWLINE> print ( * ans ) <NEWLINE>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> if w >= v : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> if max ( a - b , b - a ) / ( v - w ) <= t else <STRING> ) <NEWLINE>
import time <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> inf = 10 ** 18 <NEWLINE> t = time . time ( ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > inf : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> for A in range ( - 120 , 120 ) : <NEWLINE> <INDENT> for B in range ( - 120 , 120 ) : <NEWLINE> <INDENT> if A ** 5 - B ** 5 == X : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> r = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> r *= a <NEWLINE> <NL> if r > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> List . sort ( reverse = True ) <NEWLINE> if 0 in List : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in List : <NEWLINE> <INDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> ans *= i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> L [ i + 1 ] += L [ i ] <NEWLINE> if X [ i ] > L [ i ] * 2 : <NEWLINE> <INDENT> L [ i + 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> L [ i ] = i - L [ i ] <NEWLINE> <NL> <DEDENT> d = Counter ( L ) <NEWLINE> ans = 1 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( 10 ** 5 ) : <NEWLINE> <INDENT> tmp += d [ i ] <NEWLINE> if tmp == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans *= tmp <NEWLINE> ans %= mod <NEWLINE> tmp -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from math import floor <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( floor ( A * min ( B - 1 , N ) / B ) ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> q = math . gcd ( i + 1 , j + 1 ) <NEWLINE> for l in range ( k ) : <NEWLINE> <INDENT> ans += math . gcd ( q , l + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> <NL> rtow = c . count ( <STRING> ) <NEWLINE> wtor = 0 <NEWLINE> <NL> anses = [ ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> anses . append ( max ( rtow , wtor ) ) <NEWLINE> if i == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> wtor += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rtow -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( anses ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> C = list ( input ( ) ) <NEWLINE> <NL> white = [ 0 ] * ( N + 1 ) <NEWLINE> red = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if C [ i ] == <STRING> : <NEWLINE> <INDENT> white [ i + 1 ] = white [ i ] + 1 <NEWLINE> red [ i + 1 ] = red [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> white [ i + 1 ] = white [ i ] <NEWLINE> red [ i + 1 ] = red [ i ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if white [ - 1 ] == N or red [ - 1 ] == N : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = float ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> wcnt = white [ i ] <NEWLINE> rcnt = red [ - 1 ] - red [ i ] <NEWLINE> m = max ( wcnt , rcnt ) <NEWLINE> ans = min ( m , ans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = [ ] <NEWLINE> tmp = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <DEDENT> <DEDENT> name = <STRING> <NEWLINE> <NL> while n != 0 : <NEWLINE> <INDENT> mod = n % 26 <NEWLINE> h . append ( mod ) <NEWLINE> n //= 26 <NEWLINE> if mod == 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> <DEDENT> <DEDENT> h . reverse ( ) <NEWLINE> for i in h : <NEWLINE> <INDENT> name += tmp [ i - 1 ] <NEWLINE> <DEDENT> print ( name ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> a = k ( ) <NEWLINE> b = l ( ) <NEWLINE> b . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in b : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= i <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> count = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for l in range ( N ) : <NEWLINE> <INDENT> j = i + l <NEWLINE> k = j + l <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( pow ( m , n , 1000000007 ) ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> S = input ( ) <NEWLINE> is_flag = True <NEWLINE> while is_flag : <NEWLINE> <COMMENT> <NL> <INDENT> if len ( S ) >= 5 : <NEWLINE> <INDENT> temp = S [ : 5 ] <NEWLINE> <COMMENT> <NL> if temp == <STRING> : <NEWLINE> <INDENT> S = S [ 5 : ] <NEWLINE> if len ( S ) != 0 : <NEWLINE> <INDENT> if S [ : 5 ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif S [ : 2 ] == <STRING> : <NEWLINE> <INDENT> S = S [ 2 : ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif temp == <STRING> : <NEWLINE> <INDENT> S = S [ 5 : ] <NEWLINE> if len ( S ) != 0 : <NEWLINE> <INDENT> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> S = S [ 1 : ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> is_flag = False <NEWLINE> <DEDENT> <DEDENT> elif len ( S ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> is_flag = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> is_flag = False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> R = len ( [ s for s in S if s == <STRING> ] ) <NEWLINE> G = len ( [ s for s in S if s == <STRING> ] ) <NEWLINE> B = len ( [ s for s in S if s == <STRING> ] ) <NEWLINE> <NL> out = R * G * B <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> intvl = math . ceil ( ( N - i ) / 2 ) <NEWLINE> for j in range ( 1 , intvl ) : <NEWLINE> <INDENT> if S [ i ] != S [ i + j ] and S [ i + j ] != S [ i + 2 * j ] and S [ i ] != S [ i + 2 * j ] : <NEWLINE> <INDENT> out -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( out ) <NEWLINE>
input_line = input ( ) . split ( ) <NEWLINE> a = int ( input_line [ 0 ] ) <NEWLINE> b = int ( input_line [ 1 ] ) <NEWLINE> print ( a * b , a * 2 + b * 2 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i + k ] > a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( 5 ) ] <NEWLINE> ans = math . ceil ( n / min ( a ) ) + 4 <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> S = sum ( A ) % mod <NEWLINE> ans = 0 <NEWLINE> <NL> for x in A : <NEWLINE> <INDENT> S -= x <NEWLINE> S %= mod <NEWLINE> ans += S * x <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> ans %= mod <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <COMMENT> <NEWLINE> Amax = A [ - 1 ] <NEWLINE> dp = [ 1 ] * ( Amax + 1 ) <COMMENT> <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> p = A [ i ] <NEWLINE> if dp [ p ] == 1 : <COMMENT> <NEWLINE> <INDENT> for q in range ( Amax // p + 1 ) : <NEWLINE> <INDENT> dp [ p * q ] = 0 <COMMENT> <NEWLINE> <DEDENT> if A [ i ] != A [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if dp [ Amax ] == 1 : <COMMENT> <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> t = sum ( a ) ; v = w = 1 <NEWLINE> for q in a : <NEWLINE> <INDENT> if ( w : = min ( 2 * ( w - q ) , t : = t - q ) ) < 0 : exit ( print ( - 1 ) ) <NEWLINE> v += w <NEWLINE> <DEDENT> print ( v ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_CumulativeSum = [ 0 ] <NEWLINE> B_CumulativeSum = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A_CumulativeSum . append ( A [ i ] + A_CumulativeSum [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B_CumulativeSum . append ( B [ i ] + B_CumulativeSum [ i ] ) <NEWLINE> <NL> <DEDENT> if A_CumulativeSum [ n - 1 ] + B_CumulativeSum [ m - 1 ] <= k : <NEWLINE> <INDENT> print ( n + m ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> time = A_CumulativeSum [ i ] <NEWLINE> if time > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> time_b = k - time <NEWLINE> while time_b < B_CumulativeSum [ j ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <DEDENT> count = i + j <NEWLINE> ans = max ( count , ans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> m , f , r = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> total = m + f <NEWLINE> if m == - 1 or f == - 1 or total < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif total < 50 and r < 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif total < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif total < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from bisect import bisect_left <NEWLINE> <NL> while True : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> if not d : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> stores = { 0 , d } <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> stores . add ( int ( input ( ) ) ) <NEWLINE> <DEDENT> sorted_stores = sorted ( stores ) <NEWLINE> <NL> total_dist = 0 <NEWLINE> while m : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> i = bisect_left ( sorted_stores , k ) <NEWLINE> if i : <NEWLINE> <INDENT> l , r = sorted_stores [ i - 1 : i + 1 ] <NEWLINE> total_dist += min ( k - l , r - k ) <NEWLINE> <DEDENT> m -= 1 <NEWLINE> <DEDENT> print ( total_dist ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> print ( a [ 0 ] + a [ 1 ] + a [ 2 ] ) <NEWLINE>
class Dice ( ) : <NEWLINE> <INDENT> def __init__ ( self , nums ) : <NEWLINE> <INDENT> self . nums = nums <NEWLINE> self . top , self . front , self . right = 0 , 1 , 2 <NEWLINE> <NL> <DEDENT> def __eq__ ( self , dice ) : <NEWLINE> <INDENT> for x in <STRING> : <NEWLINE> <INDENT> dice . move ( x ) <NEWLINE> for _ in range ( 4 ) : <NEWLINE> <INDENT> dice . move ( <STRING> ) <NEWLINE> if self . nums [ self . top ] == dice . nums [ dice . top ] and self . nums [ self . front ] == dice . nums [ dice . front ] and self . nums [ self . right ] == dice . nums [ dice . right ] and self . nums [ 5 - self . top ] == dice . nums [ 5 - dice . top ] and self . nums [ 5 - self . front ] == dice . nums [ 5 - dice . front ] and self . nums [ 5 - self . right ] == dice . nums [ 5 - dice . right ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def move ( self , op ) : <NEWLINE> <INDENT> for c in op : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> self . top , self . front = self . front , 5 - self . top <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> self . top , self . front = 5 - self . front , self . top <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> self . top , self . right = 5 - self . right , self . top <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . top , self . right = self . right , 5 - self . top <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dice1 = Dice ( [ int ( n ) for n in input ( ) . split ( ) ] ) <NEWLINE> dice2 = Dice ( [ int ( n ) for n in input ( ) . split ( ) ] ) <NEWLINE> if dice1 == dice2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> X = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> L = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> L [ i + 1 ] = L [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ i + 1 ] = L [ i ] <NEWLINE> <DEDENT> <DEDENT> L [ N ] = L [ N - 1 ] <NEWLINE> for x in X : <NEWLINE> <INDENT> print ( L [ x [ 1 ] - 1 ] - L [ x [ 0 ] - 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = 1 <NEWLINE> B = 1 <NEWLINE> d = 0 <NEWLINE> e = 0 <NEWLINE> <NL> while A < N : <NEWLINE> <INDENT> while A * B < N : <NEWLINE> <INDENT> if A == B : <NEWLINE> <INDENT> e += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> B += 1 <NEWLINE> <DEDENT> A += 1 <NEWLINE> B = A <NEWLINE> <NL> <DEDENT> print ( d * 2 + e ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> r = min ( b - 1 , n ) <NEWLINE> c = int ( a * r / b ) - a * int ( r / b ) <NEWLINE> print ( c ) <NEWLINE>
import numpy as np <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = a [ 0 ] <NEWLINE> n = a [ 1 ] <NEWLINE> <NL> if ( n == 0 ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> min_int = d [ np . argmin ( d ) ] <NEWLINE> max_int = d [ np . argmax ( d ) ] <NEWLINE> if ( x < min_int or max_int < x ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = [ ] <NEWLINE> for var in range ( min_int - 10 , max_int + 10 ) : <NEWLINE> <INDENT> if var not in d : <NEWLINE> <INDENT> p . append ( var ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for pp in p : <NEWLINE> <INDENT> ans . append ( np . abs ( pp - x ) ) <NEWLINE> <DEDENT> ans = np . array ( ans ) <NEWLINE> print ( p [ np . argmin ( ans ) ] ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> <NL> <NL> def search ( H , W , S , start ) : <NEWLINE> <INDENT> wall_i = ord ( <STRING> ) <NEWLINE> used = [ [ - 1 for h in range ( W ) ] for w in range ( H ) ] <NEWLINE> <NL> qu = collections . deque ( ) <NEWLINE> qu . append ( start ) <NEWLINE> used [ start [ 0 ] ] [ start [ 1 ] ] = 0 <NEWLINE> <NL> while qu : <NEWLINE> <INDENT> h , w = qu . popleft ( ) <NEWLINE> cost = used [ h ] [ w ] <NEWLINE> for h0 , w0 in ( ( h - 1 , w ) , ( h + 1 , w ) , ( h , w - 1 ) , ( h , w + 1 ) ) : <NEWLINE> <INDENT> if not ( 0 <= h0 < H and 0 <= w0 < W ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if used [ h0 ] [ w0 ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ h0 ] [ w0 ] == wall_i : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> used [ h0 ] [ w0 ] = cost + 1 <NEWLINE> qu . append ( ( h0 , w0 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> return max ( cost for costs in used for cost in costs ) <NEWLINE> <NL> <NL> <DEDENT> def resolve ( in_ ) : <NEWLINE> <INDENT> H , W = map ( int , next ( in_ ) . split ( ) ) <NEWLINE> S = tuple ( s . strip ( ) for s in itertools . islice ( in_ , H ) ) <NEWLINE> <NL> road_i = ord ( <STRING> ) <NEWLINE> <NL> roads = [ ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if S [ h ] [ w ] == road_i : <NEWLINE> <INDENT> roads . append ( ( h , w ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = max ( search ( H , W , S , start ) for start in roads ) <NEWLINE> <NL> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> answer = resolve ( sys . stdin . buffer ) <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = collections . defaultdict ( int ) <NEWLINE> for a in A : <NEWLINE> <INDENT> cnt [ a ] += 1 <NEWLINE> <DEDENT> ans = sum ( A ) <NEWLINE> <NL> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += ( C - B ) * cnt [ B ] <NEWLINE> cnt [ C ] += cnt [ B ] <NEWLINE> cnt [ B ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ 0 ] * d <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> lis = [ 0 ] * 26 <NEWLINE> sum_score = 0 <NEWLINE> for i in range ( d ) : <COMMENT> <NEWLINE> <INDENT> ans = - float ( <STRING> ) <NEWLINE> num = 0 <NEWLINE> for j in range ( 26 ) : <COMMENT> <NEWLINE> <INDENT> score = 0 <NEWLINE> score += s [ i ] [ j ] <NEWLINE> for k in range ( 26 ) : <NEWLINE> <INDENT> if k != j : <NEWLINE> <INDENT> score -= ( lis [ k ] + 1 ) * c [ k ] <NEWLINE> <DEDENT> <DEDENT> if score > ans : <NEWLINE> <INDENT> ans = score <NEWLINE> num = j <NEWLINE> <DEDENT> <DEDENT> sum_score += ans <NEWLINE> <COMMENT> <NL> print ( num + 1 ) <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> if j != num : <NEWLINE> <INDENT> lis [ j ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis [ j ] = 0 <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] -= i + 1 <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> total = sum ( A ) <NEWLINE> mean1 = total // N <NEWLINE> mean2 = total // N + 1 <NEWLINE> med1 = A [ N // 2 ] <NEWLINE> <COMMENT> <NL> ans1 = 0 <NEWLINE> ans2 = 0 <NEWLINE> ans3 = 0 <NEWLINE> ans4 = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans1 += abs ( a - mean1 ) <NEWLINE> ans2 += abs ( a - mean2 ) <NEWLINE> ans3 += abs ( a - med1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( min ( [ ans1 , ans2 , ans3 ] ) ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> i = 2 <NEWLINE> a = [ ] <NEWLINE> x = n <NEWLINE> while ( i * i <= n ) : <NEWLINE> <INDENT> if ( n % i == 0 ) : <NEWLINE> <INDENT> a . append ( i ) <NEWLINE> n //= i <NEWLINE> while ( n % i == 0 ) : <NEWLINE> <INDENT> n //= i <NEWLINE> a . append ( a [ - 1 ] * i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> if ( n != 1 ) : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> a . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> while ( x != 1 and len ( a ) ) : <NEWLINE> <INDENT> while ( x % a [ - 1 ] ) : <NEWLINE> <INDENT> a . pop ( ) <NEWLINE> if ( len ( a ) == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ( len ( a ) == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x //= a [ - 1 ] <NEWLINE> a . pop ( ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for i in range ( 0 , 11 ) : <NEWLINE> <INDENT> if ( 1000 * i ) - N >= 0 : <NEWLINE> <INDENT> ans . append ( ( 1000 * i ) - N ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( ans ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lr = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> l = 1 <NEWLINE> r = n <NEWLINE> for i , j in lr : <NEWLINE> <INDENT> l = max ( i , l ) <NEWLINE> r = min ( j , r ) <NEWLINE> <DEDENT> print ( max ( r - l + 1 , 0 ) ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> X = abs ( X ) <NEWLINE> if X >= K * D : <NEWLINE> <INDENT> ans = X - K * D <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> n , d = divmod ( X , D ) <NEWLINE> ans = d <NEWLINE> if ( K - n ) % 2 : <NEWLINE> <INDENT> ans = D - d <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> ar = [ [ ] for i in range ( n ) ] <NEWLINE> br = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> ar [ x - 1 ] . append ( y - 1 ) <NEWLINE> ar [ y - 1 ] . append ( x - 1 ) <NEWLINE> <DEDENT> cr = [ 0 ] <NEWLINE> dr = [ ] <NEWLINE> for r in cr : <NEWLINE> <INDENT> for i in ar [ r ] : <NEWLINE> <INDENT> if br [ i ] == 0 : <NEWLINE> <INDENT> br [ i ] = r + 1 <NEWLINE> cr . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( br [ i ] ) <NEWLINE> <DEDENT>
from numba import jit <NEWLINE> @ jit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = - 10 ** 10 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> start , count = i , 1 <NEWLINE> val = c [ start ] <NEWLINE> while p [ start ] - 1 != i : <NEWLINE> <INDENT> start = p [ start ] - 1 <NEWLINE> count += 1 <NEWLINE> val += c [ start ] <NEWLINE> <NL> <DEDENT> start = i <NEWLINE> if val > 0 : <NEWLINE> <INDENT> a = ( k // count - 1 ) * val <NEWLINE> ans = max ( a , ans ) <NEWLINE> num = k % count + count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> num = min ( k , count ) <NEWLINE> <NL> <DEDENT> for _ in range ( num ) : <NEWLINE> <INDENT> start = p [ start ] - 1 <NEWLINE> a += c [ start ] <NEWLINE> ans = max ( a , ans ) <NEWLINE> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
x , n , * p = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> print ( min ( { * range ( 999 ) } - { * p } , key = lambda y : abs ( y - x ) ) ) <NEWLINE>
import bisect <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> l_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l_lst . sort ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <NL> <INDENT> a = l_lst [ i ] <NEWLINE> b = l_lst [ j ] <NEWLINE> tmp = bisect . bisect_left ( l_lst , a + b ) <NEWLINE> tmp -= j + 1 <NEWLINE> tmp = max ( 0 , tmp ) <NEWLINE> count += tmp <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 2 * ( 10 ** 6 ) ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for i in range ( n ) ] <NEWLINE> visit = [ False for i in range ( n ) ] <NEWLINE> def dfs ( v ) : <NEWLINE> <INDENT> visit [ v ] = True <NEWLINE> for i in edges [ v ] : <NEWLINE> <INDENT> if not visit [ i ] : <NEWLINE> <INDENT> dfs ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a - 1 ] . append ( b - 1 ) <NEWLINE> edges [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not visit [ i ] : <NEWLINE> <INDENT> dfs ( i ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt - 1 ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> for a in range ( 200 ) : <NEWLINE> <INDENT> for b in range ( 200 ) : <NEWLINE> <INDENT> if pow ( a , 5 ) - pow ( b , 5 ) == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if pow ( - a , 5 ) - pow ( b , 5 ) == x : <NEWLINE> <INDENT> print ( - a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if pow ( a , 5 ) - pow ( - b , 5 ) == x : <NEWLINE> <INDENT> print ( a , - b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if pow ( - a , 5 ) - pow ( - b , 5 ) == x : <NEWLINE> <INDENT> print ( - a , - b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> readline = sys . stdin . readline <NEWLINE> <NL> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> h = [ int ( x ) for x in readline ( ) . split ( ) ] <NEWLINE> <NL> inf = float ( <STRING> ) <NEWLINE> dp = [ inf ] * N <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> leng = i + 1 if i < K else K + 1 <NEWLINE> for j in range ( leng ) : <NEWLINE> <INDENT> cal = dp [ i - j ] + abs ( h [ i ] - h [ i - j ] ) <NEWLINE> if dp [ i ] > cal : <NEWLINE> <INDENT> dp [ i ] = cal <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> resolve ( ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += ( ( N // i ) * ( i + ( N // i ) * i ) ) / 2 <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if N > M : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst . sort ( ) <NEWLINE> sum_1 = max ( lst ) - min ( lst ) <NEWLINE> D = [ ] <NEWLINE> for i in range ( 1 , M ) : <NEWLINE> <INDENT> D . append ( lst [ i ] - lst [ i - 1 ] ) <NEWLINE> <DEDENT> D . sort ( reverse = True ) <NEWLINE> sum_2 = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> sum_2 += D [ i ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> ans = sum_1 - sum_2 <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> lines = sys . stdin . readlines ( ) <NEWLINE> <NL> X = lines [ 0 ] . split ( <STRING> ) <NEWLINE> N = int ( X [ 0 ] ) <NEWLINE> M = int ( X [ 1 ] ) <NEWLINE> <NL> H = [ ] <NEWLINE> Y = [ ] <NEWLINE> <NL> H = lines [ 1 ] . split ( <STRING> ) <NEWLINE> <NL> for j in range ( M ) : <NEWLINE> <INDENT> A = int ( lines [ j + 2 ] . split ( <STRING> ) [ 0 ] ) <NEWLINE> B = int ( lines [ j + 2 ] . split ( <STRING> ) [ 1 ] ) <NEWLINE> if int ( H [ A - 1 ] ) <= int ( H [ B - 1 ] ) : <NEWLINE> <INDENT> Y . append ( A - 1 ) <NEWLINE> <DEDENT> if int ( H [ B - 1 ] ) <= int ( H [ A - 1 ] ) : <NEWLINE> <INDENT> Y . append ( B - 1 ) <NEWLINE> <DEDENT> <DEDENT> Z = len ( set ( Y ) ) <NEWLINE> print ( N - Z ) <NEWLINE>
ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> re += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , ac ) <NEWLINE> print ( <STRING> , wa ) <NEWLINE> print ( <STRING> , tle ) <NEWLINE> print ( <STRING> , re ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> num = input ( ) . split ( ) <NEWLINE> <NL> l = 0 <NEWLINE> ass = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> l += int ( num [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> l -= int ( num [ i ] ) <NEWLINE> ass += int ( num [ i ] ) * l <NEWLINE> <NL> <NL> <DEDENT> ans = ass % ( 10 ** 9 + 7 ) <NEWLINE> print ( ans ) <NEWLINE>
from collections import Counter , defaultdict , deque <NEWLINE> from heapq import heappop , heappush , heapify <NEWLINE> import sys , bisect , math , itertools , fractions , pprint <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def inp ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> k = inp ( ) <NEWLINE> res = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> xx = gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> res += gcd ( xx , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> T = 0 <NEWLINE> s = <STRING> <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> q = list ( input ( ) . split ( ) ) <NEWLINE> if q [ 0 ] == <STRING> : <NEWLINE> <INDENT> T = ( T + 1 ) % 2 <NEWLINE> <DEDENT> elif ( T == 0 and q [ 1 ] == <STRING> ) or ( T == 1 and q [ 1 ] == <STRING> ) : <NEWLINE> <INDENT> s += q [ 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S += q [ 2 ] <NEWLINE> <DEDENT> <DEDENT> if T == 0 : <NEWLINE> <INDENT> S = s [ : : - 1 ] + S <NEWLINE> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = S [ : : - 1 ] + s <NEWLINE> print ( S ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if k >= n : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> H . sort ( reverse = True ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> H [ i ] = 0 <NEWLINE> <NL> <DEDENT> print ( sum ( H ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for n in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n <= 3000 : <NEWLINE> <INDENT> for a in range ( 1 , 3501 ) : <NEWLINE> <INDENT> for b in range ( 1 , 3501 ) : <NEWLINE> <INDENT> s = n * a * b <NEWLINE> <COMMENT> <NL> t = 4 * a * b - n * b - n * a <NEWLINE> <COMMENT> <NL> if s <= t * 3500 : <NEWLINE> <INDENT> if t != 0 and s % t == 0 and t > 0 : <NEWLINE> <INDENT> c = s // t <NEWLINE> print ( a , b , c ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for a in range ( 3501 , 1 , - 1 ) : <NEWLINE> <INDENT> for b in range ( 3501 , 1 , - 1 ) : <NEWLINE> <INDENT> s = n * a * b <NEWLINE> <COMMENT> <NL> t = 4 * a * b - n * b - n * a <NEWLINE> <COMMENT> <NL> if s <= t * 3500 : <NEWLINE> <INDENT> if t != 0 and s % t == 0 and t > 0 : <NEWLINE> <INDENT> c = s // t <NEWLINE> print ( a , b , c ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> elif N == 100 : <NEWLINE> <INDENT> if X <= 50 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 101 ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> abs_list = [ ] <NEWLINE> re_list = [ ] <NEWLINE> min = 1000 <NEWLINE> min_index = 0 <NEWLINE> <NL> for i in range ( 250 ) : <NEWLINE> <INDENT> abs_list . append ( - 100 + i ) <NEWLINE> <DEDENT> for j in p : <NEWLINE> <INDENT> abs_list . remove ( j ) <NEWLINE> <DEDENT> for i in range ( len ( abs_list ) ) : <NEWLINE> <NL> <INDENT> re_list . append ( abs ( abs_list [ i ] - X ) ) <NEWLINE> <DEDENT> for i in range ( len ( re_list ) ) : <NEWLINE> <INDENT> if min > re_list [ i ] : <NEWLINE> <INDENT> min = re_list [ i ] <NEWLINE> min_index = i <NEWLINE> <DEDENT> <DEDENT> if re_list [ min_index ] > X : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs_list [ min_index ] ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> <NL> n = int ( s ) <NEWLINE> <NL> answer = [ ] <NEWLINE> <NL> x = 1 <NEWLINE> answer . append ( x ) <NEWLINE> <NL> while ( x * x <= n ) : <NEWLINE> <INDENT> x += 1 <NEWLINE> answer . append ( x * x ) <NEWLINE> <NL> <DEDENT> p = answer . pop ( ) <NEWLINE> if p == 1 : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = answer . pop ( ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sa = [ ] <NEWLINE> num = [ ] <NEWLINE> for i in range ( - 110 , 110 ) : <NEWLINE> <INDENT> if i in p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> sa . append ( abs ( x - i ) ) <NEWLINE> num . append ( i ) <NEWLINE> <NL> <DEDENT> print ( num [ sa . index ( min ( sa ) ) ] ) <NEWLINE>
lin = input ( ) <NEWLINE> l = lin . split ( <STRING> ) <NEWLINE> a = int ( l [ 0 ] ) <NEWLINE> b = int ( l [ 1 ] ) <NEWLINE> c = int ( l [ 2 ] ) <NEWLINE> <NL> l = [ a , b , c ] <NEWLINE> l . sort ( ) <NEWLINE> <NL> print ( str ( l [ 0 ] ) + <STRING> + str ( l [ 1 ] ) + <STRING> + str ( l [ 2 ] ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 : break <NEWLINE> print ( <STRING> * b ) <NEWLINE> for i in range ( a - 2 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( b - 2 ) + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * b ) <NEWLINE> print ( ) <NEWLINE> <DEDENT>
<NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> inds = sorted ( range ( len ( As ) ) , key = lambda k : As [ k ] ) [ : : - 1 ] <NEWLINE> <COMMENT> <NL> <NL> ds = [ 0 ] <NEWLINE> for xy in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> i = inds [ xy - 1 ] <NEWLINE> a = As [ i ] <NEWLINE> nds = [ 0 ] * ( xy + 1 ) <NEWLINE> nds [ - 1 ] = ds [ - 1 ] + a * ( i - ( xy - 1 ) ) <NEWLINE> nds [ 0 ] = ds [ 0 ] + a * ( N - xy - i ) <NEWLINE> <NL> for x in range ( 1 , xy ) : <NEWLINE> <INDENT> y = xy - x <NEWLINE> c1 = ds [ x - 1 ] + a * abs ( i - ( x - 1 ) ) <NEWLINE> c2 = ds [ x ] + a * abs ( N - y - i ) <NEWLINE> nds [ x ] = max ( c1 , c2 ) <NEWLINE> <DEDENT> ds = nds . copy ( ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> print ( max ( ds ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( int ( input ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total = 0 <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lis . sort ( ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> total += lis [ i ] <NEWLINE> <DEDENT> print ( total ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab [ a - 1 ] . append ( b - 1 ) <NEWLINE> ab [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> visit = [ False ] * n <NEWLINE> cnt = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ p - 1 ] += x <NEWLINE> <DEDENT> q = [ ( 0 , 0 ) ] <NEWLINE> while q : <NEWLINE> <INDENT> v , a = q . pop ( ) <NEWLINE> visit [ v ] = True <NEWLINE> a += cnt [ v ] <NEWLINE> cnt [ v ] = a <NEWLINE> for i in ab [ v ] : <NEWLINE> <INDENT> if visit [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . append ( ( i , a ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> print ( <STRING> . join ( input ( ) . split ( ) [ : : - 1 ] ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 0 <NEWLINE> dx = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if i > x : <NEWLINE> <INDENT> x = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dx += ( x - i ) <NEWLINE> <DEDENT> <DEDENT> print ( dx ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for e in a : <NEWLINE> <INDENT> ans *= e <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> x1 , y1 , x2 , y2 = input ( ) . split ( ) <NEWLINE> <NL> X = float ( x2 ) - float ( x1 ) <NEWLINE> Y = float ( y2 ) - float ( y1 ) <NEWLINE> <NL> length = math . sqrt ( X ** 2 + Y ** 2 ) <NEWLINE> print ( length ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for a in range ( 1 , n ) : c += ( n - 1 ) // a <NEWLINE> print ( c ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> INP = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list1 = [ INP [ 0 ] , INP [ 1 ] ] <NEWLINE> list2 = [ INP [ 2 ] , INP [ 3 ] ] <NEWLINE> if INP [ 0 ] < 0 and INP [ 1 ] > 0 : <NEWLINE> <INDENT> list1 . extend ( [ - 1 , 0 , 1 ] ) <NEWLINE> <DEDENT> if INP [ 2 ] < 0 and INP [ 3 ] > 0 : <NEWLINE> <INDENT> list2 . extend ( [ - 1 , 0 , 1 ] ) <NEWLINE> <DEDENT> ans = - ( 10 ** 18 ) <NEWLINE> for item in list1 : <NEWLINE> <INDENT> for item2 in list2 : <NEWLINE> <INDENT> ans = max ( ans , item * item2 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dist = { } <NEWLINE> for idx , d in enumerate ( A ) : <NEWLINE> <INDENT> dist [ idx + 1 ] = d <NEWLINE> <NL> <DEDENT> n = 1 <NEWLINE> hist = [ 1 ] <NEWLINE> already = { 1 } <NEWLINE> flag = True <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> n = dist [ n ] <NEWLINE> if n in already : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> already . add ( n ) <NEWLINE> hist . append ( n ) <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start = hist . index ( n ) <NEWLINE> loop = hist [ start : ] <NEWLINE> print ( loop [ ( K - start ) % len ( loop ) ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> if A [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for a in A [ : : - 1 ] : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] + A <COMMENT> <NEWLINE> visited = [ 0 ] * ( N + 1 ) <NEWLINE> town = 1 <NEWLINE> cycle = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> town = A [ town ] <NEWLINE> if visited [ town ] == 0 : <NEWLINE> <INDENT> visited [ town ] = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cycle = i - visited [ town ] <NEWLINE> place = ( K - visited [ town ] ) % cycle + visited [ town ] <NEWLINE> for j in range ( N + 1 ) : <NEWLINE> <INDENT> if visited [ j ] == place : <NEWLINE> <INDENT> print ( j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( town ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> dp = [ - 7 for _ in range ( n + 1 ) ] <NEWLINE> <NL> dp [ 0 ] = 1000 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> buy = dp [ j ] // l [ j ] <NEWLINE> tmp = dp [ j ] % l [ j ] + buy * l [ i - 1 ] <NEWLINE> dp [ i ] = max ( dp [ i ] , tmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> from collections import deque <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> x1 -= 1 <NEWLINE> y1 -= 1 <NEWLINE> x2 -= 1 <NEWLINE> y2 -= 1 <NEWLINE> mas = [ list ( input ( ) ) for i in range ( H ) ] <NEWLINE> <NL> dist = [ [ - 1 ] * W for i in range ( H ) ] <NEWLINE> dist [ x1 ] [ y1 ] = 0 <NEWLINE> <NL> qu = deque ( [ ( x1 , y1 ) ] ) <NEWLINE> qup = qu . popleft <NEWLINE> qua = qu . append <NEWLINE> <NL> d = ( ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ) <NEWLINE> <NL> while ( len ( qu ) > 0 ) : <NEWLINE> <INDENT> v = qup ( ) <NEWLINE> for di in d : <NEWLINE> <INDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> nvh = v [ 0 ] + i * di [ 0 ] <NEWLINE> nvw = v [ 1 ] + i * di [ 1 ] <NEWLINE> if nvh < 0 or nvh >= H or nvw < 0 or nvw >= W or mas [ nvh ] [ nvw ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if dist [ nvh ] [ nvw ] != - 1 and dist [ nvh ] [ nvw ] <= dist [ v [ 0 ] ] [ v [ 1 ] ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if dist [ nvh ] [ nvw ] == - 1 : <NEWLINE> <INDENT> dist [ nvh ] [ nvw ] = dist [ v [ 0 ] ] [ v [ 1 ] ] + 1 <NEWLINE> qua ( ( nvh , nvw ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dist [ x2 ] [ y2 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> num = [ 0 ] * n <NEWLINE> sc = [ ] <NEWLINE> S = 0 <NEWLINE> C = 1 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> sc . append ( [ s - 1 , c ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( 1000 ) : <NEWLINE> <INDENT> ok = True <NEWLINE> string = str ( i ) <NEWLINE> if len ( string ) == n : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> if string [ sc [ j ] [ S ] ] != str ( sc [ j ] [ C ] ) : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
S = input ( ) [ : : - 1 ] <NEWLINE> <NL> modCount = [ 0 ] * 2019 <NEWLINE> modCount [ 0 ] = 1 <NEWLINE> mod = 0 <NEWLINE> dig = 1 <NEWLINE> result = 0 <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> mod = ( int ( S [ i : i + 1 ] ) * dig + mod ) % 2019 <NEWLINE> dig = ( dig * 10 ) % 2019 <NEWLINE> result += modCount [ mod ] <NEWLINE> modCount [ mod ] += 1 <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
ABN = input ( ) . split ( ) <NEWLINE> A = int ( ABN [ 0 ] ) <NEWLINE> B = int ( ABN [ 1 ] ) <NEWLINE> N = int ( ABN [ 2 ] ) <NEWLINE> <NL> answer = 0 <NEWLINE> temp = 0 <NEWLINE> <NL> if N >= B : <NEWLINE> <INDENT> answer = A * ( B - 1 ) // B - A * ( ( B - 1 ) // B ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> answer = A * N // B - A * ( N // B ) <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> <NL> <NL> def find_square ( data ) : <NEWLINE> <INDENT> max_size = 0 <NEWLINE> lmap = [ ] <NEWLINE> for row in data : <NEWLINE> <INDENT> temp = [ 0 ] <NEWLINE> for c in row : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> temp . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> lmap . append ( temp ) <NEWLINE> temp = [ 0 ] <NEWLINE> <NL> <DEDENT> prev_row = lmap [ 0 ] <NEWLINE> for curr_row in lmap [ 1 : ] : <NEWLINE> <INDENT> for x in range ( 1 , len ( lmap [ 0 ] ) ) : <NEWLINE> <INDENT> if curr_row [ x ] == 1 : <NEWLINE> <INDENT> if prev_row [ x - 1 ] != 0 and prev_row [ x ] != 0 and curr_row [ x - 1 ] != 0 : <NEWLINE> <INDENT> curr_row [ x ] = min ( prev_row [ x - 1 ] , min ( prev_row [ x ] , curr_row [ x - 1 ] ) ) + 1 <NEWLINE> if curr_row [ x ] > max_size : <NEWLINE> <INDENT> max_size = curr_row [ x ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> prev_row = curr_row <NEWLINE> <DEDENT> return max_size <NEWLINE> <NL> <NL> <DEDENT> def main ( args ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> data = [ input ( ) for _ in range ( n ) ] <NEWLINE> result = find_square ( data ) <NEWLINE> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> C = input ( ) <NEWLINE> <NL> from collections import Counter <NEWLINE> <NL> if <STRING> not in C : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> <NL> c = Counter ( C ) <NEWLINE> k = c [ <STRING> ] <NEWLINE> D = C [ : k ] <NEWLINE> d = Counter ( D ) <NEWLINE> print ( d [ <STRING> ] ) <NEWLINE>
import numpy as np <NEWLINE> import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = np . array ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = [ map ( int , input ( ) . split ( ) ) for _ in range ( q ) ] <NEWLINE> b , c = [ list ( i ) for i in zip ( * bc ) ] <NEWLINE> <NL> count_dict = collections . Counter ( a ) <NEWLINE> ans = np . sum ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if count_dict [ b [ i ] ] > 0 : <NEWLINE> <INDENT> ans += count_dict [ b [ i ] ] * ( c [ i ] - b [ i ] ) <NEWLINE> count_dict [ c [ i ] ] += count_dict [ b [ i ] ] <NEWLINE> count_dict [ b [ i ] ] = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> print ( <STRING> if A [ i + k - 1 ] > A [ i - 1 ] else <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> marks = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> j = i + k <NEWLINE> while j < n : <NEWLINE> <INDENT> if marks [ j ] > marks [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT>
input ( ) <NEWLINE> <NL> a = input ( ) . split ( ) <NEWLINE> <NL> a . reverse ( ) <NEWLINE> print ( <STRING> . join ( a ) ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> for i in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for j in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class Dice : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . omote = 1 <NEWLINE> self . sita = 2 <NEWLINE> self . migi = 3 <NEWLINE> self . ue = 5 <NEWLINE> self . hidari = 4 <NEWLINE> self . ura = 6 <NEWLINE> <NL> <DEDENT> def North ( self ) : <NEWLINE> <INDENT> self . omote , self . ue , self . ura , self . sita = self . sita , self . omote , self . ue , self . ura <NEWLINE> <NL> <DEDENT> def East ( self ) : <NEWLINE> <INDENT> self . omote , self . hidari , self . ura , self . migi = self . hidari , self . ura , self . migi , self . omote <NEWLINE> <NL> <DEDENT> def West ( self ) : <NEWLINE> <INDENT> self . omote , self . migi , self . ura , self . hidari = self . migi , self . ura , self . hidari , self . omote <NEWLINE> <NL> <DEDENT> def South ( self ) : <NEWLINE> <INDENT> self . omote , self . ue , self . ura , self . sita = self . ue , self . ura , self . sita , self . omote <NEWLINE> <NL> <DEDENT> def Right ( self ) : <NEWLINE> <INDENT> self . sita , self . migi , self . ue , self . hidari = self . migi , self . ue , self . hidari , self . sita <NEWLINE> <NL> <DEDENT> def Left ( self ) : <NEWLINE> <INDENT> self . sita , self . hidari , self . ue , self . migi = self . hidari , self . ue , self . migi , self . sita <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> while ( n != 0 ) : <NEWLINE> <INDENT> sum = 1 <NEWLINE> dice = Dice ( ) <NEWLINE> dice_def = { <STRING> : dice . North , <STRING> : dice . East , <STRING> : dice . South , <STRING> : dice . West , <STRING> : dice . Right , <STRING> : dice . Left } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dice_def [ input ( ) . strip ( ) ] ( ) <NEWLINE> sum += dice . omote <NEWLINE> <DEDENT> print ( sum ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> <DEDENT>
from itertools import permutations <NEWLINE> import numpy as np <NEWLINE> N , C = map ( int , input ( ) . split ( ) ) <NEWLINE> D = np . ndarray ( ( C , C ) , dtype = int ) <NEWLINE> c = np . ndarray ( ( N , N ) , dtype = int ) <NEWLINE> for i in range ( C ) : <NEWLINE> <INDENT> D [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> c [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> c -= 1 <NEWLINE> acc = np . zeros ( ( 3 , C ) , dtype = int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> acc [ ( i + j ) % 3 ] += D [ c [ i ] [ j ] ] <NEWLINE> <DEDENT> <DEDENT> ans = float ( <STRING> ) <NEWLINE> for i , j , k in permutations ( range ( C ) , r = 3 ) : <NEWLINE> <INDENT> ans = min ( ans , acc [ 0 ] [ i ] + acc [ 1 ] [ j ] + acc [ 2 ] [ k ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = np . array ( A ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> ruisekiwa = np . zeros ( N , dtype = <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ruisekiwa [ i ] = ruisekiwa [ i - 1 ] + A [ i ] <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> res += ( ruisekiwa [ N - 1 ] - ruisekiwa [ i ] ) % MOD * A [ i ] % MOD <NEWLINE> <DEDENT> print ( res % MOD ) <NEWLINE> <NL> <COMMENT> <NL> <NEWLINE>
import math <NEWLINE> import functools <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> gcd_list = [ [ float ( <STRING> ) for i in range ( K + 1 ) ] for j in range ( K + 1 ) ] <NEWLINE> <COMMENT> <NL> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> gcd_list [ i ] [ j ] = math . gcd ( i , j ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> mysum = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> mygcd = gcd_list [ i ] [ j ] <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> mygcd2 = math . gcd ( mygcd , k ) <NEWLINE> mysum += mygcd2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( mysum ) <NEWLINE>
def BinarySearch ( n , key , A ) : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = n <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = ( int ) ( ( left + right ) / 2 ) <NEWLINE> if A [ mid ] == key : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> if key < A [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> if key > A [ mid ] : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> <DEDENT> return 1 <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> S = [ 0 for i in range ( n ) ] <NEWLINE> S = input ( ) . split ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> S [ i ] = ( int ) ( S [ i ] ) <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> T = [ 0 for i in range ( q ) ] <NEWLINE> T = input ( ) . split ( ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> T [ i ] = ( int ) ( T [ i ] ) <NEWLINE> a = BinarySearch ( n , T [ i ] , S ) <NEWLINE> if a == 2 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> r_s = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> minv = r_s [ 0 ] <NEWLINE> maxv = r_s [ 1 ] - r_s [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> maxv = max ( maxv , r_s [ i ] - minv ) <NEWLINE> minv = min ( minv , r_s [ i ] ) <NEWLINE> <NL> <DEDENT> print ( maxv ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> def bfs ( u , result , out_edge , in_degree , processed ) : <NEWLINE> <COMMENT> <NL> <INDENT> q = deque ( ) <NEWLINE> q . append ( u ) <NEWLINE> processed [ u ] = True <NEWLINE> while q : <NEWLINE> <INDENT> u = q . popleft ( ) <NEWLINE> result . append ( u ) <NEWLINE> for e in out_edge [ u ] : <NEWLINE> <INDENT> in_degree [ e ] -= 1 <COMMENT> <NEWLINE> if in_degree [ e ] == 0 and processed [ e ] == False : <COMMENT> <NEWLINE> <INDENT> processed [ e ] = True <NEWLINE> q . append ( e ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def solve ( V , in_degree , out_edge ) : <NEWLINE> <COMMENT> <NL> <INDENT> result = [ ] <NEWLINE> processed = [ False for _ in range ( V ) ] <COMMENT> <NEWLINE> for i , u in enumerate ( in_degree ) : <NEWLINE> <INDENT> if u == 0 and processed [ i ] == False : <COMMENT> <NEWLINE> <INDENT> bfs ( i , result , out_edge , in_degree , processed ) <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> def decode_txt ( S ) : <NEWLINE> <COMMENT> <NL> <INDENT> es = set ( ) <NEWLINE> cars = set ( ) <COMMENT> <NEWLINE> l = len ( S ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( l ) : <NEWLINE> <INDENT> if not <STRING> <= S [ i ] <= <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> s = S [ i ] <NEWLINE> try : <NEWLINE> <INDENT> t = S [ i + 3 ] <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cars . add ( s ) <NEWLINE> cars . add ( t ) <NEWLINE> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> es . add ( ( s , t ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> es . add ( ( t , s ) ) <NEWLINE> <DEDENT> <DEDENT> return es , cars <NEWLINE> <NL> <NL> <DEDENT> def main ( args ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> S = input ( ) . strip ( ) <NEWLINE> if len ( S ) < 4 : <NEWLINE> <INDENT> print ( S ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> es_txt , cars = decode_txt ( S ) <NEWLINE> <NL> V = len ( cars ) <NEWLINE> num = 0 <NEWLINE> mapping = dict ( ) <NEWLINE> for c in cars : <NEWLINE> <INDENT> mapping [ c ] = num <NEWLINE> num += 1 <NEWLINE> <NL> <DEDENT> rev_mapping = dict ( zip ( mapping . values ( ) , mapping . keys ( ) ) ) <NEWLINE> es = [ ] <NEWLINE> for s , t in es_txt : <NEWLINE> <INDENT> es . append ( [ mapping [ s ] , mapping [ t ] ] ) <NEWLINE> <NL> <NL> <DEDENT> in_degree = [ 0 for _ in range ( V ) ] <COMMENT> <NEWLINE> out_edge = [ [ ] for _ in range ( V ) ] <COMMENT> <NEWLINE> for s , t in es : <NEWLINE> <INDENT> out_edge [ s ] . append ( t ) <NEWLINE> in_degree [ t ] += 1 <NEWLINE> <NL> <DEDENT> result = solve ( V , in_degree , out_edge ) <NEWLINE> txt = [ rev_mapping [ x ] for x in result ] <COMMENT> <NEWLINE> print ( <STRING> . join ( txt ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> return arr <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> l = factorization ( n ) <NEWLINE> ans = 0 <NEWLINE> for c in l : <NEWLINE> <INDENT> if c [ 0 ] == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> lim = c [ 1 ] <NEWLINE> num = 1 <NEWLINE> while lim >= num : <NEWLINE> <INDENT> lim -= num <NEWLINE> num += 1 <NEWLINE> <DEDENT> ans += num - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> hs = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> a = np . zeros ( N , int ) <NEWLINE> a [ 0 ] = 0 <NEWLINE> a [ 1 ] = abs ( hs [ 1 ] - hs [ 0 ] ) <NEWLINE> <NL> if N == 2 : <NEWLINE> <INDENT> print ( a [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 2 , N ) : <NEWLINE> <INDENT> b = a [ max ( i - K , 0 ) : i ] + np . abs ( hs [ i ] - hs [ max ( i - K , 0 ) : i ] ) <NEWLINE> a [ i ] = np . min ( b ) <NEWLINE> <DEDENT> print ( a [ - 1 ] ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> r = range ( 1 , k + 1 ) <NEWLINE> ans = sum ( [ gcd ( gcd ( a , b ) , c ) for a in r for b in r for c in r ] ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> amax = max ( a ) <NEWLINE> ans = 0 <NEWLINE> numlist = [ 0 ] * amax <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if numlist [ a [ i ] - 1 ] != 0 : <NEWLINE> <INDENT> numlist [ a [ i ] - 1 ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 1 , amax // a [ i ] + 1 ) : <NEWLINE> <INDENT> numlist [ a [ i ] * j - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if numlist [ a [ i ] - 1 ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> from collections import Counter <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> l = [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] <NEWLINE> n -= 1 <NEWLINE> i = 1 <NEWLINE> res = 0 <NEWLINE> ans = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> if n >= pow ( 26 , i ) + res : <NEWLINE> <INDENT> res += pow ( 26 , i ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> keta = i <NEWLINE> n -= res <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> for i in range ( keta ) : <NEWLINE> <INDENT> r = n % pow ( 26 , keta - i - 1 ) <NEWLINE> s = n // pow ( 26 , keta - i - 1 ) <NEWLINE> ans += l [ s ] <NEWLINE> n = r <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) . rstrip ( ) ) <NEWLINE> judge = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> hap_lst = list ( map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) ) <NEWLINE> if not judge : <NEWLINE> <INDENT> judge = hap_lst <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_0 , b_0 , c_0 = judge <NEWLINE> a_1 , b_1 , c_1 = hap_lst <NEWLINE> judge = [ a_1 + max ( b_0 , c_0 ) , b_1 + max ( a_0 , c_0 ) , c_1 + max ( a_0 , b_0 ) ] <NEWLINE> <DEDENT> <DEDENT> print ( max ( judge ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> root = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> root [ a - 1 ] . append ( b ) <NEWLINE> root [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> kakutei = [ 1 ] <NEWLINE> <NL> answer_li = [ 0 ] * n <NEWLINE> <NL> while kakutei : <NEWLINE> <INDENT> k = kakutei . pop ( 0 ) <NEWLINE> for r in root [ k - 1 ] : <NEWLINE> <INDENT> if answer_li [ r - 1 ] == 0 : <NEWLINE> <INDENT> kakutei . append ( r ) <NEWLINE> answer_li [ r - 1 ] = k <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> answer_li = answer_li [ 1 : ] <NEWLINE> if 0 in answer_li : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in answer_li : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = [ 0 ] * 8 <NEWLINE> p = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] < 3200 : <NEWLINE> <INDENT> t [ a [ i ] // 400 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> x = t . count ( 1 ) <NEWLINE> amax = p + x <NEWLINE> if x == 0 : <NEWLINE> <INDENT> amin = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> amin = x <NEWLINE> <DEDENT> print ( amin , amax ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( b // x ) - ( ( a - 1 ) // x ) ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> x = input ( ) <NEWLINE> final = deque ( [ ] ) <NEWLINE> final . append ( x [ 0 ] ) <NEWLINE> for i in range ( 1 , len ( x ) ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> final . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not final : <NEWLINE> <INDENT> final . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> last = final . pop ( ) <NEWLINE> if last == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> final . append ( <STRING> ) <NEWLINE> final . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( final ) ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> cnt = 0 <NEWLINE> lcnt = 0 <NEWLINE> sl = [ 0 ] * n <NEWLINE> for p in range ( k ) : <NEWLINE> <INDENT> if sl [ i ] == 0 : <NEWLINE> <INDENT> sl [ i ] = 1 <NEWLINE> i = l [ i ] - 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> elif sl [ i ] == 1 : <NEWLINE> <INDENT> sl [ i ] = 2 <NEWLINE> lcnt += 1 <NEWLINE> i = l [ i ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = ( k - cnt ) % lcnt <NEWLINE> if c != 0 : <NEWLINE> <INDENT> for tmp in range ( c ) : <NEWLINE> <INDENT> i = l [ i ] - 1 <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( i + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_lst = input ( ) . split ( ) <NEWLINE> odd = [ a for i , a in enumerate ( a_lst ) if i % 2 != 0 ] <NEWLINE> even = [ a for i , a in enumerate ( a_lst ) if i % 2 == 0 ] <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> b = list ( reversed ( odd ) ) + even <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = list ( reversed ( even ) ) + odd <NEWLINE> <DEDENT> print ( <STRING> . join ( b ) ) <NEWLINE>
from math import floor , ceil , sqrt , factorial , log <NEWLINE> from collections import Counter , deque <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> import itertools <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def MS ( ) : return map ( str , input ( ) . split ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def FLI ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> def LS ( ) : return list ( MS ( ) ) <NEWLINE> def LI ( ) : return list ( MI ( ) ) <NEWLINE> def LLS ( ) : return [ list ( map ( str , l . split ( ) ) ) for l in input ( ) ] <NEWLINE> def LLI ( ) : return [ list ( map ( int , l . split ( ) ) ) for l in input ( ) ] <NEWLINE> def LLSN ( n : int ) : return [ LS ( ) for _ in range ( n ) ] <NEWLINE> def LLIN ( n : int ) : return [ LI ( ) for _ in range ( n ) ] <NEWLINE> <NL> N = I ( ) <NEWLINE> <NL> ans = [ 0 for _ in range ( 10050 ) ] <NEWLINE> <NL> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> for j in range ( 1 , 100 ) : <NEWLINE> <INDENT> for k in range ( 1 , 100 ) : <NEWLINE> <INDENT> v = ( i + j + k ) ** 2 - ( i * j + j * k + k * i ) <NEWLINE> if v < 10050 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
def divisor_enumetarion ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> divisors . remove ( n ) <NEWLINE> return divisors <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dp = [ 0 ] * k <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( k , 0 , - 1 ) : <NEWLINE> <INDENT> toori = pow ( k // i , n , mod ) <NEWLINE> <NL> dp [ i - 1 ] += toori <NEWLINE> <NL> x = divisor_enumetarion ( i ) <NEWLINE> for j in x : <NEWLINE> <INDENT> dp [ j - 1 ] -= dp [ i - 1 ] % mod <NEWLINE> <NL> <DEDENT> ans += ( dp [ i - 1 ] * i ) % mod <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( ans % mod ) <NEWLINE> <NL> <COMMENT> <NL> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> b [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in b : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> cnt = 0 <NEWLINE> lis = [ 0 ] <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> or S [ i ] == <STRING> or S [ i ] == <STRING> or S [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> lis . append ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max ( lis ) ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> for i in range ( 121 ) : <NEWLINE> <INDENT> a = i <NEWLINE> for j in range ( 121 ) : <NEWLINE> <INDENT> b = j <NEWLINE> if ( a ** 5 - b ** 5 == X ) : <NEWLINE> <INDENT> A = a <NEWLINE> B = b <NEWLINE> <DEDENT> b = - j <NEWLINE> if ( a ** 5 - b ** 5 == X ) : <NEWLINE> <INDENT> A = a <NEWLINE> B = b <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( A , B ) <NEWLINE>
from sys import stdin <NEWLINE> n = int ( stdin . readline ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = str ( int ( stdin . readline ( ) . strip ( ) ) + int ( stdin . readline ( ) . strip ( ) ) ) <NEWLINE> if ( len ( c ) > 80 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> r = range <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> d = { } <NEWLINE> s = 0 <NEWLINE> for i in r ( n ) : <NEWLINE> <INDENT> cu = a [ i ] <NEWLINE> <NL> if d . get ( cu , None ) : <NEWLINE> <INDENT> d [ cu ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ cu ] = 1 <NEWLINE> <NL> <DEDENT> s += cu <NEWLINE> <NL> <DEDENT> for _ in r ( q ) : <NEWLINE> <INDENT> bi , ci = map ( int , input ( ) . split ( ) ) <NEWLINE> diff = ci - bi <NEWLINE> <NL> if d . get ( ci , None ) : <NEWLINE> <INDENT> d [ ci ] += d . get ( bi , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ ci ] = d . get ( bi , 0 ) <NEWLINE> <NL> <DEDENT> s += diff * d . get ( bi , 0 ) <NEWLINE> print ( s ) <NEWLINE> <NL> if d . get ( bi , None ) : <NEWLINE> <INDENT> d [ bi ] = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> t = 1 <NEWLINE> for _ in range ( t ) : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 1 <NEWLINE> machi = 0 <NEWLINE> machi_list = [ 0 ] <NEWLINE> next_machi = x [ machi ] - 1 <NEWLINE> machi_dict = { } <NEWLINE> while True : <NEWLINE> <INDENT> if next_machi in machi_dict : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> machi_dict [ next_machi ] = 1 <NEWLINE> machi_list . append ( next_machi ) <NEWLINE> machi = next_machi <NEWLINE> next_machi = x [ machi ] - 1 <NEWLINE> <NL> <DEDENT> z = 0 <NEWLINE> for i in range ( 0 , count ) : <NEWLINE> <INDENT> if machi_list [ i ] == next_machi : <NEWLINE> <INDENT> z = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> loop_machi_list = machi_list [ z : ] <NEWLINE> if k < z : <NEWLINE> <INDENT> machi = machi_list [ k ] + 1 <NEWLINE> print ( machi ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = k - z <NEWLINE> machi = loop_machi_list [ k % len ( loop_machi_list ) ] + 1 <NEWLINE> print ( machi ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def merge ( lst , left , mid , right ) : <NEWLINE> <INDENT> L = lst [ left : mid ] <NEWLINE> R = lst [ mid : right ] <NEWLINE> l_len = len ( L ) <NEWLINE> r_len = len ( R ) <NEWLINE> cnt = 0 <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if l_len <= i : <NEWLINE> <INDENT> lst [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> elif r_len <= j : <NEWLINE> <INDENT> lst [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> elif L [ i ] <= R [ j ] : <NEWLINE> <INDENT> lst [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> def mergeSort ( lst , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) >> 1 <NEWLINE> cnt = mergeSort ( lst , left , mid ) <NEWLINE> cnt += mergeSort ( lst , mid , right ) <NEWLINE> return merge ( lst , left , mid , right ) + cnt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> lst = [ val . split ( ) for val in sys . stdin . read ( ) . splitlines ( ) ] <NEWLINE> data = [ int ( n ) for n in lst [ 1 ] ] <NEWLINE> cnt = mergeSort ( data , 0 , int ( lst [ 0 ] [ 0 ] ) ) <NEWLINE> print ( <STRING> . join ( [ str ( n ) for n in data ] ) ) <NEWLINE> print ( cnt ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> m = 10 ** 9 + 7 <NEWLINE> pri_num = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 , 101 , 103 , 107 , 109 , 113 , 127 , 131 , 137 , 139 , 149 , 151 , 157 , 163 , 167 , 173 , 179 , 181 , 191 , 193 , 197 , 199 , 211 , 223 , 227 , 229 , 233 , 239 , 241 , 251 , 257 , 263 , 269 , 271 , 277 , 281 , 283 , 293 , 307 , 311 , 313 , 317 , 331 , 337 , 347 , 349 , 353 , 359 , 367 , 373 , 379 , 383 , 389 , 397 , 401 , 409 , 419 , 421 , 431 , 433 , 439 , 443 , 449 , 457 , 461 , 463 , 467 , 479 , 487 , 491 , 499 , 503 , 509 , 521 , 523 , 541 , 547 , 557 , 563 , 569 , 571 , 577 , 587 , 593 , 599 , 601 , 607 , 613 , 617 , 619 , 631 , 641 , 643 , 647 , 653 , 659 , 661 , 673 , 677 , 683 , 691 , 701 , 709 , 719 , 727 , 733 , 739 , 743 , 751 , 757 , 761 , 769 , 773 , 787 , 797 , 809 , 811 , 821 , 823 , 827 , 829 , 839 , 853 , 857 , 859 , 863 , 877 , 881 , 883 , 887 , 907 , 911 , 919 , 929 , 937 , 941 , 947 , 953 , 967 , 971 , 977 , 983 , 991 , 997 ] <NEWLINE> dic = { } <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> for pri in pri_num : <NEWLINE> <INDENT> while i > 0 : <NEWLINE> <INDENT> if i % pri == 0 : <NEWLINE> <INDENT> if pri in dic : <NEWLINE> <INDENT> dic [ pri ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ pri ] = 1 <NEWLINE> <DEDENT> i = i // pri <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> count = 1 <NEWLINE> for val in dic . values ( ) : <NEWLINE> <INDENT> count = ( count * ( val + 1 ) ) % m <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <NL> <NL>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> t = 0 <NEWLINE> max = n - 1 <NEWLINE> min = 0 <NEWLINE> while max - min > 1 : <NEWLINE> <INDENT> nn = math . floor ( ( max + min ) / 2 ) <NEWLINE> if a [ nn ] == k : <NEWLINE> <INDENT> t = 1 <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif a [ nn ] <= k : <NEWLINE> <INDENT> min = nn <NEWLINE> <DEDENT> elif a [ nn ] >= k : <NEWLINE> <INDENT> max = nn <NEWLINE> <DEDENT> <DEDENT> if t == 0 : <NEWLINE> <INDENT> if a [ max ] == k or a [ min ] == k : <NEWLINE> <INDENT> t = 1 <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> mod = 1000000007 <NEWLINE> n , k = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> l = ( i for i in range ( n + 1 ) ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> former = 0 <NEWLINE> acm = tuple ( ( former : = former + i ) for i in range ( n + 1 ) ) <NEWLINE> former = 0 <NEWLINE> acm_rev = tuple ( ( former : = former + i ) for i in range ( n , - 1 , - 1 ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for j in range ( k - 1 , n + 1 ) : <NEWLINE> <INDENT> ans += acm_rev [ j ] - acm [ j ] + 1 <NEWLINE> ans %= mod <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> highest_tenbo = [ 0 for i in range ( N ) ] <NEWLINE> <NL> for a , b in arr : <NEWLINE> <INDENT> highest_tenbo [ a - 1 ] = max ( highest_tenbo [ a - 1 ] , H [ b - 1 ] ) <NEWLINE> highest_tenbo [ b - 1 ] = max ( highest_tenbo [ b - 1 ] , H [ a - 1 ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i , t in enumerate ( highest_tenbo ) : <NEWLINE> <INDENT> if t < H [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> s = np . count_nonzero ( a >> i & 1 ) <NEWLINE> ans += pow ( 2 , i , mod ) * s * ( N - s ) % mod <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> <NL> <NL> class Node ( object ) : <NEWLINE> <INDENT> def __init__ ( self , data ) : <NEWLINE> <INDENT> self . data = data <NEWLINE> self . left , self . right = None , None <NEWLINE> <NL> <DEDENT> def insert ( self , data ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if data < self . data : <NEWLINE> <INDENT> if self . left is None : <NEWLINE> <INDENT> self . left = Node ( data ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . left . insert ( data ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if self . right is None : <NEWLINE> <INDENT> self . right = Node ( data ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . right . insert ( data ) <NEWLINE> <NL> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def pre_order ( node ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> print ( <STRING> , node . data , end = <STRING> ) <NEWLINE> pre_order ( node . left ) <NEWLINE> pre_order ( node . right ) <NEWLINE> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def in_order ( node ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> in_order ( node . left ) <NEWLINE> print ( <STRING> , node . data , end = <STRING> ) <NEWLINE> in_order ( node . right ) <NEWLINE> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def action ( command , content ) : <NEWLINE> <INDENT> if command . startswith ( <STRING> ) : <NEWLINE> <INDENT> tree_root . insert ( int ( content ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> in_order ( tree_root ) <NEWLINE> print ( <STRING> ) <NEWLINE> pre_order ( tree_root ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> array_length = int ( _input [ 0 ] ) <NEWLINE> command_list = list ( map ( lambda x : x . split ( ) , _input [ 1 : ] ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> flag , tree_root = False , None <NEWLINE> for each in command_list : <NEWLINE> <INDENT> command , content = each [ 0 ] , each [ - 1 ] <NEWLINE> if ( not flag ) and command . startswith ( <STRING> ) : <NEWLINE> <INDENT> tree_root = Node ( data = int ( content ) ) <NEWLINE> flag = True <NEWLINE> continue <NEWLINE> <DEDENT> action ( command , content ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ 0 for i in range ( N ) ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> S [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( S [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <COMMENT> <NL> import math <NEWLINE> import collections <NEWLINE> <COMMENT> <NL> import bisect <NEWLINE> import itertools <NEWLINE> import fractions <NEWLINE> <COMMENT> <NL> import copy <NEWLINE> <COMMENT> <NL> import decimal <NEWLINE> <COMMENT> <NL> import queue <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000001 ) <NEWLINE> INF = 10 ** 16 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> ni = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> eps = 10 ** ( - 9 ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> def popcounter ( n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> for _ in range ( INF ) : <NEWLINE> <INDENT> tmp = bin ( n ) . count ( <STRING> ) <NEWLINE> n = n % tmp <NEWLINE> cnt += 1 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> return cnt <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = ni ( ) <NEWLINE> x = sys . stdin . readline ( ) <NEWLINE> x_1 = x . count ( <STRING> ) <NEWLINE> <NL> num = int ( x , 2 ) <NEWLINE> num1 = num % ( x_1 - 1 ) if x_1 - 1 > 0 else 0 <NEWLINE> num0 = num % ( x_1 + 1 ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ n - 1 - i ] == <STRING> : <NEWLINE> <INDENT> if x_1 - 1 < 1 : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp_n = ( num1 - pow ( 2 , i , x_1 - 1 ) ) % ( x_1 - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tmp_n = ( num0 + pow ( 2 , i , x_1 + 1 ) ) % ( x_1 + 1 ) <NEWLINE> <DEDENT> ans . append ( popcounter ( tmp_n ) + 1 ) <NEWLINE> <NL> <DEDENT> l = len ( ans ) <NEWLINE> for i in range ( l - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> def convolve ( A , B ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> dtype = np . int64 <NEWLINE> fft , ifft = np . fft . rfft , np . fft . irfft <NEWLINE> a , b = len ( A ) , len ( B ) <NEWLINE> if a == b == 1 : <NEWLINE> <INDENT> return np . array ( [ A [ 0 ] * B [ 0 ] ] ) <NEWLINE> <DEDENT> n = a + b - 1 <COMMENT> <NEWLINE> k = 1 << ( n - 1 ) . bit_length ( ) <NEWLINE> AB = np . zeros ( ( 2 , k ) , dtype = dtype ) <NEWLINE> AB [ 0 , : a ] = A <NEWLINE> AB [ 1 , : b ] = B <NEWLINE> return np . rint ( ifft ( fft ( AB [ 0 ] ) * fft ( AB [ 1 ] ) ) ) . astype ( np . int64 ) [ : n ] <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = np . zeros ( 100001 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> c = convolve ( cnt , cnt ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( c ) ) [ : : - 1 ] : <NEWLINE> <INDENT> if c [ i ] > 0 : <NEWLINE> <INDENT> p = min ( m , c [ i ] ) <NEWLINE> m -= p <NEWLINE> ans += i * p <NEWLINE> if m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<STRING> <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] + a <NEWLINE> vis = [ - 1 ] * ( n + 5 ) <NEWLINE> <NL> <NL> turn = k <NEWLINE> now = 1 <NEWLINE> c = 0 <NEWLINE> while vis [ now ] == - 1 : <NEWLINE> <NL> <INDENT> if turn <= 0 : <NEWLINE> <INDENT> print ( now ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> vis [ now ] = c <NEWLINE> c += 1 <NEWLINE> now = a [ now ] <NEWLINE> turn = turn - 1 <NEWLINE> <NL> <DEDENT> diff = c - vis [ now ] <NEWLINE> <NL> lo = 1 <NEWLINE> hi = 10 ** 25 <NEWLINE> cost = vis [ now ] <NEWLINE> while lo <= hi : <NEWLINE> <NL> <INDENT> mid = ( lo + hi ) // 2 <NEWLINE> t = mid * diff <NEWLINE> if t + cost <= k : <NEWLINE> <INDENT> lo = mid + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hi = mid - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> t = hi * diff + cost <NEWLINE> <NL> <NL> rem = k - t <NEWLINE> <NL> while rem > 0 : <NEWLINE> <INDENT> now = a [ now ] <NEWLINE> rem -= 1 <NEWLINE> <NL> <DEDENT> print ( now ) <NEWLINE>
def e_colorful_blocks ( MOD = 998244353 ) : <NEWLINE> <INDENT> N , M , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> class Combination ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> __slots__ = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> def __init__ ( self , max_val_arg : int = 10 ** 6 , mod : int = 10 ** 9 + 7 ) : <NEWLINE> <INDENT> fac , inv = [ 1 ] , [ ] <NEWLINE> fac_append , inv_append = fac . append , inv . append <NEWLINE> <NL> for i in range ( 1 , max_val_arg + 1 ) : <NEWLINE> <INDENT> fac_append ( fac [ - 1 ] * i % mod ) <NEWLINE> <NL> <DEDENT> inv_append ( pow ( fac [ - 1 ] , - 1 , mod ) ) <NEWLINE> for i in range ( max_val_arg , 0 , - 1 ) : <NEWLINE> <INDENT> inv_append ( ( inv [ - 1 ] * i ) % mod ) <NEWLINE> <NL> <DEDENT> self . mod , self . fact , self . factinv = mod , fac , inv [ : : - 1 ] <NEWLINE> <NL> <DEDENT> def combination ( self , n , r ) : <NEWLINE> <INDENT> return ( 0 if n < 0 or r < 0 or n < r <NEWLINE> <INDENT> else self . fact [ n ] * self . factinv [ r ] * self . factinv [ n - r ] % self . mod ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> comb = Combination ( max ( N , M ) , MOD ) . combination <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> a = ( M * pow ( M - 1 , N - 1 - x , MOD ) ) % MOD <NEWLINE> b = comb ( N - 1 , x ) <NEWLINE> ans = ( ans + a * b ) % MOD <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> print ( e_colorful_blocks ( ) ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) . strip ( ) ) <NEWLINE> S_list = [ input ( ) . strip ( ) for _ in range ( N ) ] <NEWLINE> <COMMENT> <NL> <NL> def count_brackets ( brackets ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> min_cnt = 0 <NEWLINE> <NL> for i in range ( len ( brackets ) ) : <NEWLINE> <INDENT> if brackets [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> min_cnt = min ( min_cnt , cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> return cnt , min_cnt <NEWLINE> <NL> <NL> <DEDENT> tmp_cnt_plus = [ ] <NEWLINE> tmp_cnt_minus = [ ] <NEWLINE> <NL> for S in S_list : <NEWLINE> <INDENT> cnt , min_cnt = count_brackets ( S ) <NEWLINE> <NL> if cnt == min_cnt == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if cnt >= 0 : <NEWLINE> <INDENT> tmp_cnt_plus . append ( ( cnt , min_cnt ) ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> tmp_cnt_minus . append ( ( cnt , min_cnt ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> tmp_cnt_plus . sort ( key = lambda x : - x [ 1 ] ) <NEWLINE> tmp_cnt_minus . sort ( key = lambda x : - ( x [ 0 ] - x [ 1 ] ) ) <NEWLINE> <NL> <NL> sum_bracket = 0 <NEWLINE> flag = True <NEWLINE> <NL> for cnt , min_cnt in ( tmp_cnt_plus + tmp_cnt_minus ) : <NEWLINE> <INDENT> if ( sum_bracket + min_cnt ) < 0 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> sum_bracket += cnt <NEWLINE> <NL> <NL> <DEDENT> if ( sum_bracket == 0 ) and flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s_l = list ( input ( ) ) <NEWLINE> n = len ( s_l ) <NEWLINE> <NL> <COMMENT> <NL> dp_dict = { 0 : 1 } <NEWLINE> t = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( s_l [ - ( i + 1 ) ] ) <NEWLINE> t = ( t + a * ( pow ( 10 , i , 2019 ) ) ) % 2019 <NEWLINE> dp_dict [ t ] = dp_dict . get ( t , 0 ) + 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for val in dp_dict . values ( ) : <NEWLINE> <INDENT> ans += val * ( val - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( * A [ : : - 2 ] , * A [ N % 2 : : 2 ] ) <NEWLINE>
<COMMENT> <NL> <NL> S = input ( ) <NEWLINE> size = len ( S ) <NEWLINE> L = [ 0 ] * 2019 <NEWLINE> <NL> tmp = int ( S [ size - 1 ] ) <COMMENT> <NEWLINE> L [ 0 ] = 1 <NEWLINE> L [ tmp ] += 1 <NEWLINE> tmp_r = 1 <COMMENT> <NEWLINE> <NL> for i in reversed ( range ( size - 1 ) ) : <COMMENT> <NEWLINE> <INDENT> n = int ( S [ i ] ) <COMMENT> <NEWLINE> tmp_r = ( tmp_r * 10 ) % 2019 <NEWLINE> r = ( n * tmp_r ) % 2019 <NEWLINE> tmp = ( tmp + r ) % 2019 <NEWLINE> <COMMENT> <NL> L [ tmp ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> tmp = L [ i ] <NEWLINE> if ( tmp > 1 ) : <NEWLINE> <INDENT> ans += tmp * ( tmp - 1 ) // 2 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def calc ( i ) : <NEWLINE> <INDENT> if ( i == 0 ) : <NEWLINE> <INDENT> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dif = 100000 <NEWLINE> o_list = [ ] <NEWLINE> <NL> if len ( num_list ) == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if i not in num_list : <NEWLINE> <INDENT> o_list . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> o_list . sort ( reverse = True ) <NEWLINE> <NL> for num in o_list : <NEWLINE> <INDENT> if abs ( x - num ) <= dif : <NEWLINE> <COMMENT> <NL> <INDENT> dif = abs ( x - num ) <NEWLINE> ans = num <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> li = input ( ) . split ( ) <NEWLINE> a = Counter ( li ) <NEWLINE> <NL> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( a [ str ( i ) ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> visited = [ - 1 for _ in range ( n ) ] <NEWLINE> visited [ 0 ] = 0 <NEWLINE> l = [ 0 ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> nex = a [ l [ i ] ] <NEWLINE> if visited [ nex ] != - 1 : <NEWLINE> <INDENT> res = visited [ nex ] <NEWLINE> cyc = i + 1 - visited [ nex ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l += [ nex ] <NEWLINE> visited [ nex ] = i + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res = k + 1 <NEWLINE> <DEDENT> print ( l [ res + ( k - res ) % cyc ] + 1 if k > res else l [ k ] + 1 ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> m = 2019 <NEWLINE> <NL> a = 0 <NEWLINE> r = [ 0 for _ in range ( m + 1 ) ] <NEWLINE> r [ 0 ] = 1 <NEWLINE> z = 0 <NEWLINE> j = 1 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> j = j * 10 % m <NEWLINE> ss = int ( s [ n - i - 1 ] ) * j + z <NEWLINE> z = ss % m <NEWLINE> <NL> <NL> <NL> a += r [ z ] <NEWLINE> r [ z ] += 1 <NEWLINE> <NL> <DEDENT> print ( a ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> for i in range ( 1 , a + 1 , 1 ) : <NEWLINE> <INDENT> if <STRING> in str ( i ) : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> elif i % 3 == 0 : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in b : <NEWLINE> <INDENT> count += 1 <NEWLINE> if len ( b ) == count : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> print ( i , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in l : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for e in l : <NEWLINE> <INDENT> ans *= e <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( str ( ans ) ) <NEWLINE>
from math import gcd <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> res = n * m // gcd ( n , m ) <NEWLINE> a = m // gcd ( n , m ) <NEWLINE> b = n // gcd ( n , m ) <NEWLINE> if n >= m : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> if ( i * b ) % a == 0 : <NEWLINE> <INDENT> if s [ ( i * b ) // a ] != t [ i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( i * a ) % b == 0 : <NEWLINE> <INDENT> if s [ i ] != t [ ( i * a ) // b ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> divs = [ ] <NEWLINE> while i ** 2 <= N : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> divs . append ( ( i , N // i ) ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for p in divs : <NEWLINE> <INDENT> r = p [ 0 ] <NEWLINE> m = p [ 1 ] - 1 <NEWLINE> if m == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if N % m == r : <NEWLINE> <INDENT> ans += m <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = sorted ( A , key = lambda x : abs ( x ) , reverse = True ) <NEWLINE> Bp = [ x for x in B if x > 0 ] <NEWLINE> Bm = [ x for x in B if x < 0 ] <NEWLINE> Bpm = [ x for x in B if x != 0 ] <NEWLINE> Bmm = [ ] <NEWLINE> for i in range ( 0 , len ( Bm ) - 1 , 2 ) : <NEWLINE> <INDENT> Bmm . append ( Bm [ i ] * Bm [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> q = 10 ** 9 + 7 <NEWLINE> <NL> n_plus , n_zero , n_minus = 0 , 0 , 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a > 0 : <NEWLINE> <INDENT> n_plus += 1 <NEWLINE> <DEDENT> elif a < 0 : <NEWLINE> <INDENT> n_minus += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n_zero += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> rest = K <NEWLINE> ans = 1 <NEWLINE> <NL> if K <= n_plus + n_minus and not ( ( n_plus == 0 or K == n_plus + n_minus ) and ( K - n_plus ) % 2 == 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> i , j = 0 , 0 <NEWLINE> while rest > 0 : <NEWLINE> <INDENT> if rest >= 2 and j < len ( Bmm ) : <NEWLINE> <INDENT> if i + 1 < len ( Bp ) : <NEWLINE> <INDENT> if Bmm [ j ] >= Bp [ i ] * Bp [ i + 1 ] : <NEWLINE> <INDENT> ans = ( ans * ( Bmm [ j ] % q ) ) % q <NEWLINE> j += 1 <NEWLINE> rest -= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( ans * Bp [ i ] ) % q <NEWLINE> i += 1 <NEWLINE> rest -= 1 <NEWLINE> <DEDENT> <DEDENT> elif i < len ( Bp ) : <NEWLINE> <INDENT> if Bmm [ j ] >= Bp [ i ] : <NEWLINE> <INDENT> ans = ( ans * ( Bmm [ j ] % q ) ) % q <NEWLINE> j += 1 <NEWLINE> rest -= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( ans * Bp [ i ] ) % q <NEWLINE> i += 1 <NEWLINE> rest -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = ( ans * ( Bmm [ j ] % q ) ) % q <NEWLINE> j += 1 <NEWLINE> rest -= 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = ( ans * Bp [ i ] ) % q <NEWLINE> i += 1 <NEWLINE> rest -= 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> elif n_zero > 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> ans = ( ans * Bpm [ len ( Bpm ) - 1 - i ] ) % q <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( main ( ) ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> if a >= k : <NEWLINE> <INDENT> cnt += k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= a <NEWLINE> cnt += a <NEWLINE> if k > 0 : <NEWLINE> <INDENT> k -= b <NEWLINE> if k > 0 : <NEWLINE> <INDENT> cnt -= k <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from heapq import heappop , heappush <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M , S = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> U , V , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ U - 1 ] . append ( [ V - 1 , A , B ] ) <NEWLINE> G [ V - 1 ] . append ( [ U - 1 , A , B ] ) <NEWLINE> <DEDENT> C = [ ] <NEWLINE> D = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> C . append ( c ) <NEWLINE> D . append ( d ) <NEWLINE> <NL> <DEDENT> MaxMoney = 2500 <NEWLINE> <NL> dp = [ [ float ( <STRING> ) for __ in range ( MaxMoney + 1 ) ] for _ in range ( N ) ] <NEWLINE> <NL> cost = 0 <NEWLINE> money = min ( S , MaxMoney ) <NEWLINE> que = [ ] <NEWLINE> heappush ( que , ( cost , 0 , money ) ) <COMMENT> <NEWLINE> dp [ 0 ] [ money ] = 0 <NEWLINE> <NL> while len ( que ) > 0 : <NEWLINE> <INDENT> cost , node , money = heappop ( que ) <NEWLINE> <NL> stop_money = min ( money + C [ node ] , MaxMoney ) <NEWLINE> stop_cost = cost + D [ node ] <NEWLINE> if stop_cost < dp [ node ] [ stop_money ] : <NEWLINE> <INDENT> dp [ node ] [ stop_money ] = stop_cost <NEWLINE> heappush ( que , ( stop_cost , node , stop_money ) ) <NEWLINE> <NL> <DEDENT> for to_node , to_money , to_cost in G [ node ] : <NEWLINE> <INDENT> money_ = min ( money - to_money , MaxMoney ) <NEWLINE> if money_ < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cost_ = cost + to_cost <NEWLINE> if dp [ to_node ] [ money_ ] <= cost_ : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> dp [ to_node ] [ money_ ] = cost_ <NEWLINE> heappush ( que , ( cost_ , to_node , money_ ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( min ( dp [ i ] ) ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> a = 7 <NEWLINE> p = { } <NEWLINE> ans = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> t = a % K <NEWLINE> ans += 1 <NEWLINE> if t == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> if t in p : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> a = 10 * t + 7 <NEWLINE> p [ t ] = 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import itertools <NEWLINE> <NL> S = [ ] <NEWLINE> N = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n , s = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if s == 0 and n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N . append ( n ) <NEWLINE> S . append ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , len ( S ) ) : <NEWLINE> <INDENT> sumMap = list ( map ( sum , list ( itertools . combinations ( range ( 0 , 10 ) , N [ i ] ) ) ) ) <NEWLINE> print ( sum ( [ 1 for j in range ( 0 , len ( sumMap ) ) if sumMap [ j ] == S [ i ] ] ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <NL>
v , e , s = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ ] <NEWLINE> inf = 1000000100 <NEWLINE> for i in range ( v ) : <NEWLINE> <INDENT> edge . append ( [ ] ) <NEWLINE> <NL> <DEDENT> for i in range ( e ) : <NEWLINE> <INDENT> vs , vt , d = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ vs ] . append ( ( vt , d ) ) <NEWLINE> <NL> <DEDENT> dis = [ ] <NEWLINE> for i in range ( v ) : <NEWLINE> <INDENT> dis . append ( inf ) <NEWLINE> <NL> <DEDENT> dis [ s ] = 0 <NEWLINE> <NL> for j in range ( v ) : <NEWLINE> <INDENT> update = False <NEWLINE> for i in range ( v ) : <NEWLINE> <INDENT> for ( t , d ) in edge [ i ] : <NEWLINE> <INDENT> if dis [ i ] < inf and d < inf and dis [ t ] > dis [ i ] + d : <NEWLINE> <INDENT> dis [ t ] = dis [ i ] + d <NEWLINE> update = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if update == False : break <NEWLINE> <NL> <DEDENT> for i in range ( v ) : <NEWLINE> <INDENT> if dis [ i ] >= inf : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dis [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s1 = ( sum ( nums ) - nums [ 0 ] ) % ( 10 ** 9 + 7 ) <NEWLINE> sums = [ s1 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> s = sums [ i - 1 ] - nums [ i ] <NEWLINE> s %= 10 ** 9 + 7 <NEWLINE> sums . append ( s ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> temp = nums [ i ] * sums [ i ] % ( 10 ** 9 + 7 ) <NEWLINE> ans += temp <NEWLINE> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> S = sum ( A ) <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S -= A [ i ] <NEWLINE> ans += ( A [ i ] * S ) % p <NEWLINE> <DEDENT> print ( ans % p ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == S [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if 2 * j - i < N : <NEWLINE> <INDENT> if S [ 2 * j - i ] != S [ i ] and S [ 2 * j - i ] != S [ j ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
na = 0 <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> b . append ( a [ na ] ) <NEWLINE> if a [ na ] == 2 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> na = a [ na ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> from itertools import * <NEWLINE> <NL> <NL> def solve ( N : int , M : int , Q : int , a : <STRING> , b : <STRING> , c : <STRING> , d : <STRING> ) : <NEWLINE> <INDENT> l = [ i for i in range ( 1 , M + 1 ) ] <NEWLINE> ans = 0 <NEWLINE> for v in combinations_with_replacement ( l , N ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> for j in range ( Q ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if ( v [ b [ j ] - 1 ] - v [ a [ j ] - 1 ] ) == c [ j ] : <NEWLINE> <INDENT> score += d [ j ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = max ( ans , score ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> return <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> M = int ( next ( tokens ) ) <COMMENT> <NEWLINE> Q = int ( next ( tokens ) ) <COMMENT> <NEWLINE> a = [ int ( ) ] * ( Q ) <COMMENT> <NEWLINE> b = [ int ( ) ] * ( Q ) <COMMENT> <NEWLINE> c = [ int ( ) ] * ( Q ) <COMMENT> <NEWLINE> d = [ int ( ) ] * ( Q ) <COMMENT> <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a [ i ] = int ( next ( tokens ) ) <NEWLINE> b [ i ] = int ( next ( tokens ) ) <NEWLINE> c [ i ] = int ( next ( tokens ) ) <NEWLINE> d [ i ] = int ( next ( tokens ) ) <NEWLINE> <DEDENT> solve ( N , M , Q , a , b , c , d ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> from collections import defaultdict <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> class Graph ( object ) : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . N = N <NEWLINE> self . E = defaultdict ( list ) <NEWLINE> <NL> <DEDENT> def add_edge ( self , f , t , w = 1 ) : <NEWLINE> <INDENT> self . E [ f ] . append ( ( t , w ) ) <NEWLINE> self . E [ t ] . append ( ( f , w ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> c = [ x - 1 for x in map ( int , input ( ) . split ( ) ) ] <NEWLINE> A = [ None ] * ( N - 1 ) <NEWLINE> B = [ None ] * ( N - 1 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> g = Graph ( N ) <NEWLINE> for a , b in zip ( A , B ) : <NEWLINE> <INDENT> g . add_edge ( a - 1 , b - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> ans = [ 0 ] * N <NEWLINE> <NL> <NL> def f ( curr , par = - 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ret = defaultdict ( int ) <NEWLINE> size = 1 <NEWLINE> for dest , w in g . E [ curr ] : <NEWLINE> <INDENT> if dest == par : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> sz , child = f ( dest , curr ) <NEWLINE> size += sz <NEWLINE> <NL> <COMMENT> <NL> n = sz - child [ c [ curr ] ] <NEWLINE> ans [ c [ curr ] ] += n * ( n + 1 ) // 2 <NEWLINE> <NL> <COMMENT> <NL> if len ( ret ) < len ( child ) : <NEWLINE> <INDENT> child , ret = ret , child <NEWLINE> <DEDENT> for key in child : <NEWLINE> <INDENT> ret [ key ] += child [ key ] <NEWLINE> <NL> <DEDENT> <DEDENT> ret [ c [ curr ] ] = size <NEWLINE> return size , ret <NEWLINE> <NL> <NL> <DEDENT> sz , ret = f ( 0 ) <NEWLINE> for color in range ( N ) : <NEWLINE> <INDENT> if color != c [ 0 ] : <NEWLINE> <INDENT> n = sz - ret [ color ] <NEWLINE> ans [ color ] += n * ( n + 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> tot = N * ( N + 1 ) // 2 <NEWLINE> for a in ans : <NEWLINE> <INDENT> print ( tot - a ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> <NL> d = { } <NEWLINE> for a in A : <NEWLINE> <INDENT> d . setdefault ( a , 0 ) <NEWLINE> d [ a ] += 1 <NEWLINE> <NL> <DEDENT> A = sorted ( set ( A ) ) <NEWLINE> t = [ True ] * ( 10 ** 6 + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if d [ a ] > 1 : <NEWLINE> <INDENT> t [ a ] = False <NEWLINE> <DEDENT> for i in range ( a + a , 10 ** 6 + 1 , a ) : <NEWLINE> <INDENT> t [ i ] = False <NEWLINE> <DEDENT> <DEDENT> print ( sum ( 1 for a in A if t [ a ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> max_number = max ( A ) + 1 <NEWLINE> ng = [ False ] * max_number <NEWLINE> counter = 0 <NEWLINE> prev = 0 <NEWLINE> for ai in A : <NEWLINE> <INDENT> if ai == prev : <NEWLINE> <INDENT> counter -= 1 <NEWLINE> prev = 0 <NEWLINE> <DEDENT> if not ng [ ai ] : <NEWLINE> <INDENT> counter += 1 <NEWLINE> prev = ai <NEWLINE> <DEDENT> for i in range ( ai , max_number , ai ) : <NEWLINE> <INDENT> ng [ i ] = True <NEWLINE> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i in A : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> x = P [ 0 ] <NEWLINE> for p in P : <NEWLINE> <INDENT> if x > p : <NEWLINE> <INDENT> ans += 1 <NEWLINE> x = p <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> heighest = 0 <NEWLINE> stepsum = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if heighest < i : <NEWLINE> <INDENT> heighest = i <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stepsum += heighest - i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( stepsum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> total = 0 <NEWLINE> before = 0 <NEWLINE> for i in range ( len ( As ) - 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> total = total + As [ i ] * sum ( As [ i + 1 : ] ) <NEWLINE> before = sum ( As [ i + 1 : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total = total + ( ( before - As [ i ] ) * As [ i ] ) <NEWLINE> before = before - As [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> total = total % ( 10 ** 9 + 7 ) <NEWLINE> <NL> print ( int ( total ) ) <NEWLINE>
n = input ( ) <NEWLINE> t = sum ( list ( map ( int , list ( n ) ) ) ) <NEWLINE> <NL> <NL> if int ( t / 9 ) == t / 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> b [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in b : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <NL> <NL> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . readline <NEWLINE> read = sys . stdin . read <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> <COMMENT> <NL> from collections import deque <NEWLINE> <COMMENT> <NL> <NL> def generate_inv ( n , mod ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = [ 0 , 1 ] <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> next = - ret [ mod % i ] * ( mod // i ) <NEWLINE> next %= mod <NEWLINE> ret . append ( next ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def generate_comb_m_i ( M , N , inv , mod ) : <NEWLINE> <INDENT> ret = [ 1 , M ] <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> tmp = ( ret [ - 1 ] * ( M - ( i - 1 ) ) * inv [ i ] ) % mod <NEWLINE> ret . append ( tmp ) <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT> def generate_p_N_i ( N , mod ) : <NEWLINE> <INDENT> ret = [ 1 ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> tmp = ( ret [ - 1 ] * ( N - ( i - 1 ) ) ) % mod <NEWLINE> ret . append ( tmp ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def generate_p_mi_ni ( M , N , mod ) : <NEWLINE> <INDENT> ret = deque ( [ 1 ] ) <NEWLINE> cache = deque ( [ 1 ] ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> tmp = ( cache [ 0 ] * ( M - N + i ) ) % mod <NEWLINE> cache . appendleft ( tmp ) <NEWLINE> ret . appendleft ( ( tmp ** 2 ) % mod ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> inv = generate_inv ( M , mod ) <NEWLINE> <NL> comb_m_i = generate_comb_m_i ( M , N , inv , mod ) <NEWLINE> <COMMENT> <NL> p_N_i = generate_p_N_i ( N , mod ) <NEWLINE> <COMMENT> <NL> p_mi_ni = generate_p_mi_ni ( M , N , mod ) <NEWLINE> <COMMENT> <NL> <NL> ret = p_mi_ni [ 0 ] <NEWLINE> <NL> arr01 = [ - 1 , 1 ] * ( N // 2 + 1 ) <NEWLINE> arr01 = arr01 [ : N + 1 ] <NEWLINE> <NL> comb_m_i = np . array ( comb_m_i , dtype = np . int64 ) <NEWLINE> p_N_i = np . array ( p_N_i , dtype = np . int64 ) <NEWLINE> p_mi_ni = np . array ( p_mi_ni , dtype = np . int64 ) <NEWLINE> arr01 = np . array ( arr01 , dtype = np . int64 ) <NEWLINE> <NL> tmp = ( comb_m_i * p_N_i ) % mod <NEWLINE> tmp = ( tmp * p_mi_ni ) % mod <NEWLINE> tmp = ( tmp * arr01 ) % mod <NEWLINE> tmp = tmp [ 1 : ] <NEWLINE> sub = 0 <NEWLINE> for val in tmp : <NEWLINE> <INDENT> sub += val <NEWLINE> sub %= mod <NEWLINE> <NL> <DEDENT> ret -= sub <NEWLINE> ret %= mod <NEWLINE> <NL> print ( ret ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
INF = 10 ** 10 <NEWLINE> <NL> <NL> def merge ( ary , left , mid , right ) : <NEWLINE> <INDENT> lry = ary [ left : mid ] <NEWLINE> rry = ary [ mid : right ] <NEWLINE> lry . append ( INF ) <NEWLINE> rry . append ( INF ) <NEWLINE> <NL> cnt = 0 <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if lry [ i ] <= rry [ j ] : <NEWLINE> <INDENT> ary [ k ] = lry [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ary [ k ] = rry [ j ] <NEWLINE> j += 1 <NEWLINE> cnt += len ( lry ) - 1 - i <NEWLINE> <NL> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> def merge_sort ( ary , left , right ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> cnt += merge_sort ( ary , left , mid ) <NEWLINE> cnt += merge_sort ( ary , mid , right ) <NEWLINE> cnt += merge ( ary , left , mid , right ) <NEWLINE> <NL> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ary = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> print ( merge_sort ( ary , 0 , n ) ) <NEWLINE> <NL> <DEDENT>
import numpy as np <NEWLINE> from collections import Counter <NEWLINE> <NL> <NL> def solve ( string ) : <NEWLINE> <INDENT> n , * a = map ( int , string . split ( ) ) <NEWLINE> table = np . array ( [ True ] * ( 10 ** 6 + 1 ) ) <NEWLINE> for _a in a : <NEWLINE> <INDENT> if table [ _a ] : <NEWLINE> <INDENT> table [ 2 * _a : : _a ] = False <NEWLINE> <DEDENT> <DEDENT> i = np . array ( [ k for k , v in Counter ( a ) . items ( ) if v == 1 ] , dtype = np . int ) <NEWLINE> return str ( table [ i ] . sum ( ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> print ( solve ( sys . stdin . read ( ) . strip ( ) ) ) <NEWLINE> <DEDENT>
<NL> def sign ( x ) : <NEWLINE> <INDENT> return ( x > 0 ) - ( x < 0 ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> _ = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> arr = [ ] <NEWLINE> state = 0 <NEWLINE> for an in a : <NEWLINE> <INDENT> if len ( arr ) < 2 : <NEWLINE> <INDENT> arr . append ( an ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> state += ( arr [ - 1 ] - arr [ - 2 ] ) <NEWLINE> if state == 0 : <NEWLINE> <INDENT> arr . append ( an ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> current = an - arr [ - 1 ] <NEWLINE> if current == 0 or sign ( state ) == sign ( current ) : <NEWLINE> <INDENT> arr . append ( an ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( arr ) <NEWLINE> arr = [ an ] <NEWLINE> state = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans . append ( arr ) <NEWLINE> <NL> print ( len ( ans ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = min ( abs ( 101 - x ) , abs ( x ) ) <NEWLINE> if abs ( 101 - x ) >= abs ( x ) : <NEWLINE> <INDENT> answer = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = 101 <NEWLINE> <DEDENT> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> if i in p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ab > abs ( x - i ) : <NEWLINE> <INDENT> ab = abs ( x - i ) <NEWLINE> answer = i <NEWLINE> <DEDENT> elif ab == abs ( x - i ) and answer > i : <NEWLINE> <INDENT> answer = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * l ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
<COMMENT> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if K == N : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 0 : <NEWLINE> <INDENT> ans = ans % MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif max ( A ) <= 0 and K % 2 == 1 : <NEWLINE> <INDENT> A . sort ( reverse = True ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 0 : <NEWLINE> <INDENT> ans = ans % MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> Ap = [ ] <NEWLINE> Am = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] > 0 : <NEWLINE> <INDENT> Ap . append ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Am . append ( A [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> Ap . sort ( reverse = True ) <NEWLINE> Am . sort ( ) <NEWLINE> <NL> if K % 2 == 1 and Ap : <NEWLINE> <INDENT> ans *= Ap . pop ( 0 ) <NEWLINE> <NL> <DEDENT> P = [ ] <NEWLINE> <NL> for i in range ( len ( Ap ) // 2 ) : <NEWLINE> <INDENT> P . append ( Ap [ i * 2 ] * Ap [ i * 2 + 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( Am ) // 2 ) : <NEWLINE> <INDENT> P . append ( Am [ i * 2 ] * Am [ i * 2 + 1 ] ) <NEWLINE> <NL> <DEDENT> P . sort ( reverse = True ) <NEWLINE> <NL> for i in range ( K // 2 ) : <NEWLINE> <INDENT> ans *= P [ i ] <NEWLINE> ans = ans % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans % MOD ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> num = [ 0 ] * 100010 <NEWLINE> b = [ 0 ] * q <NEWLINE> c = [ 0 ] * q <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b [ i ] , c [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> num [ i ] += 1 <NEWLINE> <NL> <DEDENT> s = sum ( a ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> for i in range ( q ) : <NEWLINE> <INDENT> s += ( c [ i ] - b [ i ] ) * num [ b [ i ] ] <NEWLINE> num [ c [ i ] ] += num [ b [ i ] ] <NEWLINE> <COMMENT> <NL> num [ b [ i ] ] = 0 <NEWLINE> <COMMENT> <NL> print ( s ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p . sort ( ) <NEWLINE> sum = p [ 0 ] <NEWLINE> for i in range ( 1 , k ) : <NEWLINE> <INDENT> sum += p [ i ] <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
import numpy <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> acc_a = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> acc_a . append ( acc_a [ i ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> acc_b = [ 0 ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> acc_b . append ( acc_b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> acc_a = numpy . array ( acc_a ) <NEWLINE> acc_b = numpy . array ( acc_b ) <NEWLINE> <NL> currentMax = 0 <NEWLINE> bnum = M <NEWLINE> for anum in range ( N + 1 ) : <NEWLINE> <INDENT> if acc_a [ anum ] > K : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> if acc_b [ bnum ] > K - acc_a [ anum ] : <NEWLINE> <INDENT> bnum = bnum - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> currentMax = max ( currentMax , anum + bnum ) <NEWLINE> <NL> <NL> <DEDENT> print ( currentMax ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( n * ( n - 1 ) // 2 ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> num = 7 <NEWLINE> while True : <NEWLINE> <INDENT> if num % k == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> num += 7 * pow ( 10 , ans - 1 , k ) <NEWLINE> num %= k <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> X , K , D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if X < 0 : <NEWLINE> <INDENT> X = - X <NEWLINE> <NL> <DEDENT> if X - K * D >= 0 : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> temp_X = X <NEWLINE> temp_K = K <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> k = X // D <NEWLINE> <NL> temp_X = X - k * D <NEWLINE> temp_K = K - k <NEWLINE> <NL> if temp_K % 2 == 0 : <NEWLINE> <INDENT> print ( temp_X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( temp_X - D ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> s1 = sum ( l ) <NEWLINE> a = 0 <NEWLINE> for x in range ( n - 1 ) : <NEWLINE> <INDENT> s += ( l [ x ] * ( s1 - l [ x ] - a ) ) <NEWLINE> a += l [ x ] <NEWLINE> <DEDENT> print ( s % 1000000007 ) <NEWLINE>
T_list = input ( ) <NEWLINE> T = list ( T_list ) <NEWLINE> nT = [ 0 ] * len ( T ) <NEWLINE> if T [ len ( T ) - 1 ] == <STRING> : <NEWLINE> <INDENT> T [ len ( T ) - 1 ] = <STRING> <NEWLINE> <DEDENT> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ i ] != <STRING> : <NEWLINE> <INDENT> nT [ i ] = T [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if 0 < i and i < len ( T ) - 1 : <NEWLINE> <INDENT> if T [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> nT [ i ] = <STRING> <NEWLINE> T [ i ] = <STRING> <NEWLINE> <DEDENT> elif T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> nT [ i ] = <STRING> <NEWLINE> T [ i ] = <STRING> <NEWLINE> <DEDENT> elif T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> nT [ i ] = <STRING> <NEWLINE> T [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nT [ i ] = <STRING> <NEWLINE> T [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i < len ( T ) - 1 : <NEWLINE> <INDENT> if T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> nT [ i ] = <STRING> <NEWLINE> T [ i ] = <STRING> <NEWLINE> <DEDENT> elif T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> nT [ i ] = <STRING> <NEWLINE> T [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nT [ i ] = <STRING> <NEWLINE> T [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> nT = <STRING> . join ( nT ) <NEWLINE> print ( nT ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> from functools import reduce <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> k , s = rm ( ) <NEWLINE> cnt = 0 <NEWLINE> for x in range ( k , - 1 , - 1 ) : <NEWLINE> <INDENT> for y in range ( k , - 1 , - 1 ) : <NEWLINE> <INDENT> if 0 <= s - x - y <= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> <NL> count = [ ] <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> temp = input ( ) <NEWLINE> count . append ( temp ) <NEWLINE> <NL> <DEDENT> count = set ( count ) <NEWLINE> <NL> print ( len ( count ) ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> RL = [ ] <NEWLINE> GL = [ ] <NEWLINE> BL = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> word = s [ i - 1 ] <NEWLINE> if word == <STRING> : <NEWLINE> <INDENT> RL . append ( i ) <NEWLINE> <DEDENT> elif word == <STRING> : <NEWLINE> <INDENT> GL . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> BL . append ( i ) <NEWLINE> <DEDENT> <DEDENT> nagasa_r = len ( RL ) <NEWLINE> nagasa_g = len ( GL ) <NEWLINE> nagasa_b = len ( BL ) <NEWLINE> SBL = set ( BL ) <NEWLINE> ans = 0 <NEWLINE> if nagasa_b == 0 or nagasa_g == 0 or nagasa_r == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> out_count = 0 <NEWLINE> for r in RL : <NEWLINE> <INDENT> for g in GL : <NEWLINE> <INDENT> bigger = max ( r , g ) <NEWLINE> smaller = min ( r , g ) <NEWLINE> delta = bigger - smaller <NEWLINE> if ( r + g ) % 2 == 0 : <NEWLINE> <INDENT> outnumber = [ bigger + delta , smaller - delta , ( r + g ) // 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> outnumber = [ bigger + delta , smaller - delta ] <NEWLINE> <DEDENT> for num in outnumber : <NEWLINE> <INDENT> if num in SBL : <NEWLINE> <INDENT> out_count += 1 <NEWLINE> <DEDENT> <DEDENT> ans += nagasa_b <NEWLINE> <DEDENT> <DEDENT> ans -= out_count <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , numpy , string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> P = LI ( ) <NEWLINE> ans = 0 <NEWLINE> min_num = P [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if min_num >= P [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> min_num = P [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> Alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Alist . sort ( ) <NEWLINE> ans = 1 <NEWLINE> err = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * Alist [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> err = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if err == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = n // 2019 <NEWLINE> b = m // 2019 <NEWLINE> if n * m % 2019 == 0 or b - a >= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> best = 2018 <NEWLINE> for c in range ( n % 2019 , m % 2019 ) : <NEWLINE> <INDENT> for d in range ( c + 1 , m % 2019 + 1 ) : <NEWLINE> <INDENT> if c * d % 2019 < best : <NEWLINE> <INDENT> best = c * d % 2019 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( best ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> def comb ( n , r ) : <NEWLINE> <INDENT> return ( fact [ n ] * revfact [ n - r ] * revfact [ r ] ) % mod <NEWLINE> <NL> <DEDENT> mod = 998244353 <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> fact = [ 1 ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> fact [ i ] = ( fact [ i - 1 ] * i ) % mod <COMMENT> <NEWLINE> <COMMENT> <NL> <DEDENT> revfact = [ 1 ] * ( N + 1 ) <COMMENT> <NEWLINE> revfact [ N ] = pow ( fact [ N ] , mod - 2 , mod ) <COMMENT> <NEWLINE> <COMMENT> <NL> for i in reversed ( range ( 1 , N ) ) : <COMMENT> <NEWLINE> <INDENT> revfact [ i ] = ( ( i + 1 ) * revfact [ i + 1 ] ) % mod <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for k in range ( K + 1 ) : <NEWLINE> <INDENT> ans += ( M * pow ( M - 1 , N - 1 - k , mod ) * comb ( N - 1 , k ) ) % mod <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> list_A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in list_A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> result = 1 <NEWLINE> for a in list_A : <NEWLINE> <INDENT> result *= a <NEWLINE> if result > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> d = 0 <NEWLINE> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> b = i * ( i - 1 ) / 2 <NEWLINE> c = i * ( 2 * n - i + 1 ) / 2 <NEWLINE> d += ( c - b + 1 ) <NEWLINE> <DEDENT> print ( int ( d ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
t = input ( ) <NEWLINE> le = len ( t ) <NEWLINE> tt = [ ] <NEWLINE> for i in range ( le ) : <NEWLINE> <INDENT> c = t [ i ] <NEWLINE> if t [ i ] == <STRING> : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> if i > 0 and tt [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> <DEDENT> elif i == 0 and le > 1 and t [ i + 1 ] == <STRING> or i == 0 and le > 1 and t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> <DEDENT> elif i < le - 1 and t [ i + 1 ] == <STRING> or i < le - 1 and t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> <DEDENT> <DEDENT> tt . append ( c ) <NEWLINE> <DEDENT> print ( <STRING> . join ( tt ) ) <NEWLINE>
import numpy as np <NEWLINE> import pprint <NEWLINE> import math <NEWLINE> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = min ( n , b - 1 ) <NEWLINE> ans = math . floor ( a * s / b ) - a * math . floor ( s / b ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x . sort ( ) <NEWLINE> print ( <STRING> % ( min ( x ) , max ( x ) , sum ( x ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> B , C = [ 0 ] * Q , [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B [ i ] , C [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> bucket = [ 0 ] * 100001 <NEWLINE> for i in A : <NEWLINE> <INDENT> bucket [ i ] += 1 <NEWLINE> <NL> <DEDENT> sum = sum ( A ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> sum += ( C [ i ] - B [ i ] ) * bucket [ B [ i ] ] <NEWLINE> bucket [ C [ i ] ] += bucket [ B [ i ] ] <NEWLINE> bucket [ B [ i ] ] = 0 <NEWLINE> print ( sum ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = <STRING> <NEWLINE> while n != 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> tmp = n % 26 <NEWLINE> s = chr ( 96 + tmp + 1 ) + s <NEWLINE> n //= 26 <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> s = <STRING> <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> s += <STRING> + str ( i ) <NEWLINE> <DEDENT> elif <STRING> in list ( str ( i ) ) : <NEWLINE> <INDENT> s += <STRING> + str ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
from collections import deque <NEWLINE> s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> d = deque ( ) <NEWLINE> for i in s : <NEWLINE> <INDENT> d . append ( i ) <NEWLINE> <DEDENT> rv = 0 <NEWLINE> lst = [ 1 , 0 ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> z = input ( ) <NEWLINE> if z [ 0 ] == <STRING> : <NEWLINE> <INDENT> rv = lst [ rv ] <NEWLINE> <DEDENT> elif z [ 2 ] == <STRING> : <NEWLINE> <INDENT> if rv == 1 : <NEWLINE> <INDENT> d . append ( z [ 4 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . appendleft ( z [ 4 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if rv == 0 : <NEWLINE> <INDENT> d . append ( z [ 4 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . appendleft ( z [ 4 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if rv == 1 : <NEWLINE> <INDENT> print ( <STRING> . join ( d ) [ : : - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( d ) ) <NEWLINE> <DEDENT>
from math import sqrt <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> result = [ 0 ] * N <NEWLINE> <NL> n = int ( sqrt ( N ) ) <NEWLINE> <NL> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> check = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> <NL> if check <= N : <NEWLINE> <INDENT> result [ check - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in result : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> a , b , n = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if n < b - 1 : <NEWLINE> <INDENT> ans = ( a * n // b ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = ( ( b - 1 ) * a ) // b <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> taka = a <NEWLINE> aoki = b <NEWLINE> recur = k <NEWLINE> if taka >= k : <NEWLINE> <INDENT> print ( <STRING> . format ( taka - k , aoki ) ) <NEWLINE> <DEDENT> elif k >= taka and ( aoki + taka ) >= k : <NEWLINE> <INDENT> print ( <STRING> . format ( 0 , aoki - ( k - taka ) ) ) <NEWLINE> <DEDENT> elif ( aoki + taka ) <= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if ( i + j ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> result = [ 1 for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if h [ a - 1 ] < h [ b - 1 ] : <NEWLINE> <INDENT> result [ a - 1 ] = 0 <NEWLINE> <DEDENT> elif h [ a - 1 ] > h [ b - 1 ] : <NEWLINE> <INDENT> result [ b - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result [ b - 1 ] = 0 <NEWLINE> result [ a - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result . count ( 1 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> import heapq <NEWLINE> <NL> <NL> <NL> <NL> <NL> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> heap = factorization ( N ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> heapq . heapify ( heap ) <NEWLINE> ans = 0 <NEWLINE> <NL> while ( heap ) : <NEWLINE> <COMMENT> <NL> <INDENT> if N == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sub , prime , cnt = heapq . heappop ( heap ) <NEWLINE> if N < sub : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if N % sub == 0 : <NEWLINE> <INDENT> N = N // sub <NEWLINE> ans += 1 <NEWLINE> if cnt > 0 : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> sub *= prime <NEWLINE> heapq . heappush ( heap , [ sub , prime , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = ( 10 ** 9 + 7 ) <NEWLINE> ans = 0 <NEWLINE> <NL> import numpy <NEWLINE> alistsum = numpy . cumsum ( alist ) <NEWLINE> asum = sum ( alist ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += alist [ i ] * ( asum - alist [ i ] ) <NEWLINE> asum -= alist [ i ] <NEWLINE> ans = ans % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from numba import njit <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> @ njit <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> f = [ 1 ] * ( n + 1 ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if f [ i ] != 1 : continue <NEWLINE> m = i <NEWLINE> while m <= n : <NEWLINE> <INDENT> tmp = m <NEWLINE> cnt = 0 <NEWLINE> while tmp % i == 0 : <NEWLINE> <INDENT> tmp = tmp // i <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> f [ m ] *= cnt + 1 <NEWLINE> m += i <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += i * f [ i ] <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> dum = round ( p ** ( 1 / n ) ) <NEWLINE> for i in range ( dum , - 1 , - 1 ) : <NEWLINE> <INDENT> if p % ( i ** n ) == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> B = deque ( A [ : K ] ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if B . popleft ( ) < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> B . append ( A [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import defaultdict <NEWLINE> <NL> <NL> def solve ( * args : str ) -> str : <NEWLINE> <INDENT> t = int ( args [ 0 ] ) <NEWLINE> NABCD = [ tuple ( map ( int , nabcd . split ( ) ) ) for nabcd in args [ 1 : ] ] <NEWLINE> <NL> ret = [ ] <NEWLINE> for n , a , b , c , d in NABCD : <NEWLINE> <INDENT> ABC = ( ( 2 , a ) , ( 3 , b ) , ( 5 , c ) ) <NEWLINE> dp = defaultdict ( lambda : n * d ) <NEWLINE> stack = [ ( n , 0 ) ] <NEWLINE> while stack : <NEWLINE> <INDENT> rem , cost = stack . pop ( ) <NEWLINE> if min ( dp [ 0 ] , dp [ rem ] ) <= cost : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> dp [ rem ] = cost <NEWLINE> dp [ 0 ] = min ( dp [ 0 ] , cost + rem * d ) <NEWLINE> <NL> if 0 < rem : <NEWLINE> <INDENT> for x , y in ABC : <NEWLINE> <INDENT> l , h = rem // x , - ( - rem // x ) <NEWLINE> stack . append ( ( l , d * abs ( l * x - rem ) + cost + y * ( 0 < l ) ) ) <NEWLINE> stack . append ( ( h , d * abs ( h * x - rem ) + cost + y ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ret . append ( str ( dp [ 0 ] ) ) <NEWLINE> <NL> <DEDENT> return <STRING> . join ( ret ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( solve ( * ( open ( 0 ) . read ( ) . splitlines ( ) ) ) ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> <NL> print ( int ( a + a ** 2 + a ** 3 ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> box = [ ] <NEWLINE> cnt = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> box . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> <DEDENT> box . append ( cnt ) <NEWLINE> print ( max ( box ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> friendly = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> friendly . sort ( reverse = True ) <NEWLINE> if len ( friendly ) <= 2 : <NEWLINE> <INDENT> print ( sum ( friendly [ 0 : n - 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = friendly [ 0 ] + sum ( friendly [ 1 : ( n + 1 ) // 2 - 1 ] ) * 2 + friendly [ ( n + 1 ) // 2 - 1 ] * ( ( n + 1 ) % 2 + 1 ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> Takahashi = 0 <NEWLINE> Aoki = 0 <NEWLINE> while C - B > 0 : <NEWLINE> <INDENT> C -= B <NEWLINE> Takahashi += 1 <NEWLINE> <DEDENT> while A - D > 0 : <NEWLINE> <INDENT> A -= D <NEWLINE> Aoki += 1 <NEWLINE> <DEDENT> print ( <STRING> ) if Aoki >= Takahashi else print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> N , W = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> items = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> items . append ( tuple ( int ( x ) for x in input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> DP = [ [ 0 ] * ( W + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( W + 1 ) : <NEWLINE> <INDENT> v , w = items [ i ] <NEWLINE> if w <= j : <NEWLINE> <INDENT> DP [ i + 1 ] [ j ] = max ( DP [ i ] [ j ] , v + DP [ i + 1 ] [ j - w ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> DP [ i + 1 ] [ j ] = DP [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( DP [ - 1 ] [ - 1 ] ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> <NL> area = math . pi * r * r <NEWLINE> circum = 2 * math . pi * r <NEWLINE> print ( str ( <STRING> . format ( area ) ) + <STRING> + str ( <STRING> . format ( circum ) ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> MOD = 1000000007 <COMMENT> <NEWLINE> <NL> <NL> def solve ( N : int , K : int ) : <NEWLINE> <INDENT> num_gcd = { } <NEWLINE> for k in range ( K , 0 , - 1 ) : <NEWLINE> <INDENT> num_select = K // k <NEWLINE> num_gcd_k = pow ( num_select , N , MOD ) <NEWLINE> for multiple in range ( 2 , num_select + 1 ) : <NEWLINE> <INDENT> num_gcd_k -= num_gcd [ k * multiple ] <NEWLINE> <DEDENT> num_gcd [ k ] = num_gcd_k <NEWLINE> <NL> <DEDENT> result = 0 <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> result += ( k * num_gcd [ k ] ) % MOD <NEWLINE> <DEDENT> print ( result % MOD ) <NEWLINE> return <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> K = int ( next ( tokens ) ) <COMMENT> <NEWLINE> solve ( N , K ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) [ : : - 1 ] <NEWLINE> l = len ( s ) <NEWLINE> x = [ 0 for _ in range ( 2019 ) ] <NEWLINE> x [ 0 ] += 1 <NEWLINE> k = 0 <NEWLINE> p = 1 <NEWLINE> for si in s : <NEWLINE> <INDENT> k += int ( si ) * p % 2019 <NEWLINE> k %= 2019 <NEWLINE> x [ k ] += 1 <NEWLINE> p *= 10 <NEWLINE> p %= 2019 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for xi in x : <NEWLINE> <INDENT> ans += max ( 0 , xi * ( xi - 1 ) // 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> seki = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if seki <= 10 ** 18 : <NEWLINE> <INDENT> seki *= A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if seki <= 10 ** 18 : <NEWLINE> <INDENT> print ( seki ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> lista = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = Counter ( lista ) <NEWLINE> lista . sort ( ) <NEWLINE> <NL> M = 1000001 <NEWLINE> P = [ 0 ] * ( M + 1 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in lista : <NEWLINE> <INDENT> if P [ i ] == 0 : <NEWLINE> <INDENT> for j in range ( M + 1 ) : <NEWLINE> <INDENT> x = i * j <NEWLINE> if x > M : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> P [ x ] = 1 <NEWLINE> <DEDENT> if count [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A1 = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> A1 *= A [ j ] <NEWLINE> if A1 > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( A1 ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> from collections import deque <NEWLINE> scores = deque ( ) <NEWLINE> <NL> for i in range ( 0 , K ) : <NEWLINE> <INDENT> scores . append ( A [ i ] ) <NEWLINE> <NL> <DEDENT> for j in range ( K , N ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if scores . popleft ( ) < A [ j ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> scores . append ( A [ j ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> scores . append ( A [ j ] ) <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> ans = - 1 <NEWLINE> keep = 0 <NEWLINE> check = 7 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> keep = ( keep + check ) % K <NEWLINE> if keep == 0 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> check = ( check * 10 ) % K <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def solve ( arr , target ) : <NEWLINE> <INDENT> memo = { } <NEWLINE> return solve_rec ( 0 , arr , target , memo ) <NEWLINE> <NL> <DEDENT> def solve_rec ( i , arr , target , memo ) : <NEWLINE> <NL> <INDENT> res = False <NEWLINE> <NL> key = str ( i ) + <STRING> + str ( target ) <NEWLINE> if key in memo : <NEWLINE> <INDENT> res = memo [ key ] <NEWLINE> <DEDENT> elif target == 0 : <NEWLINE> <INDENT> res = True <NEWLINE> <DEDENT> elif i >= len ( arr ) : <NEWLINE> <INDENT> res = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res1 = solve_rec ( i + 1 , arr , target , memo ) <NEWLINE> res2 = solve_rec ( i + 1 , arr , target - arr [ i ] , memo ) <NEWLINE> res = res1 or res2 <NEWLINE> <NL> <DEDENT> memo [ key ] = res <NEWLINE> return res <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> targets = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> res = solve ( arr , targets [ i ] ) <NEWLINE> if res == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
S , T = open ( 0 ) . read ( ) . split ( ) <NEWLINE> score = 0 <NEWLINE> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> score = max ( score , sum ( [ T [ k ] == S [ i + k ] for k in range ( len ( T ) ) ] ) ) <NEWLINE> <DEDENT> print ( len ( T ) - score ) <NEWLINE>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> dis = abs ( A - B ) <NEWLINE> v = V - W <NEWLINE> <NL> if v > 0 and dis / v <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> N = len ( s ) <NEWLINE> kyonen = 2019 <NEWLINE> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> alist = [ ] <NEWLINE> for i in reversed ( range ( N ) ) : <NEWLINE> <INDENT> alist . append ( ( int ( s [ i ] ) * pow ( 10 , ( N - 1 - i ) , kyonen ) ) % kyonen ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ruisekiwa = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ruisekiwa . append ( ( ruisekiwa [ - 1 ] + alist [ i ] ) % kyonen ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> kazoe = [ 0 ] * 2019 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> kazoe [ ruisekiwa [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2019 ) : <NEWLINE> <INDENT> if kazoe [ i ] >= 2 : <NEWLINE> <INDENT> ans += int ( kazoe [ i ] * ( kazoe [ i ] - 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ruisekiwa [ N ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if min ( a ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> kList = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> kList . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( kList ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ls2 = [ 0 for x in range ( n ) ] <NEWLINE> <COMMENT> <NL> <NL> for x in ls : <NEWLINE> <INDENT> ls2 [ x - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for x in range ( n ) : <NEWLINE> <INDENT> print ( ls2 [ x ] ) <NEWLINE> <DEDENT>
from bisect import bisect_left <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> dp = [ 0 for i in range ( n ) ] <NEWLINE> dp [ 0 ] = a [ 0 ] <NEWLINE> length = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if dp [ length - 1 ] < a [ i ] : <NEWLINE> <INDENT> dp [ length ] = a [ i ] <NEWLINE> length += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ bisect_left ( dp [ : length ] , a [ i ] ) ] = a [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( length ) <NEWLINE>
<COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> aN = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> mQ = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def dfs ( cur , depth , ans ) : <NEWLINE> <COMMENT> <NL> <INDENT> if cur == ans : <NEWLINE> <INDENT> return True <NEWLINE> <COMMENT> <NL> <DEDENT> if cur in memo [ depth ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> memo [ depth ] . add ( cur ) <NEWLINE> <COMMENT> <NL> for i in range ( depth , N ) : <NEWLINE> <INDENT> if dfs ( cur + aN [ i ] , i + 1 , ans ) : <NEWLINE> <INDENT> return True <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> memo = [ set ( ) for j in range ( N + 1 ) ] <NEWLINE> if dfs ( 0 , 0 , mQ [ i ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> results = { } <NEWLINE> p_list = [ ] <NEWLINE> y_list = [ ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p , y = map ( int , input ( ) . split ( ) ) <NEWLINE> p_list . append ( p ) <NEWLINE> y_list . append ( y ) <NEWLINE> if results . get ( p ) is None : <NEWLINE> <INDENT> results [ p ] = [ y ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> results [ p ] . append ( y ) <NEWLINE> <DEDENT> <DEDENT> for i , p in results . items ( ) : <NEWLINE> <INDENT> p_sorted = sorted ( p ) <NEWLINE> results [ i ] = p_sorted <NEWLINE> <NL> <DEDENT> for i , p in enumerate ( p_list ) : <NEWLINE> <INDENT> import bisect <NEWLINE> print ( <STRING> . format ( p ) + <STRING> . format ( bisect . bisect_left ( results [ p ] , y_list [ i ] ) + 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ a - 1 ] = max ( A [ a - 1 ] , h [ b - 1 ] ) <NEWLINE> A [ b - 1 ] = max ( A [ b - 1 ] , h [ a - 1 ] ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] < h [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( N == 0 ) : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> nums . sort ( ) <NEWLINE> low = nums [ 0 ] <NEWLINE> high = nums [ - 1 ] <NEWLINE> minDiff = 100000000 <NEWLINE> minNum = - 1 <NEWLINE> for i in range ( - 10 , 110 ) : <NEWLINE> <INDENT> if i in nums : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Dif = abs ( X - i ) <NEWLINE> <DEDENT> if ( Dif < minDiff ) : <NEWLINE> <INDENT> minDiff = Dif <NEWLINE> minNum = i <NEWLINE> <DEDENT> <DEDENT> print ( minNum ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n > 0 : <NEWLINE> <INDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = [ ] <NEWLINE> <NL> <DEDENT> ans , dist = 0 , 1000 <NEWLINE> for i in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if i not in P : <NEWLINE> <INDENT> if abs ( i - x ) < dist : <NEWLINE> <INDENT> dist = abs ( i - x ) <NEWLINE> ans = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N >= B - 1 : <NEWLINE> <INDENT> i = B - 1 <NEWLINE> ans = A * i // B - A * ( i // B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A * N // B - A * ( N // B ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
input ( ) ; ans , a = 1 , [ * map ( int , input ( ) . split ( ) ) ] <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) ; break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> from collections import defaultdict <NEWLINE> from math import gcd <NEWLINE> <NL> iim = lambda : map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> it = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> d1 = [ defaultdict ( int ) , defaultdict ( int ) ] <NEWLINE> z0 = 0 <NEWLINE> for ai , bi in zip ( it , it ) : <NEWLINE> <INDENT> if ai == 0 and bi == 0 : <NEWLINE> <INDENT> z0 += 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> ci = gcd ( ai , bi ) <NEWLINE> ai , bi = ai // ci , bi // ci <NEWLINE> <NL> t = ai * bi < 0 <NEWLINE> if ai < 0 : <NEWLINE> <INDENT> ai , bi = - ai , - bi <NEWLINE> <DEDENT> elif ai == 0 : <NEWLINE> <INDENT> bi = - 1 <NEWLINE> t = 1 <NEWLINE> <NL> <DEDENT> d1 [ t ] [ ( ai , bi ) ] += 1 <NEWLINE> <NL> <NL> <DEDENT> a1 , a2 = d1 <NEWLINE> ans = 1 <NEWLINE> for ( ai , bi ) , v in a1 . items ( ) : <NEWLINE> <INDENT> k2 = ( bi , - ai ) <NEWLINE> if k2 in a2 : <NEWLINE> <INDENT> v2 = a2 [ k2 ] <NEWLINE> ans *= pow ( 2 , v , mod ) + pow ( 2 , v2 , mod ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= pow ( 2 , v , mod ) <NEWLINE> <DEDENT> ans %= mod <NEWLINE> <NL> <DEDENT> for ( ai , bi ) , v in a2 . items ( ) : <NEWLINE> <INDENT> k2 = ( - bi , ai ) <NEWLINE> <NL> if k2 in a1 : continue <NEWLINE> <NL> ans *= pow ( 2 , v , mod ) <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ( ans - 1 + z0 ) % mod ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] <NEWLINE> B = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( A [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( B [ i ] + b [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if A [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while j > 0 and k - A [ i ] < B [ j ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> dicti = { } <NEWLINE> boss = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in boss : <NEWLINE> <INDENT> if i in dicti : <NEWLINE> <INDENT> dicti [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dicti [ i ] = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> print ( dicti [ j ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
class Tree : <NEWLINE> <INDENT> root = None <NEWLINE> <NL> def insert ( self , node ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = self . root <NEWLINE> while x : <NEWLINE> <INDENT> y = x <NEWLINE> x = x . left if node . key < x . key else x . right <NEWLINE> <DEDENT> node . parent = y <NEWLINE> <NL> if not y : <NEWLINE> <INDENT> self . root = node <NEWLINE> <DEDENT> elif node . key < y . key : <NEWLINE> <INDENT> y . left = node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = node <NEWLINE> <NL> <DEDENT> <DEDENT> def find_node ( self , value ) : <NEWLINE> <INDENT> return self . root . find ( value ) <NEWLINE> <NL> <DEDENT> def find ( self , value ) : <NEWLINE> <INDENT> print ( <STRING> if self . find_node ( value ) else <STRING> ) <NEWLINE> <NL> <DEDENT> def delete ( self , value ) : <NEWLINE> <INDENT> self . find_node ( value ) . delete ( ) <NEWLINE> <NL> <DEDENT> def print ( self ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * self . root . print_in ( ) ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * self . root . print_pre ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Node : <NEWLINE> <INDENT> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . parent = self . left = self . right = None <NEWLINE> self . key = key <NEWLINE> <NL> <DEDENT> def find ( self , value ) : <NEWLINE> <INDENT> diff = self . key - value <NEWLINE> if diff == 0 : <NEWLINE> <INDENT> return self <NEWLINE> <DEDENT> elif diff > 0 : <NEWLINE> <INDENT> return self . left and self . left . find ( value ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . right and self . right . find ( value ) <NEWLINE> <NL> <DEDENT> <DEDENT> def delete ( self ) : <NEWLINE> <INDENT> left , right = self . left , self . right <NEWLINE> if not left and not right : <NEWLINE> <INDENT> self . delete_connect ( self . parent , None ) <NEWLINE> <DEDENT> elif left and not right : <NEWLINE> <INDENT> self . delete_connect ( self . parent , left ) <NEWLINE> <DEDENT> elif not left and right : <NEWLINE> <INDENT> self . delete_connect ( self . parent , right ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> next_node = right . get_leftmost ( ) <NEWLINE> self . key = next_node . key <NEWLINE> next_node . delete ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def delete_connect ( self , parent , child ) : <NEWLINE> <INDENT> if parent : <NEWLINE> <INDENT> if parent . key > self . key : <NEWLINE> <INDENT> parent . left = child <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent . right = child <NEWLINE> <DEDENT> <DEDENT> if child : <NEWLINE> <INDENT> child . parent = parent <NEWLINE> <NL> <DEDENT> <DEDENT> def get_leftmost ( self ) : <NEWLINE> <INDENT> if self . left : <NEWLINE> <INDENT> return self . left . get_leftmost ( ) <NEWLINE> <DEDENT> return self <NEWLINE> <NL> <DEDENT> def print_pre ( self ) : <NEWLINE> <INDENT> yield self . key <NEWLINE> if self . left : <NEWLINE> <INDENT> for k in self . left . print_pre ( ) : yield k <NEWLINE> <DEDENT> if self . right : <NEWLINE> <INDENT> for k in self . right . print_pre ( ) : yield k <NEWLINE> <NL> <DEDENT> <DEDENT> def print_in ( self ) : <NEWLINE> <INDENT> if self . left : <NEWLINE> <INDENT> for k in self . left . print_in ( ) : yield k <NEWLINE> <DEDENT> yield self . key <NEWLINE> if self . right : <NEWLINE> <INDENT> for k in self . right . print_in ( ) : yield k <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> tree = Tree ( ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> <NL> while m : <NEWLINE> <INDENT> l = input ( ) <NEWLINE> f = l [ 0 ] <NEWLINE> if f == <STRING> : <NEWLINE> <INDENT> tree . insert ( Node ( int ( l . split ( ) [ 1 ] ) ) ) <NEWLINE> <DEDENT> elif f == <STRING> : <NEWLINE> <INDENT> tree . find ( int ( l . split ( ) [ 1 ] ) ) <NEWLINE> <DEDENT> elif f == <STRING> : <NEWLINE> <INDENT> tree . delete ( int ( l . split ( ) [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree . print ( ) <NEWLINE> <DEDENT> m -= 1 <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> input_num = int ( input ( ) ) <NEWLINE> input_numline = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> op_list = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> op_list . append ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <NL> <DEDENT> maxnum = 100000 <NEWLINE> <NL> num_list = [ 0 for m in range ( maxnum + 1 ) ] <NEWLINE> <NL> for n in input_numline : <NEWLINE> <INDENT> num_list [ n ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for j in range ( maxnum + 1 ) : <NEWLINE> <INDENT> ans += j * num_list [ j ] <NEWLINE> <NL> <DEDENT> for o in op_list : <NEWLINE> <INDENT> ans -= o [ 0 ] * num_list [ o [ 0 ] ] <NEWLINE> ans += o [ 1 ] * num_list [ o [ 0 ] ] <NEWLINE> num_list [ o [ 1 ] ] += num_list [ o [ 0 ] ] <NEWLINE> num_list [ o [ 0 ] ] = 0 <NEWLINE> <NL> print ( ans ) <NEWLINE> <DEDENT>
from bisect import bisect_left as bl <NEWLINE> def primes ( n ) : <NEWLINE> <INDENT> tf = [ True ] * ( n + 1 ) <NEWLINE> tf [ 0 ] = tf [ 1 ] = False <NEWLINE> for i in range ( 2 , int ( n ** ( 1 / 2 ) + 1 ) ) : <NEWLINE> <INDENT> if tf [ i ] : <NEWLINE> <INDENT> for j in range ( i ** 2 , n + 1 , i ) : <NEWLINE> <INDENT> tf [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return [ i for i in range ( n + 1 ) if tf [ i ] ] <NEWLINE> <NL> <DEDENT> def search_pair ( x , prime_lst , len_prime ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for prime in prime_lst : <NEWLINE> <INDENT> if prime > x // 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i = bl ( prime_lst , x - prime ) <NEWLINE> if i < len_prime and prime_lst [ i ] == x - prime : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> prime_lst = primes ( 1000000 ) <NEWLINE> len_prime = len ( prime_lst ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( search_pair ( n , prime_lst , len_prime ) ) <NEWLINE> <NL> <DEDENT>
def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ps = [ ] <NEWLINE> dic = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> dic [ ( x , y ) ] = 1 ; <NEWLINE> <COMMENT> <NL> ps . append ( ( x , y ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> p1 = ps [ i ] <NEWLINE> p2 = ps [ j ] <NEWLINE> vx = p2 [ 0 ] - p1 [ 0 ] <NEWLINE> vy = p2 [ 1 ] - p1 [ 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if ( p1 [ 0 ] + vy , p1 [ 1 ] - vx ) in dic and ( p2 [ 0 ] + vy , p2 [ 1 ] - vx ) in dic : <NEWLINE> <INDENT> ans = max ( ans , vx ** 2 + vy ** 2 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE> <NL> <NL> <NL>
<COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> <COMMENT> <NL> file = sys . stdin <NEWLINE> <NL> r = float ( file . readline ( ) ) <NEWLINE> l = 2 * math . pi * r <NEWLINE> s = math . pi * r * r <NEWLINE> <NL> print ( <STRING> . format ( s , l ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> m = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = max ( m , a [ i ] ) <NEWLINE> ans += m - a [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> den = int ( 1e9 + 7 ) <NEWLINE> print ( ( 10 ** n - 2 * 9 ** n + 8 ** n ) % den ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> l = [ ] <NEWLINE> r = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l . append ( lr [ i ] [ 0 ] ) <NEWLINE> r . append ( lr [ i ] [ 1 ] ) <NEWLINE> <DEDENT> lm = max ( l ) <NEWLINE> rm = min ( r ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if lm <= i <= rm : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> hako = set ( P ) <NEWLINE> <COMMENT> <NL> ans = [ ] <NEWLINE> P . sort ( ) <NEWLINE> kari = [ ] <NEWLINE> for i in range ( 102 ) : <NEWLINE> <INDENT> if i not in hako : <NEWLINE> <INDENT> kari . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( kari ) ) : <NEWLINE> <INDENT> ans . append ( [ abs ( X - kari [ i ] ) , kari [ i ] ] ) <NEWLINE> <DEDENT> ans . sort ( ) <NEWLINE> print ( ans [ 0 ] [ 1 ] ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> ans = - 1 <NEWLINE> N = 7 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if N % K == 0 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> N = ( N * 10 + 7 ) % K <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import numpy as np <NEWLINE> from scipy . sparse . csgraph import shortest_path , floyd_warshall , dijkstra , bellman_ford , johnson <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> import networkx as nx <NEWLINE> <NL> import heapq <NEWLINE> import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def dijkstra_heap ( s , edge ) : <NEWLINE> <COMMENT> <NL> <INDENT> d = [ 10 ** 20 ] * N <NEWLINE> used = [ True ] * N <COMMENT> <NEWLINE> d [ s ] = 0 <NEWLINE> used [ s ] = False <NEWLINE> edgelist = [ ] <NEWLINE> path = [ - 1 ] * N <NEWLINE> for a , b in edge [ s ] : <NEWLINE> <INDENT> path [ b ] = s <NEWLINE> heapq . heappush ( edgelist , a * ( 10 ** 6 ) + b ) <NEWLINE> <DEDENT> while len ( edgelist ) : <NEWLINE> <INDENT> minedge = heapq . heappop ( edgelist ) <NEWLINE> <COMMENT> <NL> if not used [ minedge % ( 10 ** 6 ) ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v = minedge % ( 10 ** 6 ) <NEWLINE> d [ v ] = minedge // ( 10 ** 6 ) <NEWLINE> used [ v ] = False <NEWLINE> for e in edge [ v ] : <NEWLINE> <INDENT> if used [ e [ 1 ] ] : <NEWLINE> <INDENT> if path [ e [ 1 ] ] == - 1 : <NEWLINE> <INDENT> path [ e [ 1 ] ] = v <NEWLINE> <DEDENT> heapq . heappush ( edgelist , ( e [ 0 ] + d [ v ] ) * ( 10 ** 6 ) + e [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d , path <NEWLINE> <NL> <DEDENT> edge = [ [ ] for i in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ x - 1 ] . append ( [ 1 , y - 1 ] ) <NEWLINE> edge [ y - 1 ] . append ( [ 1 , x - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> d , path = dijkstra_heap ( 0 , edge ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( path [ i ] + 1 ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from math import ceil , floor , sqrt , pi , factorial , gcd <NEWLINE> from copy import deepcopy <NEWLINE> from collections import Counter , deque <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from itertools import accumulate , product , combinations , combinations_with_replacement <NEWLINE> from bisect import bisect , bisect_left , bisect_right <NEWLINE> from functools import reduce <NEWLINE> from decimal import Decimal , getcontext <NEWLINE> <COMMENT> <NL> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> def lcm ( a , b ) : return a * b // gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> num_list = [ ] <NEWLINE> str_list = [ ] <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> h , w = i_map ( ) <NEWLINE> str_list = s_row_list ( h ) <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if str_list [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i != 0 : <NEWLINE> <INDENT> if str_list [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if j != 0 : <NEWLINE> <INDENT> if str_list [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if i != h - 1 : <NEWLINE> <INDENT> if str_list [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if j != w - 1 : <NEWLINE> <INDENT> if str_list [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> l = set ( S [ : i ] ) <NEWLINE> r = set ( S [ i : ] ) <NEWLINE> ans . append ( len ( l & r ) ) <NEWLINE> <DEDENT> print ( max ( ans ) ) <NEWLINE>
import itertools <NEWLINE> <NL> <NL> def out ( X ) : <NEWLINE> <INDENT> return list ( itertools . accumulate ( X , func = lambda x , y : x * y % mod ) ) [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> N , K = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> A = sorted ( [ int ( _ ) for _ in input ( ) . split ( ) ] , key = lambda x : - abs ( x ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ipos = ineg = - 1 <NEWLINE> for i , a in enumerate ( A [ : K ] ) : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> ineg = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ipos = i <NEWLINE> <DEDENT> <DEDENT> if cnt % 2 == 0 : <NEWLINE> <INDENT> print ( out ( A [ : K ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> oneg = opos = - 10 ** 10 <NEWLINE> for i , a in enumerate ( A [ K : ] ) : <NEWLINE> <INDENT> if a < 0 and ipos != - 1 : <NEWLINE> <INDENT> X = A [ : ipos ] + A [ ipos + 1 : K ] + [ A [ K + i ] ] <NEWLINE> oneg = out ( X ) <NEWLINE> beforeneg = A [ ipos ] <NEWLINE> afterneg = A [ K + i ] <NEWLINE> ipos = - 1 <NEWLINE> <DEDENT> elif a > 0 and ineg != - 1 : <NEWLINE> <INDENT> Y = A [ : ineg ] + A [ ineg + 1 : K ] + [ A [ K + i ] ] <NEWLINE> opos = out ( Y ) <NEWLINE> beforepos = A [ ineg ] <NEWLINE> afterpos = A [ K + i ] <NEWLINE> ineg = - 1 <NEWLINE> <DEDENT> <DEDENT> if oneg != - 10 ** 10 and opos != - 10 ** 10 : <NEWLINE> <COMMENT> <NL> <INDENT> if afterneg * beforepos > afterpos * beforeneg : <NEWLINE> <INDENT> print ( oneg ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( opos ) <NEWLINE> <DEDENT> <DEDENT> elif oneg != - 10 ** 10 or opos != - 10 ** 10 : <NEWLINE> <INDENT> print ( max ( opos , oneg ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C = A [ : : - 1 ] <NEWLINE> print ( out ( C [ : K ] ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from math import gcd <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> <NL> res = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> g1 = gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> g2 = gcd ( g1 , c ) <NEWLINE> res += g2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n , r = open ( 0 ) . read ( ) . split ( maxsplit = 1 ) <NEWLINE> n = int ( n ) <NEWLINE> * a , r = r . split ( maxsplit = n ) <NEWLINE> a = list ( map ( int , a ) ) <NEWLINE> q , * bc = map ( int , r . split ( ) ) <NEWLINE> <NL> d = { } <NEWLINE> for x in a : <NEWLINE> <INDENT> if x in d : <NEWLINE> <INDENT> d [ x ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ x ] = 1 <NEWLINE> <DEDENT> <DEDENT> ret = sum ( a ) <NEWLINE> for i in range ( 0 , min ( q * 2 , len ( bc ) ) , 2 ) : <NEWLINE> <INDENT> b = bc [ i ] <NEWLINE> c = bc [ i + 1 ] <NEWLINE> if b in d : <NEWLINE> <INDENT> v = d . pop ( b ) <NEWLINE> if c in d : <NEWLINE> <INDENT> d [ c ] += v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ c ] = v <NEWLINE> <DEDENT> ret += c * v - b * v <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ret ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> max_res = int ( a * x / b ) - a * int ( x / b ) <NEWLINE> print ( max_res ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> <NL> def checker ( n ) : <NEWLINE> <INDENT> n = str ( n ) <NEWLINE> OK3 = False <NEWLINE> OK5 = False <NEWLINE> OK7 = False <NEWLINE> for i in n : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> OK3 = True <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> OK5 = True <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> OK7 = True <NEWLINE> <DEDENT> <DEDENT> if OK3 and OK5 and OK7 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> if n < 357 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> nxt = [ 3 , 5 , 7 ] <NEWLINE> nxt = deque ( nxt ) <NEWLINE> OK = True <NEWLINE> while OK : <NEWLINE> <INDENT> a = nxt . popleft ( ) <NEWLINE> if a > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> nxt . append ( a * 10 + 3 ) <NEWLINE> nxt . append ( a * 10 + 5 ) <NEWLINE> nxt . append ( a * 10 + 7 ) <NEWLINE> if checker ( a ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
s = input ( ) [ : : - 1 ] <COMMENT> <NEWLINE> <NL> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> <NL> num , d = 0 , 1 <NEWLINE> <NL> for char in s : <NEWLINE> <INDENT> num += int ( char ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> counts [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in counts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <COMMENT> <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> <NL> g = { } <NEWLINE> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans += a <NEWLINE> if a not in g : <NEWLINE> <INDENT> g [ a ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g [ a ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = tuple ( BC [ i ] ) <NEWLINE> if B in g : <NEWLINE> <INDENT> t = g . pop ( B ) <NEWLINE> ans += t * ( C - B ) <NEWLINE> if C in g : <NEWLINE> <INDENT> g [ C ] += t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g [ C ] = t <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import string <NEWLINE> a = string . ascii_lowercase <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> count = 1 <NEWLINE> n = 26 <NEWLINE> s = 0 <NEWLINE> while N > n : <NEWLINE> <INDENT> count += 1 <NEWLINE> s = n <NEWLINE> n += 26 ** count <NEWLINE> <DEDENT> N -= s + 1 <NEWLINE> for i in range ( count ) : <NEWLINE> <INDENT> n = N // 26 <NEWLINE> m = N % 26 <NEWLINE> ans . append ( a [ m ] ) <NEWLINE> N = n <NEWLINE> <DEDENT> Ans = [ ] <NEWLINE> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> Ans . append ( ans [ len ( ans ) - i - 1 ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( Ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> B = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> B . append ( 0 ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> taosukazu1 = min ( A [ i ] , B [ i ] ) <NEWLINE> B [ i ] -= taosukazu1 <NEWLINE> A [ i ] -= taosukazu1 <NEWLINE> ans += taosukazu1 <NEWLINE> if B [ i ] > 0 : <NEWLINE> <INDENT> taosukazu2 = min ( A [ i + 1 ] , B [ i ] ) <NEWLINE> B [ i ] -= taosukazu2 <NEWLINE> A [ i + 1 ] -= taosukazu2 <NEWLINE> ans += taosukazu2 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import copy <NEWLINE> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> C = [ ] <NEWLINE> A = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ipt = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C . append ( ipt [ 0 ] ) <NEWLINE> A [ i ] = ipt [ 1 : ] <NEWLINE> <NL> <DEDENT> bestscore = 99999999999 <NEWLINE> def rec ( n , score , money ) : <NEWLINE> <INDENT> global bestscore <NEWLINE> if n == N : return <NEWLINE> s = copy . deepcopy ( score ) <NEWLINE> rec ( n + 1 , s , money ) <NEWLINE> <NL> money += C [ n ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> score [ i ] += A [ n ] [ i ] <NEWLINE> <NL> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> if score [ i ] < X : <NEWLINE> <INDENT> s = copy . deepcopy ( score ) <NEWLINE> rec ( n + 1 , s , money ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> bestscore = min ( bestscore , money ) <NEWLINE> <NL> <DEDENT> score = [ 0 for i in range ( M ) ] <NEWLINE> <NL> rec ( 0 , score , 0 ) <NEWLINE> if bestscore == 99999999999 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( bestscore ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> import numpy as np <NEWLINE> n , k = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> a = np . array ( stdin . readline ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> <NL> ng = 0 <NEWLINE> ok = 10 ** 9 + 1 <NEWLINE> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) >> 1 <NEWLINE> if np . sum ( 0 - - a // mid - 1 ) <= k : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> print ( ok ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += ( N - 1 ) // i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> cnt = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if s [ i ] == s [ j ] or k >= n or s [ k ] == s [ i ] or s [ k ] == s [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL>
l = [ [ [ 0 for i in range ( 10 ) ] for i in range ( 3 ) ] for i in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b , c , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l [ a - 1 ] [ b - 1 ] [ c - 1 ] += d <NEWLINE> <DEDENT> for i in l [ : - 1 ] : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( list ( map ( str , j ) ) ) ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> for j in l [ - 1 ] : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( list ( map ( str , j ) ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> num_list = list ( ) <NEWLINE> string = input ( ) . split ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num_list . append ( int ( string [ i ] ) ) <NEWLINE> <DEDENT> del n <NEWLINE> del string <NEWLINE> num_list = sorted ( num_list ) <NEWLINE> pro = 1 <NEWLINE> for number in num_list : <NEWLINE> <INDENT> pro *= number <NEWLINE> if pro > 10 ** 18 : <NEWLINE> <INDENT> pro = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( pro ) <NEWLINE>
n = ( input ( ) ) <NEWLINE> if n == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n . count ( <STRING> ) ) <NEWLINE> <DEDENT>
mod = 10 ** 9 + 7 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> pi = 1 <NEWLINE> ni = 0 <NEWLINE> ans = 1 <NEWLINE> i = 0 <NEWLINE> while i < k - 1 : <NEWLINE> <INDENT> if a [ ni ] * a [ ni + 1 ] > a [ - pi ] * a [ - pi - 1 ] : <NEWLINE> <INDENT> ans = ans * a [ ni ] * a [ ni + 1 ] % mod <NEWLINE> ni += 2 <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * a [ - pi ] % mod <NEWLINE> pi += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> if i == k - 1 : <NEWLINE> <INDENT> ans = ans * a [ - pi ] % mod <NEWLINE> <DEDENT> if a [ - 1 ] < 0 and k % 2 == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in a [ n - k : ] : <NEWLINE> <INDENT> ans = ans * i % mod <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import Counter <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> c_s = Counter ( s ) <NEWLINE> sum_a = 0 <NEWLINE> for diff in range ( 1 , ( n - 1 ) // 2 + 1 ) : <NEWLINE> <INDENT> for i in range ( n - 2 * diff ) : <NEWLINE> <INDENT> if s [ i ] != s [ i + diff ] and s [ i + diff ] != s [ i + 2 * diff ] and s [ i ] != s [ i + 2 * diff ] : <NEWLINE> <INDENT> sum_a += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c_s [ <STRING> ] * c_s [ <STRING> ] * c_s [ <STRING> ] - sum_a ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( math . pi * r ** 2 , math . pi * 2 * r ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tmp = 1000 <NEWLINE> result = [ ] <NEWLINE> result2 = [ ] <NEWLINE> for i in range ( 0 , 102 ) : <NEWLINE> <INDENT> if i in A : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> hoge = abs ( X - i ) <NEWLINE> if hoge <= tmp : <NEWLINE> <INDENT> tmp = hoge <NEWLINE> result2 . append ( tmp ) <NEWLINE> result . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> result3 = [ ] <NEWLINE> for i , v in enumerate ( result2 ) : <NEWLINE> <INDENT> if v == min ( result2 ) : <NEWLINE> <INDENT> result3 . append ( result [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( result3 ) ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> tmp = 7 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if tmp % K == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> tmp = ( tmp * 10 + 7 ) % K <NEWLINE> tmp %= K <NEWLINE> <DEDENT> print ( - 1 ) <NEWLINE>
def ans ( n ) : <NEWLINE> <NL> <INDENT> aa = 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> aa += int ( i ) <NEWLINE> <DEDENT> return True if aa % 9 == 0 else False <NEWLINE> <NL> <NL> <DEDENT> n = input ( ) <NEWLINE> <NL> print ( <STRING> if ans ( n ) else <STRING> ) <NEWLINE>
from collections import Counter <NEWLINE> from itertools import accumulate <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> aaa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> acc = [ 0 ] + list ( accumulate ( aaa ) ) <NEWLINE> agg = Counter ( acc ) <NEWLINE> print ( sum ( v * ( v - 1 ) // 2 for v in agg . values ( ) ) ) <NEWLINE>
def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> prime_list = factorization ( p ) <NEWLINE> ans = 1 <NEWLINE> for x in prime_list : <NEWLINE> <INDENT> ans *= x [ 0 ] ** ( x [ 1 ] // n ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( sys . stdin . readline ( ) ) <NEWLINE> P = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i , p_i in enumerate ( P ) : <NEWLINE> <INDENT> if p_i == i + 1 : <NEWLINE> <INDENT> if i + 1 == N : <NEWLINE> <INDENT> P [ i ] , P [ i - 1 ] = P [ i - 1 ] , P [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P [ i + 1 ] , P [ i ] = P [ i ] , P [ i + 1 ] <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
counter = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( counter , x ) ) <NEWLINE> counter = counter + 1 <NEWLINE> <NL> <DEDENT> <DEDENT>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if Y % 1000 != 0 : <NEWLINE> <INDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE> <NL> <DEDENT> n1 = Y // 10000 <NEWLINE> n2 = Y // 5000 <NEWLINE> <NL> for i in range ( n1 + 1 ) : <NEWLINE> <INDENT> for j in range ( n2 + 1 ) : <NEWLINE> <INDENT> if ( N - i - j ) < 0 : continue <NEWLINE> if i * 10000 + j * 5000 + ( N - i - j ) * 1000 == Y : <NEWLINE> <INDENT> print ( i , j , ( N - i - j ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if Y < i * 10000 + j * 5000 + ( N - i - j ) * 1000 : break <NEWLINE> <DEDENT> <DEDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( int ( p ** ( 1 / n ) + ( p > n ** 2 ) ) , 0 , - 1 ) : <NEWLINE> <INDENT> if p % i ** n == 0 : exit ( print ( i ) ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> cnt = 0 <NEWLINE> pre = <STRING> <NEWLINE> tmp = <STRING> <NEWLINE> for s in S : <NEWLINE> <INDENT> tmp += s <NEWLINE> if tmp != pre : <NEWLINE> <INDENT> pre = tmp <NEWLINE> tmp = <STRING> <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> money = 1000 <NEWLINE> stock = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> tmp = money // A [ i ] <NEWLINE> stock += tmp <NEWLINE> money -= tmp * A [ i ] <NEWLINE> <DEDENT> if A [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> money += stock * A [ i ] <NEWLINE> stock = 0 <NEWLINE> <DEDENT> <DEDENT> money += stock * A [ - 1 ] <NEWLINE> print ( money ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> s = str ( input ( ) ) <NEWLINE> a . append ( s ) <NEWLINE> <DEDENT> ans = set ( a ) <NEWLINE> print ( len ( ans ) ) <NEWLINE>
<COMMENT> <NL> class RootedTree : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . id = None <NEWLINE> self . child = [ ] <NEWLINE> self . parent = - 1 <NEWLINE> self . node_type = <STRING> <NEWLINE> self . depth = 0 <NEWLINE> <NL> <DEDENT> def show ( self ) : <NEWLINE> <INDENT> print ( <STRING> . format ( self . id , self . parent , self . depth , self . node_type , self . child ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def cal_depth ( tree , node , cur_depth ) : <NEWLINE> <INDENT> node . depth += cur_depth <NEWLINE> <COMMENT> <NL> for index in node . child : <NEWLINE> <INDENT> cal_depth ( tree , tree [ index ] , cur_depth + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def make_tree ( tree_data ) : <COMMENT> <NEWLINE> <INDENT> tree = [ RootedTree ( ) for i in range ( len ( tree_data ) ) ] <NEWLINE> <NL> for data in tree_data : <NEWLINE> <INDENT> focus = tree [ data [ 0 ] ] <NEWLINE> focus . id = data [ 0 ] <NEWLINE> <NL> if data [ 2 : ] : <NEWLINE> <INDENT> focus . child = data [ 2 : ] <NEWLINE> <NL> for child_index in data [ 2 : ] : <NEWLINE> <INDENT> tree [ child_index ] . parent = data [ 0 ] <NEWLINE> <NL> if tree_data [ [ a [ 0 ] for a in tree_data ] . index ( child_index ) ] [ 2 : ] : <NEWLINE> <INDENT> tree [ child_index ] . node_type = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree [ child_index ] . node_type = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> root_index = [ n . node_type for n in tree ] . index ( <STRING> ) <NEWLINE> cal_depth ( tree , tree [ root_index ] , 0 ) <NEWLINE> return tree <NEWLINE> <NL> <DEDENT> def set_tree_data ( tree , target , parent , depth ) : <NEWLINE> <INDENT> tree [ target ] [ <STRING> ] += depth <NEWLINE> tree [ target ] [ <STRING> ] = parent <NEWLINE> <NL> for c in tree [ target ] [ <STRING> ] : <NEWLINE> <INDENT> set_tree_data ( tree , c , target , depth + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def make_tree_revision ( tree_data , n_tree ) : <NEWLINE> <INDENT> tree = [ { <STRING> : None , <STRING> : 0 , <STRING> : None } for i in range ( n_tree ) ] <NEWLINE> root = sum ( range ( n_tree ) ) <NEWLINE> <NL> for node_data in tree_data : <NEWLINE> <INDENT> tree [ node_data [ 0 ] ] [ <STRING> ] = node_data [ 2 : ] <NEWLINE> root -= sum ( node_data [ 2 : ] ) <NEWLINE> <NL> <DEDENT> set_tree_data ( tree , root , - 1 , 0 ) <NEWLINE> return tree <NEWLINE> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n_tree = int ( input ( ) ) <NEWLINE> tree_data = [ [ int ( a ) for a in input ( ) . split ( ) ] for i in range ( n_tree ) ] <NEWLINE> <NL> for i , node in enumerate ( make_tree_revision ( tree_data , n_tree ) ) : <NEWLINE> <INDENT> category = <STRING> <NEWLINE> if ( not node [ <STRING> ] == - 1 ) and node [ <STRING> ] : <NEWLINE> <INDENT> category = <STRING> <NEWLINE> <DEDENT> elif not node [ <STRING> ] == - 1 : <NEWLINE> <INDENT> category = <STRING> <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( i , node [ <STRING> ] , node [ <STRING> ] , category , node [ <STRING> ] ) ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> acum = [ 0 ] * ( n + 1 ) <NEWLINE> bcum = [ 0 ] * ( m + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> acum [ i + 1 ] = acum [ i ] + a [ i ] <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> bcum [ i + 1 ] = bcum [ i ] + b [ i ] <NEWLINE> <NL> <DEDENT> j = m <NEWLINE> maxv = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if acum [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while acum [ i ] + bcum [ j ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> maxv = max ( maxv , i + j ) <NEWLINE> <DEDENT> print ( maxv ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> f = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> f = 0 <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> f *= i <NEWLINE> if f > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( f ) <NEWLINE> <DEDENT> solve ( ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> s_count = collections . Counter ( s ) <NEWLINE> largest = max ( list ( s_count . values ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for key in list ( s_count . keys ( ) ) : <NEWLINE> <INDENT> if s_count . get ( key ) == largest : <NEWLINE> <INDENT> ans . append ( key ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans . sort ( ) <NEWLINE> <NL> for word in ans : <NEWLINE> <INDENT> print ( word ) <NEWLINE> <DEDENT>
MOD = 1000000007 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> str_ary = input ( ) . split ( ) <NEWLINE> ary = [ int ( c ) for c in str_ary ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> result = 0 <NEWLINE> sum = sum ( ary [ i ] for i in range ( n ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> sum -= ary [ i ] <NEWLINE> result += ary [ i ] * sum <NEWLINE> <NL> <DEDENT> print ( result % MOD ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_num = 0 <NEWLINE> b_num = 0 <NEWLINE> book_num = 0 <NEWLINE> passed_k = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] + passed_k <= k : <NEWLINE> <INDENT> a_num += 1 <NEWLINE> passed_k += a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if b [ i ] + passed_k <= k : <NEWLINE> <INDENT> b_num += 1 <NEWLINE> passed_k += b [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> book_num = a_num + b_num <NEWLINE> <NL> while a_num > 0 : <NEWLINE> <INDENT> passed_k -= a [ a_num - 1 ] <NEWLINE> a_num -= 1 <NEWLINE> while b_num < m : <NEWLINE> <INDENT> if passed_k + b [ b_num ] <= k : <NEWLINE> <INDENT> passed_k += b [ b_num ] <NEWLINE> b_num += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> book_num = max ( book_num , a_num + b_num ) <NEWLINE> if b_num == m : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( book_num ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> col = [ 0 ] * n <NEWLINE> next = [ [ ] for i in range ( n ) ] <NEWLINE> d = [ float ( <STRING> ) ] * n <NEWLINE> d [ 0 ] = 0 <NEWLINE> <NL> def dfs ( now , parent ) : <NEWLINE> <INDENT> for next1 , w1 in next [ now ] : <NEWLINE> <INDENT> if next1 == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif d [ next1 ] == float ( <STRING> ) : <NEWLINE> <INDENT> d [ next1 ] = d [ now ] + w1 <NEWLINE> dfs ( next1 , now ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> next [ u - 1 ] . append ( ( v - 1 , w ) ) <NEWLINE> next [ v - 1 ] . append ( ( u - 1 , w ) ) <NEWLINE> <NL> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if d [ i ] % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * q <NEWLINE> b = [ 0 ] * q <NEWLINE> c = [ 0 ] * q <NEWLINE> d = [ 0 ] * q <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> A = list ( itertools . combinations_with_replacement ( range ( 1 , m + 1 ) , n ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> if ( A [ i ] [ b [ j ] - 1 ] - A [ i ] [ a [ j ] - 1 ] ) == c [ j ] : <NEWLINE> <INDENT> tmp = tmp + d [ j ] <NEWLINE> <DEDENT> <DEDENT> cnt = max ( cnt , tmp ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
from collections import Counter <NEWLINE> from functools import lru_cache <NEWLINE> from math import gcd <NEWLINE> <NL> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def get_dividers ( n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> dividers = { i for i in range ( 1 , int ( n ** 0.5 ) + 1 ) if n % i == 0 } <NEWLINE> return dividers | { n // d for d in dividers } <NEWLINE> <NL> <NL> <DEDENT> @ lru_cache ( maxsize = None ) <NEWLINE> def lcm ( a , b ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> return a * b // gcd ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> counter = Counter ( ) <NEWLINE> for a in A : <NEWLINE> <INDENT> counter . update ( get_dividers ( a ) ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> candidates = [ ] <NEWLINE> for key , value in counter . items ( ) : <NEWLINE> <INDENT> if value == N : <NEWLINE> <INDENT> ans = lcm ( ans , key ) <NEWLINE> <DEDENT> elif value == N - 1 : <NEWLINE> <INDENT> candidates . append ( key ) <NEWLINE> <NL> <DEDENT> <DEDENT> if candidates : <NEWLINE> <INDENT> ans = max ( [ lcm ( ans , c ) for c in candidates ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def LI ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> L , R = LI ( ) <NEWLINE> ans = 2020 <NEWLINE> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> y = ( i * j ) % 2019 <NEWLINE> ans = min ( ans , y ) <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> num = 0 <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , 1000000 ) : <NEWLINE> <INDENT> num = num * 10 + 7 <NEWLINE> num %= K <NEWLINE> if num == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> if i * 1000 >= n : <NEWLINE> <INDENT> print ( i * 1000 - n ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> x = ( n * ( n - 1 ) ) // 2 <NEWLINE> print ( x ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> q = int ( math . sqrt ( N ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( 1 , q + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> a = i <NEWLINE> b = int ( N / a ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( str ( b ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> for k in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> print ( A [ k ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( A [ - 1 ] ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> <NL> for k in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> print ( A [ k ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( A [ - 1 ] ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def abc ( A , B , C , K ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> <COMMENT> <NL> K = K - A <NEWLINE> result = A + result <NEWLINE> if K < 0 : <NEWLINE> <INDENT> K = K + A <NEWLINE> result -= abs ( abs ( K ) - A ) <NEWLINE> return result <NEWLINE> <DEDENT> K -= B <NEWLINE> if K < 0 : <NEWLINE> <INDENT> return result <NEWLINE> <DEDENT> K -= C <NEWLINE> result -= C <NEWLINE> if K < 0 : <NEWLINE> <INDENT> K += C <NEWLINE> result += abs ( abs ( K ) - C ) <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT> print ( abc ( A , B , C , K ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> fl = input ( ) . split ( <STRING> ) <NEWLINE> V = int ( fl [ 0 ] ) <NEWLINE> E = int ( fl [ 1 ] ) <NEWLINE> R = int ( fl [ 2 ] ) <NEWLINE> <COMMENT> <NL> G = defaultdict ( list ) <NEWLINE> for i in range ( int ( E ) ) : <NEWLINE> <INDENT> s , t , w = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> G [ s ] . append ( ( t , w ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> d = { } <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> for i in range ( V ) : <NEWLINE> <INDENT> d [ i ] = INF <NEWLINE> <DEDENT> d [ R ] = 0 <NEWLINE> q = [ R ] <NEWLINE> while q : <NEWLINE> <INDENT> u = q . pop ( 0 ) <NEWLINE> for v in G [ u ] : <NEWLINE> <INDENT> if d [ v [ 0 ] ] > d [ u ] + v [ 1 ] : <NEWLINE> <INDENT> d [ v [ 0 ] ] = d [ u ] + v [ 1 ] <NEWLINE> q . append ( v [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for k in d . keys ( ) : <NEWLINE> <INDENT> if d [ k ] == float ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d [ k ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_list = sum ( A ) <NEWLINE> sum_of_product = 0 <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> sum_list -= i <NEWLINE> sum_of_product = ( ( sum_list * i ) % ( 10 ** 9 + 7 ) + sum_of_product ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( sum_of_product ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> inf = 10 ** 9 + 7 <NEWLINE> <NL> S = sum ( a ) <NEWLINE> S2 = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> S2 += i * i <NEWLINE> <NL> <DEDENT> print ( ( S * S - S2 ) // 2 % inf ) <NEWLINE>
import collections <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> A = list ( map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> L = [ i + A [ i ] for i in range ( N ) ] <NEWLINE> R = [ i - A [ i ] for i in range ( N ) ] <NEWLINE> c_l = collections . Counter ( L ) <NEWLINE> c_r = collections . Counter ( R ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for k , v in c_l . items ( ) : <NEWLINE> <INDENT> v_ = c_r . get ( k , 0 ) <NEWLINE> ans += v * v_ <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> g = math . gcd ( i + 1 , j + 1 ) <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> sum += math . gcd ( g , k + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> def my_pow ( base , n , mod ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> x = base <NEWLINE> y = 1 <NEWLINE> while n > 1 : <NEWLINE> <INDENT> if n % 2 == 0 : <NEWLINE> <INDENT> x *= x <NEWLINE> n //= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y *= x <NEWLINE> n -= 1 <NEWLINE> <DEDENT> x %= mod <NEWLINE> y %= mod <NEWLINE> <DEDENT> return x * y % mod <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> adj = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> adj [ a ] . append ( b ) <NEWLINE> adj [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> pows = [ 1 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> pows [ i ] = ( pows [ i - 1 ] * 2 ) % MOD <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> def dfs ( v , p ) : <NEWLINE> <INDENT> global ans <NEWLINE> subs = [ ] <NEWLINE> res = 1 <NEWLINE> for u in adj [ v ] : <NEWLINE> <INDENT> if u == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> val = dfs ( u , v ) <NEWLINE> res += val <NEWLINE> subs . append ( val ) <NEWLINE> <COMMENT> <NL> <DEDENT> if p != - 1 : <NEWLINE> <INDENT> subs . append ( N - res ) <NEWLINE> <DEDENT> now = pows [ N - 1 ] - 1 <COMMENT> <NEWLINE> for sub in subs : <NEWLINE> <INDENT> now -= pows [ sub ] - 1 <NEWLINE> <DEDENT> ans += now <NEWLINE> ans %= MOD <NEWLINE> return res <NEWLINE> <NL> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> print ( ans * my_pow ( 2 ** N , MOD - 2 , MOD ) % MOD ) <NEWLINE>
from collections import Counter <NEWLINE> n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> s = set ( a ) <NEWLINE> c = Counter ( a ) <NEWLINE> m = max ( s ) <NEWLINE> l = [ True ] * ( m + 1 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> if i in s and l [ i ] : <NEWLINE> <INDENT> if c [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> for j in range ( 1 , m // i + 1 ) : <NEWLINE> <INDENT> l [ i * j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = 0 <NEWLINE> <NL> if K > N : <NEWLINE> <INDENT> a = K - N <NEWLINE> <NL> <DEDENT> for _ in range ( a ) : <NEWLINE> <INDENT> H . append ( 0 ) <NEWLINE> <NL> <DEDENT> H . sort ( reverse = True ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> H [ i ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> sum += H [ i ] <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> class UnionFind : <NEWLINE> <COMMENT> <NL> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , * XY = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> MAX = 100010 <NEWLINE> uf = UnionFind ( MAX * 2 ) <NEWLINE> for x , y in zip ( * [ iter ( XY ) ] * 2 ) : <NEWLINE> <INDENT> uf . union ( x , y + MAX ) <NEWLINE> <NL> <DEDENT> x_comp = Counter ( ) <NEWLINE> y_comp = Counter ( ) <NEWLINE> for i in range ( MAX ) : <NEWLINE> <INDENT> x_comp [ uf . find ( i ) ] += 1 <NEWLINE> <DEDENT> for i in range ( MAX , 2 * MAX ) : <NEWLINE> <INDENT> y_comp [ uf . find ( i ) ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for k in x_comp . keys ( ) : <NEWLINE> <INDENT> ans += x_comp [ k ] * y_comp [ k ] <NEWLINE> <NL> <DEDENT> ans -= N <NEWLINE> <NL> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( H == 0 and W == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for k in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> from sys import stdin <NEWLINE> from bisect import bisect_right , bisect_left <NEWLINE> input = stdin . readline <NEWLINE> <NL> <NL> def main ( args ) : <NEWLINE> <INDENT> N , V = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> B = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> C = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> D = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> AB = [ ] <NEWLINE> for i in A : <NEWLINE> <INDENT> for j in B : <NEWLINE> <INDENT> AB . append ( i + j ) <NEWLINE> <DEDENT> <DEDENT> AB . sort ( ) <NEWLINE> <NL> CD = [ float ( <STRING> ) , float ( <STRING> ) ] <NEWLINE> for i in C : <NEWLINE> <INDENT> for j in D : <NEWLINE> <INDENT> CD . append ( i + j ) <NEWLINE> <DEDENT> <DEDENT> CD . sort ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for ab in AB : <NEWLINE> <INDENT> i = bisect_left ( CD , V - ab ) <NEWLINE> j = bisect_right ( CD , V - ab ) <NEWLINE> count += max ( ( j - i ) , 0 ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
SENTINEL = 2 ** 32 <NEWLINE> cnt = 0 <NEWLINE> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> L = A [ left : mid ] + [ SENTINEL ] <NEWLINE> R = A [ mid : right ] + [ SENTINEL ] <NEWLINE> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> cnt += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def merge_sort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( A , left , mid ) <NEWLINE> merge_sort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> merge_sort ( A , 0 , len ( A ) ) <NEWLINE> print ( * A ) <NEWLINE> print ( cnt ) <NEWLINE>
import numpy as np <NEWLINE> <NL> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> num_lists = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> all_num = list ( range ( 0 , 102 , 1 ) ) <NEWLINE> lists = [ i for i in all_num if i not in num_lists ] <NEWLINE> <NL> lists_arr = np . array ( lists ) <NEWLINE> diff_arr = lists_arr - x <NEWLINE> abs_arr = np . abs ( diff_arr ) <NEWLINE> index = np . where ( abs_arr == abs_arr . min ( ) ) <NEWLINE> answer_list = lists_arr [ index ] <NEWLINE> print ( answer_list [ 0 ] ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = [ 0 ] * ( n + 1 ) <NEWLINE> now = 1 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = A [ now - 1 ] <NEWLINE> if not D [ tmp ] : <NEWLINE> <INDENT> now = tmp <NEWLINE> D [ now ] += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pre = D [ tmp ] <NEWLINE> loop = i - D [ tmp ] <NEWLINE> if loop > 1 : <NEWLINE> <INDENT> now = D . index ( ( k - pre ) % loop + pre ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now = tmp <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( now ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> if 0 in li : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * li [ i ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> b1 = [ ] <NEWLINE> b2 = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> b1 . append ( b ) <NEWLINE> <DEDENT> if b == n : <NEWLINE> <INDENT> b2 . append ( a ) <NEWLINE> <DEDENT> <DEDENT> if len ( b1 ) + len ( b2 ) == len ( list ( set ( b1 + b2 ) ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> m = len ( n ) <NEWLINE> n = int ( n ) <NEWLINE> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if m == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> ans_plus = n // ( 2 * 5 ** i ) <NEWLINE> if ans_plus == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += ans_plus <NEWLINE> <NL> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> total += math . gcd ( tmp , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> cnt = 1 <NEWLINE> mod = 7 <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> if mod % x == 0 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> mod = ( 10 * mod + 7 ) % x <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( - 1 ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N , K , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> root_road = [ - 1 ] * N <NEWLINE> root_train = [ - 1 ] * N <NEWLINE> <NL> <NL> def find_road ( x ) : <NEWLINE> <INDENT> if root_road [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <DEDENT> root_road [ x ] = find_road ( root_road [ x ] ) <NEWLINE> return root_road [ x ] <NEWLINE> <NL> <NL> <DEDENT> def union_road ( x , y ) : <NEWLINE> <INDENT> x = find_road ( x ) <NEWLINE> y = find_road ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> root_road [ x ] += root_road [ y ] <NEWLINE> root_road [ y ] = x <NEWLINE> <NL> <NL> <DEDENT> def same_road ( x , y ) : <NEWLINE> <INDENT> return find_road ( x ) == find_road ( y ) <NEWLINE> <NL> <NL> <DEDENT> def find_train ( x ) : <NEWLINE> <INDENT> if root_train [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <DEDENT> root_train [ x ] = find_train ( root_train [ x ] ) <NEWLINE> return root_train [ x ] <NEWLINE> <NL> <NL> <DEDENT> def union_train ( x , y ) : <NEWLINE> <INDENT> x = find_train ( x ) <NEWLINE> y = find_train ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> root_train [ x ] += root_train [ y ] <NEWLINE> root_train [ y ] = x <NEWLINE> <NL> <NL> <DEDENT> def same_train ( x , y ) : <NEWLINE> <INDENT> return find_train ( x ) == find_train ( y ) <NEWLINE> <NL> <NL> <DEDENT> dc = defaultdict ( list ) <NEWLINE> dt = defaultdict ( list ) <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> p -= 1 <NEWLINE> q -= 1 <NEWLINE> dc [ p ] . append ( q ) <NEWLINE> dc [ q ] . append ( p ) <NEWLINE> union_road ( p , q ) <NEWLINE> <NL> <DEDENT> for _ in range ( L ) : <NEWLINE> <INDENT> r , s = map ( int , input ( ) . split ( ) ) <NEWLINE> r -= 1 <NEWLINE> s -= 1 <NEWLINE> dt [ r ] . append ( s ) <NEWLINE> dt [ s ] . append ( r ) <NEWLINE> union_train ( r , s ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> dic = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( find_road ( i ) , find_train ( i ) ) not in dic : <NEWLINE> <INDENT> dic [ ( find_road ( i ) , find_train ( i ) ) ] = 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ ( find_road ( i ) , find_train ( i ) ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans . append ( dic [ ( find_road ( i ) , find_train ( i ) ) ] ) <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> sum = sum ( b ) <NEWLINE> for i in range ( a - 1 ) : <NEWLINE> <INDENT> sum = sum - b [ i ] <NEWLINE> c += b [ i ] * ( sum ) <NEWLINE> <DEDENT> print ( c % ( 10 ** 9 + 7 ) ) <NEWLINE>
import sys <NEWLINE> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ ] <NEWLINE> w = [ ] <NEWLINE> Hcount = [ 0 for _ in range ( H ) ] <NEWLINE> Wcount = [ 0 for _ in range ( W ) ] <NEWLINE> B = set ( ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> hi , wi = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> B . add ( ( hi , wi ) ) <NEWLINE> Hcount [ hi - 1 ] += 1 <NEWLINE> Wcount [ wi - 1 ] += 1 <NEWLINE> <DEDENT> Hcountmax = max ( Hcount ) <NEWLINE> Wcountmax = max ( Wcount ) <NEWLINE> h_max = [ i for i , v in enumerate ( Hcount ) if v == Hcountmax ] <NEWLINE> w_max = [ i for i , v in enumerate ( Wcount ) if v == Wcountmax ] <NEWLINE> <COMMENT> <NL> for ii in range ( len ( h_max ) ) : <NEWLINE> <INDENT> for jj in range ( len ( w_max ) ) : <NEWLINE> <INDENT> if ( h_max [ ii ] + 1 , w_max [ jj ] + 1 ) not in B : <NEWLINE> <INDENT> print ( max ( Hcount ) + max ( Wcount ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( Hcount ) + max ( Wcount ) - 1 ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cou = 0 <NEWLINE> pdic = { } <NEWLINE> kan = [ ] <NEWLINE> betu = [ 0 , 0 , 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a * b != 0 : <NEWLINE> <INDENT> g = math . gcd ( abs ( a ) , abs ( b ) ) <NEWLINE> if a * b > 0 : <NEWLINE> <INDENT> m = 1 <NEWLINE> <DEDENT> elif a * b < 0 : <NEWLINE> <INDENT> m = - 1 <NEWLINE> <DEDENT> p = ( m * abs ( a ) // g , abs ( b ) // g ) <NEWLINE> q = ( ( - m ) * abs ( b ) // g , abs ( a ) // g ) <NEWLINE> if pdic . get ( q , - 1 ) != - 1 : <NEWLINE> <INDENT> kan [ pdic [ q ] ] [ 1 ] += 1 <NEWLINE> <DEDENT> elif pdic . get ( p , - 1 ) == - 1 : <NEWLINE> <INDENT> pdic [ p ] = cou <NEWLINE> kan . append ( [ 1 , 0 ] ) <NEWLINE> cou += 1 <NEWLINE> <DEDENT> elif pdic . get ( p , - 1 ) != - 1 : <NEWLINE> <INDENT> kan [ pdic [ p ] ] [ 0 ] += 1 <NEWLINE> <DEDENT> <DEDENT> elif a * b == 0 : <NEWLINE> <INDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> betu [ 2 ] += 1 <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> betu [ 0 ] += 1 <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> betu [ 1 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for i in range ( len ( kan ) ) : <NEWLINE> <INDENT> ans *= ( pow ( 2 , kan [ i ] [ 0 ] , mod ) + pow ( 2 , kan [ i ] [ 1 ] , mod ) - 1 ) % mod <NEWLINE> ans %= mod <NEWLINE> <DEDENT> ans *= ( pow ( 2 , betu [ 0 ] , mod ) + pow ( 2 , betu [ 1 ] , mod ) - 1 ) % mod <NEWLINE> print ( ( ans - 1 + betu [ 2 ] ) % mod ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> p . sort ( ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans += p [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> t = 10 ** 9 + 7 <NEWLINE> S = [ a % t for a in A ] <NEWLINE> g = sum ( S ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> g -= S [ i ] <NEWLINE> ans += S [ i ] * g % t <NEWLINE> <DEDENT> print ( ans % t ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
import sys <NEWLINE> import threading <NEWLINE> <NL> S = int ( input ( ) ) <NEWLINE> A = [ - 1 for _ in range ( 2001 ) ] <NEWLINE> A [ 0 ] = 0 <NEWLINE> A [ 1 ] = 0 <NEWLINE> A [ 2 ] = 0 <NEWLINE> A [ 3 ] = 1 <NEWLINE> <NL> for i in range ( S + 1 ) : <NEWLINE> <INDENT> if A [ i ] == - 1 : <NEWLINE> <INDENT> A [ i ] = A [ i - 1 ] + A [ i - 3 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( A [ S ] % ( 10 ** 9 + 7 ) ) <NEWLINE>
from math import gcd <NEWLINE> <NL> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> n = c * d // gcd ( c , d ) <NEWLINE> x = ( b // c ) - ( ( a - 1 ) // c ) <NEWLINE> y = ( b // d ) - ( ( a - 1 ) // d ) <NEWLINE> z = ( b // n ) - ( ( a - 1 ) // n ) <NEWLINE> print ( b - a + 1 - ( x + y - z ) ) <NEWLINE>
hoge = [ <STRING> if i % 15 == 0 else ( <STRING> if i % 3 == 0 else ( <STRING> if i % 5 == 0 else str ( i ) ) ) for i in range ( 10001 ) ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> man = list ( range ( 1 , m + 1 ) ) <NEWLINE> game = [ input ( ) for _ in range ( n ) ] <NEWLINE> idx = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if game [ i ] != hoge [ i + 1 ] : <NEWLINE> <INDENT> del man [ idx ] <NEWLINE> if len ( man ) == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> idx += 1 <NEWLINE> <DEDENT> idx %= len ( man ) <NEWLINE> <DEDENT> print ( * man ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> visited = [ False for _ in range ( N ) ] <NEWLINE> now = 0 <NEWLINE> <NL> cycle = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> cycle . append ( now ) <NEWLINE> visited [ now ] = True <NEWLINE> now = A [ now ] - 1 <NEWLINE> <NL> if visited [ now ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> total_len = len ( cycle ) <NEWLINE> <NL> cycle_start = 0 <NEWLINE> <NL> for i in range ( total_len ) : <NEWLINE> <INDENT> if cycle [ i ] == now : <NEWLINE> <INDENT> cycle_start = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> cycle_len = total_len - cycle_start <NEWLINE> <NL> if K < cycle_start : <NEWLINE> <INDENT> print ( cycle [ K ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cycle [ cycle_start + ( K - cycle_start ) % cycle_len ] + 1 ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ str ( input ( ) ) for _ in range ( h ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> n = h * w <NEWLINE> <NL> def Find ( x , par ) : <NEWLINE> <INDENT> if par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = Find ( par [ x ] , par ) <NEWLINE> return par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def Unite ( x , y , par , rank ) : <NEWLINE> <INDENT> x = Find ( x , par ) <NEWLINE> y = Find ( y , par ) <NEWLINE> <NL> if x != y : <NEWLINE> <INDENT> if rank [ x ] < rank [ y ] : <NEWLINE> <INDENT> par [ y ] += par [ x ] <NEWLINE> par [ x ] = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] += par [ y ] <NEWLINE> par [ y ] = x <NEWLINE> if rank [ x ] == rank [ y ] : <NEWLINE> <INDENT> rank [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def Same ( x , y , par ) : <NEWLINE> <INDENT> return Find ( x , par ) == Find ( y , par ) <NEWLINE> <NL> <DEDENT> def Size ( x , par ) : <NEWLINE> <INDENT> return - par [ Find ( x , par ) ] <NEWLINE> <NL> <DEDENT> par = [ - 1 ] * n <NEWLINE> rank = [ 0 ] * n <NEWLINE> <NL> for y in range ( h ) : <NEWLINE> <INDENT> for x in range ( w ) : <NEWLINE> <INDENT> idx1 = y * w + x <NEWLINE> for dy , dx in ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) : <NEWLINE> <INDENT> ny , nx = y + dy , x + dx <NEWLINE> if 0 <= ny < h and 0 <= nx < w : <NEWLINE> <INDENT> idx2 = ny * w + nx <NEWLINE> if S [ y ] [ x ] != S [ ny ] [ nx ] : <NEWLINE> <INDENT> Unite ( idx1 , idx2 , par , rank ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> X = [ [ 0 , 0 ] for _ in range ( n ) ] <NEWLINE> K = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> y , x = divmod ( i , w ) <NEWLINE> if par [ i ] < 0 : <NEWLINE> <INDENT> K . append ( i ) <NEWLINE> if S [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> X [ i ] [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X [ i ] [ 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if S [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> X [ Find ( i , par ) ] [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X [ Find ( i , par ) ] [ 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k in K : <NEWLINE> <INDENT> ans += X [ k ] [ 0 ] * X [ k ] [ 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> p = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> for j in range ( 1 , int ( ( n - i ) / 2 ) + 1 ) : <NEWLINE> <INDENT> if i + j * 2 >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ i + j ] and s [ i ] != s [ i + j * 2 ] and s [ i + j * 2 ] != s [ i + j ] : <NEWLINE> <INDENT> p -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
import itertools <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> inputList = [ ] <NEWLINE> for i in range ( 1 , q + 1 ) : <NEWLINE> <INDENT> abcd = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> inputList . append ( abcd ) <NEWLINE> <DEDENT> AList = list ( itertools . combinations_with_replacement ( range ( 1 , m + 1 ) , n ) ) <NEWLINE> PointList = [ ] <NEWLINE> for array in AList : <NEWLINE> <INDENT> point = 0 <NEWLINE> for iList in inputList : <NEWLINE> <INDENT> if array [ iList [ 1 ] - 1 ] - array [ iList [ 0 ] - 1 ] == iList [ 2 ] : <NEWLINE> <INDENT> point = point + iList [ 3 ] <NEWLINE> <DEDENT> <DEDENT> PointList . append ( point ) <NEWLINE> <DEDENT> print ( max ( PointList ) ) <NEWLINE>
import sys <NEWLINE> def Ii ( ) : return int ( sys . stdin . buffer . read ( ) ) <NEWLINE> def Mi ( ) : return map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> def Li ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n , k = Mi ( ) <NEWLINE> a = Li ( ) <NEWLINE> b = [ 1 ] <NEWLINE> b . append ( a [ 0 ] ) <NEWLINE> flag = False <NEWLINE> for i in range ( n ) : b . append ( a [ b [ - 1 ] - 1 ] ) <NEWLINE> if len ( b ) > k : <NEWLINE> <INDENT> print ( b [ k ] ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> for j in range ( len ( b ) ) : <NEWLINE> <INDENT> if b [ j ] == a [ b [ - 1 ] - 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> roop = len ( b ) - j <NEWLINE> roopk = ( k - j ) % roop <NEWLINE> print ( b [ roopk + j ] ) <NEWLINE>
import sys , math <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( eval ( s ) // 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( math . pi * r ** 2 , 2 * math . pi * r ) ) <NEWLINE>
try : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> if not S : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> S = S . lower ( ) <NEWLINE> a = a + S <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> for i in range ( 97 , 97 + 26 ) : <NEWLINE> <NL> <INDENT> b = a . count ( chr ( i ) ) <NEWLINE> print ( chr ( i ) + <STRING> + str ( b ) ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> b = [ 0 ] * q <NEWLINE> c = [ 0 ] * q <NEWLINE> s = [ 0 ] * ( q + 1 ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b [ i ] , c [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> f = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> f . setdefault ( a [ i ] , 0 ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> f [ a [ i ] ] += 1 <NEWLINE> <DEDENT> for g , h in f . items ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> s [ 0 ] = s [ 0 ] + h * g <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( 1 , q + 1 ) : <NEWLINE> <INDENT> if b [ i - 1 ] in f : <NEWLINE> <INDENT> if c [ i - 1 ] in f : <NEWLINE> <INDENT> f [ c [ i - 1 ] ] = f [ c [ i - 1 ] ] + f [ b [ i - 1 ] ] <NEWLINE> s [ i ] = s [ i - 1 ] - f [ b [ i - 1 ] ] * b [ i - 1 ] <NEWLINE> <COMMENT> <NL> <NL> s [ i ] = s [ i ] + f [ b [ i - 1 ] ] * c [ i - 1 ] <NEWLINE> f . pop ( b [ i - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f . setdefault ( c [ i - 1 ] , 0 ) <NEWLINE> f [ c [ i - 1 ] ] = f [ c [ i - 1 ] ] + f [ b [ i - 1 ] ] <NEWLINE> s [ i ] = s [ i - 1 ] - f [ b [ i - 1 ] ] * b [ i - 1 ] <NEWLINE> <COMMENT> <NL> <NL> s [ i ] += f [ b [ i - 1 ] ] * c [ i - 1 ] <NEWLINE> f . pop ( b [ i - 1 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s [ i ] = s [ i - 1 ] <NEWLINE> <DEDENT> print ( s [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) - 1 <NEWLINE> ans = ( 1 + n ) * n // 2 <NEWLINE> <NL> print ( ans ) <NEWLINE>
class Solver ( ) : <NEWLINE> <INDENT> def __init__ ( self , A : [ int ] ) : <NEWLINE> <INDENT> self . A = A <NEWLINE> self . max_depth = len ( A ) <NEWLINE> <NL> <DEDENT> def solve ( self , tgt ) : <NEWLINE> <INDENT> self . tgt = tgt <NEWLINE> self . history = ( self . max_depth + 1 ) * [ 4000 * [ None ] ] <NEWLINE> self . history = [ [ None for i in range ( 4000 ) ] for x in range ( self . max_depth + 1 ) ] <NEWLINE> if self . _rec_solve ( 0 , 0 ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def _rec_solve ( self , _sum , index ) : <NEWLINE> <INDENT> if self . history [ index ] [ _sum ] is not None : <NEWLINE> <INDENT> return self . history [ index ] [ _sum ] <NEWLINE> <DEDENT> if _sum == self . tgt : <NEWLINE> <INDENT> self . history [ index ] [ _sum ] = True <NEWLINE> return True <NEWLINE> <DEDENT> if index >= self . max_depth or _sum > self . tgt : <NEWLINE> <INDENT> self . history [ index ] [ _sum ] = False <NEWLINE> return False <NEWLINE> <DEDENT> self . history [ index ] [ _sum ] = self . _rec_solve ( _sum + self . A [ index ] , index + 1 ) or self . _rec_solve ( _sum , index + 1 ) <NEWLINE> return self . history [ index ] [ _sum ] <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> m_ary = [ int ( i ) for i in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> s = Solver ( A ) <NEWLINE> for val in m_ary : <NEWLINE> <INDENT> print ( s . solve ( val ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b = input ( ) <NEWLINE> a . add ( b ) <NEWLINE> <DEDENT> print ( len ( a ) ) <NEWLINE>
import math <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dic = { } <COMMENT> <NEWLINE> ans = 0 <NEWLINE> moddo = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> t = k - i <COMMENT> <NEWLINE> if t > k / 2 : <COMMENT> <NEWLINE> <INDENT> dic [ t ] = 1 <NEWLINE> ans += t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = pow ( k // t , n , moddo ) <NEWLINE> <COMMENT> <NL> fac = 2 <NEWLINE> while fac * t <= k : <NEWLINE> <INDENT> temp -= dic [ fac * t ] <NEWLINE> fac += 1 <NEWLINE> <DEDENT> dic [ t ] = temp % moddo <NEWLINE> ans = ( ans + ( ( temp * t ) % moddo ) ) % moddo <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> from bisect import bisect <NEWLINE> from collections import defaultdict , Counter <NEWLINE> inp = sys . stdin . readline <NEWLINE> read = lambda : list ( map ( int , inp ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> n , m , k = read ( ) <NEWLINE> arr1 = [ 0 ] + read ( ) ; arr2 = [ 0 ] + read ( ) <NEWLINE> for i in range ( 1 , n + 1 ) : arr1 [ i ] += arr1 [ i - 1 ] <NEWLINE> for i in range ( 1 , m + 1 ) : arr2 [ i ] += arr2 [ i - 1 ] <NEWLINE> <NL> i = 0 ; ans = 0 <NEWLINE> while i < n + 1 and arr1 [ i ] <= k : <NEWLINE> <INDENT> tem = i + bisect ( arr2 , k - arr1 [ i ] ) - 1 <NEWLINE> <COMMENT> <NL> ans = max ( ans , tem ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if len ( p ) == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if not X in p : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> small = [ i for i in range ( - 101 , X ) ] <NEWLINE> big = [ i for i in range ( X + 1 , 102 ) ] <NEWLINE> small . reverse ( ) <NEWLINE> for i in range ( max ( len ( big ) , len ( small ) ) ) : <NEWLINE> <INDENT> if not small [ i ] in p : <NEWLINE> <INDENT> print ( small [ i ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif not big [ i ] in p : <NEWLINE> <INDENT> print ( big [ i ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> d = [ ] <NEWLINE> a = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d . append ( int ( input ( ) ) ) <NEWLINE> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT> sunuke = [ 0 ] * n <NEWLINE> for i in range ( k ) : <NEWLINE> <COMMENT> <NL> <INDENT> for j in range ( int ( d [ i ] ) ) : <NEWLINE> <INDENT> temp = a [ i ] [ j ] - 1 <NEWLINE> sunuke [ temp ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( sunuke . count ( 0 ) ) <NEWLINE> <NL>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ma = [ i - a [ i ] for i in range ( n ) ] <NEWLINE> r = Counter ( ma ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += r [ i + a [ i ] ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Asum = [ 0 ] <NEWLINE> Bsum = [ 0 ] <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> Asum . append ( Asum [ i ] + a ) <NEWLINE> <DEDENT> for i , b in enumerate ( B ) : <NEWLINE> <INDENT> Bsum . append ( Bsum [ i ] + b ) <NEWLINE> <NL> <DEDENT> ans , b = 0 , M <NEWLINE> for a , asum in enumerate ( Asum ) : <NEWLINE> <INDENT> if asum > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while Bsum [ b ] > K - asum : <NEWLINE> <INDENT> b -= 1 <NEWLINE> <DEDENT> ans = max ( ans , a + b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
<NL> <COMMENT> <NL> <COMMENT> <NL> <NL> class DisjSet : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> self . rank = [ 1 ] * n <NEWLINE> self . parent = [ i for i in range ( n ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if ( self . parent [ x ] != x ) : <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> self . parent [ x ] = self . find ( self . parent [ x ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> return self . parent [ x ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def Union ( self , x , y ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> xset = self . find ( x ) <NEWLINE> yset = self . find ( y ) <NEWLINE> <NL> <COMMENT> <NL> if xset == yset : <NEWLINE> <INDENT> return <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if self . rank [ xset ] < self . rank [ yset ] : <NEWLINE> <INDENT> self . parent [ xset ] = yset <NEWLINE> <NL> <DEDENT> elif self . rank [ xset ] > self . rank [ yset ] : <NEWLINE> <INDENT> self . parent [ yset ] = xset <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ yset ] = xset <NEWLINE> self . rank [ xset ] = self . rank [ xset ] + 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <STRING> <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> obj = DisjSet ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> obj . Union ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> c = 0 <NEWLINE> l1 = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l1 [ obj . find ( i ) ] += 1 <NEWLINE> <DEDENT> print ( max ( l1 ) ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> AA = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> BB = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_max = 0 <NEWLINE> AAs = [ 0 ] * N <NEWLINE> AAs [ 0 ] = AA [ 0 ] <NEWLINE> if K >= AAs [ 0 ] : <NEWLINE> <INDENT> A_max = 1 <NEWLINE> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> AAs [ i ] = AAs [ i - 1 ] + AA [ i ] <NEWLINE> if K >= AAs [ i ] : <NEWLINE> <INDENT> A_max += 1 <NEWLINE> <DEDENT> <DEDENT> BBs = [ 0 ] * M <NEWLINE> BBs [ 0 ] = BB [ 0 ] <NEWLINE> BM = M <NEWLINE> for i in range ( 1 , M ) : <NEWLINE> <INDENT> BBs [ i ] = BBs [ i - 1 ] + BB [ i ] <NEWLINE> <DEDENT> Book_max = 0 <NEWLINE> for i in range ( A_max + 1 ) : <NEWLINE> <INDENT> b_max = 0 <NEWLINE> if i == 0 : <NEWLINE> <INDENT> B_time = K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B_time = K - AAs [ i - 1 ] <NEWLINE> <DEDENT> for j in range ( BM - 1 , - 1 , - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if B_time >= BBs [ j ] : <NEWLINE> <INDENT> b_max = j + 1 <NEWLINE> BM = b_max <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if Book_max < b_max + i : <NEWLINE> <INDENT> Book_max = b_max + i <NEWLINE> <DEDENT> <DEDENT> print ( Book_max ) <NEWLINE> <DEDENT> solve ( ) <NEWLINE>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> dp = [ 0 for i in range ( 10 ** 5 ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> dp [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> ans = sum ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = ans - ( dp [ b - 1 ] * b ) + ( c * dp [ b - 1 ] ) <NEWLINE> dp [ c - 1 ] += dp [ b - 1 ] <NEWLINE> dp [ b - 1 ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( math . sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = list ( input ( ) ) <NEWLINE> n . reverse ( ) <NEWLINE> x = [ 0 ] * ( len ( n ) ) <NEWLINE> a = 0 <NEWLINE> ex = 1 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> a += int ( n [ i ] ) * ex <NEWLINE> x [ i ] = a % 2019 <NEWLINE> ex = ex * 10 % 2019 <NEWLINE> <DEDENT> c = Counter ( x ) <NEWLINE> ans = c [ 0 ] <NEWLINE> for i in c . keys ( ) : <NEWLINE> <INDENT> b = c [ i ] <NEWLINE> ans += b * ( b - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> <NL> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> P = 2019 <NEWLINE> <NL> if P == 2 or P == 5 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if int ( S [ i ] ) % P == 0 : <NEWLINE> <INDENT> ans += i + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> num = [ 0 ] * P <NEWLINE> num [ 0 ] = 1 <NEWLINE> now , ans = 0 , 0 <NEWLINE> _10 = 1 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> now = ( now + int ( S [ i ] ) * _10 ) % P <NEWLINE> _10 *= 10 <NEWLINE> _10 %= P <NEWLINE> ans += num [ now ] <NEWLINE> num [ now ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A_list = [ - 1 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> out_loop = [ 1 ] <NEWLINE> flag = [ 0 , 1 ] + [ 0 ] * ( N - 1 ) <NEWLINE> a = A_list [ 1 ] <NEWLINE> while flag [ a ] == 0 : <NEWLINE> <INDENT> out_loop . append ( a ) <NEWLINE> flag [ a ] = 1 <NEWLINE> a = A_list [ a ] <NEWLINE> <NL> <NL> <NL> <DEDENT> if K <= ( len ( out_loop ) - 1 ) : <NEWLINE> <INDENT> print ( out_loop [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop = out_loop [ out_loop . index ( a ) : ] <NEWLINE> k = K - ( len ( out_loop ) - 1 ) <NEWLINE> k %= len ( loop ) <NEWLINE> print ( loop [ k - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = ( 10 ** 9 ) + 7 <NEWLINE> t = 0 <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> sum += A [ i ] <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> t += ( A [ i ] * sum ) % mod <NEWLINE> sum -= A [ i + 1 ] <NEWLINE> <DEDENT> t = t % mod <NEWLINE> print ( t ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 100000 ) <COMMENT> <NEWLINE> <NL> def func ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <COMMENT> <NEWLINE> <DEDENT> if memo [ n ] != - 1 : <NEWLINE> <INDENT> return memo [ n ] <COMMENT> <NEWLINE> <NL> <DEDENT> res = n <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> pow6 = 6 ** i <NEWLINE> if pow6 > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> res = min ( res , func ( n - pow6 ) + 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> pow9 = 9 ** i <NEWLINE> if pow9 > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> res = min ( res , func ( n - pow9 ) + 1 ) <NEWLINE> <NL> <DEDENT> memo [ n ] = res <NEWLINE> return res <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> max_n = 110000 <NEWLINE> memo = [ - 1 ] * max_n <NEWLINE> ans = func ( N ) <NEWLINE> print ( ans ) <NEWLINE>
from sys import stdin , stdout <NEWLINE> n , m = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> L = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> L [ a - 1 ] = max ( L [ a - 1 ] , H [ b - 1 ] ) <NEWLINE> L [ b - 1 ] = max ( L [ b - 1 ] , H [ a - 1 ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if H [ i ] > L [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> stdout . write ( str ( ans ) ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = min ( N % K , K - ( N % K ) ) <NEWLINE> print ( ans ) <NEWLINE>
def marge_ponds ( lx , area_of_pond ) : <NEWLINE> <INDENT> global ponds <NEWLINE> if ponds : <NEWLINE> <INDENT> lp = ponds . pop ( ) <NEWLINE> if lp [ 0 ] > lx : <NEWLINE> <INDENT> return marge_ponds ( lx , area_of_pond + lp [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ponds . append ( lp ) <NEWLINE> <DEDENT> <DEDENT> return area_of_pond <NEWLINE> <NL> <NL> <DEDENT> terrains = input ( ) . strip ( ) <NEWLINE> x , last_x , ponds = 0 , [ ] , [ ] <NEWLINE> <NL> for terrain in terrains : <NEWLINE> <INDENT> if terrain == <STRING> : <NEWLINE> <INDENT> last_x . append ( x ) <NEWLINE> <DEDENT> elif terrain == <STRING> : <NEWLINE> <INDENT> if last_x : <NEWLINE> <INDENT> lx = last_x . pop ( ) <NEWLINE> area_of_pond = marge_ponds ( lx , x - lx ) <NEWLINE> ponds . append ( ( lx , area_of_pond ) ) <NEWLINE> <DEDENT> <DEDENT> x += 1 <NEWLINE> <NL> <DEDENT> print ( sum ( pond [ 1 ] for pond in ponds ) ) <NEWLINE> ponds . insert ( 0 , ( 0 , len ( ponds ) ) ) <NEWLINE> print ( <STRING> . join ( map ( str , [ pond [ 1 ] for pond in ponds ] ) ) ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> v = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> g = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> v += math . gcd ( g , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( v ) <NEWLINE>
import sys <NEWLINE> <NL> W = sys . stdin . readline ( ) . strip ( ) <NEWLINE> num = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> T = sys . stdin . readline ( ) . strip ( ) <NEWLINE> if T == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t = T . lower ( ) <NEWLINE> T_line = t . split ( ) <NEWLINE> for i in T_line : <NEWLINE> <INDENT> if W == i : <NEWLINE> <INDENT> num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> ans = 1 <NEWLINE> c = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <COMMENT> <NL> <INDENT> c = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if c == 1 : <NEWLINE> <INDENT> print ( <STRING> . format ( ans ) ) <NEWLINE> <DEDENT> elif c == 0 : <NEWLINE> <INDENT> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> . format ( 0 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( - 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
import heapq <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> a = [ ( - x , x ) for x in H ] <NEWLINE> heapq . heapify ( a ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( <STRING> . format ( a [ i ] [ 1 ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> for a in A : <NEWLINE> <INDENT> ans [ a - 1 ] += 1 <NEWLINE> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> m , f , r = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if ( m == - 1 and f == - 1 and r == - 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( m == - 1 or f == - 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( m + f >= 80 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( 65 <= m + f <= 80 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( 50 <= m + f <= 65 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( 30 <= m + f <= 50 and r < 50 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( r >= 50 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> asum = sum ( A ) <NEWLINE> S = { } <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] in S : <NEWLINE> <INDENT> S [ A [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ A [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> D = [ ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> diff = 0 <NEWLINE> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if not c in S : <NEWLINE> <INDENT> S [ c ] = 0 <NEWLINE> <DEDENT> if b in S : <NEWLINE> <INDENT> diff = ( S [ b ] * c - S [ b ] * b ) <NEWLINE> S [ c ] += S [ b ] <NEWLINE> S [ b ] = 0 <NEWLINE> <NL> <DEDENT> asum += diff <NEWLINE> D . append ( asum ) <NEWLINE> <NL> <DEDENT> for d in D : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <NL> <NL> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_sum = sum ( a ) <NEWLINE> ac = collections . Counter ( a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> b_num = ac [ b ] <NEWLINE> before = b * b_num <NEWLINE> after = c * ( b_num ) <NEWLINE> a_sum = a_sum - before + after <NEWLINE> ans . append ( a_sum ) <NEWLINE> <NL> tmp = ac [ b ] <NEWLINE> del ac [ b ] <NEWLINE> ac [ c ] += tmp <NEWLINE> <NL> <DEDENT> [ print ( total ) for total in ans ] <NEWLINE>
import heapq <NEWLINE> <NL> N , M , S = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> u , v , A , B = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> graph [ u ] . append ( ( v , A , B ) ) <NEWLINE> graph [ v ] . append ( ( u , A , B ) ) <NEWLINE> <NL> <DEDENT> exchanges = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> C , D = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> exchanges . append ( ( C , D ) ) <NEWLINE> <NL> <DEDENT> queue = [ ( 0 , 0 , S ) ] <NEWLINE> max_fare = 2500 <NEWLINE> <NL> state_table = [ [ None ] * ( max_fare + 1 ) for i in range ( N ) ] <NEWLINE> <NL> reached = [ False ] * N <NEWLINE> reached_count = 0 <NEWLINE> <NL> while queue : <NEWLINE> <COMMENT> <NL> <INDENT> time , cur , money = heapq . heappop ( queue ) <NEWLINE> if not reached [ cur ] : <NEWLINE> <INDENT> reached [ cur ] = True <NEWLINE> reached_count += 1 <NEWLINE> if reached_count >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> count , d_time = exchanges [ cur ] <NEWLINE> for n , A , B in graph [ cur ] : <NEWLINE> <INDENT> n_money = money - A <NEWLINE> n_time = time + B <NEWLINE> if n_money >= 0 : <NEWLINE> <INDENT> states = state_table [ n ] <NEWLINE> if n_money > max_fare : <NEWLINE> <INDENT> n_money = max_fare <NEWLINE> <DEDENT> if states [ n_money ] == None or states [ n_money ] > n_time : <NEWLINE> <INDENT> states [ n_money ] = n_time <NEWLINE> heapq . heappush ( queue , ( n_time , n , n_money ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> states = state_table [ cur ] <NEWLINE> money += count <NEWLINE> time += d_time <NEWLINE> if money >= 0 : <NEWLINE> <INDENT> if money > max_fare : <NEWLINE> <INDENT> money = max_fare <NEWLINE> <DEDENT> if states [ money ] == None or states [ money ] > time : <NEWLINE> <INDENT> states [ money ] = time <NEWLINE> heapq . heappush ( queue , ( time , cur , money ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> states = state_table [ i ] <NEWLINE> minimum = None <NEWLINE> for t in states : <NEWLINE> <INDENT> if t != None and ( minimum == None or minimum > t ) : <NEWLINE> <INDENT> minimum = t <NEWLINE> <DEDENT> <DEDENT> print ( minimum ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> a = [ 0 ] * n <NEWLINE> <NL> for x in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , y + 1 ) : <NEWLINE> <INDENT> t = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x - 1 <NEWLINE> if t >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if x == y == z : <NEWLINE> <INDENT> a [ t ] += 1 <NEWLINE> <DEDENT> elif ( x != y ) and ( y != z ) and ( x != z ) : <NEWLINE> <INDENT> a [ t ] += 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ t ] += 3 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> t = input ( ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( s ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> a = a + 1 <NEWLINE> <DEDENT> elif t [ i ] == <STRING> : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> <DEDENT> g = a * b * c <NEWLINE> for j in range ( s ) : <NEWLINE> <INDENT> for k in range ( j + 1 , s ) : <NEWLINE> <INDENT> p = 2 * k - j <NEWLINE> if p > s - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if t [ j ] != t [ k ] and t [ p ] != t [ k ] and t [ p ] != t [ j ] : <NEWLINE> <INDENT> g = g - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( g ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> S = sum ( A ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> if A [ i ] < S / ( 4 * M ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> class Hash ( object ) : <NEWLINE> <INDENT> def __init__ ( self , size ) : <NEWLINE> <INDENT> self . _array = [ None ] * size <NEWLINE> self . _size = size <NEWLINE> <NL> <DEDENT> def _hash ( self , key ) : <NEWLINE> <INDENT> return key % self . _size <NEWLINE> <NL> <DEDENT> def insert ( self , key , value ) : <NEWLINE> <INDENT> j = self . _hash ( key ) <NEWLINE> if self . _array [ j ] is None : <NEWLINE> <INDENT> self . _array [ j ] = [ value ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . _array [ j ] . append ( value ) <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( self , key , value ) : <NEWLINE> <INDENT> j = self . _hash ( key ) <NEWLINE> if self . _array [ j ] is None : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif value in self . _array [ j ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def stoi ( s ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> p = 1 <NEWLINE> ctoi = { <STRING> : 1 , <STRING> : 2 , <STRING> : 3 , <STRING> : 4 } <NEWLINE> for c in s : <NEWLINE> <INDENT> ret += ctoi [ c ] * p <NEWLINE> p *= 7 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def dictionary ( lst ) : <NEWLINE> <INDENT> h = Hash ( 1046527 ) <NEWLINE> ret = [ ] <NEWLINE> for val in lst : <NEWLINE> <INDENT> if val [ 0 ] == <STRING> : <NEWLINE> <INDENT> h . insert ( stoi ( val [ 1 ] ) , val [ 1 ] ) <NEWLINE> <DEDENT> elif val [ 0 ] == <STRING> : <NEWLINE> <INDENT> if h . find ( stoi ( val [ 1 ] ) , val [ 1 ] ) : <NEWLINE> <INDENT> ret . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> lst = [ val . split ( ) for val in sys . stdin . read ( ) . splitlines ( ) ] <NEWLINE> n = int ( lst . pop ( 0 ) [ 0 ] ) <NEWLINE> print ( <STRING> . join ( dictionary ( lst ) ) ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = min ( N , B ) <NEWLINE> <NL> if p % B == 0 : <NEWLINE> <INDENT> print ( int ( A * ( p - 1 ) // B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( A * ( p ) // B ) ) <NEWLINE> <DEDENT>
from statistics import pstdev , variance , mean <NEWLINE> while 1 : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> if num == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> st = float ( pstdev ( data ) ) <NEWLINE> print ( st ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> List = [ 0 ] * ( n ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> List [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in List : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= 0 <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( b - a + 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ship = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> s1 = [ False ] * N <NEWLINE> sN = [ False ] * N <NEWLINE> <NL> for i , s in enumerate ( ship ) : <NEWLINE> <INDENT> if s [ 0 ] == 1 : <NEWLINE> <INDENT> s1 [ s [ 1 ] - 1 ] = True <NEWLINE> <NL> <DEDENT> if s [ 1 ] == N : <NEWLINE> <INDENT> sN [ s [ 0 ] - 1 ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> if any ( [ p1 * pN for p1 , pN in zip ( s1 , sN ) ] ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = i <NEWLINE> while True : <NEWLINE> <INDENT> x = x // 10 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> B = list ( ) <NEWLINE> C = list ( ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <DEDENT> sum_a = sum ( A ) <NEWLINE> c = Counter ( A ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b_num = c [ B [ i ] ] <NEWLINE> diff = ( C [ i ] - B [ i ] ) * b_num <NEWLINE> c [ C [ i ] ] = c [ C [ i ] ] + c [ B [ i ] ] <NEWLINE> c [ B [ i ] ] = 0 <NEWLINE> sum_a = sum_a + diff <NEWLINE> print ( sum_a ) <NEWLINE> <DEDENT>
def func2 ( l , value ) : <NEWLINE> <INDENT> i = - 1 <NEWLINE> c = len ( l ) <NEWLINE> result = [ ] <NEWLINE> while i < c : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> i = l . index ( value , i + 1 ) <NEWLINE> result . append ( i ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> return result <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <DEDENT> T = list ( input ( ) ) <NEWLINE> que_list = ( func2 ( T , <STRING> ) ) <NEWLINE> for i in que_list : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> print ( <STRING> . join ( T ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> S = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> S = S * A [ i ] <NEWLINE> if S > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> ans = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> def line_to_int ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def line_to_each_int ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def line_to_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def line_to_list_in_iteration ( N ) : return [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from itertools import accumulate <COMMENT> <NEWLINE> import bisect <COMMENT> <NEWLINE> <NL> n , m , k = line_to_each_int ( ) <NEWLINE> A = line_to_list ( ) <NEWLINE> B = line_to_list ( ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> a = [ 0 ] + list ( accumulate ( A ) ) <NEWLINE> b = [ 0 ] + list ( accumulate ( B ) ) <NEWLINE> <NL> ans , j = 0 , m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> A = [ ( i + 1 , a ) for i , a in enumerate ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> A = sorted ( A , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> dp = [ [ - INF ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 0 <NEWLINE> <NL> for s in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for l in range ( s + 1 ) : <NEWLINE> <INDENT> r = s - l <NEWLINE> dp [ l ] [ r ] = max ( dp [ l - 1 ] [ r ] + A [ s - 1 ] [ 1 ] * abs ( A [ s - 1 ] [ 0 ] - l ) , dp [ l ] [ r - 1 ] + A [ s - 1 ] [ 1 ] * abs ( N - r + 1 - A [ s - 1 ] [ 0 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for m in range ( N ) : <NEWLINE> <INDENT> if ( dp [ m ] [ N - m ] > ans ) : <NEWLINE> <INDENT> ans = dp [ m ] [ N - m ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> tele = [ 1 ] <NEWLINE> used = [ False for i in range ( n ) ] <NEWLINE> while True : <NEWLINE> <INDENT> next_number = a [ tele [ len ( tele ) - 1 ] ] <NEWLINE> if not used [ next_number - 1 ] : <NEWLINE> <INDENT> tele . append ( next_number ) <NEWLINE> used [ next_number - 1 ] = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> repeat = tele . index ( next_number ) <NEWLINE> tele_1 = tele [ : repeat ] <NEWLINE> tele_2 = tele [ repeat : ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if k < len ( tele_1 ) : <NEWLINE> <INDENT> print ( tele_1 [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k_new = ( k - len ( tele_1 ) + 1 ) % len ( tele_2 ) <NEWLINE> print ( tele_2 [ k_new - 1 ] ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> ans += int ( N [ i ] ) <NEWLINE> <NL> <DEDENT> if ans % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> ans = - 10000000000 <NEWLINE> mini = 10000000000 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> ans = ans if ( x - mini ) < ans else x - mini <NEWLINE> mini = mini if x > mini else x <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> <NL> l = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <COMMENT> <NEWLINE> d = [ 0 for i in range ( n ) ] <COMMENT> <NEWLINE> f = [ 0 for i in range ( n ) ] <COMMENT> <NEWLINE> stack = [ ] <COMMENT> <NEWLINE> check = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> p = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> for j in range ( n ) : <NEWLINE> <INDENT> if j + 1 in p [ 2 : ] : <NEWLINE> <INDENT> l [ i ] [ j ] = 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> time = 1 <NEWLINE> <NL> <NL> while len ( check ) < n : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i + 1 not in check : <NEWLINE> <INDENT> stack += [ i + 1 ] <NEWLINE> d [ i ] = time <NEWLINE> break <NEWLINE> <DEDENT> else : pass <NEWLINE> <NL> <DEDENT> while len ( stack ) != 0 : <NEWLINE> <COMMENT> <NL> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if l [ stack [ - 1 ] - 1 ] [ i ] == 1 and not i + 1 in check and i + 1 not in stack and stack [ - 1 ] - 1 != i : <NEWLINE> <INDENT> time += 1 <NEWLINE> d [ i ] = time <NEWLINE> stack += [ i + 1 ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> break <NEWLINE> <DEDENT> elif i == n - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> check += [ stack [ - 1 ] ] <NEWLINE> time += 1 <NEWLINE> f [ stack . pop ( ) - 1 ] = time <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> time += 1 <NEWLINE> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( i + 1 , d [ i ] , f [ i ] ) <NEWLINE> <NL> <DEDENT>
N , T = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> c = 0 <NEWLINE> MAX = 0 <NEWLINE> a1 = A [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] <= a1 : <NEWLINE> <INDENT> a1 = A [ i ] <NEWLINE> <DEDENT> a2 = A [ i + 1 ] <NEWLINE> if MAX == a2 - a1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> elif MAX < a2 - a1 : <NEWLINE> <INDENT> MAX = a2 - a1 <NEWLINE> c = 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = [ 0 ] * 8 <NEWLINE> c = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a <= 399 : <NEWLINE> <INDENT> cnt [ 0 ] += 1 <NEWLINE> <DEDENT> elif a >= 400 and a <= 799 : <NEWLINE> <INDENT> cnt [ 1 ] += 1 <NEWLINE> <DEDENT> elif a >= 800 and a <= 1199 : <NEWLINE> <INDENT> cnt [ 2 ] += 1 <NEWLINE> <DEDENT> elif a >= 1200 and a <= 1599 : <NEWLINE> <INDENT> cnt [ 3 ] += 1 <NEWLINE> <DEDENT> elif a >= 1600 and a <= 1999 : <NEWLINE> <INDENT> cnt [ 4 ] += 1 <NEWLINE> <DEDENT> elif a >= 2000 and a <= 2399 : <NEWLINE> <INDENT> cnt [ 5 ] += 1 <NEWLINE> <DEDENT> elif a >= 2400 and a <= 2799 : <NEWLINE> <INDENT> cnt [ 6 ] += 1 <NEWLINE> <DEDENT> elif a >= 2800 and a <= 3199 : <NEWLINE> <INDENT> cnt [ 7 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> Min = len ( [ i for i in cnt if i != 0 ] ) <NEWLINE> if c == 0 : <NEWLINE> <INDENT> print ( Min , Min ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Max = Min + c <NEWLINE> if Min == 0 : <NEWLINE> <INDENT> print ( 1 , Max ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Min , Max ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> _ = input ( ) <NEWLINE> a = [ * map ( int , input ( ) . split ( ) ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> s = sum ( a ) <NEWLINE> b = [ [ * map ( int , input ( ) . split ( ) ) ] for _ in range ( q ) ] <NEWLINE> c = collections . Counter ( a ) <NEWLINE> for i , j in b : <NEWLINE> <INDENT> if j not in c : <NEWLINE> <INDENT> c [ j ] = 0 <NEWLINE> <DEDENT> if i not in c : <NEWLINE> <INDENT> c [ i ] = 0 <NEWLINE> <DEDENT> s += ( j - i ) * c [ i ] <NEWLINE> c [ j ] += c [ i ] <NEWLINE> c [ i ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> S = int ( input ( ) ) <NEWLINE> <NL> A = [ - 1 ] * ( 2001 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> A [ i ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 3 , 6 ) : <NEWLINE> <INDENT> A [ i ] = 1 <NEWLINE> <NL> <NL> <DEDENT> def dfs ( n ) : <NEWLINE> <INDENT> if A [ n ] != - 1 : <NEWLINE> <INDENT> return A [ n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ n ] = ( dfs ( n - 3 ) + dfs ( n - 1 ) ) % mod <NEWLINE> return A [ n ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( dfs ( S ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> count = 0 <NEWLINE> while ( a <= b ) : <NEWLINE> <INDENT> if c % a == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> a += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if ( N % 2 == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> m = N // 2 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if ( S [ i ] != S [ i + m ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ab_max = n - 1 <NEWLINE> ans = sum ( ab_max // a for a in range ( 1 , n ) ) <NEWLINE> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ False ] * n <NEWLINE> pos = 0 <NEWLINE> for i in range ( min ( n , k ) ) : <NEWLINE> <INDENT> if b [ pos ] != False : <NEWLINE> <INDENT> loop = i - b [ pos ] + 1 <NEWLINE> break <NEWLINE> <DEDENT> b [ pos ] = i + 1 <NEWLINE> pos = a [ pos ] - 1 <NEWLINE> k -= 1 <NEWLINE> <DEDENT> if k > 0 : <NEWLINE> <INDENT> for i in range ( k % loop ) : <NEWLINE> <INDENT> pos = a [ pos ] - 1 <NEWLINE> <DEDENT> <DEDENT> print ( pos + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = { } <NEWLINE> for i in a : <NEWLINE> <INDENT> cnt . setdefault ( i , 0 ) <NEWLINE> cnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> cnt . setdefault ( i , 0 ) <NEWLINE> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> alp = <STRING> <NEWLINE> answer = <STRING> <NEWLINE> <NL> while n >= 1 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> answer += alp [ n % 26 ] <NEWLINE> n //= 26 <NEWLINE> <NL> <DEDENT> real_answer = <STRING> <NEWLINE> for i in range ( 1 , len ( answer ) + 1 ) : <NEWLINE> <INDENT> real_answer += answer [ - i ] <NEWLINE> <NL> <DEDENT> print ( real_answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> d = set ( ) <NEWLINE> input ( ) <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> c , g = e . split ( ) <NEWLINE> if <STRING> == c [ 0 ] : d |= set ( [ g ] ) <NEWLINE> else : print ( [ <STRING> , <STRING> ] [ g in d ] ) <NEWLINE> <DEDENT>
import os <NEWLINE> <NL> N = input ( ) <NEWLINE> S = set ( ) <NEWLINE> N = int ( N ) <NEWLINE> count = 0 <NEWLINE> for i in range ( int ( N ) ) : <NEWLINE> <INDENT> tmp = input ( ) <NEWLINE> if ( tmp in S ) == False : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> S . add ( tmp ) <NEWLINE> <NL> <NL> <DEDENT> print ( count ) <NEWLINE>
while True : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if N == 0 : break <NEWLINE> dataset = input ( ) <NEWLINE> mens = [ <STRING> for _ in range ( N ) ] <NEWLINE> i = 0 <NEWLINE> p = <STRING> <NEWLINE> while dataset : <NEWLINE> <INDENT> if i == N : i = 0 <NEWLINE> card , dataset = dataset [ 0 ] , dataset [ 1 : ] <NEWLINE> if card == <STRING> : <NEWLINE> <INDENT> mens [ i ] += card <NEWLINE> <DEDENT> elif card == <STRING> : <NEWLINE> <INDENT> p += card + mens [ i ] <NEWLINE> mens [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mens [ i ] += card + p <NEWLINE> p = <STRING> <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , sorted ( [ len ( m ) for m in mens ] ) ) ) , len ( p ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def solve ( S : str ) : <NEWLINE> <NL> <INDENT> l = [ 0 ] * 2019 <NEWLINE> ps = 0 <NEWLINE> d = 1 <NEWLINE> for i in range ( 1 , len ( S ) + 1 ) : <NEWLINE> <INDENT> ps += int ( S [ - i ] ) * d <NEWLINE> l [ ps % 2019 ] += 1 <NEWLINE> d = d * 10 % 2019 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> ans += l [ 0 ] <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> return <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> S = next ( tokens ) <COMMENT> <NEWLINE> solve ( S ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections as cl <NEWLINE> N = int ( input ( ) ) <NEWLINE> x = [ ] <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> x . append ( a ) <NEWLINE> <NL> <DEDENT> d = cl . Counter ( x ) <NEWLINE> <NL> for i in d . values ( ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 0 <NEWLINE> m = l [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> m = max ( m , l [ i ] ) <NEWLINE> sum += m - l [ i ] <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
t = input ( ) <NEWLINE> u = list ( t ) <NEWLINE> if u [ 0 ] == <STRING> : <NEWLINE> <INDENT> u [ 0 ] = <STRING> <NEWLINE> <DEDENT> if u [ - 1 ] == <STRING> : <NEWLINE> <INDENT> u [ - 1 ] = <STRING> <NEWLINE> <DEDENT> for i in range ( 1 , len ( u ) - 1 ) : <NEWLINE> <INDENT> if u [ i ] == <STRING> : <NEWLINE> <INDENT> if u [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> u [ i ] = <STRING> <NEWLINE> <DEDENT> elif u [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> u [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> u [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( u ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> z = n % k <NEWLINE> if k == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( z , k - z ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
mod = 1000000007 <NEWLINE> l = input ( ) . split ( ) <NEWLINE> m = int ( l [ 0 ] ) <NEWLINE> n = int ( l [ 1 ] ) <NEWLINE> <NL> <NL> def power ( x , y ) : <NEWLINE> <INDENT> if y == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif y == 1 : <NEWLINE> <INDENT> return x % mod <NEWLINE> <DEDENT> elif y % 2 == 0 : <NEWLINE> <INDENT> return power ( x , y / 2 ) ** 2 % mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return power ( x , int ( y / 2 ) ) ** 2 * x % mod <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = power ( m , n ) <NEWLINE> print ( ans ) <NEWLINE> <NL>
h = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 10 ** 12 ) : <NEWLINE> <INDENT> if 2 ** i <= h < 2 ** ( i + 1 ) : <NEWLINE> <INDENT> ans = 2 ** ( i + 1 ) - 1 <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> class DAG : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . n = n <NEWLINE> self . adj = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> <DEDENT> def addEdge ( self , parent , child ) : <NEWLINE> <INDENT> self . adj [ parent ] . append ( child ) <NEWLINE> <NL> <DEDENT> def dfsWithDp ( self , node , dp , visited ) : <NEWLINE> <INDENT> if ( visited [ node ] ) : <NEWLINE> <INDENT> return dp [ node ] <NEWLINE> <DEDENT> visited [ node ] = True <NEWLINE> for child in self . adj [ node ] : <NEWLINE> <INDENT> if not visited [ child ] : <NEWLINE> <INDENT> self . dfsWithDp ( child , dp , visited ) <NEWLINE> <DEDENT> dp [ node ] = max ( dp [ node ] , 1 + self . dfsWithDp ( child , dp , visited ) ) <NEWLINE> <DEDENT> return dp [ node ] <NEWLINE> <NL> <DEDENT> def findLongestPathWithDp ( self ) : <NEWLINE> <INDENT> visited = [ False ] * self . n <NEWLINE> dp = [ 0 ] * self . n <COMMENT> <NEWLINE> ans = 0 <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> ans = max ( ans , self . dfsWithDp ( i , dp , visited ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> dag = DAG ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> parent , child = map ( lambda i : int ( i ) - 1 , input ( ) . split ( ) ) <NEWLINE> dag . addEdge ( parent , child ) <NEWLINE> <DEDENT> print ( dag . findLongestPathWithDp ( ) ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 2 * 10 ** 9 ) <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> i , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ i - 1 ] . append ( k - 1 ) <NEWLINE> A [ k - 1 ] . append ( i - 1 ) <NEWLINE> <DEDENT> n_P = [ 0 ] * N <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> k , n = map ( int , input ( ) . split ( ) ) <NEWLINE> n_P [ k - 1 ] += n <NEWLINE> <DEDENT> ans = [ 0 ] * N <NEWLINE> visited = [ 0 ] * N <NEWLINE> def make ( num , p ) : <NEWLINE> <INDENT> ans [ num ] += n_P [ num ] <NEWLINE> ans [ num ] += p <NEWLINE> visited [ num ] = 1 <NEWLINE> for i in A [ num ] : <NEWLINE> <INDENT> if visited [ i ] == 0 : <NEWLINE> <INDENT> make ( i , ans [ num ] ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <DEDENT> make ( 0 , ans [ 0 ] ) <NEWLINE> print ( * ans ) <NEWLINE>
import math <NEWLINE> <NL> pi = math . pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> <NL> S = r * r * pi <NEWLINE> L = 2 * r * pi <NEWLINE> <NL> print ( <STRING> . format ( S , L ) ) <NEWLINE>
import math <NEWLINE> <NL> n , m , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> road = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> u , v , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> road . append ( [ u , v , a , b ] ) <NEWLINE> <NL> <DEDENT> change = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> change . append ( [ c , d ] ) <NEWLINE> <NL> <DEDENT> tree = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> r = road [ i ] <NEWLINE> tree [ r [ 0 ] ] . append ( [ r [ 0 ] , r [ 1 ] , r [ 2 ] , r [ 3 ] ] ) <NEWLINE> tree [ r [ 1 ] ] . append ( [ r [ 1 ] , r [ 0 ] , r [ 2 ] , r [ 3 ] ] ) <NEWLINE> <NL> <DEDENT> least_cost = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for l in range ( n + 1 ) : <NEWLINE> <INDENT> least_cost [ l ] = [ math . inf ] * 2501 <NEWLINE> <NL> <NL> <DEDENT> def insort_queue ( q , v ) : <NEWLINE> <INDENT> len_a = len ( q ) <NEWLINE> if len_a == 0 : <NEWLINE> <INDENT> q . append ( v ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> min = 0 <NEWLINE> max_1 = len_a <NEWLINE> <NL> if max_1 == 1 : <NEWLINE> <INDENT> if v [ 2 ] > q [ 0 ] [ 2 ] : <NEWLINE> <INDENT> min = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min = 0 <NEWLINE> <DEDENT> <DEDENT> while max_1 - min > 1 : <NEWLINE> <INDENT> mid = ( max_1 + min ) // 2 <NEWLINE> if v [ 2 ] > q [ mid ] [ 2 ] : <NEWLINE> <INDENT> min = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_1 = mid <NEWLINE> <DEDENT> <DEDENT> index = max_1 <NEWLINE> q . insert ( index , v ) <NEWLINE> <NL> <DEDENT> queue = [ ] <NEWLINE> <NL> <COMMENT> <NL> def dijakstra ( q ) : <NEWLINE> <INDENT> while q != [ ] : <NEWLINE> <INDENT> hwd = q . pop ( 0 ) <NEWLINE> <NL> if least_cost [ hwd [ 0 ] ] [ hwd [ 1 ] ] > hwd [ 2 ] : <NEWLINE> <INDENT> least_cost [ hwd [ 0 ] ] [ hwd [ 1 ] ] = hwd [ 2 ] <NEWLINE> <NL> for node in tree [ hwd [ 0 ] ] : <NEWLINE> <COMMENT> <NL> <INDENT> if hwd [ 1 ] - node [ 2 ] >= 0 : <NEWLINE> <INDENT> insort_queue ( q , [ node [ 1 ] , hwd [ 1 ] - node [ 2 ] , hwd [ 2 ] + node [ 3 ] ] ) <NEWLINE> <DEDENT> <DEDENT> if hwd [ 1 ] + change [ hwd [ 0 ] - 1 ] [ 0 ] <= 500 : <NEWLINE> <INDENT> insort_queue ( q , [ hwd [ 0 ] , hwd [ 1 ] + change [ hwd [ 0 ] - 1 ] [ 0 ] , hwd [ 2 ] + change [ hwd [ 0 ] - 1 ] [ 1 ] ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return least_cost <NEWLINE> <NL> <DEDENT> if s > 2500 : <NEWLINE> <INDENT> s = 2500 <NEWLINE> <DEDENT> queue . append ( [ 1 , s , 0 ] ) <NEWLINE> <NL> ans = dijakstra ( queue ) <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( min ( ans [ i ] ) ) <NEWLINE> <DEDENT>
def merge_jibun ( A , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> inf = 10 ** 9 <NEWLINE> L = A [ left : mid ] + [ inf ] <NEWLINE> R = A [ mid : right ] + [ inf ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> <NL> <NL> for k in range ( left , right ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def merge_hoka ( A , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> inf = 10 ** 9 <NEWLINE> L = A [ left : mid ] + [ inf ] <NEWLINE> R = A [ mid : right ] + [ inf ] <NEWLINE> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge_jibun ( A , left , mid , right ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> mergeSort ( A , 0 , n ) <NEWLINE> <NL> print ( <STRING> . join ( list ( map ( str , A ) ) ) ) <NEWLINE> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> word = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , i + k + 1 ) : <NEWLINE> <INDENT> word . append ( s [ i : j ] ) <NEWLINE> <DEDENT> <DEDENT> word = sorted ( list ( set ( word ) ) ) <NEWLINE> print ( word [ k - 1 ] ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> si = input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> sorted_s = <STRING> . join ( sorted ( Counter ( si ) . elements ( ) ) ) <NEWLINE> if sorted_s in dic : <NEWLINE> <INDENT> ans += dic [ sorted_s ] <NEWLINE> dic [ sorted_s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ sorted_s ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> lst = [ ] <NEWLINE> for P in range ( 1 , max ( x ) + 1 ) : <NEWLINE> <INDENT> n = 0 <NEWLINE> for j in x : <NEWLINE> <INDENT> n += ( j - P ) ** 2 <NEWLINE> <DEDENT> lst . append ( n ) <NEWLINE> <DEDENT> print ( min ( lst ) ) <NEWLINE>
from math import gcd <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> m = max ( a ) <NEWLINE> p = [ 0 ] * ( m + 1 ) <NEWLINE> for i in range ( 2 , m + 1 ) : <NEWLINE> <INDENT> if p [ i ] == 0 : <NEWLINE> <INDENT> for j in range ( i , m + 1 , i ) : <NEWLINE> <INDENT> p [ j ] = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> factors = set ( ) <NEWLINE> for ai in a : <NEWLINE> <INDENT> if ai == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> f = set ( ) <NEWLINE> while ai > p [ ai ] : <NEWLINE> <INDENT> f . add ( p [ ai ] ) <NEWLINE> ai //= p [ ai ] <NEWLINE> <DEDENT> f . add ( ai ) <NEWLINE> if factors & f : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> factors |= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> g = a [ 0 ] <NEWLINE> for ai in a [ 1 : ] : <NEWLINE> <INDENT> g = gcd ( ai , g ) <NEWLINE> if g == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a = Counter ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> sum_a = sum ( a . elements ( ) ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ c ] += a [ b ] <NEWLINE> sum_a += ( c - b ) * a [ b ] <NEWLINE> a [ b ] = 0 <NEWLINE> print ( sum_a ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> MAX = 9999999999 <NEWLINE> <NL> c = [ ] <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ca = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c . append ( ca [ 0 ] ) <NEWLINE> a . append ( ca [ 1 : ] ) <NEWLINE> <NL> <DEDENT> c = np . array ( c ) <NEWLINE> a = np . array ( a ) <NEWLINE> <NL> pat = 2 ** n <NEWLINE> ans = MAX <NEWLINE> for i in range ( pat ) : <NEWLINE> <INDENT> pat_i = bin ( i ) [ 2 : ] . zfill ( n ) <NEWLINE> ai = np . array ( [ 0 for _ in range ( m ) ] ) <NEWLINE> ansi = 0 <NEWLINE> <NL> for j in range ( len ( pat_i ) ) : <NEWLINE> <INDENT> if ( pat_i [ j ] == <STRING> ) : <NEWLINE> <INDENT> ansi += c [ j ] <NEWLINE> ai += a [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> if ( min ( ai ) >= x ) : <NEWLINE> <INDENT> ans = min ( ans , ansi ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ( ans != MAX ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = [ ] <NEWLINE> sum1 = sum ( a ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> bc . append ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <DEDENT> d = defaultdict ( lambda : 0 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> if bc [ i ] [ 0 ] in d : <NEWLINE> <INDENT> sum1 += ( bc [ i ] [ 1 ] - bc [ i ] [ 0 ] ) * d [ bc [ i ] [ 0 ] ] <NEWLINE> d [ bc [ i ] [ 1 ] ] += d [ bc [ i ] [ 0 ] ] <NEWLINE> del d [ bc [ i ] [ 0 ] ] <NEWLINE> <DEDENT> print ( sum1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( lambda x : int ( x ) * ( - 1 ) , input ( ) . split ( ) ) ) <NEWLINE> import heapq <NEWLINE> heapq . heapify ( a ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> num = heapq . heappop ( a ) <NEWLINE> heapq . heappush ( a , ( - num // 2 ) * ( - 1 ) ) <NEWLINE> <DEDENT> print ( - sum ( a ) ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( tmp , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_all = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a_all ^= a [ i ] <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> ans . append ( a_all ^ a [ j ] ) <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
import math <NEWLINE> <NL> <NL> K = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> r = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> result += math . gcd ( r , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for _ in range ( m ) ] ) <NEWLINE> <NL> nums = [ 0 ] * ( n + 1 ) <NEWLINE> nums [ 0 ] = 1 <NEWLINE> if 1 not in a : nums [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> nums [ i ] = nums [ i - 1 ] + nums [ i - 2 ] <NEWLINE> if i in a : nums [ i ] = 0 <NEWLINE> <DEDENT> print ( nums [ n ] % 1000000007 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p , q = 1 , 1 <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = max ( ( p + t - 1 ) // t , ( q + a - 1 ) // a ) <NEWLINE> p , q = n * t , n * a <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( p + q ) <NEWLINE>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( a , gcd ( b , c ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
ni = lambda : int ( input ( ) ) <NEWLINE> nm = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 500000 ) <NEWLINE> <NL> visited = set ( ) <NEWLINE> <NL> n , q = nm ( ) <NEWLINE> <NL> tval = [ 0 ] * n <NEWLINE> t = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = nm ( ) <NEWLINE> t [ a - 1 ] . append ( b - 1 ) <NEWLINE> t [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> p , x = nm ( ) <NEWLINE> tval [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> def dfs ( num , val ) : <NEWLINE> <INDENT> visited . add ( num ) <NEWLINE> now = val + tval [ num ] <NEWLINE> ans [ num ] = now <NEWLINE> for nn in t [ num ] : <NEWLINE> <INDENT> if nn not in visited : <NEWLINE> <INDENT> dfs ( nn , now ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , 0 ) <NEWLINE> <NL> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> visit = { 0 } <NEWLINE> tmp = 0 <NEWLINE> a_list = [ 0 ] <NEWLINE> ans = True <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> tmp = a [ tmp ] <NEWLINE> if tmp in visit : <NEWLINE> <INDENT> left = a_list . index ( tmp ) <NEWLINE> ans = False <NEWLINE> print ( a_list [ left + ( k - left ) % ( i + 1 - left ) ] + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visit . add ( tmp ) <NEWLINE> a_list . append ( tmp ) <NEWLINE> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( tmp + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import Counter <NEWLINE> <NL> h , w , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> H = [ ] <NEWLINE> W = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> hh , ww = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H . append ( hh ) <NEWLINE> W . append ( ww ) <NEWLINE> <DEDENT> h_m = Counter ( H ) . most_common ( ) [ 0 ] <NEWLINE> w_m = Counter ( W ) . most_common ( ) [ 0 ] <NEWLINE> <NL> ans_1 = h_m [ 1 ] <NEWLINE> ans_2 = w_m [ 1 ] <NEWLINE> <NL> <COMMENT> <NL> WW = [ ] <NEWLINE> HH = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if H [ i ] == h_m [ 0 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> WW . append ( W [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if W [ i ] == w_m [ 0 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> HH . append ( H [ i ] ) <NEWLINE> <DEDENT> if WW : <NEWLINE> <INDENT> ans_1 += Counter ( WW ) . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> <DEDENT> if HH : <NEWLINE> <INDENT> ans_2 += Counter ( HH ) . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> <NL> <DEDENT> print ( max ( ans_1 , ans_2 ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( str , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <NL> result = collections . Counter ( a ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( result [ str ( i ) ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import math <NEWLINE> x = int ( input ( ) ) <NEWLINE> ys = [ ] <NEWLINE> i = 1 <NEWLINE> while i ** 2 < x : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> ys . append ( i ) <NEWLINE> ys . append ( x // i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if i ** 2 == x : <NEWLINE> <INDENT> ys . append ( i ) <NEWLINE> <NL> <DEDENT> f = False <NEWLINE> <NL> for j in ys : <NEWLINE> <INDENT> for i in range ( 10 ** 3 ) : <NEWLINE> <INDENT> if i ** 5 - ( i - j ) ** 5 == x : <NEWLINE> <INDENT> print ( i , i - j ) <NEWLINE> break <NEWLINE> <DEDENT> elif i ** 5 - ( i - j ) ** 5 > x and i - j > 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = [ ] <NEWLINE> g = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> unchi = set ( b ) <NEWLINE> for i in r : <NEWLINE> <INDENT> for j in g : <NEWLINE> <INDENT> u = abs ( i - j ) <NEWLINE> count += [ 0 , 1 ] [ ( max ( i , j ) + u ) in unchi ] + [ 0 , 1 ] [ ( min ( i , j ) - u ) in unchi ] + [ 0 , 1 ] [ u % 2 == 0 and ( i + j ) // 2 in unchi ] <NEWLINE> <DEDENT> <DEDENT> print ( len ( r ) * len ( g ) * len ( b ) - count ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( - 120 , 120 ) : <NEWLINE> <INDENT> for j in range ( - 120 , 120 ) : <NEWLINE> <INDENT> if pow ( i , 5 ) - pow ( j , 5 ) == x : <NEWLINE> <INDENT> ans += [ [ i , j ] ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = list ( map ( str , ans [ 0 ] ) ) <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE>
def cal ( A , B , x ) : <NEWLINE> <INDENT> return int ( ( A * x ) / B ) - A * int ( x / B ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N <= B - 1 : <NEWLINE> <INDENT> ans = cal ( A , B , N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = cal ( A , B , B - 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = { } <NEWLINE> s = [ ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> ab = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ab [ 0 ] in d . keys ( ) : <NEWLINE> <INDENT> d [ ab [ 0 ] ] = max ( d [ ab [ 0 ] ] , H [ ab [ 1 ] - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ ab [ 0 ] ] = H [ ab [ 1 ] - 1 ] <NEWLINE> <DEDENT> if ab [ 1 ] in d . keys ( ) : <NEWLINE> <INDENT> d [ ab [ 1 ] ] = max ( d [ ab [ 1 ] ] , H [ ab [ 0 ] - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ ab [ 1 ] ] = H [ ab [ 0 ] - 1 ] <NEWLINE> <DEDENT> s . append ( ab [ 0 ] ) <NEWLINE> s . append ( ab [ 1 ] ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in d . keys ( ) : <NEWLINE> <INDENT> if H [ i - 1 ] > d [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count += N - len ( set ( s ) ) <NEWLINE> <NL> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ [ ] for x in range ( N ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> L [ i ] = [ A [ i ] , i + 1 ] <NEWLINE> <DEDENT> L . sort ( ) <NEWLINE> <NL> ANS = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ANS [ i ] = L [ i ] [ 1 ] <NEWLINE> <DEDENT> print ( * ANS ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def process ( commands ) : <NEWLINE> <INDENT> d = set ( ) <NEWLINE> for c in commands : <NEWLINE> <INDENT> cpair = c . split ( ) <NEWLINE> if cpair [ 0 ] == <STRING> : <NEWLINE> <INDENT> d . add ( cpair [ 1 ] ) <NEWLINE> <DEDENT> elif cpair [ 0 ] == <STRING> : <NEWLINE> <INDENT> r = <STRING> if cpair [ 1 ] in d else <STRING> <NEWLINE> print ( r ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> commands = [ input ( ) for i in range ( n ) ] <NEWLINE> process ( commands ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = input ( ) <NEWLINE> N = int ( N ) <NEWLINE> x = N // 3 <NEWLINE> x = int ( x ) <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> sum = 0 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( x ) : <NEWLINE> <INDENT> y = N - 3 * k - 3 <NEWLINE> l = k <NEWLINE> M = y + l <NEWLINE> a = math . factorial ( l ) <NEWLINE> b = math . factorial ( M ) <NEWLINE> c = math . factorial ( y ) <NEWLINE> d = a * c <NEWLINE> z = b // d <NEWLINE> z = z % p <NEWLINE> sum += z <NEWLINE> sum = sum % p <NEWLINE> <NL> <DEDENT> sum = int ( sum ) <NEWLINE> print ( sum ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
import sys <NEWLINE> <NL> n , x , m = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> l = [ x ] <NEWLINE> ans = x <NEWLINE> memo_array = [ - 1 ] * ( m + 1 ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = ans ** 2 % m <NEWLINE> idx = memo_array [ ans ] <NEWLINE> if idx != - 1 : <NEWLINE> <INDENT> loop_num , mod = divmod ( ( n - idx ) , ( i - idx ) ) <NEWLINE> print ( sum ( l [ : idx ] ) + sum ( l [ idx : ] ) * ( loop_num ) + sum ( l [ idx : idx + mod ] ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> l . append ( ans ) <NEWLINE> memo_array [ ans ] = i <NEWLINE> <DEDENT> print ( sum ( l ) ) <NEWLINE>
import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> <NL> def is_prime ( x ) : <NEWLINE> <INDENT> a = int ( math . sqrt ( X ) ) + 1 <COMMENT> <NEWLINE> for i in range ( 2 , a ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <COMMENT> <NEWLINE> <NL> <DEDENT> for j in range ( X , 10 ** 5 + 4 ) : <NEWLINE> <INDENT> if is_prime ( j ) : <NEWLINE> <INDENT> ans = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for t in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for s in range ( t , K + 1 ) : <NEWLINE> <INDENT> for v in range ( s , K + 1 ) : <NEWLINE> <INDENT> if t != s != v : <NEWLINE> <INDENT> count += ( 6 * math . gcd ( ( math . gcd ( t , s ) ) , v ) ) <NEWLINE> <DEDENT> elif ( t == s and t != v ) or ( t == v and t != s ) or ( s == v and s != t ) : <NEWLINE> <INDENT> count += ( 3 * math . gcd ( ( math . gcd ( t , s ) ) , v ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += math . gcd ( ( math . gcd ( t , s ) ) , v ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if ( a [ i ] > a [ i - k ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a_list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> ary = [ 0 for _ in range ( ( 10 ** 5 ) + 1 ) ] <NEWLINE> <NL> for i in a_list : <NEWLINE> <INDENT> ary [ i ] += 1 <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> <NL> f_ans = sum ( a_list ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> f_ans += ( c - b ) * ary [ b ] <NEWLINE> ary [ c ] += ary [ b ] <NEWLINE> ary [ b ] = 0 <NEWLINE> <NL> ans . append ( f_ans ) <NEWLINE> <NL> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
from math import sqrt <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> n_sqrt = int ( sqrt ( n ) ) <NEWLINE> <NL> dp = [ - 1 ] * ( n_sqrt + 2 ) <NEWLINE> <NL> for i in range ( 2 , n_sqrt + 2 ) : <NEWLINE> <INDENT> if dp [ i ] == - 1 : <NEWLINE> <INDENT> dp [ i ] = 1 <NEWLINE> for j in range ( i * 2 , n_sqrt + 2 , i ) : <NEWLINE> <INDENT> dp [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> prime = [ ] <NEWLINE> <NL> for i in range ( 2 , n_sqrt + 2 ) : <NEWLINE> <INDENT> if dp [ i ] == 1 : <NEWLINE> <INDENT> prime . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> prime . append ( n ) <NEWLINE> <NL> memo = [ ] <NEWLINE> for p in prime : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while n % p == 0 : <NEWLINE> <INDENT> n //= p <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> if cnt : <NEWLINE> <INDENT> memo . append ( cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> if n > 1 : <NEWLINE> <INDENT> memo . append ( 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for j in memo : <NEWLINE> <INDENT> k = 1 <NEWLINE> while True : <NEWLINE> <NL> <INDENT> if k * ( k + 1 ) // 2 <= j <= k * ( k + 3 ) // 2 : <NEWLINE> <INDENT> ans += k <NEWLINE> break <NEWLINE> <DEDENT> k += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) ) <NEWLINE> while n : <NEWLINE> <INDENT> l = list ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> l . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> a = l . copy ( ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a [ i ] = max ( a [ i - 1 ] + l [ i ] , l [ i ] ) <NEWLINE> <DEDENT> print ( max ( a ) ) <NEWLINE> n = int ( sys . stdin . readline ( ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) . split ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> t = input ( ) . split ( ) <NEWLINE> c = 0 <NEWLINE> s = list ( map ( int , s ) ) <NEWLINE> t = list ( map ( int , t ) ) <NEWLINE> <NL> for i in t : <NEWLINE> <INDENT> l = 0 <NEWLINE> r = n - 1 <NEWLINE> cen = int ( ( l + r ) / 2 ) <NEWLINE> while r >= l : <NEWLINE> <COMMENT> <NL> <INDENT> if i > s [ cen ] : <NEWLINE> <INDENT> l = cen <NEWLINE> cen = int ( ( l + r ) / 2 ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif i < s [ cen ] : <NEWLINE> <INDENT> r = cen <NEWLINE> cen = int ( ( l + r ) / 2 ) <NEWLINE> <COMMENT> <NL> <DEDENT> if i == s [ cen ] or i == s [ l ] or i == s [ r ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <COMMENT> <NL> break <NEWLINE> <DEDENT> if l + 1 > r - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from collections import Counter <NEWLINE> <NL> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> r = [ ] <NEWLINE> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> r += i - A [ i ] , <NEWLINE> l += i + A [ i ] , <NEWLINE> <NL> <DEDENT> c = Counter ( l ) <NEWLINE> for i in r : <NEWLINE> <INDENT> count += c [ i ] <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> pp , ss = map ( int , input ( ) . split ( ) ) <NEWLINE> ss -= 1 <NEWLINE> pp -= 1 <NEWLINE> A [ pp ] . append ( H [ ss ] ) <NEWLINE> A [ ss ] . append ( H [ pp ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> now = H [ j ] <NEWLINE> if not A [ j ] or now > max ( A [ j ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> resolve ( ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> class BIT : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . size = n <NEWLINE> self . tree = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> <DEDENT> def sum ( self , i ) : <NEWLINE> <COMMENT> <NL> <INDENT> s = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> s += self . tree [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return s <NEWLINE> <COMMENT> <NL> <DEDENT> def add ( self , i , x ) : <NEWLINE> <INDENT> while i <= self . size : <NEWLINE> <INDENT> self . tree [ i ] += x <NEWLINE> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> bit = BIT ( 2001 ) <NEWLINE> count = [ 0 ] * ( 2001 ) <NEWLINE> t = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = a [ i ] <NEWLINE> count [ x ] += 1 <NEWLINE> t . append ( i - bit . sum ( x ) ) <NEWLINE> bit . add ( x , 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 2001 ) : <NEWLINE> <INDENT> count [ i ] += count [ i - 1 ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = k * ( 2 * t [ i ] + ( k - 1 ) % mod * count [ a [ i ] - 1 ] ) // 2 <NEWLINE> ans = ( ans + x ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<NL> <NL> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if ( x == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> M = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> M = M * A [ i ] <NEWLINE> if M > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( M ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> quotient = N // ( A + B ) * A <NEWLINE> remainder = N % ( A + B ) <NEWLINE> <NL> quotient += min ( ( remainder , A ) ) <NEWLINE> <NL> print ( quotient ) <NEWLINE>
from decimal import * <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> a = Decimal ( a ) <NEWLINE> b = Decimal ( b ) <NEWLINE> ans = int ( a * b ) <NEWLINE> print ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) ; <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) ; <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> b = int ( input ( ) ) ; <NEWLINE> if b == x : <NEWLINE> <INDENT> print ( x - 1 ) ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) ; <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) ; <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a . count ( x - i ) == 0 : <NEWLINE> <INDENT> ooo = 1 ; <NEWLINE> break ; <NEWLINE> <DEDENT> if a . count ( x + i ) == 0 : <NEWLINE> <INDENT> ooo = 2 ; <NEWLINE> break ; <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if ooo == 1 : <NEWLINE> <INDENT> print ( x - i ) ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x + i ) ; <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> is_ok = [ False ] * ( 10 ** 6 + 1 ) <NEWLINE> is_exist = [ False ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if is_exist [ a ] : <NEWLINE> <INDENT> is_ok [ a ] = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> is_exist [ a ] = True <NEWLINE> is_ok [ a ] = True <NEWLINE> for i in range ( 1 , 10 ** 6 // a + 1 ) : <NEWLINE> <INDENT> if a * i <= 10 ** 6 : <NEWLINE> <INDENT> is_exist [ a * i ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( is_ok . count ( True ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = { } <NEWLINE> if N == 1 and M == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if N == 2 and M == 0 : <NEWLINE> <INDENT> print ( 10 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if N == 3 and M == 0 : <NEWLINE> <INDENT> print ( 100 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if N == 1 and M == 1 : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( c ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if s == 1 and c == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if s in lis : <NEWLINE> <INDENT> if lis [ s ] == c : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> lis [ s ] = c <NEWLINE> <DEDENT> <DEDENT> if not 1 in lis : <NEWLINE> <INDENT> lis [ 1 ] = 1 <NEWLINE> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if not i in lis : <NEWLINE> <INDENT> lis [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += str ( lis [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
input ( ) <NEWLINE> print ( <STRING> . join ( input ( ) . split ( ) [ : : - 1 ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = 1 <NEWLINE> if 0 in num_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in num_list : <NEWLINE> <INDENT> a = a * x <NEWLINE> if ( a > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( a <= 1000000000000000000 ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> name = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a == b ) : <NEWLINE> <INDENT> sum += 1 <NEWLINE> if ( sum == 3 ) : <NEWLINE> <INDENT> name . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> sum = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( name ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> _sum = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> _sum += p [ i ] <NEWLINE> <DEDENT> print ( _sum ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = [ ] <COMMENT> <NEWLINE> ord = [ - 1 for i in range ( n + 1 ) ] <COMMENT> <NEWLINE> c = 1 <COMMENT> <NEWLINE> l = 0 <COMMENT> <NEWLINE> <NL> v = 1 <COMMENT> <NEWLINE> while ord [ v ] == - 1 : <NEWLINE> <INDENT> ord [ v ] = len ( s ) <NEWLINE> s . append ( v ) <NEWLINE> v = a [ v - 1 ] <NEWLINE> <NL> <DEDENT> l = ord [ v ] <NEWLINE> c = len ( s ) - l <NEWLINE> <NL> if k < l : <NEWLINE> <INDENT> print ( s [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= l <NEWLINE> k %= c <NEWLINE> print ( s [ l + k ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> power = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> power *= i <NEWLINE> if power >= 10 ** 9 + 7 : <NEWLINE> <INDENT> power %= 10 ** 9 + 7 <NEWLINE> <DEDENT> <DEDENT> print ( power % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> lb = 0 <NEWLINE> ub = 3 * n - 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lb += 1 <NEWLINE> ub -= 1 <NEWLINE> ans += a [ ub ] <NEWLINE> ub -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> m = 0 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> m = ( m * 10 + 7 ) % k <NEWLINE> if m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif i == k - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( i + 1 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i - k ] < a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a . sort ( ) <NEWLINE> fmt = format ( <STRING> ) <NEWLINE> g = fmt . format ( a [ 0 ] , a [ 1 ] , a [ 2 ] ) <NEWLINE> print ( g ) <NEWLINE>
while True : <NEWLINE> <INDENT> n , m , h , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> points = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> bars = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> bars_h = [ set ( ) for _ in range ( h ) ] <NEWLINE> for ba , bh in bars : <NEWLINE> <INDENT> bars_h [ bh ] . add ( ba - 1 ) <NEWLINE> <DEDENT> swap = list ( range ( n ) ) <NEWLINE> history = set ( ) <NEWLINE> <NL> for i in range ( h - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> for ba in bars_h [ i ] : <NEWLINE> <INDENT> l , r = swap [ ba : ba + 2 ] <NEWLINE> history . add ( ( l , r ) if l < r else ( r , l ) ) <NEWLINE> swap [ ba : ba + 2 ] = r , l <NEWLINE> <DEDENT> <DEDENT> swap_dict = { v : i for i , v in enumerate ( swap ) } <NEWLINE> min_score_d = 0 <NEWLINE> for l , r in history : <NEWLINE> <INDENT> li , ri = swap_dict [ l ] , swap_dict [ r ] <NEWLINE> if li > ri : <NEWLINE> <INDENT> l , r , li , ri = r , l , ri , li <NEWLINE> <DEDENT> if li < k and k <= ri : <NEWLINE> <INDENT> min_score_d = min ( min_score_d , points [ r ] - points [ l ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( points [ x ] for x in swap [ : k ] ) + min_score_d ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> l = len ( S ) <NEWLINE> mod = [ 0 ] * 2019 <NEWLINE> dp = 0 <NEWLINE> pw = 1 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> mod [ dp % 2019 ] += 1 <NEWLINE> dp = dp + pw * int ( S [ - 1 - i ] ) <NEWLINE> pw = ( pw * 10 ) % 2019 <NEWLINE> <DEDENT> mod [ dp % 2019 ] += 1 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> cnt += ( mod [ i ] * ( mod [ i ] - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
import itertools <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> M_chr = [ ] <NEWLINE> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> M_chr . append ( i ) <NEWLINE> <DEDENT> As = list ( itertools . combinations_with_replacement ( M_chr , N ) ) <NEWLINE> pointA_max = 0 <NEWLINE> for i , A in enumerate ( As ) : <NEWLINE> <INDENT> pointA = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> if A [ abcd [ i ] [ 1 ] - 1 ] - A [ abcd [ i ] [ 0 ] - 1 ] == abcd [ i ] [ 2 ] : <NEWLINE> <INDENT> pointA = pointA + abcd [ i ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if pointA_max < pointA : <NEWLINE> <INDENT> pointA_max = pointA <NEWLINE> <DEDENT> <DEDENT> print ( pointA_max ) <NEWLINE>
import sys <NEWLINE> import os <NEWLINE> import itertools <NEWLINE> import numpy as np <NEWLINE> from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) == <STRING> : <NEWLINE> <INDENT> sys . stdin = open ( os . path . dirname ( __file__ ) + <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> print ( sieve ( N ) ) <NEWLINE> <NL> <DEDENT> def sieve ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> sum = n * ( 2 + n - 1 ) // 2 <NEWLINE> <COMMENT> <NL> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> d = n // i <NEWLINE> <COMMENT> <NL> sum += d * ( ( d + 1 ) * i ) // 2 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> return sum <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> ans = 0 <NEWLINE> if a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = a [ : : - 1 ] <NEWLINE> ans = a [ 0 ] <NEWLINE> for i in a [ 1 : ] : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_sum = sum ( A [ 1 : ] ) <NEWLINE> <NL> tot = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> tot += ( A [ i ] * A_sum ) % ( 10 ** 9 + 7 ) <NEWLINE> tot = tot % ( 10 ** 9 + 7 ) <NEWLINE> A_sum -= A [ i + 1 ] <NEWLINE> <NL> <DEDENT> print ( tot ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> b = 1 <NEWLINE> <NL> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> if a [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> b *= i <NEWLINE> if b > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( b ) <NEWLINE> <NL> <NL>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> C = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> A = deque ( [ ] ) <NEWLINE> for c in C : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> A . popleft ( ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> A . pop ( ) <NEWLINE> <DEDENT> elif <STRING> in c : <NEWLINE> <INDENT> q = int ( c [ 7 : ] ) <NEWLINE> if q in A : <NEWLINE> <INDENT> A . remove ( q ) <NEWLINE> <DEDENT> <DEDENT> elif <STRING> in c : <NEWLINE> <INDENT> q = int ( c [ 7 : ] ) <NEWLINE> A . appendleft ( q ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ai = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> ai . sort ( reverse = True ) <NEWLINE> <NL> if ai [ n - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= ai [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> for i in range ( - 400 , 400 ) : <NEWLINE> <INDENT> for j in range ( - 400 , 400 ) : <NEWLINE> <INDENT> if ( i ** 5 ) - ( j ** 5 ) == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> b = 1 <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1000000000000000000 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( a [ i ] == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) ; <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> b = b * a [ i ] <NEWLINE> if ( b > x ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( b ) ; <NEWLINE>
N = input ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> if N [ 1 : ] == <STRING> * ( len ( N ) - 1 ) : <NEWLINE> <INDENT> ans = int ( N [ 0 ] ) + ( 9 * ( len ( N ) - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = int ( N [ 0 ] ) + 9 * ( len ( N ) - 1 ) - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> if k >= len ( s ) : <NEWLINE> <INDENT> print ( <STRING> . join ( s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> l . append ( s [ i ] ) <NEWLINE> <DEDENT> l . append ( <STRING> ) <NEWLINE> m = <STRING> . join ( l ) <NEWLINE> print ( m ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( tmp , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N == 2 : <NEWLINE> <INDENT> print ( max ( 0 , A [ 0 ] , A [ 1 ] ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if N == 3 : <NEWLINE> <INDENT> print ( max ( 0 , A [ 0 ] , A [ 1 ] , A [ 2 ] ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> dp = [ [ - 10 ** 18 for i in range ( N ) ] for j in range ( 3 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = A [ 0 ] <NEWLINE> dp [ 1 ] [ 1 ] = A [ 1 ] <NEWLINE> dp [ 2 ] [ 2 ] = A [ 2 ] <NEWLINE> <NL> for n in range ( 3 ) : <NEWLINE> <INDENT> for index in range ( N ) : <NEWLINE> <INDENT> if dp [ n ] [ index ] != - 1 : <NEWLINE> <INDENT> if n != 2 and index + 3 < N : <NEWLINE> <INDENT> dp [ n + 1 ] [ index + 3 ] = max ( dp [ n + 1 ] [ index + 3 ] , dp [ n ] [ index ] + A [ index + 3 ] ) <NEWLINE> <DEDENT> if n == 0 and index + 4 < N : <NEWLINE> <INDENT> dp [ n + 2 ] [ index + 4 ] = max ( dp [ n + 2 ] [ index + 4 ] , dp [ n ] [ index ] + A [ index + 4 ] ) <NEWLINE> <DEDENT> if index + 2 < N : <NEWLINE> <INDENT> dp [ n ] [ index + 2 ] = max ( dp [ n ] [ index + 2 ] , dp [ n ] [ index ] + A [ index + 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> a = ( dp [ 0 ] [ - 1 ] ) <NEWLINE> b = ( dp [ 1 ] [ - 1 ] ) <NEWLINE> c = ( dp [ 2 ] [ - 1 ] ) <NEWLINE> <NL> print ( max ( a , b , c ) ) <NEWLINE> <NL> <NL> <NL>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> v = [ 0 ] * n <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if v [ i ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> q = deque ( ) <NEWLINE> q . append ( i ) <NEWLINE> v [ i ] = 1 <NEWLINE> while q : <NEWLINE> <INDENT> node = q . popleft ( ) <NEWLINE> for j in graph [ node ] : <NEWLINE> <INDENT> if v [ j ] == 0 : <NEWLINE> <INDENT> q . append ( j ) <NEWLINE> v [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans - 1 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ( i + 1 ) / 2 for i in p ] <NEWLINE> cans = sum ( s [ : k ] ) <NEWLINE> ans = cans <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> cans = cans - s [ i ] + s [ i + k ] <NEWLINE> ans = max ( ans , cans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def calc_gcd ( x , y ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if y == 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return calc_gcd ( y , x % y ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> data = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> result = calc_gcd ( data [ 0 ] , data [ 1 ] ) <NEWLINE> print ( <STRING> . format ( result ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> class UnionFind : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , n : int ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> self . root = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x : int ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> if self . root [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> self . root [ x ] = self . find ( self . root [ x ] ) <NEWLINE> return self . root [ x ] <NEWLINE> <NL> <DEDENT> def unite ( self , x : int , y : int ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if self . root [ x ] > self . root [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . root [ x ] += self . root [ y ] <NEWLINE> self . root [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def same ( self , x : int , y : int ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def size ( self , x : int ) -> bool : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> return self . root [ self . find ( x ) ] * - 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> lst = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> lst . unite ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = - 1 <NEWLINE> for i in lst . root : <NEWLINE> <INDENT> if i < 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> gcd1 = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> gcd2 = math . gcd ( k , gcd1 ) <NEWLINE> sum += gcd2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
a , b , m = map ( int , input ( ) . split ( ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bl = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> yasuiyo = min ( al ) + min ( bl ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans . append ( al [ x - 1 ] + bl [ y - 1 ] - c ) <NEWLINE> <NL> <DEDENT> print ( min ( min ( ans ) , yasuiyo ) ) <NEWLINE>
import sys <NEWLINE> <NL> readline = sys . stdin . readline <NEWLINE> n , k = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> visited = [ False ] * n <NEWLINE> visited [ 0 ] = True <NEWLINE> l = [ 1 ] <NEWLINE> while True : <NEWLINE> <INDENT> x = A [ l [ - 1 ] - 1 ] <NEWLINE> if visited [ x - 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> l . append ( x ) <NEWLINE> visited [ x - 1 ] = True <NEWLINE> <COMMENT> <NL> <DEDENT> if len ( l ) > k : <NEWLINE> <INDENT> print ( l [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l [ l . index ( x ) : ] [ ( k - l . index ( x ) ) % len ( l [ l . index ( x ) : ] ) ] ) <NEWLINE> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> if X > 0 : <NEWLINE> <INDENT> c , x = divmod ( X , D ) <NEWLINE> if c > K : <NEWLINE> <INDENT> print ( X - D * K ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> elif X < 0 : <NEWLINE> <INDENT> c , x = divmod ( - X , D ) <NEWLINE> if c > K : <NEWLINE> <INDENT> print ( abs ( X + D * K ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( D ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> if ( K - c ) % 2 == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x - D ) ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ 0 ] * n <NEWLINE> A = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C [ i ] , A [ i ] = c [ 0 ] , c [ 1 : ] <NEWLINE> <NL> <DEDENT> INF = 10 ** 9 <NEWLINE> ans = INF <NEWLINE> <NL> for bit in range ( 0 , 1 << n ) : <NEWLINE> <INDENT> cost = 0 <NEWLINE> flag = True <NEWLINE> tmp = [ 0 ] * m <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if bit & 1 << i : <NEWLINE> <INDENT> cost += C [ i ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> tmp [ j ] += A [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if tmp [ i ] < x : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> ans = min ( ans , cost ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 if ans == INF else ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> ans *= x <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if a . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif ans > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> import math <NEWLINE> <NL> ans = 0 <NEWLINE> if N < B : <NEWLINE> <INDENT> end = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> end = B - 1 <NEWLINE> <NL> <DEDENT> x = end <NEWLINE> tmp = math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> <NL> print ( tmp ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> hat = [ 0 , 0 , 0 ] <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> index = 0 <NEWLINE> for j , k in enumerate ( hat ) : <NEWLINE> <INDENT> if k == a [ i ] : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> index = j <NEWLINE> <NL> <DEDENT> <DEDENT> ans = ( ans * tmp ) % mod <NEWLINE> <NL> hat [ index ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
import math <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( B - 1 , N ) <NEWLINE> ans = math . floor ( ( A * x ) / B ) - A * math . floor ( x / B ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import bisect <NEWLINE> from sys import stdin , stdout <NEWLINE> from math import gcd , floor , sqrt , log <NEWLINE> from collections import defaultdict as dd <NEWLINE> from bisect import bisect_left as bl , bisect_right as br <NEWLINE> <NL> sys . setrecursionlimit ( 100000000 ) <NEWLINE> <NL> ii = lambda : int ( input ( ) ) <NEWLINE> si = lambda : input ( ) <NEWLINE> jn = lambda x , l : x . join ( map ( str , l ) ) <NEWLINE> sl = lambda : list ( map ( str , input ( ) . strip ( ) ) ) <NEWLINE> mi = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> mif = lambda : map ( float , input ( ) . split ( ) ) <NEWLINE> lii = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ceil = lambda x : int ( x ) if ( x == int ( x ) ) else int ( x ) + 1 <NEWLINE> ceildiv = lambda x , d : x // d if ( x % d == 0 ) else x // d + 1 <NEWLINE> <NL> flush = lambda : stdout . flush ( ) <NEWLINE> stdstr = lambda : stdin . readline ( ) <NEWLINE> stdint = lambda : int ( stdin . readline ( ) ) <NEWLINE> stdpr = lambda x : stdout . write ( str ( x ) ) <NEWLINE> <NL> mod = 1000000007 <NEWLINE> <NL> <NL> <COMMENT> <NL> def findProductSum ( A , n ) : <NEWLINE> <INDENT> array_sum = 0 <NEWLINE> for i in range ( 0 , n , 1 ) : <NEWLINE> <INDENT> array_sum = array_sum + A [ i ] <NEWLINE> <DEDENT> array_sum_square = array_sum * array_sum <NEWLINE> individual_square_sum = 0 <NEWLINE> for i in range ( 0 , n , 1 ) : <NEWLINE> <INDENT> individual_square_sum += A [ i ] * A [ i ] <NEWLINE> <DEDENT> return ( array_sum_square - <NEWLINE> <INDENT> individual_square_sum ) // 2 <NEWLINE> <DEDENT> <DEDENT> n = ii ( ) <NEWLINE> arr = lii ( ) <NEWLINE> print ( findProductSum ( arr , n ) % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> table = [ True for _ in range ( 2 * ( 10 ** 6 ) ) ] <NEWLINE> a . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if table [ a [ i ] ] : <NEWLINE> <INDENT> for j in range ( a [ i ] , 2 * ( 10 ** 6 ) , a [ i ] ) : <NEWLINE> <INDENT> table [ j ] = False <NEWLINE> <DEDENT> if i + 1 < n : <NEWLINE> <INDENT> if a [ i + 1 ] != a [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> elif i + 1 == n : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ij = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( l , ij ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ i for i in range ( N + 1 ) ] <NEWLINE> size = [ 1 for i in range ( N + 1 ) ] <NEWLINE> <NL> def find ( a ) : <NEWLINE> <INDENT> if a == P [ a ] : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return find ( P [ a ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( b , c ) : <NEWLINE> <INDENT> B = find ( b ) <NEWLINE> C = find ( c ) <NEWLINE> if size [ B ] < size [ C ] : <NEWLINE> <INDENT> P [ B ] = P [ C ] <NEWLINE> size [ C ] += size [ B ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P [ C ] = P [ B ] <NEWLINE> size [ B ] += size [ C ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if find ( a ) == find ( b ) : <NEWLINE> <INDENT> P [ a ] = find ( a ) <NEWLINE> P [ b ] = find ( b ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> union ( a , b ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> P [ i ] = find ( P [ i ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> D = { } <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if P [ i ] not in D : <NEWLINE> <INDENT> D [ P [ i ] ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D [ P [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k , v in D . items ( ) : <NEWLINE> <INDENT> if ans < v : <NEWLINE> <INDENT> ans = v <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> LineData = np . int64 ( sys . stdin . buffer . read ( ) . split ( ) ) <NEWLINE> <NL> INF = 10 ** 9 + 1 <NEWLINE> <NL> LineData = LineData . reshape ( - 1 , 3 ) <NEWLINE> A , B , C = LineData [ : N ] . T <NEWLINE> D , E , F = LineData [ N : ] . T <NEWLINE> X = np . unique ( np . concatenate ( [ D , [ - INF , INF ] ] ) ) <NEWLINE> Y = np . unique ( np . concatenate ( [ C , [ - INF , INF ] ] ) ) <NEWLINE> A = np . searchsorted ( X , A ) <NEWLINE> B = np . searchsorted ( X , B , <STRING> ) - 1 <NEWLINE> C = np . searchsorted ( Y , C ) <NEWLINE> D = np . searchsorted ( X , D ) <NEWLINE> E = np . searchsorted ( Y , E ) <NEWLINE> F = np . searchsorted ( Y , F , <STRING> ) - 1 <NEWLINE> <NL> area = cal_area ( A , B , C , D , E , F , X , Y ) <NEWLINE> <NL> if area == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( area ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def cal_area ( A , B , C , D , E , F , X , Y ) : <NEWLINE> <INDENT> x = np . searchsorted ( X , 0 , <STRING> ) - 1 <NEWLINE> y = np . searchsorted ( Y , 0 , <STRING> ) - 1 <NEWLINE> <NL> DX = X [ 1 : ] - X [ : - 1 ] <NEWLINE> DY = Y [ 1 : ] - Y [ : - 1 ] <NEWLINE> <NL> A = A . tolist ( ) <NEWLINE> B = B . tolist ( ) <NEWLINE> C = C . tolist ( ) <NEWLINE> D = D . tolist ( ) <NEWLINE> E = E . tolist ( ) <NEWLINE> F = F . tolist ( ) <NEWLINE> X = X . tolist ( ) <NEWLINE> Y = Y . tolist ( ) <NEWLINE> DX = DX . tolist ( ) <NEWLINE> DY = DY . tolist ( ) <NEWLINE> <NL> LenX = len ( X ) <NEWLINE> LenY = len ( Y ) <NEWLINE> <NL> visit = [ [ False ] * LenY for _ in range ( LenX ) ] <NEWLINE> visit [ x ] [ y ] = True <NEWLINE> area = 0 <NEWLINE> queue = [ ( x , y ) ] <NEWLINE> <NL> LineX = [ [ False ] * LenY for _ in range ( LenX ) ] <NEWLINE> LineY = [ [ False ] * LenY for _ in range ( LenX ) ] <NEWLINE> <NL> for x1 , x2 , y in zip ( A , B , C ) : <NEWLINE> <INDENT> for x in range ( x1 , x2 ) : <NEWLINE> <INDENT> LineY [ x ] [ y ] = True <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for x , y1 , y2 in zip ( D , E , F ) : <NEWLINE> <INDENT> for y in range ( y1 , y2 ) : <NEWLINE> <INDENT> LineX [ x ] [ y ] = True <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> LenX -= 1 <NEWLINE> LenY -= 1 <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> x , y = queue . pop ( ) <NEWLINE> <NL> if x == 0 or x == LenX or y == 0 or y == LenY : <NEWLINE> <INDENT> area = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> area += DX [ x ] * DY [ y ] <NEWLINE> <NL> x1 = x - 1 <NEWLINE> if not LineX [ x ] [ y ] and not visit [ x1 ] [ y ] : <NEWLINE> <INDENT> visit [ x1 ] [ y ] = True <NEWLINE> queue . append ( ( x1 , y ) ) <NEWLINE> <DEDENT> y1 = y - 1 <NEWLINE> if not LineY [ x ] [ y ] and not visit [ x ] [ y1 ] : <NEWLINE> <INDENT> visit [ x ] [ y1 ] = True <NEWLINE> queue . append ( ( x , y1 ) ) <NEWLINE> <DEDENT> x1 = x + 1 <NEWLINE> if not LineX [ x1 ] [ y ] and not visit [ x1 ] [ y ] : <NEWLINE> <INDENT> visit [ x1 ] [ y ] = True <NEWLINE> queue . append ( ( x1 , y ) ) <NEWLINE> <DEDENT> y1 = y + 1 <NEWLINE> if not LineY [ x ] [ y1 ] and not visit [ x ] [ y1 ] : <NEWLINE> <INDENT> visit [ x ] [ y1 ] = True <NEWLINE> queue . append ( ( x , y1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> return area <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT> sys . exit ( ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> count = 0 <NEWLINE> for n in range ( K , N + 2 ) : <NEWLINE> <INDENT> maxSum = ( n * ( N + N - n + 1 ) ) // 2 <NEWLINE> minSum = ( n * ( n - 1 ) ) // 2 <NEWLINE> count += maxSum - minSum + 1 <NEWLINE> count %= mod <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
notice = int ( input ( ) ) <NEWLINE> record = [ [ [ 0 ] * 10 for i in range ( 3 ) ] for j in range ( 4 ) ] <NEWLINE> <NL> for _ in range ( notice ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> record [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> ans = ( <STRING> + <STRING> * 20 + <STRING> ) . join ( [ <STRING> . join ( [ <STRING> + <STRING> . join ( map ( str , floor ) ) for floor in building ] ) for building in record ] ) <NEWLINE> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> def div ( n ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> y = int ( n / i ) <NEWLINE> a += y * ( y + 1 ) * i / 2 <NEWLINE> <DEDENT> return int ( a ) <NEWLINE> <DEDENT> print ( div ( n ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> N , A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> A , B , C , D = A - 1 , B - 1 , C - 1 , D - 1 <NEWLINE> <NL> <COMMENT> <NL> if B == 1 : <NEWLINE> <INDENT> a = S . find ( <STRING> ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = S . find ( <STRING> , 3 ) + 1 <NEWLINE> <NL> <DEDENT> dx = [ 1 , 2 ] <NEWLINE> <NL> <COMMENT> <NL> def dfs_ini ( v , seen_ini , X ) : <NEWLINE> <INDENT> seen_ini [ v ] = True <COMMENT> <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> next_v = v + dx [ i ] <NEWLINE> <COMMENT> <NL> if not ( - 1 < next_v < N ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( S [ next_v ] == <STRING> ) or ( next_v == X ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if seen_ini [ next_v ] == True : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs_ini ( next_v , seen_ini , X ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def dfs_fin ( w , seen_fin , Y ) : <NEWLINE> <INDENT> seen_fin [ w ] = True <COMMENT> <NEWLINE> for j in range ( 2 ) : <NEWLINE> <INDENT> next_w = w + dx [ j ] <NEWLINE> <COMMENT> <NL> if not ( - 1 < next_w < N ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( S [ next_w ] == <STRING> ) or ( next_w == Y ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if seen_fin [ next_w ] == True : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs_fin ( next_w , seen_fin , Y ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if C > D : <NEWLINE> <INDENT> seen_ini_A = [ False ] * N <NEWLINE> seen_fin_B = [ False ] * N <NEWLINE> <COMMENT> <NL> if ( a < B ) or ( a > D ) : <NEWLINE> <INDENT> a = B <NEWLINE> <DEDENT> dfs_ini ( A , seen_ini_A , a ) <NEWLINE> dfs_fin ( B , seen_fin_B , C ) <NEWLINE> result = <STRING> <NEWLINE> if seen_ini_A [ C ] and seen_fin_B [ D ] : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> seen_ini_B = [ False ] * N <NEWLINE> seen_fin_A = [ False ] * N <NEWLINE> dfs_ini ( B , seen_ini_B , A ) <NEWLINE> dfs_fin ( A , seen_fin_A , D ) <NEWLINE> result = <STRING> <NEWLINE> if seen_ini_B [ D ] and seen_fin_A [ C ] : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> result = 1 <NEWLINE> for value in s : <NEWLINE> <INDENT> result *= value <NEWLINE> if result > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst = set ( ) <NEWLINE> c = collections . Counter ( A ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if ( c [ i ] != 0 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> def cross ( p1 , p2 , q1 , q2 ) : <NEWLINE> <INDENT> p = p2 - p1 <NEWLINE> q = q2 - q1 <NEWLINE> return p . real * q . imag - p . imag * q . real <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> er = 1e-16 <NEWLINE> <NL> def convex_diameter ( points , n ) : <NEWLINE> <INDENT> points . append ( points [ 0 ] ) <NEWLINE> p0 = points [ 0 ] <NEWLINE> p1 = points [ 1 ] <NEWLINE> for i , ( q1 , q2 ) in enumerate ( zip ( points [ 1 : ] , points [ 2 : ] ) , start = 1 ) : <NEWLINE> <INDENT> if cross ( p0 , p1 , q1 , q2 ) < - er : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> max_d = abs ( points [ i ] - points [ 0 ] ) <NEWLINE> <NL> points . append ( points [ 1 ] ) <NEWLINE> side1 = zip ( points [ 0 : i + 1 ] , points [ 1 : i + 2 ] ) <NEWLINE> side2 = zip ( points [ i : n + 1 ] , points [ i + 1 : ] ) <NEWLINE> p1 , p2 = side1 . __next__ ( ) <NEWLINE> q1 , q2 = side2 . __next__ ( ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if cross ( p1 , p2 , q1 , q2 ) > er : <NEWLINE> <INDENT> q1 , q2 = side2 . __next__ ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p1 , p2 = side1 . __next__ ( ) <NEWLINE> <DEDENT> max_d = max ( max_d , abs ( p1 - q1 ) ) <NEWLINE> <NL> <DEDENT> return max_d <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def string_to_complex ( s ) : <NEWLINE> <INDENT> x , y = map ( float , s . split ( ) ) <NEWLINE> return x + y * 1j <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> <NL> file_input = sys . stdin <NEWLINE> <NL> n = int ( file_input . readline ( ) ) <NEWLINE> <NL> P = [ string_to_complex ( line ) for line in file_input ] <NEWLINE> <NL> <COMMENT> <NL> ans = convex_diameter ( P , n ) <NEWLINE> print ( <STRING> . format ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> res = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> res = res * i <NEWLINE> res = res % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
<NL> import sys <NEWLINE> from bisect import bisect_left , bisect , bisect_right <NEWLINE> <NL> icase = 0 <NEWLINE> if icase == 0 : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = [ ] <NEWLINE> cb = [ [ 0 ] * 2 for i in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> bi , ci = map ( int , input ( ) . split ( ) ) <NEWLINE> cb [ i ] = [ ci , bi ] <NEWLINE> <DEDENT> <DEDENT> elif icase == 2 : <NEWLINE> <INDENT> n , m = 10 , 3 <NEWLINE> a = [ 1 , 4 , 5 , 5 , 7 , 8 , 13 , 33 , 52 , 100 ] <NEWLINE> cb = [ [ 30 , 4 ] , [ 10 , 3 ] , [ 4 , 1 ] ] <NEWLINE> <NL> <DEDENT> a . sort ( ) <NEWLINE> cb . sort ( reverse = True ) <NEWLINE> <NL> asum = 0 <NEWLINE> isum = 0 <NEWLINE> isumm = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> isum += cb [ i ] [ 1 ] <NEWLINE> if isum > n : <NEWLINE> <INDENT> if a [ n - 1 ] <= cb [ i ] [ 0 ] : <NEWLINE> <INDENT> asum += cb [ i ] [ 0 ] * ( n - isumm ) <NEWLINE> print ( asum ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ii = bisect_right ( a , cb [ i ] [ 0 ] ) <NEWLINE> asum += cb [ i ] [ 0 ] * ( ii - isumm ) <NEWLINE> asum += sum ( a [ ii : ] ) <NEWLINE> print ( asum ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> if a [ isum - 1 ] <= cb [ i ] [ 0 ] : <NEWLINE> <INDENT> asum += cb [ i ] [ 0 ] * cb [ i ] [ 1 ] <NEWLINE> isumm = isum <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ii = bisect_right ( a , cb [ i ] [ 0 ] ) <NEWLINE> asum += cb [ i ] [ 0 ] * ( ii - isumm ) <NEWLINE> asum += sum ( a [ ii : ] ) <NEWLINE> print ( asum ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> asum += sum ( a [ isum : ] ) <NEWLINE> <NL> print ( asum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> dictionary = set ( ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> cmd , arg = input ( ) . split ( ) <NEWLINE> if cmd == <STRING> : <NEWLINE> <INDENT> dictionary . add ( arg ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> if arg in dictionary : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> m_list = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> if m_list and i == m_list [ 0 ] : <NEWLINE> <INDENT> m_list . pop ( 0 ) <NEWLINE> dp [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> elif m_list and i == m_list [ 0 ] : <NEWLINE> <INDENT> m_list . pop ( 0 ) <NEWLINE> dp [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % 1000000007 <NEWLINE> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n : int ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . n = n <NEWLINE> <STRING> <NEWLINE> self . d = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x : int ) -> int : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . d [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . d [ x ] = self . find ( self . d [ x ] ) <NEWLINE> return self . d [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x : int , y : int ) -> bool : <NEWLINE> <INDENT> <STRING> <NEWLINE> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> if self . d [ x ] > self . d [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . d [ x ] += self . d [ y ] <NEWLINE> self . d [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def same ( self , x : int , y : int ) -> bool : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def size ( self , x : int ) -> int : <NEWLINE> <INDENT> <STRING> <NEWLINE> return - self . d [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def members ( self , x : int ) -> list : <NEWLINE> <INDENT> <STRING> <NEWLINE> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def groups ( self ) -> list : <NEWLINE> <INDENT> <STRING> <NEWLINE> return [ i for i , x in enumerate ( self . d ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) -> int : <NEWLINE> <INDENT> <STRING> <NEWLINE> return len ( self . groups ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> uf = UnionFind ( N ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . unite ( A - 1 , B - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in uf . groups ( ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
ok = True <NEWLINE> i = 0 <NEWLINE> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> k = c // b <NEWLINE> c -= b * k <NEWLINE> a -= d * ( k ) <NEWLINE> if ( a <= 0 and c != 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> <COMMENT> <NL> counts = [ 0 ] * 2019 <NEWLINE> n , d = 0 , 1 <NEWLINE> <NL> for s in S [ : : - 1 ] : <NEWLINE> <INDENT> n += int ( s ) * d <NEWLINE> d *= 10 <NEWLINE> n %= 2019 <NEWLINE> d %= 2019 <NEWLINE> counts [ n ] += 1 <NEWLINE> <DEDENT> ans = counts [ 0 ] <NEWLINE> for count in counts : <NEWLINE> <INDENT> ans += count * ( count - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> num = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> <NL> number = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> number . append ( i + 1 ) <NEWLINE> <DEDENT> a = list ( itertools . combinations_with_replacement ( number , n ) ) <NEWLINE> length = len ( a ) <NEWLINE> memo = [ 0 ] * length <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( length ) : <COMMENT> <NEWLINE> <INDENT> sum = 0 <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> if a [ i ] [ num [ j ] [ 1 ] - 1 ] - a [ i ] [ num [ j ] [ 0 ] - 1 ] == num [ j ] [ 2 ] : <NEWLINE> <INDENT> sum += num [ j ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( sum , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> <NL> h = s // 3600 <NEWLINE> s -= h * 3600 <NEWLINE> m = s // 60 <NEWLINE> s -= m * 60 <NEWLINE> <NL> print ( h , m , s , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> def Dijkestra ( G , n ) : <NEWLINE> <INDENT> d = [ 100000000000 ] * n <NEWLINE> pi = [ None ] * n <NEWLINE> d [ 0 ] = 0 <NEWLINE> C = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> C . append ( i ) <NEWLINE> <NL> <DEDENT> while len ( C ) != 0 : <NEWLINE> <INDENT> u = C [ 0 ] <NEWLINE> for i in range ( 1 , len ( C ) ) : <NEWLINE> <INDENT> if d [ u ] > d [ C [ i ] ] : <NEWLINE> <INDENT> u = C [ i ] <NEWLINE> <DEDENT> <DEDENT> C . remove ( u ) <NEWLINE> for i in range ( len ( G [ u ] ) ) : <NEWLINE> <INDENT> if G [ u ] [ i ] == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif d [ i ] > d [ u ] + G [ u ] [ i ] : <NEWLINE> <INDENT> d [ i ] = d [ u ] + G [ u ] [ i ] <NEWLINE> pi [ i ] = u <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( i , d [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> G = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> ele = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = ele [ 1 ] <NEWLINE> t = ele [ 2 : ] <NEWLINE> v = c = [ ] <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> v = v + [ t [ 2 * j ] ] <NEWLINE> c = c + [ t [ 2 * j + 1 ] ] <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> if j in v : <NEWLINE> <INDENT> a . append ( c [ v . index ( j ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> G . append ( a ) <NEWLINE> <DEDENT> Dijkestra ( G , n ) <NEWLINE> <DEDENT>
s = input ( ) [ : : - 1 ] <NEWLINE> ans = 0 <NEWLINE> u = 0 <NEWLINE> d = 1 <NEWLINE> l = [ 0 ] * 2019 <NEWLINE> l [ 0 ] = 1 <NEWLINE> for i in map ( int , s ) : <NEWLINE> <INDENT> u = ( u + i * d ) % 2019 <NEWLINE> l [ u ] += 1 <NEWLINE> d = d * 10 % 2019 <NEWLINE> <DEDENT> for i in l : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> K = int ( input ( ) ) <NEWLINE> lun = deque ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] ) <NEWLINE> for i in range ( K - 1 ) : <NEWLINE> <INDENT> x = lun . popleft ( ) <NEWLINE> if x % 10 > 0 : <NEWLINE> <INDENT> lun . append ( 10 * x + x % 10 - 1 ) <NEWLINE> <DEDENT> lun . append ( 10 * x + x % 10 ) <NEWLINE> if x % 10 < 9 : <NEWLINE> <INDENT> lun . append ( 10 * x + x % 10 + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( lun . popleft ( ) ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> def index ( a , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> i = bisect_left ( a , x ) <NEWLINE> if i != len ( a ) and a [ i ] == x : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> raise ValueError <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> num = int ( input ( ) ) <NEWLINE> S = tuple ( int ( x ) for x in input ( ) . split ( <STRING> ) ) <NEWLINE> num = int ( input ( ) ) <NEWLINE> T = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> <COMMENT> <NL> found = 0 <NEWLINE> for t in T : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> index ( S , t ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> found += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( found ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> bomb = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> H_bomb = [ 0 ] * ( H + 1 ) <NEWLINE> W_bomb = [ 0 ] * ( W + 1 ) <NEWLINE> for b in bomb : <NEWLINE> <INDENT> H_bomb [ b [ 0 ] ] += 1 <NEWLINE> W_bomb [ b [ 1 ] ] += 1 <NEWLINE> <DEDENT> max_h , max_w = max ( H_bomb ) , max ( W_bomb ) <NEWLINE> cnt = H_bomb . count ( max_h ) * W_bomb . count ( max_w ) <NEWLINE> for b in bomb : <NEWLINE> <INDENT> if H_bomb [ b [ 0 ] ] == max_h and W_bomb [ b [ 1 ] ] == max_w : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( max_h + max_w + bool ( cnt ) - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> c = <STRING> <NEWLINE> while ( a > 26 ) : <NEWLINE> <INDENT> b = int ( a ) % 26 <NEWLINE> c += chr ( ord ( <STRING> ) + ( 25 if b == 0 else int ( b ) - 1 ) ) <NEWLINE> a = int ( a / 26 - 1 if a % 26 == 0 else a / 26 ) <NEWLINE> <DEDENT> c += chr ( ord ( <STRING> ) + int ( a ) - 1 ) <NEWLINE> print ( c [ : : - 1 ] ) <NEWLINE>
<NL> n1 , n2 , n3 = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> list1 = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for _ in range ( n1 ) ] <NEWLINE> list2 = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for _ in range ( n2 ) ] <NEWLINE> <NL> mat = [ [ 0 for _ in range ( n3 ) ] for _ in range ( n1 ) ] <NEWLINE> for i in range ( n1 ) : <NEWLINE> <INDENT> for j in range ( n2 ) : <NEWLINE> <INDENT> for k in range ( n3 ) : <NEWLINE> <INDENT> mat [ i ] [ k ] += list1 [ i ] [ j ] * list2 [ j ] [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for m in mat : <NEWLINE> <INDENT> print ( * m ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> def solver ( n ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> y = math . floor ( n / i ) <NEWLINE> sum += ( i * y * ( y + 1 ) / 2 ) <NEWLINE> <DEDENT> return int ( sum ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( solver ( n ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = True <NEWLINE> prd = 1 <NEWLINE> A . sort ( reverse = True ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> prd *= A [ i ] <NEWLINE> if prd > 10 ** 18 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( prd ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> <NL> words = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> ans = <STRING> <NEWLINE> <NL> pointer = len ( s ) <NEWLINE> while pointer > 0 : <NEWLINE> <INDENT> if s [ pointer - 5 : pointer ] == list ( words [ 0 ] ) : <NEWLINE> <INDENT> pointer -= 5 <NEWLINE> <DEDENT> elif s [ pointer - 5 : pointer ] == list ( words [ 2 ] ) : <NEWLINE> <INDENT> pointer -= 5 <NEWLINE> <DEDENT> elif s [ pointer - 7 : pointer ] == list ( words [ 1 ] ) : <NEWLINE> <INDENT> pointer -= 7 <NEWLINE> <DEDENT> elif s [ pointer - 6 : pointer ] == list ( words [ 3 ] ) : <NEWLINE> <INDENT> pointer -= 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> area = math . pi * r ** 2 <NEWLINE> circum = 2 * math . pi * r <NEWLINE> print ( <STRING> . format ( area , circum ) ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <INDENT> A , B , N = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> mini = 0 <NEWLINE> if N >= B : <NEWLINE> <INDENT> ans = int ( A * ( B - 1 ) / B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = int ( A * ( N ) / B ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from functools import reduce <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> if A [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = 1 ; <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> p *= A [ i ] ; <NEWLINE> if p > 10 ** 18 : <NEWLINE> <INDENT> p = - 1 ; <NEWLINE> break ; <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE> <DEDENT>
c = [ ] <NEWLINE> for i in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for j in range ( 1 , 14 ) : <NEWLINE> <INDENT> c . append ( <STRING> . format ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <DEDENT> d = [ i for i in c if i not in a ] <NEWLINE> if len ( d ) != 0 : <NEWLINE> <INDENT> print ( * d , sep = <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> from collections import Counter <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> c = Counter ( a ) <NEWLINE> print ( sum ( sorted ( c . values ( ) , reverse = True ) [ k : len ( c ) ] ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import string <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> alphabet = list ( string . ascii_lowercase ) <NEWLINE> num2alphabet = { i + 1 : a for i , a in enumerate ( alphabet ) } <NEWLINE> num2alphabet [ 0 ] = <STRING> <NEWLINE> ans = <STRING> <NEWLINE> <NL> while N > 0 : <NEWLINE> <INDENT> num = N % 26 <NEWLINE> ans += num2alphabet [ num ] <NEWLINE> if N <= 26 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if num == 0 : <NEWLINE> <INDENT> N -= 1 <NEWLINE> <NL> <DEDENT> N = N // 26 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( list ( reversed ( ans ) ) ) ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> from sys import stdin <NEWLINE> from collections import defaultdict <NEWLINE> input = stdin . readline <NEWLINE> <NL> <NL> def main ( args ) : <NEWLINE> <INDENT> lut = defaultdict ( int ) <NEWLINE> for a in range ( 1001 ) : <NEWLINE> <INDENT> for b in range ( 1001 ) : <NEWLINE> <INDENT> lut [ a + b ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> n = int ( line ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> ans += lut [ i ] * lut [ n - i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ - 1 ] * N <NEWLINE> <NL> <COMMENT> <NL> def rec ( i ) : <NEWLINE> <INDENT> if dp [ i ] >= 0 : <NEWLINE> <INDENT> return dp [ i ] <NEWLINE> <NL> <DEDENT> res = - 1 <NEWLINE> if i == N - 1 : <NEWLINE> <INDENT> res = 0 <NEWLINE> <DEDENT> elif i == N - 2 : <NEWLINE> <INDENT> res = rec ( i + 1 ) + abs ( h [ i + 1 ] - h [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = min ( rec ( i + 1 ) + abs ( h [ i + 1 ] - h [ i ] ) , rec ( i + 2 ) + abs ( h [ i + 2 ] - h [ i ] ) ) <NEWLINE> <NL> <DEDENT> dp [ i ] = res <NEWLINE> return dp [ i ] <NEWLINE> <NL> <DEDENT> print ( rec ( 0 ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import sys , math , os <NEWLINE> <NL> <COMMENT> <NL> PYDEV = os . environ . get ( <STRING> ) <NEWLINE> if PYDEV == <STRING> : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def third_root ( q ) : <NEWLINE> <INDENT> x = q / 2 <NEWLINE> while abs ( x ** 3 - q ) >= 1e-5 * q : <NEWLINE> <INDENT> x = x - ( x ** 3 - q ) / ( 3 * x ** 2 ) <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <NL> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> n = int ( line ) <NEWLINE> if n == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> % third_root ( n ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> cnt = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> sumA = sum ( A ) <NEWLINE> for a in A : <NEWLINE> <INDENT> cnt [ a ] += 1 <NEWLINE> <NL> <DEDENT> for query in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> sumA += cnt [ b ] * ( c - b ) <NEWLINE> cnt [ c ] += cnt [ b ] <NEWLINE> cnt [ b ] = 0 <NEWLINE> print ( sumA ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> t = 0 <NEWLINE> for i1 in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for i2 in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for i3 in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> t += gcd ( gcd ( i1 , i2 ) , i3 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> limit = max ( A ) + 1 <NEWLINE> <NL> dp = [ True ] * ( limit + 1 ) <NEWLINE> d = { } <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> p = 2 <NEWLINE> while i * p <= limit : <NEWLINE> <INDENT> dp [ i * p ] = False <NEWLINE> p += 1 <NEWLINE> <DEDENT> d . setdefault ( i , 0 ) <NEWLINE> d [ i ] += 1 <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for i in A : <NEWLINE> <INDENT> if dp [ i ] and d [ i ] == 1 : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> print ( S ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif n // i == n / i : <NEWLINE> <INDENT> x += ( n // i ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x += n // i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( a , b ) : <NEWLINE> <INDENT> a = find ( a ) <NEWLINE> b = find ( b ) <NEWLINE> if a == b : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if rank [ a ] < rank [ b ] : <NEWLINE> <INDENT> par [ a ] = b <NEWLINE> rank [ b ] += rank [ a ] <NEWLINE> rank [ a ] = rank [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ b ] = a <NEWLINE> rank [ a ] += rank [ b ] <NEWLINE> rank [ b ] = rank [ a ] <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <DEDENT> def chk ( a , b ) : <NEWLINE> <INDENT> if par [ a ] == par [ b ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> par = ( list ( range ( N + 1 ) ) ) <NEWLINE> rank = [ 1 ] * ( N + 1 ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> union ( A , B ) <NEWLINE> <NL> <DEDENT> print ( max ( rank ) ) <NEWLINE>
import bisect <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> da = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> da [ i + 1 ] = da [ i ] + a [ i ] <NEWLINE> <DEDENT> db = [ 0 for _ in range ( M + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> db [ i + 1 ] = db [ i ] + b [ i ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if da [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = max ( ans , i + bisect . bisect_right ( db , K - da [ i ] ) - 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> from math import gcd <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans = ans + gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp = 2 * y - x <NEWLINE> if tmp % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> up = tmp // 3 <NEWLINE> total = y - up * 2 + up <NEWLINE> <NL> n = total <NEWLINE> k = up <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if k == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> modinv_table = [ - 1 ] * ( k + 1 ) <NEWLINE> modinv_table [ 1 ] = 1 <NEWLINE> for i in range ( 2 , k + 1 ) : <NEWLINE> <INDENT> modinv_table [ i ] = ( - modinv_table [ mod % i ] * ( mod // i ) ) % mod <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> k = total - up <NEWLINE> modinv_table = [ - 1 ] * ( k + 1 ) <NEWLINE> modinv_table [ 1 ] = 1 <NEWLINE> for i in range ( 2 , k + 1 ) : <NEWLINE> <INDENT> modinv_table [ i ] = ( - modinv_table [ mod % i ] * ( mod // i ) ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> def binomial_coefficients ( n , k ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= n - i <NEWLINE> ans *= modinv_table [ i + 1 ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> print ( binomial_coefficients ( n , k ) ) <NEWLINE>
import math <NEWLINE> from collections import defaultdict <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> res . append ( 2 ) <NEWLINE> <DEDENT> for i in range ( 3 , math . floor ( n // 2 ) + 1 , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in res : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <DEDENT> def fact2 ( n ) : <NEWLINE> <INDENT> p = factorization ( n ) <NEWLINE> res = [ ] <NEWLINE> for i in p : <NEWLINE> <INDENT> c = 0 <NEWLINE> z = n <NEWLINE> while 1 : <NEWLINE> <INDENT> if z % i == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> z /= i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> res . append ( [ i , c ] ) <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> def pop2 ( li ) : <NEWLINE> <INDENT> c = 1 <NEWLINE> i = li . pop ( 0 ) <NEWLINE> while 1 : <NEWLINE> <INDENT> j = li . pop ( 0 ) <NEWLINE> if j == i : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return i , c , [ j ] + li <NEWLINE> <NL> <DEDENT> n = readInt ( ) <NEWLINE> a = readInts ( ) <NEWLINE> <NL> li = [ ] <NEWLINE> ri = [ ] <NEWLINE> <NL> d1 = defaultdict ( int ) <NEWLINE> d2 = defaultdict ( int ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> d1 [ i + a [ i ] ] += 1 <NEWLINE> d2 [ i - a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for key in d1 : <NEWLINE> <INDENT> ans += d1 [ key ] * d2 [ key ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> from itertools import combinations <NEWLINE> from bisect import bisect <NEWLINE> from heapq import heappush , heappop <NEWLINE> file_input = sys . stdin <NEWLINE> inf = float ( <STRING> ) <NEWLINE> while True : <NEWLINE> <INDENT> n , m , c , s , g = map ( int , file_input . readline ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> adj_matrices = [ [ [ inf ] * n for j in range ( n ) ] for i in range ( c ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> x , y , d , c = map ( int , file_input . readline ( ) . split ( ) ) <NEWLINE> mat = adj_matrices [ c - 1 ] <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> pre_d = mat [ x ] [ y ] <NEWLINE> if d < pre_d : <NEWLINE> <INDENT> mat [ x ] [ y ] = d <NEWLINE> mat [ y ] [ x ] = d <NEWLINE> <NL> <DEDENT> <DEDENT> p = file_input . readline ( ) <NEWLINE> <NL> <COMMENT> <NL> adj_matrix = [ [ inf ] * n for i in range ( n ) ] <NEWLINE> <NL> for mat in adj_matrices : <NEWLINE> <COMMENT> <NL> <INDENT> for k in range ( n ) : <NEWLINE> <INDENT> for x , y in combinations ( range ( n ) , 2 ) : <NEWLINE> <INDENT> d1 = mat [ x ] [ y ] <NEWLINE> d2 = mat [ x ] [ k ] + mat [ k ] [ y ] <NEWLINE> if d2 < d1 : <NEWLINE> <INDENT> mat [ x ] [ y ] = d2 <NEWLINE> mat [ y ] [ x ] = d2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> q = list ( map ( int , file_input . readline ( ) . split ( ) ) ) <NEWLINE> r = list ( map ( int , file_input . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> for x , y in combinations ( range ( n ) , 2 ) : <NEWLINE> <INDENT> d = mat [ x ] [ y ] <NEWLINE> if d != inf : <NEWLINE> <INDENT> idx = bisect ( q , d ) <NEWLINE> fare = 0 <NEWLINE> pre_sd = 0 <NEWLINE> for sd , f in zip ( q [ : idx ] , r ) : <NEWLINE> <INDENT> fare += f * ( sd - pre_sd ) <NEWLINE> pre_sd = sd <NEWLINE> <DEDENT> fare += r [ idx ] * ( d - pre_sd ) <NEWLINE> if fare < adj_matrix [ x ] [ y ] : <NEWLINE> <INDENT> adj_matrix [ x ] [ y ] = fare <NEWLINE> adj_matrix [ y ] [ x ] = fare <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> s -= 1 <NEWLINE> g -= 1 <NEWLINE> fare = [ inf ] * n <NEWLINE> fare [ s ] = 0 <NEWLINE> pq = [ ( 0 , s ) ] <NEWLINE> while pq : <NEWLINE> <INDENT> u_fare , u = heappop ( pq ) <NEWLINE> <NL> if u == g : <NEWLINE> <INDENT> print ( u_fare ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> for v , f in enumerate ( adj_matrix [ u ] ) : <NEWLINE> <INDENT> new_fare = u_fare + f <NEWLINE> if new_fare < fare [ v ] : <NEWLINE> <INDENT> fare [ v ] = new_fare <NEWLINE> heappush ( pq , ( new_fare , v ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if <STRING> in str ( i ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL>
input ( ) <NEWLINE> s = 1 <NEWLINE> for a in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> if a == 0 : s = 0 ; break <NEWLINE> if s > 0 : s *= a <NEWLINE> if s > 1e18 : s = - 1 <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> C = input ( ) <NEWLINE> <NL> flag_left = 0 <NEWLINE> flag_right = N - 1 <NEWLINE> counter = 0 <NEWLINE> <NL> ok = max ( C . count ( <STRING> ) , C . count ( <STRING> ) ) <NEWLINE> if ok == N : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> while flag_left < flag_right : <NEWLINE> <INDENT> while C [ flag_left ] == <STRING> : <NEWLINE> <INDENT> flag_left += 1 <NEWLINE> if flag_left > N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> while C [ flag_right ] == <STRING> : <NEWLINE> <INDENT> flag_right -= 1 <NEWLINE> if flag_left < 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag_left < flag_right : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> flag_left += 1 <NEWLINE> flag_right -= 1 <NEWLINE> <DEDENT> print ( counter ) <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> print ( <STRING> . format ( math . pi * r * r , 2 * math . pi * r ) ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> res = 0 <NEWLINE> if N < B : <NEWLINE> <INDENT> res = ( A * N ) // B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = B - 1 <NEWLINE> right = 10 ** 15 <NEWLINE> while right - left > 1 : <NEWLINE> <INDENT> mid = ( right + left ) // 2 <NEWLINE> a = ( ( A * mid ) // B ) - ( A * ( mid // B ) ) <NEWLINE> if res > a : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = a <NEWLINE> left = mid <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import math <NEWLINE> import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( [ i + 1 , a [ i ] ] ) <NEWLINE> <NL> <DEDENT> sl = sorted ( l , key = lambda x : x [ 1 ] ) <NEWLINE> sl0 = [ r [ 0 ] for r in sl ] <NEWLINE> print ( <STRING> . join ( [ str ( _ ) for _ in sl0 ] ) ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> ans = <STRING> <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , H - 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , W - 1 ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> and s [ i ] [ j + 1 ] == s [ i + 1 ] [ j ] == s [ i ] [ j - 1 ] == s [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> uf = UnionFind ( n ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> roots = uf . roots ( ) <NEWLINE> cnt = [ ] <NEWLINE> for r in roots : <NEWLINE> <INDENT> cnt . append ( uf . size ( r ) ) <NEWLINE> <DEDENT> cnt . sort ( reverse = True ) <NEWLINE> ans = cnt [ 0 ] <NEWLINE> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> div = 7 + 10 ** 9 <NEWLINE> ans = 1 <NEWLINE> t = 0 <NEWLINE> i , j = 0 , N - 1 <NEWLINE> <NL> if A [ - 1 ] < 0 and K % 2 == 1 : <NEWLINE> <INDENT> for i1 in range ( N - K , N ) : <NEWLINE> <INDENT> ans *= A [ i1 ] <NEWLINE> ans %= div <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> while t < K - 1 : <NEWLINE> <INDENT> if A [ i ] * A [ i + 1 ] > A [ j ] * A [ j - 1 ] : <NEWLINE> <INDENT> ans *= A [ i ] * A [ i + 1 ] <NEWLINE> ans %= div <NEWLINE> i += 2 <NEWLINE> t += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= A [ j ] <NEWLINE> ans %= div <NEWLINE> j += - 1 <NEWLINE> t += 1 <NEWLINE> <DEDENT> <DEDENT> if t == K - 1 : <NEWLINE> <INDENT> ans *= A [ j ] <NEWLINE> ans %= div <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> for c in s : <NEWLINE> <INDENT> if c . islower ( ) : <NEWLINE> <INDENT> print ( c . upper ( ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c . lower ( ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
<COMMENT> <NL> def solve ( balls ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> last_b = last_c = 0 <NEWLINE> <NL> while balls : <NEWLINE> <INDENT> new = balls . pop ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> if new <= last_b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> elif new <= last_c : <NEWLINE> <INDENT> last_b = new <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> last_c = new <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> balls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> solve ( balls ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> AB_gcd = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( AB_gcd , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> answer = 1 <NEWLINE> flag = 1 <NEWLINE> zero = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> answer *= A [ i ] <NEWLINE> if answer > pow ( 10 , 18 ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> h , w , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> x = [ 0 ] * 300001 <NEWLINE> y = [ 0 ] * 300001 <NEWLINE> z = [ ] <NEWLINE> mx , my = 0 , 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> x [ a ] += 1 <NEWLINE> y [ b ] += 1 <NEWLINE> mx = max ( mx , x [ a ] ) <NEWLINE> my = max ( my , y [ b ] ) <NEWLINE> z . append ( ( a , b ) ) <NEWLINE> <DEDENT> x1 = x . count ( mx ) <NEWLINE> y1 = y . count ( my ) <NEWLINE> z1 = x1 * y1 <NEWLINE> for i , j in z : <NEWLINE> <INDENT> if x [ i ] == mx and y [ j ] == my : <NEWLINE> <INDENT> z1 -= 1 <NEWLINE> <DEDENT> <DEDENT> if z1 : print ( mx + my ) <NEWLINE> else : print ( mx + my - 1 ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> chars = sorted ( set ( S ) ) <NEWLINE> checked = set ( ) <NEWLINE> <NL> <NL> def dfs ( s ) : <NEWLINE> <INDENT> for c in chars : <NEWLINE> <INDENT> if len ( checked ) >= K : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> next_s = s + c <NEWLINE> if next_s not in checked and next_s in S : <NEWLINE> <INDENT> checked . add ( next_s ) <NEWLINE> if len ( checked ) == K : <NEWLINE> <INDENT> print ( next_s ) <NEWLINE> return <NEWLINE> <DEDENT> elif len ( next_s ) <= len ( S ) : <NEWLINE> <INDENT> dfs ( next_s ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dfs ( <STRING> ) <NEWLINE>
import numpy as np <NEWLINE> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> union = UnionFind ( n ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> union . union ( a , b ) <NEWLINE> <NL> <DEDENT> print ( union . group_count ( ) - 1 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> aL = sorted ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <COMMENT> <NL> <NL> dp = [ False for _ in range ( 1000001 ) ] <NEWLINE> <NL> d = { } <NEWLINE> for a in aL : <NEWLINE> <INDENT> if a in d : <NEWLINE> <INDENT> d [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ a ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in aL : <NEWLINE> <INDENT> if dp [ a ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if d [ a ] > 1 : <NEWLINE> <INDENT> c = 1 <NEWLINE> while a * c <= 1000000 : <NEWLINE> <INDENT> dp [ a * c ] = True <NEWLINE> c += 1 <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <NL> c = 1 <NEWLINE> while a * c <= 1000000 : <NEWLINE> <INDENT> dp [ a * c ] = True <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> memo = [ - 1 ] * ( n + 1 ) <NEWLINE> memo [ 0 ] = 1 <NEWLINE> memo [ 1 ] = 1 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> memo [ int ( input ( ) ) ] = 0 <NEWLINE> <NL> <DEDENT> def fib ( x ) : <NEWLINE> <INDENT> if memo [ x ] == - 1 : <NEWLINE> <INDENT> memo [ x ] = fib ( x - 1 ) + fib ( x - 2 ) <NEWLINE> <DEDENT> return memo [ x ] <NEWLINE> <NL> <DEDENT> def fib2 ( x ) : <NEWLINE> <INDENT> if x <= 1 : <NEWLINE> <INDENT> return memo [ x ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( x - 1 ) : <NEWLINE> <INDENT> if memo [ i + 2 ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> memo [ i + 2 ] = memo [ i ] + memo [ i + 1 ] <NEWLINE> <DEDENT> return memo [ x ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( fib2 ( n ) % 1000000007 ) <NEWLINE>
import itertools <NEWLINE> N = int ( input ( ) ) <NEWLINE> num = int ( N ** 0.5 ) + 1 <NEWLINE> <NL> ans = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for x , y , z in itertools . product ( range ( 1 , num + 1 ) , repeat = 3 ) : <NEWLINE> <INDENT> fn = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if fn > N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ fn ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if len ( N ) >= 3 : <NEWLINE> <INDENT> A = int ( N [ - 3 ] ) * 100 + int ( N [ - 2 ] ) * 10 + int ( N [ - 1 ] ) <NEWLINE> if A == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - A ) <NEWLINE> <DEDENT> <DEDENT> elif len ( N ) == 2 : <NEWLINE> <INDENT> A = int ( N [ - 2 ] ) * 10 + int ( N [ - 1 ] ) <NEWLINE> print ( 1000 - A ) <NEWLINE> <DEDENT> elif len ( N ) == 1 : <NEWLINE> <INDENT> A = int ( N [ - 1 ] ) <NEWLINE> print ( 1000 - A ) <NEWLINE> <DEDENT>
import itertools as it <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans . append ( [ a , b ] ) <NEWLINE> ans . append ( [ b , a ] ) <NEWLINE> <NL> <DEDENT> a = 0 <NEWLINE> for e in it . permutations ( range ( n ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> count = 1 <NEWLINE> if e [ 0 ] != 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if [ e [ i ] + 1 , e [ i + 1 ] + 1 ] in ans : <NEWLINE> <INDENT> count *= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count *= 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> a += count <NEWLINE> <NL> <DEDENT> print ( a ) <NEWLINE>
string = input ( ) <NEWLINE> height = 0 <NEWLINE> height_list = [ [ 0 , False ] ] <NEWLINE> for s in string : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> height += - 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> height += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> height_list . append ( [ height , False ] ) <NEWLINE> <NL> <DEDENT> highest = 0 <NEWLINE> for i in range ( 1 , len ( height_list ) ) : <NEWLINE> <INDENT> if height_list [ i - 1 ] [ 0 ] < height_list [ i ] [ 0 ] <= highest : <NEWLINE> <INDENT> height_list [ i ] [ 1 ] = True <NEWLINE> <DEDENT> highest = max ( highest , height_list [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> puddles = [ ] <NEWLINE> area = 0 <NEWLINE> surface_level = None <NEWLINE> <NL> for i in range ( len ( height_list ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if surface_level != None : <NEWLINE> <INDENT> area += surface_level - height_list [ i ] [ 0 ] <NEWLINE> if surface_level == height_list [ i ] [ 0 ] : <NEWLINE> <INDENT> puddles += [ area ] <NEWLINE> surface_level = None <NEWLINE> area = 0 <NEWLINE> <DEDENT> <DEDENT> if surface_level == None and height_list [ i ] [ 1 ] : <NEWLINE> <INDENT> surface_level = height_list [ i ] [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> puddles = puddles [ : : - 1 ] <NEWLINE> print ( sum ( puddles ) ) <NEWLINE> print ( len ( puddles ) , * puddles ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> G2 , G4 = [ ] , [ ] <NEWLINE> cnt2 = 0 <NEWLINE> cnt3 = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> MIN = 0 <NEWLINE> cnt = 0 <NEWLINE> for s in list ( S ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> MIN = min ( MIN , cnt ) <NEWLINE> <DEDENT> if MIN == 0 and cnt >= 0 : <NEWLINE> <INDENT> cnt2 += cnt <NEWLINE> <DEDENT> if MIN < 0 and cnt >= 0 : <NEWLINE> <INDENT> G2 . append ( [ MIN , cnt ] ) <NEWLINE> <DEDENT> if MIN == cnt and cnt < 0 : <NEWLINE> <INDENT> cnt3 += cnt <NEWLINE> <DEDENT> if MIN < cnt and cnt < 0 : <NEWLINE> <INDENT> G4 . append ( [ MIN , cnt ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> G2 . sort ( reverse = True ) <NEWLINE> for L in G2 : <NEWLINE> <INDENT> if cnt2 + L [ 0 ] < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt2 += L [ 1 ] <NEWLINE> <DEDENT> <DEDENT> for L in G4 : <NEWLINE> <INDENT> if cnt2 + L [ 0 ] < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt2 += L [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> cnt2 += cnt3 <NEWLINE> <NL> if cnt2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . reverse ( ) <NEWLINE> for y , x in enumerate ( a ) : <NEWLINE> <INDENT> if y + 1 == len ( a ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x , end = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> import copy <NEWLINE> sys . setrecursionlimit ( 2147483647 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m , k = map ( int , input ( ) . strip ( <STRING> ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( <STRING> ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . strip ( <STRING> ) . split ( ) ) ) <NEWLINE> t = sum ( B ) <NEWLINE> j = m <NEWLINE> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> while j > 0 and t > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> t -= B [ j ] <NEWLINE> <DEDENT> if t > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> if i == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t += A [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> nlist = [ ] <NEWLINE> nans = - 100001 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> nlist . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> nkeep = 0 <NEWLINE> for i in nlist : <NEWLINE> <INDENT> if nkeep < 0 : <NEWLINE> <INDENT> nkeep = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nkeep += i <NEWLINE> <DEDENT> if nans < nkeep : nans = nkeep <NEWLINE> <DEDENT> if max ( nlist ) < 0 : nans = max ( nlist ) <NEWLINE> print ( nans ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dic = { } <NEWLINE> for i , v in enumerate ( A ) : <NEWLINE> <INDENT> dic [ i + 1 ] = v <NEWLINE> <NL> <DEDENT> town = 1 <NEWLINE> s = set ( ) <NEWLINE> l = [ ] <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> l . append ( town ) <NEWLINE> s . add ( town ) <NEWLINE> town = dic [ town ] <NEWLINE> if town in s : <NEWLINE> <INDENT> stop_twon = town <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if N <= K : <NEWLINE> <INDENT> list_first_split = l [ : l . index ( stop_twon ) ] <NEWLINE> list_second_split = l [ l . index ( stop_twon ) : ] <NEWLINE> print ( list_second_split [ ( K - ( len ( list_first_split ) ) ) % len ( list_second_split ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( town ) <NEWLINE> <DEDENT>
def e_bullet ( MOD = 10 ** 9 + 7 ) : <NEWLINE> <INDENT> from math import gcd <NEWLINE> from collections import defaultdict <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> zero_all = 0 <NEWLINE> pair = defaultdict ( int ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> zero_all += 1 <NEWLINE> continue <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if a != 0 and b != 0 : <NEWLINE> <INDENT> g = gcd ( a , b ) * a // abs ( a ) <NEWLINE> <DEDENT> elif a != 0 : <NEWLINE> <INDENT> g = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = b <NEWLINE> <DEDENT> pair [ ( a // g , b // g ) ] += 1 <COMMENT> <NEWLINE> <NL> <DEDENT> done = set ( ) <NEWLINE> total = 1 <NEWLINE> for ( a , b ) , v in list ( pair . items ( ) ) : <NEWLINE> <INDENT> if ( b , - a ) in done or ( - b , a ) in done : <NEWLINE> <INDENT> continue <COMMENT> <NEWLINE> <DEDENT> done . add ( ( a , b ) ) <NEWLINE> <NL> <COMMENT> <NL> w = pair [ ( b , - a ) ] + pair [ ( - b , a ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> total *= pow ( 2 , v , MOD ) + pow ( 2 , w , MOD ) - 1 <NEWLINE> total %= MOD <NEWLINE> <NL> <DEDENT> ans = ( total + zero_all - 1 ) % MOD <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> print ( e_bullet ( ) ) <NEWLINE>
MOD = ( int ) ( 1e9 + 7 ) <NEWLINE> <NL> def power ( a , n ) : <NEWLINE> <INDENT> if a == 0 : return 0 <NEWLINE> if n == 0 : return 1 <NEWLINE> <NL> res = 1 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> if n % 2 == 1 : res = res * a % MOD <NEWLINE> a = a * a % MOD <NEWLINE> n //= 2 <NEWLINE> <NL> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def inverse ( n ) : <NEWLINE> <INDENT> return power ( n , MOD - 2 ) <NEWLINE> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ ] <NEWLINE> pos , neg = 0 , 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a > 0 : <NEWLINE> <INDENT> B . append ( [ a , 1 ] ) <NEWLINE> pos += 1 <NEWLINE> <DEDENT> if a < 0 : <NEWLINE> <INDENT> B . append ( [ - a , - 1 ] ) <NEWLINE> neg += 1 <NEWLINE> <DEDENT> if a == 0 : <NEWLINE> <INDENT> B . append ( [ 0 , 0 ] ) <NEWLINE> <DEDENT> <DEDENT> B . sort ( reverse = True ) <NEWLINE> <NL> ans , sign = 1 , 1 <NEWLINE> if N == neg and K % 2 == 1 : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> ans *= B [ N - 1 - i ] [ 0 ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( - ans % MOD ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> ans *= B [ i ] [ 0 ] <NEWLINE> ans %= MOD <NEWLINE> sign *= B [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> if N == K : <NEWLINE> <INDENT> if sign >= 0 : print ( ans ) <NEWLINE> else : print ( - ans % MOD ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if sign < 0 : <NEWLINE> <INDENT> out_neg , out_pos = 0 , 0 <NEWLINE> in_pos , in_neg = 0 , 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if B [ K - 1 - i ] [ 1 ] < 0 : <NEWLINE> <INDENT> out_neg = B [ K - 1 - i ] [ 0 ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> if B [ K - 1 - i ] [ 1 ] > 0 : <NEWLINE> <INDENT> out_pos = B [ K - 1 - i ] [ 0 ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N - K ) : <NEWLINE> <INDENT> if B [ K + i ] [ 1 ] > 0 : <NEWLINE> <INDENT> in_pos = B [ K + i ] [ 0 ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N - K ) : <NEWLINE> <INDENT> if B [ K + i ] [ 1 ] < 0 : <NEWLINE> <INDENT> in_neg = B [ K + i ] [ 0 ] <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if in_neg == 0 or out_pos == 0 : <NEWLINE> <INDENT> ans = ( ans * in_pos % MOD ) * inverse ( out_neg ) % MOD <NEWLINE> <DEDENT> elif in_pos == 0 or out_neg == 0 : <NEWLINE> <INDENT> ans = ( ans * in_neg % MOD ) * inverse ( out_pos ) % MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if out_pos * in_pos < out_neg * in_neg : <NEWLINE> <INDENT> ans = ( ans * in_neg % MOD ) * inverse ( out_pos ) % MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( ans * in_pos % MOD ) * inverse ( out_neg ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = list ( set ( range ( - 200 , 200 ) ) ^ set ( p ) ) <NEWLINE> num = sorted ( [ [ abs ( i - x ) , i ] for i in num ] ) <NEWLINE> if len ( num ) >= 2 and num [ 0 ] [ 0 ] == num [ 1 ] [ 0 ] : <NEWLINE> <INDENT> print ( min ( num [ 0 ] [ 1 ] , num [ 1 ] [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( num [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
X , A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if X < A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE> <NL>
k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> import math <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> def gcdlist ( l ) : <NEWLINE> <INDENT> a = l [ 0 ] <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> a = gcd ( a , l [ i ] ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> sumlis = { } <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> t = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( t , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> def segmentTree ( dat , f , sentinel ) : <NEWLINE> <INDENT> pad = 2 ** math . ceil ( math . log ( len ( dat ) , 2 ) ) <NEWLINE> dat = [ 0 ] * pad + dat + [ sentinel ] * ( pad - len ( dat ) ) <NEWLINE> for i in range ( pad - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> dat [ i ] = f ( dat [ i * 2 ] , dat [ i * 2 + 1 ] ) <NEWLINE> <DEDENT> return dat <NEWLINE> <NL> <DEDENT> def get_lr ( b , d ) : <NEWLINE> <INDENT> l = r = 0 <NEWLINE> while r < len ( b ) : <NEWLINE> <INDENT> while b [ l ] + d < b [ r ] : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> for r in range ( r , len ( b ) ) : <NEWLINE> <INDENT> if b [ l ] + d < b [ r ] : <NEWLINE> <INDENT> r -= 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> r += 1 <NEWLINE> yield l , r <NEWLINE> l += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> _ , d = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> <NL> xyb = [ ] <NEWLINE> for line in f : <NEWLINE> <INDENT> xyb . append ( tuple ( map ( int , line . split ( ) ) ) ) <NEWLINE> <DEDENT> from operator import itemgetter <NEWLINE> xyb . sort ( key = itemgetter ( 2 ) ) <NEWLINE> <NL> x = [ xybi [ 0 ] for xybi in xyb ] <NEWLINE> y = [ xybi [ 1 ] for xybi in xyb ] <NEWLINE> b = [ xybi [ 2 ] for xybi in xyb ] <NEWLINE> <NL> xmax = segmentTree ( x , max , sentinel = 0 ) <NEWLINE> xmin = segmentTree ( x , min , sentinel = 2000000 ) <NEWLINE> ymax = segmentTree ( y , max , sentinel = 0 ) <NEWLINE> ymin = segmentTree ( y , min , sentinel = 2000000 ) <NEWLINE> <NL> <NL> pad = len ( xmax ) // 2 <NEWLINE> max_size = 0 <NEWLINE> def create_index ( l , r ) : <NEWLINE> <INDENT> index = [ ] <NEWLINE> ia = index . append <NEWLINE> while l < r : <NEWLINE> <INDENT> if r & 1 : <NEWLINE> <INDENT> r -= 1 <NEWLINE> ia ( r ) <NEWLINE> <DEDENT> if l & 1 : <NEWLINE> <INDENT> ia ( l ) <NEWLINE> l += 1 <NEWLINE> <DEDENT> l >>= 1 <NEWLINE> r >>= 1 <NEWLINE> <DEDENT> return index <NEWLINE> <NL> <DEDENT> for l , r in get_lr ( b , d ) : <NEWLINE> <INDENT> l += pad <NEWLINE> r += pad <NEWLINE> index = create_index ( l , r ) <NEWLINE> <NL> now_xmax = max ( xmax [ i ] for i in index ) <NEWLINE> now_ymax = max ( ymax [ i ] for i in index ) <NEWLINE> if max_size < now_xmax * now_ymax : <NEWLINE> <INDENT> max_size = max ( max_size , ( ( now_xmax - min ( xmin [ i ] for i in index ) ) * ( now_ymax - min ( ymin [ i ] for i in index ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> print ( max_size ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmp = 1 <NEWLINE> route = [ tmp ] <NEWLINE> edge = { tmp } <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = A [ tmp - 1 ] <NEWLINE> if tmp in edge : <NEWLINE> <INDENT> left = route . index ( tmp ) <NEWLINE> right = len ( route ) <NEWLINE> idx = left + ( k - left ) % ( right - left ) <NEWLINE> print ( route [ idx ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> route . append ( tmp ) <NEWLINE> edge . add ( tmp ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( tmp ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if W == 0 and H == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for i in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> G = { i : [ ] for i in range ( N + 1 ) } <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> parent = [ 0 ] * ( N + 1 ) <NEWLINE> parent [ 0 ] == - 1 <NEWLINE> parent [ 1 ] == - 1 <NEWLINE> q = deque ( ) <NEWLINE> q . append ( 1 ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> room = q . popleft ( ) <NEWLINE> child = G [ room ] <NEWLINE> <NL> for i in child : <NEWLINE> <INDENT> if parent [ i ] == 0 : <NEWLINE> <INDENT> parent [ i ] = room <NEWLINE> q . append ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if min ( parent [ 2 : ] ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in parent [ 2 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
S = list ( input ( ) ) <NEWLINE> L = len ( S ) <NEWLINE> Slist = set ( ) <NEWLINE> for i in range ( L ) : <NEWLINE> <INDENT> Slist . add ( ord ( S [ i ] ) ) <NEWLINE> <DEDENT> Slist = list ( Slist ) <NEWLINE> Slist . sort ( ) <NEWLINE> ans = <STRING> <NEWLINE> j = 0 <NEWLINE> L = len ( Slist ) <NEWLINE> for i in range ( 97 , 123 ) : <NEWLINE> <INDENT> if Slist [ j ] == i : <NEWLINE> <INDENT> j += 1 <NEWLINE> if j >= L and i + 1 < 123 : <NEWLINE> <INDENT> ans = chr ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> ans = chr ( i ) <NEWLINE> break <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> M = [ list ( map ( int , stdin . readline ( ) . split ( ) ) ) for i in [ 0 ] * N ] <NEWLINE> M = np . array ( M ) <NEWLINE> <NL> @ njit <NEWLINE> def main ( h , n , m ) : <NEWLINE> <INDENT> dp = [ 10 ** 8 + 1 ] * ( 10 ** 4 + 1 ) <NEWLINE> dp = np . array ( dp ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , 10 ** 4 + 1 ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> a = m [ j ] [ 0 ] <NEWLINE> b = m [ j ] [ 1 ] <NEWLINE> if a > i : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i ] , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i ] , dp [ i - a ] + b ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ h ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( H , N , M ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = max ( A ) + 1 <NEWLINE> C = [ 0 for i in range ( M ) ] <NEWLINE> for a in A : <NEWLINE> <INDENT> C [ a ] += 1 <NEWLINE> <NL> <DEDENT> pairwise = True <NEWLINE> for i in range ( 2 , M ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( i , M , i ) : <NEWLINE> <INDENT> cnt += C [ j ] <NEWLINE> <NL> <DEDENT> if cnt > 1 : <NEWLINE> <INDENT> pairwise = False <NEWLINE> <NL> <DEDENT> <DEDENT> if pairwise : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> g = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> g = math . gcd ( g , A [ i ] ) <NEWLINE> <NL> <DEDENT> if g == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
while True : <NEWLINE> <INDENT> h , w = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> quit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 0 , h ) : <NEWLINE> <INDENT> for j in range ( 0 , w ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= 0 : <NEWLINE> <INDENT> if N <= A : <NEWLINE> <INDENT> print ( A - N , B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N = N - A <NEWLINE> if N <= B : <NEWLINE> <INDENT> print ( 0 , B - N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <NL> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for k in range ( W ) : <NEWLINE> <INDENT> if i == 0 or i == H - 1 or k == 0 or k == W - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <DEDENT>
d , g = map ( int , input ( ) . split ( ) ) <NEWLINE> pc = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( d ) ] <NEWLINE> <NL> ans = float ( <STRING> ) <NEWLINE> <NL> for bit in range ( 1 << d ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> sum = 0 <NEWLINE> nokori = set ( range ( 1 , d + 1 ) ) <NEWLINE> <NL> for i in range ( d ) : <NEWLINE> <INDENT> if bit & ( 1 << i ) : <NEWLINE> <INDENT> sum += pc [ i ] [ 0 ] * ( i + 1 ) * 100 + pc [ i ] [ 1 ] <NEWLINE> count += pc [ i ] [ 0 ] <NEWLINE> nokori . discard ( i + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if sum < g : <NEWLINE> <INDENT> use = max ( nokori ) <NEWLINE> n = min ( pc [ use - 1 ] [ 0 ] , - ( - ( g - sum ) // ( use * 100 ) ) ) <NEWLINE> count += n <NEWLINE> sum += n * use * 100 <NEWLINE> <NL> <DEDENT> if sum >= g : <NEWLINE> <INDENT> ans = min ( ans , count ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> N = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> As = list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <NL> ll = [ 0 ] * N <NEWLINE> lr = [ 0 ] * N <NEWLINE> for i , a in enumerate ( As ) : <NEWLINE> <INDENT> ll [ i ] = i + a <NEWLINE> lr [ i ] = i - a <NEWLINE> <NL> <DEDENT> cl = Counter ( ll ) <NEWLINE> cr = Counter ( lr ) <NEWLINE> <NL> ans = 0 <NEWLINE> for l in cl . keys ( ) : <NEWLINE> <INDENT> ans += cl [ l ] * cr [ l ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> m , f , l = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == f == l == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ( m == - 1 ) or ( f == - 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( m + f >= 30 ) and ( l >= 50 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> point = [ 0 ] * n <NEWLINE> total_b = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> point [ i ] = a + b <NEWLINE> total_b += b <NEWLINE> <NL> <DEDENT> point . sort ( reverse = True ) <NEWLINE> <NL> sum_t = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> sum_t += point [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum_t - total_b ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dd = defaultdict ( int ) <NEWLINE> <NL> for a in arr : <NEWLINE> <INDENT> dd [ a ] += 1 <NEWLINE> <NL> <DEDENT> sum = sum ( arr ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if dd [ b ] > 0 : <NEWLINE> <INDENT> sum += dd [ b ] * ( c - b ) <NEWLINE> dd [ c ] += dd [ b ] <NEWLINE> dd [ b ] = 0 <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> n , a = input ( ) . split ( ) <NEWLINE> A . append ( int ( n ) ) <NEWLINE> B . append ( int ( a ) ) <NEWLINE> <DEDENT> def f ( x ) : <NEWLINE> <INDENT> if x <= 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mini = g ( x - A [ 0 ] ) + B [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> sub = g ( x - A [ i ] ) + B [ i ] <NEWLINE> if sub < mini : <NEWLINE> <INDENT> mini = sub <NEWLINE> <DEDENT> <DEDENT> return mini <NEWLINE> <DEDENT> <DEDENT> def g ( x ) : <NEWLINE> <INDENT> if x < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return g_list [ x ] <NEWLINE> <DEDENT> <DEDENT> g_list = [ ] <NEWLINE> g_list . append ( 0 ) <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> g_list . append ( f ( i ) ) <NEWLINE> <DEDENT> print ( g_list [ - 1 ] ) <NEWLINE>
<NL> from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ map ( int , input ( ) . split ( ) ) for _ in range ( M ) ] <NEWLINE> <NL> links = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> links [ a ] . append ( b ) <NEWLINE> links [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> result = [ - 1 ] * ( N + 1 ) <NEWLINE> q = deque ( [ 1 ] ) <NEWLINE> while q : <NEWLINE> <INDENT> i = q . popleft ( ) <NEWLINE> for j in links [ i ] : <NEWLINE> <INDENT> if result [ j ] == - 1 : <NEWLINE> <INDENT> result [ j ] = i <NEWLINE> q . append ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( str ( i ) for i in result [ 2 : ] ) ) <NEWLINE> <NL> <NL>
SIZE = 5 * 10 ** 5 + 1 ; MOD = 10 ** 9 + 7 <COMMENT> <NEWLINE> <NL> SIZE += 1 <NEWLINE> inv = [ 0 ] * SIZE <COMMENT> <NEWLINE> fac = [ 0 ] * SIZE <COMMENT> <NEWLINE> finv = [ 0 ] * SIZE <COMMENT> <NEWLINE> inv [ 1 ] = 1 <NEWLINE> fac [ 0 ] = fac [ 1 ] = 1 <NEWLINE> finv [ 0 ] = finv [ 1 ] = 1 <NEWLINE> for i in range ( 2 , SIZE ) : <NEWLINE> <INDENT> inv [ i ] = MOD - ( MOD // i ) * inv [ MOD % i ] % MOD <NEWLINE> fac [ i ] = fac [ i - 1 ] * i % MOD <NEWLINE> finv [ i ] = finv [ i - 1 ] * inv [ i ] % MOD <NEWLINE> <NL> <DEDENT> def choose ( n , r ) : <COMMENT> <NEWLINE> <INDENT> if 0 <= r <= n : <NEWLINE> <INDENT> return ( fac [ n ] * finv [ r ] % MOD ) * finv [ n - r ] % MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> def chofuku ( n , r ) : <COMMENT> <NEWLINE> <INDENT> return choose ( n + r - 1 , r ) <NEWLINE> <NL> <DEDENT> def narabekae ( n , r ) : <COMMENT> <NEWLINE> <INDENT> return fac [ n ] * finv [ n - r ] % MOD <NEWLINE> <NL> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for k in range ( N + 1 ) : <NEWLINE> <INDENT> ans += choose ( N , k ) * narabekae ( M - k , N - k ) * ( - 1 if k % 2 == 1 else 1 ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> ans *= narabekae ( M , N ) <NEWLINE> print ( ans % MOD ) <NEWLINE>
import math <NEWLINE> import itertools <NEWLINE> def gcd ( lst ) : <NEWLINE> <INDENT> return math . gcd ( math . gcd ( lst [ 0 ] , lst [ 1 ] ) , lst [ 2 ] ) <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> lst = [ i for i in range ( 1 , k + 1 ) ] <NEWLINE> itr = itertools . combinations_with_replacement ( lst , 3 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in itr : <NEWLINE> <INDENT> st = set ( i ) <NEWLINE> num = len ( st ) <NEWLINE> if num == 1 : <NEWLINE> <INDENT> ans += i [ 0 ] <NEWLINE> <DEDENT> elif num == 2 : <NEWLINE> <INDENT> a , b = st <NEWLINE> ans += math . gcd ( a , b ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += math . gcd ( math . gcd ( i [ 0 ] , i [ 1 ] ) , i [ 2 ] ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> used_dict = defaultdict ( int ) <NEWLINE> used_dict [ 0 ] += 1 <NEWLINE> now_town = 0 <NEWLINE> flag = False <NEWLINE> <NL> for i in range ( min ( N , K ) ) : <NEWLINE> <INDENT> now_town = A [ now_town ] - 1 <NEWLINE> if used_dict [ now_town ] : <NEWLINE> <INDENT> used_dict [ now_town ] += 1 <NEWLINE> break <NEWLINE> <DEDENT> used_dict [ now_town ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> if not flag : <NEWLINE> <INDENT> now_town2 = 0 <NEWLINE> cnt = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if now_town2 == now_town : <NEWLINE> <INDENT> for _ in range ( ( K - cnt ) % ( i - cnt + 1 ) ) : <NEWLINE> <INDENT> now_town = A [ now_town ] - 1 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> now_town2 = A [ now_town2 ] - 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( now_town + 1 ) <NEWLINE>
s = [ 0 ] * 4001 <NEWLINE> for i in range ( 2001 ) : <NEWLINE> <INDENT> a = a + 2 * ( i - 999 ) * ( i - 1000 ) if i > 1000 else 0 <NEWLINE> s [ i ] = ( i + 3 ) * ( i + 2 ) * - ~ i // 6 - a <NEWLINE> s [ 4000 - i ] = s [ i ] <NEWLINE> <DEDENT> while 1 : <NEWLINE> <INDENT> try : print ( s [ int ( input ( ) ) ] ) <NEWLINE> except : break <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> nums = input ( ) . split ( ) <NEWLINE> end = False <NEWLINE> result = 1 <NEWLINE> for num in nums : <NEWLINE> <INDENT> if num == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> end = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not end : <NEWLINE> <INDENT> nums = [ int ( s ) for s in nums ] <NEWLINE> for num in nums : <NEWLINE> <INDENT> result = result * num <NEWLINE> if 10 ** 18 < result : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import scipy . sparse as sps <NEWLINE> import scipy . misc as spm <NEWLINE> import collections as col <NEWLINE> import functools as func <NEWLINE> import itertools as ite <NEWLINE> import fractions as frac <NEWLINE> import math as ma <NEWLINE> import cmath as cma <NEWLINE> import copy as cp <NEWLINE> import sys <NEWLINE> def sinput ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def iinput ( ) : return int ( sinput ( ) ) <NEWLINE> def imap ( ) : return map ( int , sinput ( ) . split ( ) ) <NEWLINE> def fmap ( ) : return map ( float , sinput ( ) . split ( ) ) <NEWLINE> def iarr ( n = 0 ) : <NEWLINE> <INDENT> if n : return [ 0 for _ in range ( n ) ] <NEWLINE> else : return list ( imap ( ) ) <NEWLINE> <DEDENT> def farr ( ) : return list ( fmap ( ) ) <NEWLINE> def sarr ( n = 0 ) : <NEWLINE> <INDENT> if n : return [ <STRING> for _ in range ( n ) ] <NEWLINE> else : return sinput ( ) . split ( ) <NEWLINE> <DEDENT> def adj ( n ) : return [ [ ] for _ in range ( n ) ] <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> MOD = 10 ** 9 + 7 ; EPS = sys . float_info . epsilon <NEWLINE> PI = np . pi ; EXP = np . e ; INF = np . inf <NEWLINE> <NL> def bin ( arr , val ) : <NEWLINE> <INDENT> l , r = 0 , len ( arr ) - 1 <NEWLINE> while l <= r : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> if arr [ mid ] == val : return 1 <NEWLINE> elif arr [ mid ] <= val : l = mid + 1 <NEWLINE> elif arr [ mid ] >= val : r = mid - 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> x , n = imap ( ) <NEWLINE> p = sorted ( iarr ( ) ) <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> a , b = x - i , x + i <NEWLINE> if not bin ( p , a ) : ans = a ; break <NEWLINE> if not bin ( p , b ) : ans = b ; break <NEWLINE> <NL> <DEDENT> if n == 0 : ans = x <NEWLINE> print ( ans ) <NEWLINE> <NL>
<NL> import sys <NEWLINE> _ = input ( ) <NEWLINE> l = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> result = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> t = gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> result += gcd ( t , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
beforex_plus_y = [ ] <NEWLINE> beforex_minus_y = [ ] <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> xy = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> beforex_plus_y . append ( xy [ 0 ] + xy [ 1 ] ) <NEWLINE> beforex_minus_y . append ( xy [ 0 ] - xy [ 1 ] ) <NEWLINE> <NL> <DEDENT> print ( max ( max ( beforex_plus_y ) - min ( beforex_plus_y ) , max ( beforex_minus_y ) - min ( beforex_minus_y ) ) ) <NEWLINE>
def partition ( p , r ) : <NEWLINE> <INDENT> x = a [ r ] <NEWLINE> i = p - 1 <NEWLINE> <NL> for j in range ( p , r ) : <NEWLINE> <INDENT> if a [ j ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> a [ i ] , a [ j ] = a [ j ] , a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> a [ i + 1 ] , a [ r ] = a [ r ] , a [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> idx = partition ( 0 , n - 1 ) <NEWLINE> a [ idx ] = [ a [ idx ] ] <NEWLINE> print ( * a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in arr : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = 1 <NEWLINE> for i in arr : <NEWLINE> <INDENT> if r * i > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> r *= i <NEWLINE> <DEDENT> print ( r ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> num = min ( b - 1 , n ) <NEWLINE> <NL> print ( int ( ( a * num ) / b ) - a * int ( num / b ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> root = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> root [ A - 1 ] . append ( B - 1 ) <NEWLINE> root [ B - 1 ] . append ( A - 1 ) <NEWLINE> <DEDENT> ans = [ [ - 1 , - 1 ] for _ in range ( N ) ] <NEWLINE> <NL> S = [ [ 0 , 0 , 0 ] ] <NEWLINE> <NL> while len ( S ) > 0 : <NEWLINE> <INDENT> S_ = [ ] <NEWLINE> for s in S : <NEWLINE> <INDENT> if ans [ s [ 0 ] ] [ 0 ] == - 1 or s [ 2 ] < ans [ s [ 0 ] ] [ 0 ] : <NEWLINE> <INDENT> ans [ s [ 0 ] ] [ 0 ] = s [ 2 ] <NEWLINE> ans [ s [ 0 ] ] [ 1 ] = s [ 1 ] <NEWLINE> for next in root [ s [ 0 ] ] : <NEWLINE> <INDENT> S_ . append ( [ next , s [ 0 ] , s [ 2 ] + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> S = S_ <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for a in ans [ 1 : ] : <NEWLINE> <INDENT> print ( a [ 1 ] + 1 ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import heapq <NEWLINE> a = list ( map ( lambda x : x * ( - 1 ) , A ) ) <COMMENT> <NEWLINE> <NL> heapq . heapify ( a ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> num = heapq . heappop ( a ) * ( - 1 ) <NEWLINE> heapq . heappush ( a , - 1 * ( int ( num / 2 ) ) ) <NEWLINE> <COMMENT> <NL> if num == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( - sum ( a ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> s = sum ( A ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> s -= A [ i ] <NEWLINE> ans += ( A [ i ] * ( s ) ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , v ) : <NEWLINE> <INDENT> if self . parents [ v ] < 0 : <NEWLINE> <INDENT> return v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ v ] = self . find ( self . parents [ v ] ) <NEWLINE> return self . parents [ v ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , u , v ) : <NEWLINE> <INDENT> u = self . find ( u ) <NEWLINE> v = self . find ( v ) <NEWLINE> <NL> if u == v : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ u ] > self . parents [ v ] : <NEWLINE> <INDENT> u , v = v , u <NEWLINE> <NL> <DEDENT> self . parents [ u ] += self . parents [ v ] <NEWLINE> self . parents [ v ] = u <NEWLINE> <NL> <DEDENT> def size ( self , v ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( v ) ] <NEWLINE> <NL> <DEDENT> def same ( self , u , v ) : <NEWLINE> <INDENT> return self . find ( u ) == self . find ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . unite ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if 0 == ( i % 2 ) : <NEWLINE> <INDENT> out = <STRING> <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if 0 == ( j % 2 ) : <NEWLINE> <INDENT> out += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> out += <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( out ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> out = <STRING> <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if 0 == ( j % 2 ) : <NEWLINE> <INDENT> out += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> out += <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( out ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> inf = 1000000000000000 <NEWLINE> <NL> def minHeapify ( Q , i ) : <NEWLINE> <INDENT> H = len ( Q ) <NEWLINE> l = 2 * i <NEWLINE> r = 2 * i + 1 <NEWLINE> if l < H and Q [ l ] [ 1 ] < Q [ i ] [ 1 ] : <NEWLINE> <INDENT> smallest = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> smallest = i <NEWLINE> <DEDENT> if r < H and Q [ r ] [ 1 ] < Q [ smallest ] [ 1 ] : <NEWLINE> <INDENT> smallest = r <NEWLINE> <NL> <DEDENT> if smallest != i : <NEWLINE> <INDENT> Q [ i ] , Q [ smallest ] = Q [ smallest ] , Q [ i ] <NEWLINE> minHeapify ( Q , smallest ) <NEWLINE> <NL> <DEDENT> <DEDENT> def buildMinHeap ( Q ) : <NEWLINE> <INDENT> H = len ( Q ) <NEWLINE> for i in range ( H // 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> minHeapify ( Q , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> def Insert ( Q , key ) : <NEWLINE> <INDENT> v = key [ 0 ] <NEWLINE> Q . append ( [ v , inf ] ) <NEWLINE> lens = len ( Q ) <NEWLINE> heapIncreaseKey ( Q , lens - 1 , key ) <NEWLINE> <NL> <DEDENT> def heapIncreaseKey ( Q , i , key ) : <NEWLINE> <INDENT> Q [ i ] [ 1 ] = key [ 1 ] <NEWLINE> while i > 0 and Q [ i // 2 ] [ 1 ] > Q [ i ] [ 1 ] : <NEWLINE> <INDENT> Q [ i ] , Q [ i // 2 ] = Q [ i // 2 ] , Q [ i ] <NEWLINE> i //= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> def heapExtractMin ( Q ) : <NEWLINE> <INDENT> H = len ( Q ) <NEWLINE> minv = Q [ 0 ] [ 0 ] <NEWLINE> Q [ 0 ] = Q [ H - 1 ] <NEWLINE> Q . pop ( ) <NEWLINE> minHeapify ( Q , 0 ) <NEWLINE> return minv <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> def dijkstra ( s ) : <NEWLINE> <INDENT> color = [ <STRING> for i in range ( n ) ] <NEWLINE> d = [ inf for i in range ( n ) ] <NEWLINE> d [ s ] = 0 <NEWLINE> Q = [ [ s , 0 ] ] <NEWLINE> while Q != [ ] : <NEWLINE> <INDENT> u = heapExtractMin ( Q ) <NEWLINE> color [ u ] = <STRING> <NEWLINE> for vw in mtrx [ u ] : <NEWLINE> <INDENT> [ v , w ] = vw <NEWLINE> if color [ v ] != <STRING> : <NEWLINE> <INDENT> if d [ u ] + w < d [ v ] : <NEWLINE> <INDENT> d [ v ] = d [ u ] + w <NEWLINE> color [ v ] = <STRING> <NEWLINE> Insert ( Q , [ v , d [ v ] ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <NL> <NL> <DEDENT> mtrx = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> col = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> u , k = col [ 0 ] , col [ 1 ] <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> [ v , w ] = col [ 2 * j + 2 : 2 * j + 4 ] <NEWLINE> mtrx [ u ] . append ( [ v , w ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> d = dijkstra ( 0 ) <NEWLINE> for i , j in enumerate ( d ) : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( tmp , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> U = [ input ( ) for i in range ( N ) ] <NEWLINE> M = int ( input ( ) ) <NEWLINE> T = [ input ( ) for i in range ( M ) ] <NEWLINE> <NL> opened = False <NEWLINE> for T_i in T : <NEWLINE> <INDENT> if T_i in U : <NEWLINE> <INDENT> if opened == True : <NEWLINE> <INDENT> print ( <STRING> + T_i ) <NEWLINE> opened = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + T_i ) <NEWLINE> opened = True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + T_i ) <NEWLINE> <DEDENT> <DEDENT>
def popcount_int ( n ) : <NEWLINE> <INDENT> return bin ( n ) . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> def popcount_bin ( s ) : <NEWLINE> <INDENT> return s . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> def poptimes ( n , cnt = 1 ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return cnt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n %= popcount_int ( n ) <NEWLINE> cnt += 1 <NEWLINE> return poptimes ( n , cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> S_int = int ( S , 2 ) <NEWLINE> pc = popcount_bin ( S ) <NEWLINE> pc_plus = S_int % ( pc + 1 ) <NEWLINE> if pc != 1 : <NEWLINE> <INDENT> pc_minus = S_int % ( pc - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if pc != 1 : <NEWLINE> <INDENT> tmp = pc_minus - pow ( 2 , N - i - 1 , pc - 1 ) <NEWLINE> print ( poptimes ( tmp % ( pc - 1 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tmp = pc_plus + pow ( 2 , N - i - 1 , pc + 1 ) <NEWLINE> print ( poptimes ( tmp % ( pc + 1 ) ) ) <NEWLINE> <DEDENT> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> if x > s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if x + y > s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif s - x - y <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> <NL> <NL> k = int ( input ( ) ) <NEWLINE> sum_c = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum_c += gcd ( gcd ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum_c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> for h in range ( 1 , 3501 ) : <NEWLINE> <INDENT> for n in range ( 1 , 3501 ) : <NEWLINE> <INDENT> if 4 * h * n - N * n - N * h > 0 and ( N * h * n ) % ( 4 * h * n - N * n - N * h ) == 0 : <NEWLINE> <INDENT> print ( h , n , ( N * h * n ) // ( 4 * h * n - N * n - N * h ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> road = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> road [ a - 1 ] . append ( b - 1 ) <NEWLINE> road [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> visit = [ 0 ] * N <NEWLINE> <NL> q = deque ( [ 0 ] ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> visit [ 0 ] = 1 <NEWLINE> def bfs ( q ) : <NEWLINE> <INDENT> while ( q ) : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> <COMMENT> <NL> for x in road [ v ] : <NEWLINE> <INDENT> if ( visit [ x ] == 0 ) : <NEWLINE> <INDENT> q . append ( x ) <NEWLINE> <COMMENT> <NL> visit [ x ] = 1 <NEWLINE> ans [ x ] = v + 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> bfs ( q ) <NEWLINE> print ( <STRING> ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
MOD = 998244353 <NEWLINE> MAX = 510000 <NEWLINE> fac = [ 1 , 1 ] <COMMENT> <NEWLINE> finv = [ 1 , 1 ] <COMMENT> <NEWLINE> inv = [ None , 1 ] <COMMENT> <NEWLINE> <NL> def comb_init ( ) : <NEWLINE> <INDENT> for i in range ( 2 , MAX ) : <NEWLINE> <INDENT> fac . append ( fac [ i - 1 ] * i % MOD ) <NEWLINE> inv . append ( MOD - inv [ MOD % i ] * ( MOD // i ) % MOD ) <NEWLINE> finv . append ( finv [ i - 1 ] * inv [ i ] % MOD ) <NEWLINE> <NL> <DEDENT> <DEDENT> def inverse_mod ( a ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return pow ( a , MOD - 2 , MOD ) <NEWLINE> <NL> <DEDENT> def comb_mod ( n , r ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if n < r : return 0 <NEWLINE> if n < 0 or r < 0 : return 0 <NEWLINE> return fac [ n ] * ( finv [ r ] * finv [ n - r ] % MOD ) % MOD <NEWLINE> <NL> <DEDENT> def solve ( n , m , k ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for k in range ( K + 1 ) : <NEWLINE> <INDENT> ans = ( ans + m * ( comb_mod ( n - 1 , k ) * pow ( m - 1 , n - k - 1 , MOD ) % MOD ) % MOD ) % MOD <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> comb_init ( ) <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( solve ( N , M , K ) ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <NL> <INDENT> <STRING> <NEWLINE> H = int ( input ( ) . strip ( ) ) <NEWLINE> hkeys = list ( map ( int , ( input ( ) . split ( ) ) ) ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> txts = [ ] <NEWLINE> id = i + 1 <NEWLINE> txts . append ( <STRING> . format ( id , hkeys [ i ] ) ) <NEWLINE> parent = int ( id / 2 ) <NEWLINE> if parent != 0 : <NEWLINE> <INDENT> txts . append ( <STRING> . format ( hkeys [ parent - 1 ] ) ) <NEWLINE> <DEDENT> left = id * 2 <NEWLINE> if left > 0 and left <= H : <NEWLINE> <INDENT> txts . append ( <STRING> . format ( hkeys [ left - 1 ] ) ) <NEWLINE> <DEDENT> right = left + 1 <NEWLINE> if right > 0 and right <= H : <NEWLINE> <INDENT> txts . append ( <STRING> . format ( hkeys [ right - 1 ] ) ) <NEWLINE> <DEDENT> print ( <STRING> . format ( <STRING> . join ( txts ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import * <NEWLINE> from itertools import * <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = map ( int , input ( ) . split ( ) ) <NEWLINE> SA = SB = 0 <NEWLINE> ABI = sorted ( ( ( b : = max ( N - i , i - 1 ) * a , SA : = SA + a , SB : = SB + b ) and ( a , b , i ) for i , a in enumerate ( A , 1 ) ) , reverse = True ) <NEWLINE> <NL> prev = { 0 : 0 } <NEWLINE> prev_max = 0 <NEWLINE> for k , ( a , b , i ) in enumerate ( ABI ) : <NEWLINE> <INDENT> curr = defaultdict ( int ) <NEWLINE> curr_max = 0 <NEWLINE> for l , p in prev . items ( ) : <NEWLINE> <INDENT> r = k - l <NEWLINE> if p + SB - min ( l , r ) * SA < prev_max : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> curr [ l ] = max ( curr [ l ] , p + abs ( N - i - r ) * a ) <NEWLINE> curr [ l + 1 ] = p + abs ( i - l - 1 ) * a <NEWLINE> curr_max = max ( curr_max , curr [ l ] , curr [ l + 1 ] ) <NEWLINE> <DEDENT> SA -= a <NEWLINE> SB -= b <NEWLINE> prev = curr <NEWLINE> prev_max = curr_max <NEWLINE> <NL> <DEDENT> print ( curr_max ) <NEWLINE>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> circle_squre = r * r * pi <NEWLINE> circle_length = ( r * 2 ) * pi <NEWLINE> <NL> print ( <STRING> . format ( circle_squre ) , <STRING> . format ( circle_length ) ) <NEWLINE>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> al = [ [ ] for i in range ( 10 ** 5 ) ] <NEWLINE> ans = 0 <NEWLINE> h = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> al [ a - 1 ] += [ - b ] <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> for j in al [ i ] : <NEWLINE> <INDENT> heapq . heappush ( h , j ) <NEWLINE> <DEDENT> if h : <NEWLINE> <INDENT> ans -= heapq . heappop ( h ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> j = a [ i : ] . index ( min ( a [ i : ] ) ) + i <NEWLINE> if i != j : <NEWLINE> <INDENT> a [ i ] , a [ j ] = a [ j ] , a [ i ] <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , a ) ) ) <NEWLINE> print ( c ) <NEWLINE>
from collections import deque <NEWLINE> import math <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <STRING> <NEWLINE> dist = [ - 1 for i in range ( N ) ] <NEWLINE> graph = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ A ] . append ( B ) <NEWLINE> graph [ B ] . append ( A ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> ans = [ - 1 ] * ( N + 1 ) <NEWLINE> q = deque ( ) <NEWLINE> q . append ( 1 ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> node = q . popleft ( ) <NEWLINE> for j in graph [ node ] : <NEWLINE> <INDENT> if ans [ j ] == - 1 : <NEWLINE> <INDENT> ans [ j ] = node <NEWLINE> q . append ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( list ( map ( str , ans [ 2 : ] ) ) ) ) <NEWLINE>
import sys <NEWLINE> import copy <NEWLINE> import bisect <NEWLINE> <NL> sys . setrecursionlimit ( 202020 ) <NEWLINE> <NL> INF = 10 ** 12 <NEWLINE> MAX_N = 202020 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> to = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 ; v -= 1 <NEWLINE> to [ u ] . append ( v ) <NEWLINE> to [ v ] . append ( u ) <NEWLINE> <NL> <DEDENT> dp = [ INF for _ in range ( MAX_N ) ] <NEWLINE> ans = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> def dfs ( v , p = - 1 ) : <NEWLINE> <INDENT> i = bisect . bisect_left ( dp , a [ v ] ) <NEWLINE> old = dp [ i ] <NEWLINE> dp [ i ] = a [ v ] <NEWLINE> ans [ v ] = i <NEWLINE> if p != - 1 : <NEWLINE> <INDENT> ans [ v ] = max ( ans [ v ] , ans [ p ] ) <NEWLINE> <DEDENT> for u in to [ v ] : <NEWLINE> <INDENT> if u == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( u , v ) <NEWLINE> <DEDENT> dp [ i ] = old <NEWLINE> <NL> <DEDENT> dp [ 0 ] = - INF <NEWLINE> dfs ( 0 ) <NEWLINE> print ( * ans ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import math <NEWLINE> from collections import Counter <NEWLINE> import itertools <NEWLINE> import fractions <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> def II ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def SR ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> ascii_lowercase = <STRING> <NEWLINE> ascii_uppercase = <STRING> <NEWLINE> ascii_uppercase2 = <STRING> <NEWLINE> <NL> <COMMENT> <NL> p2D = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> p2E = lambda x : print ( <STRING> . join ( x ) ) <NEWLINE> p2S = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> n = II ( ) <NEWLINE> A = LI ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> def formula ( x ) : <NEWLINE> <INDENT> return math . floor ( A * x / B ) - ( A * math . floor ( x / B ) ) <NEWLINE> <DEDENT> A , B , n = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if ( n <= B - 1 ) : <NEWLINE> <INDENT> x = n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> <DEDENT> maxi = formula ( x ) <NEWLINE> print ( maxi ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 10 ** 18 <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > m : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if ans > m : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import copy <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> B = copy . copy ( A ) <NEWLINE> B . sort ( ) <NEWLINE> A_max = B [ - 1 ] <NEWLINE> A_max2 = B [ - 2 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] < A_max : <NEWLINE> <INDENT> print ( A_max ) <NEWLINE> <DEDENT> elif A [ i ] == A_max : <NEWLINE> <INDENT> print ( A_max2 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a + b ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = np . sort ( np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> max_num = a [ - 1 ] + 1 <NEWLINE> dp = np . array ( [ 0 ] * ( max_num ) ) <NEWLINE> <NL> if np . count_nonzero ( a == 1 ) >= 1 : <NEWLINE> <INDENT> if np . count_nonzero ( a == 1 ) > 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> for j in np . arange ( i , max_num , i ) : <NEWLINE> <INDENT> dp [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( np . count_nonzero ( dp [ a ] == 1 ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> i = 0 <NEWLINE> <NL> while i < n : <NEWLINE> <INDENT> ko = 1 <NEWLINE> while ( i + ko ) < n and a [ i ] == a [ i + ko ] : <NEWLINE> <INDENT> ko += 1 <NEWLINE> <DEDENT> if ko % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> i += ko <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
NIL = - 1 <NEWLINE> class Node : <NEWLINE> <INDENT> parent = NIL <NEWLINE> left = NIL <NEWLINE> right = NIL <NEWLINE> type = NIL <NEWLINE> depth = NIL <NEWLINE> sibling = NIL <NEWLINE> degree = NIL <NEWLINE> height = NIL <NEWLINE> <NL> <DEDENT> def setHeight ( u ) : <NEWLINE> <INDENT> h1 = h2 = 0 <NEWLINE> if T [ u ] . right != NIL : <NEWLINE> <INDENT> h1 = setHeight ( T [ u ] . right ) + 1 <NEWLINE> <DEDENT> if T [ u ] . left != NIL : <NEWLINE> <INDENT> h2 = setHeight ( T [ u ] . left ) + 1 <NEWLINE> <DEDENT> if h1 == h2 == NIL : <NEWLINE> <INDENT> return NIL <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return max ( h1 , h2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def getDepth ( u ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> while T [ u ] . parent != NIL : <NEWLINE> <INDENT> u = T [ u ] . parent <NEWLINE> d += 1 <NEWLINE> <DEDENT> return d <NEWLINE> <NL> <DEDENT> def getSibling ( u ) : <NEWLINE> <INDENT> if T [ u ] . parent == NIL : <NEWLINE> <INDENT> return NIL <NEWLINE> <DEDENT> if T [ T [ u ] . parent ] . left != u and T [ T [ u ] . parent ] . left != NIL : <NEWLINE> <INDENT> return T [ T [ u ] . parent ] . left <NEWLINE> <DEDENT> if T [ T [ u ] . parent ] . right != u and T [ T [ u ] . parent ] . right != NIL : <NEWLINE> <INDENT> return T [ T [ u ] . parent ] . right <NEWLINE> <DEDENT> return NIL <NEWLINE> <NL> <DEDENT> def getDegree ( u ) : <NEWLINE> <INDENT> deg = 0 <NEWLINE> if T [ u ] . left != NIL : <NEWLINE> <INDENT> deg += 1 <NEWLINE> <DEDENT> if T [ u ] . right != NIL : <NEWLINE> <INDENT> deg += 1 <NEWLINE> <DEDENT> return deg <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> T = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> T [ i ] = Node ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> id , l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> T [ id ] . left = l <NEWLINE> T [ id ] . right = r <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if T [ i ] . left != NIL : <NEWLINE> <INDENT> T [ T [ i ] . left ] . parent = i <NEWLINE> <DEDENT> if T [ i ] . right != NIL : <NEWLINE> <INDENT> T [ T [ i ] . right ] . parent = i <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if T [ i ] . parent == NIL : <NEWLINE> <INDENT> T [ i ] . type = <STRING> <NEWLINE> <DEDENT> elif T [ i ] . parent != NIL and ( T [ i ] . left != NIL or T [ i ] . right != NIL ) : <NEWLINE> <INDENT> T [ i ] . type = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ i ] . type = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> T [ i ] . depth = getDepth ( i ) <NEWLINE> T [ i ] . sibling = getSibling ( i ) <NEWLINE> T [ i ] . degree = getDegree ( i ) <NEWLINE> T [ i ] . height = setHeight ( i ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> , i , <STRING> , T [ i ] . parent , <STRING> , T [ i ] . sibling , <STRING> , T [ i ] . degree , <STRING> , T [ i ] . depth , <STRING> , T [ i ] . height , <STRING> , T [ i ] . type , sep = <STRING> ) <NEWLINE> <DEDENT>
def floyd ( ) : <NEWLINE> <INDENT> global d <NEWLINE> global INF <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( d [ i ] [ k ] == INF ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> if ( d [ k ] [ j ] == INF ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n , q = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> maxx = 110 <NEWLINE> INF = 1 << 48 <NEWLINE> d = [ [ INF for j in range ( n + 2 ) ] for i in range ( n + 2 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> d [ i ] [ i ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> s = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> d [ s [ 0 ] ] [ s [ 1 ] ] = s [ 2 ] <NEWLINE> <NL> <DEDENT> floyd ( ) <NEWLINE> <NL> <COMMENT> <NL> negative = False ; <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( d [ i ] [ i ] < 0 ) : <NEWLINE> <INDENT> negative = True ; <NEWLINE> <NL> <DEDENT> <DEDENT> if ( negative ) : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if ( d [ i ] [ j ] == INF ) : <NEWLINE> <INDENT> if j == n - 1 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if j != n - 1 : print ( <STRING> % ( d [ i ] [ j ] ) , end = <STRING> ) <NEWLINE> else : print ( <STRING> % ( d [ i ] [ j ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> while True : <NEWLINE> <INDENT> E = int ( input ( ) ) <NEWLINE> if E == 0 : break <NEWLINE> ans = 10 ** 10 <NEWLINE> z = 0 <NEWLINE> while z ** 3 <= E : <NEWLINE> <INDENT> y = int ( math . sqrt ( E - z ** 3 ) ) <NEWLINE> x = E - z ** 3 - y ** 2 <NEWLINE> ans = min ( x + y + z , ans ) <NEWLINE> z += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> kuso = sum ( array ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> kuso -= array [ i ] <NEWLINE> ans += array [ i ] * kuso <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> delete_list = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] > h [ b - 1 ] : <NEWLINE> <INDENT> delete_list . append ( b ) <NEWLINE> <DEDENT> if h [ a - 1 ] == h [ b - 1 ] : <NEWLINE> <INDENT> delete_list . append ( a ) <NEWLINE> delete_list . append ( b ) <NEWLINE> <DEDENT> if h [ a - 1 ] < h [ b - 1 ] : <NEWLINE> <INDENT> delete_list . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> delete_list = set ( delete_list ) <NEWLINE> print ( n - len ( delete_list ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ int ( k ) for k in input ( ) . split ( ) ] <NEWLINE> lnew = { } <NEWLINE> for i in l : <NEWLINE> <INDENT> if i in lnew : <NEWLINE> <INDENT> lnew [ i ] += 1 <NEWLINE> <DEDENT> else : lnew [ i ] = 1 <NEWLINE> <DEDENT> Sum = 0 <NEWLINE> for num , val in lnew . items ( ) : <NEWLINE> <INDENT> Sum += num * val <NEWLINE> <DEDENT> k = int ( input ( ) ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if a in lnew : <NEWLINE> <INDENT> Sum -= lnew [ a ] * a <NEWLINE> c = 0 <NEWLINE> if b in lnew : <NEWLINE> <INDENT> c = lnew [ b ] <NEWLINE> Sum -= lnew [ b ] * b <NEWLINE> <DEDENT> lnew [ b ] = c + lnew [ a ] <NEWLINE> Sum += lnew [ b ] * b <NEWLINE> <DEDENT> lnew . pop ( a , None ) <NEWLINE> <NL> print ( Sum ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) [ : : - 1 ] <NEWLINE> l = [ 0 ] * 2019 <NEWLINE> l [ 0 ] = 1 <NEWLINE> ten = 1 <NEWLINE> mod = 2019 <NEWLINE> now = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> a = int ( s [ i ] ) * ten <NEWLINE> now = ( now + a ) % mod <NEWLINE> ans += l [ now ] <NEWLINE> l [ now ] += 1 <NEWLINE> ten *= 10 <NEWLINE> ten %= 2019 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for l in range ( n ) ] <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ count ] == 2 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = a [ count ] - 1 <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
from copy import deepcopy <NEWLINE> from math import ceil <NEWLINE> n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> q = deepcopy ( p ) <NEWLINE> for i in range ( 2 , int ( p ** 0.5 ) + 2 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while p % i == 0 : <NEWLINE> <INDENT> p //= i <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if cnt > 0 : <NEWLINE> <INDENT> ans *= i ** ( cnt // n ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans if p != q and n != 1 else q ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> s [ k - 1 ] = s [ k - 1 ] . lower ( ) <NEWLINE> print ( <STRING> . join ( s ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> def check ( p : int , h : list , ways : dict ) : <NEWLINE> <INDENT> for w in ways [ p ] : <NEWLINE> <INDENT> if h [ p ] <= h [ w ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> tmp = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> n = tmp [ 0 ] <NEWLINE> m = tmp [ 1 ] <NEWLINE> <NL> ways = defaultdict ( set ) <NEWLINE> h = [ 0 ] + [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> tmp = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ways [ tmp [ 0 ] ] . add ( tmp [ 1 ] ) <NEWLINE> ways [ tmp [ 1 ] ] . add ( tmp [ 0 ] ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if check ( i , h , ways ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from decimal import * <NEWLINE> a , b = map ( Decimal , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> total = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> total += a [ i - 1 ] <NEWLINE> ans += a [ i ] * total <NEWLINE> <DEDENT> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> N = len ( s ) <NEWLINE> <NL> ref = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lst = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> if s [ i ] in ref : <NEWLINE> <INDENT> while s [ i ] in ref : <NEWLINE> <INDENT> ans = ans + s [ i ] <NEWLINE> i += 1 <NEWLINE> if i >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> lst . append ( ans ) <NEWLINE> <NL> <DEDENT> ans = - float ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , len ( lst [ i ] ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def is_contain_cycle ( g , v ) : <NEWLINE> <INDENT> visited = set ( ) <NEWLINE> for i in range ( v ) : <NEWLINE> <INDENT> if i in visited : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> route = [ None ] <NEWLINE> dfs_stack = [ ( i , None ) ] <NEWLINE> while dfs_stack : <NEWLINE> <INDENT> u , prev = dfs_stack . pop ( ) <NEWLINE> while route [ - 1 ] != prev : <NEWLINE> <INDENT> route . pop ( ) <NEWLINE> <DEDENT> if u in route : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if u in visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited |= { u } <NEWLINE> dfs_stack . extend ( ( v , u ) for v in g [ u ] ) <NEWLINE> route . append ( u ) <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> from sys import stdin <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <NL> readline = stdin . readline <NEWLINE> <NL> v , e = map ( int , readline ( ) . split ( ) ) <NEWLINE> g = defaultdict ( set ) <NEWLINE> for i in range ( e ) : <NEWLINE> <INDENT> s , t = map ( int , readline ( ) . split ( ) ) <NEWLINE> g [ s ] |= { t } <NEWLINE> <DEDENT> print ( 1 if is_contain_cycle ( g , v ) else 0 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> n -= 1 <NEWLINE> a = <STRING> <NEWLINE> a = list ( a ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 1 , 20 ) : <NEWLINE> <INDENT> if n < 26 ** i : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> ans += a [ n % 26 ] <NEWLINE> n //= 26 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n -= 26 ** i <NEWLINE> <DEDENT> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> min_cal = [ 0 ] * N <NEWLINE> min_cal [ 0 ] = P [ 0 ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> min_cal [ i + 1 ] = min ( min_cal [ i ] , P [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if min_cal [ i ] >= P [ i ] : <NEWLINE> <INDENT> ans [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> Ps = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> numlist = [ ] <NEWLINE> for i in range ( 102 ) : <NEWLINE> <INDENT> numlist . append ( i ) <NEWLINE> <DEDENT> for p in Ps : <NEWLINE> <INDENT> numlist . remove ( p ) <NEWLINE> <DEDENT> import bisect <NEWLINE> a = bisect . bisect_left ( numlist , x ) <NEWLINE> b = a - 1 <NEWLINE> if abs ( numlist [ a ] - x ) >= abs ( numlist [ b ] - x ) : <NEWLINE> <INDENT> print ( numlist [ b ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( numlist [ a ] ) <NEWLINE> <DEDENT>
def solve ( A ) : <NEWLINE> <INDENT> n = A [ - 1 ] <NEWLINE> is_nodiv = [ True for _ in range ( n + 1 ) ] <NEWLINE> <NL> pre = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if pre == a or not is_nodiv [ a ] : <NEWLINE> <INDENT> is_nodiv [ a ] = False <NEWLINE> continue <NEWLINE> <NL> <DEDENT> for j in range ( 2 * a , n + 1 , a ) : <NEWLINE> <INDENT> is_nodiv [ j ] = False <NEWLINE> <NL> <DEDENT> pre = a <NEWLINE> <NL> <DEDENT> return sum ( [ is_nodiv [ a ] for a in A ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> ans = solve ( A ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * k <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> for i in range ( k , 0 , - 1 ) : <NEWLINE> <INDENT> dp [ i - 1 ] += pow ( k // i , n , mod ) <NEWLINE> for j in range ( k // i , 1 , - 1 ) : <NEWLINE> <INDENT> dp [ i - 1 ] -= dp [ i * j - 1 ] <NEWLINE> <DEDENT> ans += dp [ i - 1 ] * i <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , readline ( ) . split ( ) ) <NEWLINE> A -= 1 ; B -= 1 <NEWLINE> graph [ A ] . append ( B ) <NEWLINE> graph [ B ] . append ( A ) <NEWLINE> <DEDENT> trace = [ - 1 ] * N <NEWLINE> trace [ 0 ] = 0 <NEWLINE> <NL> que = deque ( [ 0 ] ) <NEWLINE> while True : <NEWLINE> <INDENT> fr = que . popleft ( ) <NEWLINE> for to in graph [ fr ] : <NEWLINE> <INDENT> if trace [ to ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> trace [ to ] = fr <NEWLINE> que . append ( to ) <NEWLINE> <DEDENT> if len ( que ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if - 1 in trace : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for t in trace [ 1 : ] : <NEWLINE> <INDENT> print ( t + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M , X = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> price , exp , rst = [ ] , [ [ ] for i in range ( N ) ] , - 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ls = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> price . append ( ls [ 0 ] ) <NEWLINE> exp [ i ] = ls [ 1 : ] <NEWLINE> <DEDENT> for i in range ( 1 << N ) : <NEWLINE> <INDENT> price_combi , exp_combi , exp_sum , cnt_ls = [ ] , [ ] , [ 0 ] * M , [ ] <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if i >> j & 1 : <NEWLINE> <INDENT> price_combi . append ( price [ j ] ) <NEWLINE> exp_combi . append ( exp [ j ] ) <NEWLINE> <DEDENT> <DEDENT> for s in exp_combi : <NEWLINE> <INDENT> for t in range ( M ) : <NEWLINE> <INDENT> exp_sum [ t ] += s [ t ] <NEWLINE> <DEDENT> <DEDENT> [ cnt_ls . append ( x ) for x in exp_sum if x >= X ] <NEWLINE> if len ( cnt_ls ) == M : <NEWLINE> <INDENT> if rst == - 1 : <NEWLINE> <INDENT> rst = sum ( price_combi ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rst = min ( rst , sum ( price_combi ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( rst ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( N , B - 1 ) <NEWLINE> a = A * x // B - A * ( x // B ) <NEWLINE> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> highest = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i > highest : <NEWLINE> <INDENT> highest = i <NEWLINE> <DEDENT> ans += highest - i <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def f ( a , b , n ) : <NEWLINE> <INDENT> return int ( a * n / b ) - a * int ( n / b ) <NEWLINE> <NL> <DEDENT> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( f ( a , b , b - 1 ) if n >= b - 1 else f ( a , b , n ) ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> S = sum ( A ) % mod <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S -= A [ i ] <NEWLINE> if S < 0 : S += mod <NEWLINE> <NL> ans += S * A [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from math import ceil , floor , comb , factorial , gcd , pow , sqrt , log2 , cos , sin , tan , pi , inf <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heappop , heappush <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> n , m = MAP ( ) <NEWLINE> ans = [ - 1 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> s , c = MAP ( ) <NEWLINE> s -= 1 <NEWLINE> if ans [ s ] == - 1 or ans [ s ] == c : <NEWLINE> <INDENT> ans [ s ] = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans [ 0 ] == 0 : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ans [ i ] == - 1 : <NEWLINE> <INDENT> if n != 1 and i == 0 : <NEWLINE> <INDENT> ans [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <DEDENT>
<NL> <COMMENT> <NL> n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ [ 0 ] * m for i in range ( n ) ] <NEWLINE> B = [ [ 0 ] * l for i in range ( m ) ] <NEWLINE> C = [ [ 0 ] * l for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B [ i ] = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> tmp += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <DEDENT> C [ i ] [ j ] = tmp <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , C [ i ] ) ) ) <NEWLINE> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> s = 0 <NEWLINE> <NL> for n , i in enumerate ( reversed ( A [ 1 : ] ) , 1 ) : <NEWLINE> <INDENT> s += i <NEWLINE> ans += A [ N - n - 1 ] * s <NEWLINE> <NL> <DEDENT> print ( ans % 1000000007 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> R = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> min_i = 0 <NEWLINE> max_val = R [ 1 ] - R [ 0 ] <NEWLINE> max_j = - 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if R [ min_i ] < R [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif R [ min_i ] > R [ i ] : <NEWLINE> <INDENT> min_i = i <NEWLINE> <NL> <DEDENT> if max_j <= i : <NEWLINE> <INDENT> max_j = i + 1 <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if R [ max_j ] < R [ j ] : <NEWLINE> <INDENT> max_j = j <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if max_val < R [ max_j ] - R [ min_i ] : <NEWLINE> <INDENT> max_val = R [ max_j ] - R [ min_i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_val ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> C = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> S = input ( ) <NEWLINE> L = len ( S ) <NEWLINE> <NL> <NL> def dfs ( x , l ) : <NEWLINE> <INDENT> if l == L : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif l > L : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> match = S [ l : l + 7 ] <NEWLINE> for c in C : <NEWLINE> <INDENT> if match . find ( c ) == 0 : <NEWLINE> <INDENT> if dfs ( c , l + len ( c ) ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> print ( <STRING> if dfs ( <STRING> , 0 ) else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nums = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> temp = nums [ 1 ] - nums [ 0 ] <NEWLINE> p = nums [ 0 ] <NEWLINE> <NL> for i in nums [ 1 : ] : <NEWLINE> <INDENT> if i - p > temp : <NEWLINE> <INDENT> temp = i - p <NEWLINE> <DEDENT> if i < p : <NEWLINE> <INDENT> p = i <NEWLINE> <DEDENT> <DEDENT> print ( temp ) <NEWLINE>
import heapq <NEWLINE> <NL> <NL> class Edge : <NEWLINE> <INDENT> def __init__ ( self , dst , weight ) : <NEWLINE> <INDENT> self . dst , self . weight = dst , weight <NEWLINE> <NL> <DEDENT> def __lt__ ( self , e ) : <NEWLINE> <INDENT> return self . weight > e . weight <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Graph : <NEWLINE> <INDENT> def __init__ ( self , V ) : <NEWLINE> <INDENT> self . V = V <NEWLINE> self . E = [ [ ] for _ in range ( V ) ] <NEWLINE> <NL> <DEDENT> def add_edge ( self , src , dst , weight ) : <NEWLINE> <INDENT> self . E [ src ] . append ( Edge ( dst , weight ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class ShortestPath : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , G , INF = 10 ** 9 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . G , self . INF = G , INF <NEWLINE> <NL> <DEDENT> class Node : <NEWLINE> <INDENT> def __init__ ( self , v , cost ) : <NEWLINE> <INDENT> self . v , self . cost = v , cost <NEWLINE> <NL> <DEDENT> def __lt__ ( self , n ) : <NEWLINE> <INDENT> return self . cost < n . cost <NEWLINE> <NL> <DEDENT> <DEDENT> def dijkstra ( self , start , goal = None ) : <NEWLINE> <INDENT> que = list ( ) <NEWLINE> self . dist = [ self . INF ] * self . G . V <COMMENT> <NEWLINE> self . dist [ start ] = 0 <NEWLINE> heapq . heappush ( que , self . Node ( start , 0 ) ) <NEWLINE> <NL> while len ( que ) > 0 : <NEWLINE> <INDENT> n = heapq . heappop ( que ) <NEWLINE> if self . dist [ n . v ] < n . cost : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if goal is not None and n . v == goal : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for e in self . G . E [ n . v ] : <NEWLINE> <INDENT> if self . dist [ n . v ] + e . weight < self . dist [ e . dst ] : <NEWLINE> <INDENT> self . dist [ e . dst ] = self . dist [ n . v ] + e . weight <NEWLINE> heapq . heappush ( que , self . Node ( e . dst , self . dist [ e . dst ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> V , E , start = map ( int , input ( ) . split ( ) ) <NEWLINE> G = Graph ( V ) <NEWLINE> for _ in range ( E ) : <NEWLINE> <INDENT> s , t , d = map ( int , input ( ) . split ( ) ) <NEWLINE> G . add_edge ( s , t , d ) <NEWLINE> <DEDENT> INF = 10 ** 9 <NEWLINE> sp = ShortestPath ( G , INF ) <NEWLINE> sp . dijkstra ( start ) <NEWLINE> for i in range ( G . V ) : <NEWLINE> <INDENT> print ( <STRING> if sp . dist [ i ] == INF else sp . dist [ i ] ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> t = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> t . append ( [ a , b , c , d ] ) <NEWLINE> <NL> <DEDENT> def judge ( l ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a , b , c , d = t [ i ] <NEWLINE> if l [ b ] - l [ a ] == c : <NEWLINE> <INDENT> ans += d <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> num = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> num . append ( i ) <NEWLINE> <NL> <DEDENT> for df in itertools . combinations_with_replacement ( num , n ) : <NEWLINE> <NL> <INDENT> ty = list ( df ) <NEWLINE> f = judge ( ty ) <NEWLINE> ans = max ( ans , f ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = { } <NEWLINE> R = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> t = A [ i ] + i <NEWLINE> if t in L : <NEWLINE> <INDENT> L [ t ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ t ] = 1 <NEWLINE> <DEDENT> s = i - A [ i ] <NEWLINE> if s in R : <NEWLINE> <INDENT> R [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R [ s ] = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t = A [ i ] + i <NEWLINE> <COMMENT> <NL> if t in R . keys ( ) : <NEWLINE> <INDENT> ans += R [ t ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> dict = { } <NEWLINE> for i in range ( 1 , A [ N - 1 ] + 1 ) : <NEWLINE> <INDENT> dict [ i ] = 0 <NEWLINE> <NL> <DEDENT> if N == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> if A [ 0 ] == 1 and A [ 1 ] != 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif A [ 0 ] == 1 and A [ 1 ] == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> temp = 1 <NEWLINE> <NL> for num in A : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if num * temp <= A [ N - 1 ] : <NEWLINE> <INDENT> dict [ num * temp ] += 1 <NEWLINE> temp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for num2 in A : <NEWLINE> <INDENT> if dict [ num2 ] <= 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
import math <NEWLINE> import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> m = 0 <NEWLINE> l = collections . Counter ( prime_factorize ( n ) ) <NEWLINE> l2 = list ( dict . values ( l ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for i in range ( len ( l2 ) ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if l2 [ i ] >= j * ( j + 1 ) / 2 : <NEWLINE> <INDENT> m = j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> s += m <NEWLINE> <NL> <NL> <DEDENT> print ( s ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> from enum import Enum <NEWLINE> <NL> <NL> class Graph ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> class Status ( Enum ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> white = 1 <COMMENT> <NEWLINE> gray = 2 <COMMENT> <NEWLINE> black = 3 <COMMENT> <NEWLINE> <NL> <DEDENT> def __init__ ( self , n , data ) : <NEWLINE> <INDENT> num_of_nodes = n + 1 <NEWLINE> self . color = [ Graph . Status . white ] * num_of_nodes <COMMENT> <NEWLINE> self . M = [ [ float ( <STRING> ) ] * num_of_nodes for _ in range ( num_of_nodes ) ] <NEWLINE> for i in range ( num_of_nodes ) : <NEWLINE> <INDENT> self . M [ i ] [ i ] = 0 <NEWLINE> <DEDENT> self . _make_matrix ( data ) <COMMENT> <NEWLINE> self . d = [ float ( <STRING> ) ] * num_of_nodes <COMMENT> <NEWLINE> self . p = [ - 1 ] * num_of_nodes <COMMENT> <NEWLINE> <NL> <DEDENT> def _make_matrix ( self , data ) : <NEWLINE> <INDENT> for d in data : <NEWLINE> <INDENT> r = d [ 0 ] <NEWLINE> for t in d [ 2 : ] : <NEWLINE> <INDENT> self . M [ r ] [ t ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def dijkstra ( self , start ) : <NEWLINE> <INDENT> self . d [ start ] = 0 <NEWLINE> self . p [ start ] = - 1 <NEWLINE> while True : <NEWLINE> <INDENT> mincost = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> for i in range ( len ( self . d ) ) : <NEWLINE> <INDENT> if self . color [ i ] != Graph . Status . black and self . d [ i ] < mincost : <COMMENT> <NEWLINE> <INDENT> mincost = self . d [ i ] <NEWLINE> u = i <COMMENT> <NEWLINE> <DEDENT> <DEDENT> if mincost == float ( <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> self . color [ u ] = Graph . Status . black <COMMENT> <NEWLINE> for v in range ( len ( self . d ) ) : <NEWLINE> <INDENT> if self . color [ v ] != Graph . Status . black and self . M [ u ] [ v ] != float ( <STRING> ) : <NEWLINE> <COMMENT> <NL> <INDENT> if self . d [ u ] + self . M [ u ] [ v ] < self . d [ v ] : <NEWLINE> <INDENT> self . d [ v ] = self . d [ u ] + self . M [ u ] [ v ] <NEWLINE> self . p [ v ] = u <NEWLINE> self . color [ v ] = Graph . Status . gray <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( args ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> network = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> network . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> packets = [ ] <NEWLINE> p = int ( input ( ) ) <NEWLINE> for _ in range ( p ) : <NEWLINE> <INDENT> packets . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> memo = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> g = Graph ( n , network ) <NEWLINE> g . dijkstra ( i ) <NEWLINE> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if g . d [ j ] == float ( <STRING> ) : <NEWLINE> <INDENT> memo [ i ] [ j ] = float ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> path = [ j ] <NEWLINE> u = j <NEWLINE> while g . p [ u ] != i : <NEWLINE> <INDENT> path . append ( g . p [ u ] ) <NEWLINE> u = g . p [ u ] <NEWLINE> <DEDENT> path . append ( i ) <NEWLINE> memo [ i ] [ j ] = len ( path ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for s , d , v in packets : <NEWLINE> <INDENT> if memo [ s ] [ d ] <= v : <NEWLINE> <INDENT> print ( memo [ s ] [ d ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> R = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> R [ A ] . append ( B ) <NEWLINE> R [ B ] . append ( A ) <NEWLINE> <DEDENT> P = [ - 1 ] * ( N + 1 ) <NEWLINE> P [ 1 ] = 0 <NEWLINE> Q = deque ( ) <NEWLINE> Q . append ( 1 ) <NEWLINE> <NL> while Q : <NEWLINE> <INDENT> v = Q . popleft ( ) <NEWLINE> for r in R [ v ] : <NEWLINE> <INDENT> if P [ r ] == - 1 : <NEWLINE> <INDENT> P [ r ] = v <NEWLINE> Q . append ( r ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for p in P [ 2 : ] : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT>
import math <NEWLINE> pi = math . pi <NEWLINE> <NL> x = float ( input ( ) ) <NEWLINE> <NL> a = pi * x * x <NEWLINE> b = pi * ( x + x ) <NEWLINE> <NL> print ( <STRING> . format ( a , b ) ) <NEWLINE>
import itertools <NEWLINE> import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_accumulate = list ( itertools . accumulate ( a_list ) ) <NEWLINE> a_sum = sum ( a_list ) <NEWLINE> result = 0 <NEWLINE> i = 0 <NEWLINE> for a in a_list : <NEWLINE> <INDENT> result += a * ( a_sum - a_accumulate [ i ] ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( result % ( pow ( 10 , 9 ) + 7 ) ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> dis = X <NEWLINE> if X >= D : <NEWLINE> <INDENT> dis = X - D * ( min ( abs ( X ) // D , K ) ) <NEWLINE> K = K - min ( abs ( X ) // D , K ) <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> print ( dis ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( dis - D ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> print ( dis ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( dis - D ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , ID , left , right ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . id = ID <NEWLINE> self . parent = - 1 <COMMENT> <NEWLINE> self . sibling = - 1 <COMMENT> <NEWLINE> self . degree = - 1 <COMMENT> <NEWLINE> self . depth = 0 <COMMENT> <NEWLINE> self . height = 0 <COMMENT> <NEWLINE> self . type = None <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> self . left_child = left <NEWLINE> self . right_child = right <NEWLINE> <NL> <DEDENT> <DEDENT> def calc_depth ( i ) : <NEWLINE> <INDENT> global node_list <NEWLINE> <NL> if node_list [ i ] . depth != 0 : <NEWLINE> <INDENT> return node_list [ i ] . depth <NEWLINE> <NL> <DEDENT> depth = 0 <NEWLINE> if node_list [ i ] . parent != - 1 : <NEWLINE> <INDENT> depth = calc_depth ( node_list [ i ] . parent ) + 1 <NEWLINE> <NL> <DEDENT> node_list [ i ] . depth = depth <NEWLINE> return depth <NEWLINE> <NL> <NL> <DEDENT> def calc_height ( i ) : <NEWLINE> <INDENT> global node_list <NEWLINE> <NL> if node_list [ i ] . height != 0 : <NEWLINE> <INDENT> return node_list [ i ] . height <NEWLINE> <NL> <DEDENT> h1 = h2 = 0 <NEWLINE> if node_list [ i ] . right_child != - 1 : <NEWLINE> <INDENT> h1 = calc_height ( node_list [ i ] . right_child ) + 1 <NEWLINE> <DEDENT> if node_list [ i ] . left_child != - 1 : <NEWLINE> <INDENT> h2 = calc_height ( node_list [ i ] . left_child ) + 1 <NEWLINE> <NL> <DEDENT> height = max ( h1 , h2 ) <NEWLINE> node_list [ i ] . height = height <NEWLINE> return height <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> data = [ tuple ( map ( int , input ( ) . split ( ) ) ) for x in range ( n ) ] <NEWLINE> node_list = [ ] <NEWLINE> <NL> for data_row in data : <NEWLINE> <INDENT> ID , left , right = data_row <NEWLINE> node = Node ( ID , left , right ) <NEWLINE> node_list . append ( node ) <NEWLINE> <NL> <DEDENT> node_list . sort ( key = lambda node : node . id ) <NEWLINE> <NL> for i , node in enumerate ( node_list ) : <NEWLINE> <INDENT> left = node . left_child <NEWLINE> right = node . right_child <NEWLINE> degree = 0 <NEWLINE> <NL> <COMMENT> <NL> if left != - 1 : <NEWLINE> <INDENT> degree += 1 <NEWLINE> node_list [ left ] . parent = i <NEWLINE> node_list [ left ] . sibling = right <NEWLINE> <NL> <DEDENT> if right != - 1 : <NEWLINE> <INDENT> degree += 1 <NEWLINE> node_list [ right ] . parent = i <NEWLINE> node_list [ right ] . sibling = left <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> node . degree = degree <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> calc_depth ( i ) <NEWLINE> calc_height ( i ) <NEWLINE> <NL> node = node_list [ i ] <NEWLINE> <NL> if node . depth == 0 : <NEWLINE> <INDENT> node . type = <STRING> <NEWLINE> <DEDENT> elif node . height == 0 : <NEWLINE> <INDENT> node . type = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . type = <STRING> <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( node . id , node . parent , node . sibling , node . degree , node . depth , node . height , node . type ) ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans2 = 0 <NEWLINE> for n in range ( K + 1 , N + 1 ) : <NEWLINE> <INDENT> ans1 = As [ n - K - 1 ] <NEWLINE> ans2 = As [ n - 1 ] <NEWLINE> if ans1 < ans2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = [ 0 ] * ( n + 1 ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> arr [ i + 1 ] += arr [ i ] + a [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans += ( a [ i ] * ( arr [ n ] - arr [ i + 1 ] ) ) % mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> dic = { } <NEWLINE> suma = sum ( a ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i in dic : <NEWLINE> <INDENT> dic [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in bc : <NEWLINE> <INDENT> dif = j [ 1 ] - j [ 0 ] <NEWLINE> if j [ 0 ] in dic : <NEWLINE> <INDENT> suma += dif * dic [ j [ 0 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( suma ) <NEWLINE> continue <NEWLINE> <DEDENT> if j [ 1 ] in dic : <NEWLINE> <INDENT> dic [ j [ 1 ] ] += dic . pop ( j [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ j [ 1 ] ] = dic . pop ( j [ 0 ] ) <NEWLINE> <DEDENT> print ( suma ) <NEWLINE> <DEDENT>
cards = input ( ) <NEWLINE> new = cards . split ( ) <NEWLINE> a = int ( new [ 0 ] ) <NEWLINE> b = int ( new [ 1 ] ) <NEWLINE> c = int ( new [ 2 ] ) <NEWLINE> k = int ( new [ 3 ] ) <NEWLINE> if a > k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a + b > k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum = a + ( k - ( a + b ) ) * ( - 1 ) <NEWLINE> print ( sum ) <NEWLINE> <DEDENT> <DEDENT>
MOD = 10 ** 9 + 7 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a1 = sum ( a ) <NEWLINE> a2 = sum ( [ x * x for x in a ] ) <NEWLINE> <NL> print ( ( ( a1 ** 2 - a2 ) // 2 ) % MOD ) <NEWLINE>
from bisect import bisect <NEWLINE> from numpy import cumsum <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = cumsum ( a ) <NEWLINE> b = cumsum ( b ) <NEWLINE> <NL> read = bisect ( a , k ) <NEWLINE> time = a [ read - 1 ] <NEWLINE> ans = read <NEWLINE> <NL> for i in range ( read ) : <NEWLINE> <INDENT> extra = k - time <NEWLINE> r = bisect ( b , extra ) <NEWLINE> ans = max ( ans , read + r ) <NEWLINE> read -= 1 <NEWLINE> time = a [ read - 1 ] <NEWLINE> <DEDENT> read = bisect ( b , k ) <NEWLINE> ans = max ( ans , read ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = A [ 0 ] <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> m *= A [ i ] <NEWLINE> if m > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
def lcs ( x , y ) : <NEWLINE> <INDENT> a = len ( x ) <NEWLINE> b = len ( y ) <NEWLINE> c1 = [ 0 ] * ( b + 1 ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> e1 = x [ i ] <NEWLINE> c2 = c1 [ : ] <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> if e1 == y [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c2 [ j ] + 1 <NEWLINE> <DEDENT> elif c1 [ j + 1 ] < c1 [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c1 [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return c1 [ - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) . rstrip ( ) ) <NEWLINE> ret = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s1 = input ( ) . rstrip ( ) <NEWLINE> s2 = input ( ) . rstrip ( ) <NEWLINE> ret . append ( lcs ( s1 , s2 ) ) <NEWLINE> <DEDENT> print ( * ret , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> def partition ( target_list , l , r ) : <NEWLINE> <INDENT> x = int ( target_list [ r ] [ 1 : ] ) <NEWLINE> i = l - 1 <NEWLINE> <NL> for j in range ( l , r ) : <NEWLINE> <INDENT> if int ( target_list [ j ] [ 1 : ] ) <= x : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> tmp = target_list [ i ] <NEWLINE> target_list [ i ] = target_list [ j ] <NEWLINE> target_list [ j ] = tmp <NEWLINE> <DEDENT> <DEDENT> tmp = target_list [ r ] <NEWLINE> target_list [ r ] = target_list [ i + 1 ] <NEWLINE> target_list [ i + 1 ] = tmp <NEWLINE> <NL> return i + 1 <NEWLINE> <NL> <DEDENT> def merge ( l , r ) : <NEWLINE> <NL> <INDENT> l_index = 0 <NEWLINE> r_index = 0 <NEWLINE> merge_list = [ ] <NEWLINE> l . append ( <STRING> + str ( pow ( 10 , 9 ) + 1 ) ) <NEWLINE> r . append ( <STRING> + str ( pow ( 10 , 9 ) + 1 ) ) <NEWLINE> <NL> for k in range ( len ( l ) + len ( r ) - 2 ) : <NEWLINE> <INDENT> if int ( l [ l_index ] [ 1 : ] ) <= int ( r [ r_index ] [ 1 : ] ) : <NEWLINE> <INDENT> merge_list . append ( l [ l_index ] ) <NEWLINE> l_index += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> merge_list . append ( r [ r_index ] ) <NEWLINE> r_index += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return merge_list <NEWLINE> <NL> <DEDENT> def merge_sort ( target_list ) : <NEWLINE> <INDENT> if len ( target_list ) == 1 : <NEWLINE> <INDENT> return target_list <NEWLINE> <NL> <DEDENT> mid = int ( len ( target_list ) / 2 ) <NEWLINE> l = merge_sort ( target_list [ : mid ] ) <NEWLINE> r = merge_sort ( target_list [ mid : ] ) <NEWLINE> <NL> return merge ( l , r ) <NEWLINE> <NL> <DEDENT> def check_stable ( origin_list , target_list ) : <NEWLINE> <INDENT> sorted_list = merge_sort ( origin_list ) <NEWLINE> if sorted_list == target_list : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> def quick_sort ( target_list , l , r ) : <NEWLINE> <INDENT> if l < r : <NEWLINE> <INDENT> c = partition ( target_list , l , r ) <NEWLINE> quick_sort ( target_list , l , c - 1 ) <NEWLINE> quick_sort ( target_list , c + 1 , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n_list = int ( input ( ) ) <NEWLINE> <NL> target_list = [ ] <NEWLINE> for i in range ( n_list ) : <NEWLINE> <INDENT> target_list . append ( input ( ) ) <NEWLINE> <DEDENT> origin_list = [ a for a in target_list ] <NEWLINE> quick_sort ( target_list , 0 , n_list - 1 ) <NEWLINE> print ( check_stable ( origin_list , target_list ) ) <NEWLINE> print ( <STRING> . join ( target_list ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ [ int ( n ) for n in input ( ) . split ( ) ] for i in range ( n ) ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> c = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> c [ i ] += a [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( lambda x : ( int ( x ) + 1 ) / 2 , input ( ) . split ( ) ) ) <NEWLINE> <NL> t = sum ( p [ : k ] ) <NEWLINE> ans = t <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> t += p [ i ] - p [ i - k ] <NEWLINE> if ans < t : ans = t <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
printn = lambda x : print ( x , end = <STRING> ) <NEWLINE> inn = lambda : int ( input ( ) ) <NEWLINE> inl = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> inm = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> ins = lambda : input ( ) . strip ( ) <NEWLINE> DBG = True <COMMENT> <NEWLINE> BIG = 10 ** 18 <NEWLINE> R = 10 ** 9 + 7 <NEWLINE> <NL> def ddprint ( x ) : <NEWLINE> <INDENT> if DBG : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> from math import gcd <NEWLINE> k = inn ( ) <NEWLINE> sm = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> g = gcd ( i , j ) <NEWLINE> if g == 1 : <NEWLINE> <INDENT> sm += k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for m in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sm += gcd ( g , m ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sm ) <NEWLINE>
<COMMENT> <NL> p_str = input ( ) . split ( ) <NEWLINE> ( N , K ) = [ int ( n ) for n in p_str ] <NEWLINE> <COMMENT> <NL> p_str = input ( ) . split ( ) <NEWLINE> p_int = [ int ( n ) for n in p_str ] <NEWLINE> ( A , B ) = ( 1 , 1 ) <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> B = p_int [ i ] <NEWLINE> A = p_int [ i + K ] <NEWLINE> <COMMENT> <NL> if B < A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> D = int ( input ( ) . rstrip ( <STRING> ) ) <NEWLINE> cs = [ int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ] <NEWLINE> S = { } <NEWLINE> cd = [ 0 ] * 26 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> S [ i ] = [ int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ] <NEWLINE> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> s1 = S [ i ] <NEWLINE> s1_s = sorted ( s1 , reverse = True ) <NEWLINE> if i != D - 1 : <NEWLINE> <INDENT> s2 = S [ i + 1 ] <NEWLINE> s1_a = [ x - y for x , y in zip ( s1 , cd ) ] <NEWLINE> s2_i = [ x - y for x , y in zip ( s2 , cd ) ] <NEWLINE> s1_b = sorted ( s1_a , reverse = True ) <NEWLINE> if s2_i . index ( max ( s2_i ) ) == s1_a . index ( s1_b [ 0 ] ) : <NEWLINE> <INDENT> x = s1_a . index ( s1_b [ 1 ] ) + 1 <NEWLINE> cd = [ y + z for y , z in zip ( cd , cs ) ] <NEWLINE> cd [ x - 1 ] = 0 <NEWLINE> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = s1_a . index ( s1_b [ 0 ] ) + 1 <NEWLINE> cd = [ y + z for y , z in zip ( cd , cs ) ] <NEWLINE> cd [ x - 1 ] = 0 <NEWLINE> print ( x ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s1_a = [ x - y for x , y in zip ( s1 , cd ) ] <NEWLINE> print ( s1_a . index ( max ( s1_a ) ) + 1 ) <NEWLINE> <DEDENT> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = n // i <NEWLINE> ans += x * ( x + 1 ) * i // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for ai in a : <NEWLINE> <INDENT> ans *= ai <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from functools import reduce <NEWLINE> def nCr ( n , r , DIV ) : <NEWLINE> <INDENT> if r < n - r : <NEWLINE> <INDENT> r = n - r <NEWLINE> <DEDENT> if r == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> f = lambda x , y : x * y % DIV <NEWLINE> X = reduce ( f , range ( n - r + 1 , n + 1 ) ) <NEWLINE> Y = reduce ( f , range ( 1 , r + 1 ) ) <NEWLINE> return X * pow ( Y , DIV - 2 , DIV ) % DIV <NEWLINE> <NL> <DEDENT> mod = pow ( 10 , 9 ) + 7 <NEWLINE> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> left , right = 0 , 0 <NEWLINE> a , b = max ( x , y ) , min ( x , y ) <NEWLINE> <NL> if ( 2 * b - a ) % 3 == 0 : <NEWLINE> <INDENT> d , s = a - b , ( 2 * b - a ) // 3 <NEWLINE> p , q = d + s , s <NEWLINE> print ( nCr ( p + q , p , mod ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <STRING> <NEWLINE> if abs ( ( x2 - x1 ) * ( y4 - y3 ) - ( x4 - x3 ) * ( y2 - y1 ) ) < 1e-10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> x , y , h = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( x , y , h ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> s = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> h = - 1 <NEWLINE> ok = 1 <NEWLINE> for t in s : <NEWLINE> <INDENT> if t [ 2 ] == 0 : <NEWLINE> <INDENT> ok += 1 <NEWLINE> <DEDENT> elif h == - 1 : <NEWLINE> <INDENT> h = abs ( t [ 0 ] - i ) + abs ( t [ 1 ] - j ) + t [ 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h0 = abs ( t [ 0 ] - i ) + abs ( t [ 1 ] - j ) + t [ 2 ] <NEWLINE> if h == h0 : <NEWLINE> <INDENT> ok += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ok == n : <NEWLINE> <INDENT> for t in s : <NEWLINE> <INDENT> if abs ( t [ 0 ] - i ) + abs ( t [ 1 ] - j ) <= h : <NEWLINE> <INDENT> if not h == abs ( t [ 0 ] - i ) + abs ( t [ 1 ] - j ) + t [ 2 ] : <NEWLINE> <INDENT> ok = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if not t [ 2 ] == 0 : <NEWLINE> <INDENT> ok = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ok == n : <NEWLINE> <INDENT> print ( i , j , h ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v = 1000 <NEWLINE> s = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + 1 ] : <NEWLINE> <INDENT> s = v // a [ i ] <NEWLINE> v += ( a [ i + 1 ] - a [ i ] ) * s <NEWLINE> <DEDENT> <DEDENT> print ( v ) <NEWLINE>
from itertools import permutations <NEWLINE> import copy <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> G = [ [ 0 ] * N for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> G [ a - 1 ] [ b - 1 ] = 1 <NEWLINE> G [ b - 1 ] [ a - 1 ] = 1 <NEWLINE> <NL> <DEDENT> ls = list ( permutations ( range ( 1 , N ) ) ) <NEWLINE> ans = 0 <NEWLINE> for l in ls : <NEWLINE> <INDENT> h = copy . deepcopy ( G ) <NEWLINE> cnt = 1 <NEWLINE> p = 0 <NEWLINE> for k in l : <NEWLINE> <INDENT> if h [ p ] [ k ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> p = k <NEWLINE> <DEDENT> <DEDENT> if cnt == N : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> t = int ( input ( ) ) <NEWLINE> for _ in range ( t ) : <NEWLINE> <INDENT> n , a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> memo = { 0 : 0 , 1 : d } <NEWLINE> <NL> def dfs ( m ) : <NEWLINE> <INDENT> if m in memo : <NEWLINE> <INDENT> return memo [ m ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res1 = m * d <NEWLINE> <NL> res2 = ( m % 2 ) * d + a + dfs ( m // 2 ) <NEWLINE> res3 = ( m % 3 ) * d + b + dfs ( m // 3 ) <NEWLINE> res4 = ( m % 5 ) * d + c + dfs ( m // 5 ) <NEWLINE> <NL> res5 = ( ( 2 - ( m % 2 ) ) % 2 ) * d + a + dfs ( <NEWLINE> <INDENT> ( m + ( 2 - ( m % 2 ) ) % 2 ) // 2 ) <NEWLINE> <DEDENT> res6 = ( ( 3 - ( m % 3 ) ) % 3 ) * d + b + dfs ( <NEWLINE> <INDENT> ( m + ( 3 - ( m % 3 ) ) % 3 ) // 3 ) <NEWLINE> <DEDENT> res7 = ( ( 5 - ( m % 5 ) ) % 5 ) * d + c + dfs ( <NEWLINE> <INDENT> ( m + ( 5 - ( m % 5 ) ) % 5 ) // 5 ) <NEWLINE> <NL> <DEDENT> memo [ m ] = min ( res1 , res2 , res3 , res4 , res5 , res6 , res7 ) <NEWLINE> return memo [ m ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = dfs ( n ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( A ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
import copy <NEWLINE> import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = v [ 0 : : 2 ] <NEWLINE> b = v [ 1 : : 2 ] <NEWLINE> <NL> cnta = np . zeros ( 10 ** 5 + 1 , dtype = int ) <NEWLINE> cntb = np . zeros ( 10 ** 5 + 1 , dtype = int ) <NEWLINE> for i in range ( n // 2 ) : <NEWLINE> <INDENT> ca , cb = a [ i ] , b [ i ] <NEWLINE> cnta [ ca ] += 1 <NEWLINE> cntb [ cb ] += 1 <NEWLINE> <NL> <DEDENT> la = np . zeros ( ( 2 , 2 ) , dtype = int ) <NEWLINE> lb = np . zeros ( ( 2 , 2 ) , dtype = int ) <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> ia = cnta . argmax ( ) <NEWLINE> ib = cntb . argmax ( ) <NEWLINE> la [ i ] [ 0 ] , la [ i ] [ 1 ] = ia , cnta [ ia ] <NEWLINE> lb [ i ] [ 0 ] , lb [ i ] [ 1 ] = ib , cntb [ ib ] <NEWLINE> cnta [ ia ] = 0 <NEWLINE> cntb [ ib ] = 0 <NEWLINE> <NL> <DEDENT> if la [ 0 ] [ 0 ] != lb [ 0 ] [ 0 ] : <NEWLINE> <INDENT> ans = n // 2 - la [ 0 ] [ 1 ] + n // 2 - lb [ 0 ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( n // 2 - la [ 0 ] [ 1 ] + n // 2 - lb [ 1 ] [ 1 ] , n // 2 - la [ 1 ] [ 1 ] + n // 2 - lb [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> num , k = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> mai = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> main = sorted ( mai , key = abs , reverse = True ) <NEWLINE> result = 1 <NEWLINE> def findplus_plus ( x ) : <NEWLINE> <INDENT> for i in range ( x , len ( main ) ) : <NEWLINE> <INDENT> if main [ i ] >= 0 : <NEWLINE> <INDENT> return main [ i ] <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <DEDENT> def findplus_minus ( x ) : <NEWLINE> <INDENT> for i in range ( x , len ( main ) ) : <NEWLINE> <INDENT> if main [ i ] < 0 : <NEWLINE> <INDENT> return main [ i ] <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <DEDENT> def findminus_plus ( x ) : <NEWLINE> <INDENT> for i in range ( x - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if main [ i ] >= 0 : <NEWLINE> <INDENT> return main [ i ] <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <DEDENT> def findminus_minus ( x ) : <NEWLINE> <INDENT> for i in range ( x - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if main [ i ] < 0 : <NEWLINE> <INDENT> return main [ i ] <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> if num == k : <NEWLINE> <INDENT> for i in main : <NEWLINE> <INDENT> result *= i <NEWLINE> result %= mod <NEWLINE> <DEDENT> <DEDENT> elif sorted ( main ) [ len ( sorted ( main ) ) - 1 ] < 0 : <NEWLINE> <INDENT> if ( k % 2 ) == 0 : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> result *= main [ i ] <NEWLINE> result %= mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( main ) - 1 , len ( main ) - 1 - k , - 1 ) : <NEWLINE> <INDENT> result *= main [ i ] <NEWLINE> result %= mod <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if main [ i ] < 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> result *= main [ i ] <NEWLINE> result %= mod <NEWLINE> <DEDENT> if ( count % 2 ) == 1 : <NEWLINE> <INDENT> minplus = findminus_plus ( k ) <NEWLINE> minminus = findminus_minus ( k ) <NEWLINE> maxplus = findplus_plus ( k ) <NEWLINE> maxminus = findplus_minus ( k ) <NEWLINE> if type ( maxplus ) == type ( <STRING> ) : <NEWLINE> <INDENT> plusplus = - 1 <NEWLINE> minusminus = minminus * maxminus <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if type ( maxminus ) == type ( <STRING> ) or type ( minplus ) == type ( <STRING> ) : <NEWLINE> <INDENT> minusminus = - 1 <NEWLINE> plusplus = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minusminus = minminus * maxminus <NEWLINE> plusplus = minplus * maxplus <NEWLINE> <DEDENT> <DEDENT> if plusplus > minusminus : <NEWLINE> <INDENT> main . remove ( minminus ) <NEWLINE> result = 1 <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> result *= main [ i ] <NEWLINE> result %= mod <NEWLINE> <DEDENT> result *= maxplus <NEWLINE> <DEDENT> elif plusplus <= minusminus : <NEWLINE> <INDENT> main . remove ( minplus ) <NEWLINE> result = 1 <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> result *= main [ i ] <NEWLINE> result %= mod <NEWLINE> <DEDENT> result *= maxminus <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for a in range ( 1 , n ) : <NEWLINE> <INDENT> cnt += ( ( n - 1 ) // a ) <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> chars = <STRING> <NEWLINE> <NL> n_rem = n <NEWLINE> res = <STRING> <NEWLINE> <NL> while True : <NEWLINE> <INDENT> x = n_rem % 26 <NEWLINE> <NL> if x == 0 : <NEWLINE> <INDENT> x = 26 <NEWLINE> <DEDENT> res += chars [ x ] <NEWLINE> <NL> <NL> n_rem -= x <NEWLINE> <NL> <NL> if n_rem == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> n_rem //= 26 <NEWLINE> <NL> <NL> <DEDENT> print ( res [ : : - 1 ] ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> Q = sys . stdin . readline ( ) <NEWLINE> for _ in range ( int ( Q ) ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> N = int ( sys . stdin . readline ( ) ) <NEWLINE> if N != 0 : <NEWLINE> <INDENT> digLeng = int ( math . log10 ( N ) ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> digLeng = 1 <NEWLINE> <DEDENT> while digLeng > 1 : <NEWLINE> <INDENT> Nmax = 0 <NEWLINE> for dig in range ( digLeng ) : <NEWLINE> <INDENT> lNum = N // int ( math . pow ( 10 , dig ) ) <NEWLINE> rNum = N % int ( math . pow ( 10 , dig ) ) <NEWLINE> Nmax = max ( Nmax , lNum * rNum ) <NEWLINE> <DEDENT> N = Nmax <NEWLINE> cnt += 1 <NEWLINE> if N != 0 : <NEWLINE> <INDENT> digLeng = int ( math . log10 ( N ) ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> digLeng = 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> <NL> if ( 0 in a ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> if x % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import numpy as np <NEWLINE> k = int ( input ( ) ) <NEWLINE> x = np . arange ( 1 , k + 1 ) <NEWLINE> <COMMENT> <NL> a = np . gcd . outer ( np . gcd . outer ( x , x ) , x ) <NEWLINE> print ( a . sum ( ) ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> t = 0 <NEWLINE> for i1 in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for i2 in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for i3 in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> t += gcd ( gcd ( i1 , i2 ) , i3 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
<COMMENT> <NL> distance = ( <NEWLINE> <INDENT> ( ) , <NEWLINE> ( 0 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 2 , 3 , 4 , 5 , 3 , 4 , 5 , 6 ) , <NEWLINE> ( 1 , 0 , 1 , 2 , 2 , 1 , 2 , 3 , 3 , 2 , 3 , 4 , 4 , 3 , 4 , 5 ) , <NEWLINE> ( 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 4 , 3 , 2 , 3 , 5 , 4 , 3 , 4 ) , <NEWLINE> ( 3 , 2 , 1 , 0 , 4 , 3 , 2 , 1 , 5 , 4 , 3 , 2 , 6 , 5 , 4 , 3 ) , <NEWLINE> ( 1 , 2 , 3 , 4 , 0 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 2 , 3 , 4 , 5 ) , <NEWLINE> ( 2 , 1 , 2 , 3 , 1 , 0 , 1 , 2 , 2 , 1 , 2 , 3 , 3 , 2 , 3 , 4 ) , <NEWLINE> ( 3 , 2 , 1 , 2 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 4 , 3 , 2 , 3 ) , <NEWLINE> ( 4 , 3 , 2 , 1 , 3 , 2 , 1 , 0 , 4 , 3 , 2 , 1 , 5 , 4 , 3 , 2 ) , <NEWLINE> ( 2 , 3 , 4 , 5 , 1 , 2 , 3 , 4 , 0 , 1 , 2 , 3 , 1 , 2 , 3 , 4 ) , <NEWLINE> ( 3 , 2 , 3 , 4 , 2 , 1 , 2 , 3 , 1 , 0 , 1 , 2 , 2 , 1 , 2 , 3 ) , <NEWLINE> ( 4 , 3 , 2 , 3 , 3 , 2 , 1 , 2 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 ) , <NEWLINE> ( 5 , 4 , 3 , 2 , 4 , 3 , 2 , 1 , 3 , 2 , 1 , 0 , 4 , 3 , 2 , 1 ) , <NEWLINE> ( 3 , 4 , 5 , 6 , 2 , 3 , 4 , 5 , 1 , 2 , 3 , 4 , 0 , 1 , 2 , 3 ) , <NEWLINE> ( 4 , 3 , 4 , 5 , 3 , 2 , 3 , 4 , 2 , 1 , 2 , 3 , 1 , 0 , 1 , 2 ) , <NEWLINE> ( 5 , 4 , 3 , 4 , 4 , 3 , 2 , 3 , 3 , 2 , 1 , 2 , 2 , 1 , 0 , 1 ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> def get_distance ( board ) : <NEWLINE> <INDENT> sd = 0 <NEWLINE> for i in range ( 16 ) : <NEWLINE> <INDENT> p = board [ i ] <NEWLINE> if p == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> sd += distance [ p ] [ i ] <NEWLINE> <DEDENT> return sd <NEWLINE> <NL> <DEDENT> adjacent = ( <NEWLINE> <INDENT> ( 1 , 4 ) , <COMMENT> <NEWLINE> ( 0 , 2 , 5 ) , <COMMENT> <NEWLINE> ( 1 , 3 , 6 ) , <COMMENT> <NEWLINE> ( 2 , 7 ) , <COMMENT> <NEWLINE> ( 0 , 5 , 8 ) , <COMMENT> <NEWLINE> ( 1 , 4 , 6 , 9 ) , <COMMENT> <NEWLINE> ( 2 , 5 , 7 , 10 ) , <COMMENT> <NEWLINE> ( 3 , 6 , 11 ) , <COMMENT> <NEWLINE> ( 4 , 9 , 12 ) , <COMMENT> <NEWLINE> ( 5 , 8 , 10 , 13 ) , <COMMENT> <NEWLINE> ( 6 , 9 , 11 , 14 ) , <COMMENT> <NEWLINE> ( 7 , 10 , 15 ) , <COMMENT> <NEWLINE> ( 8 , 13 ) , <COMMENT> <NEWLINE> ( 9 , 12 , 14 ) , <COMMENT> <NEWLINE> ( 10 , 13 , 15 ) , <COMMENT> <NEWLINE> ( 11 , 14 ) <COMMENT> <NEWLINE> <DEDENT> ) <NEWLINE> <NL> GOAL = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 0 ] <NEWLINE> <NL> import sys <NEWLINE> import heapq <NEWLINE> <NL> <COMMENT> <NL> def solve ( ) : <NEWLINE> <INDENT> board = list ( map ( int , sys . stdin . read ( ) . split ( ) ) ) <NEWLINE> h_cost = get_distance ( board ) <NEWLINE> state = ( h_cost , board ) <NEWLINE> <NL> q = [ state ] <COMMENT> <NEWLINE> d = { tuple ( board ) : True } <NEWLINE> <NL> while q : <NEWLINE> <INDENT> state1 = heapq . heappop ( q ) <NEWLINE> h_cost , board = state1 <NEWLINE> if board == GOAL : <NEWLINE> <INDENT> return h_cost <NEWLINE> <DEDENT> space = board . index ( 0 ) <NEWLINE> for i in adjacent [ space ] : <NEWLINE> <INDENT> p = board [ i ] <NEWLINE> new_board = board [ : ] <NEWLINE> new_board [ space ] , new_board [ i ] = p , 0 <NEWLINE> new_h_cost = h_cost + 1 - distance [ p ] [ i ] + distance [ p ] [ space ] <NEWLINE> <NL> key = tuple ( new_board ) <NEWLINE> if key not in d and new_h_cost <= 45 : <NEWLINE> <INDENT> new_state = ( new_h_cost , new_board ) <NEWLINE> heapq . heappush ( q , new_state ) <NEWLINE> d [ key ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( solve ( ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <COMMENT> <NL> def int1 ( x ) : return int ( x ) - 1 <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MI1 ( ) : return map ( int1 , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LI1 ( ) : return list ( map ( int1 , input ( ) . split ( ) ) ) <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def MS ( ) : return input ( ) . split ( ) <NEWLINE> def LS ( ) : return list ( input ( ) ) <NEWLINE> def LLS ( rows_number ) : return [ LS ( ) for _ in range ( rows_number ) ] <NEWLINE> def printlist ( lst , k = <STRING> ) : print ( k . join ( list ( map ( str , lst ) ) ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> from itertools import combinations as comb , combinations_with_replacement as comb_w , accumulate , product , permutations <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from bisect import bisect_right , bisect_left <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> N , M , K = MI ( ) <NEWLINE> A = LI ( ) <NEWLINE> B = LI ( ) <NEWLINE> A = [ 0 ] + list ( accumulate ( A ) ) <NEWLINE> B = [ 0 ] + list ( accumulate ( B ) ) <NEWLINE> <NL> def is_ok ( arg , a ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> return B [ arg ] <= K - a <NEWLINE> <NL> <DEDENT> def meguru_bisect ( ng , ok , a ) : <NEWLINE> <INDENT> while ( abs ( ok - ng ) > 1 ) : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if is_ok ( mid , a ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> idx = meguru_bisect ( M + 1 , - 1 , a ) <NEWLINE> if 0 <= idx <= M : <NEWLINE> <INDENT> ans = max ( ans , i + idx ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , data = input_data ( ) <NEWLINE> vMax = float ( <STRING> ) <NEWLINE> vMin = data . pop ( 0 ) <NEWLINE> <NL> for Rj in data : <NEWLINE> <INDENT> if vMax < Rj - vMin : <NEWLINE> <INDENT> vMax = Rj - vMin <NEWLINE> <DEDENT> if vMin > Rj : <NEWLINE> <INDENT> vMin = Rj <NEWLINE> <NL> <DEDENT> <DEDENT> print ( vMax ) <NEWLINE> <NL> <DEDENT> def input_data ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> lst = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> return ( n , lst ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> M *= A [ i ] <NEWLINE> if M > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if M > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( M ) ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> L = [ set ( ) for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> L [ a - 1 ] |= { b } <NEWLINE> L [ b - 1 ] |= { a } <NEWLINE> <DEDENT> Y = { range ( 1 , n + 1 ) } <NEWLINE> Z = [ 0 ] * ( n - 1 ) <NEWLINE> S = { 1 } <NEWLINE> def f ( X ) : <NEWLINE> <INDENT> global S , Z <NEWLINE> X_next = set ( ) <NEWLINE> for j in X : <NEWLINE> <INDENT> R = L [ j - 1 ] - S <NEWLINE> S |= L [ j - 1 ] <NEWLINE> X_next |= R <NEWLINE> for k in R : <NEWLINE> <INDENT> Z [ k - 2 ] += j <NEWLINE> <DEDENT> <DEDENT> if X_next == set ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , Z ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return f ( X_next ) <NEWLINE> <DEDENT> <DEDENT> f ( { 1 } ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> l = 0 <NEWLINE> r = n - 1 <NEWLINE> ans = 0 <NEWLINE> while r > l : <NEWLINE> <NL> <INDENT> while r > l : <NEWLINE> <INDENT> if s [ l ] == <STRING> : break <NEWLINE> else : l += 1 <NEWLINE> <DEDENT> while r > l : <NEWLINE> <INDENT> if s [ r ] == <STRING> : break <NEWLINE> else : r -= 1 <NEWLINE> <DEDENT> if r > l : <NEWLINE> <INDENT> ans += 1 <NEWLINE> r -= 1 <NEWLINE> l += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> d = int ( input ( ) ) <NEWLINE> C = np . array ( list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) ) <NEWLINE> S = np . array ( [ list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) for i in range ( d ) ] ) <NEWLINE> <NL> D = np . zeros ( 26 ) <NEWLINE> s_d = np . zeros ( d ) <NEWLINE> W = np . ones ( 26 ) + C / 100 <NEWLINE> out = np . zeros ( d ) <NEWLINE> t = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> day = i + 1 <NEWLINE> temp_score = 0 <NEWLINE> con = 0 <NEWLINE> d_l = [ day ] * 26 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> score = S [ i ] [ j ] <NEWLINE> score -= sum ( ( d_l - D ) * C ) <NEWLINE> score += ( day - D [ j ] ) * C [ j ] * W [ j ] <NEWLINE> if score > temp_score : <NEWLINE> <INDENT> con = j <NEWLINE> temp_score = score <NEWLINE> <DEDENT> <DEDENT> out [ i ] = con + 1 <NEWLINE> D [ con ] = i + 1 <NEWLINE> t += temp_score <NEWLINE> s_d [ i ] = t <NEWLINE> W = W * 1.1 <NEWLINE> W [ j ] = W [ j ] * 0.9 <NEWLINE> <DEDENT> for i in out : <NEWLINE> <INDENT> print ( int ( i ) ) <NEWLINE> <DEDENT>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> target_points = { tuple ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) for _ in range ( m ) } <NEWLINE> <NL> row_points = [ 0 ] * h <NEWLINE> col_points = [ 0 ] * w <NEWLINE> for row , col in target_points : <NEWLINE> <INDENT> row_points [ row ] += 1 <NEWLINE> col_points [ col ] += 1 <NEWLINE> <NL> <DEDENT> row_max = max ( row_points ) <NEWLINE> col_max = max ( col_points ) <NEWLINE> <NL> row_max_indexes = [ i for i in range ( h ) if row_points [ i ] == row_max ] <NEWLINE> col_max_indexes = [ i for i in range ( w ) if col_points [ i ] == col_max ] <NEWLINE> <NL> empty_crossing_exist = False <NEWLINE> for row in row_max_indexes : <NEWLINE> <INDENT> for col in col_max_indexes : <NEWLINE> <INDENT> if ( row , col ) not in target_points : <NEWLINE> <INDENT> empty_crossing_exist = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if empty_crossing_exist : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( row_max + col_max - ( not empty_crossing_exist ) ) <NEWLINE>
<NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 1 if H == 1 or W == 1 else ( H * W + 1 ) // 2 <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL>
from collections import Counter <NEWLINE> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> A = [ 0 ] * ( ( n : = len ( S ) ) + 1 ) <NEWLINE> A [ 1 ] = ( a : = int ( S [ - 1 ] ) ) % 2019 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> a += pow ( 10 , i - 1 , 2019 ) * int ( S [ - i ] ) <NEWLINE> A [ i ] = a % 2019 <NEWLINE> <DEDENT> c = Counter ( A ) <NEWLINE> ans = 0 <NEWLINE> for v in c . values ( ) : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = input ( ) . split ( ) <NEWLINE> X = int ( N [ 0 ] ) <NEWLINE> Y = int ( N [ 1 ] ) <NEWLINE> <NL> flag = False <NEWLINE> <NL> for i in range ( X ) : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if ( X - i ) * 2 + i * 4 == Y : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> if ( X - i ) * 4 + i * 2 == Y : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> f = [ ] <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> s = math . gcd ( i , j ) <NEWLINE> f . append ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> S = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in f : <NEWLINE> <INDENT> S += math . gcd ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ float ( <STRING> ) ] * n <NEWLINE> <NL> dp [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ j ] + abs ( h [ i ] - h [ j ] ) for j in range ( max ( 0 , i - k ) , i ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ ] <NEWLINE> for i in range ( a , a + k ) : <NEWLINE> <INDENT> if i > b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> lst . append ( i ) <NEWLINE> print ( i ) <NEWLINE> <DEDENT> for i in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> if i < a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if not i in lst : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( input ( ) . split ( ) ) <NEWLINE> <NL> l = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> for i in a : <NEWLINE> <INDENT> l [ int ( i ) ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( l [ j ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> mul = 1 <NEWLINE> if 0 in a_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if mul > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mul *= a_list [ i ] <NEWLINE> <DEDENT> <DEDENT> if mul <= 10 ** 18 : <NEWLINE> <INDENT> print ( mul ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> V = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a = a - 1 <NEWLINE> b = b - 1 <NEWLINE> V [ a ] . append ( b ) <NEWLINE> V [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> <NL> q = deque ( [ 0 ] ) <NEWLINE> <NL> ans = [ - 1 ] * N <NEWLINE> ans [ 0 ] = 0 <NEWLINE> <NL> while q : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for nv in V [ v ] : <NEWLINE> <INDENT> if ans [ nv ] == - 1 : <NEWLINE> <INDENT> ans [ nv ] = v + 1 <NEWLINE> q . append ( nv ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * ans [ 1 : ] , sep = <STRING> ) <NEWLINE>
from collections import Counter <NEWLINE> s = input ( ) <NEWLINE> a = [ 0 ] <NEWLINE> mod = 2019 <NEWLINE> for i , j in enumerate ( s [ : : - 1 ] ) : <NEWLINE> <INDENT> a . append ( a [ - 1 ] + int ( j ) * pow ( 10 , i , mod ) ) <NEWLINE> a [ - 1 ] %= mod <NEWLINE> <DEDENT> b = Counter ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in b . values ( ) : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> n1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in n1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> sum = 1 <NEWLINE> for i in n1 : <NEWLINE> <INDENT> sum *= i <NEWLINE> if sum > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dec = 10 ** 18 <NEWLINE> Ans = 1 <NEWLINE> <COMMENT> <NL> if ( 0 in L ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in L : <NEWLINE> <INDENT> Ans = Ans * i <NEWLINE> if dec < Ans : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( Ans ) <NEWLINE> <DEDENT> <DEDENT>
import networkx as nx <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> S = [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> G = nx . DiGraph ( ) <NEWLINE> <NL> start = ( n , m ) <NEWLINE> cnt = 0 <NEWLINE> goal = ( n , m + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> if S [ i ] [ j ] != <STRING> : <NEWLINE> <INDENT> if S [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> G . add_edge ( start , ( i , j ) , capacity = 1 ) <NEWLINE> <DEDENT> if i + 1 < n : <NEWLINE> <INDENT> if S [ i + 1 ] [ j ] != <STRING> : <NEWLINE> <INDENT> G . add_edge ( ( i , j ) , ( i + 1 , j ) , weight = - 1 ) <NEWLINE> <DEDENT> <DEDENT> if j + 1 < m : <NEWLINE> <INDENT> if S [ i ] [ j + 1 ] != <STRING> : <NEWLINE> <INDENT> G . add_edge ( ( i , j ) , ( i , j + 1 ) , weight = - 1 ) <NEWLINE> <DEDENT> <DEDENT> G . add_edge ( ( i , j ) , goal , capacity = 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> mincostflow = nx . max_flow_min_cost ( G , start , goal ) <NEWLINE> ans = nx . cost_of_flow ( G , mincostflow ) <NEWLINE> print ( abs ( ans ) ) <NEWLINE>
import queue <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> e = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> e [ A ] . append ( B ) <NEWLINE> e [ B ] . append ( A ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> seen = [ - 1 ] * N <NEWLINE> k = - 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if seen [ i ] == - 1 : <NEWLINE> <INDENT> k += 1 <NEWLINE> seen [ i ] = k <NEWLINE> que = queue . Queue ( ) <NEWLINE> que . put ( i ) <NEWLINE> while not que . empty ( ) : <NEWLINE> <INDENT> v = que . get ( ) <NEWLINE> for nv in e [ v ] : <NEWLINE> <INDENT> if seen [ nv ] != - 1 : continue <NEWLINE> seen [ nv ] = k <NEWLINE> que . put ( nv ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( k ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = collections . Counter ( ) <COMMENT> <NEWLINE> n = collections . Counter ( ) <COMMENT> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> p [ i + A [ i ] ] += 1 <NEWLINE> n [ i - A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in p . keys ( ) : <NEWLINE> <INDENT> ans += p [ i ] * n [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if not ( s in d ) : d [ s ] = 1 <NEWLINE> <NL> <DEDENT> print ( len ( d ) ) <NEWLINE> <NL>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> number = list ( range ( 0 , 102 ) ) <NEWLINE> min = 100 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> number . remove ( s [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( 102 - n ) : <NEWLINE> <INDENT> if min > abs ( x - number [ i ] ) : <NEWLINE> <INDENT> min = abs ( x - number [ i ] ) <NEWLINE> j = i <NEWLINE> <DEDENT> <DEDENT> print ( number [ j ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> <NL> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> <NL> <NL> ans = r * g * b <NEWLINE> dib = 0 <NEWLINE> m = 0 <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> m = ( N + i ) // 2 + 1 <NEWLINE> for j in range ( i + 1 , m ) : <NEWLINE> <INDENT> dib = j - i <NEWLINE> if j + dib <= N - 1 : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ i ] != S [ j + dib ] and S [ j ] != S [ j + dib ] : <NEWLINE> <INDENT> ans = ans - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <COMMENT> <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> multip_K = [ i for i in range ( K , N + 1 , K ) ] <NEWLINE> <NL> <COMMENT> <NL> le = len ( multip_K ) <NEWLINE> ans_mod_0 = le ** 3 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> ans_mod_haf = 0 <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> multip_haf = [ i for i in range ( 1 , N + 1 ) if i % K == K // 2 ] <NEWLINE> le_haf = len ( multip_haf ) <NEWLINE> ans_mod_haf = le_haf ** 3 <NEWLINE> <NL> <DEDENT> ans = ans_mod_0 + ans_mod_haf <NEWLINE> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if n > k : <NEWLINE> <INDENT> n = n - ( n // k ) * k <NEWLINE> <DEDENT> while n > abs ( k - n ) : <NEWLINE> <INDENT> n = abs ( k - n ) <NEWLINE> <DEDENT> print ( n ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 10 ** 18 <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <NL> ans = 1 <NEWLINE> if 0 in a_lst : <NEWLINE> <COMMENT> <NL> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a_lst [ i ] <NEWLINE> if ans > x : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> a = 0 <NEWLINE> m = { } <NEWLINE> d = 1 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> b = int ( s [ len ( s ) - 1 - i ] ) * d + a <NEWLINE> b = b % 2019 <NEWLINE> a = b <NEWLINE> d = d * 10 % 2019 <NEWLINE> if b in m : <NEWLINE> <INDENT> m [ b ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m [ b ] = 1 <NEWLINE> <DEDENT> <DEDENT> if 0 in m : <NEWLINE> <INDENT> sum = m [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum = 0 <NEWLINE> <DEDENT> for i in m : <NEWLINE> <INDENT> sum += m [ i ] * ( m [ i ] - 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( sum ) ) <NEWLINE> <NL>
from sys import stdin <NEWLINE> nii = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> lnii = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> h , w , d = nii ( ) <NEWLINE> <NL> a_dict = { } <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> a = lnii ( ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> a_dict [ a [ j ] ] = ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> b_dict = { } <NEWLINE> for i in range ( 1 , h * w + 1 ) : <NEWLINE> <INDENT> if i - d <= 0 : <NEWLINE> <INDENT> b_dict [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> oy , ox = a_dict [ i - d ] <NEWLINE> ny , nx = a_dict [ i ] <NEWLINE> b_dict [ i ] = b_dict [ i - d ] + abs ( ny - oy ) + abs ( nx - ox ) <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> l , r = nii ( ) <NEWLINE> ans = b_dict [ r ] - b_dict [ l ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
<NL> from copy import copy <NEWLINE> N = int ( input ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> di = [ - 1 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ u - 1 ] . append ( [ v - 1 , w ] ) <NEWLINE> G [ v - 1 ] . append ( [ u - 1 , w ] ) <NEWLINE> <NL> <DEDENT> di [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if di [ i ] != - 1 : continue <NEWLINE> seen = [ 0 ] * N <NEWLINE> stack = [ [ 0 , 0 ] ] <NEWLINE> while stack : <NEWLINE> <INDENT> y , d = stack . pop ( ) <NEWLINE> if seen [ y ] == 1 : continue <NEWLINE> seen [ y ] = 1 <NEWLINE> for z , dist in G [ y ] : <NEWLINE> <INDENT> if seen [ z ] == 0 : <NEWLINE> <INDENT> di [ z ] = d + dist <NEWLINE> stack . append ( [ z , d + dist ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if di [ i ] % 2 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> n = input ( ) <NEWLINE> data = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> over = False <NEWLINE> zero = False <NEWLINE> <NL> if 0 in data : <NEWLINE> <INDENT> zero = True <NEWLINE> <NL> <DEDENT> for num in data : <NEWLINE> <INDENT> ans *= num <NEWLINE> if ( ans > 1000000000000000000 ) : <NEWLINE> <INDENT> over = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 1000000000000000000 : <NEWLINE> <INDENT> over = True <NEWLINE> <NL> <DEDENT> if zero : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif over : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> temp = gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( temp , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . par = [ - 1 ] * ( n + 1 ) <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . par [ x ] > self . par [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . par [ x ] += self . par [ y ] <NEWLINE> self . par [ y ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> ans = - min ( uf . par ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> a = i + 1 <NEWLINE> for j in range ( num ) : <NEWLINE> <INDENT> b = j + 1 <NEWLINE> for k in range ( num ) : <NEWLINE> <INDENT> c = k + 1 <NEWLINE> sum += math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> print ( 6 - A - B ) <NEWLINE>
s = input ( ) . split ( ) ; <NEWLINE> a = int ( s [ 0 ] ) ; <NEWLINE> b = int ( s [ 1 ] ) ; <NEWLINE> c = int ( s [ 2 ] ) ; <NEWLINE> k = int ( s [ 3 ] ) ; <NEWLINE> max = 0 ; <NEWLINE> x = a ; <NEWLINE> if ( ( a - k ) >= 0 ) : <NEWLINE> <INDENT> max = k ; <NEWLINE> <DEDENT> elif ( ( a + b - k ) >= 0 ) : <NEWLINE> <INDENT> max = a ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = k - ( a + b ) ; <NEWLINE> max = - k ; <NEWLINE> max = max + a ; <NEWLINE> <NL> <DEDENT> print ( max ) ; <NEWLINE>
MAX = pow ( 10 , 18 ) <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > MAX : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ * input ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> from collections import * <NEWLINE> d = defaultdict ( list ) <NEWLINE> from bisect import * <NEWLINE> for i , c in enumerate ( s ) : <NEWLINE> <INDENT> d [ c ] += [ i ] <NEWLINE> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> x , y , z = input ( ) . split ( ) <NEWLINE> y = int ( y ) - 1 <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> if s [ y ] == z : continue <NEWLINE> d [ s [ y ] ] . pop ( bisect ( d [ s [ y ] ] , y ) - 1 ) <NEWLINE> s [ y ] = z <NEWLINE> insort ( d [ z ] , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> for l in d . values ( ) : <NEWLINE> <INDENT> if bisect ( l , int ( z ) - 1 ) - bisect_left ( l , y ) : a += 1 <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> print ( <STRING> if n % 9 == 0 else <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> d = len ( S ) - len ( T ) <NEWLINE> print ( len ( T ) - max ( sum ( t == s for t , s in zip ( T , S [ i : i + len ( T ) + 1 ] ) ) for i in range ( d + 1 ) ) ) <NEWLINE>
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a , b = abs ( x2 - x1 ) , abs ( y1 - y2 ) <NEWLINE> <NL> if ( x1 <= x2 ) and ( y1 <= y2 ) : <NEWLINE> <INDENT> x3 , y3 = x2 - b , y2 + a <NEWLINE> x4 , y4 = x3 - a , y3 - b <NEWLINE> <DEDENT> elif ( x1 >= x2 ) and ( y1 <= y2 ) : <NEWLINE> <INDENT> x3 , y3 = x2 - b , y2 - a <NEWLINE> x4 , y4 = x3 + a , y3 - b <NEWLINE> <DEDENT> elif ( x1 >= x2 ) and ( y1 >= y2 ) : <NEWLINE> <INDENT> x3 , y3 = x2 + b , y2 - a <NEWLINE> x4 , y4 = x3 + a , y3 + b <NEWLINE> <DEDENT> elif ( x1 <= x2 ) and ( y1 >= y2 ) : <NEWLINE> <INDENT> x3 , y3 = x2 + b , y2 + a <NEWLINE> x4 , y4 = x3 - a , y3 + b <NEWLINE> <NL> <DEDENT> print ( x3 , y3 , x4 , y4 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> li_X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> li_X . sort ( ) <NEWLINE> li_X_delta = [ ] <NEWLINE> for i in range ( len ( li_X ) - 1 ) : <NEWLINE> <INDENT> li_X_delta . append ( li_X [ i + 1 ] - li_X [ i ] ) <NEWLINE> <DEDENT> li_X_delta . sort ( reverse = True ) <NEWLINE> cnt = 0 <NEWLINE> <NL> ans = li_X [ - 1 ] - li_X [ 0 ] <NEWLINE> for i in range ( min ( n - 1 , len ( li_X_delta ) ) ) : <NEWLINE> <INDENT> ans -= li_X_delta [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<NL> import bisect <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> <NL> def LIS ( lis ) : <NEWLINE> <NL> <INDENT> seq = [ ] <NEWLINE> <NL> for c in lis : <NEWLINE> <INDENT> ind = bisect . bisect_left ( seq , c ) <NEWLINE> <NL> if ind == len ( seq ) : <NEWLINE> <INDENT> seq . append ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> seq [ ind ] = c <NEWLINE> <NL> <DEDENT> <DEDENT> return len ( seq ) <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lis = [ [ ] for i in range ( N ) ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <NL> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> <NL> lis [ u ] . append ( v ) <NEWLINE> lis [ v ] . append ( u ) <NEWLINE> <NL> <DEDENT> ans = [ None ] * N <NEWLINE> <NL> def dfs ( v , p , ln ) : <NEWLINE> <NL> <INDENT> ind = bisect . bisect_left ( ln , a [ v ] ) <NEWLINE> <NL> if ind == len ( ln ) : <NEWLINE> <INDENT> mt = None <NEWLINE> ln . append ( a [ v ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mt = ln [ ind ] <NEWLINE> ln [ ind ] = a [ v ] <NEWLINE> <NL> <DEDENT> ans [ v ] = len ( ln ) <NEWLINE> <NL> for nex in lis [ v ] : <NEWLINE> <NL> <INDENT> if nex != p : <NEWLINE> <INDENT> dfs ( nex , v , ln ) <NEWLINE> <NL> <DEDENT> <DEDENT> if mt == None : <NEWLINE> <INDENT> del ln [ - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ln [ ind ] = mt <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <DEDENT> dfs ( 0 , 0 , [ ] ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <DEDENT>
def bit_set ( num : int , n : int ) : <NEWLINE> <INDENT> if num & ( 1 << n ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ca_list = [ list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <INDENT> for nesya in range ( n ) ] <NEWLINE> <DEDENT> c = - 1 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> skill = [ 0 ] * m <NEWLINE> cost = 0 <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> if bit_set ( i , k ) == True : <NEWLINE> <INDENT> ca = ca_list [ k ] <NEWLINE> cost += ca [ 0 ] <NEWLINE> a = ca [ 1 : ] <NEWLINE> skill = [ j + l for ( j , l ) in zip ( skill , a ) ] <NEWLINE> <DEDENT> <DEDENT> if all ( ( hoge >= x ) for hoge in skill ) : <NEWLINE> <INDENT> if c == - 1 : <NEWLINE> <INDENT> c = cost <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = min ( c , cost ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> xx = ( x2 - x1 ) ** 2 <NEWLINE> yy = ( y2 - y1 ) ** 2 <NEWLINE> print ( math . sqrt ( xx + yy ) ) <NEWLINE>
<COMMENT> <NL> <NL> K = int ( input ( ) ) <NEWLINE> ans = - 1 <NEWLINE> if K == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> elif K == 2 or K == 5 or K == 10 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> p = ( p * 10 + 7 ) % K <NEWLINE> <COMMENT> <NL> if p == 0 : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Asum = [ 0 ] * N <NEWLINE> Asum [ 0 ] = A [ N - 1 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> Asum [ i ] = Asum [ i - 1 ] + A [ N - 1 - i ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += ( A [ i ] * Asum [ N - 2 - i ] ) % mod <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> S = set ( [ 1 ] ) <NEWLINE> for i in range ( 2 , X ) : <NEWLINE> <INDENT> b = 2 <NEWLINE> while ( i ** b <= X ) : <NEWLINE> <INDENT> S . add ( i ** b ) <NEWLINE> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( S ) <NEWLINE> print ( ans ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 for i in range ( k ) ] <NEWLINE> ans = 0 <NEWLINE> M = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( k , 0 , - 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> b = pow ( k // i , n , M ) <NEWLINE> for j in range ( i * 2 , k + 1 , i ) : <NEWLINE> <INDENT> b -= l [ j - 1 ] <NEWLINE> <DEDENT> l [ i - 1 ] = b % M <NEWLINE> <NL> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += i * l [ i - 1 ] <NEWLINE> <NL> <DEDENT> print ( ans % M ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> SC = [ input ( ) . split ( ) for _ in range ( M ) ] <NEWLINE> ans = [ <STRING> ] * N <NEWLINE> for s , c in SC : <NEWLINE> <INDENT> if ans [ int ( s ) - 1 ] != <STRING> and ans [ int ( s ) - 1 ] != c : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if N > 1 and s == <STRING> and c == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans [ int ( s ) - 1 ] = c <NEWLINE> <DEDENT> if ans [ 0 ] == <STRING> and N > 1 : <NEWLINE> <INDENT> ans [ 0 ] = <STRING> <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
line = input ( ) <NEWLINE> <NL> strL = line . split ( ) <NEWLINE> X = abs ( int ( strL [ 0 ] ) ) <NEWLINE> K = int ( strL [ 1 ] ) <NEWLINE> D = int ( strL [ 2 ] ) <NEWLINE> <NL> mod = X % D <NEWLINE> div = int ( X / D ) <NEWLINE> <NL> if div > K : <NEWLINE> <INDENT> ans = X - K * D <NEWLINE> <DEDENT> elif ( K - div ) % 2 != 0 : <NEWLINE> <INDENT> ans = mod - D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = mod <NEWLINE> <NL> <DEDENT> print ( abs ( int ( ans ) ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> ( n , q ) = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ i for i in range ( n ) ] <NEWLINE> dq = [ deque ( ) for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dq [ i ] . append ( i ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> ( a , b , c ) = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if a == 0 : <NEWLINE> <INDENT> sb = s [ b ] <NEWLINE> sc = s [ c ] <NEWLINE> if sb == sc : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dq [ sb ] . extend ( dq [ sc ] ) <NEWLINE> dq [ sc ] = None <NEWLINE> for j in dq [ sb ] : <NEWLINE> <INDENT> s [ j ] = sb <NEWLINE> <DEDENT> <DEDENT> elif a == 1 : <NEWLINE> <INDENT> if c in dq [ s [ b ] ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = sorted ( A ) <NEWLINE> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if a == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in lst : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> res = 1 <NEWLINE> for a in lst : <NEWLINE> <INDENT> res = res * a <NEWLINE> if res > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import copy <NEWLINE> from functools import lru_cache <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> @ njit <NEWLINE> def func ( A ) : <NEWLINE> <COMMENT> <NL> <INDENT> B = np . zeros_like ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l = max ( 0 , i - A [ i ] ) <NEWLINE> r = min ( i + A [ i ] , N - 1 ) <NEWLINE> B [ l ] += 1 <NEWLINE> if r + 1 < N : <NEWLINE> <INDENT> B [ r + 1 ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> B = np . cumsum ( B ) <NEWLINE> return B <NEWLINE> <NL> <DEDENT> for k in range ( K ) : <NEWLINE> <COMMENT> <NL> <INDENT> A = func ( A ) <NEWLINE> if k >= 50 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> ans . append ( a * c ) <NEWLINE> ans . append ( b * c ) <NEWLINE> ans . append ( a * d ) <NEWLINE> ans . append ( b * d ) <NEWLINE> <NL> print ( max ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> w = tuple ( x ) <NEWLINE> x . sort ( ) <NEWLINE> if x [ ( n // 2 ) - 1 ] == x [ n // 2 ] : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( x [ n // 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for h in w : <NEWLINE> <INDENT> if h <= x [ ( n // 2 ) - 1 ] : <NEWLINE> <INDENT> print ( x [ n // 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x [ ( n // 2 ) - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> iro = [ - 1 for i in range ( 2 * ( 10 ** 5 ) + 1 ) ] <NEWLINE> dp = [ 1 for i in range ( n + 1 ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] <NEWLINE> now = int ( input ( ) ) <NEWLINE> if iro [ now ] != - 1 and iro [ now ] != i - 1 : <NEWLINE> <INDENT> dp [ i ] += dp [ iro [ now ] ] <NEWLINE> <DEDENT> iro [ now ] = i <NEWLINE> dp [ i ] %= mod <NEWLINE> <DEDENT> print ( dp [ n ] ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> num_0 = S . count ( <STRING> ) <NEWLINE> num_1 = S . count ( <STRING> ) <NEWLINE> <NL> print ( min ( num_0 , num_1 ) * 2 ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , numpy , string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> sl = list ( S ) <NEWLINE> setS = set ( S ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> if str ( i ) not in setS : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i100_ind = sl . index ( str ( i ) ) <NEWLINE> S10 = sl [ i100_ind + 1 : - 1 ] <NEWLINE> S10set = set ( S10 ) <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> if str ( j ) not in S10set : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i10_ind = S10 . index ( str ( j ) ) <NEWLINE> S1 = S10 [ i10_ind + 1 : ] <NEWLINE> S1 . append ( sl [ - 1 ] ) <NEWLINE> ans += len ( set ( S1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from bisect import bisect <NEWLINE> from sys import setrecursionlimit <NEWLINE> <NL> setrecursionlimit ( 10000000 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> adj = [ list ( ) for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> adj [ a ] . append ( b ) <NEWLINE> adj [ b ] . append ( a ) <NEWLINE> <NL> <NL> <DEDENT> res = [ None ] * N <NEWLINE> dp = [ float ( <STRING> ) for _ in range ( N ) ] <NEWLINE> <NL> def rec ( v , ml ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> a = A [ v ] <NEWLINE> i = bisect ( dp , a - 1 ) <NEWLINE> ml += int ( ml == i ) <NEWLINE> res [ v ] = ml <NEWLINE> <NL> orig = dp [ i ] <NEWLINE> dp [ i ] = a <NEWLINE> for u in adj [ v ] : <NEWLINE> <INDENT> if res [ u ] is None : <NEWLINE> <INDENT> rec ( u , ml ) <NEWLINE> <DEDENT> <DEDENT> dp [ i ] = orig <NEWLINE> <NL> <DEDENT> rec ( 0 , 0 ) <NEWLINE> <NL> print ( * res , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> a -= 1 <NEWLINE> b -= 1 <NEWLINE> wide = 100 <NEWLINE> <NL> ans1 = [ [ <STRING> ] * wide for i in range ( wide // 2 ) ] <NEWLINE> <NL> ans2 = [ [ <STRING> ] * wide for i in range ( wide // 2 ) ] <NEWLINE> <NL> index_x = 0 <NEWLINE> index_y = 0 <NEWLINE> while ( a > 0 ) : <NEWLINE> <INDENT> ans1 [ index_y ] [ index_x ] = <STRING> <NEWLINE> index_x += 2 <NEWLINE> if index_x == wide : <NEWLINE> <INDENT> index_x = 0 <NEWLINE> index_y += 2 <NEWLINE> <DEDENT> a -= 1 <NEWLINE> <NL> <NL> <DEDENT> index_x = 0 <NEWLINE> index_y = 1 <NEWLINE> a = b <NEWLINE> while ( a > 0 ) : <NEWLINE> <INDENT> ans2 [ index_y ] [ index_x ] = <STRING> <NEWLINE> index_x += 2 <NEWLINE> if index_x == wide : <NEWLINE> <INDENT> index_x = 0 <NEWLINE> index_y += 2 <NEWLINE> <DEDENT> a -= 1 <NEWLINE> <NL> <DEDENT> print ( 100 , 100 ) <NEWLINE> for i in ans1 + ans2 : <NEWLINE> <INDENT> print ( <STRING> . join ( i ) ) <NEWLINE> <DEDENT>
def make_tbl ( n ) : <NEWLINE> <INDENT> tbl = [ False , True , False , False , False , True ] * ( n // 6 + 1 ) <NEWLINE> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> tbl [ i ] = not tbl [ i ] <NEWLINE> <DEDENT> p , stp , sqrt = 5 , 2 , n ** 0.5 <NEWLINE> while p < sqrt : <NEWLINE> <INDENT> for i in range ( p ** 2 , n , 2 * p ) : <NEWLINE> <INDENT> tbl [ i ] = False <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> p += stp <NEWLINE> stp = 6 - stp <NEWLINE> if tbl [ p ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return tbl <NEWLINE> <DEDENT> tbl = make_tbl ( 50000 ) <NEWLINE> ps = [ i for i in range ( 50000 ) if tbl [ i ] ] <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> res = 0 <NEWLINE> if n % 2 : <NEWLINE> <INDENT> if tbl [ n - 2 ] : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res = 0 <NEWLINE> for p in ps : <NEWLINE> <INDENT> if 2 * p > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if tbl [ n - p ] : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> t = 0 <NEWLINE> for p in range ( n ) : <NEWLINE> <INDENT> if t + a [ p ] > k : <NEWLINE> <INDENT> p -= 1 <NEWLINE> break <NEWLINE> <DEDENT> t += a [ p ] <NEWLINE> <DEDENT> for q in range ( m ) : <NEWLINE> <INDENT> if t + b [ q ] > k : <NEWLINE> <INDENT> q -= 1 <NEWLINE> break <NEWLINE> <DEDENT> t += b [ q ] <NEWLINE> <DEDENT> ans = p + q + 2 <NEWLINE> if q < m - 1 : <NEWLINE> <INDENT> z = ans <NEWLINE> q += 1 <NEWLINE> for s in range ( p , - 1 , - 1 ) : <NEWLINE> <INDENT> t -= a [ s ] <NEWLINE> z -= 1 <NEWLINE> while q < m and t + b [ q ] <= k : <NEWLINE> <INDENT> t += b [ q ] <NEWLINE> q += 1 <NEWLINE> z += 1 <NEWLINE> <DEDENT> if z > ans : <NEWLINE> <INDENT> ans = z <NEWLINE> <DEDENT> if q == m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ ] <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> li . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> li . sort ( key = lambda x : x [ 3 ] ) <NEWLINE> num = [ i for i in range ( 1 , M + 1 ) ] <NEWLINE> l = list ( itertools . combinations_with_replacement ( num , N ) ) <NEWLINE> max_sum = - 1 <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( Q ) : <NEWLINE> <INDENT> if l [ i ] [ li [ j ] [ 1 ] - 1 ] - l [ i ] [ li [ j ] [ 0 ] - 1 ] == li [ j ] [ 2 ] : <NEWLINE> <INDENT> s += li [ j ] [ 3 ] <NEWLINE> <NL> <DEDENT> <DEDENT> max_sum = max ( max_sum , s ) <NEWLINE> <DEDENT> print ( max_sum ) <NEWLINE>
import typing <NEWLINE> from typing import List , NamedTuple , Deque , Set , Counter <NEWLINE> <NL> class node : <NEWLINE> <INDENT> def __init__ ( self , id : int ) -> None : <NEWLINE> <INDENT> self . id : int = id <NEWLINE> self . parent : node = self <NEWLINE> self . root : node = self <NEWLINE> self . rank : int = 0 <NEWLINE> self . connection : List [ node ] = [ ] <NEWLINE> <NL> <DEDENT> def addConnection ( self , other : <STRING> ) -> None : <NEWLINE> <INDENT> self . connection . append ( other ) <NEWLINE> other . connection . append ( self ) <NEWLINE> <NL> <DEDENT> def delConnection ( self , other : <STRING> ) -> None : <NEWLINE> <INDENT> self . connection . remove ( other ) <NEWLINE> other . connection . remove ( self ) <NEWLINE> <NL> <DEDENT> def setParent ( self , other : <STRING> ) -> None : <NEWLINE> <INDENT> self . parent = other <NEWLINE> self . rank = other . rank + 1 <NEWLINE> <NL> <DEDENT> def setRoot ( self , other : <STRING> ) -> None : <NEWLINE> <INDENT> self . root = other <NEWLINE> <NL> <DEDENT> def setAsRoot ( self ) -> None : <NEWLINE> <INDENT> self . parent = self <NEWLINE> self . root = self <NEWLINE> self . rank = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def makePath ( root : node , target : node ) -> Deque [ node ] : <NEWLINE> <INDENT> path : Deque [ node ] = Deque ( ) <NEWLINE> path . append ( target ) <NEWLINE> while path [ 0 ] != root : <NEWLINE> <INDENT> path . appendleft ( path [ 0 ] . parent ) <NEWLINE> <DEDENT> return path <NEWLINE> <NL> <NL> <DEDENT> def bfs ( root : node ) : <NEWLINE> <INDENT> reserved : Deque [ node ] = Deque ( [ root ] ) <NEWLINE> seen : Set [ int ] = { root . id } <NEWLINE> while len ( reserved ) > 0 : <NEWLINE> <INDENT> current_node = reserved . popleft ( ) <NEWLINE> for next_node in current_node . connection : <NEWLINE> <INDENT> if next_node . id in seen : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> next_node . setParent ( current_node ) <NEWLINE> next_node . setRoot ( root ) <NEWLINE> seen . add ( next_node . id ) <NEWLINE> reserved . append ( next_node ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> Edge = [ map ( int , input ( ) . split ( ) ) for _ in range ( N - 1 ) ] <NEWLINE> <NL> Node : List [ node ] = [ node ( i ) for i in range ( N ) ] <NEWLINE> for a , b in Edge : <NEWLINE> <INDENT> Node [ a - 1 ] . addConnection ( Node [ b - 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> bfs ( Node [ 0 ] ) <NEWLINE> <COMMENT> <NL> between : int = Node [ N - 1 ] . rank - 1 <NEWLINE> <COMMENT> <NL> sep = ( between + 1 ) // 2 <NEWLINE> path = makePath ( Node [ 0 ] , Node [ N - 1 ] ) <NEWLINE> <COMMENT> <NL> path [ sep ] . delConnection ( path [ sep + 1 ] ) <NEWLINE> path [ sep + 1 ] . setAsRoot ( ) <NEWLINE> bfs ( path [ sep + 1 ] ) <NEWLINE> <COMMENT> <NL> fennec , snuke = Counter ( [ n . root . id for n in Node ] ) . values ( ) <NEWLINE> <COMMENT> <NL> print ( <STRING> if fennec > snuke else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> P = [ a for a in A if a >= 0 ] <NEWLINE> N = [ a for a in A if a < 0 ] <NEWLINE> <NL> def canPositive ( ) : <NEWLINE> <INDENT> for i in range ( 0 , len ( N ) + 1 , 2 ) : <NEWLINE> <INDENT> p = K - i <NEWLINE> if p < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if len ( P ) >= p : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> if not canPositive ( ) : <NEWLINE> <INDENT> A . sort ( key = lambda a : abs ( a ) ) <NEWLINE> ans = 1 <NEWLINE> for a in A [ : K ] : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if not P or not N or len ( A ) == K : <NEWLINE> <INDENT> A . sort ( key = lambda a : abs ( a ) , reverse = True ) <NEWLINE> ans = 1 <NEWLINE> for a in A [ : K ] : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> P . sort ( key = lambda a : abs ( a ) ) <NEWLINE> N . sort ( key = lambda a : abs ( a ) ) <NEWLINE> P = deque ( P ) <NEWLINE> N = deque ( N ) <NEWLINE> <NL> ans = 1 <NEWLINE> sign = 1 <NEWLINE> while K > 0 : <NEWLINE> <INDENT> ans %= MOD <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if K == 1 : <NEWLINE> <INDENT> if sign < 0 : <NEWLINE> <INDENT> ans *= N . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= P . pop ( ) <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> if len ( P ) >= 2 and len ( N ) >= 2 : <NEWLINE> <INDENT> p = P [ - 1 ] * P [ - 2 ] <NEWLINE> n = N [ - 1 ] * N [ - 2 ] <NEWLINE> if p > n : <NEWLINE> <INDENT> ans *= P . pop ( ) <NEWLINE> K -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= N . pop ( ) * N . pop ( ) <NEWLINE> K -= 2 <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> if len ( P ) <= 1 or len ( N ) <= 1 : <NEWLINE> <INDENT> if len ( N ) == 0 : <NEWLINE> <INDENT> ans *= P . pop ( ) <NEWLINE> K -= 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if len ( P ) == 0 : <NEWLINE> <INDENT> ans *= N . pop ( ) <NEWLINE> K -= 1 <NEWLINE> sign *= - 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if len ( P ) == len ( N ) == 1 : <NEWLINE> <INDENT> ans *= P . pop ( ) * N . pop ( ) <NEWLINE> K -= 2 <NEWLINE> sign *= - 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if len ( N ) == 1 : <NEWLINE> <INDENT> n = N . pop ( ) <NEWLINE> if sign < 0 : <NEWLINE> <INDENT> ans *= n <NEWLINE> K -= 1 <NEWLINE> sign *= - 1 <NEWLINE> <DEDENT> continue <NEWLINE> <NL> <DEDENT> if len ( P ) == 1 : <NEWLINE> <INDENT> p = P . pop ( ) <NEWLINE> if K % 2 == 1 and sign > 0 or K % 2 == 0 and sign < 0 : <NEWLINE> <INDENT> ans *= p <NEWLINE> K -= 1 <NEWLINE> <DEDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans % MOD ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> An = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> An . sort ( ) <NEWLINE> max_num = An [ - 1 ] <NEWLINE> <NL> primes = [ True ] * max_num <NEWLINE> once = [ False ] * max_num <NEWLINE> <NL> i = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> once [ An [ i ] - 1 ] = True <NEWLINE> <NL> j = 1 <NEWLINE> while i + j < n : <NEWLINE> <INDENT> if An [ i ] == An [ i + j ] : <NEWLINE> <INDENT> once [ An [ i ] - 1 ] = False <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> i += j <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if primes [ An [ i ] - 1 ] : <NEWLINE> <INDENT> base = An [ i ] <NEWLINE> idx = An [ i ] * 2 - 1 <NEWLINE> while idx < max_num : <NEWLINE> <INDENT> primes [ idx ] = False <NEWLINE> idx += base <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = [ x and y for ( x , y ) in zip ( once , primes ) ] <NEWLINE> print ( ans . count ( True ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> l = 0 ; <NEWLINE> flag = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> l += ( len ( str ( A [ i ] ) ) - 1 ) <NEWLINE> if l > 18 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> ans *= A [ i ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> a = [ 0 for _ in range ( S + 1 ) ] <NEWLINE> if S < 3 : <NEWLINE> <INDENT> print ( a [ S ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a [ 3 ] = 1 <NEWLINE> <NL> <NL> for n in range ( 4 , S + 1 ) : <NEWLINE> <INDENT> sm = 0 <NEWLINE> for i in range ( 3 , S ) : <NEWLINE> <INDENT> sm += a [ n - i ] <NEWLINE> <DEDENT> a [ n ] = sm + 1 <NEWLINE> <NL> <DEDENT> print ( a [ S ] % ( ( 10 ** 9 ) + 7 ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> com = 0 <NEWLINE> if n < b : <NEWLINE> <INDENT> x = n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> <DEDENT> val = ( a * x ) // b <NEWLINE> print ( val ) <NEWLINE>
import sys <NEWLINE> import time <NEWLINE> import math <NEWLINE> st = time . perf_counter ( ) <NEWLINE> def inpl ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> nl = [ 0 ] * 100100 <NEWLINE> ls = inpl ( ) <NEWLINE> ans = 0 <NEWLINE> for i in ls : <NEWLINE> <INDENT> nl [ i ] += 1 <NEWLINE> ans += i <NEWLINE> <DEDENT> M = int ( input ( ) ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = ans - ( nl [ a ] * a ) + ( nl [ a ] * b ) <NEWLINE> nl [ b ] += nl [ a ] <NEWLINE> nl [ a ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ed = time . perf_counter ( ) <NEWLINE> print ( <STRING> , ed - st , file = sys . stderr ) <NEWLINE>
class Node ( object ) : <NEWLINE> <INDENT> root = None <NEWLINE> <NL> def __init__ ( self , key , parent = None , left = None , right = None ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . parent = parent <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> self . height = None <NEWLINE> <NL> <DEDENT> @ classmethod <NEWLINE> def insert ( cls , z ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = cls . root <NEWLINE> while x != None : <COMMENT> <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> z . parent = y <NEWLINE> if y == None : <NEWLINE> <INDENT> cls . root = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> @ classmethod <NEWLINE> def find ( cls , k ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> x = cls . root <NEWLINE> while x != None and k != x . key : <NEWLINE> <INDENT> if k < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> return x <NEWLINE> <NL> <DEDENT> @ classmethod <NEWLINE> def walk_preorder ( cls , node ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( <STRING> . format ( node . key ) , end = <STRING> ) <NEWLINE> if node . left != None : <NEWLINE> <COMMENT> <NL> <INDENT> cls . walk_preorder ( node . left ) <NEWLINE> <DEDENT> if node . right != None : <NEWLINE> <COMMENT> <NL> <INDENT> cls . walk_preorder ( node . right ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> @ classmethod <NEWLINE> def walk_inorder ( cls , node ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> if node . left != None : <NEWLINE> <COMMENT> <NL> <INDENT> cls . walk_inorder ( node . left ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( <STRING> . format ( node . key ) , end = <STRING> ) <NEWLINE> if node . right != None : <NEWLINE> <COMMENT> <NL> <INDENT> cls . walk_inorder ( node . right ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> @ classmethod <NEWLINE> def delete_node ( cls , z ) : <NEWLINE> <INDENT> if z . left == None or z . right == None : <NEWLINE> <INDENT> y = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = Node . get_successor ( z ) <NEWLINE> <DEDENT> if y . left != None : <NEWLINE> <INDENT> x = y . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = y . right <NEWLINE> <DEDENT> if x != None : <NEWLINE> <INDENT> x . parent = y . parent <NEWLINE> <DEDENT> if y . parent == None : <NEWLINE> <INDENT> Node . root = x <NEWLINE> <DEDENT> elif y == y . parent . left : <NEWLINE> <INDENT> y . parent . left = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . parent . right = x <NEWLINE> <DEDENT> if y != z : <NEWLINE> <INDENT> z . key = y . key <NEWLINE> <NL> <DEDENT> <DEDENT> @ classmethod <NEWLINE> def get_successor ( cls , x ) : <NEWLINE> <INDENT> if x . right != None : <NEWLINE> <INDENT> return Node . get_minimum ( x . right ) <NEWLINE> <DEDENT> y = x . parent <NEWLINE> while y != None and x == y . right : <NEWLINE> <INDENT> x = yy = y . parent <NEWLINE> <DEDENT> return y <NEWLINE> <NL> <DEDENT> @ classmethod <NEWLINE> def get_minimum ( cls , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> while x . left != None : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def get_type ( self ) : <NEWLINE> <INDENT> if self . parent == None : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif self . left == None and self . right == None : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def get_depth ( self ) : <NEWLINE> <INDENT> if self . parent == None : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> depth = 1 <NEWLINE> t = self . parent <NEWLINE> while t . parent != None : <NEWLINE> <INDENT> t = t . parent <NEWLINE> depth += 1 <NEWLINE> <DEDENT> return depth <NEWLINE> <NL> <DEDENT> <DEDENT> def get_height ( self ) : <NEWLINE> <INDENT> if self . height : <NEWLINE> <INDENT> return self . height <NEWLINE> <DEDENT> h_left = 0 <NEWLINE> h_right = 0 <NEWLINE> if self . left != None : <NEWLINE> <INDENT> h_left = self . left . get_height ( ) + 1 <NEWLINE> <DEDENT> if self . right != None : <NEWLINE> <INDENT> h_right = self . right . get_height ( ) + 1 <NEWLINE> <DEDENT> self . height = max ( h_left , h_right ) <NEWLINE> return self . height <NEWLINE> <NL> <DEDENT> def get_degree ( self ) : <NEWLINE> <INDENT> degree = 0 <NEWLINE> if self . left != None : <NEWLINE> <INDENT> degree += 1 <NEWLINE> <DEDENT> if self . right != None : <NEWLINE> <INDENT> degree += 1 <NEWLINE> <DEDENT> return degree <NEWLINE> <NL> <DEDENT> def get_sibling ( self ) : <NEWLINE> <INDENT> if self . parent == None : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> p = self . parent <NEWLINE> if p . left != self and p . left != None : <NEWLINE> <INDENT> return p . left <NEWLINE> <DEDENT> if p . right != self and p . right != None : <NEWLINE> <INDENT> return p . right <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def process_node_data ( node_data ) : <NEWLINE> <INDENT> for inst in node_data : <NEWLINE> <INDENT> if inst [ 0 ] == <STRING> : <NEWLINE> <INDENT> result = Node . walk_inorder ( Node . root ) <NEWLINE> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> result = Node . walk_preorder ( Node . root ) <NEWLINE> <COMMENT> <NL> print ( <STRING> ) <NEWLINE> <DEDENT> elif inst [ 0 ] == <STRING> : <NEWLINE> <INDENT> node_key = int ( inst [ 1 ] ) <NEWLINE> new_node = Node ( node_key ) <NEWLINE> Node . insert ( new_node ) <NEWLINE> <DEDENT> elif inst [ 0 ] == <STRING> : <NEWLINE> <INDENT> result = Node . find ( int ( inst [ 1 ] ) ) <NEWLINE> if result : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif inst [ 0 ] == <STRING> : <NEWLINE> <INDENT> result = Node . delete_node ( Node . find ( int ( inst [ 1 ] ) ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def flatten ( l ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import collections <NEWLINE> for el in l : <NEWLINE> <INDENT> if isinstance ( el , collections . Iterable ) and not isinstance ( el , ( str , bytes ) ) : <NEWLINE> <INDENT> yield from flatten ( el ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> yield el <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> num_of_nodes = int ( input ( ) ) <NEWLINE> node_data = [ input ( ) . split ( <STRING> ) for _ in range ( num_of_nodes ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> process_node_data ( node_data ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( a + b ) // 2 if ( a + b ) % 2 == 0 else <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> cnt = 0 <NEWLINE> ans = len ( T ) <NEWLINE> <NL> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if S [ i + j ] != T [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , cnt ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> max_val1 = sorted ( A ) [ - 1 ] <NEWLINE> max_val2 = sorted ( A ) [ - 2 ] <NEWLINE> for x in A : <NEWLINE> <INDENT> print ( max_val2 if x == max_val1 else max_val1 ) <NEWLINE> <DEDENT>
from numba import njit <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maxA = max ( A ) <NEWLINE> dp = [ 0 ] * maxA <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if dp [ A [ i ] - 1 ] != 0 : <NEWLINE> <INDENT> dp [ A [ i ] - 1 ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 1 , maxA // A [ i ] + 1 ) : <NEWLINE> <INDENT> dp [ A [ i ] * j - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if dp [ A [ i ] - 1 ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M , Q , * ABCD = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> L = list ( zip ( * [ iter ( ABCD ) ] * 4 ) ) <NEWLINE> <NL> def solve ( A ) : <NEWLINE> <INDENT> if len ( A ) == N : <NEWLINE> <INDENT> return sum ( d for a , b , c , d in L if A [ b - 1 ] - A [ a - 1 ] == c ) <NEWLINE> <NL> <DEDENT> return max ( solve ( A + [ i ] ) for i in range ( A [ - 1 ] , M + 1 ) ) <NEWLINE> <NL> <DEDENT> print ( solve ( [ 1 ] ) ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> def checkSorted ( A ) : <NEWLINE> <INDENT> check = True <NEWLINE> a = A [ 0 ] <NEWLINE> for e in A : <NEWLINE> <INDENT> if a > e : <NEWLINE> <INDENT> check = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = e <NEWLINE> <DEDENT> <DEDENT> return check <NEWLINE> <NL> <NL> <DEDENT> def insertionSort ( A , n , g , cnt ) : <NEWLINE> <INDENT> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <DEDENT> return [ cnt , A ] <NEWLINE> <NL> <DEDENT> <STRING> <NEWLINE> def shellSort ( A , n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> m = 1 <NEWLINE> G = [ 1 ] <NEWLINE> while G [ - 1 ] < n : <NEWLINE> <INDENT> G . append ( 3 * G [ - 1 ] + 1 ) <NEWLINE> m += 1 <NEWLINE> <DEDENT> if m > 1 : <NEWLINE> <INDENT> G = G [ : - 1 ] <NEWLINE> G . reverse ( ) <NEWLINE> m -= 1 <NEWLINE> <NL> <DEDENT> for g in G : <NEWLINE> <INDENT> A = insertionSort ( A , n , g , cnt ) <NEWLINE> cnt = A [ 0 ] <NEWLINE> A = A [ 1 ] <NEWLINE> <NL> <DEDENT> return [ m , G , cnt , A ] <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> results = shellSort ( A , n ) <NEWLINE> m = results [ 0 ] <NEWLINE> G = results [ 1 ] <NEWLINE> cnt = results [ 2 ] <NEWLINE> Ar = results [ 3 ] <NEWLINE> print ( m ) <NEWLINE> gs = <STRING> <NEWLINE> for g in G : <NEWLINE> <INDENT> gs = gs + str ( g ) + <STRING> <NEWLINE> <DEDENT> print ( gs [ : - 1 ] ) <NEWLINE> print ( cnt ) <NEWLINE> for a in Ar : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> u = sum ( map ( int , str ( n ) ) ) <NEWLINE> if u % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> S = 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> S = S + p [ i ] <NEWLINE> <NL> <DEDENT> print ( S ) <NEWLINE>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = <STRING> + input ( ) <NEWLINE> l = [ ] <NEWLINE> r = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> _l , _r = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( _l ) <NEWLINE> r . append ( _r ) <NEWLINE> <DEDENT> dp = [ 0 ] * ( N + 2 ) <COMMENT> <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ - i ] == <STRING> and S [ - i - 1 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> dp [ N - i ] = cnt <NEWLINE> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> ans = dp [ l [ q ] ] - dp [ r [ q ] + 1 ] <NEWLINE> if r [ q ] < N : <NEWLINE> <INDENT> if S [ r [ q ] ] == <STRING> and S [ r [ q ] + 1 ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> w = s . count ( <STRING> ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> <NL> a = <STRING> <COMMENT> <NEWLINE> b = <STRING> <COMMENT> <NEWLINE> cnt = 0 <NEWLINE> <NL> for t in s : <NEWLINE> <INDENT> if t == <STRING> : <NEWLINE> <INDENT> b = b + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = b + <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( r + w ) : <NEWLINE> <INDENT> if i < r : <NEWLINE> <INDENT> a = a + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = a + <STRING> <NEWLINE> <DEDENT> if a [ i ] != b [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = cnt // 2 <NEWLINE> <NL> print ( cnt ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from collections import Counter <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> Q = int ( readline ( ) ) <NEWLINE> d = Counter ( A ) <NEWLINE> <NL> total = sum ( A ) <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> total -= B * d [ B ] <NEWLINE> total += C * d [ B ] <NEWLINE> <NL> d [ C ] += d [ B ] <NEWLINE> d [ B ] = 0 <NEWLINE> <NL> print ( total ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ti = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> <NL> def euc_alg ( val1 , val2 ) : <NEWLINE> <NL> <INDENT> if val1 == val2 : <NEWLINE> <INDENT> return val1 <NEWLINE> <NL> <DEDENT> mod = min ( val1 , val2 ) <NEWLINE> divided = max ( val1 , val2 ) <NEWLINE> while 1 : <NEWLINE> <INDENT> tmp_mod = divided % mod <NEWLINE> <NL> if tmp_mod == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> divided = mod <NEWLINE> mod = tmp_mod <NEWLINE> <NL> <DEDENT> ret = val1 * val2 // mod <NEWLINE> <NL> return ret <NEWLINE> <NL> <DEDENT> maxti = max ( ti ) <NEWLINE> <COMMENT> <NL> <NL> ans = ti [ 0 ] <NEWLINE> for t in ti : <NEWLINE> <INDENT> ans = euc_alg ( ans , t ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> s = input ( ) . strip ( ) <NEWLINE> t = 0 <NEWLINE> counts = np . array ( [ 0 ] * 2019 ) <NEWLINE> counts [ 0 ] += 1 <NEWLINE> m = 1 <NEWLINE> <NL> for a in reversed ( s ) : <NEWLINE> <INDENT> t = ( t + m * int ( a ) ) % 2019 <NEWLINE> counts [ t ] += 1 <NEWLINE> m = m * 10 % 2019 <NEWLINE> <NL> <DEDENT> print ( int ( np . sum ( counts * ( counts - 1 ) / 2 ) ) ) <NEWLINE>
import numpy as np <NEWLINE> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( b // x - ( a - 1 ) // x ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> cnt += ( n - 1 ) // a <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> score = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> if score [ i ] < score [ K + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
r = float ( input ( ) ) <NEWLINE> p = 3.14159265358979 <NEWLINE> print ( <STRING> . format ( p * r ** 2 , 2 * p * r ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> d , s = [ 0 ] * n , 0 <NEWLINE> for i , x in enumerate ( a ) : <NEWLINE> <INDENT> if i + x < n : <NEWLINE> <INDENT> d [ i + x ] += 1 <NEWLINE> <DEDENT> if i - x >= 0 : <NEWLINE> <INDENT> s += d [ i - x ] <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 998244353 <NEWLINE> dd = [ ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) ] <NEWLINE> ddn = [ ( 0 , - 1 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 0 , 1 ) , ( - 1 , - 1 ) , ( - 1 , 0 ) , ( - 1 , 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> <NL> st = string . digits + string . ascii_uppercase <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n , m , q = LI ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> a = [ LS ( ) for _ in range ( q ) ] <NEWLINE> if n == 1 : <NEWLINE> <INDENT> rr . append ( <STRING> * m ) <NEWLINE> continue <NEWLINE> <DEDENT> u = [ 0 ] * m <NEWLINE> v = [ 0 ] * m <NEWLINE> ms = 0 <NEWLINE> mk = 2 ** n - 1 <NEWLINE> for t , s in a : <NEWLINE> <INDENT> mt = int ( t [ : : - 1 ] , 2 ) <NEWLINE> tu = ms ^ mt <NEWLINE> tv = mk ^ tu <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> u [ i ] |= tu <NEWLINE> v [ i ] |= tv <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v [ i ] |= tu <NEWLINE> u [ i ] |= tv <NEWLINE> <DEDENT> <DEDENT> ms = tu <NEWLINE> <NL> <DEDENT> r = <STRING> <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> t = None <NEWLINE> for ti in range ( n ) : <NEWLINE> <INDENT> if ( u [ i ] & 2 ** ti ) > 0 and ( v [ i ] & 2 ** ti ) == 0 : <NEWLINE> <INDENT> if t is None : <NEWLINE> <INDENT> t = st [ ti ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if not t : <NEWLINE> <INDENT> t = <STRING> <NEWLINE> <DEDENT> r += str ( t ) <NEWLINE> <NL> <DEDENT> rr . append ( r ) <NEWLINE> <NL> <DEDENT> return <STRING> . join ( map ( str , rr ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m % n == 0 : <NEWLINE> <INDENT> print ( int ( m // n ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = m / n <NEWLINE> l = [ ] <NEWLINE> for i in range ( int ( m ** 0.5 ) , 0 , - 1 ) : <NEWLINE> <INDENT> if m % i == 0 : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> l . append ( m // i ) <NEWLINE> <DEDENT> <DEDENT> l = sorted ( l ) [ : : - 1 ] <NEWLINE> for j in l : <NEWLINE> <INDENT> if j <= a : <NEWLINE> <INDENT> print ( j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> n += 1 <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for j in range ( 1 , n ) : <NEWLINE> <INDENT> gcdIJ = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n ) : <NEWLINE> <INDENT> sum += math . gcd ( gcdIJ , k ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> <NL> ans = S [ 1 : ] . count ( <STRING> ) <NEWLINE> tmp = S [ 1 : ] . count ( <STRING> ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> tmp -= 1 <NEWLINE> <DEDENT> ans = min ( ans , tmp ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> s = input ( ) <NEWLINE> <COMMENT> <NL> l = [ - 1 for _ in range ( len ( s ) + 1 ) ] <NEWLINE> def aa ( ix , v ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> if ( ix >= len ( s ) and v == 1 ) or ( ix == 0 and v == 0 - 1 ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if v == 1 and s [ ix ] == <STRING> and l [ ix + 1 ] <= l [ ix ] : <NEWLINE> <INDENT> l [ ix + 1 ] = l [ ix ] + 1 <NEWLINE> aa ( ix + 1 , 1 ) <NEWLINE> <DEDENT> elif v == - 1 and s [ ix - 1 ] == <STRING> and l [ ix - 1 ] <= l [ ix ] : <NEWLINE> <INDENT> l [ ix - 1 ] = l [ ix ] + 1 <NEWLINE> aa ( ix - 1 , - 1 ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> for i in range ( 0 , len ( s ) ) : <NEWLINE> <INDENT> if i == 0 and s [ 0 ] == <STRING> : <NEWLINE> <INDENT> l [ 0 ] = 0 <NEWLINE> aa ( i , 1 ) <NEWLINE> <DEDENT> elif i == len ( s ) - 1 and s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> l [ - 1 ] = 0 <NEWLINE> aa ( i + 1 , - 1 ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> l [ i + 1 ] = 0 <NEWLINE> aa ( i + 1 , 1 ) <NEWLINE> aa ( i + 1 , - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( l ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> S = len ( s ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> tmp_ans = pow ( 26 , n , mod ) <NEWLINE> div = pow ( 26 , - 1 , mod ) <NEWLINE> <NL> ans = tmp_ans <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> tmp_ans = ( tmp_ans * 25 * div ) % mod <NEWLINE> tmp_ans = ( ( tmp_ans * ( S - 1 + i ) ) * pow ( i , - 1 , mod ) ) % mod <NEWLINE> ans = ( ans + tmp_ans ) % mod <NEWLINE> <NL> <DEDENT> ans %= mod <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> N = int ( N ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a = 1 <NEWLINE> if A . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> a = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> a = a * A [ i ] <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> a = - 1 <NEWLINE> print ( a ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if a > 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def target ( x ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> return math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> <NL> <DEDENT> print ( target ( min ( N , B - 1 ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> n , m = map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> <NL> dp = [ - 1 ] * n <NEWLINE> <NL> def root ( x ) : <NEWLINE> <INDENT> if dp [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> return root ( dp [ x ] ) <NEWLINE> <NL> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> rx = root ( x ) <NEWLINE> ry = root ( y ) <NEWLINE> <NL> if rx == ry : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> if dp [ rx ] > dp [ ry ] : <NEWLINE> <INDENT> rx , ry = ry , rx <NEWLINE> <NL> <DEDENT> dp [ rx ] += dp [ ry ] <NEWLINE> dp [ ry ] = rx <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> return - dp [ root ( x ) ] <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> unite ( a , b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ 0 ] * ( N + 1 ) <NEWLINE> L = int ( N ** 0.5 ) + 1 <NEWLINE> for x in range ( 1 , L + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , L + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , L + 1 ) : <NEWLINE> <INDENT> num = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if num <= N : <NEWLINE> <INDENT> A [ num ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - ( i + j ) <NEWLINE> if z >= 0 and z <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> <NL> readline = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = np . array ( readline ( ) . split ( ) , np . int64 ) <NEWLINE> all_xor = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> all_xor = all_xor ^ a <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> xor = all_xor ^ a <NEWLINE> print ( xor , end = <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( A ) : <NEWLINE> <INDENT> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <NL> <DEDENT> main ( A ) <NEWLINE>
import numpy as np <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> S = 0 <NEWLINE> count = - 1 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> S = ( S * 10 ) % K <NEWLINE> S = ( S + 7 ) % K <NEWLINE> if ( S == 0 ) : <NEWLINE> <INDENT> count = i + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1 << 25 ) <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . readline <COMMENT> <NEWLINE> <NL> import numpy as np <NEWLINE> from functools import partial <NEWLINE> array = partial ( np . array , dtype = np . int64 ) <NEWLINE> zeros = partial ( np . zeros , dtype = np . int64 ) <NEWLINE> full = partial ( np . full , dtype = np . int64 ) <NEWLINE> <NL> ra = range <NEWLINE> enu = enumerate <NEWLINE> <NL> <NL> def exit ( * argv , ** kwarg ) : <NEWLINE> <INDENT> print ( * argv , ** kwarg ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> def mina ( * argv , sub = 1 ) : return list ( map ( lambda x : x - sub , argv ) ) <NEWLINE> <COMMENT> <NL> <NL> <NL> def a_int ( ) : return int ( readline ( ) ) <NEWLINE> <NL> <NL> def ints ( ) : return np . fromstring ( readline ( ) , sep = <STRING> , dtype = np . int64 ) <NEWLINE> <NL> <NL> def read_matrix ( H , W ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> lines = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> lines . append ( read ( ) ) <NEWLINE> <DEDENT> lines = <STRING> . join ( lines ) <COMMENT> <NEWLINE> return np . fromstring ( lines , sep = <STRING> , dtype = np . int64 ) . reshape ( H , W ) <NEWLINE> <NL> <NL> <DEDENT> def read_col ( H ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> ret . append ( list ( map ( int , readline ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> return tuple ( map ( list , zip ( * ret ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def read_tuple ( H ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> ret . append ( tuple ( map ( int , readline ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> INF = 2 ** 31 <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> from collections import defaultdict , Counter , deque <NEWLINE> from operator import itemgetter , xor , add <NEWLINE> from itertools import product , permutations , combinations <NEWLINE> from bisect import bisect_left , bisect_right <COMMENT> <NEWLINE> from functools import reduce , lru_cache <NEWLINE> from math import gcd <NEWLINE> <NL> <NL> def lcm ( a , b ) : <NEWLINE> <COMMENT> <NL> <INDENT> g = gcd ( a , b ) <NEWLINE> return a // g * b <NEWLINE> <NL> <NL> <DEDENT> N = a_int ( ) <NEWLINE> A = ints ( ) <NEWLINE> cnt = Counter ( A ) <NEWLINE> <STRING> <NEWLINE> <NL> dp = np . full ( ( N + 1 , N + 1 , N + 1 ) , - 1.0 ) <NEWLINE> dp [ 0 , 0 , 0 ] = 0 <NEWLINE> from numba import njit <NEWLINE> <COMMENT> <NL> <NL> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def dfs ( i , j , k , N , dp ) : <NEWLINE> <INDENT> if i < 0 or j < 0 or k < 0 or i == j == k == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if dp [ i , j , k ] != - 1 : <NEWLINE> <INDENT> return dp [ i , j , k ] <NEWLINE> <DEDENT> ret = 1 <NEWLINE> ret += i / N * dfs ( i - 1 , j , k , N , dp ) <NEWLINE> ret += j / N * dfs ( i + 1 , j - 1 , k , N , dp ) <NEWLINE> ret += k / N * dfs ( i , j + 1 , k - 1 , N , dp ) <NEWLINE> if ( i + j + k ) == 0 : <NEWLINE> <INDENT> dp [ i , j , k ] = ret <NEWLINE> return ret <NEWLINE> <DEDENT> dp [ i , j , k ] = N / ( i + j + k ) * ret <NEWLINE> return dp [ i , j , k ] <NEWLINE> <NL> <NL> <DEDENT> print ( dfs ( cnt [ 1 ] , cnt [ 2 ] , cnt [ 3 ] , N , dp ) ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD_NUMBER = 10 ** 9 + 7 <NEWLINE> nizyo_list = [ i ** 2 for i in li ] <NEWLINE> ans = ( sum ( li ) ** 2 - sum ( nizyo_list ) ) // 2 <NEWLINE> print ( ans % MOD_NUMBER ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> A = [ int ( _ ) for _ in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> if A [ 0 ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A [ 0 ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> elif ans < 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> elif A [ i ] == 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from collections import deque , Counter <NEWLINE> from heapq import heappop , heappush <NEWLINE> from bisect import bisect_right , bisect_left <NEWLINE> from itertools import accumulate <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> INF = 10 ** 12 <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> def cal_primes ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> candidate = [ * range ( 2 , N + 1 ) ] <NEWLINE> primes = [ ] <NEWLINE> <NL> while candidate [ 0 ] ** 2 <= N : <NEWLINE> <INDENT> primes . append ( candidate [ 0 ] ) <NEWLINE> candidate = [ * filter ( lambda x : x % candidate [ 0 ] != 0 , candidate ) ] <NEWLINE> <NL> <DEDENT> primes . extend ( candidate ) <NEWLINE> return primes <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> primes = cal_primes ( 55555 ) <NEWLINE> primes = [ * filter ( lambda x : x % 5 == 1 , primes ) ] <NEWLINE> <NL> print ( * primes [ : N ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i + k ] <= a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> B = { } <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> aa1 = i + 1 - a <NEWLINE> if aa1 > 0 : <NEWLINE> <INDENT> if aa1 not in B : <NEWLINE> <INDENT> B [ aa1 ] = [ ] <NEWLINE> <DEDENT> B [ aa1 ] . append ( ( i + 1 , a ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> aa1 = i + 1 + a <NEWLINE> if aa1 in B : <NEWLINE> <INDENT> count += len ( B [ aa1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import heapq <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( lambda x : x * ( - 1 ) , a ) ) <NEWLINE> <NL> heapq . heapify ( a ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x = heapq . heappop ( a ) <NEWLINE> heapq . heappush ( a , ( - 1 ) * ( - x // 2 ) ) <NEWLINE> <NL> <DEDENT> print ( - sum ( a ) ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if a >= k : <NEWLINE> <INDENT> ans += k <NEWLINE> print ( ans ) <NEWLINE> k -= a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a <NEWLINE> k -= a <NEWLINE> <NL> <DEDENT> if k > 0 : <NEWLINE> <INDENT> if b >= k : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> k -= b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= b <NEWLINE> <NL> <DEDENT> <DEDENT> if k > 0 : <NEWLINE> <INDENT> if c >= k : <NEWLINE> <INDENT> ans -= k <NEWLINE> print ( ans ) <NEWLINE> k -= c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= c <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> pos = [ * filter ( lambda x : x >= 0 , A ) ] <NEWLINE> neg = [ * filter ( lambda x : x < 0 , A ) ] <NEWLINE> pos . sort ( reverse = True ) <NEWLINE> neg . sort ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> i , j = 0 , 0 <COMMENT> <NEWLINE> while i + j < K : <NEWLINE> <INDENT> flag = True <NEWLINE> if i == len ( pos ) : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> elif j == len ( neg ) : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> elif pos [ i ] >= - neg [ j ] : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> <NL> <DEDENT> if flag : <NEWLINE> <INDENT> ans = ans * pos [ i ] % m <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * neg [ j ] % m <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if j % 2 == 0 or N == K : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> elif len ( pos ) == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans = ans * neg [ len ( neg ) - 1 - i ] % m <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag2 = True <NEWLINE> if i == 0 : <NEWLINE> <INDENT> flag2 = True <NEWLINE> <DEDENT> elif j == 0 : <NEWLINE> <INDENT> flag2 = False <NEWLINE> <DEDENT> elif i == len ( pos ) : <NEWLINE> <INDENT> flag2 = False <NEWLINE> <DEDENT> elif j == len ( neg ) : <NEWLINE> <INDENT> flag2 = True <NEWLINE> <DEDENT> elif pos [ i - 1 ] * pos [ i ] > neg [ j - 1 ] * neg [ j ] : <COMMENT> <NEWLINE> <INDENT> flag2 = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag2 = False <NEWLINE> <NL> <DEDENT> if flag2 : <NEWLINE> <INDENT> ans = ans * pow ( neg [ j - 1 ] , m - 2 , m ) % m <NEWLINE> ans = ans * pos [ i ] % m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * pow ( pos [ i - 1 ] , m - 2 , m ) % m <NEWLINE> ans = ans * neg [ j ] % m <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from datetime import datetime <NEWLINE> <NL> def measure ( f ) : <NEWLINE> <INDENT> measure_start = datetime . now ( ) <NEWLINE> v = f ( ) <NEWLINE> print ( datetime . now ( ) - measure_start ) <NEWLINE> return v <NEWLINE> <NL> <DEDENT> input = raw_input <NEWLINE> range = xrange <NEWLINE> <NL> def init ( ) : <NEWLINE> <INDENT> table = [ True ] * 1000001 <NEWLINE> table [ 0 ] = False <NEWLINE> table [ 1 ] = False <NEWLINE> n = len ( table ) <NEWLINE> <NL> def prime ( p ) : <NEWLINE> <INDENT> for i in range ( p + p , n , p ) : <NEWLINE> <INDENT> table [ i ] = False <NEWLINE> <DEDENT> <DEDENT> prime ( 2 ) <NEWLINE> prime ( 3 ) <NEWLINE> prime ( 5 ) <NEWLINE> prime ( 7 ) <NEWLINE> prime ( 11 ) <NEWLINE> prime ( 13 ) <NEWLINE> <NL> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if ( i % 2 != 0 and i % 3 != 0 and i % 5 != 0 and <NEWLINE> <INDENT> i % 7 != 0 and i % 11 != 0 and i % 13 != 0 ) : <NEWLINE> for j in range ( i + i , n , i ) : <NEWLINE> <INDENT> table [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return table <NEWLINE> <NL> <DEDENT> def solve ( price , ps , is_prime ) : <NEWLINE> <INDENT> dp = [ 0 ] * ( ( price >> 5 ) + 1 ) <NEWLINE> <NL> for i in range ( 0 , price + 1 , ps [ 0 ] ) : <NEWLINE> <INDENT> dp [ i >> 5 ] |= 1 << ( i & 31 ) <NEWLINE> <DEDENT> dp [ 0 ] = 1 <NEWLINE> <NL> for i in range ( 1 , len ( ps ) ) : <NEWLINE> <INDENT> cur_p = ps [ i ] <NEWLINE> r = cur_p & 31 <NEWLINE> rest = 0 <NEWLINE> if cur_p >= 32 : <NEWLINE> <INDENT> for p in range ( cur_p , price + 1 , 32 ) : <NEWLINE> <INDENT> i1 = ( p - cur_p ) >> 5 <NEWLINE> i2 = p >> 5 <NEWLINE> v = dp [ i1 ] <NEWLINE> dp [ i2 ] |= ( v << r ) | rest <NEWLINE> rest = ( v >> ( 32 - r ) ) & ( ( 1 << r ) - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for p in range ( cur_p , price + 1 ) : <NEWLINE> <INDENT> dp [ p >> 5 ] |= ( dp [ ( p - cur_p ) >> 5 ] >> ( ( p - cur_p ) & 31 ) & 1 ) << ( p & 31 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> p = - 1 <NEWLINE> for i in range ( 0 , price + 1 ) : <NEWLINE> <INDENT> if is_prime [ i ] and ( dp [ i >> 5 ] >> ( i & 31 ) ) & 1 == 1 : <NEWLINE> <INDENT> p = i <NEWLINE> <DEDENT> <DEDENT> if p == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> table = init ( ) <NEWLINE> while True : <NEWLINE> <INDENT> n , price = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and price == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> ps = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ps . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> solve ( price , ps , table ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> A = list ( int ( x ) for x in readline ( ) . split ( ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> def bubble_sort ( c ) : <NEWLINE> <INDENT> c = list ( c ) <NEWLINE> for i in range ( len ( c ) ) : <NEWLINE> <INDENT> for j in range ( len ( c ) - 1 , i , - 1 ) : <NEWLINE> <INDENT> if int ( c [ j ] [ 1 ] ) < int ( c [ j - 1 ] [ 1 ] ) : <NEWLINE> <INDENT> c [ j ] , c [ j - 1 ] = c [ j - 1 ] , c [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return c <NEWLINE> <NL> <DEDENT> def selection_sort ( c ) : <NEWLINE> <INDENT> c = list ( c ) <NEWLINE> for i in range ( len ( c ) ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i + 1 , len ( c ) ) : <NEWLINE> <INDENT> if int ( c [ j ] [ 1 ] ) < int ( c [ minj ] [ 1 ] ) : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> c [ i ] , c [ minj ] = c [ minj ] , c [ i ] <NEWLINE> <DEDENT> return c <NEWLINE> <NL> <DEDENT> input_num = int ( input ( ) ) <NEWLINE> input_list = input ( ) . split ( ) <NEWLINE> bubble_list = bubble_sort ( input_list ) <NEWLINE> selection_list = selection_sort ( input_list ) <NEWLINE> for c in bubble_list : <NEWLINE> <INDENT> print ( c , end = <STRING> ) <NEWLINE> if c != bubble_list [ len ( bubble_list ) - 1 ] : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> stable_flg = True <NEWLINE> for i in range ( len ( input_list ) ) : <NEWLINE> <INDENT> if bubble_list [ i ] != selection_list [ i ] : <NEWLINE> <INDENT> stable_flg = False <NEWLINE> <DEDENT> print ( selection_list [ i ] , end = <STRING> ) <NEWLINE> if i < len ( input_list ) - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if stable_flg : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> j = N // i <NEWLINE> ans += i * ( j * ( j + 1 ) // 2 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> k = int ( input ( ) ) <NEWLINE> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> s = 7 <NEWLINE> c = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if s % k == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = ( 10 * s + 7 ) % k <NEWLINE> c += 1 <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = 1 <NEWLINE> <NL> c = collections . Counter ( a ) <NEWLINE> <NL> for x in range ( max ( a ) + 2 ) : <NEWLINE> <INDENT> d = c [ x ] + c [ x - 1 ] + c [ x + 1 ] <NEWLINE> if d >= M : <NEWLINE> <INDENT> M = d <NEWLINE> <NL> <DEDENT> <DEDENT> print ( M ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> def bfs ( x1 , y1 , d ) : <NEWLINE> <INDENT> q = deque ( [ ] ) <NEWLINE> q . append ( ( d , x1 , y1 ) ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> d , x1 , y1 = q . popleft ( ) <NEWLINE> M [ x1 ] [ y1 ] = d <NEWLINE> <NL> if [ x1 , y1 ] == [ xg , yg ] : <NEWLINE> <INDENT> print ( d ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for dx , dy in ( ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( - 1 , 0 ) ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> x2 = x1 + dx * k <NEWLINE> y2 = y1 + dy * k <NEWLINE> if x2 < 0 or x2 >= H : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if y2 < 0 or y2 >= W : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if m [ x2 ] [ y2 ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if M [ x2 ] [ y2 ] < d + 1 : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if M [ x2 ] [ y2 ] == d + 1 : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> q . append ( ( d + 1 , x2 , y2 ) ) <NEWLINE> M [ x2 ] [ y2 ] = d + 1 <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> H , W , K = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> xs , ys , xg , yg = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> xg -= 1 <NEWLINE> yg -= 1 <NEWLINE> <NL> m = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> m . append ( list ( map ( str , sys . stdin . readline ( ) . strip ( ) ) ) ) <NEWLINE> <NL> <DEDENT> M = [ [ float ( <STRING> ) ] * W for _ in range ( H ) ] <NEWLINE> <NL> bfs ( xs - 1 , ys - 1 , 0 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> heights = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> diffMax = 2 * max ( heights ) <NEWLINE> diffMin = 2 * min ( heights ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> arrSize = min ( [ max ( [ i + heights [ i ] for i in range ( len ( heights ) ) ] ) , max ( [ i - heights [ i ] for i in range ( len ( heights ) ) ] ) ] ) + 1 <NEWLINE> <NL> seppenPlus = [ 0 ] * arrSize <NEWLINE> seppenMinus = [ 0 ] * arrSize <NEWLINE> <NL> <NL> for i in range ( len ( heights ) ) : <NEWLINE> <INDENT> seppenPlusNum = i + heights [ i ] <NEWLINE> seppenMinusNum = i - heights [ i ] <NEWLINE> <NL> if seppenPlusNum < arrSize : <NEWLINE> <INDENT> seppenPlus [ seppenPlusNum ] += 1 <NEWLINE> <NL> <DEDENT> if seppenMinusNum >= 0 : <NEWLINE> <INDENT> seppenMinus [ seppenMinusNum ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( seppenPlus ) ) : <NEWLINE> <INDENT> cnt += seppenPlus [ i ] * seppenMinus [ i ] <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> b = [ ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> b += [ list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> <DEDENT> b = sorted ( b , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> for j in range ( b [ i ] [ 0 ] ) : <NEWLINE> <INDENT> if a [ 0 ] < b [ i ] [ 1 ] : <NEWLINE> <INDENT> a . pop ( 0 ) <NEWLINE> a . append ( b [ i ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( a ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE> <NL> <NL>
O = str ( input ( ) ) <NEWLINE> E = str ( input ( ) ) <NEWLINE> st = <STRING> <NEWLINE> if len ( O ) == len ( E ) : <NEWLINE> <INDENT> for i in range ( len ( O ) ) : <NEWLINE> <INDENT> st += O [ i ] <NEWLINE> st += E [ i ] <NEWLINE> <DEDENT> print ( st ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( O ) - 1 ) : <NEWLINE> <INDENT> st += O [ i ] <NEWLINE> st += E [ i ] <NEWLINE> <NL> <DEDENT> print ( st + O [ - 1 ] ) <NEWLINE> <DEDENT>
<NL> aaa = [ 0 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 5 , 5 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 ] <NEWLINE> <NL> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> l = factorization ( N ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for arr in l : <NEWLINE> <INDENT> if arr [ 0 ] != 1 : <NEWLINE> <INDENT> a = arr [ 1 ] <NEWLINE> b = aaa [ a ] <NEWLINE> ans += b <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import numpy as np <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> visited = set ( ) <NEWLINE> from2to = { } <NEWLINE> for i , a in enumerate ( As ) : <NEWLINE> <INDENT> from2to [ i + 1 ] = a <NEWLINE> <NL> <DEDENT> id2n_warp = { } <NEWLINE> current = 1 <NEWLINE> loop_anchor = - 1 <NEWLINE> n_warp = 0 <NEWLINE> visited . add ( 1 ) <NEWLINE> id2n_warp [ 1 ] = 0 <NEWLINE> while True : <NEWLINE> <INDENT> n_warp += 1 <NEWLINE> next_ = from2to [ current ] <NEWLINE> if n_warp == K : <NEWLINE> <INDENT> print ( next_ ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if next_ in visited : <NEWLINE> <INDENT> loop_anchor = next_ <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> id2n_warp [ next_ ] = n_warp <NEWLINE> visited . add ( next_ ) <NEWLINE> <DEDENT> current = next_ <NEWLINE> <NL> <DEDENT> K -= id2n_warp [ loop_anchor ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> K = K % ( n_warp - id2n_warp [ loop_anchor ] ) <NEWLINE> <COMMENT> <NL> <NL> current = loop_anchor <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> next_ = from2to [ current ] <NEWLINE> current = next_ <NEWLINE> <NL> <DEDENT> print ( next_ ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> while True : <NEWLINE> <INDENT> left_white_idx = S . find ( <STRING> ) <NEWLINE> right_red_idx = S . rfind ( <STRING> ) <NEWLINE> <NL> if left_white_idx == - 1 or right_red_idx == - 1 or left_white_idx > right_red_idx : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> S = S [ left_white_idx + 1 : right_red_idx ] <NEWLINE> <NL> ans = ans + 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> ksum = 0 <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> m = n // k <NEWLINE> ksum += k * m * ( m + 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ksum ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> W = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> if N == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif N == W [ i ] : <NEWLINE> <INDENT> print ( W [ i + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> flg = True <NEWLINE> <NL> if 0 in A : print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flg : print ( ans ) <NEWLINE> else : print ( - 1 ) <NEWLINE> <DEDENT>
def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( len ( list ( filter ( lambda x : len ( make_divisors ( x ) ) == 8 , range ( 1 , n + 1 , 2 ) ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in A_list : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A_list : <NEWLINE> <INDENT> ans = ans * a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A >= K : print ( K ) <NEWLINE> elif A + B >= K : print ( A ) <NEWLINE> else : print ( A - ( K - ( B + A ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( a ) <NEWLINE> x = [ 0 ] * n <NEWLINE> y = 0 <NEWLINE> r = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> y = int ( a [ i ] / s * k ) <NEWLINE> x [ i ] = [ i , y , a [ i ] / ( y + 1 ) , a [ i ] ] <NEWLINE> r += y <NEWLINE> <DEDENT> x . sort ( key = lambda val : val [ 2 ] , reverse = True ) <NEWLINE> for i in range ( k - r ) : <NEWLINE> <INDENT> x [ i ] [ 1 ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , x [ i ] [ 3 ] / ( x [ i ] [ 1 ] + 1 ) ) <NEWLINE> <DEDENT> print ( int ( - ( - ans // 1 ) ) ) <NEWLINE>
[ n , m , q ] = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> lst = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> lst . append ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <NL> <DEDENT> y = [ 1 for i in range ( n ) ] <NEWLINE> <NL> def f ( index , li ) : <NEWLINE> <INDENT> if index == n : <NEWLINE> <INDENT> return eva ( li ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = 0 <NEWLINE> t = 1 <NEWLINE> if index >= 1 : <NEWLINE> <INDENT> t = li [ index - 1 ] <NEWLINE> <DEDENT> for i in range ( t , m + 1 ) : <NEWLINE> <INDENT> li [ index ] = i <NEWLINE> x = f ( index + 1 , li ) <NEWLINE> if ret < x : <NEWLINE> <INDENT> ret = x <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> <DEDENT> def eva ( li ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for k in range ( q ) : <NEWLINE> <INDENT> a = lst [ k ] [ 0 ] <NEWLINE> b = lst [ k ] [ 1 ] <NEWLINE> c = lst [ k ] [ 2 ] <NEWLINE> d = lst [ k ] [ 3 ] <NEWLINE> if li [ b - 1 ] - li [ a - 1 ] == c : <NEWLINE> <INDENT> tmp = tmp + d <NEWLINE> <DEDENT> <DEDENT> return tmp <NEWLINE> <NL> <DEDENT> print ( f ( 0 , y ) ) <NEWLINE>
from math import floor <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans1 = min ( N , B - 1 ) <NEWLINE> ans2 = floor ( A * ans1 / B ) - A * floor ( ans1 / B ) <NEWLINE> print ( ans2 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> ans = 0 <NEWLINE> k = int ( input ( ) ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> a = gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( a , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = [ 1 ] * N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if H [ A - 1 ] <= H [ B - 1 ] : <NEWLINE> <INDENT> result [ A - 1 ] = 0 <NEWLINE> <DEDENT> if H [ B - 1 ] <= H [ A - 1 ] : <NEWLINE> <INDENT> result [ B - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( result ) ) <NEWLINE> <NL>
K = int ( input ( ) ) <NEWLINE> <NL> N = 0 <NEWLINE> count = - 1 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> N = ( N * 10 + 7 ) % K <NEWLINE> if N == 0 : <NEWLINE> <INDENT> count = i + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> x = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> _gcd = math . gcd ( x , k ) <NEWLINE> count += _gcd <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> area = math . pi * r ** 2 <NEWLINE> circumference = 2 * math . pi * r <NEWLINE> print ( <STRING> . format ( area , circumference ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> S = str ( input ( ) ) [ : : - 1 ] <COMMENT> <NEWLINE> N = len ( S ) <NEWLINE> counter = [ 0 ] * 2019 <NEWLINE> counter [ 0 ] = 1 <NEWLINE> ans = 0 <NEWLINE> num , d = 0 , 1 <NEWLINE> for c in S : <NEWLINE> <INDENT> num += int ( c ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> counter [ num ] += 1 <NEWLINE> <DEDENT> for i in counter : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> sum_of_digits = 0 <NEWLINE> cnts = [ 0 ] * 2019 <NEWLINE> cnts [ 0 ] = 1 <NEWLINE> <NL> d = 1 <NEWLINE> for c in s : <NEWLINE> <INDENT> sum_of_digits += int ( c ) * d <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> sum_of_digits %= 2019 <NEWLINE> cnts [ sum_of_digits ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in cnts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import itertools <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b + 1 , k + 1 ) : <NEWLINE> <INDENT> r = math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> r *= 6 <NEWLINE> result += r <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , k + 1 ) : <NEWLINE> <INDENT> r = math . gcd ( a , b ) <NEWLINE> r *= 6 <NEWLINE> result += r <NEWLINE> <NL> <DEDENT> <DEDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> result += a <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> w = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> def check ( p ) : <NEWLINE> <INDENT> c = t = 0 <NEWLINE> for wi in w : <NEWLINE> <INDENT> t += wi <NEWLINE> if t > p : <NEWLINE> <INDENT> t = wi <NEWLINE> c += 1 <NEWLINE> if c >= k : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> s = max ( w ) <NEWLINE> l = sum ( w ) <NEWLINE> m = l + ( s - l ) * k // n <NEWLINE> while s < l : <NEWLINE> <INDENT> if check ( m ) : <NEWLINE> <INDENT> l = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = m + 1 <NEWLINE> <DEDENT> m = ( s + l ) // 2 <NEWLINE> <DEDENT> print ( m ) <NEWLINE>
<COMMENT> <NL> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> upper = [ - 1 ] * N <NEWLINE> <COMMENT> <NL> def root ( x ) : <NEWLINE> <COMMENT> <NL> <INDENT> if upper [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> upper [ x ] = root ( upper [ x ] ) <NEWLINE> <COMMENT> <NL> return upper [ x ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def equiv ( x , y ) : <NEWLINE> <INDENT> return root ( x ) == root ( y ) <NEWLINE> <NL> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x , y = root ( x ) , root ( y ) <NEWLINE> if x != y : <NEWLINE> <INDENT> if upper [ y ] < upper [ x ] : <NEWLINE> <COMMENT> <NL> <INDENT> x , y = y , x <NEWLINE> <COMMENT> <NL> <DEDENT> upper [ x ] += upper [ y ] <NEWLINE> <COMMENT> <NL> upper [ y ] = x <NEWLINE> <DEDENT> return x == y <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> unite ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> print ( - min ( upper ) ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> from sys import stdin <NEWLINE> from heapq import heappush , heappop <NEWLINE> from collections import namedtuple <NEWLINE> input = stdin . readline <NEWLINE> <NL> <NL> def warshall_floyd ( d , V ) : <NEWLINE> <INDENT> for k in range ( V ) : <NEWLINE> <INDENT> for i in range ( V ) : <NEWLINE> <INDENT> for j in range ( V ) : <NEWLINE> <INDENT> new_cost = d [ i ] [ k ] + d [ k ] [ j ] <NEWLINE> if new_cost < d [ i ] [ j ] : <NEWLINE> <INDENT> d [ i ] [ j ] = new_cost <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main1 ( args ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and k == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> d = [ [ float ( <STRING> ) ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> updated = False <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> data = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if data [ 0 ] == 0 : <NEWLINE> <INDENT> if updated : <NEWLINE> <INDENT> warshall_floyd ( d , n + 1 ) <NEWLINE> updated = False <NEWLINE> <DEDENT> f , t = data [ 1 ] , data [ 2 ] <NEWLINE> if d [ f ] [ t ] == float ( <STRING> ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d [ f ] [ t ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> f , t , c = data [ 1 ] , data [ 2 ] , data [ 3 ] <NEWLINE> if c < d [ f ] [ t ] : <NEWLINE> <INDENT> d [ f ] [ t ] = c <NEWLINE> updated = True <NEWLINE> <DEDENT> if c < d [ t ] [ f ] : <NEWLINE> <INDENT> d [ t ] [ f ] = c <NEWLINE> updated = True <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> edge = namedtuple ( <STRING> , [ <STRING> , <STRING> ] ) <NEWLINE> def dijkstra ( s , G ) : <NEWLINE> <INDENT> pq = [ ] <NEWLINE> d = [ float ( <STRING> ) ] * len ( G ) <NEWLINE> d [ s ] = 0 <NEWLINE> heappush ( pq , ( 0 , s ) ) <NEWLINE> <NL> while pq : <NEWLINE> <INDENT> c , v = heappop ( pq ) <NEWLINE> if d [ v ] < c : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for e in G [ v ] : <COMMENT> <NEWLINE> <INDENT> if d [ e . t ] > d [ v ] + e . c : <COMMENT> <NEWLINE> <INDENT> d [ e . t ] = d [ v ] + e . c <NEWLINE> heappush ( pq , ( d [ e . t ] , e . t ) ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <NL> <DEDENT> def main ( args ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and k == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> d = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> costs = [ [ float ( <STRING> ) ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> updated = False <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> data = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if data [ 0 ] == 0 : <NEWLINE> <INDENT> f , t = data [ 1 ] , data [ 2 ] <NEWLINE> if updated : <NEWLINE> <INDENT> costs [ f ] = dijkstra ( f , d ) <NEWLINE> <DEDENT> if costs [ f ] [ t ] == float ( <STRING> ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( costs [ f ] [ t ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> f , t , c = data [ 1 ] , data [ 2 ] , data [ 3 ] <NEWLINE> d [ f ] . append ( edge ( t , c ) ) <NEWLINE> d [ t ] . append ( edge ( f , c ) ) <NEWLINE> updated = True <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> minv = P [ 0 ] <COMMENT> <NEWLINE> for i in range ( 1 , len ( P ) ) : <NEWLINE> <INDENT> if minv > P [ i ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> minv = min ( minv , P [ i ] ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def eratosthenes ( n ) : <NEWLINE> <INDENT> era_list = [ 1 ] * ( n + 1 ) <NEWLINE> era_list [ 0 ] = 0 ; era_list [ 1 ] = 0 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if era_list [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = i + i <NEWLINE> while j <= n : <NEWLINE> <INDENT> era_list [ j ] = 0 <NEWLINE> j += i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return era_list <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> PN = eratosthenes ( 100001 ) <NEWLINE> TF = [ 0 ] * 100001 <NEWLINE> <NL> for i in range ( 1 , 100001 , 2 ) : <NEWLINE> <INDENT> if PN [ i ] == 1 and PN [ int ( ( i + 1 ) / 2 ) ] == 1 : <NEWLINE> <INDENT> TF [ i ] = 1 + TF [ i - 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> TF [ i ] = TF [ i - 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( 1 , Q + 1 ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> Ans = TF [ r ] - TF [ l - 2 ] <NEWLINE> print ( Ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> if a [ 0 ] == 1 : print ( 1 ) <NEWLINE> else : print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if a [ 0 ] : <NEWLINE> <INDENT> exit ( print ( - 1 ) ) <NEWLINE> <DEDENT> b = [ 1 ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> b . append ( b [ - 1 ] * 2 - a [ i ] ) <NEWLINE> <DEDENT> b [ - 1 ] = a [ - 1 ] <NEWLINE> for i in range ( n , 0 , - 1 ) : <NEWLINE> <INDENT> b [ i - 1 ] = min ( b [ i - 1 ] , b [ i ] ) <NEWLINE> if not ( b [ i - 1 ] <= b [ i ] <= 2 * b [ i - 1 ] ) : exit ( print ( - 1 ) ) <NEWLINE> b [ i - 1 ] += a [ i - 1 ] <NEWLINE> <DEDENT> print ( sum ( b ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> XINT = int ( X , 2 ) <NEWLINE> ANS = [ 0 ] * N <NEWLINE> TEMP = [ 0 ] * N <NEWLINE> CHAIND = [ 0 ] * N <NEWLINE> <NL> cnt = count_ones_by_bitmask ( XINT ) <NEWLINE> <NL> if cnt == 0 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> if cnt == 1 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> print ( ( int ( X [ N - 1 ] ) + 1 ) % 2 + 1 ) <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( int ( X [ N - 1 ] ) ) % 2 + 1 ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> p = XINT % ( cnt + 1 ) <NEWLINE> m = XINT % ( cnt - 1 ) <NEWLINE> pmod = 1 <NEWLINE> mmod = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ANS [ i ] = 1 <NEWLINE> if ( X [ N - i - 1 ] == <STRING> ) : <NEWLINE> <INDENT> TEMP [ i ] = ( p + pmod ) % ( cnt + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> TEMP [ i ] = ( m - mmod ) % ( cnt - 1 ) <NEWLINE> <DEDENT> pmod = ( pmod * 2 ) % ( cnt + 1 ) <NEWLINE> mmod = ( mmod * 2 ) % ( cnt - 1 ) <NEWLINE> <NL> <NL> <DEDENT> CHA = list ( set ( TEMP ) ) <NEWLINE> <NL> for i in range ( len ( CHA ) ) : <NEWLINE> <INDENT> an = 0 <NEWLINE> cha = CHA [ i ] <NEWLINE> cnt = count_ones_by_bitmask ( CHA [ i ] ) <NEWLINE> while cnt > 0 : <NEWLINE> <INDENT> an += 1 <NEWLINE> cha = cha % cnt <NEWLINE> cnt = count_ones_by_bitmask ( cha ) <NEWLINE> <DEDENT> CHAIND [ CHA [ i ] ] = an <NEWLINE> <NL> <DEDENT> for i in reversed ( range ( N ) ) : <NEWLINE> <INDENT> print ( ANS [ i ] + CHAIND [ TEMP [ i ] ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def count_ones_by_bitmask ( num ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> while num : <NEWLINE> <INDENT> count += num & 1 <NEWLINE> num >>= 1 <NEWLINE> <DEDENT> return count <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p_none = [ i for i in range ( 110 ) if i not in p ] <NEWLINE> p_none_sa = [ abs ( p_none [ i ] - X ) for i in range ( len ( p_none ) ) ] <NEWLINE> <NL> import sys <NEWLINE> <NL> min_p_none = min ( p_none_sa ) <NEWLINE> for i in range ( len ( p_none_sa ) ) : <NEWLINE> <INDENT> if p_none_sa [ i ] == min_p_none : <NEWLINE> <INDENT> print ( p_none [ i ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = sum ( l ) <NEWLINE> if c <= n : <NEWLINE> <INDENT> print ( n - c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> <NL> <COMMENT> <NL> A , B , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def f ( x : int ) -> int : <NEWLINE> <INDENT> return math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> result = f ( min ( B - 1 , N ) ) <NEWLINE> <NL> <COMMENT> <NL> print ( result ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> memo = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> Ai , Bi = map ( int , input ( ) . split ( ) ) <NEWLINE> memo [ Ai ] . append ( Bi ) <NEWLINE> memo [ Bi ] . append ( Ai ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> visited = [ False ] * ( N + 1 ) <NEWLINE> visited [ 1 ] = True <NEWLINE> ans = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> queue = [ 1 ] <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> room = queue . pop ( 0 ) <NEWLINE> for connected_room in memo [ room ] : <NEWLINE> <COMMENT> <NL> <INDENT> if visited [ connected_room ] == True : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ connected_room ] = room <NEWLINE> visited [ connected_room ] = True <NEWLINE> queue . append ( connected_room ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for a in ans [ 2 : ] : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> wlist = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> wlist . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> ma = sum ( wlist ) + 1 <NEWLINE> mi = max ( wlist ) - 1 <NEWLINE> while ( ma - mi > 1 ) : <NEWLINE> <INDENT> mid = ( ma + mi ) // 2 <NEWLINE> truck = [ 0 for i in range ( k ) ] <COMMENT> <NEWLINE> i = 0 <NEWLINE> gobigger = 0 <NEWLINE> for w in wlist : <NEWLINE> <INDENT> if ( truck [ i ] + w <= mid ) : <NEWLINE> <INDENT> truck [ i ] = truck [ i ] + w <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> if ( i == k ) : <NEWLINE> <INDENT> gobigger = 1 <NEWLINE> break <NEWLINE> <DEDENT> truck [ i ] = truck [ i ] + w <NEWLINE> <DEDENT> <DEDENT> if ( gobigger == 1 ) : <NEWLINE> <INDENT> mi = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ma = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ma ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> print ( <STRING> if A [ i ] > A [ i - K ] else <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> cnt = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < N : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from functools import reduce <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == <STRING> : break <NEWLINE> if len ( n ) < 4 : n = n . zfill ( 4 ) <NEWLINE> if reduce ( lambda x , y : x and y , [ n [ 0 ] == s for s in n ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while n != <STRING> : <NEWLINE> <INDENT> l = <STRING> . join ( sorted ( n , reverse = True ) ) <NEWLINE> s = <STRING> . join ( sorted ( n ) ) <NEWLINE> n = str ( int ( l ) - int ( s ) ) <NEWLINE> if len ( n ) < 4 : n = n . zfill ( 4 ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT> <DEDENT>
def max_heapify ( A , i ) : <NEWLINE> <INDENT> l = 2 * i <NEWLINE> r = 2 * i + 1 <NEWLINE> largest = i <NEWLINE> if l < len ( A ) and A [ l ] > A [ i ] : <NEWLINE> <INDENT> largest = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest = i <NEWLINE> <DEDENT> if r < len ( A ) and A [ r ] > A [ largest ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <NL> <DEDENT> if largest != i : <NEWLINE> <INDENT> temp = A [ i ] <NEWLINE> A [ i ] = A [ largest ] <NEWLINE> A [ largest ] = temp <NEWLINE> max_heapify ( A , largest ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def build_maxheap ( A ) : <NEWLINE> <INDENT> i = len ( A ) // 2 <NEWLINE> while i >= 1 : <NEWLINE> <INDENT> max_heapify ( A , i ) <NEWLINE> i -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> num_of_data = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> A . insert ( 0 , 0 ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> build_maxheap ( A ) <NEWLINE> A = A [ 1 : ] <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> print ( <STRING> . format ( <STRING> . join ( map ( str , A ) ) ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> import time <NEWLINE> from collections import defaultdict , deque <NEWLINE> from sys import stdin , stdout <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> def find ( a ) : <NEWLINE> <INDENT> return ( a * ( a + 1 ) ) // 2 <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += i * find ( n // i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL>
from collections import defaultdict <NEWLINE> <NL> S = defaultdict ( int ) <NEWLINE> for i in input ( ) : <NEWLINE> <INDENT> S [ i ] += 1 <NEWLINE> <NL> <DEDENT> if len ( S . values ( ) ) == 2 : <NEWLINE> <INDENT> a , b = S . values ( ) <NEWLINE> if a == b == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> Visit = [ False for i in range ( n + 1 ) ] <NEWLINE> <NL> loop_st , loop_end , loop_len = 0 , 0 , 0 <NEWLINE> st = 1 <NEWLINE> releki = [ ] <NEWLINE> loop_list = [ ] <NEWLINE> for i in range ( 10000000000000 ) : <NEWLINE> <INDENT> if Visit [ st ] == True : <NEWLINE> <INDENT> loop_key = st <NEWLINE> loop_st = releki . index ( loop_key ) <NEWLINE> loop_end = len ( releki ) - loop_st <NEWLINE> loop_list = releki [ loop_st : ] <NEWLINE> loop_len = len ( loop_list ) <NEWLINE> break <NEWLINE> <DEDENT> releki . append ( st ) <NEWLINE> Visit [ st ] = True <NEWLINE> st = A [ st - 1 ] <NEWLINE> <DEDENT> if k < loop_st : <NEWLINE> <INDENT> print ( releki [ k ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> k -= loop_st <NEWLINE> <NL> print ( loop_list [ k % loop_len ] ) <NEWLINE>
import math <NEWLINE> <NL> <COMMENT> <NL> <NL> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> b_degree = 6 * m <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> a_degree = 30 * h + m / 60 * 30 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if a_degree > b_degree : <NEWLINE> <INDENT> degree1 = a_degree - b_degree <NEWLINE> degree2 = 360 - degree1 <NEWLINE> degree = min ( degree1 , degree2 ) <NEWLINE> length = math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( math . radians ( degree ) ) ) <NEWLINE> <DEDENT> elif a_degree < b_degree : <NEWLINE> <INDENT> degree = b_degree - a_degree <NEWLINE> length = math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( math . radians ( degree ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> length = abs ( b - a ) <NEWLINE> <NL> <DEDENT> print ( length ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> res = 1 <NEWLINE> flag = 1 <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in l : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> <DEDENT> if flag != 0 : <NEWLINE> <INDENT> for i in l : <NEWLINE> <INDENT> res *= i <NEWLINE> if res > 1000000000000000000 : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if res > 1000000000000000000 : <NEWLINE> <INDENT> res = - 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res = 0 <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> <NL> a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a + b >= k : <NEWLINE> <INDENT> if a <= k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - ( a + b ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> class Dinic : <NEWLINE> <INDENT> def __init__ ( self , v ) : <NEWLINE> <INDENT> self . vertice = v <NEWLINE> self . inf = int ( 1e9 ) <NEWLINE> self . graph = [ [ ] for i in range ( v ) ] <NEWLINE> self . level = [ 0 ] * v <NEWLINE> self . iter = [ 0 ] * v <NEWLINE> <NL> <DEDENT> def add_edge ( self , fr , to , cap , reverse = True ) : <NEWLINE> <INDENT> self . graph [ fr ] . append ( [ to , cap , len ( self . graph [ to ] ) ] ) <NEWLINE> cap2 = cap if reverse else 0 <NEWLINE> self . graph [ to ] . append ( [ fr , cap2 , len ( self . graph [ fr ] ) - 1 ] ) <NEWLINE> <NL> <DEDENT> def bfs ( self , s ) : <NEWLINE> <INDENT> self . level = [ - 1 ] * self . vertice <NEWLINE> que = deque ( [ ] ) <NEWLINE> self . level [ s ] = 0 <NEWLINE> que . append ( s ) <NEWLINE> <NL> while que : <NEWLINE> <INDENT> v = que . popleft ( ) <NEWLINE> for i in range ( len ( self . graph [ v ] ) ) : <NEWLINE> <INDENT> e = self . graph [ v ] [ i ] <NEWLINE> if e [ 1 ] > 0 and self . level [ e [ 0 ] ] < 0 : <NEWLINE> <INDENT> self . level [ e [ 0 ] ] = self . level [ v ] + 1 <NEWLINE> que . append ( e [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def dfs ( self , v , t , f ) : <NEWLINE> <INDENT> if v == t : <NEWLINE> <INDENT> return f <NEWLINE> <DEDENT> for i in range ( self . iter [ v ] , len ( self . graph [ v ] ) ) : <NEWLINE> <INDENT> self . iter [ v ] = i <NEWLINE> e = self . graph [ v ] [ i ] <NEWLINE> if e [ 1 ] > 0 and self . level [ v ] < self . level [ e [ 0 ] ] : <NEWLINE> <INDENT> d = self . dfs ( e [ 0 ] , t , min ( f , e [ 1 ] ) ) <NEWLINE> if d > 0 : <NEWLINE> <INDENT> e [ 1 ] -= d <NEWLINE> self . graph [ e [ 0 ] ] [ e [ 2 ] ] [ 1 ] += d <NEWLINE> return d <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def max_flow ( self , s , t ) : <NEWLINE> <INDENT> flow = 0 <NEWLINE> while True : <NEWLINE> <INDENT> self . bfs ( s ) <NEWLINE> if self . level [ t ] < 0 : <NEWLINE> <INDENT> return flow <NEWLINE> <DEDENT> self . iter = [ 0 ] * self . vertice <NEWLINE> <NL> f = self . dfs ( s , t , self . inf ) <NEWLINE> while f : <NEWLINE> <INDENT> flow += f <NEWLINE> f = self . dfs ( s , t , self . inf ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ [ 1 if x == <STRING> else 0 for x in input ( ) [ : - 1 ] ] for i in range ( n ) ] <NEWLINE> <NL> flow = Dinic ( n * m + 2 ) <NEWLINE> start = 0 <NEWLINE> end = n * m + 1 <NEWLINE> direction = [ ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == 0 : <NEWLINE> <INDENT> if ( i + j ) % 2 : <NEWLINE> <INDENT> flow . add_edge ( start , i * m + j + 1 , 1 , reverse = False ) <NEWLINE> for x , y in direction : <NEWLINE> <INDENT> ni , nj = x + i , y + j <NEWLINE> if 0 <= ni < n and 0 <= nj < m and s [ ni ] [ nj ] == 0 : <NEWLINE> <INDENT> flow . add_edge ( i * m + j + 1 , ni * m + nj + 1 , 1 , reverse = False ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> flow . add_edge ( i * m + j + 1 , end , 1 , reverse = False ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> res = flow . max_flow ( start , end ) <NEWLINE> print ( res ) <NEWLINE> <NL> ans = [ [ <STRING> if s [ i ] [ j ] else <STRING> for j in range ( m ) ] for i in range ( n ) ] <NEWLINE> <NL> flow_list = dict ( ) <NEWLINE> for i , g in enumerate ( flow . graph ) : <NEWLINE> <INDENT> for node in g : <NEWLINE> <INDENT> fr , to = i , node [ 0 ] <NEWLINE> if fr == start or to == end or to == start or fr == end : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> fr -= 1 <NEWLINE> to -= 1 <NEWLINE> xi , xj = divmod ( fr , m ) <NEWLINE> if ( xi + xj ) % 2 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if node [ 1 ] == 0 : <NEWLINE> <INDENT> if fr > to : <NEWLINE> <INDENT> fr , to = to , fr <NEWLINE> <DEDENT> flow_list [ fr ] = to <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for k , v in flow_list . items ( ) : <NEWLINE> <INDENT> if v - k == m : <NEWLINE> <INDENT> ans [ k // m ] [ k % m ] = <STRING> <NEWLINE> ans [ v // m ] [ v % m ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ k // m ] [ k % m ] = <STRING> <NEWLINE> ans [ v // m ] [ v % m ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( <STRING> . join ( a ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
s = input ( ) <NEWLINE> flag = 0 <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import floor <NEWLINE> while ( True ) : <NEWLINE> <INDENT> e = int ( input ( ) ) <NEWLINE> if e == 0 : <NEWLINE> <INDENT> quit ( ) <NEWLINE> <DEDENT> ans = e <NEWLINE> for i in range ( 0 , e ) : <NEWLINE> <INDENT> if i ** 3 > e : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> j = floor ( ( e - i ** 3 ) ** 0.5 ) <NEWLINE> k = e - i ** 3 - j ** 2 + i + j <NEWLINE> if k < ans : <NEWLINE> <INDENT> ans = k <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in li : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum = sum * li [ i ] <NEWLINE> if sum > 10 ** 18 : <NEWLINE> <INDENT> sum = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> hb = L [ - 1 ] <NEWLINE> dp = [ - 1 for i in range ( hb + 1 ) ] <NEWLINE> for i in L : <NEWLINE> <INDENT> if dp [ i ] != 0 : <NEWLINE> <INDENT> if dp [ i ] == 1 : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> continue <NEWLINE> <DEDENT> dp [ i ] = 1 <NEWLINE> for j in range ( 2 * i , hb + 1 , i ) : <NEWLINE> <INDENT> dp [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in L : <NEWLINE> <INDENT> if dp [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> for l in sys . stdin : <NEWLINE> <INDENT> H , W = map ( int , l . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> print ( W * <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def h ( temp ) : <NEWLINE> <INDENT> if temp [ 0 ] == <STRING> : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> elif temp [ 0 ] == <STRING> : <NEWLINE> <INDENT> if temp [ 2 ] == <STRING> : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 3 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a = 2 <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def H ( temp , y , a ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> if a == 0 or a == 2 : <NEWLINE> <INDENT> for j in range ( 5 ) : <NEWLINE> <INDENT> if y [ a ] [ 4 - j ] != temp [ 0 ] : <NEWLINE> <INDENT> return c <NEWLINE> <DEDENT> temp . remove ( temp [ 0 ] ) <NEWLINE> <DEDENT> c = 1 <NEWLINE> <DEDENT> elif a == 3 : <NEWLINE> <INDENT> for j in range ( 6 ) : <NEWLINE> <INDENT> if y [ a ] [ 5 - j ] != temp [ 0 ] : <NEWLINE> <INDENT> return c <NEWLINE> <DEDENT> temp . remove ( temp [ 0 ] ) <NEWLINE> <DEDENT> c = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 7 ) : <NEWLINE> <INDENT> if y [ a ] [ 6 - j ] != temp [ 0 ] : <NEWLINE> <INDENT> return c <NEWLINE> <DEDENT> temp . remove ( temp [ 0 ] ) <NEWLINE> <DEDENT> c = 1 <NEWLINE> <DEDENT> return c <NEWLINE> <NL> <NL> <DEDENT> s = input ( ) <NEWLINE> y = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> temp = [ ] <NEWLINE> t = [ ] <NEWLINE> k = len ( s ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> temp . append ( s [ k - i - 1 ] ) <NEWLINE> <DEDENT> c = 1 <NEWLINE> while len ( temp ) != 0 and c == 1 : <NEWLINE> <INDENT> a = h ( temp ) <NEWLINE> c = H ( temp , y , a ) <NEWLINE> <DEDENT> if c == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
L = [ ] <NEWLINE> N = 0 <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if ( n == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> L . append ( n ) <NEWLINE> N = N + 1 <NEWLINE> <NL> <DEDENT> for x in range ( N ) : <NEWLINE> <INDENT> print ( <STRING> , str ( x + 1 ) + <STRING> , L [ x ] ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> print ( int ( a * x / b ) - a * int ( x / b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = list ( ) <NEWLINE> g = list ( ) <NEWLINE> b = list ( ) <NEWLINE> for idx , si in enumerate ( s ) : <NEWLINE> <INDENT> if si == <STRING> : <NEWLINE> <INDENT> r . append ( idx ) <NEWLINE> <DEDENT> elif si == <STRING> : <NEWLINE> <INDENT> g . append ( idx ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( idx ) <NEWLINE> <NL> <DEDENT> <DEDENT> ret = 0 <NEWLINE> bi_cnt = len ( b ) <NEWLINE> for ri in r : <NEWLINE> <INDENT> for gi in g : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> try : <NEWLINE> <INDENT> dan1 = 2 * ri - gi <NEWLINE> if ( dan1 > 0 ) & ( s [ dan1 ] == <STRING> ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> try : <NEWLINE> <INDENT> dan3 = 2 * gi - ri <NEWLINE> if ( dan3 > 0 ) & ( s [ dan3 ] == <STRING> ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> try : <NEWLINE> <INDENT> dan2 , mod = divmod ( ri + gi , 2 ) <NEWLINE> if ( mod == 0 ) & ( s [ dan2 ] == <STRING> ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> ret += ( bi_cnt - cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> R_i = { } <NEWLINE> G_i = { } <NEWLINE> B_i = { } <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> R_i [ i ] = 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> G_i [ i ] = 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> B_i [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = len ( R_i ) * len ( G_i ) * len ( B_i ) <NEWLINE> <NL> for ri in R_i : <NEWLINE> <INDENT> for gi in G_i : <NEWLINE> <COMMENT> <NL> <INDENT> if 2 * ri - gi in B_i : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if 2 * gi - ri in B_i : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if ( ri + gi ) % 2 == 0 : <NEWLINE> <INDENT> if ( ri + gi ) // 2 in B_i : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> explored = [ 0 ] * ( n + 1 ) <NEWLINE> t = 1 <NEWLINE> cycle = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if explored [ t ] == 2 : <NEWLINE> <INDENT> k %= cycle <NEWLINE> if k == 0 : <NEWLINE> <INDENT> k = cycle <NEWLINE> <DEDENT> explored [ t ] += 1 <NEWLINE> <DEDENT> elif explored [ t ] == 1 : <NEWLINE> <INDENT> explored [ t ] += 1 <NEWLINE> cycle += 1 <NEWLINE> <DEDENT> elif explored [ t ] == 0 : <NEWLINE> <INDENT> explored [ t ] += 1 <NEWLINE> <NL> <DEDENT> k -= 1 <NEWLINE> if k == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = a [ t ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( a [ t ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i >= K : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import collections <NEWLINE> <NL> N = int ( sys . stdin . readline ( ) ) <NEWLINE> A = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( A ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> from collections import deque <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( len ( s [ 0 ] ) ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> pre = 0 <NEWLINE> p = np . full ( ( h , w ) , - 1 ) <NEWLINE> p [ i ] [ j ] = 0 <NEWLINE> check = deque ( [ ( ( i , j ) , 0 ) ] ) <COMMENT> <NEWLINE> while check : <NEWLINE> <INDENT> now , d = check . popleft ( ) <NEWLINE> pre = max ( pre , d ) <NEWLINE> for k , l in [ ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ] : <NEWLINE> <INDENT> b = now [ 0 ] + k <NEWLINE> c = now [ 1 ] + l <NEWLINE> if b < 0 or c < 0 or b >= h or c >= w : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif p [ b ] [ c ] == - 1 and s [ b ] [ c ] != <STRING> : <NEWLINE> <INDENT> check . append ( ( ( b , c ) , d + 1 ) ) <NEWLINE> p [ b ] [ c ] = d + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = max ( ans , pre ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> input = lambda : stdin . readline ( ) [ : - 1 ] <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) ; print ( n * ( n - 1 ) // 2 ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> neighbor_max = [ 0 ] * N <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> neighbor_max [ A - 1 ] = max ( neighbor_max [ A - 1 ] , H [ B - 1 ] ) <NEWLINE> neighbor_max [ B - 1 ] = max ( neighbor_max [ B - 1 ] , H [ A - 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if H [ i ] > neighbor_max [ i ] : ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> X = [ [ ] for j in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> X [ a ] . append ( b ) <NEWLINE> X [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> result = [ 0 ] * ( N + 1 ) <NEWLINE> c = [ ] <NEWLINE> flag = [ 0 ] * N <NEWLINE> for x in X [ 1 ] : <NEWLINE> <INDENT> result [ x ] = 1 <NEWLINE> c . append ( x ) <NEWLINE> flag [ x - 1 ] = True <NEWLINE> <NL> <DEDENT> c_new = [ ] <NEWLINE> while not all ( flag ) : <NEWLINE> <INDENT> for x in c : <NEWLINE> <INDENT> for y in X [ x ] : <NEWLINE> <INDENT> if flag [ y - 1 ] == False : <NEWLINE> <INDENT> result [ y ] = x <NEWLINE> c_new . append ( y ) <NEWLINE> flag [ y - 1 ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> c = c_new <NEWLINE> c_new = [ ] <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for j in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( result [ j ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> turnT = math . ceil ( i [ 0 ] / i [ 3 ] ) ; <NEWLINE> turnA = math . ceil ( i [ 2 ] / i [ 1 ] ) ; <NEWLINE> <NL> if turnT >= turnA : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> t . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> ans = [ True ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = t [ i ] <NEWLINE> if ( h [ a - 1 ] <= h [ b - 1 ] ) : <NEWLINE> <INDENT> ans [ a - 1 ] = False <NEWLINE> <DEDENT> if ( h [ b - 1 ] <= h [ a - 1 ] ) : <NEWLINE> <INDENT> ans [ b - 1 ] = False <NEWLINE> <DEDENT> <DEDENT> print ( ans . count ( True ) ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> <NL> if ( __name__ == <STRING> ) : <NEWLINE> <INDENT> Str = input ( ) <NEWLINE> <NL> Stred = Str . replace ( <STRING> , <STRING> ) <NEWLINE> print ( Stred ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> m = A [ - 1 ] + 1 <NEWLINE> dp = [ 0 ] * ( m * 2 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> for i in range ( 0 , m // a + 1 ) : <NEWLINE> <INDENT> dp [ a * i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for a in A : <NEWLINE> <INDENT> if dp [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def prim ( ) : <NEWLINE> <INDENT> distance [ 0 ] = 0 <NEWLINE> parent [ 0 ] = - 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> mincost = float ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if color [ i ] != <STRING> and distance [ i ] < mincost : <NEWLINE> <INDENT> mincost = distance [ i ] <NEWLINE> u = i <NEWLINE> <DEDENT> <DEDENT> if mincost == float ( <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> color [ u ] = <STRING> <NEWLINE> <NL> for v in range ( n ) : <NEWLINE> <INDENT> if color [ v ] != <STRING> and adjMat [ u ] [ v ] != float ( <STRING> ) : <NEWLINE> <INDENT> if adjMat [ u ] [ v ] < distance [ v ] : <NEWLINE> <INDENT> distance [ v ] = adjMat [ u ] [ v ] <NEWLINE> parent [ v ] = u <NEWLINE> color [ v ] = <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> color = [ <STRING> ] * n <NEWLINE> parent = [ - 1 ] * n <NEWLINE> distance = [ float ( <STRING> ) ] * n <NEWLINE> <NL> adjMat = [ [ 0 ] * n for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> adjRow = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for v , weight in enumerate ( adjRow ) : <NEWLINE> <INDENT> if weight == - 1 : <NEWLINE> <INDENT> adjMat [ i ] [ v ] = float ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> adjMat [ i ] [ v ] = weight <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> prim ( ) <NEWLINE> <NL> print ( sum ( distance ) ) <NEWLINE>
from itertools import combinations <NEWLINE> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> books = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> books . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> P = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for item in list ( combinations ( books , i ) ) : <NEWLINE> <INDENT> P . append ( item ) <NEWLINE> <DEDENT> <DEDENT> ans = 10 ** 9 + 1 <NEWLINE> for items in P : <NEWLINE> <INDENT> price = 0 <NEWLINE> chk = [ 0 ] * M <NEWLINE> for p in items : <NEWLINE> <INDENT> price += p [ 0 ] <NEWLINE> for i , item in enumerate ( p [ 1 : ] ) : <NEWLINE> <INDENT> chk [ i ] += item <NEWLINE> <DEDENT> if all ( c >= X for c in chk ) : <NEWLINE> <INDENT> ans = min ( ans , price ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans == 10 ** 9 + 1 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> ans = x <NEWLINE> if ans in lst : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> left , right = ans - 1 , ans + 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if left in lst and right in lst : <NEWLINE> <INDENT> left -= 1 <NEWLINE> right += 1 <NEWLINE> <NL> <DEDENT> elif left in lst : <NEWLINE> <INDENT> print ( right ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( left ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
def gcd_cnt ( n ) : <NEWLINE> <INDENT> sub = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> kosuu = n // i <NEWLINE> sub += kosuu * ( 2 * i + ( kosuu - 1 ) * i ) // 2 <NEWLINE> <DEDENT> return sub <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> sub = gcd_cnt ( n ) <NEWLINE> print ( sub ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> c = collections . Counter ( l ) <NEWLINE> answer = sum ( l ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> j , k = map ( int , input ( ) . split ( ) ) <NEWLINE> save = c [ j ] <NEWLINE> del c [ j ] <NEWLINE> c [ k ] += save <NEWLINE> answer = answer + k * save - j * save <NEWLINE> print ( answer ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h_dict = { } <NEWLINE> for i , name in enumerate ( h , 1 ) : <NEWLINE> <INDENT> h_dict [ i ] = name <NEWLINE> <NL> <DEDENT> ab = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> ab . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> flg_bad = set ( ) <NEWLINE> for j in ab : <NEWLINE> <INDENT> if h_dict [ j [ 0 ] ] < h_dict [ j [ 1 ] ] : <NEWLINE> <INDENT> flg_bad . add ( j [ 0 ] ) <NEWLINE> <DEDENT> elif h_dict [ j [ 0 ] ] > h_dict [ j [ 1 ] ] : <NEWLINE> <INDENT> flg_bad . add ( j [ 1 ] ) <NEWLINE> <DEDENT> elif h_dict [ j [ 0 ] ] == h_dict [ j [ 1 ] ] : <NEWLINE> <INDENT> flg_bad . add ( j [ 0 ] ) <NEWLINE> flg_bad . add ( j [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( h ) - len ( flg_bad ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> class Dice : <NEWLINE> <INDENT> def __init__ ( self , top , down , right , left , up , bottom ) : <NEWLINE> <INDENT> self . top = top <NEWLINE> self . bottom = bottom <NEWLINE> self . up = up <NEWLINE> self . down = down <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> <DEDENT> def roll ( self , command ) : <NEWLINE> <INDENT> for c in list ( command ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> self . up , self . top , self . down , self . bottom = self . top , self . down , self . bottom , self . up <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> self . up , self . top , self . down , self . bottom = self . bottom , self . up , self . top , self . down <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> self . left , self . top , self . right , self . bottom = self . bottom , self . left , self . top , self . right <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> self . left , self . top , self . right , self . bottom = self . top , self . right , self . bottom , self . left <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def pip ( self ) : <NEWLINE> <INDENT> return self . top <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> seq = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dice = Dice ( * seq ) <NEWLINE> dice . roll ( input ( ) ) <NEWLINE> print ( dice . pip ( ) ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> ls = { } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = <STRING> . join ( sorted ( input ( ) ) ) <NEWLINE> if s in ls : <NEWLINE> <INDENT> ans += ls [ s ] <NEWLINE> ls [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ls [ s ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
num = 0 <NEWLINE> last = 1 <NEWLINE> while last != 0 : <NEWLINE> <INDENT> t = input ( ) <NEWLINE> if t == <STRING> : <NEWLINE> <INDENT> last = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num += 1 <NEWLINE> print ( <STRING> + str ( num ) + <STRING> + str ( t ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> a = sorted ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
ans_list = [ ] <NEWLINE> def make_pieces ( w , d , s ) : <NEWLINE> <INDENT> if w == 0 and d == 0 : <NEWLINE> <INDENT> print ( w , d , s ) <NEWLINE> <DEDENT> s %= ( 2 * w + 2 * d ) <NEWLINE> while True : <NEWLINE> <INDENT> if w > s : <NEWLINE> <INDENT> return [ s , d ] , [ w - s , d ] <NEWLINE> <DEDENT> s -= w <NEWLINE> if d > s : <NEWLINE> <INDENT> return [ w , s ] , [ w , d - s ] <NEWLINE> <DEDENT> s -= d <NEWLINE> if w > s : <NEWLINE> <INDENT> return [ w - s , d ] , [ s , d ] <NEWLINE> <DEDENT> s -= w <NEWLINE> if d > s : <NEWLINE> <INDENT> return [ w , s ] , [ w , d - s ] <NEWLINE> <DEDENT> s -= d <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ [ w , d ] ] <NEWLINE> if n == 0 and w == 0 and d == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> p , s = map ( int , input ( ) . split ( ) ) <NEWLINE> new_pieces = make_pieces ( P [ p - 1 ] [ 0 ] , P [ p - 1 ] [ 1 ] , s ) <NEWLINE> <COMMENT> <NL> if new_pieces [ 0 ] [ 0 ] * new_pieces [ 0 ] [ 1 ] < new_pieces [ 1 ] [ 0 ] * new_pieces [ 1 ] [ 1 ] : <NEWLINE> <INDENT> P = P [ : p - 1 ] + P [ p : ] + [ new_pieces [ 0 ] ] + [ new_pieces [ 1 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = P [ : p - 1 ] + P [ p : ] + [ new_pieces [ 1 ] ] + [ new_pieces [ 0 ] ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> S_list = [ ] <NEWLINE> for i in P : <NEWLINE> <INDENT> S_list . append ( i [ 0 ] * i [ 1 ] ) <NEWLINE> <NL> <DEDENT> S_list . sort ( ) <NEWLINE> ans_list . append ( S_list ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( ans_list ) ) : <NEWLINE> <INDENT> I = ans_list [ i ] <NEWLINE> for j in range ( len ( I ) ) : <NEWLINE> <INDENT> J = I [ j ] <NEWLINE> if j == len ( I ) - 1 : <NEWLINE> <INDENT> print ( J , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( J , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
from heapq import heappop , heappush <NEWLINE> from collections import defaultdict <NEWLINE> <NL> def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N , M , L = inpl ( ) <NEWLINE> <NL> while N : <NEWLINE> <INDENT> G = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b , d , e = inpl ( ) <NEWLINE> G [ a ] . append ( [ b , d , e ] ) <NEWLINE> G [ b ] . append ( [ a , d , e ] ) <NEWLINE> <NL> <DEDENT> Q = [ [ 0 , 0 , 1 ] ] <COMMENT> <NEWLINE> cost = [ [ 10 ** 6 ] * ( L + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> cost [ 1 ] [ 0 ] = 0 <NEWLINE> while Q : <NEWLINE> <INDENT> e , d , p = heappop ( Q ) <NEWLINE> if cost [ p ] [ d ] < e : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if p == N : <NEWLINE> <INDENT> print ( e ) <NEWLINE> break <NEWLINE> <DEDENT> for q , dd , de in G [ p ] : <NEWLINE> <INDENT> if d + dd <= L and e < cost [ q ] [ d + dd ] : <NEWLINE> <INDENT> heappush ( Q , ( e , d + dd , q ) ) <NEWLINE> cost [ q ] [ d + dd ] = e <NEWLINE> <DEDENT> if e + de < cost [ q ] [ d ] : <NEWLINE> <INDENT> heappush ( Q , ( e + de , d , q ) ) <NEWLINE> cost [ q ] [ d ] = e + de <NEWLINE> <DEDENT> <DEDENT> <DEDENT> N , M , L = inpl ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> coun = collections . Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( coun [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = { } <NEWLINE> for i in A : <NEWLINE> <INDENT> if i in dic : <NEWLINE> <INDENT> dic [ i ] = dic [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> s = sum ( A ) <NEWLINE> <NL> Q = int ( input ( ) ) <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <DEDENT> for b , c in zip ( B , C ) : <NEWLINE> <INDENT> if b in dic : <NEWLINE> <INDENT> temp = dic [ b ] <NEWLINE> s = s + ( c - b ) * temp <NEWLINE> del dic [ b ] <NEWLINE> if c in dic : <NEWLINE> <INDENT> dic [ c ] = dic [ c ] + temp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ c ] = temp <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
ans = [ 0 ] * 10 ** 6 <NEWLINE> <NL> for x in range ( 1 , 99 ) : <NEWLINE> <INDENT> for y in range ( 1 , 99 ) : <NEWLINE> <INDENT> for z in range ( 1 , 99 ) : <NEWLINE> <INDENT> ans [ ( x + y + z ) ** 2 - x * y - x * z - y * z ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = ( l [ 1 ] * l [ 5 ] - l [ 2 ] * l [ 4 ] ) / ( l [ 1 ] * l [ 3 ] - l [ 0 ] * l [ 4 ] ) <NEWLINE> y = ( l [ 2 ] - l [ 0 ] * x ) / l [ 1 ] <NEWLINE> if x == 0 : x = 0 <NEWLINE> print ( <STRING> . format ( x , y ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> try : <NEWLINE> <INDENT> if a . index ( 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> <NL> <NL> def isprime ( n ) : <NEWLINE> <INDENT> if n == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif n < 2 or n % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 3 , math . floor ( math . sqrt ( n ) ) + 1 , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ms = ( int ( input ( ) ) for i in range ( n ) ) <NEWLINE> print ( len ( list ( filter ( isprime , ms ) ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def koch_divide ( p , q ) : <NEWLINE> <INDENT> v = [ q [ 0 ] - p [ 0 ] , q [ 1 ] - p [ 1 ] ] <NEWLINE> s = [ p [ 0 ] + v [ 0 ] / 3 , p [ 1 ] + v [ 1 ] / 3 ] <NEWLINE> t = [ q [ 0 ] - v [ 0 ] / 3 , q [ 1 ] - v [ 1 ] / 3 ] <NEWLINE> u = [ p [ 0 ] + v [ 0 ] * 0.5 - v [ 1 ] * 0.288675 , p [ 1 ] + v [ 0 ] * 0.288675 + v [ 1 ] * 0.5 ] <NEWLINE> return [ s , u , t , q ] <NEWLINE> <NL> <DEDENT> def koch_curve ( previous ) : <NEWLINE> <INDENT> vertices = [ previous [ 0 ] ] <NEWLINE> for p , q in zip ( previous [ : - 1 ] , previous [ 1 : ] ) : <NEWLINE> <INDENT> vertices . extend ( koch_divide ( p , q ) ) <NEWLINE> <DEDENT> return vertices <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> p_q = [ [ 0.0 , 0.0 ] , [ 100.0 , 0.0 ] ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> p_q = koch_curve ( p_q ) <NEWLINE> <DEDENT> for vertex in p_q : <NEWLINE> <INDENT> print ( <STRING> . join ( [ <STRING> . format ( x ) for x in vertex ] ) ) <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> readline = stdin . readline <NEWLINE> n = int ( readline ( ) ) <NEWLINE> s = tuple ( readline ( ) . strip ( ) for _ in range ( n ) ) <NEWLINE> <NL> plus , minus = [ ] , [ ] <NEWLINE> for c in s : <NEWLINE> <INDENT> if 2 * c . count ( <STRING> ) - len ( c ) > 0 : <NEWLINE> <INDENT> plus . append ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus . append ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> plus . sort ( key = lambda x : x . count ( <STRING> ) ) <NEWLINE> minus . sort ( key = lambda x : x . count ( <STRING> ) , reverse = True ) <NEWLINE> plus . extend ( minus ) <NEWLINE> sum = 0 <NEWLINE> for v in plus : <NEWLINE> <INDENT> for vv in v : <NEWLINE> <INDENT> sum = sum + ( 1 if vv == <STRING> else - 1 ) <NEWLINE> if sum < 0 : return print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if sum != 0 : <NEWLINE> <INDENT> return print ( <STRING> ) <NEWLINE> <NL> <DEDENT> return print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> from itertools import permutations <NEWLINE> N = int ( input ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> ans_ = 0 <NEWLINE> count = 0 <NEWLINE> sum_list = list ( permutations ( range ( N ) , N ) ) <NEWLINE> for nums in sum_list : <NEWLINE> <INDENT> for i in range ( len ( nums ) - 1 ) : <NEWLINE> <INDENT> x1 , y1 = xy [ nums [ i ] ] <NEWLINE> x2 , y2 = xy [ nums [ i + 1 ] ] <NEWLINE> ans_ += math . sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> print ( ans_ / count ) <NEWLINE>
K = int ( input ( ) ) + 1 <NEWLINE> <NL> Ans = 0 <NEWLINE> from math import gcd <NEWLINE> for i in range ( 1 , K ) : <NEWLINE> <INDENT> for j in range ( 1 , K ) : <NEWLINE> <INDENT> tempA = gcd ( i , j ) <NEWLINE> for k in range ( 1 , K ) : <NEWLINE> <INDENT> Ans += gcd ( tempA , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( Ans ) <NEWLINE>
import math <NEWLINE> <NL> X = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1001 ) : <NEWLINE> <INDENT> f = round ( ( X + i ** 5 ) ** 0.2 ) <NEWLINE> if f ** 5 - i ** 5 == X : <NEWLINE> <INDENT> print ( int ( ( X + i ** 5 ) ** 0.2 ) , i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , 1001 ) : <NEWLINE> <INDENT> f = round ( abs ( X - i ** 5 ) ** 0.2 ) <NEWLINE> if X - i ** 5 > 0 : <NEWLINE> <INDENT> if f ** 5 - ( - i ) ** 5 == X : <NEWLINE> <INDENT> print ( f , - i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( - f ) ** 5 - ( - i ) ** 5 == X : <NEWLINE> <INDENT> print ( - f , - i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if not n : break <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> t = [ [ 0 for _ in range ( n + 1 ) ] for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> t [ i ] [ j ] = a [ i ] [ j ] <NEWLINE> t [ i ] [ n ] += a [ i ] [ j ] <NEWLINE> t [ n ] [ j ] += a [ i ] [ j ] <NEWLINE> t [ n ] [ n ] += a [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( <STRING> . format , t [ i ] ) ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> if a [ 0 ] < 2 : <NEWLINE> <INDENT> print ( a [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> sys . exit ( ) <NEWLINE> <DEDENT> tree = [ 0 for _i in range ( n + 2 ) ] <NEWLINE> tree [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> tree [ i ] = tree [ i - 1 ] * 2 <NEWLINE> tree [ i ] -= a [ i ] <NEWLINE> <DEDENT> tree [ n ] += a [ i ] <NEWLINE> for i in range ( n , 0 , - 1 ) : <NEWLINE> <INDENT> if tree [ i - 1 ] * 2 < a [ i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> x = min ( tree [ i - 1 ] , a [ i ] ) <NEWLINE> a [ i - 1 ] += x <NEWLINE> <DEDENT> if a [ 0 ] > 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( a ) ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> P = list ( range ( - 1 , 103 ) ) <NEWLINE> [ P . remove ( pp ) for pp in p ] <NEWLINE> p_min_abs = 10000000 <NEWLINE> <NL> for pp in P : <NEWLINE> <INDENT> if abs ( pp - X ) < p_min_abs : <NEWLINE> <INDENT> p_min_abs = abs ( pp - X ) <NEWLINE> p_min = pp <NEWLINE> <DEDENT> <DEDENT> print ( p_min ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = np . zeros ( n ) <NEWLINE> <NL> x , y , z = 1 , 1 , 1 <NEWLINE> <NL> while x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <= n : <NEWLINE> <INDENT> while x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <= n : <NEWLINE> <INDENT> while x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <= n : <NEWLINE> <INDENT> i = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> A [ i - 1 ] += 1 <NEWLINE> z += 1 <NEWLINE> <DEDENT> z = 1 <NEWLINE> y += 1 <NEWLINE> <DEDENT> y , z = 1 , 1 <NEWLINE> x += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( int ( A [ i ] ) ) <NEWLINE> <NL> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> counter = Counter ( A ) <NEWLINE> B = [ 1 ] * ( max ( A ) + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> for k in range ( a * 2 , len ( B ) , a ) : <NEWLINE> <INDENT> B [ k ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( B [ a ] == 1 and counter [ a ] == 1 for a in A ) ) <NEWLINE>
H , W , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> C = H - A <NEWLINE> D = W - B <NEWLINE> p = 1000000007 <NEWLINE> <NL> def power ( a , b ) : <COMMENT> <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif b % 2 == 0 : <NEWLINE> <INDENT> return power ( a , b // 2 ) ** 2 % p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return power ( a , b // 2 ) ** 2 * a % p <NEWLINE> <NL> <DEDENT> <DEDENT> f = [ 1 ] <COMMENT> <NEWLINE> for i in range ( H + W ) : <NEWLINE> <INDENT> f . append ( f [ i ] * ( i + 1 ) % p ) <NEWLINE> <NL> <DEDENT> I_f = [ 0 ] * ( H + W + 1 ) <COMMENT> <NEWLINE> I_f [ H + W ] = power ( f [ H + W ] , p - 2 ) <NEWLINE> for i in reversed ( range ( H + W ) ) : <NEWLINE> <INDENT> I_f [ i ] = I_f [ i + 1 ] * ( i + 1 ) % p <NEWLINE> <NL> <DEDENT> def combi ( a , b ) : <COMMENT> <NEWLINE> <INDENT> return f [ a + b ] * I_f [ a ] * I_f [ b ] % p <NEWLINE> <NL> <DEDENT> x = 0 <NEWLINE> for i in range ( C ) : <NEWLINE> <INDENT> x = ( x + combi ( i , B - 1 ) * combi ( D - 1 , H - i - 1 ) ) % p <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> AReqTime = [ 0 ] <NEWLINE> BReqTime = [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> AReqTime . append ( AReqTime [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> BReqTime . append ( BReqTime [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> j = M <NEWLINE> answer = 0 <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if ( AReqTime [ i ] > K ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> while BReqTime [ j ] > K - AReqTime [ i ] : <NEWLINE> <INDENT> j = j - 1 <NEWLINE> <NL> <DEDENT> answer = max ( i + j , answer ) <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> a = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if ( a [ i ] > a [ i - k ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> order = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> order [ a [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , order ) ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> if S == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> A = [ 0 ] * ( S + 1 ) <NEWLINE> A [ 0 ] = 1 <NEWLINE> A [ 1 ] = 0 <NEWLINE> A [ 2 ] = 0 <NEWLINE> <NL> cumsum = 1 <NEWLINE> for i in range ( 3 , len ( A ) ) : <NEWLINE> <INDENT> A [ i ] = cumsum <NEWLINE> cumsum += A [ i - 2 ] <NEWLINE> cumsum %= MOD <NEWLINE> <DEDENT> print ( A [ - 1 ] ) <NEWLINE>
def f ( n ) : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n %= bin ( n ) . count ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> d = x . count ( <STRING> ) <NEWLINE> if d == 1 : <NEWLINE> <INDENT> for i in x [ : - 1 ] : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> if x [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> M = 0 <NEWLINE> for i in x : <NEWLINE> <INDENT> M <<= 1 <NEWLINE> if i == <STRING> : <NEWLINE> <INDENT> M += 1 <NEWLINE> <DEDENT> <DEDENT> p = M % ( d + 1 ) <NEWLINE> m = M % ( d - 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> ans . append ( f ( ( p + pow ( 2 , n - i - 1 , d + 1 ) ) % ( d + 1 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( f ( ( m - pow ( 2 , n - i - 1 , d - 1 ) ) % ( d - 1 ) ) ) <NEWLINE> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <DEDENT>
def can_load ( num_baggages , baggages , num_truck , max_load ) : <NEWLINE> <INDENT> bag_no = 0 <NEWLINE> <NL> for i in range ( num_truck ) : <NEWLINE> <INDENT> load_cap = max_load <NEWLINE> while load_cap > 0 : <NEWLINE> <INDENT> if bag_no >= num_baggages : <NEWLINE> <COMMENT> <NL> <INDENT> return True <NEWLINE> <DEDENT> if load_cap >= baggages [ bag_no ] : <NEWLINE> <INDENT> load_cap -= baggages [ bag_no ] <NEWLINE> bag_no += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> return bag_no >= num_baggages <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> num_baggages , num_trucks = map ( int , input ( ) . split ( ) ) <NEWLINE> baggages = [ int ( input ( ) ) for x in range ( num_baggages ) ] <NEWLINE> <NL> start = max ( sum ( baggages ) // num_trucks , min ( baggages ) ) <NEWLINE> end = sum ( baggages ) <NEWLINE> <NL> while start < end : <NEWLINE> <INDENT> mid = ( start + end ) // 2 <NEWLINE> if can_load ( num_baggages , baggages , num_trucks , mid ) : <NEWLINE> <INDENT> end = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start = mid + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( start ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> def IS ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def II ( ) : return int ( IS ( ) ) <NEWLINE> def MII ( ) : return list ( map ( int , IS ( ) . split ( ) ) ) <NEWLINE> def MIIZ ( ) : return list ( map ( lambda x : x - 1 , MII ( ) ) ) <NEWLINE> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> h , w , m = MII ( ) <NEWLINE> bombs = [ MIIZ ( ) for _ in range ( m ) ] <NEWLINE> a = [ 0 ] * h <NEWLINE> b = [ 0 ] * w <NEWLINE> for y , x in bombs : <NEWLINE> <INDENT> a [ y ] += 1 <NEWLINE> b [ x ] += 1 <NEWLINE> <DEDENT> maxa = max ( a ) <NEWLINE> maxb = max ( b ) <NEWLINE> sumv = maxa + maxb <NEWLINE> c = a . count ( maxa ) * b . count ( maxb ) - sum ( a [ y ] + b [ x ] == sumv for y , x in bombs ) <NEWLINE> print ( sumv - ( c <= 0 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> while True : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> if num == 0 : break <NEWLINE> array = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> mean = sum ( array ) / num <NEWLINE> a = 0 <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> a += ( array [ i ] - mean ) ** 2 <NEWLINE> <DEDENT> a /= num <NEWLINE> a = math . sqrt ( a ) <NEWLINE> print ( a ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_list = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> node = 1 <NEWLINE> flg = False <NEWLINE> node_list = [ node ] <NEWLINE> <NL> for i in range ( len ( a_list ) - 1 ) : <NEWLINE> <INDENT> num = a_list [ i ] <NEWLINE> next = node - num <NEWLINE> if next < 0 : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <DEDENT> node = next * 2 <NEWLINE> node_list . append ( node ) <NEWLINE> <NL> <DEDENT> if node - a_list [ - 1 ] < 0 : <NEWLINE> <INDENT> flg = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = a_list [ - 1 ] <NEWLINE> res_list = [ a_list [ - 1 ] ] <NEWLINE> for i in range ( len ( a_list ) - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> v = node_list [ i ] - a_list [ i ] <COMMENT> <NEWLINE> diff = min ( diff , v ) + a_list [ i ] <NEWLINE> res_list . append ( diff ) <NEWLINE> <NL> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( res_list ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> ans1 = 0 <NEWLINE> <NL> if N > B - 1 : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> print ( int ( ( A * x ) / B ) - A * int ( x / B ) ) <NEWLINE> <DEDENT> elif N <= B - 1 : <NEWLINE> <INDENT> x = N <NEWLINE> print ( int ( ( A * x ) / B ) - A * int ( x / B ) ) <NEWLINE> <NL> <NL> <DEDENT>
def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> n_list = factorization ( n ) <NEWLINE> oh = [ ] <NEWLINE> for i in range ( len ( n_list ) ) : <NEWLINE> <INDENT> num = n_list [ i ] [ 0 ] <COMMENT> <NEWLINE> kata = n_list [ i ] [ 1 ] <COMMENT> <NEWLINE> for i in range ( 1 , kata + 1 ) : <NEWLINE> <INDENT> oh . append ( num ** i ) <NEWLINE> <DEDENT> <DEDENT> oh . sort ( ) <NEWLINE> ans = 0 <NEWLINE> z = [ ] <NEWLINE> for i in range ( len ( oh ) ) : <NEWLINE> <INDENT> if oh [ i ] == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n % oh [ i ] == 0 and oh [ i ] not in z : <NEWLINE> <INDENT> z . append ( oh [ i ] ) <NEWLINE> n = n / oh [ i ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> edges = [ [ ] for i in range ( 2 * 10 ** 5 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> xi , yi = map ( int , input ( ) . split ( ) ) <NEWLINE> xi -= 1 <NEWLINE> yi = yi - 1 + 10 ** 5 <NEWLINE> edges [ xi ] . append ( yi ) <NEWLINE> edges [ yi ] . append ( xi ) <NEWLINE> <NL> <DEDENT> already = set ( [ ] ) <NEWLINE> def dfs ( x , y , node ) : <NEWLINE> <INDENT> if node in already : <NEWLINE> <INDENT> return x , y <NEWLINE> <DEDENT> if node < 10 ** 5 : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y += 1 <NEWLINE> <DEDENT> already . add ( node ) <NEWLINE> for next_node in edges [ node ] : <NEWLINE> <INDENT> x , y = dfs ( x , y , next_node ) <NEWLINE> <DEDENT> return x , y <NEWLINE> <NL> <DEDENT> num = 0 <NEWLINE> for i in range ( 10 ** 5 ) : <NEWLINE> <INDENT> x , y = dfs ( 0 , 0 , i ) <NEWLINE> num += x * y <NEWLINE> <DEDENT> print ( num - n ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> mod = ( 10 ** 9 ) + 7 <NEWLINE> csum = sum ( a ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> csum -= a [ i ] <NEWLINE> ans += a [ i ] * csum <NEWLINE> <NL> <DEDENT> ans = int ( ans % mod ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
from functools import lru_cache <NEWLINE> import sys <NEWLINE> <NL> iMaxStackSize = 5000000 <NEWLINE> sys . setrecursionlimit ( iMaxStackSize ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> heights = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> @ lru_cache ( None ) <NEWLINE> def solve ( i ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if i + 2 >= len ( heights ) : <NEWLINE> <INDENT> return abs ( heights [ i + 1 ] - heights [ i ] ) <NEWLINE> <DEDENT> option1 = abs ( heights [ i ] - heights [ i + 1 ] ) <NEWLINE> option1 += solve ( i + 1 ) <NEWLINE> option2 = abs ( heights [ i ] - heights [ i + 2 ] ) <NEWLINE> option2 += solve ( i + 2 ) <NEWLINE> return min ( option1 , option2 ) <NEWLINE> <NL> <DEDENT> print ( solve ( 0 ) ) <NEWLINE>
import sys <NEWLINE> from functools import reduce <NEWLINE> from math import gcd <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> N = int ( readline ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> lcm = reduce ( lambda x , y : x * y // gcd ( x , y ) , A ) <NEWLINE> ans = 0 <NEWLINE> ans = sum ( lcm // x for x in A ) <NEWLINE> print ( ans % mod ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> def zs ( num ) : <NEWLINE> <INDENT> k = 6 - len ( str ( num ) ) <NEWLINE> return <STRING> * k + str ( num ) <NEWLINE> <DEDENT> lst = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> lst . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> slst = sorted ( lst ) <NEWLINE> dic = { } <NEWLINE> temp = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if slst [ i ] [ 0 ] == slst [ i - 1 ] [ 0 ] : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = 1 <NEWLINE> <DEDENT> dic [ slst [ i ] ] = zs ( slst [ i ] [ 0 ] ) + zs ( temp ) <NEWLINE> <DEDENT> for i in lst : <NEWLINE> <INDENT> print ( dic [ i ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> from sys import maxsize <NEWLINE> from copy import deepcopy <NEWLINE> <NL> <NL> class Graph : <NEWLINE> <INDENT> def __init__ ( self , No_of_nodes ) : <NEWLINE> <INDENT> self . n = No_of_nodes <NEWLINE> self . adj = [ [ ] for i in range ( self . n ) ] <NEWLINE> <NL> <DEDENT> def addEdge ( self , a , b , w ) : <NEWLINE> <INDENT> self . adj [ a ] . append ( [ b , w ] ) <NEWLINE> <NL> <DEDENT> def BFS ( self , start ) : <NEWLINE> <INDENT> visited = [ False ] * self . n <NEWLINE> depth = [ 0 for i in range ( self . n ) ] <NEWLINE> que = deque ( ) <NEWLINE> q = [ start ] <NEWLINE> que . append ( start ) <NEWLINE> visited [ start ] = True <NEWLINE> ans = <STRING> <NEWLINE> f = 0 <NEWLINE> while que : <NEWLINE> <INDENT> s = que . popleft ( ) <NEWLINE> ans += str ( s ) + <STRING> <NEWLINE> for i in self . adj [ s ] : <NEWLINE> <INDENT> if not visited [ i [ 0 ] ] : <NEWLINE> <INDENT> depth [ i [ 0 ] ] = s <NEWLINE> que . append ( i [ 0 ] ) <NEWLINE> visited [ i [ 0 ] ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return depth <NEWLINE> <NL> <DEDENT> def dijkstra ( self , start ) : <NEWLINE> <INDENT> nxtpoint = [ None for i in range ( self . n ) ] <NEWLINE> distance = [ maxsize for i in range ( self . n ) ] <NEWLINE> distance [ start ] = 0 <NEWLINE> q = deque ( ) <NEWLINE> q . append ( start ) <NEWLINE> while len ( q ) != 0 : <NEWLINE> <INDENT> a = q . pop ( ) <NEWLINE> for u in self . adj [ a ] : <NEWLINE> <INDENT> b , w = u <NEWLINE> if distance [ a ] + w < distance [ b ] : <NEWLINE> <INDENT> distance [ b ] = distance [ a ] + w <NEWLINE> nxtpoint [ b ] = a <NEWLINE> q . append ( b ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return nxtpoint <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ls = [ ] <NEWLINE> g = Graph ( n ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> g . addEdge ( a , b , 1 ) <NEWLINE> g . addEdge ( b , a , 1 ) <NEWLINE> <DEDENT> point = g . BFS ( 0 ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if point [ i ] is None : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += str ( point [ i ] + 1 ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ [ ] for i in range ( m ) ] <NEWLINE> g = [ 0 for i in range ( h ) ] <NEWLINE> r = [ 0 for i in range ( w ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ i ] . append ( x ) <NEWLINE> a [ i ] . append ( y ) <NEWLINE> g [ x - 1 ] += 1 <NEWLINE> r [ y - 1 ] += 1 <NEWLINE> <DEDENT> G = [ 0 for i in range ( h ) ] <NEWLINE> R = [ 0 for i in range ( w ) ] <NEWLINE> d = max ( g ) <NEWLINE> e = max ( r ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if g [ i ] == d : <NEWLINE> <INDENT> G [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( w ) : <NEWLINE> <INDENT> if r [ i ] == e : <NEWLINE> <INDENT> R [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> f = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> q = 0 <NEWLINE> x = a [ i ] [ 0 ] <NEWLINE> y = a [ i ] [ 1 ] <NEWLINE> if G [ x - 1 ] == 1 : <NEWLINE> <INDENT> p = 1 <NEWLINE> <DEDENT> if R [ y - 1 ] == 1 : <NEWLINE> <INDENT> q = 1 <NEWLINE> <NL> <NL> <DEDENT> if p == q == 1 : <NEWLINE> <INDENT> f += 1 <NEWLINE> <DEDENT> <DEDENT> v = 1 <NEWLINE> if f != G . count ( 1 ) * R . count ( 1 ) : <NEWLINE> <INDENT> v = 0 <NEWLINE> <DEDENT> ans = max ( g ) + max ( r ) <NEWLINE> print ( ans if v == 0 else ans - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> Building = [ [ [ 0 for r in range ( 11 ) ] for f in range ( 4 ) ] for b in range ( 5 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> Building [ b ] [ f ] [ r ] += v <NEWLINE> <NL> <DEDENT> for b in range ( 1 , 5 ) : <NEWLINE> <INDENT> for f in range ( 1 , 4 ) : <NEWLINE> <INDENT> for r in range ( 1 , 11 ) : <NEWLINE> <INDENT> print ( <STRING> + str ( Building [ b ] [ f ] [ r ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> if b != 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> abs_A = list ( map ( lambda x : abs ( x ) , A ) ) <NEWLINE> <NL> pos = [ ] <NEWLINE> neg = [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> for e in A : <NEWLINE> <INDENT> if e > 0 : <NEWLINE> <INDENT> pos . append ( e ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> neg . append ( e ) <NEWLINE> <DEDENT> <DEDENT> if len ( neg ) % 2 == 0 : <NEWLINE> <INDENT> ans = sum ( abs_A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans = sum ( abs_A ) <NEWLINE> ans -= 2 * min ( abs_A ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> s = int ( s ) <NEWLINE> h = s // 3600 <NEWLINE> s = s - 3600 * h <NEWLINE> m = s // 60 <NEWLINE> s = s - 60 * m <NEWLINE> print ( h , <STRING> , m , <STRING> , s , sep = <STRING> ) <NEWLINE>
a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> print ( a * b , ( 2 * a ) + ( 2 * b ) ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> from sys import stdin <NEWLINE> def input ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> dist = [ - 1 ] * N <NEWLINE> G = dict ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> G [ i ] = [ ] <NEWLINE> <DEDENT> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a - 1 ] . append ( b - 1 ) <NEWLINE> G [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> q = [ 0 ] <NEWLINE> pre = [ 0 ] * N <NEWLINE> dist [ 0 ] = 0 <NEWLINE> while ( q != [ ] ) : <NEWLINE> <INDENT> v = q [ 0 ] <NEWLINE> q . remove ( q [ 0 ] ) <NEWLINE> for vertex in G [ v ] : <NEWLINE> <INDENT> if dist [ vertex ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ vertex ] = dist [ v ] + 1 <NEWLINE> pre [ vertex ] = v <NEWLINE> q . append ( vertex ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for v in range ( 1 , N ) : <NEWLINE> <INDENT> print ( pre [ v ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> S = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = input ( ) <NEWLINE> T = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = 0 <NEWLINE> <NL> for i in T : <NEWLINE> <INDENT> if i in S : <NEWLINE> <INDENT> C += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( C ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> anses = [ ] <NEWLINE> for i in range ( 0 , len ( s ) - len ( t ) + 1 , 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ i + j ] == t [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> anses . append ( cnt ) <NEWLINE> <DEDENT> print ( len ( t ) - max ( anses ) ) <NEWLINE>
def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = input ( ) <NEWLINE> heights = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> max_value = 0 <NEWLINE> <NL> for i in range ( 0 , len ( heights ) ) : <NEWLINE> <INDENT> if max_value < heights [ i ] : <NEWLINE> <INDENT> max_value = heights [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum = sum + max_value - heights [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
from collections import deque <NEWLINE> count = 0 <NEWLINE> <NL> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> L = deque ( A [ left : mid ] ) <NEWLINE> R = deque ( A [ mid : right ] ) <NEWLINE> L . append ( float ( <STRING> ) ) <NEWLINE> R . append ( float ( <STRING> ) ) <NEWLINE> <NL> global count <NEWLINE> <NL> for k in range ( left , right ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if L [ 0 ] <= R [ 0 ] : <NEWLINE> <INDENT> A [ k ] = L . popleft ( ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R . popleft ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> middle = ( left + right ) // 2 <NEWLINE> mergeSort ( A , left , middle ) <NEWLINE> mergeSort ( A , middle , right ) <NEWLINE> merge ( A , left , middle , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> input ( ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mergeSort ( l , 0 , len ( l ) ) <NEWLINE> print ( * l ) <NEWLINE> print ( count ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> <NL> test = list ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> count = [ 0 , 0 , 0 ] <NEWLINE> i = 0 <NEWLINE> before = <STRING> <NEWLINE> <NL> for str in test : <NEWLINE> <INDENT> if str == <STRING> : <NEWLINE> <INDENT> count [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( count ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A . sort ( reverse = True ) <NEWLINE> result = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> result *= i <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import bisect <NEWLINE> import itertools <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> stdin = sys . stdin <NEWLINE> <NL> ni = lambda : int ( ns ( ) ) <NEWLINE> na = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> ns = lambda : stdin . readline ( ) . rstrip ( ) <COMMENT> <NEWLINE> <NL> n = ni ( ) <NEWLINE> a = na ( ) <NEWLINE> b = a . copy ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] += i + 1 <NEWLINE> b [ i ] -= i + 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> b . sort ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += bisect . bisect_right ( b , - a [ i ] ) - bisect . bisect_left ( b , - a [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> print ( input ( ) . swapcase ( ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> import math <NEWLINE> <NL> a , b , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ - math . inf ] <NEWLINE> t = [ - math . inf ] <NEWLINE> x = [ ] <NEWLINE> for _ in range ( a ) : <NEWLINE> <INDENT> s . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for _ in range ( b ) : <NEWLINE> <INDENT> t . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> x . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> s . append ( math . inf ) <NEWLINE> t . append ( math . inf ) <NEWLINE> <NL> for i in x : <NEWLINE> <INDENT> ws = abs ( s [ bisect . bisect ( s , i ) - 1 ] - i ) <NEWLINE> if ws != math . inf : <NEWLINE> <INDENT> ws += min ( abs ( t [ bisect . bisect ( t , s [ bisect . bisect ( s , i ) - 1 ] ) - 1 ] - s [ bisect . bisect ( s , i ) - 1 ] ) , abs ( t [ bisect . bisect ( t , s [ bisect . bisect ( s , i ) - 1 ] ) ] - s [ bisect . bisect ( s , i ) - 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ws = math . inf <NEWLINE> <NL> <DEDENT> es = abs ( s [ bisect . bisect ( s , i ) ] - i ) <NEWLINE> if es != math . inf : <NEWLINE> <INDENT> es += min ( abs ( t [ bisect . bisect ( t , s [ bisect . bisect ( s , i ) ] ) - 1 ] - s [ bisect . bisect ( s , i ) ] ) , abs ( t [ bisect . bisect ( t , s [ bisect . bisect ( s , i ) ] ) ] - s [ bisect . bisect ( s , i ) ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> es = math . inf <NEWLINE> <NL> <DEDENT> wt = abs ( t [ bisect . bisect ( t , i ) - 1 ] - i ) <NEWLINE> if wt != math . inf : <NEWLINE> <INDENT> wt += min ( abs ( s [ bisect . bisect ( s , t [ bisect . bisect ( t , i ) - 1 ] ) - 1 ] - t [ bisect . bisect ( t , i ) - 1 ] ) , abs ( s [ bisect . bisect ( s , t [ bisect . bisect ( t , i ) - 1 ] ) ] - t [ bisect . bisect ( t , i ) - 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wt = math . inf <NEWLINE> <NL> <DEDENT> et = abs ( t [ bisect . bisect ( t , i ) ] - i ) <NEWLINE> if et != math . inf : <NEWLINE> <INDENT> et += min ( abs ( s [ bisect . bisect ( s , t [ bisect . bisect ( t , i ) ] ) - 1 ] - t [ bisect . bisect ( t , i ) ] ) , abs ( s [ bisect . bisect ( s , t [ bisect . bisect ( t , i ) ] ) ] - t [ bisect . bisect ( t , i ) ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> et = math . inf <NEWLINE> <NL> <DEDENT> print ( min ( ws , es , wt , et ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> INT = lambda : int ( input ( ) ) <NEWLINE> INTM = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> STRM = lambda : map ( str , input ( ) . split ( ) ) <NEWLINE> STR = lambda : str ( input ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LISTS = lambda : list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> def do ( ) : <NEWLINE> <INDENT> n = INT ( ) <NEWLINE> a = np . array ( LIST ( ) ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( 70 ) : <NEWLINE> <INDENT> digit = np . sum ( ( a >> i ) & 1 ) <NEWLINE> ans += pow ( 2 , i , mod ) * ( ( ( n - digit ) * digit ) % mod ) % mod <NEWLINE> ans = ans % mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> do ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> mini = float ( <STRING> ) <NEWLINE> <NL> for i in range ( 0 , len ( P ) ) : <NEWLINE> <INDENT> if P [ i ] < mini : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> mini = P [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import itertools <NEWLINE> from collections import deque <NEWLINE> from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> M = [ input ( ) [ : - 1 ] for _ in range ( H ) ] <NEWLINE> <NL> def bfs ( start ) : <NEWLINE> <INDENT> dist = [ [ float ( <STRING> ) ] * W for _ in range ( H ) ] <NEWLINE> dist [ start [ 0 ] ] [ start [ 1 ] ] = 0 <NEWLINE> <NL> is_visited = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> q = deque ( [ start ] ) <NEWLINE> max_ = 0 <NEWLINE> <NL> while len ( q ) : <NEWLINE> <INDENT> now_h , now_w = q . popleft ( ) <NEWLINE> if M [ now_h ] [ now_w ] == <STRING> : <NEWLINE> <INDENT> return <NEWLINE> <COMMENT> <NL> <DEDENT> is_visited [ now_h ] [ now_w ] = float ( <STRING> ) <NEWLINE> for next_h , next_w in ( ( now_h + 1 , now_w ) , <NEWLINE> <INDENT> ( now_h - 1 , now_w ) , <NEWLINE> ( now_h , now_w - 1 ) , <NEWLINE> ( now_h , now_w + 1 ) ) : <NEWLINE> <NL> if not ( 0 <= next_h < H ) or not ( 0 <= next_w < W ) or ( dist [ next_h ] [ next_w ] != float ( <STRING> ) ) or M [ next_h ] [ next_w ] == <STRING> : <NEWLINE> <COMMENT> <NL> continue <NEWLINE> <NL> dist [ next_h ] [ next_w ] = dist [ now_h ] [ now_w ] + 1 <NEWLINE> max_ = max ( max_ , dist [ next_h ] [ next_w ] ) <NEWLINE> q . append ( ( next_h , next_w ) ) <NEWLINE> <DEDENT> <DEDENT> return max_ <NEWLINE> <NL> <DEDENT> max_ = 0 <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if M [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> max_ = max ( bfs ( ( h , w ) ) , max_ ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max_ ) <NEWLINE> <NL> <NL> <DEDENT> if ( __name__ == <STRING> ) : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> c = [ 0 if x == <STRING> else 1 for x in input ( ) ] <NEWLINE> counter = 0 <NEWLINE> <NL> white_index = [ i for i , ele in enumerate ( c ) if ele == 0 ] <NEWLINE> red_index = [ i for i in range ( len ( c ) - 1 , - 1 , - 1 ) if c [ i ] == 1 ] <NEWLINE> <NL> <NL> for i in range ( min ( len ( white_index ) , len ( red_index ) ) ) : <NEWLINE> <INDENT> if white_index [ i ] < red_index [ i ] : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
<COMMENT> <NL> from collections import Counter <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = Counter ( a ) <NEWLINE> d = [ 0 ] + [ l [ i + 1 ] for i in range ( 10 ** 5 ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> s = sum ( a ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if d [ B ] != 0 : <NEWLINE> <INDENT> tmp = d [ B ] <NEWLINE> d [ B ] = 0 <NEWLINE> d [ C ] += tmp <NEWLINE> s = s - tmp * B + tmp * C <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> list = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> list . append ( str ( input ( ) ) ) <NEWLINE> <DEDENT> a = list . count ( <STRING> ) <NEWLINE> b = list . count ( <STRING> ) <NEWLINE> c = list . count ( <STRING> ) <NEWLINE> d = list . count ( <STRING> ) <NEWLINE> <NL> print ( <STRING> , a ) <NEWLINE> print ( <STRING> , b ) <NEWLINE> print ( <STRING> , c ) <NEWLINE> print ( <STRING> , d ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> cs = input ( ) <NEWLINE> r_num = 0 <NEWLINE> w_num = 0 <NEWLINE> <COMMENT> <NL> r_num = cs . count ( <STRING> ) <NEWLINE> w_num = cs . count ( <STRING> ) <NEWLINE> <NL> if r_num == 0 or w_num == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> W = 0 <NEWLINE> rl_num = 0 <NEWLINE> for c in cs : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> rl_num += 1 <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> W += 1 <NEWLINE> <DEDENT> R = r_num - rl_num <NEWLINE> ans . append ( max ( W , R ) ) <NEWLINE> <NL> <DEDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . insert ( 0 , - 1 ) <NEWLINE> root = [ 1 ] <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> root . append ( A [ root [ - 1 ] ] ) <NEWLINE> <NL> <DEDENT> if K > N : <NEWLINE> <INDENT> start = root . index ( root [ - 1 ] ) <NEWLINE> index = ( K - start ) % ( len ( root ) - start - 1 ) + start <NEWLINE> ans = root [ index ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = root [ K ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> hashmap = { } <NEWLINE> for k in K : <NEWLINE> <INDENT> if k not in hashmap : <NEWLINE> <INDENT> hashmap [ k ] = 0 <NEWLINE> <DEDENT> hashmap [ k ] += 1 <NEWLINE> <DEDENT> total = 0 <NEWLINE> for v in hashmap . values ( ) : <NEWLINE> <INDENT> if v >= 2 : <NEWLINE> <INDENT> total += math . factorial ( v ) // ( math . factorial ( v - 2 ) * 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for k in K : <NEWLINE> <INDENT> print ( total - ( hashmap [ k ] - 1 ) ) <NEWLINE> <DEDENT>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf , comb <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> from functools import reduce <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> n , k = MAP ( ) <NEWLINE> a = LIST ( ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> if a [ 0 ] == k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> m = gcd ( a [ 0 ] , a [ 1 ] ) <NEWLINE> for x in a : <NEWLINE> <INDENT> m = gcd ( m , x ) <NEWLINE> <DEDENT> for x in a : <NEWLINE> <INDENT> if x - k >= 0 and ( x - k ) % m == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> sum_a = sum ( A ) <NEWLINE> sum_squares = sum ( [ a * a for a in A ] ) <NEWLINE> <NL> ans = ( sum_a ** 2 - sum_squares ) // 2 <NEWLINE> ans %= MOD <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from string import ascii_lowercase , ascii_uppercase <NEWLINE> l = ascii_lowercase <NEWLINE> u = ascii_uppercase <NEWLINE> def conv ( c ) : <NEWLINE> <INDENT> if c in l : <NEWLINE> <INDENT> return u [ l . index ( c ) ] <NEWLINE> <DEDENT> if c in u : <NEWLINE> <INDENT> return l [ u . index ( c ) ] <NEWLINE> <DEDENT> return c <NEWLINE> <DEDENT> open ( 1 , <STRING> ) . write ( <STRING> . join ( map ( conv , open ( 0 ) . readline ( ) ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> total = 0 <NEWLINE> left = 0 <NEWLINE> sum = sum ( A ) <NEWLINE> <COMMENT> <NL> <NL> for i in range ( N - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> left = left + A [ i ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> right = sum - left <NEWLINE> <COMMENT> <NL> total = ( total + A [ i ] * right ) % 1000000007 <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE>
import itertools <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = [ i for i in range ( 1 , m + 1 ) ] <NEWLINE> lis = list ( itertools . combinations_with_replacement ( lis , n ) ) <NEWLINE> box = [ 0 for j in range ( len ( lis ) ) ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> que = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( len ( lis ) ) : <NEWLINE> <INDENT> if lis [ j ] [ que [ 1 ] - 1 ] - lis [ j ] [ que [ 0 ] - 1 ] == que [ 2 ] : <NEWLINE> <INDENT> box [ j ] += que [ 3 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( box ) ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> m = int ( input ( ) ) <NEWLINE> A = [ list ( input ( ) . split ( ) ) for i in range ( m ) ] <NEWLINE> <NL> T = [ [ - 1 , - 1 , - 1 , - 1 ] ] <NEWLINE> def insert ( T , u , x ) : <NEWLINE> <INDENT> if T [ 0 ] [ 3 ] == - 1 : <NEWLINE> <INDENT> T [ 0 ] [ 3 ] = x <NEWLINE> return <NEWLINE> <DEDENT> if x < T [ u ] [ 3 ] : <NEWLINE> <INDENT> if T [ u ] [ 1 ] == - 1 : <NEWLINE> <INDENT> T [ u ] [ 1 ] = len ( T ) <NEWLINE> T . append ( [ u , - 1 , - 1 , x ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> insert ( T , T [ u ] [ 1 ] , x ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if T [ u ] [ 2 ] == - 1 : <NEWLINE> <INDENT> T [ u ] [ 2 ] = len ( T ) <NEWLINE> T . append ( [ u , - 1 , - 1 , x ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> insert ( T , T [ u ] [ 2 ] , x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> def ino ( u ) : <NEWLINE> <INDENT> if T [ u ] [ 1 ] != - 1 : <NEWLINE> <INDENT> ino ( T [ u ] [ 1 ] ) <NEWLINE> <DEDENT> ino_res . append ( str ( T [ u ] [ 3 ] ) ) <NEWLINE> if T [ u ] [ 2 ] != - 1 : <NEWLINE> <INDENT> ino ( T [ u ] [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> def pre ( u ) : <NEWLINE> <INDENT> pre_res . append ( str ( T [ u ] [ 3 ] ) ) <NEWLINE> if T [ u ] [ 1 ] != - 1 : <NEWLINE> <INDENT> pre ( T [ u ] [ 1 ] ) <NEWLINE> <DEDENT> if T [ u ] [ 2 ] != - 1 : <NEWLINE> <INDENT> pre ( T [ u ] [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> def find ( u , x ) : <NEWLINE> <INDENT> if x == T [ u ] [ 3 ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif x < T [ u ] [ 3 ] : <NEWLINE> <INDENT> if T [ u ] [ 1 ] == - 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return find ( T [ u ] [ 1 ] , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if T [ u ] [ 2 ] == - 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return find ( T [ u ] [ 2 ] , x ) <NEWLINE> <DEDENT> <DEDENT> for c in A : <NEWLINE> <INDENT> if c [ 0 ] == <STRING> : <NEWLINE> <INDENT> insert ( T , 0 , int ( c [ 1 ] ) ) <NEWLINE> <DEDENT> elif c [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) if find ( 0 , int ( c [ 1 ] ) ) else print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ino_res = [ ] <NEWLINE> ino ( 0 ) <NEWLINE> pre_res = [ ] <NEWLINE> pre ( 0 ) <NEWLINE> print ( <STRING> + <STRING> . join ( ino_res ) ) <NEWLINE> print ( <STRING> + <STRING> . join ( pre_res ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<NL> def main ( ) : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> arr = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = tuple ( sorted ( enumerate ( arr ) , key = lambda tpl : - tpl [ 1 ] ) ) <NEWLINE> <NL> dp = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> for i , ( p , a ) in enumerate ( arr ) : <NEWLINE> <INDENT> for l in range ( i + 1 ) : <NEWLINE> <INDENT> dp [ i + 1 ] [ l ] = max ( dp [ i + 1 ] [ l ] , dp [ i ] [ l ] + a * abs ( p - ( n - ( i - l ) - 1 ) ) ) <NEWLINE> dp [ i + 1 ] [ l + 1 ] = max ( dp [ i + 1 ] [ l + 1 ] , dp [ i ] [ l ] + a * abs ( p - l ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( dp [ n ] ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = 10 ** 9 + 1 <NEWLINE> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> L = A [ left : left + n1 ] <NEWLINE> R = A [ mid : mid + n2 ] <NEWLINE> L . append ( M ) <NEWLINE> R . append ( M ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> mergeSort ( S , 0 , len ( S ) ) <NEWLINE> print ( * S ) <NEWLINE> print ( count ) <NEWLINE>
n = [ int ( x ) for x in input ( ) ] <NEWLINE> op_cnt = len ( n ) - 1 <NEWLINE> out = 0 <NEWLINE> for i in range ( 2 ** op_cnt ) : <NEWLINE> <INDENT> op = [ <STRING> ] * op_cnt <NEWLINE> box = <STRING> <NEWLINE> for j in range ( op_cnt ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> op [ op_cnt - 1 - j ] = <STRING> <NEWLINE> <DEDENT> box = <STRING> <NEWLINE> <DEDENT> for a , b in zip ( n , op + [ <STRING> ] ) : <NEWLINE> <INDENT> box += ( str ( a ) + b ) <NEWLINE> <DEDENT> box = box . split ( <STRING> ) <NEWLINE> ou = 0 <NEWLINE> for k in box : <NEWLINE> <INDENT> out += int ( k ) <NEWLINE> <DEDENT> <DEDENT> print ( out ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = sum ( lst ) % ( ( 10 ** 9 + 7 ) * 2 ) <NEWLINE> y = x ** 2 % ( ( 10 ** 9 + 7 ) * 2 ) <NEWLINE> z = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> z = ( z + ( lst [ i ] % ( ( 10 ** 9 + 7 ) * 2 ) ) ** 2 ) % ( ( 10 ** 9 + 7 ) * 2 ) <NEWLINE> <DEDENT> ans = int ( ( y - z ) % ( ( 10 ** 9 + 7 ) * 2 ) / 2 ) <NEWLINE> print ( ans ) <NEWLINE>
numTest = int ( input ( ) ) <NEWLINE> <NL> value = numTest % 10 <NEWLINE> <NL> if value == 2 or value == 4 or value == 5 or value == 7 or value == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif value == 0 or value == 1 or value == 6 or value == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif value == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> graph [ A ] . append ( B ) <NEWLINE> graph [ B ] . append ( A ) <NEWLINE> <NL> <DEDENT> def bfs ( maze , start ) : <NEWLINE> <INDENT> queue = deque ( [ start ] ) <NEWLINE> d = [ float ( <STRING> ) ] * N <NEWLINE> d [ start ] = 0 <NEWLINE> while queue : <NEWLINE> <INDENT> x = queue . popleft ( ) <NEWLINE> for y in graph [ x ] : <NEWLINE> <INDENT> if d [ y ] == float ( <STRING> ) : <NEWLINE> <INDENT> d [ y ] = d [ x ] + 1 <NEWLINE> queue . append ( y ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> d = bfs ( graph , 0 ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for vertex in graph [ i ] : <NEWLINE> <INDENT> if d [ vertex ] == d [ i ] - 1 : <NEWLINE> <INDENT> ans [ i ] = vertex + 1 <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * ans [ 1 : ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = 0 <NEWLINE> ans = 1000 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + 1 ] : <NEWLINE> <INDENT> k = ans // a [ i ] <NEWLINE> ans -= a [ i ] * k <NEWLINE> ans += a [ i + 1 ] * k <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans = i * ans % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> def histogram_sorted ( data ) : <NEWLINE> <INDENT> table = [ ] <NEWLINE> prev = data [ 0 ] <NEWLINE> c = 1 <NEWLINE> for i in range ( 1 , len ( data ) ) : <NEWLINE> <INDENT> if prev == data [ i ] : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> table . append ( [ prev , c ] ) <NEWLINE> prev = data [ i ] <NEWLINE> c = 1 <NEWLINE> <DEDENT> <DEDENT> table . append ( [ prev , c ] ) <NEWLINE> return table <NEWLINE> <NL> <DEDENT> T = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> T . append ( S [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> print ( len ( histogram_sorted ( sorted ( T ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> <NL> wi = c . find ( <STRING> ) <NEWLINE> ri = c . rfind ( <STRING> ) <NEWLINE> <NL> if wi == - 1 or ri == - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> while wi < ri : <NEWLINE> <INDENT> wi += 1 <NEWLINE> wi = c [ wi : ] . find ( <STRING> ) + wi <NEWLINE> ri = c [ : ri ] . rfind ( <STRING> ) <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> <NL> def f ( n ) : <NEWLINE> <INDENT> a = LI ( ) <NEWLINE> l = len ( a ) <NEWLINE> s = set ( ) <NEWLINE> r = 0 <NEWLINE> for i in range ( l - 1 ) : <NEWLINE> <INDENT> if abs ( a [ i ] - a [ i + 1 ] ) < 2 : <NEWLINE> <INDENT> s . add ( ( i , i + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 4 , l + 1 ) : <NEWLINE> <INDENT> for j in range ( l - i + 1 ) : <NEWLINE> <INDENT> k = j + i - 1 <NEWLINE> if ( j + 1 , k - 1 ) in s and abs ( a [ j ] - a [ k ] ) < 2 : <NEWLINE> <INDENT> s . add ( ( j , k ) ) <NEWLINE> continue <NEWLINE> <DEDENT> for m in range ( j + 2 , k , 2 ) : <NEWLINE> <INDENT> if ( j , m - 1 ) in s and ( m , k ) in s : <NEWLINE> <INDENT> s . add ( ( j , k ) ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> m = { } <NEWLINE> m [ l ] = 0 <NEWLINE> def _f ( i ) : <NEWLINE> <INDENT> if i in m : <NEWLINE> <INDENT> return m [ i ] <NEWLINE> <DEDENT> r = 0 <NEWLINE> for j in range ( i , l + 1 ) : <NEWLINE> <INDENT> t = _f ( j + 1 ) <NEWLINE> if ( i , j ) in s : <NEWLINE> <INDENT> t += j - i + 1 <NEWLINE> <DEDENT> if r < t : <NEWLINE> <INDENT> r = t <NEWLINE> <DEDENT> <DEDENT> m [ i ] = r <NEWLINE> return r <NEWLINE> <DEDENT> return _f ( 0 ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rr . append ( f ( n ) ) <NEWLINE> <NL> <DEDENT> return <STRING> . join ( map ( str , rr ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> q = N // i <NEWLINE> ans += q * ( q * i + i ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = l [ 0 ] <NEWLINE> count = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if m > l [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> m = l [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def strToList ( str , offset = 0 ) : <NEWLINE> <INDENT> res = [ ] ; <NEWLINE> for el in str . split ( <STRING> ) : <NEWLINE> <INDENT> if el != <STRING> : <NEWLINE> <INDENT> res . append ( int ( el ) + offset ) <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> [ N , M , K ] = strToList ( input ( ) ) <NEWLINE> A = strToList ( input ( ) ) <NEWLINE> B = strToList ( input ( ) ) <NEWLINE> <NL> current_time = 0 <NEWLINE> current_value = 0 <NEWLINE> iA = 0 <NEWLINE> iB = 0 <NEWLINE> <NL> while iA < N : <NEWLINE> <INDENT> if current_time + A [ iA ] <= K : <NEWLINE> <INDENT> current_time += A [ iA ] <NEWLINE> current_value += 1 <NEWLINE> iA += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> max_value = current_value <NEWLINE> iA -= 1 <NEWLINE> <NL> while iA > - 2 and iB < M : <NEWLINE> <INDENT> if current_time + B [ iB ] <= K : <NEWLINE> <INDENT> current_time += B [ iB ] <NEWLINE> iB += 1 <NEWLINE> current_value += 1 <NEWLINE> if current_value > max_value : <NEWLINE> <INDENT> max_value = current_value <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> current_time -= A [ iA ] <NEWLINE> iA -= 1 <NEWLINE> current_value -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_value ) <NEWLINE>
import collections <NEWLINE> def my_index_multi ( l , x ) : <NEWLINE> <INDENT> return [ i for i , _x in enumerate ( l ) if _x == x ] <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> goukei = sum ( A ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> BC . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> c = collections . Counter ( A ) <NEWLINE> for i in BC : <NEWLINE> <INDENT> goukei += c [ i [ 0 ] ] * ( i [ 1 ] - i [ 0 ] ) <NEWLINE> c [ i [ 1 ] ] = c [ i [ 0 ] ] + c [ i [ 1 ] ] <NEWLINE> c [ i [ 0 ] ] = 0 <NEWLINE> print ( goukei ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> p [ x - 1 ] . append ( y - 1 ) <NEWLINE> <NL> <DEDENT> f = [ - 1 for _ in range ( n ) ] <NEWLINE> <NL> def calc ( x ) : <NEWLINE> <INDENT> if f [ x ] != - 1 : <NEWLINE> <INDENT> return f [ x ] <NEWLINE> <DEDENT> if len ( p [ x ] ) == 0 : <NEWLINE> <INDENT> f [ x ] = 0 <NEWLINE> return 0 <NEWLINE> <DEDENT> f [ x ] = max ( [ calc ( i ) for i in p [ x ] ] ) + 1 <NEWLINE> return f [ x ] <NEWLINE> <NL> <DEDENT> m = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if f [ i ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> m = max ( m , calc ( i ) ) <NEWLINE> <DEDENT> print ( m ) <NEWLINE>
N , K = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> preX = 0 <NEWLINE> nowX = 1 <NEWLINE> <NL> for i in range ( K + 1 , N + 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> if A [ i - K - 1 ] < A [ i - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
[ X , K , D ] = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> X = abs ( X ) <NEWLINE> Y = X // D <NEWLINE> if Y <= K : <NEWLINE> <INDENT> X -= Y * D <NEWLINE> if ( K - Y ) % 2 != 0 : <NEWLINE> <INDENT> X = abs ( X - D ) if abs ( X - D ) < abs ( X + D ) else abs ( X + D ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> X -= K * D <NEWLINE> <DEDENT> print ( X ) <NEWLINE>
import math <NEWLINE> <NL> A , B , N = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> count = min ( B - 1 , N ) <NEWLINE> a = math . floor ( float ( A * count ) / B ) - A * math . floor ( float ( count ) / B ) <NEWLINE> print ( a ) <NEWLINE> <NL> <NL> <NL>
import itertools <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> lst . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> flag1 = True <NEWLINE> max_lst = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> understanding = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> understanding += lst [ j ] [ i + 1 ] <NEWLINE> <DEDENT> max_lst . append ( understanding ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( max_lst ) ) : <NEWLINE> <INDENT> maximum = max_lst [ i ] <NEWLINE> if maximum < x : <NEWLINE> <INDENT> cost = - 1 <NEWLINE> flag1 = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag1 : <NEWLINE> <INDENT> number = 1 <NEWLINE> cost_lst = [ ] <NEWLINE> while number <= n : <COMMENT> <NEWLINE> <INDENT> n_lst = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> n_lst . append ( i ) <NEWLINE> <DEDENT> choice = list ( itertools . combinations ( n_lst , number ) ) <NEWLINE> combination_number = len ( choice ) <NEWLINE> choice_number = len ( choice [ 0 ] ) <NEWLINE> <NL> for i in range ( combination_number ) : <NEWLINE> <NL> <INDENT> cost1 = 0 <NEWLINE> understanding_lst = [ 0 ] * m <NEWLINE> for j in range ( choice_number ) : <COMMENT> <NEWLINE> <INDENT> choiced_number = choice [ i ] [ j ] <NEWLINE> cost1 += lst [ choiced_number ] [ 0 ] <NEWLINE> <NL> for k in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> unstg = lst [ choiced_number ] [ k ] <NEWLINE> understanding_lst [ k - 1 ] += unstg <NEWLINE> <NL> <DEDENT> <DEDENT> over_x = 0 <NEWLINE> for l in range ( m ) : <NEWLINE> <INDENT> understanding = understanding_lst [ l ] <NEWLINE> if understanding >= x : <NEWLINE> <INDENT> over_x += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if over_x == m : <NEWLINE> <INDENT> cost_lst . append ( cost1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> number += 1 <NEWLINE> <NL> <DEDENT> cost = min ( cost_lst ) <NEWLINE> <NL> <DEDENT> print ( cost ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> h = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> total = 0 <NEWLINE> while h > 0 : <NEWLINE> <INDENT> total += 2 ** c <NEWLINE> h = h // 2 <NEWLINE> if h == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> total += 2 ** c <NEWLINE> break <NEWLINE> <DEDENT> c += 1 <NEWLINE> <DEDENT> print ( total ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
<COMMENT> <NL> <NL> from bisect import bisect_left <NEWLINE> <NL> <NL> def leq_search ( xs , x , s , t ) : <NEWLINE> <COMMENT> <NL> <INDENT> if t - s <= 5 : <NEWLINE> <INDENT> res = 0 <NEWLINE> for i in range ( s , t ) : <NEWLINE> <INDENT> if xs [ i ] <= x : <NEWLINE> <INDENT> res = i <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> i = ( s + t ) // 2 <NEWLINE> if xs [ i ] <= x : <NEWLINE> <INDENT> return leq_search ( xs , x , i , t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return leq_search ( xs , x , s , i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = [ None ] * ( N + 1 ) <NEWLINE> S [ 0 ] = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> S [ i ] = S [ i - 1 ] + A [ i - 1 ] <NEWLINE> <NL> <DEDENT> T = [ None ] * ( M + 1 ) <NEWLINE> T [ 0 ] = 0 <NEWLINE> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> T [ i ] = T [ i - 1 ] + B [ i - 1 ] <NEWLINE> <NL> <DEDENT> n_read = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if S [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n = leq_search ( T , K - S [ i ] , 0 , M + 1 ) <NEWLINE> <COMMENT> <NL> if n_read < n + i : <NEWLINE> <INDENT> n_read = n + i <NEWLINE> <NL> <DEDENT> <DEDENT> return n_read <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
import sys <NEWLINE> dataset = sys . stdin . readlines ( ) <NEWLINE> <NL> for s in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for data in dataset : <NEWLINE> <INDENT> count += data . lower ( ) . count ( chr ( s ) ) <NEWLINE> <DEDENT> print ( <STRING> . format ( chr ( s ) , count ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bad = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] > h [ b - 1 ] : <NEWLINE> <INDENT> bad . append ( b ) <NEWLINE> <DEDENT> elif h [ a - 1 ] == h [ b - 1 ] : <NEWLINE> <INDENT> bad . append ( a ) <NEWLINE> bad . append ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bad . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> bad_two = set ( bad ) <NEWLINE> ans = n - len ( bad_two ) <NEWLINE> print ( ans ) <NEWLINE>
h , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def bupdp ( l , h , k ) : <NEWLINE> <INDENT> dp = [ 0 ] * ( h + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( 0 , h ) : <NEWLINE> <INDENT> if i > k : <NEWLINE> <INDENT> mini = min ( [ dp [ i - j ] + abs ( l [ i ] - l [ i - j ] ) for j in range ( 1 , k + 1 ) ] ) <NEWLINE> dp [ i ] = mini <NEWLINE> <DEDENT> if i <= k and i != 0 : <NEWLINE> <INDENT> minim = min ( [ dp [ i - j ] + abs ( l [ i ] - l [ i - j ] ) for j in range ( 1 , i + 1 ) ] ) <NEWLINE> dp [ i ] = minim <NEWLINE> <DEDENT> if i < 1 : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> return dp [ - 2 ] <NEWLINE> <NL> <DEDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( bupdp ( l , h , k ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = [ input ( ) for _ in range ( n ) ] <NEWLINE> ans = <STRING> <NEWLINE> if len ( x ) == len ( set ( x ) ) : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if x [ i ] [ - 1 ] != x [ i + 1 ] [ 0 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> from itertools import combinations <NEWLINE> N , M , X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> book_dict = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> book_dict [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> answer = ( 10 ** 5 * 12 ) + 1 <NEWLINE> for i in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> for v in combinations ( book_dict . keys ( ) , i ) : <NEWLINE> <INDENT> search_book = list ( map ( lambda x : book_dict [ x ] , list ( v ) ) ) <NEWLINE> sum_search_book = np . array ( np . sum ( search_book , axis = 0 ) ) <NEWLINE> if ( np . count_nonzero ( sum_search_book [ 1 : ] >= X ) == M ) and sum_search_book [ 0 ] < answer : <NEWLINE> <INDENT> answer = sum_search_book [ 0 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if answer == ( 10 ** 5 * 12 ) + 1 : <NEWLINE> <INDENT> answer = - 1 <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = set ( p ) <NEWLINE> for i in range ( 200 ) : <NEWLINE> <INDENT> if X - i not in p : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> break <NEWLINE> <DEDENT> if X + i not in p : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( ( <STRING> * w + <STRING> ) * h ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N , M , X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = np . zeros ( ( N , M ) ) <NEWLINE> C = np . zeros ( N ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C [ i ] += tmp [ 0 ] <NEWLINE> a [ i ] += tmp [ 1 : ] <NEWLINE> <NL> <DEDENT> answer_price = 10 ** 10 <NEWLINE> <NL> for i in range ( 1 << N ) : <NEWLINE> <INDENT> tmp = np . zeros ( M ) <NEWLINE> cost = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> tmp += a [ j ] <NEWLINE> cost += C [ j ] <NEWLINE> <DEDENT> i = i >> 1 <NEWLINE> <NL> <DEDENT> if all ( tmp >= X ) and ( cost < answer_price ) : <NEWLINE> <INDENT> answer_price = cost <NEWLINE> <NL> <DEDENT> <DEDENT> if answer_price == 10 ** 10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( answer_price ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H_lis = [ ] <NEWLINE> H = lis [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in lis [ 1 : ] : <NEWLINE> <INDENT> if i <= H : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> H = i <NEWLINE> H_lis . append ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> H_lis . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> H = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( H_lis ) ) <NEWLINE>
a = [ ] ; b = [ ] ; c = [ ] <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> row = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( list ( row ) ) <NEWLINE> <NL> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> col = int ( input ( ) ) <NEWLINE> b . append ( col ) <NEWLINE> <NL> <DEDENT> for k in range ( n ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> for l in range ( m ) : <NEWLINE> <INDENT> temp += a [ k ] [ l ] * b [ l ] <NEWLINE> <DEDENT> c . append ( temp ) <NEWLINE> <NL> <DEDENT> for ind in range ( n ) : <NEWLINE> <INDENT> print ( c [ ind ] ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for b in range ( 1000 ) : <NEWLINE> <INDENT> for a in range ( 1000 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( <STRING> . format ( a , b ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ( - a ) ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( <STRING> . format ( - a , b ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if a ** 5 - ( - b ) ** 5 == x : <NEWLINE> <INDENT> print ( <STRING> . format ( a , - b ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ( - a ) ** 5 - ( - b ) ** 5 == x : <NEWLINE> <INDENT> print ( <STRING> . format ( - a , - b ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> import math <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> s = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( k , s ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
r = float ( input ( ) ) <NEWLINE> p = 3.141592653589 <NEWLINE> print ( p * r * r , 2 * p * r ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> a = bisect . bisect ( l , l [ i ] + l [ j ] - 1 ) <NEWLINE> ans += ( a - j - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> S = input ( ) <NEWLINE> cnt = 0 <NEWLINE> <NL> mod = [ 0 ] <NEWLINE> reverse_S = S [ : : - 1 ] <NEWLINE> for i in range ( len ( reverse_S ) ) : <NEWLINE> <INDENT> now = int ( reverse_S [ i ] ) * pow ( 10 , i , 2019 ) <NEWLINE> mod . append ( ( now + mod [ i ] ) % 2019 ) <NEWLINE> <NL> <NL> <DEDENT> c = collections . Counter ( mod ) <NEWLINE> hindo = c . values ( ) <NEWLINE> for i in hindo : <NEWLINE> <INDENT> if i != 1 : <NEWLINE> <INDENT> cnt += i * ( i - 1 ) // 2 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if n == 2 : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a + b ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> x = [ 0 ] * N <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> x [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in x : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
S = list ( map ( int , input ( ) ) ) [ : : - 1 ] <COMMENT> <NEWLINE> <NL> counter = 0 <NEWLINE> amari = [ 0 ] * 2019 <NEWLINE> amari [ 0 ] = 1 <NEWLINE> <NL> s , d = 0 , 1 <NEWLINE> <NL> for i in S : <NEWLINE> <INDENT> s += i * d <NEWLINE> amari [ s % 2019 ] += 1 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 2019 ) : <NEWLINE> <INDENT> counter += amari [ i ] * ( amari [ i ] - 1 ) / 2 <NEWLINE> <NL> <NL> <DEDENT> print ( int ( counter ) ) <NEWLINE>
C , n = map ( int , input ( ) . split ( ) ) <NEWLINE> mp = [ input ( ) for _ in range ( n ) ] <NEWLINE> diff_dic = { } <NEWLINE> def change ( x , y ) : <NEWLINE> <INDENT> global diff_dic <NEWLINE> if ( x , y ) in diff_dic : <NEWLINE> <INDENT> diff_dic . pop ( ( x , y ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff_dic [ ( x , y ) ] = True <NEWLINE> <DEDENT> <DEDENT> for y in range ( n // 2 ) : <NEWLINE> <INDENT> for x in range ( n // 2 ) : <NEWLINE> <INDENT> base = mp [ y ] [ x ] <NEWLINE> if mp [ y ] [ n - 1 - x ] != base : <NEWLINE> <INDENT> change ( n - 1 - x , y ) <NEWLINE> <DEDENT> if mp [ n - 1 - y ] [ x ] != base : <NEWLINE> <INDENT> change ( x , n - 1 - y ) <NEWLINE> <DEDENT> if mp [ n - 1 - y ] [ n - 1 - x ] != base : <NEWLINE> <INDENT> change ( n - 1 - x , n - 1 - y ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if n % 2 : <NEWLINE> <INDENT> for x in range ( n // 2 ) : <NEWLINE> <INDENT> if mp [ n // 2 ] [ x ] != mp [ n // 2 ] [ n - 1 - x ] : <NEWLINE> <INDENT> chenge ( n - 1 - x , n // 2 ) <NEWLINE> <DEDENT> <DEDENT> for y in range ( n // 2 ) : <NEWLINE> <INDENT> if mp [ y ] [ n // 2 ] != mp [ n - 1 - y ] [ n // 2 ] : <NEWLINE> <INDENT> change ( n // 2 , n - 1 - y ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> if not diff_dic : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> for _ in range ( C - 1 ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> for _ in range ( d ) : <NEWLINE> <INDENT> r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> r -= 1 <NEWLINE> c -= 1 <NEWLINE> if r < n // 2 and c < n // 2 : <NEWLINE> <INDENT> change ( c , n - 1 - r ) <NEWLINE> change ( n - 1 - c , r ) <NEWLINE> change ( n - 1 - c , n - 1 - r ) <NEWLINE> <DEDENT> elif n % 2 and r == n // 2 and c != n // 2 : <NEWLINE> <INDENT> change ( max ( c , n - 1 - c ) , r ) <NEWLINE> <DEDENT> elif n % 2 and r != n // 2 and c == n // 2 : <NEWLINE> <INDENT> change ( c , max ( r , n - 1 - r ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> change ( c , r ) <NEWLINE> <DEDENT> <DEDENT> if not diff_dic : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
def solve ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> y = int ( n / x ) <NEWLINE> ans += y * ( y + 1 ) * x // 2 <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> print ( solve ( ) ) <NEWLINE> <DEDENT>
Flag = True <NEWLINE> data = [ ] <NEWLINE> while Flag : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> Flag = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> data . append ( ( H , W ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for ( H , W ) in data : <NEWLINE> <INDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def is_prime ( n ) : <NEWLINE> <INDENT> for i in range ( 2 , math . floor ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> if is_prime ( k ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from collections import deque <NEWLINE> from sys import stdin <NEWLINE> q = deque ( ) <NEWLINE> input ( ) <NEWLINE> for s in stdin : <NEWLINE> <INDENT> c , * k = s . split ( ) <NEWLINE> k = k [ 0 ] if k else None <NEWLINE> if c [ 0 ] == <STRING> : <NEWLINE> <INDENT> q . appendleft ( k ) <NEWLINE> <DEDENT> elif c [ 0 ] == <STRING> : <NEWLINE> <INDENT> if c [ 6 : 7 ] == <STRING> : <NEWLINE> <INDENT> q . popleft ( ) <NEWLINE> <DEDENT> elif c [ 6 : 7 ] == <STRING> : <NEWLINE> <INDENT> q . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k in q : <NEWLINE> <INDENT> q . remove ( k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( * q ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> num = 1 <NEWLINE> max_v = 2147483647 <NEWLINE> <NL> while num < n : <NEWLINE> <INDENT> num *= 2 <NEWLINE> <NL> <DEDENT> A = [ max_v for i in range ( 2 * num - 1 ) ] <NEWLINE> <NL> <NL> def update ( i , x ) : <NEWLINE> <INDENT> i += num - 1 <NEWLINE> A [ i ] = x <NEWLINE> <NL> while i > 0 : <NEWLINE> <INDENT> i = ( i - 1 ) // 2 <NEWLINE> A [ i ] = min ( A [ i * 2 + 1 ] , A [ i * 2 + 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( a , b , k , l , r ) : <NEWLINE> <INDENT> if r <= a or b <= l : <NEWLINE> <INDENT> return max_v <NEWLINE> <DEDENT> if a <= l and r <= b : <NEWLINE> <INDENT> return A [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> vl = find ( a , b , k * 2 + 1 , l , ( l + r ) // 2 ) <NEWLINE> vr = find ( a , b , k * 2 + 2 , ( l + r ) // 2 , r ) <NEWLINE> return min ( vl , vr ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> com , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if com == 0 : <NEWLINE> <INDENT> update ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = find ( x , y + 1 , 0 , 0 , num ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> SUM = sum ( A ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> List = np . array ( [ 0 for _ in range ( 10 ** 5 + 1 ) ] ) <NEWLINE> for a in A : <NEWLINE> <INDENT> List [ a ] += 1 <NEWLINE> <DEDENT> for q in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> SUM -= B * List [ B ] <NEWLINE> SUM += C * List [ B ] <NEWLINE> List [ C ] += List [ B ] <NEWLINE> List [ B ] = 0 <NEWLINE> print ( SUM ) <NEWLINE> <DEDENT>
def calc ( s , k , n ) : <NEWLINE> <NL> <INDENT> bruh = { } <NEWLINE> for i in range ( 1 , k + 1 ) : <COMMENT> <NEWLINE> <INDENT> for j in range ( n - ( i - 1 ) ) : <COMMENT> <NEWLINE> <INDENT> bruh [ s [ j : j + i : ] ] = 0 <NEWLINE> <DEDENT> <DEDENT> another = bruh . keys ( ) <NEWLINE> another = sorted ( another ) <NEWLINE> print ( another [ k - 1 ] ) <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> n = len ( s ) <NEWLINE> <NL> calc ( s , k , n ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> an = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> <NL> dp = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> dp [ 0 ] = 1 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> if m == 0 : <NEWLINE> <INDENT> dp [ 0 ] = 1 <NEWLINE> dp [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % mod <NEWLINE> <DEDENT> print ( dp [ n ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if an [ 0 ] == 1 : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> a = 1 <NEWLINE> if len ( an ) == 1 : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> a = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i == an [ a ] : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> a += 1 <NEWLINE> if a == len ( an ) : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE>
import sys <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> def debug ( x , table ) : <NEWLINE> <INDENT> for name , val in table . items ( ) : <NEWLINE> <INDENT> if x is val : <NEWLINE> <INDENT> print ( <STRING> . format ( name , val ) , file = sys . stderr ) <NEWLINE> return None <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def SSSP ( n , Adj ) : <NEWLINE> <INDENT> d = [ inf ] * n <NEWLINE> p = [ - 1 ] * n <NEWLINE> checked = [ False ] * n <NEWLINE> d [ 0 ] = 0 <NEWLINE> checked [ 0 ] = True <NEWLINE> u = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for v , cost in Adj [ u ] : <NEWLINE> <INDENT> if d [ u ] + cost < d [ v ] : <NEWLINE> <INDENT> p [ v ] = u <NEWLINE> d [ v ] = d [ u ] + cost <NEWLINE> <NL> <DEDENT> <DEDENT> min_n = 0 <NEWLINE> min_w = inf <NEWLINE> for v in range ( n ) : <NEWLINE> <INDENT> if not checked [ v ] and d [ v ] < min_w : <NEWLINE> <INDENT> min_n = v <NEWLINE> min_w = d [ v ] <NEWLINE> <NL> <DEDENT> <DEDENT> u = min_n <NEWLINE> checked [ u ] = True <NEWLINE> <NL> <DEDENT> return d <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> Adj = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> u , k , * line = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> Adj [ u ] . append ( ( line [ 2 * j ] , line [ 2 * j + 1 ] ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> d = SSSP ( n , Adj ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( i , d [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> H = np . array ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> good = [ 1 ] * N <NEWLINE> <NL> road = [ ] <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if H [ a - 1 ] == H [ b - 1 ] : <NEWLINE> <INDENT> good [ a - 1 ] = 0 <NEWLINE> good [ b - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ a - 1 ] < H [ b - 1 ] : <NEWLINE> <INDENT> good [ a - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> good [ b - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( good ) ) <NEWLINE> <NL>
import numpy as np <NEWLINE> s = list ( map ( int , input ( ) ) ) <NEWLINE> n = len ( s ) <NEWLINE> ans = 0 <NEWLINE> mod = 2019 <NEWLINE> past = s [ n - 1 ] <NEWLINE> ima = 0 <NEWLINE> d = dict ( ) <NEWLINE> d [ s [ n - 1 ] ] = 1 <NEWLINE> now = 10 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ima = ( past + s [ n - i - 1 ] * now ) % mod <NEWLINE> if ima == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> if ima in d : <NEWLINE> <INDENT> d [ ima ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ ima ] = 1 <NEWLINE> <DEDENT> past = ima <NEWLINE> now = ( now * 10 ) % mod <NEWLINE> <NL> <DEDENT> for i in d . values ( ) : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> flag = True <NEWLINE> A = sorted ( A ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A1 = [ [ - a - i , i ] for i , a in enumerate ( A ) ] <NEWLINE> A2 = [ [ a - i , i ] for i , a in enumerate ( A ) ] <NEWLINE> A1 . sort ( ) <NEWLINE> A2 . sort ( ) <NEWLINE> i = j = 0 <NEWLINE> cnt = 0 <NEWLINE> while i < N and j < N : <NEWLINE> <INDENT> if A1 [ i ] [ 0 ] == A2 [ j ] [ 0 ] : <NEWLINE> <INDENT> buf1 = 1 <NEWLINE> for k in range ( i + 1 , N ) : <NEWLINE> <INDENT> if A1 [ k ] [ 0 ] != A1 [ i ] [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> buf1 += 1 <NEWLINE> <DEDENT> buf2 = 1 <NEWLINE> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> if A2 [ k ] [ 0 ] != A2 [ j ] [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> buf2 += 1 <NEWLINE> <DEDENT> cnt += buf1 * buf2 <NEWLINE> i += buf1 <NEWLINE> j += buf2 <NEWLINE> <DEDENT> elif A1 [ i ] [ 0 ] < A2 [ j ] [ 0 ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from heapq import heapify , heappush , heappop <NEWLINE> import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in readline ( ) . split ( ) ] <NEWLINE> <NL> ans = 1 <NEWLINE> if K == N : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> plus = [ ] <NEWLINE> minus = [ ] <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> heappush ( minus , a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> heappush ( plus , - a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if not plus : <NEWLINE> <INDENT> if K % 2 == 1 : <NEWLINE> <INDENT> for _ in range ( N - K ) : <NEWLINE> <INDENT> heappop ( minus ) <NEWLINE> <DEDENT> for _ in range ( K ) : <NEWLINE> <INDENT> ans *= heappop ( minus ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for _ in range ( K ) : <NEWLINE> <INDENT> ans *= heappop ( minus ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> p = [ ] <NEWLINE> m = [ ] <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> if plus and minus : <NEWLINE> <INDENT> if plus [ 0 ] <= minus [ 0 ] : <NEWLINE> <INDENT> p . append ( - heappop ( plus ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m . append ( heappop ( minus ) ) <NEWLINE> <DEDENT> <DEDENT> elif plus : <NEWLINE> <INDENT> p . append ( - heappop ( plus ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m . append ( heappop ( minus ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in p : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> for j in m : <NEWLINE> <INDENT> ans *= j <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> if len ( m ) % 2 == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if plus and minus and p and m : <NEWLINE> <INDENT> if p [ - 1 ] * ( - plus [ 0 ] ) >= m [ - 1 ] * minus [ 0 ] : <NEWLINE> <INDENT> ans *= pow ( m [ - 1 ] , MOD - 2 , MOD ) <NEWLINE> ans *= - plus [ 0 ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= pow ( p [ - 1 ] , MOD - 2 , MOD ) <NEWLINE> ans *= minus [ 0 ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> <DEDENT> elif plus : <NEWLINE> <INDENT> ans *= pow ( m [ - 1 ] , MOD - 2 , MOD ) <NEWLINE> ans *= - plus [ 0 ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= pow ( p [ - 1 ] , MOD - 2 , MOD ) <NEWLINE> ans *= minus [ 0 ] <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> <NL> answer = 0 <NEWLINE> <NL> nums = [ ] <NEWLINE> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> nums . append ( i ) <NEWLINE> <NL> <DEDENT> for balls in itertools . combinations_with_replacement ( nums , N ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> test = list ( balls ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> if test [ abcd [ i ] [ 0 ] - 1 ] + abcd [ i ] [ 2 ] == test [ abcd [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> score += abcd [ i ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if score > answer : <NEWLINE> <INDENT> answer = score <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> from collections import Counter , deque <NEWLINE> <COMMENT> <NL> from itertools import combinations , permutations , accumulate , groupby , product <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> import math <NEWLINE> from math import gcd <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> adj = [ [ ] for _ in range ( n ) ] <COMMENT> <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> c , b = map ( int , input ( ) . split ( ) ) <NEWLINE> adj [ c - 1 ] . append ( b - 1 ) <NEWLINE> adj [ b - 1 ] . append ( c - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> res = [ 0 ] * n <NEWLINE> res [ 0 ] = 1 <NEWLINE> <NL> def dfs ( v , par , L ) : <NEWLINE> <INDENT> if v != 0 : <NEWLINE> <INDENT> if a [ v ] > L [ - 1 ] : <NEWLINE> <INDENT> temp = - 1 <NEWLINE> L . append ( a [ v ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = bisect_left ( L , a [ v ] ) <NEWLINE> pre = L [ temp ] <NEWLINE> L [ temp ] = a [ v ] <NEWLINE> <DEDENT> <DEDENT> res [ v ] = len ( L ) <NEWLINE> for nv in adj [ v ] : <NEWLINE> <INDENT> if nv == par : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( nv , v , L ) <NEWLINE> <DEDENT> if v != 0 : <NEWLINE> <INDENT> if temp == - 1 : <NEWLINE> <INDENT> L . pop ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ temp ] = pre <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> L = [ a [ 0 ] ] <NEWLINE> dfs ( 0 , - 1 , L ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( res [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> c = Counter ( { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } ) <NEWLINE> c . update ( s ) <NEWLINE> x , y , z = c . values ( ) <NEWLINE> print ( x * y * z - sum ( s [ i ] != s [ ( i + j ) // 2 ] != s [ j ] != s [ i ] <NEWLINE> <INDENT> for i in range ( n ) for j in range ( i + 2 , n , 2 ) ) ) <NEWLINE> <DEDENT>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> b [ i - 1 ] += 1 <NEWLINE> <DEDENT> print ( * b , sep = <STRING> ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> R = [ int ( input ( ) . strip ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> maxv = - math . inf <NEWLINE> minv = R [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <NL> <INDENT> tmp_maxv = R [ i ] - minv <COMMENT> <NEWLINE> <COMMENT> <NL> if maxv < tmp_maxv : <NEWLINE> <INDENT> maxv = tmp_maxv <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if R [ i ] < minv : <NEWLINE> <INDENT> minv = R [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( maxv ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> T = list ( input ( ) ) <NEWLINE> O = list ( ) <NEWLINE> a = 0 <NEWLINE> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> b = 0 <NEWLINE> m = 0 <NEWLINE> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> if S [ b + a ] != T [ b ] : <NEWLINE> <INDENT> m = m + 1 <NEWLINE> <DEDENT> b = b + 1 <NEWLINE> <DEDENT> O . append ( m ) <NEWLINE> a = a + 1 <NEWLINE> <DEDENT> O . sort ( ) <NEWLINE> print ( O [ 0 ] ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( M - 1 ) : <NEWLINE> <INDENT> H , I = map ( int , input ( ) . split ( ) ) <NEWLINE> if H > L : <NEWLINE> <INDENT> L = H <NEWLINE> <DEDENT> if R > I : <NEWLINE> <INDENT> R = I <NEWLINE> <DEDENT> if R < L : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if R < L : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = list ( range ( L , R + 1 ) ) <NEWLINE> print ( len ( ans ) ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> S = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> dp = [ 0 ] * ( S + 4 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> acc = list ( accumulate ( dp ) ) <NEWLINE> acc [ - 1 ] = acc [ - 2 ] = acc [ - 3 ] = 0 <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 700 ) : <NEWLINE> <INDENT> ndp = [ ] <NEWLINE> for b in range ( S + 1 ) : <NEWLINE> <INDENT> ndp . append ( acc [ b - 3 ] % MOD ) <NEWLINE> <DEDENT> ndp += [ 0 , 0 , 0 ] <NEWLINE> ans += ndp [ S ] <NEWLINE> ans %= MOD <NEWLINE> dp = ndp <NEWLINE> acc = list ( accumulate ( dp ) ) <NEWLINE> acc [ - 1 ] = acc [ - 2 ] = acc [ - 3 ] = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> A = n // i <NEWLINE> ans += ( A * ( A + 1 ) * i // 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import random <NEWLINE> import sys <NEWLINE> import os <NEWLINE> <NL> <NL> class Tree : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> if self . root == None : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def print_inorder ( self ) : <NEWLINE> <INDENT> self . inorder_list = [ ] <NEWLINE> self . __inorder ( self . root ) <NEWLINE> return self . inorder_list <NEWLINE> <NL> <DEDENT> def __inorder ( self , node ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if node is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . __inorder ( node . left ) <NEWLINE> self . inorder_list . append ( node . key ) <NEWLINE> self . __inorder ( node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def print_preorder ( self ) : <NEWLINE> <INDENT> self . preorder_list = [ ] <NEWLINE> self . __preorder ( self . root ) <NEWLINE> return self . preorder_list <NEWLINE> <NL> <DEDENT> def __preorder ( self , node ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if node is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . preorder_list . append ( node . key ) <NEWLINE> self . __preorder ( node . left ) <NEWLINE> self . __preorder ( node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def insert ( self , node ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . root is None : <NEWLINE> <INDENT> self . root = node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = self . root <NEWLINE> parent_candidate = x <NEWLINE> <NL> while x is not None : <NEWLINE> <INDENT> parent_candidate = x <NEWLINE> if x . key > node . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> x = node <NEWLINE> x . parent = parent_candidate <NEWLINE> <NL> <COMMENT> <NL> if x . key < x . parent . key : <NEWLINE> <INDENT> x . parent . left = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x . parent . right = x <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def find ( self , value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> x = self . root <NEWLINE> while x is not None and x . key != value : <NEWLINE> <INDENT> if x . key > value : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def delete ( self , value ) : <NEWLINE> <INDENT> found_node = self . find ( value ) <NEWLINE> if found_node is None : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if found_node . is_leaf ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> print ( found_node . parent . left . key ) <NEWLINE> print ( found_node . key ) <NEWLINE> <NL> if found_node . parent . left . key == found_node . key : <NEWLINE> <INDENT> found_node . parent . left = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> found_node . parent . right = None <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if found_node . has_one_child ( ) : <NEWLINE> <INDENT> one_child = found_node . get_one_child ( ) <NEWLINE> <NL> <COMMENT> <NL> one_child . parent = found_node . parent <NEWLINE> <NL> <COMMENT> <NL> if found_node . parent . left == found_node : <NEWLINE> <INDENT> found_node . parent . left = one_child <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> found_node . parent . right = one_child <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> next_section_point = found_node . get_next_section_point ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> key = next_section_point . key <NEWLINE> self . delete ( next_section_point . key ) <NEWLINE> found_node . key = key <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> class Node : <NEWLINE> <INDENT> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . parent = None <COMMENT> <NEWLINE> self . left = None <COMMENT> <NEWLINE> self . right = None <COMMENT> <NEWLINE> self . key = key <COMMENT> <NEWLINE> <NL> <DEDENT> def has_one_child ( self ) : <NEWLINE> <INDENT> if self . left is None and self . right is not None : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif self . left is not None and self . right is None : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def get_one_child ( self ) : <NEWLINE> <INDENT> if not self . has_one_child ( ) : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . left is not None : <NEWLINE> <INDENT> return self . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . right <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def get_next_section_point ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> <COMMENT> <NL> if self . right is not None : <NEWLINE> <INDENT> return self . right . get_minimum ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> return self . parent <NEWLINE> <NL> <DEDENT> <DEDENT> def is_leaf ( self ) : <NEWLINE> <INDENT> if self . left is None and self . right is None : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def get_minimum ( self ) : <NEWLINE> <INDENT> if self . left is None : <NEWLINE> <INDENT> return self <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . left . get_minimum ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def test ( ) : <NEWLINE> <INDENT> tree = Tree ( ) <NEWLINE> values = [ ] <NEWLINE> for _ in range ( 10 ) : <NEWLINE> <INDENT> values . append ( random . randint ( 0 , 99 ) ) <NEWLINE> <DEDENT> print ( values ) <NEWLINE> <NL> for v in values : <NEWLINE> <INDENT> node = Node ( v ) <NEWLINE> tree . insert ( node ) <NEWLINE> <NL> <DEDENT> tree . print_inorder ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> tree . print_preorder ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> pass <NEWLINE> <NL> <NL> <DEDENT> def delete_test ( ) : <NEWLINE> <INDENT> tree = Tree ( ) <NEWLINE> values = [ ] <NEWLINE> for _ in range ( 10 ) : <NEWLINE> <INDENT> values . append ( random . randint ( 0 , 99 ) ) <NEWLINE> <DEDENT> values = list ( set ( values ) ) <NEWLINE> print ( values ) <NEWLINE> <NL> for v in values : <NEWLINE> <INDENT> node = Node ( v ) <NEWLINE> tree . insert ( node ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( <STRING> , values [ 1 ] ) <NEWLINE> tree . delete ( values [ 1 ] ) <NEWLINE> <NL> print ( <STRING> , values [ 3 ] ) <NEWLINE> tree . delete ( values [ 3 ] ) <NEWLINE> <NL> tree . print_preorder ( ) <NEWLINE> <NL> <NL> <DEDENT> tree = Tree ( ) <NEWLINE> s = input ( ) <NEWLINE> n = int ( s ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> value = int ( s . split ( <STRING> ) [ - 1 ] ) <NEWLINE> node = Node ( value ) <NEWLINE> tree . insert ( node ) <NEWLINE> <NL> <DEDENT> if <STRING> in s : <NEWLINE> <INDENT> in_list = tree . print_inorder ( ) <NEWLINE> in_list = map ( str , in_list ) <NEWLINE> print ( <STRING> + <STRING> . join ( in_list ) ) <NEWLINE> <NL> pre_list = tree . print_preorder ( ) <NEWLINE> pre_list = map ( str , pre_list ) <NEWLINE> print ( <STRING> + <STRING> . join ( pre_list ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> S = sum ( A ) - A [ 0 ] <NEWLINE> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> ans = ( ans + A [ i ] * S ) % ( 10 ** 9 + 7 ) <NEWLINE> S -= A [ i + 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import math <COMMENT> <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> from copy import deepcopy <NEWLINE> from itertools import accumulate <COMMENT> <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> from functools import lru_cache <COMMENT> <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> ans_list = [ a [ i ] for i in range ( n ) if i % 2 == 0 ] <NEWLINE> ans = [ ans_list [ i ] for i in range ( len ( ans_list ) ) if ans_list [ i ] % 2 == 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( len ( ans ) ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import queue <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> hen = [ [ ] for i in range ( n ) ] <NEWLINE> ans = [ 0 for i in range ( n ) ] <NEWLINE> a , b = 0 , 0 <NEWLINE> <NL> <NL> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> hen [ a - 1 ] . append ( b ) <NEWLINE> hen [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> q = queue . Queue ( ) <NEWLINE> q . put ( 1 ) <NEWLINE> <NL> while q . empty ( ) == False : <NEWLINE> <INDENT> head = q . get ( ) <NEWLINE> for h in hen [ head - 1 ] : <NEWLINE> <INDENT> if h != 1 and ans [ h - 1 ] == 0 : <NEWLINE> <INDENT> ans [ h - 1 ] = head <NEWLINE> q . put ( h ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> flag = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i != 0 and ans [ i ] == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x_bin = input ( ) <NEWLINE> x = int ( x_bin , 2 ) <NEWLINE> <NL> pc = x_bin . count ( <STRING> ) <NEWLINE> pc_p = pc + 1 <NEWLINE> pc_m = pc - 1 <NEWLINE> <NL> if pc == 1 : <NEWLINE> <INDENT> for i , v in enumerate ( x_bin ) : <NEWLINE> <INDENT> if v == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i != n - 1 : <NEWLINE> <INDENT> if x_bin [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> p = { 0 : 1 } <NEWLINE> m = { 0 : 1 } <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> p [ i ] = p [ i - 1 ] * 2 % pc_p <NEWLINE> m [ i ] = m [ i - 1 ] * 2 % pc_m <NEWLINE> <NL> <DEDENT> rest = { 0 : 0 } <NEWLINE> for i in range ( 1 , pc + 1 ) : <NEWLINE> <INDENT> rest [ i ] = rest [ i % bin ( i ) . count ( <STRING> ) ] + 1 <NEWLINE> <NL> <DEDENT> x_p = x % pc_p <NEWLINE> x_m = x % pc_m <NEWLINE> <NL> for i in range ( n , 0 , - 1 ) : <NEWLINE> <INDENT> if x_bin [ n - i ] == <STRING> : <NEWLINE> <INDENT> a = ( x_m - m [ i - 1 ] ) % pc_m <NEWLINE> print ( rest [ a ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = ( x_p + p [ i - 1 ] ) % pc_p <NEWLINE> print ( rest [ a ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
def L ( str1 , str2 ) : <NEWLINE> <INDENT> A = [ 0 for _ in range ( len ( str2 ) + 1 ) ] <NEWLINE> for char1 in str1 : <NEWLINE> <INDENT> A_copy = A [ : ] <NEWLINE> for j , char2 in enumerate ( str2 ) : <NEWLINE> <INDENT> if ( char1 == char2 ) : <NEWLINE> <INDENT> A [ j + 1 ] = A_copy [ j ] + 1 <NEWLINE> <DEDENT> elif ( A [ j ] > A [ j + 1 ] ) : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return A [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> m = int ( input ( ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> str1 = input ( ) <NEWLINE> str2 = input ( ) <NEWLINE> print ( L ( str1 , str2 ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for n in range ( N ) ] <NEWLINE> <NL> S . sort ( ) <NEWLINE> <NL> i = 1 <NEWLINE> prev = S [ 0 ] <NEWLINE> for e in S : <NEWLINE> <INDENT> if prev != e : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> prev = e <NEWLINE> <NL> <DEDENT> print ( i ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> input_line = input ( ) <NEWLINE> Line = input_line . split ( ) <NEWLINE> Line = [ int ( s ) for s in Line ] <NEWLINE> <NL> c = collections . Counter ( Line ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
def solve ( N , X ) : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> cnt = X . count ( <STRING> ) <NEWLINE> rem_ori = [ 0 , 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> if cnt != 1 : <NEWLINE> <INDENT> rem_ori [ 0 ] += pow ( 2 , N - i - 1 , cnt - 1 ) <NEWLINE> rem_ori [ 0 ] %= ( cnt - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rem_ori [ 0 ] = 0 <NEWLINE> <DEDENT> rem_ori [ 1 ] += pow ( 2 , N - i - 1 , cnt + 1 ) <NEWLINE> rem_ori [ 1 ] %= ( cnt + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> rem = [ ( rem_ori [ 0 ] if X [ i ] == <STRING> else rem_ori [ 1 ] ) for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> if cnt != 1 : <NEWLINE> <INDENT> rem [ i ] -= pow ( 2 , N - i - 1 , cnt - 1 ) <NEWLINE> rem [ i ] %= ( cnt - 1 ) <NEWLINE> ans . append ( cal ( rem [ i ] , 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> rem [ i ] += pow ( 2 , N - i - 1 , cnt + 1 ) <NEWLINE> rem [ i ] %= ( cnt + 1 ) <NEWLINE> ans . append ( cal ( rem [ i ] , 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def cal ( rem , rec ) : <NEWLINE> <INDENT> if rem == 0 : <NEWLINE> <INDENT> return rec <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = bin ( rem ) [ 2 : ] <NEWLINE> cnt = b . count ( <STRING> ) <NEWLINE> rem %= cnt <NEWLINE> return cal ( rem , rec + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> ans = solve ( N , X ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> xn = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xn_s = sorted ( xn ) <NEWLINE> m1 = xn_s [ n // 2 - 1 ] <NEWLINE> m2 = xn_s [ n // 2 ] <NEWLINE> for x in xn : <NEWLINE> <INDENT> if x <= m1 : <NEWLINE> <INDENT> print ( m2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m1 ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( K - A ) <= B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> a = ( math . gcd ( i , j ) ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum = sum + ( math . gcd ( a , l ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> ans = r * g * b <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < N and S [ i ] != S [ j ] != S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> G = [ [ ] for j in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a - 1 ] . append ( H [ b - 1 ] ) <NEWLINE> G [ b - 1 ] . append ( H [ a - 1 ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i , g in enumerate ( G ) : <NEWLINE> <INDENT> if not g : <NEWLINE> <INDENT> ans += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if H [ i ] > max ( g ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c1 = { } <NEWLINE> c2 = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> c1 . setdefault ( i + A [ i ] , 0 ) <NEWLINE> c1 [ i + A [ i ] ] += 1 <NEWLINE> c2 . setdefault ( i - A [ i ] , 0 ) <NEWLINE> c2 [ i - A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> result = 0 <NEWLINE> for k in set ( c1 ) . intersection ( c2 ) : <NEWLINE> <INDENT> result += c1 [ k ] * c2 [ k ] <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
while True : <NEWLINE> <INDENT> s1 = input ( ) <NEWLINE> if s1 == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s2 = input ( ) <NEWLINE> <NL> listed_s1 = [ [ ] ] <NEWLINE> listed_s2 = [ [ ] ] <NEWLINE> start = 0 <NEWLINE> now = 0 <NEWLINE> for i in range ( len ( s1 ) ) : <NEWLINE> <INDENT> if s1 [ i ] == <STRING> and not start : <NEWLINE> <INDENT> listed_s1 . append ( [ ] ) <NEWLINE> now += 1 <NEWLINE> start = 1 <NEWLINE> listed_s1 [ now ] . append ( s1 [ i ] ) <NEWLINE> <DEDENT> elif s1 [ i ] == <STRING> and start : <NEWLINE> <INDENT> listed_s1 [ now ] . append ( s1 [ i ] ) <NEWLINE> listed_s1 . append ( [ ] ) <NEWLINE> now += 1 <NEWLINE> start = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> listed_s1 [ now ] . append ( s1 [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> now = 0 <NEWLINE> for i in range ( len ( s2 ) ) : <NEWLINE> <INDENT> if s2 [ i ] == <STRING> and not start : <NEWLINE> <INDENT> listed_s2 . append ( [ ] ) <NEWLINE> now += 1 <NEWLINE> start = 1 <NEWLINE> listed_s2 [ now ] . append ( s2 [ i ] ) <NEWLINE> <DEDENT> elif s2 [ i ] == <STRING> and start : <NEWLINE> <INDENT> listed_s2 [ now ] . append ( s2 [ i ] ) <NEWLINE> listed_s2 . append ( [ ] ) <NEWLINE> now += 1 <NEWLINE> start = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> listed_s2 [ now ] . append ( s2 [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> fist_wrong = 0 <NEWLINE> ans = <STRING> <NEWLINE> if len ( listed_s1 ) != len ( listed_s2 ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> for i in range ( min ( len ( listed_s1 ) , len ( listed_s2 ) ) ) : <NEWLINE> <INDENT> if ans == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if listed_s1 [ i ] != listed_s2 [ i ] : <NEWLINE> <INDENT> if listed_s1 [ i ] [ 0 ] == <STRING> and listed_s2 [ i ] [ - 1 ] == <STRING> and listed_s2 [ i ] [ 0 ] == <STRING> and listed_s2 [ i ] [ - 1 ] == <STRING> : <NEWLINE> <INDENT> if fist_wrong : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fist_wrong = 1 <NEWLINE> ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> import numpy as np <NEWLINE> <NL> readline = sys . stdin . readline <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> <NL> f = np . zeros ( 10001 , np . int64 ) <NEWLINE> <NL> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> n = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if n > 10000 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> f [ n ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( f [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> from itertools import accumulate <NEWLINE> <NL> import heapq <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> import copy <NEWLINE> import math <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def zz ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def z ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> <NL> def S ( ) : return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <NL> def C ( line ) : return [ sys . stdin . readline ( ) for _ in range ( line ) ] <NEWLINE> <NL> <NL> def get_sieve_of_eratosthenes ( n ) : <NEWLINE> <INDENT> if not isinstance ( n , int ) : <NEWLINE> <INDENT> raise TypeError ( <STRING> ) <NEWLINE> <DEDENT> if n < 2 : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> prime = [ 2 ] <NEWLINE> limit = int ( n ** 0.5 ) <NEWLINE> data = [ i + 1 for i in range ( 2 , n , 2 ) ] <NEWLINE> while True : <NEWLINE> <INDENT> p = data [ 0 ] <NEWLINE> if limit <= p : <NEWLINE> <INDENT> return prime + data <NEWLINE> <DEDENT> prime . append ( p ) <NEWLINE> data = [ e for e in data if e % p != 0 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> max_ = pow ( 10 , 5 ) + 2 <NEWLINE> primes = get_sieve_of_eratosthenes ( max_ ) <NEWLINE> num_lile2017 = [ 0 ] * max_ <NEWLINE> primes2 = [ ] <NEWLINE> for prime in primes : <NEWLINE> <INDENT> primes2 . append ( 2 * prime - 1 ) <NEWLINE> <DEDENT> like2017 = sorted ( list ( set ( primes2 ) & set ( primes ) ) ) <NEWLINE> for i in range ( 3 , max_ , 2 ) : <NEWLINE> <INDENT> if ( i in like2017 ) : <NEWLINE> <INDENT> num_lile2017 [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> num_lile2017 = list ( accumulate ( num_lile2017 ) ) <NEWLINE> <COMMENT> <NL> <NL> Q = z ( ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = zz ( ) <NEWLINE> print ( num_lile2017 [ r ] - num_lile2017 [ l - 1 ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = collections . Counter ( a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> s = sum ( a ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s = s - ( b - c ) * count [ b ] <NEWLINE> <NL> count [ c ] += count [ b ] <NEWLINE> count [ b ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( A ) <NEWLINE> <NL> i = 1 <NEWLINE> <NL> for j in range ( N ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> import re <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> import functools <NEWLINE> <NL> DEBUG = True <NEWLINE> DEBUG = False <NEWLINE> <NL> def dbg ( * args ) : <NEWLINE> <INDENT> if DEBUG : <NEWLINE> <INDENT> print ( <STRING> , file = sys . stderr , end = <STRING> ) <NEWLINE> print ( * args , file = sys . stderr ) <NEWLINE> <NL> <DEDENT> <DEDENT> Mat = collections . namedtuple ( <STRING> , <STRING> ) <NEWLINE> <NL> def mat_mul ( ms ) : <NEWLINE> <INDENT> return Mat ( ms [ 0 ] . r , ms [ - 1 ] . c ) <NEWLINE> <NL> <DEDENT> def cost ( m1 , m2 ) : <NEWLINE> <INDENT> return m1 . r * m1 . c * m2 . c <NEWLINE> <NL> <DEDENT> def solve ( n , ms ) : <NEWLINE> <INDENT> if n == 1 : return 0 <NEWLINE> <NL> dp = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dp [ ( i , i ) ] = 0 <NEWLINE> <NL> <DEDENT> for l in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for i in range ( n - l + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> cost_min = float ( <STRING> ) <NEWLINE> for j in range ( l - 1 ) : <NEWLINE> <INDENT> dbg ( <STRING> , l , i , j ) <NEWLINE> m_lhs = mat_mul ( ms [ i : i + j + 1 ] ) <NEWLINE> m_rhs = mat_mul ( ms [ i + j + 1 : i + l ] ) <NEWLINE> dbg ( <STRING> , m_lhs , m_rhs ) <NEWLINE> cost_lhs = dp [ ( i , i + j ) ] <NEWLINE> cost_rhs = dp [ ( i + j + 1 , i + l - 1 ) ] <NEWLINE> dbg ( <STRING> , cost_lhs , cost_rhs ) <NEWLINE> cost_mul = cost ( m_lhs , m_rhs ) <NEWLINE> dbg ( <STRING> , cost_mul ) <NEWLINE> cost_now = cost_mul + cost_lhs + cost_rhs <NEWLINE> dbg ( <STRING> , cost_now ) <NEWLINE> if cost_min > cost_now : <NEWLINE> <INDENT> cost_min = cost_now <NEWLINE> <DEDENT> <DEDENT> dp [ ( i , i + l - 1 ) ] = cost_min <NEWLINE> <NL> <DEDENT> <DEDENT> dbg ( dp ) <NEWLINE> return dp [ ( 0 , n - 1 ) ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> ms = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ms . append ( Mat ( r , c ) ) <NEWLINE> <NL> <DEDENT> print ( solve ( n , ms ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : main ( ) <NEWLINE>
S = input ( ) <NEWLINE> n = int ( S ) <NEWLINE> h = int ( n / ( 60 * 60 ) ) <NEWLINE> m = int ( ( n - 60 * 60 * h ) / 60 ) <NEWLINE> s = int ( n - ( 60 * 60 * h + 60 * m ) ) <NEWLINE> print ( h , <STRING> , m , <STRING> , s , sep = <STRING> ) <NEWLINE> <NL>
import sys <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , sys . stdin . readline ( ) . rsplit ( ) ) ) <NEWLINE> B = list ( map ( int , sys . stdin . readline ( ) . rsplit ( ) ) ) <NEWLINE> <NL> sA = [ 0 ] + list ( itertools . accumulate ( A ) ) <NEWLINE> sB = [ 0 ] + list ( itertools . accumulate ( B ) ) <NEWLINE> <NL> res = 0 <NEWLINE> for i , a in enumerate ( sA ) : <NEWLINE> <INDENT> if K < a : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> j = bisect . bisect_right ( sB , K - a ) - 1 <NEWLINE> res = max ( res , i + j ) <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> T_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> T_list = [ T_list [ i ] - 1 for i in range ( N ) ] <NEWLINE> point = 0 <NEWLINE> syuuki = 0 <NEWLINE> <NL> if K < N : <NEWLINE> <INDENT> i = 0 <NEWLINE> while i < K : <NEWLINE> <INDENT> point = T_list [ point ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i = 0 <NEWLINE> while i < N : <NEWLINE> <INDENT> point = T_list [ point ] <NEWLINE> if point == 0 : <NEWLINE> <INDENT> syuuki = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> second_point = point <NEWLINE> <NL> if syuuki != 0 : <NEWLINE> <INDENT> L = K % syuuki <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> j = 0 <NEWLINE> while j < N : <NEWLINE> <INDENT> point = T_list [ point ] <NEWLINE> if point == second_point : <NEWLINE> <INDENT> syuuki = j + 1 <NEWLINE> break <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> L = ( K - i ) % syuuki <NEWLINE> <NL> <DEDENT> k = 0 <NEWLINE> while k < L : <NEWLINE> <INDENT> point = T_list [ point ] <NEWLINE> k += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( point + 1 ) <NEWLINE>
import math <NEWLINE> x_1 , y_1 , x_2 , y_2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( math . sqrt ( ( x_1 - x_2 ) ** 2 + ( y_1 - y_2 ) ** 2 ) ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = [ ] <NEWLINE> g = [ ] <NEWLINE> b = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . append ( i + 1 ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g . append ( i + 1 ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> b . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> count = len ( r ) * len ( g ) * len ( b ) <NEWLINE> for r_num in r : <NEWLINE> <INDENT> for g_num in g : <NEWLINE> <INDENT> dif = abs ( r_num - g_num ) <NEWLINE> i , j = tuple ( sorted ( [ r_num , g_num ] ) ) <NEWLINE> <NL> if i - dif > 0 : <NEWLINE> <INDENT> if s [ i - dif - 1 ] == <STRING> : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> if j + dif <= n : <NEWLINE> <INDENT> if s [ j + dif - 1 ] == <STRING> : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> if dif % 2 == 0 : <NEWLINE> <INDENT> if s [ i + dif // 2 - 1 ] == <STRING> : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> m = 0 <NEWLINE> for i in range ( 500 ) : <NEWLINE> <INDENT> for k in range ( 500 ) : <NEWLINE> <INDENT> w = i ** 5 <NEWLINE> e = k ** 5 <NEWLINE> r = k ** 5 * - 1 <NEWLINE> if w - e == x : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> print ( k ) <NEWLINE> m += 1 <NEWLINE> break <NEWLINE> <DEDENT> elif w - r == x : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> print ( k * - 1 ) <NEWLINE> m += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if m == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> x = min ( N , B - 1 ) <NEWLINE> ans = math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> print ( ans ) <NEWLINE>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> p . append ( [ a , b , c , d ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for a1 in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> for a2 in range ( a1 , m + 1 ) : <NEWLINE> <INDENT> for a3 in range ( a2 , m + 1 ) : <NEWLINE> <INDENT> for a4 in range ( a3 , m + 1 ) : <NEWLINE> <INDENT> for a5 in range ( a4 , m + 1 ) : <NEWLINE> <INDENT> for a6 in range ( a5 , m + 1 ) : <NEWLINE> <INDENT> for a7 in range ( a6 , m + 1 ) : <NEWLINE> <INDENT> for a8 in range ( a7 , m + 1 ) : <NEWLINE> <INDENT> for a9 in range ( a8 , m + 1 ) : <NEWLINE> <INDENT> for a10 in range ( a9 , m + 1 ) : <NEWLINE> <INDENT> tyu = [ 0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 ] <NEWLINE> kar = 0 <NEWLINE> for x , y , z , w in p : <NEWLINE> <INDENT> if tyu [ y ] - tyu [ x ] == z : <NEWLINE> <INDENT> kar += w <NEWLINE> <DEDENT> <DEDENT> ans = max ( kar , ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( M ) ] <NEWLINE> dp = [ 0 ] * ( N + 1 ) <NEWLINE> for k in A : <NEWLINE> <INDENT> dp [ k ] = <STRING> <NEWLINE> <DEDENT> dp [ 0 ] = 1 <NEWLINE> if dp [ 1 ] == <STRING> : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if dp [ i ] == <STRING> : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if math . gcd ( a , b ) == 1 : <NEWLINE> <INDENT> ans += k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] * ( 10 ** 4 + 1 ) <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> s = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if s <= 10 ** 4 : <NEWLINE> <INDENT> ans [ s ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( A - 1 , B - 1 ) <NEWLINE> <NL> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> for a in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for b in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if ( a ** 5 - b ** 5 ) == x : <NEWLINE> <INDENT> a_ans = a <NEWLINE> b_ans = b <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a_ans , b_ans ) <NEWLINE>
a = input ( ) <NEWLINE> s = int ( a ) <NEWLINE> s = list ( map ( int , a ) ) <NEWLINE> b = int ( a ) <NEWLINE> <NL> <NL> if b % 9 == 0 or sum ( s ) % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = 0 <NEWLINE> b = list ( ) <NEWLINE> for i in range ( 10 ** 6 + 1 ) : <NEWLINE> <INDENT> b . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if b [ a [ i ] ] == 0 : <NEWLINE> <INDENT> j = 1 <NEWLINE> while j * a [ i ] <= 10 ** 6 : <NEWLINE> <INDENT> b [ j * a [ i ] ] = 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> if ( i == n - 1 or a [ i + 1 ] != a [ i ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> <NL> maxd = float ( <STRING> ) <NEWLINE> nv , ne , r = [ int ( n ) for n in input ( ) . split ( <STRING> ) ] <NEWLINE> vertices = { k : { } for k in range ( nv ) } <NEWLINE> for i in range ( ne ) : <NEWLINE> <INDENT> s , t , w = [ int ( n ) for n in input ( ) . split ( <STRING> ) ] <NEWLINE> vertices [ s ] [ t ] = w <NEWLINE> <NL> <DEDENT> q = [ ] <NEWLINE> heapq . heappush ( q , ( 0 , r ) ) <NEWLINE> <NL> dist = { v : maxd for v in vertices } <NEWLINE> dist [ r ] = 0 <NEWLINE> <NL> while len ( q ) : <NEWLINE> <INDENT> u = heapq . heappop ( q ) [ 1 ] <NEWLINE> <NL> for v in vertices [ u ] : <NEWLINE> <INDENT> alt = dist [ u ] + vertices [ u ] [ v ] <NEWLINE> if alt < dist [ v ] : <NEWLINE> <INDENT> dist [ v ] = alt <NEWLINE> heapq . heappush ( q , ( alt , v ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> [ print ( d ) if d < maxd else print ( <STRING> ) for v , d in dist . items ( ) ] <NEWLINE>
import math <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> <NL> a = 0 <NEWLINE> b = 0 <NEWLINE> while b ** 5 > - x : <NEWLINE> <INDENT> b -= 1 <NEWLINE> <NL> <DEDENT> while a ** 5 - b ** 5 != x : <NEWLINE> <INDENT> if a ** 5 - b ** 5 < x : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> g = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> s += math . gcd ( g , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] != L : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if N == 1 and A [ 0 ] == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif 1 not in A : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
input ( ) <NEWLINE> S = set ( input ( ) . split ( ) ) <NEWLINE> input ( ) <NEWLINE> T = set ( input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for t in T : <NEWLINE> <INDENT> if t in S : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> fifth_power = [ 0 ] * 200 <NEWLINE> for i in range ( 200 ) : <NEWLINE> <INDENT> fifth_power [ i ] = ( i + 1 ) ** 5 <NEWLINE> <DEDENT> for i in range ( 200 ) : <NEWLINE> <INDENT> t = abs ( x - fifth_power [ i ] ) <NEWLINE> if x == 1 : <NEWLINE> <INDENT> print ( 0 , - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif fifth_power . count ( t ) == 1 : <NEWLINE> <INDENT> if fifth_power [ i ] - t == x : <NEWLINE> <INDENT> print ( i + 1 , fifth_power . index ( t ) + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i + 1 , - fifth_power . index ( t ) - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from itertools import product , permutations , combinations <NEWLINE> import math <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( sorted ( ( list ( map ( int , input ( ) . split ( ) ) ) ) ) ) <NEWLINE> <NL> print ( sum ( [ P [ i ] for i in range ( K ) ] ) ) <NEWLINE> exit ( ) <NEWLINE>
idx = int ( input ( ) ) <NEWLINE> in_dict = { } <NEWLINE> <NL> for i in range ( idx ) : <NEWLINE> <INDENT> b , f , r , v = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> b -= 1 <NEWLINE> f -= 1 <NEWLINE> r -= 1 <NEWLINE> in_dict [ ( b , f , r ) ] = in_dict . get ( ( b , f , r ) , 0 ) + v <NEWLINE> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> for r in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( in_dict . get ( ( b , f , r ) , 0 ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> if b in range ( 3 ) : print ( <STRING> * 20 ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( A * B , 2 * ( A + B ) ) <NEWLINE> <NL>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> <NL> def modconb ( n , k , mod ) : <NEWLINE> <COMMENT> <NL> <INDENT> fac = [ 0 ] * ( n + 1 ) <NEWLINE> finv = [ 0 ] * ( n + 1 ) <NEWLINE> inv = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> fac [ 0 ] = fac [ 1 ] = 1 <NEWLINE> finv [ 0 ] = finv [ 1 ] = 1 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i % mod <NEWLINE> inv [ i ] = mod - inv [ mod % i ] * ( mod // i ) % mod <NEWLINE> finv [ i ] = finv [ i - 1 ] * inv [ i ] % mod <NEWLINE> <COMMENT> <NL> <DEDENT> if n < k : return 0 <NEWLINE> if n < 0 or k < 0 : return 0 <NEWLINE> <NL> modcombs = [ 1 ] <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> modcombs . append ( fac [ n ] * ( finv [ k ] * finv [ n - k ] % mod ) % mod ) <NEWLINE> <DEDENT> return modcombs <NEWLINE> <NL> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( m ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> mods = modconb ( n - 1 , n - 1 , mod ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> cnt += m * mods [ i ] * pow ( m - 1 , n - i - 1 , mod ) <NEWLINE> cnt %= mod <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = [ 0 ] * N <NEWLINE> cnt = 0 <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> m [ a - 1 ] = max ( m [ a - 1 ] , H [ b - 1 ] ) <NEWLINE> m [ b - 1 ] = max ( m [ b - 1 ] , H [ a - 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if H [ i ] > m [ i ] or m [ i ] == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def m ( ) : <NEWLINE> <INDENT> e = input <NEWLINE> a = <STRING> <NEWLINE> for _ in [ 0 ] * int ( e ( ) ) : <NEWLINE> <INDENT> X , z = e ( ) , [ ] <NEWLINE> for y in e ( ) : <NEWLINE> <INDENT> s = i = 0 <NEWLINE> for k in z : <NEWLINE> <INDENT> t = X . find ( y , s ) + 1 <NEWLINE> if t < 1 : break <NEWLINE> if t < k : z [ i ] = t <NEWLINE> s = k ; i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = X . find ( y , s ) + 1 <NEWLINE> if t : z += [ t ] <NEWLINE> <DEDENT> <DEDENT> a += <STRING> <NEWLINE> <DEDENT> print ( a [ 1 : ] ) <NEWLINE> <DEDENT> if <STRING> == __name__ : m ( ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <NL> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ set ( [ ] ) for i in range ( N ) ] <NEWLINE> <NL> <NL> def dfs ( n , y ) : <NEWLINE> <INDENT> seen [ n ] = True <NEWLINE> y += 1 <NEWLINE> for c in C [ n ] : <NEWLINE> <INDENT> if seen [ c ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = dfs ( c , y ) <NEWLINE> <DEDENT> <DEDENT> return y <NEWLINE> <NL> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> C [ a - 1 ] . add ( b - 1 ) <NEWLINE> C [ b - 1 ] . add ( a - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> seen = [ False ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if seen [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x = 0 <NEWLINE> x = dfs ( i , x ) <NEWLINE> ans = max ( ans , x ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> g = [ 0 ] * N <NEWLINE> r = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if H [ a - 1 ] > H [ b - 1 ] : <NEWLINE> <INDENT> g [ a - 1 ] += 1 <NEWLINE> <DEDENT> if H [ a - 1 ] < H [ b - 1 ] : <NEWLINE> <INDENT> g [ b - 1 ] += 1 <NEWLINE> <DEDENT> r [ a - 1 ] += 1 <NEWLINE> r [ b - 1 ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if g [ j ] == r [ j ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> r0 = int ( input ( ) ) <NEWLINE> r1 = int ( input ( ) ) <NEWLINE> min_r = min ( r0 , r1 ) <NEWLINE> ans = r1 - r0 <NEWLINE> for _ in range ( 2 , n ) : <NEWLINE> <INDENT> r = int ( input ( ) ) <NEWLINE> ans = max ( ans , r - min_r ) <NEWLINE> min_r = min ( r , min_r ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for nn in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> if x2 - x1 == 0 or x4 - x3 == 0 : <NEWLINE> <INDENT> if x1 == x2 and x3 == x4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if abs ( ( y2 - y1 ) / ( x2 - x1 ) - ( y4 - y3 ) / ( x4 - x3 ) ) < 10 ** - 10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( <STRING> ) <NEWLINE> lista = [ int ( n ) for n in a ] <NEWLINE> listb = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> l = lista [ i ] <NEWLINE> listb [ l - 1 ] += 1 <NEWLINE> <DEDENT> [ print ( i ) for i in listb ] <NEWLINE>
from math import pi <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( pi * r * r ) , <STRING> . format ( 2 * r * pi ) ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> def IS ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def II ( ) : return int ( IS ( ) ) <NEWLINE> def MII ( ) : return list ( map ( int , IS ( ) . split ( ) ) ) <NEWLINE> from bisect import bisect_left <NEWLINE> from collections import deque <NEWLINE> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> n = II ( ) <NEWLINE> cc = list ( IS ( ) ) <NEWLINE> cc_rev = cc [ : : - 1 ] <NEWLINE> cnt = 0 <NEWLINE> indexs = [ ] <NEWLINE> for i , c in enumerate ( cc ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> indexs . append ( i ) <NEWLINE> <DEDENT> <DEDENT> indexs = deque ( indexs ) <NEWLINE> if cc . count ( <STRING> ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return 0 <NEWLINE> <COMMENT> <NL> <DEDENT> for i , c in enumerate ( cc_rev ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> if indexs : <NEWLINE> <INDENT> idx = indexs . popleft ( ) <NEWLINE> if idx < ( n - i - 1 ) : <NEWLINE> <INDENT> cc [ idx ] = <STRING> <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> xy = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> xy . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> a , b = xy [ 0 ] <NEWLINE> m1 = a + b <NEWLINE> p1 = xy [ 0 ] <NEWLINE> m2 = a - b <NEWLINE> p2 = xy [ 0 ] <NEWLINE> p3 = xy [ 0 ] <NEWLINE> p4 = xy [ 0 ] <NEWLINE> m3 = - a - b <NEWLINE> m4 = - a + b <NEWLINE> <NL> for x , y in xy : <NEWLINE> <INDENT> if x + y > m1 : <NEWLINE> <INDENT> m1 = x + y <NEWLINE> p1 = [ x , y ] <NEWLINE> <DEDENT> if x - y > m2 : <NEWLINE> <INDENT> m2 = x - y <NEWLINE> p2 = [ x , y ] <NEWLINE> <DEDENT> if - x - y > m3 : <NEWLINE> <INDENT> m3 = - x - y <NEWLINE> p3 = [ x , y ] <NEWLINE> <DEDENT> if - x + y > m4 : <NEWLINE> <INDENT> m4 = - x + y <NEWLINE> p4 = [ x , y ] <NEWLINE> <DEDENT> <DEDENT> m = 0 <NEWLINE> for x0 , y0 in [ p1 , p2 , p3 , p4 ] : <NEWLINE> <INDENT> for x1 , y1 in [ p1 , p2 , p3 , p4 ] : <NEWLINE> <INDENT> dis = abs ( x0 - x1 ) + abs ( y0 - y1 ) <NEWLINE> if dis > m : <NEWLINE> <INDENT> m = dis <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dic = { } <NEWLINE> list_town = [ ] <NEWLINE> set_town = set ( ) <NEWLINE> town = 1 <NEWLINE> <NL> for i , v in enumerate ( A ) : <NEWLINE> <INDENT> dic [ i + 1 ] = v <NEWLINE> <NL> <DEDENT> for _ in range ( K ) : <NEWLINE> <INDENT> list_town . append ( town ) <NEWLINE> set_town . add ( town ) <NEWLINE> town = dic [ town ] <NEWLINE> if town in set_town : <NEWLINE> <INDENT> stop_twon = town <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if N <= K : <NEWLINE> <INDENT> list_first_split = list_town [ : list_town . index ( stop_twon ) ] <NEWLINE> list_second_split = list_town [ list_town . index ( stop_twon ) : ] <NEWLINE> print ( list_second_split [ ( K - ( len ( list_first_split ) ) ) % len ( list_second_split ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( town ) <NEWLINE> <DEDENT>
MOD = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> s = sum ( a ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s -= a [ i ] <NEWLINE> ans = ( ans + a [ i ] * s % MOD ) % MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x , k , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = abs ( x ) <NEWLINE> a , b = divmod ( x , d ) <NEWLINE> a = min ( a , k ) <NEWLINE> x -= a * d <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> x -= d * ( ( k - a ) % 2 ) <NEWLINE> print ( abs ( x ) ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> input = sys . stdin . readline <NEWLINE> <NL> def inp ( ) : <NEWLINE> <INDENT> return ( int ( input ( ) ) ) <NEWLINE> <DEDENT> def inlt ( ) : <NEWLINE> <INDENT> return ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> def insr ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> return ( list ( s [ : len ( s ) - 1 ] ) ) <NEWLINE> <DEDENT> def invr ( ) : <NEWLINE> <INDENT> return ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> def run_test ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> run_test ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def multiply ( arr ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> if 0 in arr : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> for i in arr : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> print ( multiply ( nums ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> B [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( list ( map ( str , B ) ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <DEDENT> div_arr = make_divisors ( N ) <NEWLINE> <NL> if len ( div_arr ) == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif len ( div_arr ) == 2 : <NEWLINE> <INDENT> ans_num = max ( div_arr ) <NEWLINE> print ( len ( str ( ans_num ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memo = [ ] <NEWLINE> if len ( div_arr ) % 2 == 0 : <NEWLINE> <INDENT> last_idx = - 1 <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( div_arr ) ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if N == div_arr [ i ] * div_arr [ last_idx ] and count != len ( div_arr ) // 2 : <NEWLINE> <INDENT> last_idx -= 1 <NEWLINE> memo . append ( len ( str ( div_arr [ last_idx ] ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> target_index = len ( div_arr ) // 2 <NEWLINE> memo . append ( len ( str ( div_arr [ target_index ] ) ) ) <NEWLINE> <DEDENT> print ( min ( memo ) ) <NEWLINE> <DEDENT>
from numba import njit <NEWLINE> @ njit ( <STRING> ) <NEWLINE> <NL> def f ( n ) : <NEWLINE> <NL> <NL> <INDENT> l = [ 1 ] * ( n + 1 ) <NEWLINE> l [ 0 ] = 0 <NEWLINE> ans = l [ 1 ] <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 , i ) : <NEWLINE> <INDENT> l [ j ] += 1 <NEWLINE> <NL> <DEDENT> ans += ( l [ i ] * i ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( f ( n ) ) <NEWLINE>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> if abs ( b - a ) <= ( v - w ) * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> s = input ( ) <NEWLINE> a = [ str ( c ) for c in s ] <NEWLINE> <NL> c = 0 <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if a [ i ] == <STRING> and a [ i + 1 ] == <STRING> and a [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <NL>
while True : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> risks = [ ( p , d ) for d , p in ( map ( int , input ( ) . split ( ) ) for _ in range ( n ) ) ] <NEWLINE> risks . sort ( ) <NEWLINE> remain = 0 <NEWLINE> while risks : <NEWLINE> <INDENT> p , d = risks . pop ( ) <NEWLINE> if d >= m : <NEWLINE> <INDENT> remain = p * ( d - m ) <NEWLINE> break <NEWLINE> <DEDENT> m -= d <NEWLINE> <DEDENT> print ( remain + sum ( p * d for p , d in risks ) ) <NEWLINE> <DEDENT>
from itertools import combinations <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> list1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( sum ( sorted ( list1 ) [ : k ] ) ) <NEWLINE>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( round ( r * r * pi , 7 ) , round ( 2 * pi * r , 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maxL = max ( lis ) + 1 <NEWLINE> t = [ 0 ] * maxL <NEWLINE> lis . sort ( ) <NEWLINE> for k in lis : <NEWLINE> <INDENT> t [ k ] += 1 <NEWLINE> if t [ k ] == 1 : <NEWLINE> <INDENT> for p in range ( k * 2 , maxL , k ) : <NEWLINE> <INDENT> t [ p ] += 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( t . count ( 1 ) ) <NEWLINE>
from collections import deque <NEWLINE> S = input ( ) <NEWLINE> d = deque ( [ S [ i ] for i in range ( len ( S ) ) ] ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> bol = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> if a [ 0 ] == <STRING> : <NEWLINE> <INDENT> bol = 0 if bol else 1 <NEWLINE> <DEDENT> elif a [ 1 ] == <STRING> : <NEWLINE> <INDENT> if not bol : <NEWLINE> <INDENT> d . appendleft ( a [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . append ( a [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if not bol : <NEWLINE> <INDENT> d . append ( a [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . appendleft ( a [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( d ) if not bol else <STRING> . join ( reversed ( d ) ) ) <NEWLINE>
n = input ( ) <NEWLINE> A = input ( ) . split ( <STRING> ) <NEWLINE> A . sort ( ) <NEWLINE> A . reverse ( ) <NEWLINE> q = input ( ) <NEWLINE> M = input ( ) . split ( <STRING> ) <NEWLINE> <NL> A = list ( map ( int , A ) ) <NEWLINE> M = list ( map ( int , M ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> A_sum = [ 0 ] <NEWLINE> for a in A : <NEWLINE> <INDENT> A_sum . append ( a + A_sum [ - 1 ] ) <NEWLINE> <DEDENT> A_sum . pop ( 0 ) <NEWLINE> <NL> A . reverse ( ) <NEWLINE> A_sum . reverse ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> def search ( base , m , n ) : <NEWLINE> <INDENT> if base == m : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if len ( A ) - 1 < n or m - base > A_sum [ n ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> result = False <NEWLINE> for i in range ( len ( A ) - 1 , n - 1 , - 1 ) : <NEWLINE> <INDENT> if base + A [ i ] <= m : <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if search ( base + A [ i ] , m , i + 1 ) : <NEWLINE> <INDENT> return True <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <DEDENT> def print_yn ( result ) : <NEWLINE> <INDENT> if result : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> for m in M : <NEWLINE> <COMMENT> <NL> <INDENT> print_yn ( search ( 0 , m , 0 ) ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> maxlen = S // 3 <NEWLINE> maxlist = [ [ 0 ] * ( S - 2 ) for i in range ( maxlen ) ] <NEWLINE> suml = 0 <NEWLINE> for i in range ( 1 , maxlen + 1 ) : <NEWLINE> <INDENT> for j in range ( 3 * i , S + 1 ) : <NEWLINE> <INDENT> if i == 1 or j == 3 * i : <NEWLINE> <INDENT> maxlist [ i - 1 ] [ j - 3 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> maxlist [ i - 1 ] [ j - 3 ] = maxlist [ i - 1 ] [ j - 4 ] + maxlist [ i - 2 ] [ j - 6 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , maxlen + 1 ) : <NEWLINE> <INDENT> suml += maxlist [ i - 1 ] [ S - 3 ] <NEWLINE> <DEDENT> suml = suml % ( 10 ** 9 + 7 ) <NEWLINE> <NL> print ( suml ) <NEWLINE>
import heapq <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> line = [ ] <NEWLINE> heapq . heappush ( line , - A [ 0 ] ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans -= heapq . heappop ( line ) <NEWLINE> heapq . heappush ( line , - A [ i ] ) <NEWLINE> heapq . heappush ( line , - A [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from itertools import accumulate <NEWLINE> <NL> <NL> def LI ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> n = 10 ** 5 <NEWLINE> sosu = set ( range ( 2 , n + 1 ) ) <NEWLINE> for i in range ( 2 , int ( n ** 0.5 + 1 ) ) : <NEWLINE> <INDENT> sosu . difference_update ( range ( i * 2 , n + 1 , i ) ) <NEWLINE> <DEDENT> xlist = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( 1 , 10 ** 5 + 1 , 2 ) : <NEWLINE> <INDENT> if i in sosu : <NEWLINE> <INDENT> if ( i + 1 ) // 2 in sosu : <NEWLINE> <INDENT> xlist [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> Xsum = list ( accumulate ( xlist ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> L , R = LI ( ) <NEWLINE> ans = Xsum [ R ] - Xsum [ L - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for h in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X_bin = input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> X_int = int ( X_bin , 2 ) <COMMENT> <NEWLINE> <NL> <NL> def calc_bin_cnt ( next_int ) : <NEWLINE> <INDENT> if next_int == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> next_bin = bin ( next_int ) [ 2 : ] <NEWLINE> <COMMENT> <NL> cnt = 0 <NEWLINE> for i in next_bin : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> def calc_ans ( next_int , cnt = None ) : <NEWLINE> <INDENT> if next_cnt == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if next_int == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if cnt is None : <NEWLINE> <INDENT> cnt = calc_bin_cnt ( next_int ) <NEWLINE> <DEDENT> next_int = next_int % cnt <NEWLINE> if next_int > 0 : <NEWLINE> <INDENT> ans = calc_ans ( next_int ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> X_cnt = calc_bin_cnt ( X_int ) <NEWLINE> f_p = X_int % ( X_cnt + 1 ) <NEWLINE> if X_cnt - 1 == 0 : <NEWLINE> <INDENT> f_m = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f_m = X_int % ( X_cnt - 1 ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X_bin [ i ] == <STRING> : <NEWLINE> <INDENT> next_cnt = X_cnt - 1 <NEWLINE> if next_cnt == 0 : <NEWLINE> <INDENT> next_int = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> next_int = f_m - pow ( 2 , ( N - i - 1 ) , next_cnt ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> next_cnt = X_cnt + 1 <NEWLINE> next_int = f_p + pow ( 2 , ( N - i - 1 ) , next_cnt ) <NEWLINE> <DEDENT> print ( calc_ans ( next_int , next_cnt ) ) <NEWLINE> <COMMENT> <NL> <DEDENT>
import collections <NEWLINE> <NL> num_of_employee = int ( input ( ) ) <NEWLINE> employeenos = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( employeenos ) <NEWLINE> for i in range ( 1 , num_of_employee + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cal = 0 <NEWLINE> time = [ 0 ] * N <NEWLINE> town = [ ] <NEWLINE> roop = [ ] <NEWLINE> <NL> while time [ cal ] != 2 : <NEWLINE> <INDENT> if time [ cal ] == 0 : <NEWLINE> <INDENT> town . append ( cal ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> roop . append ( cal ) <NEWLINE> <NL> <DEDENT> time [ cal ] += 1 <NEWLINE> cal = A [ cal ] - 1 <NEWLINE> <NL> <DEDENT> if len ( town ) > K : <NEWLINE> <INDENT> print ( town [ K ] + 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( roop [ ( K - ( len ( town ) - len ( roop ) ) ) % len ( roop ) ] + 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> if a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a [ 0 ] <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def II ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def TI ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def RN ( N ) : return [ input ( ) . strip ( ) for i in range ( N ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = II ( ) <NEWLINE> P = LI ( ) <NEWLINE> ans = 0 <NEWLINE> min = N + 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if P [ i ] < min : <NEWLINE> <INDENT> ans += 1 <NEWLINE> min = P [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def run ( ) : <NEWLINE> <INDENT> X , N = [ int ( v ) for v in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> p = [ ] <NEWLINE> if N > 0 : <NEWLINE> <INDENT> p = [ int ( v ) for v in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> i = - 1 <NEWLINE> try : <NEWLINE> <INDENT> i = p . index ( X ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> if i == - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> return X <NEWLINE> <NL> <DEDENT> d1 = { } <NEWLINE> for k in range ( 0 , 102 ) : <NEWLINE> <INDENT> d1 [ k ] = k <NEWLINE> <NL> <DEDENT> for v in p : <NEWLINE> <INDENT> del d1 [ v ] <NEWLINE> <NL> <DEDENT> l2 = sorted ( list ( d1 . keys ( ) ) ) <NEWLINE> <NL> l2 . append ( X ) <NEWLINE> l2 . sort ( ) <NEWLINE> i = l2 . index ( X ) <NEWLINE> <NL> r = 0 <NEWLINE> if i == 0 : <NEWLINE> <INDENT> r = l2 [ 1 ] <NEWLINE> <DEDENT> elif ( i + 1 ) == len ( l2 ) : <NEWLINE> <INDENT> r = l2 [ - 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v1 = l2 [ i + 1 ] - X <NEWLINE> v2 = X - l2 [ i - 1 ] <NEWLINE> if v1 < v2 : <NEWLINE> <INDENT> r = l2 [ i + 1 ] <NEWLINE> <DEDENT> elif v1 > v2 : <NEWLINE> <INDENT> r = l2 [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> r = l2 [ i - 1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> return r <NEWLINE> <NL> <DEDENT> r = run ( ) <NEWLINE> print ( r ) <NEWLINE> <NL>
def lcs ( x , y ) : <NEWLINE> <INDENT> a = len ( x ) <NEWLINE> b = len ( y ) <NEWLINE> c1 = [ 0 ] * ( b + 1 ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> e1 = x [ i ] <NEWLINE> c2 = c1 [ : ] <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> if e1 == y [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c2 [ j ] + 1 <NEWLINE> <DEDENT> elif c1 [ j + 1 ] < c1 [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c1 [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return c1 [ - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) . rstrip ( ) ) <NEWLINE> ret = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s1 = input ( ) . rstrip ( ) <NEWLINE> s2 = input ( ) . rstrip ( ) <NEWLINE> ret . append ( lcs ( s1 , s2 ) ) <NEWLINE> <DEDENT> print ( * ret , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ <STRING> . join ( sorted ( input ( ) ) ) for _ in range ( n ) ] <NEWLINE> ans = 0 <NEWLINE> d = { } <NEWLINE> for i in s : <NEWLINE> <INDENT> if i in d : <NEWLINE> <INDENT> ans += d [ i ] <NEWLINE> d [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> if n <= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> yakusu = set ( make_divisors ( n ) ) <NEWLINE> yakusu . discard ( 1 ) <NEWLINE> <NL> sosu = set ( [ min ( yakusu ) ] ) <NEWLINE> tansaku = set ( yakusu ) <NEWLINE> kari = set ( tansaku ) <NEWLINE> <NL> <NL> <NL> while 1 : <NEWLINE> <INDENT> for var in tansaku : <NEWLINE> <INDENT> if var % max ( sosu ) == 0 : <NEWLINE> <INDENT> kari . discard ( var ) <NEWLINE> <DEDENT> <DEDENT> tansaku = set ( kari ) <NEWLINE> if len ( tansaku ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sosu . add ( min ( tansaku ) ) <NEWLINE> <DEDENT> sosu = sosu | tansaku <NEWLINE> <NL> i = 1 <NEWLINE> j = 0 <NEWLINE> kari = set ( sosu ) <NEWLINE> <NL> while n != 1 : <NEWLINE> <INDENT> for var in sosu : <NEWLINE> <INDENT> if n % ( var ** i ) == 0 : <NEWLINE> <INDENT> n = n / ( var ** i ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kari . discard ( var ) <NEWLINE> <DEDENT> <DEDENT> sosu = set ( kari ) <NEWLINE> <NL> i += 1 <NEWLINE> if i > 1000 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( j ) <NEWLINE>
import sys <NEWLINE> while True : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x == 0 ) and ( y == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 0 , x ) : <NEWLINE> <INDENT> for j in range ( 0 , y ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> print ( N * ( N - 1 ) // 2 ) <NEWLINE>
<COMMENT> <NL> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> f1 = 0 <NEWLINE> f2 = 0 <NEWLINE> if N >= B : <NEWLINE> <INDENT> f1 = int ( A * ( B - 1 ) / B ) <NEWLINE> f2 = A * int ( ( B - 1 ) / B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f1 = int ( A * N / B ) <NEWLINE> f2 = A * int ( N / B ) <NEWLINE> <NL> <DEDENT> ans = f1 - f2 <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <DEDENT> K = int ( input ( ) ) <NEWLINE> S = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> if a == b == c : <NEWLINE> <INDENT> S += a <NEWLINE> <DEDENT> if a == b != c or a != b == c : <NEWLINE> <INDENT> S += 3 * math . gcd ( a , c ) <NEWLINE> <DEDENT> if a != b != c : <NEWLINE> <INDENT> S += 6 * gcd ( a , b , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
n , m , l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> res = [ [ 0 for i in range ( l ) ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for k in range ( l ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> res [ i ] [ k ] += A [ i ] [ j ] * B [ j ] [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in res : <NEWLINE> <INDENT> print ( <STRING> . join ( list ( map ( str , i ) ) ) ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> left_l = [ <STRING> , <STRING> ] <NEWLINE> right_l = [ <STRING> , <STRING> ] <NEWLINE> s_l = [ s , s [ : : - 1 ] ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> lst = [ i for i in input ( ) . split ( ) ] <NEWLINE> if lst [ 0 ] == <STRING> : <NEWLINE> <INDENT> if c == 1 : <NEWLINE> <INDENT> s_l [ 0 ] , s_l [ 1 ] = s_l [ 1 ] , s_l [ 0 ] <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> s_l = [ right_l [ 1 ] + s_l [ 1 ] + left_l [ 1 ] , left_l [ 0 ] + s_l [ 0 ] + right_l [ 0 ] ] <NEWLINE> left_l [ 0 ] , left_l [ 1 ] = <STRING> , <STRING> <NEWLINE> right_l [ 0 ] , right_l [ 1 ] = <STRING> , <STRING> <NEWLINE> c = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> elif lst [ 0 ] == <STRING> : <NEWLINE> <INDENT> c = 0 <NEWLINE> if lst [ 1 ] == <STRING> : <NEWLINE> <INDENT> left_l [ 0 ] = lst [ 2 ] + left_l [ 0 ] <NEWLINE> left_l [ 1 ] = left_l [ 1 ] + lst [ 2 ] <NEWLINE> <DEDENT> elif lst [ 1 ] == <STRING> : <NEWLINE> <INDENT> right_l [ 0 ] = right_l [ 0 ] + lst [ 2 ] <NEWLINE> right_l [ 1 ] = lst [ 2 ] + right_l [ 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> w = left_l [ 0 ] + s_l [ 0 ] + right_l [ 0 ] <NEWLINE> print ( w ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> X = list ( input ( ) ) <NEWLINE> <NL> ones = X . count ( <STRING> ) <NEWLINE> high = ones + 1 <NEWLINE> low = ones - 1 <NEWLINE> <NL> mod_h = [ 1 ] <NEWLINE> mod_l = [ 1 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> mod_h . append ( ( mod_h [ - 1 ] * 2 ) % high ) <NEWLINE> mod_l . append ( ( mod_l [ - 1 ] * 2 ) % low if low != 0 else 0 ) <NEWLINE> <NL> <DEDENT> mod_h = mod_h [ : : - 1 ] <NEWLINE> mod_l = mod_l [ : : - 1 ] <NEWLINE> <NL> ans_high = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> ans_high += mod_h [ i ] <NEWLINE> <DEDENT> <DEDENT> ans_high %= high <NEWLINE> <NL> ans_low = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> ans_low += mod_l [ i ] <NEWLINE> <DEDENT> <DEDENT> ans_low %= low if low != 0 else 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> ans = ans_high <NEWLINE> ans += mod_h [ i ] <NEWLINE> ans %= high <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if low == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> ans = ans_low <NEWLINE> ans -= mod_l [ i ] <NEWLINE> ans %= low <NEWLINE> <NL> <DEDENT> count = 1 <NEWLINE> while ans != 0 : <NEWLINE> <INDENT> ans = ans % ( bin ( ans ) . count ( <STRING> ) ) <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for tail , head in zip ( A , A [ K : ] ) : <NEWLINE> <INDENT> if tail < head : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def solve ( s ) : <NEWLINE> <INDENT> n = len ( s ) <NEWLINE> res = 0 <NEWLINE> i = 0 <NEWLINE> num = 0 <NEWLINE> while i < n - 1 : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> num += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> elif s [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> res += num <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = 0 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> print ( solve ( s ) ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> ans = [ 0 for _ in range ( 10001 ) ] <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> m = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if m > 10000 : break <NEWLINE> ans [ m ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> l = list ( itertools . combinations_with_replacement ( list ( range ( 1 , k + 1 ) ) , 3 ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> a , b , c = i <NEWLINE> if a == b == c : <NEWLINE> <INDENT> ans += math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <DEDENT> elif ( a == b ) or ( b == c ) : <NEWLINE> <INDENT> ans += 3 * ( math . gcd ( math . gcd ( a , b ) , c ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 6 * ( math . gcd ( math . gcd ( a , b ) , c ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> @ njit <COMMENT> <NEWLINE> def imos ( n , k , a ) : <NEWLINE> <NL> <INDENT> l = np . zeros ( ( n + 1 ) , dtype = np . int64 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ai = a [ i ] <NEWLINE> start = max ( 0 , i - ai ) <COMMENT> <NEWLINE> end = min ( n , i + ai + 1 ) <COMMENT> <NEWLINE> l [ start ] += 1 <NEWLINE> l [ end ] -= 1 <NEWLINE> <DEDENT> return np . cumsum ( l ) [ : n ] <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> a = imos ( n , k , a ) <NEWLINE> if a . min ( ) == n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * a ) <NEWLINE> <DEDENT>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> List = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> <NL> <NL> ans = 10000000000000 <NEWLINE> for j in range ( 1 , 2 ** ( N + 1 ) - 1 ) : <NEWLINE> <INDENT> combinationlist = list ( map ( int , [ i for i in format ( 2 ** ( N + 1 ) + j , <STRING> ) ] ) ) <NEWLINE> del combinationlist [ 0 ] <NEWLINE> sumoflist = [ sum ( combinationlist [ s ] * List [ s ] [ k ] for s in range ( N ) ) for k in range ( M + 1 ) ] <NEWLINE> flag = True <NEWLINE> for t in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if sumoflist [ t ] < X : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag and sumoflist [ 0 ] < ans : <NEWLINE> <INDENT> ans = sumoflist [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if ans != 10000000000000 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
number = str ( input ( ) ) [ : : - 1 ] <NEWLINE> remainderDictionary = { 0 : 1 } <NEWLINE> digitDictionary = { <STRING> : 1 , <STRING> : 2 , <STRING> : 3 , <STRING> : 4 , <STRING> : 5 , <STRING> : 6 , <STRING> : 7 , <STRING> : 8 , <STRING> : 9 } <NEWLINE> <NL> sum = 0 <NEWLINE> x = 1 <NEWLINE> for i in number : <NEWLINE> <INDENT> x = ( x * 10 ) % 2019 <NEWLINE> sum = ( sum + digitDictionary [ i ] * x ) % 2019 <NEWLINE> remainderDictionary [ sum ] = remainderDictionary . get ( sum , 0 ) + 1 <NEWLINE> <NL> <DEDENT> ansDictionary = { } <COMMENT> <NEWLINE> ans = 0 <NEWLINE> for i in remainderDictionary : <NEWLINE> <INDENT> remainderOccurences = remainderDictionary [ i ] <NEWLINE> value = ansDictionary . get ( remainderOccurences , - 1 ) <NEWLINE> if value == - 1 : <NEWLINE> <INDENT> value = remainderOccurences * ( remainderOccurences - 1 ) // 2 <COMMENT> <NEWLINE> ansDictionary [ remainderOccurences ] = value <NEWLINE> <DEDENT> ans += value <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> <NL> directions = [ ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ] <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <INDENT> H , W = map ( int , s . split ( ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> M = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> s = input ( ) . strip ( ) <NEWLINE> M . append ( s ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> A = [ [ None for i in range ( W ) ] for j in range ( H ) ] <NEWLINE> <NL> def drawable ( x , y ) : <NEWLINE> <INDENT> if 0 <= x < W and 0 <= y < H and A [ y ] [ x ] == None : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> color_num = 0 <NEWLINE> <NL> def fill ( x , y ) : <NEWLINE> <INDENT> global color_num <NEWLINE> <NL> Q = [ ( x , y ) ] <NEWLINE> while Q : <NEWLINE> <INDENT> p = Q . pop ( 0 ) <NEWLINE> _x = p [ 0 ] <NEWLINE> _y = p [ 1 ] <NEWLINE> A [ _y ] [ _x ] = color_num <NEWLINE> for direction in directions : <NEWLINE> <INDENT> new_x = _x + direction [ 0 ] <NEWLINE> new_y = _y + direction [ 1 ] <NEWLINE> if drawable ( new_x , new_y ) and M [ _y ] [ _x ] == M [ new_y ] [ new_x ] : <NEWLINE> <INDENT> A [ new_y ] [ new_x ] = color_num <NEWLINE> Q . append ( ( new_x , new_y ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for y in range ( H ) : <NEWLINE> <INDENT> for x in range ( W ) : <NEWLINE> <INDENT> if drawable ( x , y ) : <NEWLINE> <INDENT> color_num += 1 <NEWLINE> fill ( x , y ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( color_num ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for _ in range ( m ) ] ) <NEWLINE> <NL> INF = 1000000007 <NEWLINE> <NL> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> if 1 not in a : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> dp [ i ] %= INF <NEWLINE> <NL> <DEDENT> print ( dp [ n ] ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <NL> <NL> N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> sorted_A = sorted ( A ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> idx = bisect_left ( sorted_A , A [ i ] ) <NEWLINE> if i % 2 != idx % 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> n = len ( s ) <NEWLINE> <NL> mod = [ 0 ] * 2019 <NEWLINE> pre = 0 <NEWLINE> mod [ pre ] = 1 <NEWLINE> x = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> pre += int ( s [ i ] ) * x <NEWLINE> pre %= 2019 <NEWLINE> mod [ pre ] += 1 <NEWLINE> x *= 10 <NEWLINE> x %= 2019 <NEWLINE> <DEDENT> print ( sum ( [ m * ( m - 1 ) // 2 for m in mod ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = a [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] < s : <NEWLINE> <INDENT> ans += s - a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = a [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> import numpy as np <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> s = input ( ) . strip ( ) <NEWLINE> N = len ( s ) <NEWLINE> p = sum ( [ 1 if si == <STRING> else 0 for si in s ] ) <NEWLINE> print ( N // 2 - p ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import pi <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( pi * r * r , 2 * pi * r ) ) <NEWLINE>
from decimal import Decimal <NEWLINE> <NL> a , b = map ( Decimal , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nums = [ ] <NEWLINE> <NL> <NL> for v in range ( n ) : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> nums . append ( num ) <NEWLINE> <NL> <DEDENT> ma = - 1000000000 <NEWLINE> mi = nums [ 0 ] <NEWLINE> for p in range ( 1 , len ( nums ) ) : <NEWLINE> <INDENT> a = nums [ p ] <NEWLINE> if a - mi > ma : <NEWLINE> <INDENT> ma = a - mi <NEWLINE> <DEDENT> if a < mi : <NEWLINE> <INDENT> mi = a <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( ma ) <NEWLINE>
N , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> d = [ ] <NEWLINE> A = [ ] <NEWLINE> person = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> d . append ( a ) <NEWLINE> b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A . append ( b ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> person . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( d [ i ] ) : <NEWLINE> <INDENT> if A [ i ] [ j ] in person : <NEWLINE> <INDENT> person . remove ( A [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( person ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> c = min ( b - 1 , n ) <NEWLINE> print ( int ( a * c / b ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> x = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> x *= a <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 if x > 10 ** 18 else x ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> from collections import deque <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> max_ = pow ( 10 , 18 ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for tmp in a : <NEWLINE> <INDENT> ans *= tmp <NEWLINE> if ( ans > max_ ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> visit = [ ] <NEWLINE> visit = [ 0 ] * n <NEWLINE> pos = 0 <NEWLINE> move = [ ] <NEWLINE> roop = [ ] <NEWLINE> while visit [ pos ] != 2 : <NEWLINE> <INDENT> if visit [ pos ] == 0 : <NEWLINE> <INDENT> move . append ( pos ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> roop . append ( pos ) <NEWLINE> <DEDENT> visit [ pos ] += 1 <NEWLINE> pos = a [ pos ] - 1 <NEWLINE> <DEDENT> if len ( move ) > k : <NEWLINE> <INDENT> print ( move [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mod = ( k - ( len ( move ) - len ( roop ) ) ) % len ( roop ) <NEWLINE> print ( roop [ mod ] + 1 ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> fly = 0 <NEWLINE> l = [ ] <NEWLINE> while fly < b : <NEWLINE> <INDENT> fly += k <NEWLINE> l . append ( fly ) <NEWLINE> <NL> <DEDENT> if len ( l ) == 1 : <NEWLINE> <INDENT> if k >= a and k <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if l [ - 1 ] >= a and l [ - 1 ] <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif l [ - 2 ] >= a and l [ - 2 ] <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> Li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Li . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> a = Li [ i ] + Li [ j ] <NEWLINE> t = bisect . bisect_left ( Li , a ) <NEWLINE> ans += t - ( j + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> f = [ 0 for i in range ( n ) ] <NEWLINE> for i in input ( ) . split ( ) : <NEWLINE> <INDENT> f [ int ( i ) - 1 ] += 1 <NEWLINE> <DEDENT> print ( * f ) <NEWLINE>
import sys <NEWLINE> <NL> d = [ 0 ] * 26 <NEWLINE> def judge ( n , t ) : <NEWLINE> <INDENT> today = t [ n - 1 ] - 1 <NEWLINE> res = S [ n - 1 ] [ today ] <NEWLINE> for j , dd in enumerate ( d ) : <NEWLINE> <INDENT> if today != j : <NEWLINE> <INDENT> res -= C [ j ] * ( n - dd ) <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> D = int ( input ( ) ) <NEWLINE> C = list ( map ( int , sys . stdin . readline ( ) . rsplit ( ) ) ) <NEWLINE> S = [ list ( map ( int , sys . stdin . readline ( ) . rsplit ( ) ) ) for _ in range ( D ) ] <NEWLINE> <NL> d = [ 0 ] * 26 <NEWLINE> res = 0 <NEWLINE> tt = [ ] <NEWLINE> for i in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> maxi = 0 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> tt . append ( j + 1 ) <NEWLINE> jg = judge ( i , tt ) <NEWLINE> if maxi < jg : <NEWLINE> <INDENT> maxT = j + 1 <NEWLINE> maxi = jg <NEWLINE> <DEDENT> tt . pop ( ) <NEWLINE> <DEDENT> d [ maxT - 1 ] = i <NEWLINE> tt . append ( maxT - 1 ) <NEWLINE> print ( maxT ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> ali = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ali . sort ( reverse = True ) <NEWLINE> <NL> comforts = deque ( [ ali [ 1 ] , ali [ 1 ] ] ) <NEWLINE> answer = ali [ 0 ] <NEWLINE> if len ( ali ) < 3 : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in ali [ 2 : ] : <NEWLINE> <INDENT> answer += comforts . pop ( ) <NEWLINE> comforts . appendleft ( i ) <NEWLINE> comforts . appendleft ( i ) <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = list ( map ( int , ( input ( ) . split ( ) ) ) ) <NEWLINE> lst = [ _ - 1 for _ in lst ] <NEWLINE> <NL> visited = [ 0 ] * n <NEWLINE> i = 0 <NEWLINE> now = 0 <NEWLINE> while k > i : <NEWLINE> <INDENT> if visited [ now ] == 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> visited [ now ] = i <NEWLINE> now = lst [ now ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> lp = ( i + 1 ) - visited [ now ] <NEWLINE> st = i - lp <NEWLINE> k_bk = k - st <NEWLINE> k_bk = k_bk // lp <NEWLINE> lft = k - ( k_bk * lp + st ) <NEWLINE> <NL> if lft == 0 : <NEWLINE> <INDENT> print ( now + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for _ in range ( lft ) : <NEWLINE> <INDENT> now = lst [ now ] <NEWLINE> <DEDENT> print ( now + 1 ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( stdin . readline ( ) ) <NEWLINE> a = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> a2 = [ [ a [ i ] , i ] for i in range ( n ) ] <NEWLINE> a2 . sort ( reverse = True ) <NEWLINE> <NL> dp = [ [ 0 for _ in range ( n + 1 ) ] for _ in range ( n + 1 ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( n + 1 - i ) : <NEWLINE> <INDENT> s1 = s2 = 0 <NEWLINE> if i > 0 : <NEWLINE> <INDENT> s1 = dp [ i - 1 ] [ j ] + a2 [ i + j - 1 ] [ 0 ] * ( a2 [ i + j - 1 ] [ 1 ] - ( i - 1 ) ) <NEWLINE> <DEDENT> if j > 0 : <NEWLINE> <INDENT> s2 = dp [ i ] [ j - 1 ] + a2 [ i + j - 1 ] [ 0 ] * ( ( n - j ) - a2 [ i + j - 1 ] [ 1 ] ) <NEWLINE> <DEDENT> dp [ i ] [ j ] = max ( s1 , s2 ) <NEWLINE> <DEDENT> ans = max ( ans , dp [ i ] [ n - i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def find_lakes ( diagram ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def calc_areas ( ls ) : <NEWLINE> <INDENT> areas = [ ] <NEWLINE> e1 , e2 = 0 , 0 <NEWLINE> for n , m in reversed ( ls ) : <NEWLINE> <INDENT> if e1 < n and e2 > m : <NEWLINE> <INDENT> area = areas . pop ( ) <NEWLINE> areas . append ( area + ( m - n ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> areas . append ( m - n ) <NEWLINE> e1 , e2 = n , m <NEWLINE> <DEDENT> <DEDENT> return areas [ : : - 1 ] <NEWLINE> <NL> <DEDENT> lakes = [ ] <NEWLINE> slopes = [ ] <NEWLINE> <NL> for i , c in enumerate ( diagram ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> slopes . append ( i ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> if len ( slopes ) > 0 : <NEWLINE> <INDENT> lakes . append ( ( slopes . pop ( ) , i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return calc_areas ( lakes ) <NEWLINE> <NL> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> ls = find_lakes ( input ( ) ) <NEWLINE> <NL> summary = [ str ( len ( ls ) ) ] + [ str ( i ) for i in ls ] <NEWLINE> print ( sum ( ls ) ) <NEWLINE> print ( <STRING> . join ( summary ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
a = input ( ) . split ( ) <NEWLINE> b = int ( a [ 0 ] ) <NEWLINE> c = int ( a [ 1 ] ) <NEWLINE> if c == 0 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> d = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> e = sorted ( d ) <NEWLINE> <NL> <NL> f = int ( e [ 0 ] - 1 ) <NEWLINE> g = int ( e [ - 1 ] + 1 ) <NEWLINE> <NL> <NL> h = int ( g - f ) <NEWLINE> <NL> X = [ ] <NEWLINE> for I in range ( int ( h + 1 ) ) : <NEWLINE> <INDENT> J = int ( f + I ) <NEWLINE> if e . count ( J ) == 0 : <NEWLINE> <INDENT> X . append ( J ) <NEWLINE> <NL> <DEDENT> <DEDENT> Y = len ( X ) <NEWLINE> H = [ ] <NEWLINE> for S in range ( Y ) : <NEWLINE> <INDENT> Q = X [ S ] <NEWLINE> if Q >= b : <NEWLINE> <INDENT> g = Q - b <NEWLINE> H . append ( g ) <NEWLINE> <DEDENT> elif Q <= b : <NEWLINE> <INDENT> g = b - Q <NEWLINE> H . append ( g ) <NEWLINE> <NL> <DEDENT> <DEDENT> P = sorted ( H ) <NEWLINE> F = P [ 0 ] <NEWLINE> O = H . index ( F ) <NEWLINE> <NL> <NL> print ( X [ O ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tm = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> tm [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in tm : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans %= ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> ans = [ i . upper ( ) if <STRING> <= i <= <STRING> else i . lower ( ) if <STRING> <= i <= <STRING> else i for i in s [ : ] ] <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for A in range ( 1 , n ) : <NEWLINE> <INDENT> if n % A == 0 : <NEWLINE> <INDENT> ans += n // A - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += n // A <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> for a in range ( - 118 , 120 ) : <NEWLINE> <INDENT> for b in range ( - 119 , 119 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> k = 100 <NEWLINE> <NL> for r in range ( 0 , 102 ) : <NEWLINE> <INDENT> if ( r not in p ) : <NEWLINE> <INDENT> if ( abs ( x - int ( r ) ) < k ) : <NEWLINE> <INDENT> A = int ( r ) <NEWLINE> k = abs ( x - int ( r ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ( A > x ) : <NEWLINE> <INDENT> if ( 2 * x - A not in p ) : <NEWLINE> <INDENT> A = 2 * x - A <NEWLINE> <NL> <DEDENT> <DEDENT> print ( A ) <NEWLINE> <NL> <NL> <NL>
from collections import deque <NEWLINE> <NL> <NL> def bfs ( rooms , v = 1 ) : <NEWLINE> <INDENT> arrow = [ - 1 ] * len ( rooms ) <NEWLINE> q = deque ( ) <NEWLINE> q . append ( v ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> now = q . popleft ( ) <NEWLINE> for next_v in rooms [ now ] : <NEWLINE> <INDENT> if arrow [ next_v ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . append ( next_v ) <NEWLINE> arrow [ next_v ] = now <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return arrow <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> rooms = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> rooms [ b ] . append ( a ) <NEWLINE> rooms [ a ] . append ( b ) <NEWLINE> <NL> <DEDENT> anss = bfs ( rooms ) <NEWLINE> print ( <STRING> ) <NEWLINE> for ans in anss [ 2 : ] : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = input ( ) . split ( <STRING> ) <NEWLINE> N = eval ( a [ 0 ] ) <NEWLINE> M = eval ( a [ 1 ] ) <NEWLINE> b = input ( ) . split ( <STRING> ) <NEWLINE> hight_lst = list ( map ( eval , b ) ) <NEWLINE> lst = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> lst . append ( 1 ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> c = input ( ) . split ( <STRING> ) <NEWLINE> c1 = eval ( c [ 0 ] ) - 1 <NEWLINE> c2 = eval ( c [ 1 ] ) - 1 <NEWLINE> if hight_lst [ c1 ] > hight_lst [ c2 ] : <NEWLINE> <INDENT> lst [ c2 ] = 0 <NEWLINE> <DEDENT> elif hight_lst [ c1 ] < hight_lst [ c2 ] : <NEWLINE> <INDENT> lst [ c1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst [ c1 ] = 0 <NEWLINE> lst [ c2 ] = 0 <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in lst : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> k = 1000 <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> while i < N - 1 : <NEWLINE> <INDENT> if L [ i ] < L [ i + 1 ] : <NEWLINE> <INDENT> n = L [ i ] <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> if i == N - 1 : <NEWLINE> <INDENT> print ( 1000 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> n = 0 <NEWLINE> for j in range ( i , N ) : <NEWLINE> <INDENT> if j == N - 1 and n != 0 : <NEWLINE> <INDENT> m = max ( L [ s : ] ) <NEWLINE> c = k % n <NEWLINE> k = ( ( k // n ) * m ) + c <NEWLINE> n = 0 <NEWLINE> break <NEWLINE> <DEDENT> if j == N - 1 and n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if L [ j ] < L [ j + 1 ] and n == 0 : <NEWLINE> <INDENT> n = L [ j ] <NEWLINE> s = j <NEWLINE> <DEDENT> if L [ j ] > L [ j + 1 ] and n != 0 : <NEWLINE> <INDENT> m = L [ j ] <NEWLINE> c = k % n <NEWLINE> k = ( ( k // n ) * m ) + c <NEWLINE> n = 0 <NEWLINE> <DEDENT> <DEDENT> print ( k ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> n = <STRING> <NEWLINE> cnt = 1 <NEWLINE> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> if int ( n ) % k != 0 : <NEWLINE> <INDENT> n = int ( n ) % k <NEWLINE> n = str ( n ) + <STRING> <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> count = 0 <NEWLINE> k = int ( input ( ) ) <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b , k + 1 ) : <NEWLINE> <INDENT> d = math . gcd ( a , b ) <NEWLINE> e = math . gcd ( d , c ) <NEWLINE> if a == b == c : <NEWLINE> <INDENT> count += e <NEWLINE> <DEDENT> elif a == b or b == c or c == a : <NEWLINE> <INDENT> count += e * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += e * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> An = [ ] <NEWLINE> mul = 1 <NEWLINE> <NL> An = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if An . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in An : <NEWLINE> <INDENT> mul *= i <NEWLINE> if mul > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if mul <= 10 ** 18 : <NEWLINE> <INDENT> print ( mul ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def solve ( X : int , K : int , D : int ) : <NEWLINE> <INDENT> X = abs ( X ) <NEWLINE> <NL> mostl = X - K * D <NEWLINE> if mostl > 0 : <NEWLINE> <INDENT> print ( mostl ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if K % 2 == 1 : <NEWLINE> <INDENT> X -= D <NEWLINE> ans = min ( abs ( X ) , abs ( X + 2 * D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( X , abs ( X - K * D ) ) <NEWLINE> <NL> <DEDENT> Kh = K // 2 <NEWLINE> <NL> N = X // ( D * 2 ) <NEWLINE> ans = min ( ans , abs ( X - D * 2 * ( N - 1 ) ) ) <NEWLINE> ans = min ( ans , abs ( X - D * 2 * N ) ) <NEWLINE> if N < Kh : <NEWLINE> <INDENT> ans = min ( ans , abs ( X - D * 2 * ( N + 1 ) ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> return <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> X = int ( next ( tokens ) ) <COMMENT> <NEWLINE> K = int ( next ( tokens ) ) <COMMENT> <NEWLINE> D = int ( next ( tokens ) ) <COMMENT> <NEWLINE> solve ( X , K , D ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def printRect ( h , w ) : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> l = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> if l [ 0 ] == 0 and l [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> printRect ( l [ 0 ] , l [ 1 ] ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> root = set ( range ( n ) ) <NEWLINE> nodes = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> node = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> children = node [ 1 : 3 ] <NEWLINE> root -= set ( children ) <NEWLINE> nodes [ node [ 0 ] ] = children <NEWLINE> <NL> <DEDENT> def preorder ( id ) : <NEWLINE> <INDENT> if ( id == - 1 ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> order . append ( id ) <NEWLINE> preorder ( nodes [ id ] [ 0 ] ) <NEWLINE> preorder ( nodes [ id ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> def inorder ( id ) : <NEWLINE> <INDENT> if ( id == - 1 ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> inorder ( nodes [ id ] [ 0 ] ) <NEWLINE> order . append ( id ) <NEWLINE> inorder ( nodes [ id ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> def postorder ( id ) : <NEWLINE> <INDENT> if ( id == - 1 ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> postorder ( nodes [ id ] [ 0 ] ) <NEWLINE> postorder ( nodes [ id ] [ 1 ] ) <NEWLINE> order . append ( id ) <NEWLINE> <NL> <DEDENT> order = [ ] <NEWLINE> preorder ( list ( root ) [ 0 ] ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * order ) <NEWLINE> order = [ ] <NEWLINE> inorder ( list ( root ) [ 0 ] ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * order ) <NEWLINE> order = [ ] <NEWLINE> postorder ( list ( root ) [ 0 ] ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * order ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * N <NEWLINE> next_town = 1 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if b [ next_town - 1 ] != 0 : <NEWLINE> <INDENT> start = next_town <NEWLINE> cycle = i - b [ next_town - 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> break <NEWLINE> <DEDENT> b [ next_town - 1 ] = i <NEWLINE> next_town = A [ next_town - 1 ] <NEWLINE> <NL> <DEDENT> next_town = 1 <NEWLINE> if b [ start - 1 ] >= K : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> next_town = A [ next_town - 1 ] <NEWLINE> <DEDENT> print ( next_town ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> next_town = start <NEWLINE> for i in range ( ( K - b [ start - 1 ] ) % cycle ) : <NEWLINE> <INDENT> next_town = A [ next_town - 1 ] <NEWLINE> <DEDENT> print ( next_town ) <NEWLINE> <DEDENT>
c = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> for i in range ( 2 , int ( x ** .5 + 1 ) ) : <NEWLINE> <INDENT> if x % i == 0 : c += 1 ; break <NEWLINE> <DEDENT> <DEDENT> print ( n - c ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> if n != 1 : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> min = p [ i ] <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if min > p [ j ] : <NEWLINE> <INDENT> min = p [ j ] <NEWLINE> p [ j ] = p [ i ] <NEWLINE> p [ i ] = min <NEWLINE> <DEDENT> <DEDENT> ans += min <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = p [ 0 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a2 = [ 0 ] <NEWLINE> b2 = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a2 . append ( a2 [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b2 . append ( b2 [ i ] + b [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> cnt = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a2 [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sm = 0 <NEWLINE> while b2 [ cnt ] > k - a2 [ i ] : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> ans = max ( cnt + i , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> dp = [ 0 ] * 2010 <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( 3 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( i - 3 + 1 ) : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i ] + dp [ j ] ) % MOD <NEWLINE> <DEDENT> <DEDENT> print ( dp [ N ] ) <NEWLINE>
def ri ( ) : return int ( input ( ) ) <NEWLINE> def rli ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def rls ( ) : return list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> def pl ( a ) : print ( <STRING> . join ( list ( map ( str , a ) ) ) ) <NEWLINE> def ma ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> <STRING> <NEWLINE> <NL> <STRING> <NEWLINE> <NL> <NL> <NL> <STRING> <NEWLINE> <STRING> <NEWLINE> n = ri ( ) <NEWLINE> s = input ( ) <NEWLINE> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans -= s [ k ] != s [ i ] != s [ j ] != s [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import collections <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import copy <NEWLINE> import collections <NEWLINE> <NL> <NL> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> AArry = LI ( ) <NEWLINE> AArry . sort ( ) <NEWLINE> count = 0 <NEWLINE> li = [ 0 for _ in range ( 10 ** 6 + 2 ) ] <NEWLINE> <NL> for i , v in enumerate ( AArry ) : <NEWLINE> <INDENT> a = v <NEWLINE> if li [ a ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if li [ a ] == 0 : <NEWLINE> <INDENT> if i != N - 1 and AArry [ i + 1 ] == a : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> for j in range ( a , 10 ** 6 + 2 , a ) : <NEWLINE> <INDENT> li [ j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( N - count ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> data = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> data [ b - 1 ] += 1 <NEWLINE> if data [ b - 1 ] == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if b == n : <NEWLINE> <INDENT> data [ a - 1 ] += 1 <NEWLINE> if data [ a - 1 ] == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
a , b , c , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if a >= k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a + b >= k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * a + b - k ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( lines [ 0 ] ) <NEWLINE> values = list ( map ( int , lines [ 1 ] . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> result = get_cnt ( values ) <NEWLINE> <NL> return [ result ] <NEWLINE> <NL> <NL> <DEDENT> def get_cnt ( values ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ret = 0 <NEWLINE> mi = min ( values ) <NEWLINE> <COMMENT> <NL> ret += mi <NEWLINE> values = [ value - mi for value in values ] <NEWLINE> <COMMENT> <NL> lst = None <NEWLINE> for value in values : <NEWLINE> <COMMENT> <NL> <INDENT> if value != 0 : <NEWLINE> <INDENT> if lst is None : <NEWLINE> <INDENT> lst = [ value ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst . append ( value ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if lst is None : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret += get_cnt ( lst ) <NEWLINE> lst = None <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if lst is not None : <NEWLINE> <INDENT> ret += get_cnt ( lst ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def func_f ( n ) : <NEWLINE> <INDENT> if n % 2 == 0 : <NEWLINE> <INDENT> return int ( n / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 3 * n + 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> ] <NEWLINE> lines_export = [ 2 ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> ] <NEWLINE> lines_export = [ 5 ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> ] <NEWLINE> lines_export = [ 221 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> <NL> def f ( p , q , a , n ) : <NEWLINE> <INDENT> r = 0 <NEWLINE> fr = fractions . Fraction ( p , q ) <NEWLINE> q = [ ( fr , 0 , 1 ) ] <NEWLINE> if fr . numerator == 1 and fr . denominator <= a : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> n1 = n - 1 <NEWLINE> for i in range ( 1 , 70 ) : <NEWLINE> <INDENT> nq = [ ] <NEWLINE> ti = fractions . Fraction ( 1 , i ) <NEWLINE> i2 = ( i + 1 ) ** 2 <NEWLINE> for t , c , m in q : <NEWLINE> <INDENT> mik = m <NEWLINE> tt = t <NEWLINE> for k in range ( 1 , n - c ) : <NEWLINE> <INDENT> mik *= i <NEWLINE> tt -= ti <NEWLINE> if tt <= 0 or a < mik * i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if tt . numerator == 1 and tt . denominator >= i and mik * tt . denominator <= a : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> if c + k < n1 and mik * ( i ** max ( math . ceil ( tt / ti ) , 2 ) ) < a : <NEWLINE> <INDENT> nq . append ( ( tt , c + k , mik ) ) <NEWLINE> <DEDENT> <DEDENT> if m * ( i ** max ( math . ceil ( t / ti ) , 2 ) ) < a : <NEWLINE> <INDENT> nq . append ( ( t , c , m ) ) <NEWLINE> <DEDENT> <DEDENT> if not nq : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> q = nq <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> p , q , a , n = LI ( ) <NEWLINE> if p == 0 and q == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rr . append ( f ( p , q , a , n ) ) <NEWLINE> <NL> <DEDENT> return <STRING> . join ( map ( str , rr ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> cnt = 1 <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in l : <NEWLINE> <INDENT> cnt *= i <NEWLINE> if cnt > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> position = 1 <NEWLINE> flag = True <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if position == 2 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> position = a [ position - 1 ] <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> <NL> def digit ( N ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> while N >= 1 : <NEWLINE> <INDENT> N /= 10 <NEWLINE> d += 1 <NEWLINE> <DEDENT> return d <NEWLINE> <NL> <NL> <DEDENT> f = [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= N : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> d1 = digit ( i ) <NEWLINE> d2 = digit ( int ( N / i ) ) <NEWLINE> f . append ( max ( d1 , d2 ) ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( min ( f ) ) <NEWLINE>
import queue <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> puted = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> ab = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab [ a ] . append ( b ) <NEWLINE> ab [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> q = queue . Queue ( ) <NEWLINE> flg = [ - 1 ] * n <NEWLINE> flg [ 0 ] = 0 <NEWLINE> q . put ( 1 ) <NEWLINE> <NL> while not q . empty ( ) : <NEWLINE> <INDENT> item = q . get ( ) <NEWLINE> for i in ab [ item ] : <NEWLINE> <INDENT> if puted [ i ] == 0 : <NEWLINE> <INDENT> flg [ i - 1 ] = item <NEWLINE> q . put ( i ) <NEWLINE> puted [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if - 1 in flg : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , len ( flg ) ) : <NEWLINE> <INDENT> print ( flg [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> data = sorted ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> if data [ 2 ] ** 2 == data [ 1 ] ** 2 + data [ 0 ] ** 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> import queue <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> vum = defaultdict ( list ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> vum [ a ] . append ( b ) <NEWLINE> vum [ b ] . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> q = queue . Queue ( ) <NEWLINE> F = [ - 1 ] * N <COMMENT> <NEWLINE> s = 1 <COMMENT> <NEWLINE> step = 0 <NEWLINE> while True : <NEWLINE> <COMMENT> <NL> <INDENT> for v in vum [ s ] : <NEWLINE> <COMMENT> <NL> <INDENT> if F [ v - 1 ] < 0 : <NEWLINE> <INDENT> q . put ( v ) <NEWLINE> F [ v - 1 ] = s <NEWLINE> <DEDENT> <DEDENT> if q . empty ( ) : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> s = q . get ( ) <NEWLINE> <NL> <DEDENT> if - 1 in F [ 1 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for d in F [ 1 : ] : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( lambda x : x * ( - 1 ) , A ) ) <NEWLINE> <NL> heapq . heapify ( A ) <NEWLINE> <NL> ans = 0 <NEWLINE> N -= 2 <NEWLINE> ans += heapq . heappop ( A ) * ( - 1 ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif N == 1 : <NEWLINE> <INDENT> ans += A [ 0 ] <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif N >= 2 : <NEWLINE> <INDENT> q = N // 2 <NEWLINE> r = N % 2 <NEWLINE> for i in range ( 1 , q + 1 ) : <NEWLINE> <INDENT> ans += 2 * heapq . heappop ( A ) * ( - 1 ) <NEWLINE> <DEDENT> if r == 1 : <NEWLINE> <INDENT> ans += heapq . heappop ( A ) * ( - 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N , K , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . n = n <NEWLINE> <COMMENT> <NL> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find_root ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find_root ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union_merge ( self , x , y ) : <NEWLINE> <INDENT> x = self . find_root ( x ) <NEWLINE> y = self . find_root ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def union_size ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> return - self . parents [ self . find_root ( x ) ] <NEWLINE> <NL> <DEDENT> def is_same_union ( self , x , y ) : <NEWLINE> <INDENT> return self . find_root ( x ) == self . find_root ( y ) <NEWLINE> <NL> <DEDENT> def same_union_members ( self , x ) : <NEWLINE> <INDENT> root = self . find_root ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find_root ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def union_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_unions ( self ) : <NEWLINE> <INDENT> return [ self . same_union_members ( r ) for r in self . roots ( ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> road = UnionFind ( N ) <NEWLINE> rail = UnionFind ( N ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> p , k = map ( int , input ( ) . split ( ) ) <NEWLINE> road . union_merge ( p - 1 , k - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( L ) : <NEWLINE> <INDENT> r , s = map ( int , input ( ) . split ( ) ) <NEWLINE> rail . union_merge ( r - 1 , s - 1 ) <NEWLINE> <NL> <DEDENT> root_combinations = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> root_combinations . append ( ( road . find_root ( i ) , rail . find_root ( i ) ) ) <NEWLINE> <NL> <DEDENT> from collections import Counter <NEWLINE> same_combinations = Counter ( root_combinations ) <NEWLINE> result = [ same_combinations [ root_combination ] for root_combination in root_combinations ] <NEWLINE> <NL> ans = <STRING> . join ( map ( str , result ) ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> Graph = [ [ ] for _ in range ( N + 10 ) ] <NEWLINE> dist = [ 10000000000000 ] * ( N + 10 ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> Graph [ u ] . append ( ( v , w ) ) <NEWLINE> Graph [ v ] . append ( ( u , w ) ) <NEWLINE> <NL> <DEDENT> dist [ 0 ] = 0 <NEWLINE> <NL> def func ( fromE , now , length ) : <NEWLINE> <INDENT> if fromE != - 1 : <NEWLINE> <INDENT> dist [ now ] = dist [ fromE ] + length <NEWLINE> <DEDENT> for i in range ( len ( Graph [ now ] ) ) : <NEWLINE> <INDENT> target = Graph [ now ] [ i ] [ 0 ] <NEWLINE> lengt = Graph [ now ] [ i ] [ 1 ] <NEWLINE> <NL> if target == fromE : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> func ( now , target , lengt ) <NEWLINE> <NL> <DEDENT> <DEDENT> func ( - 1 , 0 , 0 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if dist [ i ] % 2 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mid = 0 <NEWLINE> diff = float ( <STRING> ) <NEWLINE> total = sum ( A ) <NEWLINE> p = 0 <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if abs ( total - p ) < diff : <NEWLINE> <INDENT> diff = abs ( total - p ) <NEWLINE> mid = i <NEWLINE> <DEDENT> p += A [ i ] <NEWLINE> total -= A [ i ] <NEWLINE> <DEDENT> front = A [ : mid ] <NEWLINE> back = A [ mid : ] <NEWLINE> print ( abs ( sum ( front ) - sum ( back ) ) ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
r = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> . format ( ( ( r [ 2 ] - r [ 0 ] ) ** 2 + ( r [ 3 ] - r [ 1 ] ) ** 2 ) ** 0.5 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( each ) for each in input ( ) . split ( ) ] <NEWLINE> <NL> result = 0 <NEWLINE> s = sum ( a ) <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> s = ( s - a [ i ] ) <NEWLINE> result += s % 1000000007 * a [ i ] <NEWLINE> <DEDENT> print ( result % 1000000007 ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> <NL> def main ( n ) : <NEWLINE> <INDENT> global l <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> tmp = i * ( i + 1 ) // 2 <NEWLINE> if tmp >= n : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> if n - i == 0 : <NEWLINE> <INDENT> return l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return main ( n - i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> sys . setrecursionlimit ( 10000 ) <NEWLINE> li = main ( N ) <NEWLINE> for n in li : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> x = [ 0 ] * 100001 <NEWLINE> ans = sum ( a ) <NEWLINE> <NL> for ai in a : <NEWLINE> <INDENT> x [ ai ] += 1 <COMMENT> <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += ( c - b ) * x [ b ] <NEWLINE> x [ c ] += x [ b ] <COMMENT> <NEWLINE> x [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> order = input ( ) . split ( ) <NEWLINE> if order [ 0 ] == <STRING> : <NEWLINE> <INDENT> d [ order [ 1 ] ] = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if order [ 1 ] in d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> import heapq <NEWLINE> heapq . heapify ( A ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a = heapq . heappop ( A ) <NEWLINE> a /= 2 <NEWLINE> heapq . heappush ( A , a ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans += int ( ( - 1 ) * a ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = [ int ( input ( ) ) for _ in range ( int ( input ( ) ) ) ] <NEWLINE> <NL> if sum ( s ) % 10 != 0 : <NEWLINE> <INDENT> print ( sum ( s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . sort ( ) <NEWLINE> for i , x in enumerate ( s ) : <NEWLINE> <INDENT> if x % 10 != 0 : <NEWLINE> <INDENT> print ( sum ( s ) - x ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l_list = [ 2 , 1 ] <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> a = l_list [ i - 1 ] + l_list [ i - 2 ] <NEWLINE> l_list . append ( a ) <NEWLINE> <DEDENT> print ( l_list [ N ] ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> r = math . ceil ( x ** 0.2 ) <NEWLINE> <COMMENT> <NL> def reverse_num ( x ) : <NEWLINE> <INDENT> return r - x <NEWLINE> <DEDENT> def calc_b ( aa ) : <NEWLINE> <INDENT> bb = aa - x <NEWLINE> bbb = abs ( bb ) ** 0.2 <NEWLINE> if bb < 0 : <NEWLINE> <INDENT> b = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> return b * int ( bbb . real + bbb . imag ) <NEWLINE> <DEDENT> def check ( a ) : <NEWLINE> <INDENT> aa = a ** 5 <NEWLINE> b = calc_b ( aa ) <NEWLINE> <COMMENT> <NL> if aa - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> for a in range ( r // 2 + 1 ) : <NEWLINE> <INDENT> if check ( a ) or check ( reverse_num ( a ) ) : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> a = r + 1 <NEWLINE> while True : <NEWLINE> <INDENT> if check ( a ) : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <DEDENT> a += 1 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> m = 10 ** 9 + 7 <NEWLINE> def main ( ) : <NEWLINE> <INDENT> s = sum ( a ) <NEWLINE> ss = 0 <NEWLINE> r = 0 <NEWLINE> for nn in range ( n ) : <NEWLINE> <INDENT> ss += a [ nn ] <NEWLINE> r += a [ nn ] * ( s - ss ) <NEWLINE> <DEDENT> print ( r % m ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <COMMENT> <NL> <NL> counter = [ 0 ] * 2019 <NEWLINE> counter [ 0 ] = 1 <COMMENT> <NEWLINE> <NL> S = input ( ) <NEWLINE> tmp = 0 <NEWLINE> <STRING> <NEWLINE> MOD = 2019 <NEWLINE> <COMMENT> <NL> t = 1 <NEWLINE> for i in range ( 1 , len ( S ) + 1 ) : <NEWLINE> <INDENT> tmp += int ( S [ - i ] ) * t <NEWLINE> <COMMENT> <NL> tmp %= MOD <NEWLINE> t *= 10 <NEWLINE> <COMMENT> <NL> t %= MOD <NEWLINE> <COMMENT> <NL> counter [ tmp ] += 1 <NEWLINE> <NL> <DEDENT> print ( sum ( i * ( i - 1 ) // 2 for i in counter ) ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def popcount ( n ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> while n : <NEWLINE> <INDENT> if n & 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> n >>= 1 <NEWLINE> <NL> <DEDENT> return c <NEWLINE> <NL> <NL> <DEDENT> def f ( n , c = 0 ) : <NEWLINE> <INDENT> while pc : = popcount ( n ) : <NEWLINE> <INDENT> n %= pc <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> return c <NEWLINE> <NL> <NL> <DEDENT> def _resolve ( n , x_bytes ) : <NEWLINE> <INDENT> one_i = <STRING> [ 0 ] <NEWLINE> pc_x = x_bytes . count ( <STRING> ) <NEWLINE> <NL> i2_mod_pc_x_p1 = [ 0 ] * n <NEWLINE> i2_mod_pc_x_m1 = [ 0 ] * n <NEWLINE> x_mod_pc_x_p1 = 0 <NEWLINE> x_mod_pc_x_m1 = 0 <NEWLINE> <NL> i2 = 1 <NEWLINE> x = 0 <NEWLINE> mod = pc_x + 1 <NEWLINE> for a in range ( n ) : <NEWLINE> <INDENT> i2_mod_pc_x_p1 [ - 1 - a ] = i2 <NEWLINE> i2 *= 2 <NEWLINE> i2 %= mod <NEWLINE> <NL> x *= 2 <NEWLINE> x %= mod <NEWLINE> if ( x_bytes [ a ] == one_i ) : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> x_mod_pc_x_p1 = x % mod <NEWLINE> <NL> if pc_x > 1 : <NEWLINE> <INDENT> i2 = 1 <NEWLINE> x = 0 <NEWLINE> mod = pc_x - 1 <NEWLINE> for a in range ( n ) : <NEWLINE> <INDENT> i2_mod_pc_x_m1 [ - 1 - a ] = i2 <NEWLINE> i2 *= 2 <NEWLINE> i2 %= mod <NEWLINE> <NL> x *= 2 <NEWLINE> x %= mod <NEWLINE> if ( x_bytes [ a ] == one_i ) : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> x_mod_pc_x_m1 = x % mod <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> for a in range ( n ) : <NEWLINE> <INDENT> if x_bytes [ a ] == one_i : <NEWLINE> <INDENT> mod = pc_x - 1 <NEWLINE> if mod == 0 : <NEWLINE> <INDENT> yield 0 <NEWLINE> continue <NEWLINE> <DEDENT> b = x_mod_pc_x_m1 - i2_mod_pc_x_m1 [ a ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mod = pc_x + 1 <NEWLINE> b = x_mod_pc_x_p1 + i2_mod_pc_x_p1 [ a ] <NEWLINE> <DEDENT> b %= mod <NEWLINE> <NL> yield f ( b , 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def resolve ( in_ , out ) : <NEWLINE> <INDENT> n = int ( in_ . readline ( ) ) <NEWLINE> x_bytes = in_ . readline ( ) <NEWLINE> for ret in _resolve ( n , x_bytes ) : <NEWLINE> <INDENT> print ( ret , file = out ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> resolve ( sys . stdin . buffer , sys . stdout ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> def func ( n ) : <NEWLINE> <INDENT> rest = { i ** 2 % n for i in range ( 1 , n ) } <NEWLINE> <NL> count = [ 0 ] * n <NEWLINE> for x , y in itertools . combinations ( rest , 2 ) : <NEWLINE> <INDENT> count [ x - y ] += 2 <NEWLINE> <NL> <DEDENT> for i in range ( n // 2 ) : <NEWLINE> <INDENT> print ( count [ i + 1 ] + count [ n - i - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> func ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> if a [ i - 1 ] > a [ i ] : <NEWLINE> <INDENT> sum += a [ i - 1 ] - a [ i ] <NEWLINE> a [ i ] = a [ i - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import sys <NEWLINE> input ( ) <NEWLINE> mx = - float ( <STRING> ) <NEWLINE> res = mx <NEWLINE> mn = int ( input ( ) ) <NEWLINE> for i in map ( int , sys . stdin . readlines ( ) ) : <NEWLINE> <INDENT> if mx < i - mn : <NEWLINE> <INDENT> mx = i - mn <NEWLINE> <DEDENT> if 0 > i - mn : <NEWLINE> <INDENT> mn = i <NEWLINE> <DEDENT> res = max ( mx , res ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> dp = [ True ] * a [ - 1 ] <NEWLINE> def hantei ( i ) : <NEWLINE> <INDENT> ans = True <NEWLINE> if i != n - 1 : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] : ans = False <NEWLINE> <DEDENT> if i != 0 : <NEWLINE> <INDENT> if a [ i ] == a [ i - 1 ] : ans = False <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> for val in set ( a ) : <NEWLINE> <INDENT> for i in range ( 2 * val , a [ - 1 ] + 1 , val ) : dp [ i - 1 ] = False <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if dp [ a [ i ] - 1 ] and hantei ( i ) == 1 : ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> S = list ( input ( ) . rstrip ( <STRING> ) ) <NEWLINE> <NL> kake10 = [ 0 , 10 , 7 , 4 , 1 , 11 , 8 , 5 , 2 , 12 , 9 , 6 , 3 ] <NEWLINE> now = { 0 : 1 , 1 : 0 , 2 : 0 , 3 : 0 , 4 : 0 , 5 : 0 , 6 : 0 , 7 : 0 , 8 : 0 , 9 : 0 , 10 : 0 , 11 : 0 , 12 : 0 } <NEWLINE> for i in S : <NEWLINE> <INDENT> now = { kake10 [ x ] : now [ x ] for x in range ( 13 ) } <NEWLINE> if i == <STRING> : <NEWLINE> <INDENT> now2 = { x : sum ( now [ ( x + y ) % 13 ] for y in range ( 4 , 14 ) ) % 1000000007 for x in range ( 13 ) } <NEWLINE> now = now2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( i ) <NEWLINE> now = { ( x + a ) % 13 : now [ x ] for x in range ( 13 ) } <NEWLINE> <DEDENT> <DEDENT> print ( now [ 5 ] ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> ans = math . factorial ( N ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> print ( ans % mod ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> fumidai_list , A_after = [ ] , 0 <NEWLINE> <NL> for count_a in range ( len ( A ) ) : <NEWLINE> <INDENT> fumidai = 0 <NEWLINE> <NL> if ( A [ count_a ] >= A_after ) : <NEWLINE> <INDENT> A_after = A [ count_a ] <NEWLINE> fumidai_list . append ( fumidai ) <NEWLINE> <NL> <DEDENT> elif ( A [ count_a ] < A_after ) : <NEWLINE> <INDENT> fumidai = A_after - A [ count_a ] <NEWLINE> fumidai_list . append ( fumidai ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( fumidai_list ) ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> num = 0 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> num += math . gcd ( tmp , k ) <NEWLINE> tmp == 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> print ( <STRING> ) if num % 9 == 0 else print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> def calc ( x , y ) : <NEWLINE> <INDENT> a = fac [ x ] <NEWLINE> b = fac [ y ] <NEWLINE> c = fac [ x - y ] <NEWLINE> ret = ( ( a % p ) * pow ( b , p - 2 , p ) * pow ( c , p - 2 , p ) ) % p <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> <NL> fac = [ 1 ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> fac . append ( ( fac [ - 1 ] * i ) % p ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i <= N - K : <NEWLINE> <INDENT> nokori = N - 1 - i <NEWLINE> kumi = calc ( nokori , K - 1 ) <NEWLINE> ans -= ( A [ i ] * kumi ) % p <NEWLINE> <DEDENT> if i >= K - 1 : <NEWLINE> <INDENT> nokori = i <NEWLINE> kumi = calc ( nokori , K - 1 ) <NEWLINE> ans += ( A [ i ] * kumi ) % p <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans % p ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> x [ i - 1 ] += 1 <NEWLINE> <DEDENT> for _ in x : <NEWLINE> <INDENT> print ( _ ) <NEWLINE> <DEDENT>
import sys , math <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 2 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if not lst [ i ] : <NEWLINE> <INDENT> for j in range ( i , 10 ** 6 + 1 , i ) : <NEWLINE> <INDENT> lst [ j ] = i <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> GCD = A_lst [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> GCD = math . gcd ( GCD , A_lst [ i ] ) <NEWLINE> <NL> <DEDENT> if GCD != 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> post = 1 <NEWLINE> visited = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = A_lst [ i ] <NEWLINE> while a > 1 : <NEWLINE> <INDENT> dv = lst [ a ] <NEWLINE> if visited [ dv ] : <NEWLINE> <INDENT> post = 0 <NEWLINE> break <NEWLINE> <DEDENT> while a % dv == 0 : <NEWLINE> <INDENT> a //= dv <NEWLINE> <DEDENT> visited [ dv ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if post : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> m *= a <NEWLINE> if m > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= l [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> for j in range ( K ) : <NEWLINE> <INDENT> S . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> m = 998244353 <NEWLINE> <NL> <COMMENT> <NL> <NL> dp = [ 0 ] * N <NEWLINE> dp [ 0 ] = 1 <NEWLINE> sum_of_region = [ 0 ] * K <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> if i - S [ j ] [ 0 ] >= 0 : <NEWLINE> <INDENT> sum_of_region [ j ] += dp [ i - S [ j ] [ 0 ] ] <NEWLINE> <DEDENT> if i - S [ j ] [ 1 ] - 1 >= 0 : <NEWLINE> <INDENT> sum_of_region [ j ] -= dp [ i - S [ j ] [ 1 ] - 1 ] <NEWLINE> <DEDENT> dp [ i ] += sum_of_region [ j ] % m <NEWLINE> dp [ i ] %= m <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> ans = dp [ N - 1 ] <NEWLINE> print ( ans ) <NEWLINE>
<NL> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> <NL> L = A [ left : mid ] + [ float ( <STRING> ) ] <NEWLINE> R = A [ mid : right ] + [ float ( <STRING> ) ] <NEWLINE> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> <NL> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return right - left <NEWLINE> <NL> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> cnt1 = mergeSort ( A , left , mid ) <NEWLINE> cnt2 = mergeSort ( A , mid , right ) <NEWLINE> cnt3 = merge ( A , left , mid , right ) <NEWLINE> return cnt1 + cnt2 + cnt3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> S = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> <NL> ans = mergeSort ( S , 0 , n ) <NEWLINE> <NL> print ( * S ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = [ p for p in map ( int , input ( ) . split ( ) ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> min_p = P [ 0 ] <NEWLINE> <NL> for p in P : <NEWLINE> <INDENT> if min_p >= p : <NEWLINE> <INDENT> min_p = p <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> r [ i - a [ i ] ] += 1 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> r [ i - a [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> r [ i - a [ i ] ] -= 1 <NEWLINE> try : <NEWLINE> <INDENT> cnt += r [ i + a [ i ] ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> money = 0 <NEWLINE> if int ( n ) % 1000 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif 1000 > int ( n ) : <NEWLINE> <INDENT> ans = 1000 - int ( n ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> money = ( int ( n [ : - 3 ] ) + 1 ) * 1000 <NEWLINE> ans = money - int ( n ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> a = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> C = S [ i : i + len ( T ) ] <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if C [ j ] == T [ j ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> a . append ( ans ) <NEWLINE> ans = 0 <NEWLINE> <DEDENT> print ( len ( T ) - max ( a ) ) <NEWLINE>
from math import sqrt <NEWLINE> I_list = [ ] <NEWLINE> prime_list = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> I_list . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> I_max = max ( I_list ) <NEWLINE> search_set = { x for x in range ( 2 , I_max + 1 ) } <NEWLINE> <NL> <NL> p = - 1 <NEWLINE> while p <= sqrt ( I_max ) : <NEWLINE> <INDENT> p = min ( search_set ) <NEWLINE> prime_list . append ( p ) <NEWLINE> search_set = { x for x in search_set if x % p != 0 } <NEWLINE> <NL> <DEDENT> search_list = sorted ( list ( search_set ) ) <NEWLINE> prime_list += search_list <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> for i in I_list : <NEWLINE> <INDENT> lower_set = { j for j in prime_list if j <= i } <NEWLINE> <COMMENT> <NL> print ( len ( lower_set ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> S = [ <STRING> . join ( sorted ( input ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> table = { } <NEWLINE> <NL> ans = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s in table : <NEWLINE> <INDENT> table [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> table [ s ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for k in table : <NEWLINE> <INDENT> ans += table [ k ] * ( table [ k ] - 1 ) <NEWLINE> <NL> <DEDENT> ans //= 2 <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> a = float ( input ( ) ) <NEWLINE> d = a * a * math . pi <NEWLINE> r = 2 * a * math . pi <NEWLINE> print ( <STRING> . format ( d , r ) ) <NEWLINE>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> lsx = [ 0 ] + [ 0 ] * H <NEWLINE> lsy = [ 0 ] + [ 0 ] * W <NEWLINE> lsxy = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> lsx [ x ] += 1 <NEWLINE> lsy [ y ] += 1 <NEWLINE> lsxy . append ( [ x , y ] ) <NEWLINE> <DEDENT> maxx = max ( lsx ) <NEWLINE> maxy = max ( lsy ) <NEWLINE> cx = lsx . count ( maxx ) <NEWLINE> cy = lsy . count ( maxy ) <NEWLINE> al = cx * cy <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if lsx [ lsxy [ i ] [ 0 ] ] == maxx and lsy [ lsxy [ i ] [ 1 ] ] == maxy : <NEWLINE> <INDENT> al -= 1 <NEWLINE> <DEDENT> <DEDENT> if al == 0 : <NEWLINE> <INDENT> factor = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> factor = 0 <NEWLINE> <DEDENT> print ( maxx + maxy - factor ) <NEWLINE>
import math <NEWLINE> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> c = 0 <NEWLINE> <NL> if n >= b : <NEWLINE> <INDENT> c = b - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = n <NEWLINE> <NL> <DEDENT> ans = math . floor ( c * a / b ) - a * ( math . floor ( c / b ) ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = set ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S . add ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( S ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> Q = [ ] <NEWLINE> ans = [ ] <NEWLINE> f = 0 <NEWLINE> def dfs ( f , a , b , c ) : <NEWLINE> <INDENT> if f == N : return True <NEWLINE> if Q [ f ] == <STRING> : <NEWLINE> <INDENT> if a + b == 0 : return False <NEWLINE> if b > 0 and dfs ( f + 1 , a + 1 , b - 1 , c ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> if a > 0 and dfs ( f + 1 , a - 1 , b + 1 , c ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <NL> <DEDENT> return False <NEWLINE> <DEDENT> if Q [ f ] == <STRING> : <NEWLINE> <INDENT> if c + b == 0 : return False <NEWLINE> if c > 0 and dfs ( f + 1 , a , b + 1 , c - 1 ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> if b > 0 and dfs ( f + 1 , a , b - 1 , c + 1 ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <NL> <DEDENT> return False <NEWLINE> <DEDENT> if Q [ f ] == <STRING> : <NEWLINE> <INDENT> if a + c == 0 : return False <NEWLINE> if c > 0 and dfs ( f + 1 , a + 1 , b , c - 1 ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> if a > 0 and dfs ( f + 1 , a - 1 , b , c + 1 ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <NL> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> Q . append ( s ) <NEWLINE> <DEDENT> dfs ( 0 , A , B , C ) <NEWLINE> <COMMENT> <NL> if len ( ans ) == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> ans = ans [ : : - 1 ] <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == n - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if 2 * ( n - m - 1 ) > n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> e = [ [ ] for i in range ( n ) ] <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> e [ x ] . append ( y ) <NEWLINE> e [ y ] . append ( x ) <NEWLINE> <NL> <DEDENT> def dfs ( x ) : <NEWLINE> <INDENT> l = [ ] <NEWLINE> d [ x ] = 1 <NEWLINE> l . append ( a [ x ] ) <NEWLINE> q = deque ( [ ] ) <NEWLINE> q . append ( x ) <NEWLINE> while q : <NEWLINE> <INDENT> now = q . pop ( ) <NEWLINE> for nex in e [ now ] : <NEWLINE> <INDENT> if d [ nex ] > 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> l . append ( a [ nex ] ) <NEWLINE> d [ nex ] = 1 <NEWLINE> q . append ( nex ) <NEWLINE> <DEDENT> <DEDENT> l . sort ( ) <NEWLINE> ans = l [ 0 ] <NEWLINE> <NL> for i in l [ 1 : ] : <NEWLINE> <INDENT> h . append ( i ) <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> count = 2 * ( n - m - 1 ) <NEWLINE> d = [ - 1 ] * n <NEWLINE> ans = 0 <NEWLINE> h = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if d [ i ] < 0 : <NEWLINE> <INDENT> ans += dfs ( i ) <NEWLINE> count -= 1 <NEWLINE> <DEDENT> <DEDENT> if count > 0 : <NEWLINE> <INDENT> h . sort ( ) <NEWLINE> ans += sum ( h [ : count ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . strip ( ) ) ) <NEWLINE> <NL> count_j = X . count ( 1 ) <NEWLINE> <NL> def calc_table ( m ) : <NEWLINE> <INDENT> if m == 1 : <NEWLINE> <INDENT> return [ 0 ] * N <NEWLINE> <DEDENT> elif m == 0 : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> table = [ ] <NEWLINE> x = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> table . append ( x ) <NEWLINE> x = ( x * 2 ) % m <NEWLINE> <DEDENT> table . reverse ( ) <NEWLINE> return table <NEWLINE> <NL> <DEDENT> count_m = count_j - 1 <NEWLINE> count_p = count_j + 1 <NEWLINE> <NL> mod_m = calc_table ( count_m ) <NEWLINE> mod_j = calc_table ( count_j ) <NEWLINE> mod_p = calc_table ( count_p ) <NEWLINE> <NL> original_j = 0 <NEWLINE> original_m = 0 <NEWLINE> original_p = 0 <NEWLINE> if count_m > 0 : <NEWLINE> <INDENT> for i , b in enumerate ( X ) : <NEWLINE> <INDENT> if b == 1 : <NEWLINE> <INDENT> original_j = ( original_j + mod_j [ i ] ) % count_j <NEWLINE> original_m = ( original_m + mod_m [ i ] ) % count_m <NEWLINE> original_p = ( original_p + mod_p [ i ] ) % count_p <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i , b in enumerate ( X ) : <NEWLINE> <INDENT> if b == 1 : <NEWLINE> <INDENT> original_j = ( original_j + mod_j [ i ] ) % count_j <NEWLINE> original_p = ( original_p + mod_p [ i ] ) % count_p <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> f_cache = [ None ] * N <NEWLINE> def calc_f ( x ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> f = f_cache [ x ] <NEWLINE> if f != None : <NEWLINE> <INDENT> return f <NEWLINE> <DEDENT> count = 0 <NEWLINE> i = x <NEWLINE> while i > 0 : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> i //= 2 <NEWLINE> <DEDENT> f = calc_f ( x % count ) + 1 <NEWLINE> f_cache [ x ] = f <NEWLINE> return f <NEWLINE> <NL> <DEDENT> for i , b in enumerate ( X ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> x = ( original_p + mod_p [ i ] ) % count_p <NEWLINE> print ( calc_f ( x ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if count_m > 0 : <NEWLINE> <INDENT> x = ( original_m - mod_m [ i ] ) % count_m <NEWLINE> print ( calc_f ( x ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from functools import reduce <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> def modcumprod ( * args ) : <NEWLINE> <INDENT> return reduce ( lambda x , y : x * y % mod , args ) <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n == k : <NEWLINE> <INDENT> print ( modcumprod ( * a ) ) <NEWLINE> <DEDENT> elif max ( a ) < 0 and k % 2 == 1 : <NEWLINE> <INDENT> a . sort ( reverse = True ) <NEWLINE> print ( modcumprod ( * a [ : k ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . sort ( key = abs , reverse = True ) <NEWLINE> res = 1 <NEWLINE> cnt_neg = 0 <NEWLINE> pos1 = neg1 = 0 <NEWLINE> for e in a [ : k ] : <NEWLINE> <INDENT> res *= e <NEWLINE> res %= mod <NEWLINE> if e > 0 : <NEWLINE> <INDENT> pos1 = e <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt_neg += 1 <NEWLINE> neg1 = e <NEWLINE> <NL> <DEDENT> <DEDENT> if res == 0 or cnt_neg % 2 == 0 : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pos2 = neg2 = 0 <NEWLINE> for e in a [ k : ] : <NEWLINE> <INDENT> if e > 0 and not pos2 : <NEWLINE> <INDENT> pos2 = e <NEWLINE> <DEDENT> elif e < 0 and not neg2 : <NEWLINE> <INDENT> neg2 = e <NEWLINE> <DEDENT> if pos2 and neg2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if abs ( pos1 * pos2 ) < abs ( neg1 * neg2 ) and pos1 : <NEWLINE> <INDENT> res *= pow ( pos1 , - 1 , mod ) <NEWLINE> res *= neg2 <NEWLINE> res %= mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res *= pow ( neg1 , - 1 , mod ) <NEWLINE> res *= pos2 <NEWLINE> res %= mod <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <DEDENT> <DEDENT>
<NL> import cmath <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> import random <NEWLINE> from collections import defaultdict <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> PI = cmath . pi <NEWLINE> TAU = cmath . pi * 2 <NEWLINE> EPS = 1e-10 <NEWLINE> <NL> <NL> class Point : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> <COMMENT> <NL> CCW_COUNTER_CLOCKWISE = 1 <NEWLINE> <COMMENT> <NL> CCW_CLOCKWISE = - 1 <NEWLINE> <COMMENT> <NL> CCW_ONLINE_BACK = 2 <NEWLINE> <COMMENT> <NL> CCW_ONLINE_FRONT = - 2 <NEWLINE> <COMMENT> <NL> CCW_ON_SEGMENT = 0 <NEWLINE> <NL> def __init__ ( self , x : float , y : float ) : <NEWLINE> <INDENT> self . c = complex ( x , y ) <NEWLINE> <NL> <DEDENT> @ property <NEWLINE> def x ( self ) : <NEWLINE> <INDENT> return self . c . real <NEWLINE> <NL> <DEDENT> @ property <NEWLINE> def y ( self ) : <NEWLINE> <INDENT> return self . c . imag <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def from_complex ( c : complex ) : <NEWLINE> <INDENT> return Point ( c . real , c . imag ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def from_polar ( r : float , phi : float ) : <NEWLINE> <INDENT> c = cmath . rect ( r , phi ) <NEWLINE> return Point ( c . real , c . imag ) <NEWLINE> <NL> <DEDENT> def __add__ ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> c = self . c + p . c <NEWLINE> return Point ( c . real , c . imag ) <NEWLINE> <NL> <DEDENT> def __iadd__ ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . c += p . c <NEWLINE> return self <NEWLINE> <NL> <DEDENT> def __sub__ ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> c = self . c - p . c <NEWLINE> return Point ( c . real , c . imag ) <NEWLINE> <NL> <DEDENT> def __isub__ ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . c -= p . c <NEWLINE> return self <NEWLINE> <NL> <DEDENT> def __mul__ ( self , f : float ) : <NEWLINE> <INDENT> c = self . c * f <NEWLINE> return Point ( c . real , c . imag ) <NEWLINE> <NL> <DEDENT> def __imul__ ( self , f : float ) : <NEWLINE> <INDENT> self . c *= f <NEWLINE> return self <NEWLINE> <NL> <DEDENT> def __truediv__ ( self , f : float ) : <NEWLINE> <INDENT> c = self . c / f <NEWLINE> return Point ( c . real , c . imag ) <NEWLINE> <NL> <DEDENT> def __itruediv__ ( self , f : float ) : <NEWLINE> <INDENT> self . c /= f <NEWLINE> return self <NEWLINE> <NL> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> return <STRING> . format ( round ( self . x , 10 ) , round ( self . y , 10 ) ) <NEWLINE> <NL> <DEDENT> def __neg__ ( self ) : <NEWLINE> <INDENT> c = - self . c <NEWLINE> return Point ( c . real , c . imag ) <NEWLINE> <NL> <DEDENT> def __eq__ ( self , p ) : <NEWLINE> <INDENT> return abs ( self . c - p . c ) < EPS <NEWLINE> <NL> <DEDENT> def __abs__ ( self ) : <NEWLINE> <INDENT> return abs ( self . c ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def ccw ( a , b , c ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> b = b - a <NEWLINE> c = c - a <NEWLINE> det = b . det ( c ) <NEWLINE> if det > EPS : <NEWLINE> <INDENT> return Point . CCW_COUNTER_CLOCKWISE <NEWLINE> <DEDENT> if det < - EPS : <NEWLINE> <INDENT> return Point . CCW_CLOCKWISE <NEWLINE> <DEDENT> if b . dot ( c ) < - EPS : <NEWLINE> <INDENT> return Point . CCW_ONLINE_BACK <NEWLINE> <DEDENT> if c . norm ( ) - b . norm ( ) > EPS : <NEWLINE> <INDENT> return Point . CCW_ONLINE_FRONT <NEWLINE> <DEDENT> return Point . CCW_ON_SEGMENT <NEWLINE> <NL> <DEDENT> def dot ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . x * p . x + self . y * p . y <NEWLINE> <NL> <DEDENT> def det ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . x * p . y - self . y * p . x <NEWLINE> <NL> <DEDENT> def dist ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return abs ( self . c - p . c ) <NEWLINE> <NL> <DEDENT> def norm ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return abs ( self . c ) <NEWLINE> <NL> <DEDENT> def phase ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return cmath . phase ( self . c ) <NEWLINE> <NL> <DEDENT> def angle ( self , p , q ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ( cmath . phase ( q . c - self . c ) - cmath . phase ( p . c - self . c ) + PI ) % TAU - PI <NEWLINE> <NL> <DEDENT> def area ( self , p , q ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return abs ( ( p - self ) . det ( q - self ) / 2 ) <NEWLINE> <NL> <DEDENT> def projection_point ( self , p , q , allow_outer = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> diff_q = q - p <NEWLINE> <COMMENT> <NL> r = ( self - p ) . dot ( diff_q ) / abs ( diff_q ) <NEWLINE> <COMMENT> <NL> phase = diff_q . phase ( ) <NEWLINE> <NL> ret = Point . from_polar ( r , phase ) + p <NEWLINE> if allow_outer or ( p - ret ) . dot ( q - ret ) < EPS : <NEWLINE> <INDENT> return ret <NEWLINE> <DEDENT> return None <NEWLINE> <NL> <DEDENT> def reflection_point ( self , p , q ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> r = abs ( self - p ) <NEWLINE> <COMMENT> <NL> angle = p . angle ( q , self ) <NEWLINE> <COMMENT> <NL> angle = ( q - p ) . phase ( ) - angle <NEWLINE> return Point . from_polar ( r , angle ) + p <NEWLINE> <NL> <DEDENT> def on_segment ( self , p , q , allow_side = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not allow_side and ( self == p or self == q ) : <NEWLINE> <INDENT> return False <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> return abs ( ( p - self ) . det ( q - self ) ) < EPS and ( p - self ) . dot ( q - self ) < EPS <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def circumstance_of ( p1 , p2 , p3 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if abs ( ( p2 - p1 ) . det ( p3 - p1 ) ) < EPS : <NEWLINE> <COMMENT> <NL> <INDENT> return None <NEWLINE> <COMMENT> <NL> <DEDENT> a = ( p2 . x - p3 . x ) ** 2 + ( p2 . y - p3 . y ) ** 2 <NEWLINE> b = ( p3 . x - p1 . x ) ** 2 + ( p3 . y - p1 . y ) ** 2 <NEWLINE> c = ( p1 . x - p2 . x ) ** 2 + ( p1 . y - p2 . y ) ** 2 <NEWLINE> num = p1 * a * ( b + c - a ) + p2 * b * ( c + a - b ) + p3 * c * ( a + b - c ) <NEWLINE> den = a * ( b + c - a ) + b * ( c + a - b ) + c * ( a + b - c ) <NEWLINE> return num / den <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Line : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , a : float , b : float , c : float ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . a = a <NEWLINE> self . b = b <NEWLINE> self . c = c <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def from_gradient ( grad : float , intercept : float ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return Line ( grad , - 1 , intercept ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def from_segment ( p1 , p2 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> a = p2 . y - p1 . y <NEWLINE> b = p1 . x - p2 . x <NEWLINE> c = p2 . y * ( p2 . x - p1 . x ) - p2 . x * ( p2 . y - p1 . y ) <NEWLINE> return Line ( a , b , c ) <NEWLINE> <NL> <DEDENT> @ property <NEWLINE> def gradient ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return INF if self . b == 0 else - self . a / self . b <NEWLINE> <NL> <DEDENT> @ property <NEWLINE> def intercept ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return INF if self . b == 0 else - self . c / self . b <NEWLINE> <NL> <DEDENT> def is_parallel_to ( self , l ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> return abs ( Point . from_rect ( self . a , self . b ) . det ( Point . from_rect ( l . a , l . b ) ) ) < EPS <NEWLINE> <NL> <DEDENT> def is_orthogonal_to ( self , l ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> return abs ( Point . from_rect ( self . a , self . b ) . dot ( Point . from_rect ( l . a , l . b ) ) ) < EPS <NEWLINE> <NL> <DEDENT> def intersection_point ( self , l ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> a1 , b1 , c1 = self . a , self . b , self . c <NEWLINE> a2 , b2 , c2 = l . a , l . b , l . c <NEWLINE> det = a1 * b2 - a2 * b1 <NEWLINE> if abs ( det ) < EPS : <NEWLINE> <COMMENT> <NL> <INDENT> return None <NEWLINE> <DEDENT> x = ( b1 * c2 - b2 * c1 ) / det <NEWLINE> y = ( a2 * c1 - a1 * c2 ) / det <NEWLINE> return Point . from_rect ( x , y ) <NEWLINE> <NL> <DEDENT> def dist ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> raise NotImplementedError ( ) <NEWLINE> <NL> <DEDENT> def has_point ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return abs ( self . a * p . x + self . b * p . y + self . c ) < EPS <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Segment : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , p1 , p2 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . p1 = p1 <NEWLINE> self . p2 = p2 <NEWLINE> <NL> <DEDENT> def norm ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return abs ( self . p1 - self . p2 ) <NEWLINE> <NL> <DEDENT> def phase ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ( self . p2 - self . p1 ) . phase ( ) <NEWLINE> <NL> <DEDENT> def is_parallel_to ( self , s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> return abs ( ( self . p1 - self . p2 ) . det ( s . p1 - s . p2 ) ) < EPS <NEWLINE> <NL> <DEDENT> def is_orthogonal_to ( self , s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> return abs ( ( self . p1 - self . p2 ) . dot ( s . p1 - s . p2 ) ) < EPS <NEWLINE> <NL> <DEDENT> def intersects_with ( self , s , allow_side = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . is_parallel_to ( s ) : <NEWLINE> <COMMENT> <NL> <INDENT> return ( s . p1 . on_segment ( self . p1 , self . p2 , allow_side ) or <NEWLINE> <INDENT> s . p2 . on_segment ( self . p1 , self . p2 , allow_side ) or <NEWLINE> self . p1 . on_segment ( s . p1 , s . p2 , allow_side ) or <NEWLINE> self . p2 . on_segment ( s . p1 , s . p2 , allow_side ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> det_upper = EPS if allow_side else - EPS <NEWLINE> ok = True <NEWLINE> <COMMENT> <NL> ok &= ( self . p2 - self . p1 ) . det ( s . p1 - self . p1 ) * ( self . p2 - self . p1 ) . det ( s . p2 - self . p1 ) < det_upper <NEWLINE> <COMMENT> <NL> ok &= ( s . p2 - s . p1 ) . det ( self . p1 - s . p1 ) * ( s . p2 - s . p1 ) . det ( self . p2 - s . p1 ) < det_upper <NEWLINE> return ok <NEWLINE> <NL> <DEDENT> <DEDENT> def closest_point ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> d = ( p - self . p1 ) . dot ( self . p2 - self . p1 ) / self . norm ( ) <NEWLINE> <COMMENT> <NL> if d < EPS : <NEWLINE> <INDENT> return self . p1 <NEWLINE> <COMMENT> <NL> <DEDENT> if - EPS < d - self . norm ( ) : <NEWLINE> <INDENT> return self . p2 <NEWLINE> <COMMENT> <NL> <DEDENT> return Point . from_polar ( d , ( self . p2 - self . p1 ) . phase ( ) ) + self . p1 <NEWLINE> <NL> <DEDENT> def dist ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return abs ( p - self . closest_point ( p ) ) <NEWLINE> <NL> <DEDENT> def dist_segment ( self , s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . intersects_with ( s ) : <NEWLINE> <INDENT> return 0.0 <NEWLINE> <DEDENT> return min ( <NEWLINE> <INDENT> self . dist ( s . p1 ) , <NEWLINE> self . dist ( s . p2 ) , <NEWLINE> s . dist ( self . p1 ) , <NEWLINE> s . dist ( self . p2 ) , <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> def has_point ( self , p , allow_side = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return p . on_segment ( self . p1 , self . p2 , allow_side = allow_side ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Polygon : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , points ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . points = points <NEWLINE> <NL> <DEDENT> def iter2 ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return zip ( self . points , self . points [ 1 : ] + self . points [ : 1 ] ) <NEWLINE> <NL> <DEDENT> def iter3 ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return zip ( self . points , <NEWLINE> <INDENT> self . points [ 1 : ] + self . points [ : 1 ] , <NEWLINE> self . points [ 2 : ] + self . points [ : 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def area ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> dets = [ ] <NEWLINE> for p , q in self . iter2 ( ) : <NEWLINE> <INDENT> dets . append ( p . det ( q ) ) <NEWLINE> <DEDENT> return abs ( math . fsum ( dets ) ) / 2 <NEWLINE> <NL> <DEDENT> def is_convex ( self , allow_straight = False , allow_collapsed = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ccw = [ ] <NEWLINE> for a , b , c in self . iter3 ( ) : <NEWLINE> <INDENT> ccw . append ( Point . ccw ( a , b , c ) ) <NEWLINE> <DEDENT> ccw = set ( ccw ) <NEWLINE> if len ( ccw ) == 1 : <NEWLINE> <INDENT> if ccw == { Point . CCW_CLOCKWISE } : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if ccw == { Point . CCW_COUNTER_CLOCKWISE } : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> if allow_straight and len ( ccw ) == 2 : <NEWLINE> <INDENT> if ccw == { Point . CCW_ONLINE_FRONT , Point . CCW_CLOCKWISE } : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if ccw == { Point . CCW_ONLINE_FRONT , Point . CCW_COUNTER_CLOCKWISE } : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> if allow_collapsed and len ( ccw ) == 3 : <NEWLINE> <INDENT> return ccw == { Point . CCW_ONLINE_FRONT , Point . CCW_ONLINE_BACK , Point . CCW_ON_SEGMENT } <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def has_point_on_edge ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for a , b in self . iter2 ( ) : <NEWLINE> <INDENT> if p . on_segment ( a , b ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def contains ( self , p , allow_on_edge = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> angles = [ ] <NEWLINE> for a , b in self . iter2 ( ) : <NEWLINE> <INDENT> if p . on_segment ( a , b ) : <NEWLINE> <INDENT> return allow_on_edge <NEWLINE> <DEDENT> angles . append ( p . angle ( a , b ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> return abs ( math . fsum ( angles ) ) > EPS <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def convex_hull ( points , allow_straight = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> points = points [ : ] <NEWLINE> points . sort ( key = lambda p : ( p . x , p . y ) ) <NEWLINE> <NL> <COMMENT> <NL> det_lower = - EPS if allow_straight else EPS <NEWLINE> <NL> sz = 0 <NEWLINE> <COMMENT> <NL> ret = [ None ] * ( len ( points ) * 2 ) <NEWLINE> for p in points : <NEWLINE> <INDENT> while sz > 1 and ( ret [ sz - 1 ] - ret [ sz - 2 ] ) . det ( p - ret [ sz - 1 ] ) < det_lower : <NEWLINE> <INDENT> sz -= 1 <NEWLINE> <DEDENT> ret [ sz ] = p <NEWLINE> sz += 1 <NEWLINE> <DEDENT> floor = sz <NEWLINE> for p in reversed ( points [ : - 1 ] ) : <NEWLINE> <INDENT> while sz > floor and ( ret [ sz - 1 ] - ret [ sz - 2 ] ) . det ( p - ret [ sz - 1 ] ) < det_lower : <NEWLINE> <INDENT> sz -= 1 <NEWLINE> <DEDENT> ret [ sz ] = p <NEWLINE> sz += 1 <NEWLINE> <DEDENT> ret = ret [ : sz - 1 ] <NEWLINE> <NL> if allow_straight and len ( ret ) > len ( points ) : <NEWLINE> <COMMENT> <NL> <INDENT> ret = points <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def diameter ( points ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> points = Polygon . convex_hull ( points , allow_straight = False ) <NEWLINE> if len ( points ) == 1 : <NEWLINE> <INDENT> return 0.0 <NEWLINE> <DEDENT> if len ( points ) == 2 : <NEWLINE> <INDENT> return abs ( points [ 0 ] - points [ 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> si = points . index ( min ( points , key = lambda p : ( p . x , p . y ) ) ) <NEWLINE> sj = points . index ( max ( points , key = lambda p : ( p . x , p . y ) ) ) <NEWLINE> n = len ( points ) <NEWLINE> <NL> ret = 0.0 <NEWLINE> <COMMENT> <NL> i , j = si , sj <NEWLINE> while i != sj or j != si : <NEWLINE> <INDENT> ret = max ( ret , abs ( points [ i ] - points [ j ] ) ) <NEWLINE> ni = ( i + 1 ) % n <NEWLINE> nj = ( j + 1 ) % n <NEWLINE> <COMMENT> <NL> if ( points [ ni ] - points [ i ] ) . det ( points [ nj ] - points [ j ] ) > 0 : <NEWLINE> <INDENT> j = nj <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = ni <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def convex_cut_by_line ( self , line_p1 , line_p2 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> n = len ( self . points ) <NEWLINE> line = Line . from_segment ( line_p1 , line_p2 ) <NEWLINE> <COMMENT> <NL> on_line_points = [ ] <NEWLINE> for i , p in enumerate ( self . points ) : <NEWLINE> <INDENT> if line . has_point ( p ) : <NEWLINE> <INDENT> on_line_points . append ( i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> has_on_line_edge = False <NEWLINE> if len ( on_line_points ) >= 3 : <NEWLINE> <INDENT> has_on_line_edge = True <NEWLINE> <DEDENT> elif len ( on_line_points ) == 2 : <NEWLINE> <COMMENT> <NL> <INDENT> has_on_line_edge = abs ( on_line_points [ 0 ] - on_line_points [ 1 ] ) in [ 1 , n - 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> if has_on_line_edge : <NEWLINE> <INDENT> for p in self . points : <NEWLINE> <INDENT> ccw = Point . ccw ( line_p1 , line_p2 , p ) <NEWLINE> if ccw == Point . CCW_COUNTER_CLOCKWISE : <NEWLINE> <INDENT> return Polygon ( self . points [ : ] ) , None <NEWLINE> <DEDENT> if ccw == Point . CCW_CLOCKWISE : <NEWLINE> <INDENT> return None , Polygon ( self . points [ : ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ret_lefts = [ ] <NEWLINE> ret_rights = [ ] <NEWLINE> d = line_p2 - line_p1 <NEWLINE> for p , q in self . iter2 ( ) : <NEWLINE> <INDENT> det_p = d . det ( p - line_p1 ) <NEWLINE> det_q = d . det ( q - line_p1 ) <NEWLINE> if det_p > - EPS : <NEWLINE> <INDENT> ret_lefts . append ( p ) <NEWLINE> <DEDENT> if det_p < EPS : <NEWLINE> <INDENT> ret_rights . append ( p ) <NEWLINE> <COMMENT> <NL> <DEDENT> if det_p * det_q < - EPS : <NEWLINE> <INDENT> intersection = line . intersection_point ( Line . from_segment ( p , q ) ) <NEWLINE> ret_lefts . append ( intersection ) <NEWLINE> ret_rights . append ( intersection ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> l = Polygon ( ret_lefts ) if len ( ret_lefts ) > 1 else None <NEWLINE> r = Polygon ( ret_rights ) if len ( ret_rights ) > 1 else None <NEWLINE> return l , r <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Circle : <NEWLINE> <INDENT> def __init__ ( self , o , r ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . o = o <NEWLINE> self . r = r <NEWLINE> <NL> <DEDENT> def __eq__ ( self , other ) : <NEWLINE> <INDENT> return self . o == other . o and abs ( self . r - other . r ) < EPS <NEWLINE> <NL> <DEDENT> def ctc ( self , c ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . o == c . o : <NEWLINE> <INDENT> return INF if abs ( self . r - c . r ) < EPS else 0 <NEWLINE> <COMMENT> <NL> <DEDENT> d = self . o . dist ( c . o ) - self . r - c . r <NEWLINE> if d > EPS : <NEWLINE> <INDENT> return 4 <NEWLINE> <DEDENT> elif d > - EPS : <NEWLINE> <INDENT> return 3 <NEWLINE> <COMMENT> <NL> <DEDENT> elif d + min ( self . r , c . r ) * 2 > EPS : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> elif d + min ( self . r , c . r ) * 2 > - EPS : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def has_point_on_edge ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return abs ( self . o . dist ( p ) - self . r ) < EPS <NEWLINE> <NL> <DEDENT> def contains ( self , p , allow_on_edge = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if allow_on_edge : <NEWLINE> <COMMENT> <NL> <INDENT> return self . o . dist ( p ) - self . r < EPS <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> return self . o . dist ( p ) - self . r < - EPS <NEWLINE> <NL> <DEDENT> <DEDENT> def area ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . r ** 2 * PI <NEWLINE> <NL> <DEDENT> def circular_segment_area ( self , angle ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> sector_area = self . area ( ) * angle / TAU <NEWLINE> <COMMENT> <NL> return sector_area - self . r ** 2 * math . sin ( angle ) / 2 <NEWLINE> <NL> <DEDENT> def intersection_points ( self , other , allow_outer = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if isinstance ( other , Segment ) : <NEWLINE> <INDENT> return self . intersection_points_with_segment ( other , allow_outer = allow_outer ) <NEWLINE> <DEDENT> if isinstance ( other , Circle ) : <NEWLINE> <INDENT> return self . intersection_points_with_circle ( other ) <NEWLINE> <DEDENT> raise NotImplementedError ( ) <NEWLINE> <NL> <DEDENT> def intersection_points_with_segment ( self , s , allow_outer = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> projection_point = self . o . projection_point ( s . p1 , s . p2 , allow_outer = True ) <NEWLINE> <COMMENT> <NL> dist = self . o . dist ( projection_point ) <NEWLINE> <COMMENT> <NL> if dist - self . r > EPS : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> if dist - self . r > - EPS : <NEWLINE> <INDENT> if allow_outer or s . has_point ( projection_point ) : <NEWLINE> <INDENT> return [ projection_point ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> diff = Point . from_polar ( math . sqrt ( self . r ** 2 - dist ** 2 ) , s . phase ( ) ) <NEWLINE> ret1 = projection_point + diff <NEWLINE> ret2 = projection_point - diff <NEWLINE> ret = [ ] <NEWLINE> if allow_outer or s . has_point ( ret1 ) : <NEWLINE> <INDENT> ret . append ( ret1 ) <NEWLINE> <DEDENT> if allow_outer or s . has_point ( ret2 ) : <NEWLINE> <INDENT> ret . append ( ret2 ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def intersection_points_with_circle ( self , other ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ctc = self . ctc ( other ) <NEWLINE> if not 1 <= ctc <= 3 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> if ctc == 3 : <NEWLINE> <COMMENT> <NL> <INDENT> return [ Point . from_polar ( self . r , ( other . o - self . o ) . phase ( ) ) + self . o ] <NEWLINE> <DEDENT> if ctc == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> if self . r > other . r : <NEWLINE> <INDENT> return [ Point . from_polar ( self . r , ( other . o - self . o ) . phase ( ) ) + self . o ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ Point . from_polar ( self . r , ( self . o - other . o ) . phase ( ) ) + self . o ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> assert ctc == 2 <NEWLINE> <NL> a = other . r <NEWLINE> b = self . r <NEWLINE> c = self . o . dist ( other . o ) <NEWLINE> <COMMENT> <NL> cos_a = ( b ** 2 + c ** 2 - a ** 2 ) / ( 2 * b * c ) <NEWLINE> angle = math . acos ( cos_a ) <NEWLINE> phi = ( other . o - self . o ) . phase ( ) <NEWLINE> return [ <NEWLINE> <INDENT> self . o + Point . from_polar ( self . r , phi + angle ) , <NEWLINE> self . o + Point . from_polar ( self . r , phi - angle ) , <NEWLINE> <DEDENT> ] <NEWLINE> <NL> <DEDENT> def tangent_points_with_point ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> dist = self . o . dist ( p ) <NEWLINE> <COMMENT> <NL> if dist - self . r < - EPS : <NEWLINE> <COMMENT> <NL> <INDENT> return [ ] <NEWLINE> <DEDENT> if dist - self . r < EPS : <NEWLINE> <COMMENT> <NL> <INDENT> return [ Point ( p . x , p . y ) ] <NEWLINE> <NL> <DEDENT> a = math . sqrt ( dist ** 2 - self . r ** 2 ) <NEWLINE> b = self . r <NEWLINE> c = dist <NEWLINE> <COMMENT> <NL> cos_a = ( b ** 2 + c ** 2 - a ** 2 ) / ( 2 * b * c ) <NEWLINE> angle = math . acos ( cos_a ) <NEWLINE> phi = ( p - self . o ) . phase ( ) <NEWLINE> return [ <NEWLINE> <INDENT> self . o + Point . from_polar ( self . r , phi + angle ) , <NEWLINE> self . o + Point . from_polar ( self . r , phi - angle ) , <NEWLINE> <DEDENT> ] <NEWLINE> <NL> <DEDENT> def tangent_points_with_circle ( self , other ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ctc = self . ctc ( other ) <NEWLINE> if ctc > 4 : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> if ctc == 0 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> if ctc == 1 : <NEWLINE> <INDENT> return self . intersection_points_with_circle ( other ) <NEWLINE> <NL> <DEDENT> assert ctc in ( 2 , 3 , 4 ) <NEWLINE> ret = [ ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if abs ( self . r - other . r ) < EPS : <NEWLINE> <COMMENT> <NL> <INDENT> phi = ( other . o - self . o ) . phase ( ) <NEWLINE> ret . append ( self . o + Point . from_polar ( self . r , phi + PI / 2 ) ) <NEWLINE> ret . append ( self . o + Point . from_polar ( self . r , phi - PI / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> intersection = self . o + ( other . o - self . o ) / ( self . r - other . r ) * self . r <NEWLINE> ret += self . tangent_points_with_point ( intersection ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> intersection = self . o + ( other . o - self . o ) / ( self . r + other . r ) * self . r <NEWLINE> ret += self . tangent_points_with_point ( intersection ) <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def circumscribed_of ( p1 , p2 , p3 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if p1 . on_segment ( p2 , p3 ) : <NEWLINE> <INDENT> return Circle ( ( p2 + p3 ) / 2 , p2 . dist ( p3 ) / 2 ) <NEWLINE> <DEDENT> if p2 . on_segment ( p1 , p3 ) : <NEWLINE> <INDENT> return Circle ( ( p1 + p3 ) / 2 , p1 . dist ( p3 ) / 2 ) <NEWLINE> <DEDENT> if p3 . on_segment ( p1 , p2 ) : <NEWLINE> <INDENT> return Circle ( ( p1 + p2 ) / 2 , p1 . dist ( p2 ) / 2 ) <NEWLINE> <DEDENT> o = Point . circumstance_of ( p1 , p2 , p3 ) <NEWLINE> return Circle ( o , o . dist ( p1 ) ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def min_enclosing_circle ( points , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if len ( points ) <= 1 : <NEWLINE> <INDENT> return Circle ( points [ 0 ] , 0 ) <NEWLINE> <DEDENT> if len ( points ) == 2 : <NEWLINE> <INDENT> return Circle ( ( points [ 0 ] + points [ 1 ] ) / 2 , points [ 0 ] . dist ( points [ 1 ] ) / 2 ) <NEWLINE> <NL> <DEDENT> def mid ( p1 , p2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> return Circle ( ( p1 + p2 ) / 2 , p1 . dist ( p2 ) / 2 ) <NEWLINE> <NL> <DEDENT> points = points [ : ] <NEWLINE> random . shuffle ( points ) <NEWLINE> <COMMENT> <NL> ret = mid ( points [ 0 ] , points [ 1 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if ret . contains ( points [ i ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ret = mid ( points [ 0 ] , points [ i ] ) <NEWLINE> for j in range ( 1 , i ) : <NEWLINE> <INDENT> if ret . contains ( points [ j ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ret = mid ( points [ j ] , points [ i ] ) <NEWLINE> for k in range ( 0 , j ) : <NEWLINE> <INDENT> if ret . contains ( points [ k ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ret = Circle . circumscribed_of ( points [ k ] , points [ j ] , points [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> XY = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> points = [ ] <NEWLINE> for x , y in XY : <NEWLINE> <INDENT> points . append ( Point ( x , y ) ) <NEWLINE> <DEDENT> ans = Circle . min_enclosing_circle ( points , N ) <NEWLINE> print ( ans . r ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = 1 ; w = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if w == 0 : <NEWLINE> <INDENT> if A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> w = 1 <NEWLINE> <DEDENT> elif A [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> w = - 1 <NEWLINE> <DEDENT> <DEDENT> elif ( w > 0 and A [ i ] > A [ i + 1 ] ) or ( w < 0 and A [ i ] < A [ i + 1 ] ) : <NEWLINE> <INDENT> w = 0 <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = [ 0 ] <NEWLINE> <NL> Sum = 0 <NEWLINE> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> K = K - A [ i ] <NEWLINE> if K >= 0 : <NEWLINE> <INDENT> Sum += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = K + A [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i = N <NEWLINE> <DEDENT> S . append ( Sum ) <NEWLINE> <NL> for j in range ( M ) : <NEWLINE> <INDENT> K = K - B [ j ] <NEWLINE> if K >= 0 : <NEWLINE> <INDENT> Sum += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for k in range ( i ) : <NEWLINE> <INDENT> K = K + A [ i - k - 1 ] <NEWLINE> <NL> Sum = Sum - 1 <NEWLINE> if K >= 0 : <NEWLINE> <INDENT> i = i - k - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i = 0 <NEWLINE> continue <NEWLINE> <DEDENT> if K >= 0 : <NEWLINE> <INDENT> Sum += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> S . append ( Sum ) <NEWLINE> <NL> <DEDENT> print ( max ( S ) ) <NEWLINE>
n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> from itertools import accumulate <NEWLINE> import bisect <NEWLINE> cumsum_a = list ( accumulate ( a ) ) <NEWLINE> cumsum_b = list ( accumulate ( b ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if cumsum_a [ i - 1 ] > k : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> cnt_b = bisect . bisect ( cumsum_b , k - cumsum_a [ i - 1 ] ) <NEWLINE> ans = max ( ans , i + cnt_b ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> if cumsum_b [ i - 1 ] > k : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> cnt_a = bisect . bisect ( cumsum_a , k - cumsum_b [ i - 1 ] ) <NEWLINE> ans = max ( ans , i + cnt_a ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> W = [ 0 for i in range ( n ) ] <NEWLINE> def M ( l , r ) : <COMMENT> <NEWLINE> <INDENT> if ( l + 1 >= r ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif ( l + 2 == r ) : <NEWLINE> <INDENT> if ( nlist [ l ] <= nlist [ l + 1 ] ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nlist [ l ] , nlist [ l + 1 ] = nlist [ l + 1 ] , nlist [ l ] <NEWLINE> return 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> m = ( l + r ) // 2 <NEWLINE> i = l <NEWLINE> j = m <NEWLINE> k = l <NEWLINE> cl = M ( l , m ) <NEWLINE> cr = M ( m , r ) <NEWLINE> c = 0 <NEWLINE> while ( i < m and j < r ) : <NEWLINE> <INDENT> if ( nlist [ i ] <= nlist [ j ] ) : <NEWLINE> <INDENT> W [ k ] = nlist [ i ] <COMMENT> <NEWLINE> k += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> W [ k ] = nlist [ j ] <COMMENT> <NEWLINE> k += 1 <NEWLINE> j += 1 <NEWLINE> c += ( m - i ) <COMMENT> <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> while ( i < m ) : <COMMENT> <NEWLINE> <INDENT> W [ k ] = nlist [ i ] <NEWLINE> k += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> while ( j < r ) : <COMMENT> <NEWLINE> <INDENT> W [ k ] = nlist [ j ] <NEWLINE> k += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> for i in range ( l , r ) : <NEWLINE> <INDENT> nlist [ i ] = W [ i ] <NEWLINE> <DEDENT> return cl + cr + c <NEWLINE> <NL> <DEDENT> print ( M ( 0 , n ) ) <NEWLINE>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> result += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> def create_prime ( n ) : <NEWLINE> <INDENT> prime = [ 1 ] * ( n + 1 ) <NEWLINE> prime [ : 2 ] = [ 0 , 0 ] <NEWLINE> for i in range ( len ( prime ) ) : <NEWLINE> <INDENT> if prime [ i ] : <NEWLINE> <INDENT> for j in range ( 2 * i , len ( prime ) , i ) : <NEWLINE> <INDENT> prime [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return prime <NEWLINE> <NL> <DEDENT> sieve = create_prime ( 50000 ) <NEWLINE> <NL> prime = [ ] <NEWLINE> for i in range ( 25001 ) : <NEWLINE> <INDENT> if sieve [ i ] : <NEWLINE> <INDENT> prime . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( f . readline ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> temp = n // 2 <NEWLINE> for i in prime : <NEWLINE> <INDENT> if i > temp : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if sieve [ n - i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
S = input ( ) [ : : - 1 ] <NEWLINE> ans = 0 <NEWLINE> mods = [ 0 ] * 2019 <NEWLINE> mods [ 0 ] = 1 <NEWLINE> current = 0 <NEWLINE> x = 1 <NEWLINE> <NL> for s in S : <NEWLINE> <INDENT> current = ( current + x * int ( s ) ) % 2019 <NEWLINE> ans += mods [ current % 2019 ] <NEWLINE> mods [ current % 2019 ] += 1 <NEWLINE> x = x * 10 % 2019 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
N , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> check = [ 0 ] * N <NEWLINE> ima = 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if check [ A [ ima ] - 1 ] != 0 : <NEWLINE> <INDENT> loopen = ima <NEWLINE> check [ ima ] = i + 1 <NEWLINE> looplen = check [ ima ] - check [ A [ ima ] - 1 ] + 1 <NEWLINE> loopend = i <NEWLINE> break <NEWLINE> <DEDENT> if i == K - 1 : <NEWLINE> <INDENT> print ( A [ ima ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> check [ ima ] = i + 1 <NEWLINE> ima = A [ ima ] - 1 <NEWLINE> <NL> <DEDENT> offset = ( K - ( i - looplen ) - 1 ) % looplen <NEWLINE> ima = 0 <NEWLINE> for i in range ( loopend - looplen + offset + 1 ) : <NEWLINE> <INDENT> ima = A [ ima ] - 1 <NEWLINE> <DEDENT> print ( ima + 1 ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> kazu = 0 <NEWLINE> c_a = 0 <NEWLINE> c_b = 0 <NEWLINE> time = 0 <NEWLINE> <NL> a = [ 0 ] + a <NEWLINE> b = [ 0 ] + b <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a [ i ] = a [ i - 1 ] + a [ i ] <NEWLINE> <DEDENT> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> b [ i ] = b [ i - 1 ] + b [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( 0 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( max ( 0 , kazu - i + 1 ) , m + 1 ) : <NEWLINE> <INDENT> time = a [ i ] + b [ j ] <NEWLINE> if time > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> kazu = i + j <NEWLINE> <NL> <DEDENT> <DEDENT> print ( kazu ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ - 1 ] * M <NEWLINE> c = [ - 1 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> s [ i ] , c [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> if N == 1 and M == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if N == 1 and s [ 0 ] == 1 and c [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> arr_ans = [ - 1 ] * ( N + 1 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if arr_ans [ s [ i ] ] == - 1 or arr_ans [ s [ i ] ] == c [ i ] : <NEWLINE> <INDENT> arr_ans [ s [ i ] ] = c [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if arr_ans [ 1 ] == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if arr_ans [ i ] == - 1 : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> arr_ans [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr_ans [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> _ans = [ str ( arr_ans [ i ] ) for i in range ( N + 1 ) ] <NEWLINE> ans = <STRING> . join ( _ans [ 1 : ] ) <NEWLINE> print ( ans ) <NEWLINE>
N , blue , red = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = N // ( blue + red ) * blue <NEWLINE> rem = N % ( blue + red ) <NEWLINE> ans += min ( rem , blue ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ <STRING> . join ( sorted ( input ( ) ) ) for _ in range ( N ) ] <NEWLINE> ans = 0 <NEWLINE> import collections <NEWLINE> from math import factorial <NEWLINE> c = collections . Counter ( S ) <NEWLINE> for i in c . values ( ) : <NEWLINE> <INDENT> if 2 <= i : <NEWLINE> <INDENT> ans += factorial ( i ) // ( factorial ( i - 2 ) * factorial ( 2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> s = s [ : : - 1 ] <NEWLINE> n = len ( s ) <NEWLINE> m = [ 0 ] * 2019 <NEWLINE> m [ 0 ] = 1 <NEWLINE> a = 0 <NEWLINE> d = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = ( a + int ( s [ i ] ) * d ) % 2019 <NEWLINE> d = ( d * 10 ) % 2019 <NEWLINE> m [ a ] += 1 <NEWLINE> <DEDENT> print ( sum ( [ int ( x * ( x - 1 ) / 2 ) for x in m if x > 1 ] ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> m = ( 10 ** 9 ) + 7 <NEWLINE> l = [ 1 , 1 ] <NEWLINE> for i in range ( 2 , S + 1 ) : <NEWLINE> <INDENT> l . append ( l [ - 1 ] * i ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( S // 3 ) : <NEWLINE> <INDENT> kou = i + 1 <NEWLINE> maru = S - 3 * kou <NEWLINE> shikiri = i <NEWLINE> ans += l [ maru + shikiri ] // ( l [ maru ] * l [ shikiri ] ) <NEWLINE> <NL> <DEDENT> print ( int ( ( ans % m ) ) ) <NEWLINE>
<COMMENT> <NL> <NL> def maxHeapify ( A , i ) : <NEWLINE> <INDENT> l = 2 * i - 1 <NEWLINE> r = 2 * i <NEWLINE> largest = i - 1 <NEWLINE> <NL> if l < len ( A ) : <NEWLINE> <INDENT> largest = largest if A [ largest ] > A [ l ] else l <NEWLINE> <NL> <DEDENT> if r < len ( A ) : <NEWLINE> <INDENT> largest = largest if A [ largest ] > A [ r ] else r <NEWLINE> <NL> <DEDENT> if largest != i - 1 : <NEWLINE> <INDENT> A [ largest ] , A [ i - 1 ] = A [ i - 1 ] , A [ largest ] <NEWLINE> maxHeapify ( A , largest + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> H = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( int ( H / 2 ) , 0 , - 1 ) : <NEWLINE> <INDENT> maxHeapify ( a , i ) <NEWLINE> <NL> <DEDENT> print ( <STRING> + <STRING> . join ( str ( x ) for x in a ) ) , <NEWLINE> <DEDENT>
INT = lambda : int ( input ( ) ) <NEWLINE> INTM = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> STRM = lambda : map ( str , input ( ) . split ( ) ) <NEWLINE> STR = lambda : str ( input ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LISTS = lambda : list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> def do ( ) : <NEWLINE> <INDENT> n = INT ( ) <NEWLINE> s = STR ( ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> ans = r * g * b <NEWLINE> <COMMENT> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n // 2 + 2 ) : <NEWLINE> <INDENT> k = i + 2 * j <NEWLINE> if k <= n - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> if ( s [ i ] != s [ i + j ] and s [ k ] != s [ i + j ] and s [ i ] != s [ k ] ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> do ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def func ( ) : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> while ( True ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> line = input ( ) . rstrip ( ) <NEWLINE> elements = line . split ( <STRING> ) <NEWLINE> elements [ 0 ] = int ( elements [ 0 ] ) <NEWLINE> elements [ 2 ] = int ( elements [ 2 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return - 1 <NEWLINE> <NL> <DEDENT> operator = elements [ 1 ] <NEWLINE> if ( operator == <STRING> ) : <NEWLINE> <INDENT> print ( elements [ 0 ] + elements [ 2 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif ( operator == <STRING> ) : <NEWLINE> <INDENT> print ( elements [ 0 ] - elements [ 2 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif ( operator == <STRING> ) : <NEWLINE> <INDENT> print ( elements [ 0 ] * elements [ 2 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif ( operator == <STRING> ) : <NEWLINE> <INDENT> print ( elements [ 0 ] // elements [ 2 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif ( operator == <STRING> ) : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return - 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> func ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> list . sort ( A , reverse = True ) <NEWLINE> mx = 10 ** 18 <NEWLINE> mul = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> mul *= a <NEWLINE> if mul > mx : <NEWLINE> <INDENT> mul = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mul ) <NEWLINE>
while True : <NEWLINE> <INDENT> h , w = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( ( <STRING> * w + <STRING> ) * h ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> keihin = [ ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> keihin . append ( str ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( keihin ) ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> stud = [ ] <NEWLINE> poit = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> stud . append ( [ a , b ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> poit . append ( [ c , d ] ) <NEWLINE> <NL> <DEDENT> for a , b in stud : <NEWLINE> <INDENT> dist = float ( <STRING> ) <NEWLINE> for i , info in enumerate ( poit ) : <NEWLINE> <INDENT> c = info [ 0 ] <NEWLINE> d = info [ 1 ] <NEWLINE> mdist = abs ( a - c ) + abs ( b - d ) <NEWLINE> if dist > mdist : <NEWLINE> <INDENT> dist = mdist <NEWLINE> ans = i + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <DEDENT>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> dq = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> cmd = input ( ) . split ( ) <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> dq . appendleft ( cmd [ 1 ] ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> dq . popleft ( ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> dq . pop ( ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> dq . remove ( cmd [ 1 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * dq ) <NEWLINE>
import sys <NEWLINE> import heapq <NEWLINE> <NL> <NL> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> adj = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> adj [ a ] . append ( b ) <NEWLINE> adj [ b ] . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> INF = 10 ** 18 <NEWLINE> WHITE = 0 <NEWLINE> GRAY = 1 <NEWLINE> BLACK = 2 <NEWLINE> <NL> def dijkstra ( s ) : <NEWLINE> <INDENT> color = [ WHITE ] * N <NEWLINE> d = [ INF ] * N <NEWLINE> p = [ - 1 ] * N <NEWLINE> d [ s ] = 0 <NEWLINE> PQ = [ ] <NEWLINE> heapq . heappush ( PQ , ( 0 , s ) ) <COMMENT> <NEWLINE> color [ s ] = GRAY <NEWLINE> <NL> while PQ : <NEWLINE> <INDENT> distance , u = heapq . heappop ( PQ ) <NEWLINE> color [ u ] = BLACK <NEWLINE> <NL> if d [ u ] < distance : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for j in range ( len ( adj [ u ] ) ) : <NEWLINE> <INDENT> v = adj [ u ] [ j ] <NEWLINE> if color [ v ] == BLACK : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if d [ v ] > d [ u ] + 1 : <NEWLINE> <INDENT> d [ v ] = d [ u ] + 1 <NEWLINE> p [ v ] = u <NEWLINE> heapq . heappush ( PQ , ( d [ v ] , v ) ) <NEWLINE> color [ v ] = GRAY <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return d , p <NEWLINE> <NL> <DEDENT> d , p = dijkstra ( 0 ) <NEWLINE> <COMMENT> <NL> if INF in d [ 1 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( p [ i ] + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if arr [ i ] == i + 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> arr [ i + 1 ] , arr [ i ] = arr [ i ] , arr [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> if arr [ n - 1 ] == n : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> d = deque ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> lines = sys . stdin . readlines ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ins = lines [ i ] . split ( ) <NEWLINE> command = ins [ 0 ] <NEWLINE> if command == <STRING> : <NEWLINE> <INDENT> d . appendleft ( ins [ 1 ] ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> d . remove ( ins [ 1 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> d . popleft ( ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> d . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( d ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> used = [ 0 for _ in range ( int ( 1e6 + 1 ) ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if used [ i ] > 0 : <NEWLINE> <INDENT> used [ i ] += 1 <NEWLINE> continue <NEWLINE> <DEDENT> for j in range ( i , len ( used ) , i ) : <NEWLINE> <INDENT> used [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> for a in A : <NEWLINE> <INDENT> if used [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> card = 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i == card : <NEWLINE> <INDENT> card += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> <DEDENT>
def set1 ( ) : <NEWLINE> <INDENT> N , M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> H = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> set_N = set ( [ i for i in range ( 1 , N + 1 ) ] ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H [ A - 1 ] < H [ B - 1 ] : <NEWLINE> <INDENT> if A in set_N : <NEWLINE> <INDENT> set_N . remove ( A ) <NEWLINE> <DEDENT> <DEDENT> elif H [ B - 1 ] < H [ A - 1 ] : <NEWLINE> <INDENT> if B in set_N : <NEWLINE> <INDENT> set_N . remove ( B ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if A in set_N : <NEWLINE> <INDENT> set_N . remove ( A ) <NEWLINE> <DEDENT> if B in set_N : <NEWLINE> <INDENT> set_N . remove ( B ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( set_N ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> set1 ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 10 ** 10 <NEWLINE> mod = N % K <NEWLINE> ans = min ( mod , abs ( mod - K ) ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> s2 = list ( set ( s ) ) <NEWLINE> <NL> <NL> print ( len ( s2 ) ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maxA = A [ N - 1 ] <NEWLINE> dp = [ 0 ] * ( maxA + 1 ) <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> cursor = A [ i ] <NEWLINE> while cursor <= maxA : <NEWLINE> <INDENT> dp [ cursor ] += 1 <NEWLINE> cursor += A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if dp [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> L = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> order = [ [ ] for _ in range ( Q ) ] <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> order [ i ] = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> <DEDENT> cnt = { } <NEWLINE> for i in L : <NEWLINE> <INDENT> if i in cnt : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> cnt [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ sum ( L ) ] <NEWLINE> for i in order : <NEWLINE> <INDENT> if i [ 0 ] not in cnt : <NEWLINE> <INDENT> print ( ans [ - 1 ] ) <NEWLINE> continue <NEWLINE> <DEDENT> temp = cnt [ i [ 0 ] ] * ( i [ 1 ] - i [ 0 ] ) <NEWLINE> ans . append ( temp + ans [ - 1 ] ) <NEWLINE> print ( ans [ - 1 ] ) <NEWLINE> <NL> if i [ 1 ] in cnt : <NEWLINE> <INDENT> cnt [ i [ 1 ] ] += cnt [ i [ 0 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ i [ 1 ] ] = cnt [ i [ 0 ] ] <NEWLINE> <NL> <DEDENT> del cnt [ i [ 0 ] ] <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def check ( p ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while s + T [ i ] <= p : <NEWLINE> <INDENT> s += T [ i ] <NEWLINE> i += 1 <NEWLINE> if i == n : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return i <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = 100000 * 10000 <NEWLINE> while right - left > 1 : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> v = check ( mid ) <NEWLINE> if v >= n : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid <NEWLINE> <DEDENT> <DEDENT> return right <NEWLINE> <NL> <NL> <DEDENT> T = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> T . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> ans = solve ( ) <NEWLINE> print ( ans ) <NEWLINE> <NL>
import sys <NEWLINE> from heapq import heappush , heappop <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> INF = 10 ** 10 <NEWLINE> <NL> direct = ( ( 0 , - 1 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 1 , 0 ) ) <NEWLINE> <NL> def dist ( fr , to , mp ) : <NEWLINE> <INDENT> que = [ ] <NEWLINE> heappush ( que , ( 0 , fr ) ) <NEWLINE> visited = [ [ False ] * len ( mp [ 0 ] ) for _ in range ( len ( mp ) ) ] <NEWLINE> visited [ fr [ 1 ] ] [ fr [ 0 ] ] = True <NEWLINE> while que : <NEWLINE> <INDENT> d , point = heappop ( que ) <NEWLINE> x , y = point <NEWLINE> for dx , dy in direct : <NEWLINE> <INDENT> nx , ny = x + dx , y + dy <NEWLINE> if ( nx , ny ) == to : <NEWLINE> <INDENT> return d + 1 <NEWLINE> <DEDENT> if not visited [ ny ] [ nx ] and mp [ ny ] [ nx ] != <STRING> : <NEWLINE> <INDENT> visited [ ny ] [ nx ] = True <NEWLINE> heappush ( que , ( d + 1 , ( nx , ny ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def my_hash ( rest ) : <NEWLINE> <INDENT> return sum ( [ 10 ** i for i in rest ] ) <NEWLINE> <NL> <DEDENT> def shortest ( fr , rest , edges , dp ) : <NEWLINE> <INDENT> if rest == set ( ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if my_hash ( rest ) in dp [ fr ] : <NEWLINE> <INDENT> return dp [ fr ] [ my_hash ( rest ) ] <NEWLINE> <DEDENT> ret = INF <NEWLINE> for d , to in edges [ fr ] : <NEWLINE> <INDENT> if to in rest : <NEWLINE> <INDENT> score = d + shortest ( to , rest - { to } , edges , dp ) <NEWLINE> if score < ret : <NEWLINE> <INDENT> ret = score <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dp [ fr ] [ my_hash ( rest ) ] = ret <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> mp = [ <STRING> + input ( ) + <STRING> for _ in range ( h ) ] <NEWLINE> mp . insert ( 0 , <STRING> * ( w + 2 ) ) <NEWLINE> mp . append ( <STRING> * ( w + 2 ) ) <NEWLINE> <NL> stains = [ ] <NEWLINE> for y in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> for x in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> if mp [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> stains . append ( ( x , y ) ) <NEWLINE> <DEDENT> elif mp [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> start = len ( stains ) <NEWLINE> stains . append ( ( x , y ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> stain_num = len ( stains ) <NEWLINE> edges = [ [ ] for _ in range ( stain_num ) ] <NEWLINE> D = [ [ None ] * stain_num for _ in range ( stain_num ) ] <NEWLINE> for i in range ( stain_num ) : <NEWLINE> <INDENT> D [ i ] [ i ] = 0 <NEWLINE> <DEDENT> miss_flag = False <NEWLINE> for i in range ( stain_num ) : <NEWLINE> <INDENT> for j in range ( i + 1 , stain_num ) : <NEWLINE> <INDENT> fr = stains [ i ] <NEWLINE> to = stains [ j ] <NEWLINE> d = dist ( fr , to , mp ) <NEWLINE> if d == - 1 : <NEWLINE> <INDENT> miss_flag = True <NEWLINE> <DEDENT> edges [ i ] . append ( ( d , j ) ) <NEWLINE> edges [ j ] . append ( ( d , i ) ) <NEWLINE> D [ i ] [ j ] = d <NEWLINE> D [ j ] [ i ] = d <NEWLINE> <DEDENT> <DEDENT> if miss_flag : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> continue <NEWLINE> <NL> <NL> <DEDENT> dp = [ { } for _ in range ( 10 ) ] <NEWLINE> print ( shortest ( start , { i for i in range ( stain_num ) if i != start } , edges , dp ) ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> ax , ay , bx , by , cx , cy , dx , dy = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ abs ( ( ay - by ) * ( dx - cx ) - ( ax - bx ) * ( dy - cy ) ) < 1e-10 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N == 0 and A [ 0 ] != 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif N != 0 and A [ 0 ] != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> nodes = 1 <NEWLINE> preF = 0 <NEWLINE> sucF = sum ( A ) <NEWLINE> <NL> for d in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> fol = A [ d ] <NEWLINE> nodes = min ( ( nodes - preF ) * 2 , sucF ) <NEWLINE> <NL> if nodes < fol : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans += nodes <NEWLINE> preF = fol <NEWLINE> sucF -= fol <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> A = list ( map ( lambda x : int ( x ) , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> q = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> dic = { } <NEWLINE> for a in A : <NEWLINE> <INDENT> dic [ a ] = dic . get ( a , 0 ) + 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> summ = sum ( [ k * v for k , v in dic . items ( ) ] ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = list ( map ( lambda x : int ( x ) , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> diff = c * dic . get ( b , 0 ) - b * dic . get ( b , 0 ) <NEWLINE> dic [ c ] = dic . get ( c , 0 ) + dic . get ( b , 0 ) <NEWLINE> dic [ b ] = 0 <NEWLINE> summ += diff <NEWLINE> print ( summ ) <NEWLINE> <DEDENT> <DEDENT>
from queue import deque <NEWLINE> <NL> <NL> S = deque ( input ( ) ) <NEWLINE> y = 2019 <NEWLINE> U = [ 0 ] * y <NEWLINE> t = 0 <NEWLINE> U [ 0 ] = 1 <NEWLINE> k = 1 <NEWLINE> <NL> for s in reversed ( S ) : <NEWLINE> <INDENT> t = t + int ( s ) * k <NEWLINE> t %= y <NEWLINE> U [ t ] += 1 <NEWLINE> k *= 10 <NEWLINE> k %= y <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for u in U : <NEWLINE> <INDENT> cnt = cnt + u * ( u - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
s = list ( map ( int , list ( input ( ) ) [ : : - 1 ] ) ) <NEWLINE> n = len ( s ) <NEWLINE> cnt = [ 0 ] * 2019 <NEWLINE> cnt [ 0 ] += 1 <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c += s [ i ] * pow ( 10 , i , 2019 ) % 2019 <NEWLINE> cnt [ c % 2019 ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in cnt : <NEWLINE> <INDENT> if i <= 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Takeshi = math . ceil ( C / B ) <NEWLINE> Aoki = math . ceil ( A / D ) <NEWLINE> <NL> print ( <STRING> if Takeshi <= Aoki else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> LIMIT = 10 ** 9 <NEWLINE> lmt = 0 <NEWLINE> <NL> while lmt ** 5 - ( lmt - 1 ) ** 5 <= LIMIT : <NEWLINE> <INDENT> lmt += 1 <NEWLINE> <NL> <NL> <DEDENT> for a in range ( - lmt , lmt + 1 ) : <NEWLINE> <INDENT> for b in range ( - lmt , a + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = { } <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] in d : <NEWLINE> <INDENT> d [ a [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ a [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i in d : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> import time <NEWLINE> from itertools import permutations <NEWLINE> <NL> <NL> def solve1 ( pick , target ) : <NEWLINE> <COMMENT> <NL> <INDENT> hit = 0 <NEWLINE> for nums in permutations ( [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] , pick ) : <NEWLINE> <INDENT> temp = [ ] <NEWLINE> for i in range ( 1 , pick + 1 ) : <NEWLINE> <INDENT> temp . append ( <STRING> . format ( i , nums [ 0 ] ) ) <NEWLINE> nums = nums [ 1 : ] <NEWLINE> <DEDENT> exp = <STRING> . join ( temp ) <NEWLINE> ans = eval ( exp ) <NEWLINE> if ans == target : <NEWLINE> <COMMENT> <NL> <INDENT> hit += 1 <NEWLINE> <DEDENT> <DEDENT> return hit <NEWLINE> <NL> <NL> <DEDENT> def solve2 ( pick , target ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if target > 330 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> hit = 0 <NEWLINE> for nums in permutations ( [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] , pick ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( 1 , pick + 1 ) : <NEWLINE> <INDENT> ans += ( i * nums [ i - 1 ] ) <NEWLINE> if ans > target : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans == target : <NEWLINE> <INDENT> hit += 1 <NEWLINE> <DEDENT> <DEDENT> return hit <NEWLINE> <NL> <NL> <DEDENT> def solve3 ( pick , target ) : <NEWLINE> <COMMENT> <NL> <INDENT> if target > 330 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> hit = 0 <NEWLINE> for nums in permutations ( [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] , pick ) : <NEWLINE> <INDENT> temp = [ x * y for x , y in zip ( nums , [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ) ] <NEWLINE> ans = sum ( temp ) <NEWLINE> if ans == target : <NEWLINE> <INDENT> hit += 1 <NEWLINE> <DEDENT> <DEDENT> return hit <NEWLINE> <NL> <NL> <DEDENT> def calc_min_max ( pick , numbers ) : <NEWLINE> <COMMENT> <NL> <INDENT> multiplier = range ( 1 , pick + 1 ) <NEWLINE> min_numbers = numbers [ : pick ] <NEWLINE> min_numbers . sort ( reverse = True ) <NEWLINE> temp = [ x * y for x , y in zip ( min_numbers , multiplier ) ] <NEWLINE> min = sum ( temp ) <NEWLINE> <NL> numbers = numbers [ - pick : ] <NEWLINE> temp = [ x * y for x , y in zip ( numbers , multiplier ) ] <NEWLINE> max = sum ( temp ) <NEWLINE> <NL> return min , max <NEWLINE> <NL> <NL> <DEDENT> def solve4 ( pick , target , numbers = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> global Hit <NEWLINE> if pick == 0 : <NEWLINE> <INDENT> if target == 0 : <NEWLINE> <INDENT> Hit += 1 <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> for n in numbers : <NEWLINE> <INDENT> lnumbers = numbers [ : ] <NEWLINE> lnumbers . remove ( n ) <NEWLINE> p_min , p_max = calc_min_max ( pick - 1 , lnumbers ) <NEWLINE> if target - ( n * pick ) > p_max or target - ( n * pick ) < p_min : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> solve4 ( pick - 1 , target - ( n * pick ) , lnumbers ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def has_possibility ( pick , target , numbers ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if pick == 1 : <NEWLINE> <INDENT> return numbers [ 0 ] <= target <= numbers [ - 1 ] <NEWLINE> <NL> <DEDENT> multiplier = range ( 1 , pick + 1 ) <NEWLINE> max_numbers = numbers [ - pick : ] <COMMENT> <NEWLINE> max = sum ( x * y for x , y in zip ( max_numbers , multiplier ) ) <NEWLINE> if target > max : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> min_numbers = numbers [ : pick ] <NEWLINE> <COMMENT> <NL> min_numbers . reverse ( ) <NEWLINE> min = sum ( x * y for x , y in zip ( min_numbers , multiplier ) ) <NEWLINE> if target < min : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> Hit = 0 <NEWLINE> def solve5 ( pick , target , numbers = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> global Hit <NEWLINE> if pick == 1 : <NEWLINE> <INDENT> if target in numbers : <NEWLINE> <INDENT> Hit += 1 <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> for n in numbers : <NEWLINE> <INDENT> lnumbers = numbers [ : ] <NEWLINE> lnumbers . remove ( n ) <NEWLINE> if has_possibility ( pick - 1 , target - ( n * pick ) , lnumbers ) : <NEWLINE> <INDENT> solve5 ( pick - 1 , target - ( n * pick ) , lnumbers ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( args ) : <NEWLINE> <INDENT> global Hit <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> pick , target = [ int ( x ) for x in line . strip ( ) . split ( <STRING> ) ] <NEWLINE> solve5 ( pick , target ) <NEWLINE> print ( Hit ) <NEWLINE> Hit = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in ls : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for a in ls : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 ; <NEWLINE> break ; <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> uf = UnionFind ( N ) <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> uf . union ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE>
import string , sys <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> N = I ( ) <NEWLINE> abc = string . ascii_lowercase <NEWLINE> def main ( N ) : <NEWLINE> <INDENT> if N <= 26 : <NEWLINE> <INDENT> return abc [ N - 1 ] <NEWLINE> <DEDENT> if N % 26 == 0 : <NEWLINE> <INDENT> return main ( N // 26 - 1 ) + abc [ - 1 ] <NEWLINE> <DEDENT> return main ( N // 26 ) + abc [ N % 26 - 1 ] <NEWLINE> <DEDENT> print ( main ( N ) ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> S = int ( input ( ) ) <NEWLINE> dp = [ 0 ] * ( S + 4 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dp [ 3 ] = 1 <NEWLINE> for i in range ( 4 , S + 1 ) : <NEWLINE> <INDENT> for k in range ( i - 2 ) : <NEWLINE> <INDENT> dp [ i ] += dp [ k ] <NEWLINE> <DEDENT> <DEDENT> print ( dp [ S ] % MOD ) <NEWLINE>
<NL> x = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 100 ) : <NEWLINE> <INDENT> for j in range ( 100 ) : <NEWLINE> <INDENT> if pow ( i , 5 ) + pow ( j , 5 ) == x : <NEWLINE> <INDENT> print ( i , - j ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> return divisors <NEWLINE> <NL> <NL> <DEDENT> a = 0 <NEWLINE> for i in make_divisors ( x ) : <NEWLINE> <INDENT> a = i <NEWLINE> b = 0 <NEWLINE> while pow ( a , 5 ) - pow ( b , 5 ) <= x : <NEWLINE> <INDENT> if pow ( a , 5 ) - pow ( b , 5 ) == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> b += 1 <NEWLINE> a += 1 <NEWLINE> <DEDENT> <DEDENT>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> hw = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> hlist = [ 0 ] * ( h + 1 ) <NEWLINE> wlist = [ 0 ] * ( w + 1 ) <NEWLINE> for x , y in hw : <NEWLINE> <INDENT> hlist [ x ] += 1 <NEWLINE> wlist [ y ] += 1 <NEWLINE> <DEDENT> hmax = max ( hlist ) <NEWLINE> h_index = { n for n , v in enumerate ( hlist ) if v == hmax } <NEWLINE> wmax = max ( wlist ) <NEWLINE> w_index = { n for n , v in enumerate ( wlist ) if v == wmax } <NEWLINE> count = sum ( x in h_index and y in w_index for x , y in hw ) <NEWLINE> print ( hmax + wmax - ( len ( h_index ) * len ( w_index ) == count ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import numpy <NEWLINE> from collections import defaultdict <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> h , w , m = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> fieldh = numpy . zeros ( h , dtype = numpy . int ) <NEWLINE> fieldw = numpy . zeros ( w , dtype = numpy . int ) <NEWLINE> field = defaultdict ( int ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> ih , iw = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> fieldh [ ih - 1 ] += 1 <NEWLINE> fieldw [ iw - 1 ] += 1 <NEWLINE> field [ ih - 1 , iw - 1 ] = 1 <NEWLINE> <NL> <DEDENT> max_h = numpy . max ( fieldh ) <NEWLINE> max_w = numpy . max ( fieldw ) <NEWLINE> argsort_h = [ ih for ih in range ( h ) if fieldh [ ih ] == max_h ] <NEWLINE> argsort_w = [ iw for iw in range ( w ) if fieldw [ iw ] == max_w ] <NEWLINE> <NL> max_cnt = 0 <NEWLINE> for ih in argsort_h : <NEWLINE> <INDENT> for iw in argsort_w : <NEWLINE> <INDENT> if field [ ih , iw ] == 0 : <NEWLINE> <INDENT> max_cnt = max ( max_cnt , fieldh [ ih ] + fieldw [ iw ] ) <NEWLINE> print ( max_cnt ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_cnt = max ( max_cnt , fieldh [ ih ] + fieldw [ iw ] - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max_cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
while 1 : <NEWLINE> <INDENT> INF = 10 ** 9 <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == K == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> E = [ [ INF ] * N for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> E [ i ] [ i ] = 0 <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> q , * c = map ( int , input ( ) . split ( ) ) <NEWLINE> if q == 0 : <NEWLINE> <INDENT> a , b = c <NEWLINE> cost = E [ a - 1 ] [ b - 1 ] <NEWLINE> if INF <= cost : <NEWLINE> <INDENT> ans . append ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( cost ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> c , d , e = c <NEWLINE> if e < E [ c - 1 ] [ d - 1 ] : <NEWLINE> <INDENT> E [ c - 1 ] [ d - 1 ] = E [ d - 1 ] [ c - 1 ] = e <NEWLINE> Ec = E [ c - 1 ] ; Ed = E [ d - 1 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Ei = E [ i ] <NEWLINE> Eic = Ei [ c - 1 ] + e <NEWLINE> Eid = Ei [ d - 1 ] + e <NEWLINE> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> Ei [ j ] = E [ j ] [ i ] = min ( Ei [ j ] , Eic + Ed [ j ] , Eid + Ec [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <DEDENT>
input ( ) <NEWLINE> ans = 1 <NEWLINE> for i in sorted ( map ( int , input ( ) . split ( ) ) ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : ans = - 1 <NEWLINE> if - 1 <= ans <= 0 : break <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
<COMMENT> <NL> S = str ( input ( ) ) ; l = len ( S ) ; Str = <STRING> <NEWLINE> for num in range ( l ) : <NEWLINE> <INDENT> if S [ num ] != <STRING> : <NEWLINE> <INDENT> Str += S [ num ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Str += <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( Str ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( B - 1 , N ) <NEWLINE> max1 = int ( A * x / B ) - A * int ( x / B ) <NEWLINE> print ( max1 ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if a >= k : <NEWLINE> <INDENT> ans = k <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> elif a + b >= k : <NEWLINE> <INDENT> ans = ( k - b ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> elif a + b + c >= k : <NEWLINE> <INDENT> ans = a + ( k - a - b ) * ( - 1 ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
<NL> import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> box = [ 0 ] * ( k + 1 ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for m in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> box [ math . gcd ( l , m ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for n in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> s += math . gcd ( l , n ) * box [ l ] <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> ab = 0 <NEWLINE> num = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s [ 0 ] == <STRING> and s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> ab += 1 <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> elif s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> for j in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> and s [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if a != 0 and b != 0 : <NEWLINE> <INDENT> num += ab + 1 <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> num += min ( a , b ) <NEWLINE> <DEDENT> elif a != 0 : <NEWLINE> <INDENT> num += ab <NEWLINE> <DEDENT> elif b != 0 : <NEWLINE> <INDENT> num += ab <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num += max ( 0 , ab - 1 ) <NEWLINE> <DEDENT> print ( num ) <NEWLINE>
input ( ) ; a = sorted ( map ( int , input ( ) . split ( ) ) ) ; z = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> z *= i <NEWLINE> if z > 1e18 : z = - 1 ; break <NEWLINE> <DEDENT> print ( z ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if N == 1 : print ( 1 ) ; exit ( ) ; <NEWLINE> x = [ None ] * N <NEWLINE> y = [ None ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x [ i ] , y [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> diff = [ ] <NEWLINE> nums = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( x [ j ] - x [ i ] , y [ j ] - y [ i ] ) in diff : <NEWLINE> <INDENT> nums [ diff . index ( ( x [ j ] - x [ i ] , y [ j ] - y [ i ] ) ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff . append ( ( x [ j ] - x [ i ] , y [ j ] - y [ i ] ) ) <NEWLINE> nums . append ( 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( N - max ( nums ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> tmp = n // i <NEWLINE> ans += tmp * ( i + n // i * i ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a0 = a [ 0 ] <NEWLINE> a_else = a [ 1 : ] <NEWLINE> th = 10 ** 18 <NEWLINE> for ai in sorted ( a_else ) : <NEWLINE> <INDENT> a0 *= ai <NEWLINE> if a0 > th : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a0 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 1000000007 <NEWLINE> x = sum ( A ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x -= A [ i ] <NEWLINE> y = x % MOD <NEWLINE> z = ( A [ i ] * y ) % MOD <NEWLINE> ans += z <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> D = Counter ( ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> T = Counter ( ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> <NL> for difficult , count in T . items ( ) : <NEWLINE> <INDENT> if difficult in D and D [ difficult ] >= count : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
k , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> [ k - a [ - 1 ] + a [ 0 ] ] <NEWLINE> d = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> d . append ( a [ i ] - a [ i - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> d . append ( k - a [ - 1 ] + a [ 0 ] ) <NEWLINE> print ( k - max ( d ) ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A , B = [ ] , [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <DEDENT> A . reverse ( ) <NEWLINE> B . reverse ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for a , b in zip ( A , B ) : <NEWLINE> <INDENT> a += cnt <NEWLINE> cnt += math . ceil ( a / b ) * b - a <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> c = Counter ( s ) <NEWLINE> cnt = c [ <STRING> ] * c [ <STRING> ] * c [ <STRING> ] <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> w = j - i <NEWLINE> if j + w >= n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ j + w ] != s [ j ] and s [ j + w ] != s [ i ] : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import itertools <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> m = list ( ) <NEWLINE> res = - 100 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m . append ( n ) <NEWLINE> <DEDENT> l = [ x for x in range ( 1 , M + 1 ) ] <NEWLINE> p = itertools . combinations_with_replacement ( l , N ) <NEWLINE> for p in p : <NEWLINE> <INDENT> total = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a = m [ i ] [ 0 ] <NEWLINE> b = m [ i ] [ 1 ] <NEWLINE> A = p [ a - 1 ] <NEWLINE> B = p [ b - 1 ] <NEWLINE> C = B - A <NEWLINE> if m [ i ] [ 2 ] == C : <NEWLINE> <INDENT> total = total + m [ i ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if res < total : <NEWLINE> <INDENT> res = total <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
print ( input ( ) [ : : - 1 ] ) <NEWLINE>
N , = input ( ) . split ( ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> ans = [ 0 ] * 2000001 <NEWLINE> for i in range ( int ( N ) - 1 ) : <NEWLINE> <INDENT> ans [ int ( A [ i ] ) ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , int ( N ) + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
from heapq import heappop , heapify , heappush <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> work = [ [ ] for _ in range ( 10 ** 5 + 1 ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> work [ a ] . append ( b ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> q = [ ] <NEWLINE> heapify ( q ) <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> for w in work [ i ] : <NEWLINE> <INDENT> heappush ( q , - w ) <NEWLINE> <DEDENT> if len ( q ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += heappop ( q ) <NEWLINE> <DEDENT> ans *= - 1 <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = 0 <NEWLINE> s = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> s += ( List [ i ] + 1 ) <NEWLINE> <DEDENT> num = 0 <NEWLINE> <COMMENT> <NL> if N == K : <NEWLINE> <INDENT> print ( s / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> for i in range ( N - K ) : <NEWLINE> <INDENT> a = List [ i + K ] - List [ i ] <NEWLINE> <COMMENT> <NL> n1 = s + a <NEWLINE> s = n1 <NEWLINE> n1 = n1 / 2 <NEWLINE> if n1 >= num : <NEWLINE> <INDENT> num = n1 <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> cnt_R = S . count ( <STRING> ) <NEWLINE> cnt_G = S . count ( <STRING> ) <NEWLINE> cnt_B = S . count ( <STRING> ) <NEWLINE> total = cnt_R * cnt_G * cnt_B <NEWLINE> <NL> expt = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k < N and ( S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ i ] != S [ k ] ) : <NEWLINE> <INDENT> expt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total - expt ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> x , y , k = 0 , 0 , 0 <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif N <= 12 : <NEWLINE> <INDENT> print ( N ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> x = int ( 0.8 * N ) <NEWLINE> <NL> for i in range ( x , N ) : <NEWLINE> <INDENT> k = str ( i * 108 ) <NEWLINE> if int ( k [ 0 : - 2 ] ) == N : <NEWLINE> <INDENT> print ( i ) <NEWLINE> y += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if y != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> def readinput ( ) : <NEWLINE> <INDENT> n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> return n , m , k , a , b <NEWLINE> <NL> <DEDENT> def main ( n , m , k , a , b ) : <NEWLINE> <INDENT> qa = deque ( a ) <NEWLINE> qb = deque ( b ) <NEWLINE> count = 0 <NEWLINE> res = k <NEWLINE> while ( len ( qa ) > 0 and len ( qb ) > 0 ) : <NEWLINE> <INDENT> if qa [ 0 ] < qb [ 0 ] : <NEWLINE> <INDENT> res -= qa [ 0 ] <NEWLINE> qa . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res -= qb [ 0 ] <NEWLINE> qb . popleft ( ) <NEWLINE> <DEDENT> if res < 0 : <NEWLINE> <INDENT> return count <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( qa ) == 0 : <NEWLINE> <INDENT> while ( len ( qb ) > 0 ) : <NEWLINE> <INDENT> res -= qb [ 0 ] <NEWLINE> qb . popleft ( ) <NEWLINE> if res < 0 : <NEWLINE> <INDENT> return count <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> return count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while ( len ( qa ) > 0 ) : <NEWLINE> <INDENT> res -= qa [ 0 ] <NEWLINE> qa . popleft ( ) <NEWLINE> if res < 0 : <NEWLINE> <INDENT> return count <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> return count <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> import sys <NEWLINE> INFTY = sys . maxsize <NEWLINE> def find ( t , s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ss = s [ : ] <NEWLINE> ss . append ( INFTY ) <NEWLINE> left = 0 <NEWLINE> right = len ( ss ) <NEWLINE> while ( left < right ) : <NEWLINE> <INDENT> middle = ( left + right ) // 2 <NEWLINE> <COMMENT> <NL> if ss [ middle ] == t : <NEWLINE> <COMMENT> <NL> <INDENT> return middle <NEWLINE> <DEDENT> if t < ss [ middle ] : <NEWLINE> <INDENT> right = middle <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = middle + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return left - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def main2 ( n , m , k , a , b ) : <NEWLINE> <INDENT> sa = [ 0 ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> sa . append ( sa [ i - 1 ] + a [ i - 1 ] ) <NEWLINE> <DEDENT> sb = [ 0 ] <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> sb . append ( sb [ i - 1 ] + b [ i - 1 ] ) <NEWLINE> <DEDENT> maxab = 0 <NEWLINE> nb = m + 1 <NEWLINE> for na in range ( 0 , n + 1 ) : <NEWLINE> <INDENT> res = k - sa [ na ] <NEWLINE> if res >= 0 : <NEWLINE> <INDENT> nb = find ( res , sb [ : nb + 1 ] ) <NEWLINE> <COMMENT> <NL> maxab = max ( maxab , na + nb ) <NEWLINE> <DEDENT> <DEDENT> return maxab <NEWLINE> <NL> <DEDENT> from bisect import bisect_left , bisect_right <NEWLINE> def find_le ( a , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> i = bisect_right ( a , x ) <NEWLINE> if i : <NEWLINE> <INDENT> return i - 1 <NEWLINE> <DEDENT> raise ValueError <NEWLINE> <NL> <DEDENT> def main3 ( n , m , k , a , b ) : <NEWLINE> <INDENT> sa = [ 0 ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> sa . append ( sa [ i - 1 ] + a [ i - 1 ] ) <NEWLINE> <DEDENT> sb = [ 0 ] <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> sb . append ( sb [ i - 1 ] + b [ i - 1 ] ) <NEWLINE> <DEDENT> maxab = 0 <NEWLINE> nb = m + 1 <NEWLINE> for na in range ( 0 , n + 1 ) : <NEWLINE> <INDENT> res = k - sa [ na ] <NEWLINE> if res >= 0 : <NEWLINE> <INDENT> nb = find_le ( sb , res ) <NEWLINE> <COMMENT> <NL> maxab = max ( maxab , na + nb ) <NEWLINE> <DEDENT> <DEDENT> return maxab <NEWLINE> <NL> <DEDENT> def main4 ( n , m , k , a , b ) : <NEWLINE> <INDENT> sa = [ 0 ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> sa . append ( sa [ i - 1 ] + a [ i - 1 ] ) <NEWLINE> <DEDENT> sb = [ 0 ] <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> sb . append ( sb [ i - 1 ] + b [ i - 1 ] ) <NEWLINE> <DEDENT> maxab = 0 <NEWLINE> nb = m <NEWLINE> for na in range ( 0 , n + 1 ) : <NEWLINE> <INDENT> res = k - sa [ na ] <NEWLINE> while res < sb [ nb ] and nb >= 0 : <NEWLINE> <INDENT> nb -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if nb >= 0 : <NEWLINE> <INDENT> maxab = max ( maxab , na + nb ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> return maxab <NEWLINE> <NL> <DEDENT> def readinput2 ( ) : <NEWLINE> <INDENT> m = 2 * 10 ** 5 <NEWLINE> n = 2 * 10 ** 5 <NEWLINE> a = [ 10 ** 9 ] * n <NEWLINE> b = [ 10 ** 9 ] * m <NEWLINE> k = 1 <NEWLINE> return n , m , k , a , b <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m , k , a , b = readinput ( ) <NEWLINE> ans = main3 ( n , m , k , a , b ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
al = list ( <STRING> ) <NEWLINE> <NL> s = list ( input ( ) ) <NEWLINE> for i in s : <NEWLINE> <INDENT> if i in al : <NEWLINE> <INDENT> del al [ al . index ( i ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( al ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( al [ 0 ] ) <NEWLINE> <DEDENT>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> while 1 : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> * S , = map ( int , input ( ) . split ( ) ) <NEWLINE> D = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> SA = sum ( S ) <NEWLINE> rest = sum ( d - SA for d in D if SA <= d ) <NEWLINE> <NL> memo = { 2 ** n - 1 : rest } <NEWLINE> def dfs ( state , su , idx ) : <NEWLINE> <INDENT> if state in memo : <NEWLINE> <INDENT> return memo [ state ] <NEWLINE> <DEDENT> res = 10 ** 18 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( state >> i ) & 1 == 0 : <NEWLINE> <INDENT> s = 0 ; j = idx <NEWLINE> nxt = su + S [ i ] <NEWLINE> while j < m and D [ j ] <= nxt : <NEWLINE> <INDENT> s += min ( nxt - D [ j ] , D [ j ] - su ) ; j += 1 <NEWLINE> <DEDENT> res = min ( res , s + dfs ( state | ( 1 << i ) , su + S [ i ] , j ) ) <NEWLINE> <DEDENT> <DEDENT> memo [ state ] = res <NEWLINE> return res <NEWLINE> <DEDENT> print ( dfs ( 0 , 0 , 0 ) ) <NEWLINE> <DEDENT>
data = input ( ) . split ( ) <NEWLINE> a = int ( data [ 0 ] ) <NEWLINE> b = int ( data [ 1 ] ) <NEWLINE> c = int ( data [ 2 ] ) <NEWLINE> k = int ( data [ 3 ] ) <NEWLINE> ans = 0 <NEWLINE> <NL> if k - a > 0 : <NEWLINE> <INDENT> ans += a <NEWLINE> k -= a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += k <NEWLINE> k = 0 <NEWLINE> <DEDENT> if k - b > 0 : <NEWLINE> <INDENT> k -= b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = 0 <NEWLINE> <DEDENT> ans -= k <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> total = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <NL> lR = [ 0 ] * n <NEWLINE> lG = [ 0 ] * n <NEWLINE> lB = [ 0 ] * n <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> lR [ i ] += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> lG [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lB [ i ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> j = 1 <NEWLINE> if lR [ i ] : <NEWLINE> <INDENT> while i - j >= 0 and i + j < n : <NEWLINE> <INDENT> if lG [ i + j ] != 0 and lG [ i + j ] == lB [ i - j ] : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <DEDENT> elif lG [ i - j ] != 0 and lG [ i - j ] == lB [ i + j ] : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> elif lG [ i ] : <NEWLINE> <INDENT> while i - j >= 0 and i + j < n : <NEWLINE> <INDENT> if lR [ i + j ] != 0 and lR [ i + j ] == lB [ i - j ] : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <DEDENT> elif lR [ i - j ] != 0 and lR [ i - j ] == lB [ i + j ] : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> elif lB [ i ] : <NEWLINE> <INDENT> while i - j >= 0 and i + j < n : <NEWLINE> <INDENT> if lG [ i + j ] != 0 and lG [ i + j ] == lR [ i - j ] : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <DEDENT> elif lG [ i - j ] != 0 and lG [ i - j ] == lR [ i + j ] : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> numbers = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> numOfOperation = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> <NL> for num in numbers : <NEWLINE> <INDENT> if num in dic : dic [ num ] += 1 <NEWLINE> else : dic [ num ] = 1 <NEWLINE> <NL> <NL> <DEDENT> sums = sum ( numbers ) <NEWLINE> for i in range ( numOfOperation ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( B in dic ) : <NEWLINE> <INDENT> cnt = dic [ B ] <NEWLINE> dic [ B ] = 0 <NEWLINE> if ( C not in dic ) : dic [ C ] = cnt <NEWLINE> else : dic [ C ] += cnt <NEWLINE> sums += cnt * ( C - B ) <NEWLINE> <DEDENT> print ( sums ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( pow ( 10 , 6 ) ) <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> def dfs ( nw , d ) : <NEWLINE> <INDENT> V [ nw ] = d <NEWLINE> for nx in G [ nw ] : <NEWLINE> <INDENT> if V [ nx [ 0 ] ] == - 1 : <NEWLINE> <INDENT> dfs ( nx [ 0 ] , d + nx [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( readline ( ) ) <NEWLINE> G = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , readline ( ) . split ( ) ) <NEWLINE> G [ a - 1 ] . append ( ( b - 1 , c ) ) <NEWLINE> G [ b - 1 ] . append ( ( a - 1 , c ) ) <NEWLINE> <DEDENT> q , k = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> V = [ - 1 ] * n <NEWLINE> dfs ( k - 1 , 0 ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> x , y = map ( lambda x : int ( x ) - 1 , readline ( ) . split ( ) ) <NEWLINE> print ( V [ x ] + V [ y ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> d = [ 0 , 0 , 0 ] <NEWLINE> for i in s : <NEWLINE> <INDENT> if ( i == <STRING> ) : d [ 0 ] += 1 <NEWLINE> elif ( i == <STRING> ) : d [ 1 ] += 1 <NEWLINE> elif ( i == <STRING> ) : d [ 2 ] += 1 <NEWLINE> <DEDENT> c = d [ 0 ] * d [ 1 ] * d [ 2 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if ( k >= n ) : continue <NEWLINE> if ( s [ i ] == s [ j ] ) : continue <NEWLINE> if ( s [ j ] == s [ k ] ) : continue <NEWLINE> if ( s [ i ] == s [ k ] ) : continue <NEWLINE> c -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> % ( r ** 2 * math . pi ) , <STRING> % ( r * 2 * math . pi ) ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> if a % b == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( gcd ( a , b ) , a // gcd ( a , b ) * b ) <NEWLINE> <DEDENT>
days = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> nums = [ 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> m , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if not m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( days [ ( sum ( nums [ : m - 1 ] ) + d + 2 ) % 7 ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mat = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> mat [ i ] [ j ] = r [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> mat [ i ] [ - 1 ] += mat [ i ] [ j ] <NEWLINE> mat [ - 1 ] [ j ] += mat [ i ] [ j ] <NEWLINE> <DEDENT> mat [ - 1 ] [ - 1 ] += mat [ i ] [ - 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> print ( * mat [ i ] ) <NEWLINE> <NL> <NL> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> class Cell ( object ) : <NEWLINE> <INDENT> __slots__ = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> def __init__ ( self , value = None , pre = None , _next = None ) : <NEWLINE> <INDENT> if pre is None and _next is None : <NEWLINE> <INDENT> self . value = None <NEWLINE> self . pre = self <NEWLINE> self . next = self <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . value = value <NEWLINE> self . pre = pre <NEWLINE> self . next = _next <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class MyList ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . _nil = Cell ( ) <NEWLINE> <NL> <DEDENT> def insert ( self , value ) : <NEWLINE> <INDENT> self . _nil . next = Cell ( value , self . _nil , self . _nil . next ) <NEWLINE> self . _nil . next . next . pre = self . _nil . next <NEWLINE> <NL> <DEDENT> def delete ( self , value ) : <NEWLINE> <INDENT> self . _delete_to ( self . _search ( value ) ) <NEWLINE> <NL> <DEDENT> def delete_first ( self ) : <NEWLINE> <INDENT> self . _delete_to ( self . _nil . next ) <NEWLINE> <NL> <DEDENT> def delete_last ( self ) : <NEWLINE> <INDENT> self . _delete_to ( self . _nil . pre ) <NEWLINE> <NL> <DEDENT> def toList ( self ) : <NEWLINE> <INDENT> gen = self . _val_generator ( ) <NEWLINE> return [ val for val in gen ( ) ] <NEWLINE> <NL> <DEDENT> def _val_generator ( self ) : <NEWLINE> <INDENT> def gen ( ) : <NEWLINE> <INDENT> current = self . _nil . next <NEWLINE> while current is not self . _nil : <NEWLINE> <INDENT> yield current . value <NEWLINE> current = current . next <NEWLINE> <DEDENT> <DEDENT> return gen <NEWLINE> <NL> <DEDENT> def _delete_to ( self , cell ) : <NEWLINE> <INDENT> if cell is not self . _nil : <NEWLINE> <INDENT> cell . next . pre = cell . pre <NEWLINE> cell . pre . next = cell . next <NEWLINE> <NL> <DEDENT> <DEDENT> def _search ( self , value ) : <NEWLINE> <INDENT> current = self . _nil . next <NEWLINE> while current is not self . _nil and current . value != value : <NEWLINE> <INDENT> current = current . next <NEWLINE> <DEDENT> return current <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def doubly_inked_list ( commands ) : <NEWLINE> <INDENT> lst = MyList ( ) <NEWLINE> for command in commands : <NEWLINE> <INDENT> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> lst . insert ( command [ 1 ] ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> lst . delete ( command [ 1 ] ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> lst . delete_first ( ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> lst . delete_last ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError <NEWLINE> <DEDENT> <DEDENT> return lst . toList ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> commands = [ val . split ( ) for val in sys . stdin . read ( ) . splitlines ( ) ] <NEWLINE> pop = commands . pop ( 0 ) <NEWLINE> print ( <STRING> . join ( doubly_inked_list ( commands ) ) ) <NEWLINE> <DEDENT>
def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def lmi ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ii ( ) : return int ( input ( ) ) <NEWLINE> def isp ( ) : return input ( ) . split ( ) <NEWLINE> <NL> <NL> <NL> n = ii ( ) <NEWLINE> a = lmi ( ) <NEWLINE> S = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> S = S ^ i <NEWLINE> <NL> <DEDENT> b = [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> a_ = S ^ i <NEWLINE> b . append ( a_ ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , b ) ) ) <NEWLINE>
def f ( n , cnt ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return cnt <NEWLINE> <DEDENT> popcnt = bin ( n ) . count ( <STRING> ) <NEWLINE> return f ( n % popcnt , cnt + 1 ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> <NL> m = int ( x , 2 ) <NEWLINE> m_cnt = x . count ( <STRING> ) <NEWLINE> <NL> mp = m % ( m_cnt + 1 ) <NEWLINE> mm = m % ( m_cnt - 1 ) if m_cnt > 1 else 0 <NEWLINE> <NL> for i , s in enumerate ( x ) : <NEWLINE> <INDENT> i = n - 1 - i <NEWLINE> num = None <NEWLINE> <NL> if s == <STRING> : <NEWLINE> <INDENT> mod = m_cnt + 1 <NEWLINE> num = ( mp + pow ( 2 , i , mod ) ) % mod <NEWLINE> <DEDENT> elif m_cnt > 1 : <NEWLINE> <INDENT> mod = m_cnt - 1 <NEWLINE> num = ( mm - pow ( 2 , i , mod ) ) % mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> print ( 1 + f ( num , 0 ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> <COMMENT> <NL> arr = factorization ( n ) <NEWLINE> <NL> cnt = 1 <NEWLINE> ans = 0 <NEWLINE> flag = False <NEWLINE> while True : <NEWLINE> <INDENT> for k in arr : <NEWLINE> <INDENT> if k [ 1 ] >= cnt : <NEWLINE> <INDENT> k [ 1 ] -= cnt <NEWLINE> ans += 1 <NEWLINE> flag = True <NEWLINE> <DEDENT> <DEDENT> if not flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> flag = False <NEWLINE> <NL> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
def fib ( n ) : <NEWLINE> <INDENT> n1 = n2 = tmp = 1 <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> tmp = n1 + n2 <NEWLINE> n1 , n2 = n2 , tmp <NEWLINE> <DEDENT> return tmp <NEWLINE> <NL> <DEDENT> print ( fib ( int ( input ( ) ) ) ) <NEWLINE>
import math <NEWLINE> <NL> class common_function ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def lcm ( self , x : int , y : int ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> common = common_function ( ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> lengthX = common . lcm ( N , M ) <NEWLINE> XdivS = lengthX // N <NEWLINE> XdivT = lengthX // M <NEWLINE> X = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> j = XdivS * i <NEWLINE> X . append ( ( j , S [ i ] ) ) <NEWLINE> <DEDENT> X . sort ( key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> <NL> k , x = X . pop ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> j = XdivT * i <NEWLINE> for a in range ( lengthX ) : <NEWLINE> <INDENT> if len ( X ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if k < j : <NEWLINE> <INDENT> k , x = X . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if k == j : <NEWLINE> <INDENT> if x != T [ i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( lengthX ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum_A = sum ( A ) <NEWLINE> count = N <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> sum_A -= A [ i ] <NEWLINE> if ( sum_A ) * 2 >= A [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if ( i == 0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> count -= len ( A [ 0 : i ] ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> <NL> i = 0 <NEWLINE> a , b = 0 , 0 <NEWLINE> while i ** 5 < x : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> mx = i <NEWLINE> for k in range ( 2 * ( mx + 1 ) ) : <NEWLINE> <INDENT> for j in range ( - k , k + 1 ) : <NEWLINE> <INDENT> if k ** 5 - j ** 5 == x : <NEWLINE> <INDENT> a , b = k , j <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE>
import math <NEWLINE> <NL> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> dist = math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) <NEWLINE> print ( dist ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> cnt = [ 0 ] * 3 <NEWLINE> ans = 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : cnt [ 0 ] += 1 <NEWLINE> elif i == <STRING> : cnt [ 1 ] += 1 <NEWLINE> else : cnt [ 2 ] += 1 <NEWLINE> <DEDENT> for i in cnt : <NEWLINE> <INDENT> ans *= i <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k < n : <NEWLINE> <INDENT> if s [ i ] == s [ j ] : continue <NEWLINE> if s [ j ] == s [ k ] : continue <NEWLINE> if s [ k ] == s [ i ] : continue <NEWLINE> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math as np <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> % ( np . pi * r * r , np . pi * 2 * r ) ) <NEWLINE> <NL>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> <NL> <NL> Area_memo = [ 0 for _ in range ( 10002 ) ] <COMMENT> <NEWLINE> Area_memo [ 0 ] = 1 <NEWLINE> def count_area ( num ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global Area_memo <NEWLINE> if Area_memo [ num ] == 0 : <NEWLINE> <INDENT> Area_memo [ num ] = num + count_area ( num - 1 ) <NEWLINE> <DEDENT> return Area_memo [ num ] <NEWLINE> <NL> <NL> <DEDENT> def count_area2 ( num ) : <NEWLINE> <INDENT> wa = num * ( 1 + num ) // 2 <NEWLINE> return wa + 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> def main ( args ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> num = int ( line . strip ( ) ) <NEWLINE> result = count_area2 ( num ) <NEWLINE> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ i + a for i , a in enumerate ( s ) ] <NEWLINE> R = [ i - a for i , a in enumerate ( s ) ] <NEWLINE> t = collections . Counter ( L ) <NEWLINE> u = collections . Counter ( R ) <NEWLINE> ans = 0 <NEWLINE> for i in t . keys ( ) : <NEWLINE> <INDENT> ans += t [ i ] * u [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = 0 <NEWLINE> <NL> D = { } <NEWLINE> <NL> for j in range ( N ) : <NEWLINE> <INDENT> if j + A [ j ] in D : <NEWLINE> <INDENT> D [ j + A [ j ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D [ j + A [ j ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> if j - A [ j ] in D : <NEWLINE> <INDENT> result += D [ j - A [ j ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
def two ( a ) : <NEWLINE> <INDENT> if 0 in a : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> res = 1 <NEWLINE> for el in a : <NEWLINE> <INDENT> res *= el <NEWLINE> if res > 1e18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( two ( a ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N >= 1000 : <NEWLINE> <INDENT> M = str ( N ) <NEWLINE> X = M [ 1 : ] <NEWLINE> O = int ( X ) <NEWLINE> if O == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - O ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> O = int ( N ) <NEWLINE> print ( 1000 - O ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k <= N - 1 : <NEWLINE> <INDENT> if S [ j ] != S [ i ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> xx = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> yy = sorted ( xx ) <NEWLINE> <NL> a = yy [ n // 2 - 1 ] <NEWLINE> b = yy [ n // 2 ] <NEWLINE> <NL> for x in xx : <NEWLINE> <INDENT> if x <= a : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif x >= b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( n >= b - 1 ) : <NEWLINE> <INDENT> print ( a * ( b - 1 ) // b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a * n // b ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ [ 0 for i in range ( m ) ] for j in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> b = [ 0 for j in range ( m ) ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> b [ j ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> c = [ 0 for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> c [ i ] += a [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( i + 1 + x [ i ] ) <NEWLINE> b . append ( i + 1 - x [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> a , b = Counter ( a ) , Counter ( b ) <NEWLINE> for i in range ( min ( a ) , max ( b ) + 1 ) : <NEWLINE> <INDENT> ans += a [ i ] * b [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> a_list = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> l = defaultdict ( int ) <NEWLINE> r = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l [ i + a_list [ i ] ] += 1 <NEWLINE> r [ i - a_list [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for x in l . keys ( ) : <NEWLINE> <INDENT> ans += l [ x ] * r [ x ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = ( [ 0 ] * 1000001 ) <NEWLINE> a . sort ( ) <NEWLINE> for i in a : <NEWLINE> <INDENT> s [ i ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for j in range ( 1000001 ) : <NEWLINE> <INDENT> if s [ j ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> if s [ j ] > 0 : <NEWLINE> <INDENT> for k in range ( j , 1000001 , j ) : <NEWLINE> <INDENT> s [ k ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> root = [ i for i in range ( n ) ] <NEWLINE> height = [ 1 for i in range ( n ) ] <NEWLINE> def find ( n ) : <NEWLINE> <INDENT> sn = n <NEWLINE> while n != root [ n ] : <NEWLINE> <INDENT> n = root [ n ] <NEWLINE> <DEDENT> root [ sn ] = n <NEWLINE> return n <NEWLINE> <DEDENT> def union ( a , b ) : <NEWLINE> <INDENT> a = find ( a ) <NEWLINE> b = find ( b ) <NEWLINE> if a == b : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> elif height [ a ] >= height [ b ] : <NEWLINE> <INDENT> height [ a ] += height [ b ] <NEWLINE> height [ b ] = 0 <NEWLINE> root [ b ] = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> height [ b ] += height [ a ] <NEWLINE> height [ a ] = 0 <NEWLINE> root [ a ] = b <NEWLINE> <DEDENT> <DEDENT> l = [ set ( ) for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> union ( a , b ) <NEWLINE> l [ a ] . add ( b ) <NEWLINE> l [ b ] . add ( a ) <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> if find ( a ) == find ( b ) : <NEWLINE> <INDENT> l [ a ] . add ( b ) <NEWLINE> l [ b ] . add ( a ) <NEWLINE> <DEDENT> <DEDENT> print ( * [ height [ find ( i ) ] - len ( l [ i ] ) - 1 for i in range ( n ) ] ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , M = LI ( ) <NEWLINE> cnt = [ 0 ] * N <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = LI_ ( ) <NEWLINE> cnt [ a ] += 1 <NEWLINE> cnt [ b ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if len ( [ i for i in cnt if i % 2 == 0 ] ) == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K - 1 , N - 1 ) : <NEWLINE> <INDENT> if A [ i + 1 - K ] < A [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n >= m : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> x = sorted ( x ) <NEWLINE> l = [ 0 ] * ( m - 1 ) <NEWLINE> for i in range ( m - 1 ) : <NEWLINE> <INDENT> l [ i ] = x [ i + 1 ] - x [ i ] <NEWLINE> <NL> <DEDENT> l = sorted ( l ) [ : : - 1 ] <NEWLINE> dist = x [ m - 1 ] - x [ 0 ] - sum ( l [ : n - 1 ] ) <NEWLINE> print ( dist ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) - 1 ) <NEWLINE> <NL> <DEDENT> visited = [ False ] * n <NEWLINE> f = 0 <NEWLINE> visited [ f ] = True <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> t = a [ f ] <NEWLINE> if t == 1 : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <DEDENT> if visited [ t ] : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <DEDENT> visited [ t ] = True <NEWLINE> f = t <NEWLINE> <DEDENT> print ( cnt ) if flg else print ( - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> a . append ( A ) <NEWLINE> <NL> <DEDENT> b = sorted ( a ) <NEWLINE> <NL> m = max ( a ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == m : <NEWLINE> <INDENT> ans . append ( b [ - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( m ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <NL> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> M = int ( next ( tokens ) ) <COMMENT> <NEWLINE> X = int ( next ( tokens ) ) <COMMENT> <NEWLINE> A = np . zeros ( ( N , M + 1 ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = [ int ( next ( tokens ) ) for _ in range ( M + 1 ) ] <NEWLINE> <NL> <DEDENT> min_c = [ 10000000 ] <NEWLINE> <NL> def dfs ( k , dep ) : <NEWLINE> <INDENT> if dep == N - 1 : <NEWLINE> <INDENT> if ( k [ 1 : ] >= X ) . all ( ) : <NEWLINE> <INDENT> min_c [ 0 ] = min ( min_c [ 0 ] , k [ 0 ] ) <NEWLINE> <DEDENT> elif ( ( k + A [ dep ] ) [ 1 : ] >= X ) . all ( ) : <NEWLINE> <INDENT> min_c [ 0 ] = min ( min_c [ 0 ] , k [ 0 ] + A [ dep ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dfs ( k + A [ dep ] , dep + 1 ) <NEWLINE> dfs ( k , dep + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( np . zeros ( M + 1 ) , 0 ) <NEWLINE> <NL> if min_c [ 0 ] != 10000000 : <NEWLINE> <INDENT> print ( int ( min_c [ 0 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> X = abs ( X ) <NEWLINE> <NL> if X >= K * D : <NEWLINE> <INDENT> ans = X - K * D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = X // D <NEWLINE> if ( K - x ) % 2 == 0 : <NEWLINE> <INDENT> ans = X - x * D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = abs ( X - x * D - D ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> if R - L >= 2019 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = R * R <NEWLINE> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , ( i * j ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if N % K == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> et = N // K <NEWLINE> a1 = et * K <NEWLINE> a2 = ( et + 1 ) * K <NEWLINE> mi = min ( abs ( a1 - N ) , abs ( a2 - N ) ) <NEWLINE> print ( mi ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num_list = [ 1 ] <NEWLINE> n_set = set ( [ 1 ] ) <NEWLINE> flag = True <NEWLINE> while flag : <NEWLINE> <INDENT> tmp = a_list [ num_list [ - 1 ] - 1 ] <NEWLINE> if tmp in n_set : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n_set . add ( tmp ) <NEWLINE> num_list . append ( tmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> idx = num_list . index ( tmp ) <NEWLINE> loop = len ( num_list ) - idx <NEWLINE> if k < idx : <NEWLINE> <INDENT> print ( num_list [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( num_list [ ( k - idx ) % loop + idx ] ) <NEWLINE> <DEDENT>
INTMAX = ( 1 << 31 ) - 1 <NEWLINE> <NL> def ans ( ) : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> x = i + OFS <NEWLINE> A [ x ] = arr [ i ] <NEWLINE> while True : <NEWLINE> <INDENT> if ( x <= 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x = ( x - 1 ) // 2 <NEWLINE> l = A [ x * 2 + 1 ] <NEWLINE> r = A [ x * 2 + 2 ] <NEWLINE> A [ x ] = l if l < r else r <COMMENT> <NEWLINE> <DEDENT> <DEDENT> res = [ ] <NEWLINE> c = 0 <NEWLINE> for i in range ( _N - k ) : <NEWLINE> <INDENT> res . append ( A [ 0 ] ) <NEWLINE> x = c + OFS <NEWLINE> A [ x ] = arr [ i + k ] <NEWLINE> while True : <NEWLINE> <INDENT> if ( x <= 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x = ( x - 1 ) // 2 <NEWLINE> l = A [ x * 2 + 1 ] <NEWLINE> r = A [ x * 2 + 2 ] <NEWLINE> A [ x ] = l if l < r else r <NEWLINE> <DEDENT> c += 1 <NEWLINE> if ( c == k ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> <DEDENT> <DEDENT> res . append ( A [ 0 ] ) <NEWLINE> print ( * res ) <NEWLINE> <NL> <DEDENT> _N , k = map ( int , input ( ) . split ( ) ) <NEWLINE> * arr , = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( k == 1 ) : <NEWLINE> <INDENT> print ( * arr ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N = 2 ** ( _N - 1 ) . bit_length ( ) <NEWLINE> A = [ INTMAX ] * ( 2 * N ) <NEWLINE> OFS = N - 1 <NEWLINE> ans ( ) <NEWLINE> <NL> <DEDENT>
from collections import deque <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> dll = deque ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> command = input ( ) . split ( ) <NEWLINE> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> dll . appendleft ( command [ 1 ] ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> dll . remove ( command [ 1 ] ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> dll . popleft ( ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> dll . pop ( ) <NEWLINE> <DEDENT> <DEDENT> print ( * dll ) <NEWLINE> <DEDENT>
def scan ( s ) : <NEWLINE> <INDENT> m = 0 <NEWLINE> a = 0 <NEWLINE> for c in s : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> m = min ( m , a ) <NEWLINE> <DEDENT> return m , a <NEWLINE> <NL> <NL> <DEDENT> def key ( v ) : <NEWLINE> <INDENT> m , a = v <NEWLINE> if a >= 0 : <NEWLINE> <INDENT> return 1 , m , a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 , a - m , a <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> c = 0 <NEWLINE> for m , a in sorted ( [ scan ( s ) for s in S ] , reverse = True , key = key ) : <NEWLINE> <INDENT> if c + m < 0 : <NEWLINE> <INDENT> c += m <NEWLINE> break <NEWLINE> <DEDENT> c += a <NEWLINE> <NL> <DEDENT> if c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> <NL> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n != 0 : <NEWLINE> <INDENT> ans = a_list [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> if 0 in a_list : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = ans * a_list [ i ] <NEWLINE> <NL> if 10 ** 18 < ans : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> ans = i = j = 0 <NEWLINE> <NL> import bisect <NEWLINE> <NL> for b in B : <NEWLINE> <INDENT> i = bisect . bisect_left ( A , b ) <NEWLINE> j = N - bisect . bisect_right ( C , b ) <NEWLINE> ans += i * j <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
t = input ( ) <NEWLINE> result = <STRING> <NEWLINE> for i in range ( len ( t ) - 1 ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if result [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> result += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> result += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> if t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> result += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> result += t [ i ] <NEWLINE> <DEDENT> <DEDENT> if t [ len ( t ) - 1 ] == <STRING> or t [ len ( t ) - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( result + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result + <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> LR = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( K ) ] <NEWLINE> MOD = 998244353 <NEWLINE> <NL> dp = [ 0 ] * ( N + 1 ) <NEWLINE> S = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> S [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> for l , r in LR : <NEWLINE> <INDENT> if i - l < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] += S [ i - l ] - S [ max ( i - r - 1 , 0 ) ] <NEWLINE> <DEDENT> <DEDENT> dp [ i ] %= MOD <NEWLINE> S [ i ] = S [ i - 1 ] + dp [ i ] <NEWLINE> <DEDENT> print ( dp [ - 1 ] % MOD ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import exit <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> A . sort ( reverse = True ) <NEWLINE> if A [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 10 ** 5 + 1 <NEWLINE> for a in range ( 1 , n // 2 + 1 ) : <NEWLINE> <INDENT> a , b = list ( str ( a ) ) , list ( str ( n - a ) ) <NEWLINE> ans = min ( ans , sum ( list ( map ( int , a ) ) ) + sum ( list ( map ( int , b ) ) ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
data = [ <NEWLINE> <INDENT> <STRING> . format ( s , r ) <NEWLINE> for s in ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> for r in range ( 1 , 13 + 1 ) <NEWLINE> <DEDENT> ] <NEWLINE> <NL> count = int ( input ( ) ) <NEWLINE> for c in range ( count ) : <NEWLINE> <INDENT> card = input ( ) <NEWLINE> data . remove ( card ) <NEWLINE> <NL> <DEDENT> for c in data : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> num_list = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> num_list . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> copy = num_list . copy ( ) <NEWLINE> copy . sort ( ) <NEWLINE> maximum = copy [ - 1 ] <NEWLINE> second = copy [ - 2 ] <NEWLINE> <NL> for i in num_list : <NEWLINE> <INDENT> if i == maximum : <NEWLINE> <INDENT> print ( second ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( maximum ) <NEWLINE> <DEDENT> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> t = min ( B + 1 , N + 1 ) <NEWLINE> <NL> for x in range ( t - 2 , t ) : <NEWLINE> <INDENT> a = int ( A * x / B ) <NEWLINE> b = A * int ( x / B ) <NEWLINE> ans = max ( ans , a - b ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> L = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] in L : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> ans = max ( ans , cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
wordcount = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> words = input ( ) <NEWLINE> wordcount = wordcount + words . lower ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] : <NEWLINE> <INDENT> print ( <STRING> . format ( i , wordcount . count ( i ) ) ) <NEWLINE> <DEDENT>
from itertools import groupby <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> aa = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = { } <NEWLINE> for k , g in groupby ( aa ) : <NEWLINE> <INDENT> d [ k ] = len ( list ( g ) ) <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> bc = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> bc . append ( ( b , c ) ) <NEWLINE> <DEDENT> s = sum ( k * v for k , v in d . items ( ) ) <NEWLINE> for b , c in bc : <NEWLINE> <INDENT> if b in d : <NEWLINE> <INDENT> s += ( c - b ) * d [ b ] <NEWLINE> d [ c ] = d . setdefault ( c , 0 ) + d [ b ] <NEWLINE> del d [ b ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> class Tree ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <DEDENT> def insert ( self , key ) : <NEWLINE> <INDENT> z = Node ( key ) <NEWLINE> y = None <NEWLINE> x = self . root <NEWLINE> while x : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . parent = y <NEWLINE> if y == None : <NEWLINE> <INDENT> self . root = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <DEDENT> <DEDENT> def find ( self , key ) : <NEWLINE> <INDENT> x = self . root <NEWLINE> while x and x . key != key : <NEWLINE> <INDENT> if x . key < key : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> <DEDENT> return x <NEWLINE> <DEDENT> def delete ( self , key ) : <NEWLINE> <INDENT> z = self . find ( key ) <NEWLINE> y = self . successor ( z ) if z . left and z . right else z <NEWLINE> x = y . left if y . left else y . right <NEWLINE> <NL> if x : <NEWLINE> <INDENT> x . parent = y . parent <NEWLINE> <DEDENT> if y . parent == None : <NEWLINE> <INDENT> self . root = x <NEWLINE> <DEDENT> elif y == y . parent . left : <NEWLINE> <INDENT> y . parent . left = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . parent . right = x <NEWLINE> <DEDENT> if y != z : <NEWLINE> <INDENT> z . key = y . key <NEWLINE> <DEDENT> <DEDENT> def successor ( self , x ) : <NEWLINE> <INDENT> if x . right : <NEWLINE> <INDENT> return self . minimum ( x . right ) <NEWLINE> <DEDENT> y = x . parent <NEWLINE> while y and x == y . right : <NEWLINE> <INDENT> x = y <NEWLINE> y = y . parent <NEWLINE> <DEDENT> return y <NEWLINE> <NL> <DEDENT> def minimum ( self , x ) : <NEWLINE> <INDENT> while x . left : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def print ( self ) : <NEWLINE> <INDENT> print ( <STRING> , <STRING> . join ( map ( str , self . root . inwalk ( ) ) ) ) <NEWLINE> print ( <STRING> , <STRING> . join ( map ( str , self . root . prewalk ( ) ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . parent = self . left = self . right = None <NEWLINE> <DEDENT> def prewalk ( self ) : <NEWLINE> <INDENT> ret = [ self . key ] <NEWLINE> if self . left : <NEWLINE> <INDENT> ret += self . left . prewalk ( ) <NEWLINE> <DEDENT> if self . right : <NEWLINE> <INDENT> ret += self . right . prewalk ( ) <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT> def inwalk ( self ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> if self . left : <NEWLINE> <INDENT> ret += self . left . inwalk ( ) <NEWLINE> <DEDENT> ret += [ self . key ] <NEWLINE> if self . right : <NEWLINE> <INDENT> ret += self . right . inwalk ( ) <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT> <DEDENT> tree = Tree ( ) <NEWLINE> n = sys . stdin . readline ( ) <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> if line [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree . insert ( int ( line . split ( ) [ 1 ] ) ) <NEWLINE> <DEDENT> elif line [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> if tree . find ( int ( line . split ( ) [ 1 ] ) ) else <STRING> ) <NEWLINE> <DEDENT> elif line [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree . delete ( int ( line . split ( ) [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree . print ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> import collections <NEWLINE> ans = sum ( a ) <NEWLINE> a = collections . Counter ( a ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = a [ b ] <NEWLINE> ans -= d * b <NEWLINE> a [ b ] = 0 <NEWLINE> ans += d * c <NEWLINE> a [ c ] += d <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> m = n <NEWLINE> A = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in range ( 1 , 12 ) : <NEWLINE> <INDENT> n -= 26 ** i <NEWLINE> if n <= 0 : <NEWLINE> <INDENT> count = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> n = m <NEWLINE> <NL> for i in range ( 1 , count ) : <NEWLINE> <INDENT> n -= 26 ** i <NEWLINE> <DEDENT> n -= 1 <NEWLINE> <NL> B = [ ] <NEWLINE> for i in range ( count - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> B . append ( n // ( 26 ** i ) ) <NEWLINE> n -= ( n // ( 26 ** i ) ) * ( 26 ** i ) <NEWLINE> <DEDENT> B . append ( n ) <NEWLINE> <NL> C = [ ] <NEWLINE> for i in B : <NEWLINE> <INDENT> C . append ( A [ i ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( C ) ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> Z = 10 ** 9 + 7 <NEWLINE> a = 1 <NEWLINE> b = 1 <NEWLINE> c = 1 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> a *= 10 <NEWLINE> b *= 9 <NEWLINE> c *= 8 <NEWLINE> <NL> a = a % Z <NEWLINE> b = b % Z <NEWLINE> c = c % Z <NEWLINE> <NL> <DEDENT> print ( ( a - 2 * b + c ) % Z ) <NEWLINE>
import math <NEWLINE> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> top = min ( n , b - 1 ) <NEWLINE> ans = math . floor ( a * top / b ) <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for a in range ( 1 , N ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for b in range ( a , N ) : <NEWLINE> <INDENT> if a * b < N : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> cnt += 2 <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans += cnt <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = [ 0 ] * a <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in c : <NEWLINE> <INDENT> b [ i - 1 ] += 1 <NEWLINE> <DEDENT> print ( * b , sep = <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> t = input ( ) <NEWLINE> if t == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> n = len ( t ) <NEWLINE> ans = list ( t ) <NEWLINE> for i , c in enumerate ( t ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif i == n - 1 : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ans [ i - 1 ] == <STRING> and t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> elif ans [ i - 1 ] == <STRING> and t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> elif ans [ i - 1 ] == <STRING> and t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> elif ans [ i - 1 ] == <STRING> and t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> elif ans [ i - 1 ] == <STRING> and t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> elif ans [ i - 1 ] == <STRING> and t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s = c <NEWLINE> <DEDENT> ans [ i ] = s <NEWLINE> <DEDENT> return <STRING> . join ( ans ) <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> done = 0 <NEWLINE> for i in range ( 1 , m + 1 ) [ : : - 1 ] : <NEWLINE> <INDENT> if ( m - i ) & 1 : <NEWLINE> <INDENT> print ( m + 1 + ( m + 1 - i ) // 2 , m + 1 + ( m + 1 - i ) // 2 + i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( m - i ) // 2 + 1 , ( m - i ) // 2 + 1 + i ) <NEWLINE> <DEDENT> <DEDENT>
M = 10 ** 9 + 7 <NEWLINE> k , n = int ( input ( ) ) , len ( input ( ) ) <NEWLINE> a = t = pow ( 26 , k , M ) <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> t = t * 25 * ( i + n ) * pow ( 26 * ( i + 1 ) , - 1 , M ) % M <NEWLINE> a += t <NEWLINE> <NL> <DEDENT> print ( a % M ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> area = r * r * math . pi <NEWLINE> circum = 2 * r * math . pi <NEWLINE> print ( <STRING> . format ( area , circum ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> <NL> good = [ 1 ] * n <NEWLINE> <NL> for comb in ab : <NEWLINE> <INDENT> a = comb [ 0 ] - 1 <NEWLINE> b = comb [ 1 ] - 1 <NEWLINE> if h [ a ] <= h [ b ] : <NEWLINE> <INDENT> good [ a ] = 0 <NEWLINE> <DEDENT> if h [ a ] >= h [ b ] : <NEWLINE> <INDENT> good [ b ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = sum ( good ) <NEWLINE> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> A , B , C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = <STRING> <NEWLINE> if A % 2 == 0 or B % 2 == 0 or C % 2 == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( B * C , C * A , A * B ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> resolve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif N % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> a = 7 <NEWLINE> num = 7 <NEWLINE> while ( num % N != 0 ) : <NEWLINE> <INDENT> a = ( a * 10 ) % N <NEWLINE> num = ( num + a ) % N <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 100000000 ) <NEWLINE> S = int ( input ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> def dfs_memo ( n ) : <NEWLINE> <INDENT> memo = [ 0 ] * ( n + 1 ) <NEWLINE> memo [ 3 ] = 1 <NEWLINE> <NL> def dfs ( n ) : <NEWLINE> <INDENT> if n < 3 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if memo [ n ] != 0 : <NEWLINE> <INDENT> return memo [ n ] <NEWLINE> <DEDENT> memo [ n ] = dfs ( n - 1 ) + dfs ( n - 3 ) <NEWLINE> return memo [ n ] <NEWLINE> <DEDENT> return dfs ( n ) <NEWLINE> <NL> <DEDENT> if S < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dfs_memo ( S ) % mod ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> b_to_c = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for i in range ( Q ) ] <NEWLINE> <NL> sum = 0 <NEWLINE> memo = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> memo [ i ] += 1 <NEWLINE> sum += i <NEWLINE> <NL> <DEDENT> for bc in b_to_c : <NEWLINE> <INDENT> b = bc [ 0 ] <NEWLINE> c = bc [ 1 ] <NEWLINE> sum -= ( b * memo [ b ] ) <NEWLINE> sum += ( c * memo [ b ] ) <NEWLINE> memo [ c ] += memo [ b ] <NEWLINE> memo [ b ] = 0 <NEWLINE> print ( sum ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> MaxNum = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> MaxNum = max ( MaxNum , A [ i ] ) <NEWLINE> B = MaxNum <NEWLINE> sum += MaxNum - A [ i ] <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
import itertools <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> l = 0 <NEWLINE> T = [ ] <NEWLINE> for u in list ( itertools . combinations ( L , 3 ) ) : <NEWLINE> <INDENT> i , j , k = u <NEWLINE> if 2 * max ( i , j , k ) < i + j + k and i != k and i != j and j != k : <NEWLINE> <INDENT> l = l + 1 <NEWLINE> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
s = input ( ) <NEWLINE> ls = len ( s ) <NEWLINE> m = [ 0 ] * ( 2019 ) <NEWLINE> m [ 0 ] += 1 <NEWLINE> <NL> cnt = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( ls ) : <NEWLINE> <INDENT> a = ( b + pow ( 10 , cnt , 2019 ) * int ( s [ ls - i - 1 ] ) ) % 2019 <NEWLINE> m [ a ] += 1 <NEWLINE> b = a <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in m : <NEWLINE> <INDENT> if i <= 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( a ) <NEWLINE> l = [ ] <NEWLINE> for i in set ( a ) : <NEWLINE> <INDENT> if c [ i ] >= 2 : <NEWLINE> <INDENT> for j in range ( c [ i ] // 2 ) : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( l ) >= 2 : <NEWLINE> <INDENT> print ( heapq . nlargest ( 2 , l ) [ 0 ] * heapq . nlargest ( 2 , l ) [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> input_list = [ ] <NEWLINE> for i in range ( n ) : input_list . append ( input ( ) ) <NEWLINE> for i in set ( input_list ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif v <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t < abs ( a - b ) / ( v - w ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
seconds = int ( input ( ) ) <NEWLINE> hour , amari = divmod ( seconds , 3600 ) <NEWLINE> minute , second = divmod ( amari , 60 ) <NEWLINE> <NL> print ( <STRING> . format ( hour , minute , second ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def other_members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root and i != x ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <DEDENT> n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> counts = [ 0 ] * n <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> uf . union ( a , b ) <NEWLINE> counts [ a ] += 1 <NEWLINE> counts [ b ] += 1 <NEWLINE> <DEDENT> for _ in range ( k ) : <NEWLINE> <INDENT> c , d = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> if uf . same ( c , d ) : <NEWLINE> <INDENT> counts [ c ] += 1 <NEWLINE> counts [ d ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( uf . size ( i ) - counts [ i ] - 1 ) for i in range ( n ) ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import copy <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> line = defaultdict ( list ) <NEWLINE> q = deque <NEWLINE> next = deque ( ) <NEWLINE> <NL> ans = [ - 1 ] * ( N + 1 ) <NEWLINE> ans [ 0 ] = 0 <NEWLINE> ans [ 1 ] = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> line [ a ] . append ( b ) <NEWLINE> line [ b ] . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> next . append ( 1 ) <NEWLINE> a = 1 <NEWLINE> while len ( next ) > 0 : <NEWLINE> <INDENT> q = copy . copy ( next ) <NEWLINE> <COMMENT> <NL> next . clear ( ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> chk = q . popleft ( ) <NEWLINE> <COMMENT> <NL> for i in range ( len ( line [ chk ] ) ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if ans [ line [ chk ] [ i ] ] == - 1 : <NEWLINE> <INDENT> ans [ line [ chk ] [ i ] ] = chk <NEWLINE> next . append ( line [ chk ] [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if - 1 not in ans : break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if - 1 in ans : print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> import numpy as np <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = np . array ( [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> X = np . cumsum ( A ) <NEWLINE> Y = np . cumsum ( B ) <NEWLINE> <COMMENT> <NL> <NL> cnt = 0 <NEWLINE> j = m <NEWLINE> <COMMENT> <NL> for i , x in enumerate ( X ) : <NEWLINE> <INDENT> if x > k : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> while x + Y [ j ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> cnt = max ( cnt , i + j ) <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> S = str ( input ( ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> t = 0 <NEWLINE> <NL> d = deque ( ) <NEWLINE> d . append ( S ) <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> A = list ( input ( ) . split ( ) ) <NEWLINE> if A [ 0 ] == <STRING> : <NEWLINE> <INDENT> if t == 0 : <NEWLINE> <INDENT> t = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> elif ( A [ 1 ] == <STRING> and t == 0 ) or ( A [ 1 ] == <STRING> and t == 1 ) : <NEWLINE> <INDENT> d . appendleft ( A [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . append ( A [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> l = list ( d ) <NEWLINE> ans = <STRING> . join ( l ) <NEWLINE> if t == 1 : <NEWLINE> <INDENT> ans = ans [ : : - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n >= b - 1 : <NEWLINE> <INDENT> print ( math . floor ( a * ( b - 1 ) / b ) - a * math . floor ( ( b - 1 ) / b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . floor ( a * n / b ) - a * math . floor ( n / b ) ) <NEWLINE> <DEDENT>
from itertools import combinations_with_replacement <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * q <NEWLINE> b = [ 0 ] * q <NEWLINE> c = [ 0 ] * q <NEWLINE> d = [ 0 ] * q <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ i ] -= 1 <NEWLINE> b [ i ] -= 1 <NEWLINE> <NL> <NL> <DEDENT> arr = [ 0 ] * ( n + m ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> arr [ j ] = 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for A in combinations_with_replacement ( range ( 1 , m + 1 ) , n ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> for l in range ( q ) : <NEWLINE> <INDENT> if A [ b [ l ] ] - A [ a [ l ] ] == c [ l ] : <NEWLINE> <INDENT> score += d [ l ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , score ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> ans = sum ( A ) <NEWLINE> C = Counter ( A ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if C [ b ] != 0 : <NEWLINE> <INDENT> cnt = C [ b ] <NEWLINE> C [ c ] += cnt <NEWLINE> C [ b ] = 0 <NEWLINE> ans += ( c - b ) * cnt <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 1000000000 + 7 <NEWLINE> add = 0 <NEWLINE> tmp = sum ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp -= A [ i ] <NEWLINE> add += tmp * A [ i ] <NEWLINE> <DEDENT> print ( add % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = sum ( A ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> s -= A [ i ] <NEWLINE> ans = ( ans + A [ i ] * s ) % int ( 1e9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> p , q , r , s , t , u , x , y = map ( float , e . split ( ) ) <NEWLINE> f = lambda h , i , j , k : ( h - p ) * ( i - q ) - ( j - q ) * ( k - p ) <NEWLINE> a , b = f ( x , u , y , t ) / f ( r , u , s , t ) , f ( x , s , y , r ) / f ( t , s , u , r ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ 0 < a < 1 - b and 0 < b < 1 - a ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> for A in range ( 1 , N ) : <NEWLINE> <INDENT> result += int ( ( N - 1 ) / A ) <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
<NL> <NL> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> rs = [ 1 ] * n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> rs [ i ] = rs [ i - 1 ] * 10 % 2019 <NEWLINE> <NL> <DEDENT> ls = [ 0 ] * 2019 <NEWLINE> ls [ 0 ] += 1 <NEWLINE> <NL> r = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> r += int ( s [ i ] ) * ( rs [ n - i - 1 ] ) <NEWLINE> r %= 2019 <NEWLINE> ls [ r ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for a in ls : <NEWLINE> <INDENT> ans += a * ( a - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> G = [ ] <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> g = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> gc = math . gcd ( g , c ) <NEWLINE> G . append ( gc ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ( G ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> adj = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> adj [ a ] . append ( b ) <NEWLINE> adj [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> q = deque ( ) <NEWLINE> <NL> dist = [ - 1 ] * n <NEWLINE> ans = [ 0 ] * n <NEWLINE> <NL> q . append ( 0 ) <NEWLINE> while len ( q ) != 0 : <NEWLINE> <INDENT> now = q . popleft ( ) <NEWLINE> for to in adj [ now ] : <NEWLINE> <INDENT> if dist [ to ] != - 1 : continue <NEWLINE> dist [ to ] = dist [ now ] + 1 <NEWLINE> q . append ( to ) <NEWLINE> ans [ to ] = now <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] + 1 ) <NEWLINE> <NL> <DEDENT>
from collections import deque <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> road = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> ans = [ - 1 ] * ( N + 1 ) <NEWLINE> d = deque ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> road [ A ] . append ( B ) <NEWLINE> road [ B ] . append ( A ) <NEWLINE> <DEDENT> d . append ( 1 ) <NEWLINE> while len ( d ) != 0 : <NEWLINE> <INDENT> look = d . popleft ( ) <NEWLINE> for i in road [ look ] : <NEWLINE> <INDENT> if ans [ i ] == - 1 : <NEWLINE> <INDENT> d . append ( i ) <NEWLINE> ans [ i ] = look <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> tot = r * g * b <NEWLINE> <COMMENT> <NL> minus = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> if 2 * j - i < N : <NEWLINE> <NL> <INDENT> if S [ i ] != S [ j ] and S [ j ] != S [ 2 * j - i ] and S [ i ] != S [ 2 * j - i ] : <NEWLINE> <INDENT> minus += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( tot - minus ) <NEWLINE>
n = ( int ) ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> total = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> total *= a [ i ] <NEWLINE> if total > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( total ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> for b in range ( 2 , int ( math . sqrt ( a ) ) + 1 ) : <NEWLINE> <INDENT> if a % b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> f = [ 1 , 1 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> fib = f [ - 1 ] + f [ - 2 ] <NEWLINE> f . append ( fib ) <NEWLINE> <DEDENT> print ( f [ n ] ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> power = math . factorial ( n ) <NEWLINE> print ( power % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> <NL> pi = 3.141592653589793 <NEWLINE> r = float ( input ( ) ) <NEWLINE> <NL> area = r * r * pi <NEWLINE> circle = 2 * r * pi <NEWLINE> <NL> print ( format ( area , <STRING> ) , format ( circle , <STRING> ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if B > N : <NEWLINE> <INDENT> result = int ( A * N / B ) - A * int ( N / B ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> result = int ( A * ( B - 1 ) / B ) - A * int ( ( B - 1 ) / B ) <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> counter = defaultdict ( int ) <NEWLINE> for s in S : <NEWLINE> <INDENT> counter [ s ] += 1 <NEWLINE> <DEDENT> total = counter [ <STRING> ] * counter [ <STRING> ] * counter [ <STRING> ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i , N ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ i ] != S [ k ] : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import copy <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> Am , Ap = [ ] , [ ] <NEWLINE> pm = [ 0 , 0 ] <NEWLINE> B = [ ] <NEWLINE> <NL> def ans ( A ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for x in A : <NEWLINE> <INDENT> ans *= x <NEWLINE> ans %= mod <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> if N == K : <NEWLINE> <INDENT> print ( ans ( A ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for x in A : <NEWLINE> <INDENT> if x < 0 : <NEWLINE> <INDENT> Am . append ( - x ) <NEWLINE> B . append ( ( - x , 1 ) ) <NEWLINE> pm [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Ap . append ( x ) <NEWLINE> B . append ( ( x , 0 ) ) <NEWLINE> pm [ 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> Am . sort ( ) <NEWLINE> <NL> if pm [ 0 ] == N : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> print ( ans ( Am [ N - K : ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( - 1 * ans ( Am [ : K ] ) ) % mod ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> P = [ ] <NEWLINE> B . sort ( reverse = True ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> p_min = ( - 1 , - 1 ) <NEWLINE> m_min = ( - 1 , - 1 ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> P . append ( B [ i ] [ 0 ] ) <NEWLINE> cnt ^= B [ i ] [ 1 ] <NEWLINE> if B [ i ] [ 1 ] == 0 : <NEWLINE> <INDENT> p_min = ( B [ i ] [ 0 ] , i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m_min = ( B [ i ] [ 0 ] , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt == 0 : <NEWLINE> <INDENT> print ( ans ( P ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> P1 = copy . deepcopy ( P ) <NEWLINE> P2 = copy . deepcopy ( P ) <NEWLINE> <NL> p_max = ( - 1 , - 1 ) <NEWLINE> m_max = ( - 1 , - 1 ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if B [ i ] [ 1 ] == 0 : <NEWLINE> <INDENT> p_max = ( B [ i ] [ 0 ] , i ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( K , N ) : <NEWLINE> <INDENT> if B [ i ] [ 1 ] == 1 : <NEWLINE> <INDENT> m_max = ( B [ i ] [ 0 ] , i ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> Flag1 = False <NEWLINE> Flag2 = False <NEWLINE> <NL> if p_min [ 1 ] != - 1 and m_max [ 1 ] != - 1 : <NEWLINE> <INDENT> Flag1 = True <NEWLINE> P1 [ p_min [ 1 ] ] = 1 <NEWLINE> P1 . append ( m_max [ 0 ] ) <NEWLINE> ans1 = ans ( P1 ) <NEWLINE> <NL> <DEDENT> if m_min [ 1 ] != - 1 and p_max [ 1 ] != - 1 : <NEWLINE> <INDENT> Flag2 = True <NEWLINE> P2 [ m_min [ 1 ] ] = 1 <NEWLINE> P2 . append ( p_max [ 0 ] ) <NEWLINE> ans2 = ans ( P2 ) <NEWLINE> <NL> <DEDENT> if Flag1 and Flag2 : <NEWLINE> <INDENT> if m_min [ 0 ] * m_max [ 0 ] > p_min [ 0 ] * p_max [ 0 ] : <NEWLINE> <INDENT> print ( ans1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans2 ) <NEWLINE> <DEDENT> <DEDENT> elif Flag1 : <NEWLINE> <INDENT> print ( ans1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans2 ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> _sum = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> j = m <NEWLINE> counts = [ 0 ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if ( a [ i ] > k ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> counts . append ( i + j ) <NEWLINE> <NL> <DEDENT> print ( max ( counts ) ) <NEWLINE>
import numpy <NEWLINE> import bisect <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] + list ( numpy . cumsum ( A ) ) <NEWLINE> b = [ 0 ] + list ( numpy . cumsum ( B ) ) <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> x = k - a [ i ] <NEWLINE> if x >= 0 : <NEWLINE> <INDENT> j = bisect . bisect_right ( b , x ) - 1 <NEWLINE> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while ( H != 0 or W != 0 ) : <NEWLINE> <INDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( W * <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> if X - K * D > 0 : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> <DEDENT> elif ( K - X // D ) % 2 == 1 : <NEWLINE> <INDENT> print ( abs ( X % D - D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X % D ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( r ** 2 * math . pi , 2 * r * math . pi ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> balls = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> balls . append ( [ x , y ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> delta = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dx = balls [ j ] [ 0 ] - balls [ i ] [ 0 ] <NEWLINE> dy = balls [ j ] [ 1 ] - balls [ i ] [ 1 ] <NEWLINE> delta . append ( ( dx , dy ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> c_delta = collections . Counter ( delta ) <NEWLINE> <COMMENT> <NL> if len ( c_delta ) : <NEWLINE> <INDENT> print ( n - c_delta . most_common ( ) [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> route = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> route [ a - 1 ] . append ( b - 1 ) <NEWLINE> route [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> q = deque ( ) <NEWLINE> d = [ - 1 ] * N <NEWLINE> d [ 0 ] = 0 <NEWLINE> q . append ( 0 ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> x = q . popleft ( ) <NEWLINE> for i in route [ x ] : <NEWLINE> <INDENT> if d [ i ] == - 1 : <NEWLINE> <INDENT> d [ i ] = x + 1 <NEWLINE> q . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT>
<NL> def get_input ( ) : <NEWLINE> <INDENT> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> routes = { } <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_idx = a - 1 <NEWLINE> b_idx = b - 1 <NEWLINE> if a_idx in routes : <NEWLINE> <INDENT> routes [ a_idx ] . append ( b_idx ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> routes [ a_idx ] = [ b_idx ] <NEWLINE> <NL> <DEDENT> if b_idx in routes : <NEWLINE> <INDENT> routes [ b_idx ] . append ( a_idx ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> routes [ b_idx ] = [ a_idx ] <NEWLINE> <NL> <DEDENT> <DEDENT> return N , M , routes <NEWLINE> <NL> <DEDENT> def write_result ( marks , N ) : <NEWLINE> <INDENT> flag = True <NEWLINE> output_str = <STRING> <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if i not in marks : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> output_str += <STRING> <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( output_str ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> import numpy <NEWLINE> <NL> <NL> marks = { 0 : 0 } <NEWLINE> <NL> N , M , routes = get_input ( ) <NEWLINE> mark = { 0 : 0 } <NEWLINE> start_nodes = [ 0 ] <NEWLINE> while start_nodes : <NEWLINE> <INDENT> next_nodes = [ ] <NEWLINE> for i in start_nodes : <NEWLINE> <INDENT> for n in routes [ i ] : <NEWLINE> <INDENT> if n in marks : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> marks [ n ] = i <NEWLINE> next_nodes . append ( n ) <NEWLINE> <DEDENT> <DEDENT> start_nodes = next_nodes <NEWLINE> <DEDENT> write_result ( marks , N ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ball = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) [ : : - 1 ] : <NEWLINE> <INDENT> m = n // ( i + 1 ) <NEWLINE> count = 0 <NEWLINE> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> count += ball [ j * ( i + 1 ) - 1 ] <NEWLINE> <DEDENT> ball [ i ] = ( a [ i ] % 2 ) ^ ( count % 2 ) <NEWLINE> <NL> <DEDENT> print ( sum ( ball ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ball [ i ] == 1 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> t = 0 <NEWLINE> k = int ( input ( <STRING> ) ) + 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> for l in range ( 1 , k ) : <NEWLINE> <INDENT> for m in range ( l , k ) : <NEWLINE> <INDENT> for n in range ( m , k ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if l == m and l == n : <NEWLINE> <INDENT> t += gcd_list ( [ l , m , n ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif l == m or l == n or m == n : <NEWLINE> <INDENT> t += gcd_list ( [ l , m , n ] ) * 3 <NEWLINE> <COMMENT> <NL> <DEDENT> elif l != m and m != n : <NEWLINE> <INDENT> t += gcd_list ( [ l , m , n ] ) * 6 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> res *= i <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> res = sum ( A ) <NEWLINE> A_counter = Counter ( A ) <NEWLINE> for i , j in B : <NEWLINE> <INDENT> if i not in A_counter : <NEWLINE> <INDENT> A_counter [ i ] = 0 <NEWLINE> <DEDENT> if j not in A_counter : <NEWLINE> <INDENT> A_counter [ j ] = 0 <NEWLINE> <NL> <DEDENT> res += ( j - i ) * A_counter [ i ] <NEWLINE> print ( res ) <NEWLINE> <NL> A_counter [ j ] += A_counter [ i ] <NEWLINE> A_counter [ i ] = 0 <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> x = 0 <NEWLINE> n = int ( input ( ) ) + 1 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for j in range ( 1 , n ) : <NEWLINE> <INDENT> for k in range ( 1 , n ) : <NEWLINE> <INDENT> x += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ <STRING> ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x = a [ i ] <NEWLINE> b = ans [ a [ i ] - 1 ] <NEWLINE> c = str ( i + 1 ) <NEWLINE> ans [ a [ i ] - 1 ] = str ( i + 1 ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
import sys , os , math , bisect , itertools , collections , heapq , queue <NEWLINE> <COMMENT> <NL> from decimal import Decimal <NEWLINE> from collections import defaultdict , deque <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N = ii ( ) <NEWLINE> A = il ( ) <NEWLINE> cnt = collections . Counter ( A ) <NEWLINE> <NL> for k , v in cnt . items ( ) : <NEWLINE> <INDENT> if k == 0 and v != 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif k != 0 and v != 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ( 2 ** ( N // 2 ) ) % MOD ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def alter_altar ( s ) : <NEWLINE> <INDENT> tmp = <STRING> * s . count ( <STRING> ) + <STRING> * s . count ( <STRING> ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == tmp [ i ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> return ans // 2 <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _ = input ( ) <NEWLINE> s = input ( ) <NEWLINE> print ( alter_altar ( s ) ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> rev = False <NEWLINE> l , r = <STRING> , <STRING> <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> query = input ( ) <NEWLINE> if query [ 0 ] == <STRING> : <NEWLINE> <INDENT> rev = not rev <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T , F , C = query . split ( ) <NEWLINE> if F == <STRING> : <NEWLINE> <INDENT> if rev : <NEWLINE> <INDENT> r += C <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = C + l <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if rev : <NEWLINE> <INDENT> l = C + l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r += C <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> res = l + S + r <NEWLINE> if rev : <NEWLINE> <INDENT> res = res [ : : - 1 ] <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , p , l , r ) : <NEWLINE> <INDENT> self . p = p <NEWLINE> self . l = l <NEWLINE> self . r = r <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def rec ( u , p ) : <NEWLINE> <INDENT> D [ u ] = p <NEWLINE> if T [ u ] . r != - 1 : <NEWLINE> <INDENT> rec ( T [ u ] . r , p ) <NEWLINE> <DEDENT> if T [ u ] . l != - 1 : <NEWLINE> <INDENT> rec ( T [ u ] . l , p + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> T = [ Node ( - 1 , - 1 , - 1 ) for _ in range ( N ) ] <NEWLINE> D = [ - 1 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> i , k , * cs = map ( int , input ( ) . split ( ) ) <NEWLINE> for j , c in enumerate ( cs ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> T [ i ] . l = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ l ] . r = c <NEWLINE> <DEDENT> l = c <NEWLINE> T [ c ] . p = i <NEWLINE> <DEDENT> <DEDENT> for i , t in enumerate ( T ) : <NEWLINE> <INDENT> if t . p == - 1 : <NEWLINE> <INDENT> r = i <NEWLINE> <DEDENT> <DEDENT> rec ( r , 0 ) <NEWLINE> for i , t in enumerate ( T ) : <NEWLINE> <INDENT> cs = [ ] <NEWLINE> c = t . l <NEWLINE> while c != - 1 : <NEWLINE> <INDENT> cs . append ( c ) <NEWLINE> c = T [ c ] . r <NEWLINE> <DEDENT> if t . p == - 1 : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <INDENT> . format ( i , t . p , D [ i ] , cs ) ) <NEWLINE> <DEDENT> <DEDENT> elif t . l == - 1 : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <INDENT> . format ( i , t . p , D [ i ] , cs ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <INDENT> . format ( i , t . p , D [ i ] , cs ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> D = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s in D . keys ( ) : <COMMENT> <NEWLINE> <INDENT> D [ s ] += 1 <COMMENT> <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> D [ s ] = 1 <COMMENT> <NEWLINE> <DEDENT> <DEDENT> maxD = max ( D . values ( ) ) <NEWLINE> poll = [ k for k , v in D . items ( ) if v == maxD ] <NEWLINE> print ( <STRING> . join ( sorted ( poll ) ) ) <NEWLINE>
n = 0 <NEWLINE> t = 1 <NEWLINE> def adjacent_matrix ( ) : <NEWLINE> <INDENT> global n <NEWLINE> n = int ( input ( ) ) <NEWLINE> v = [ ] <NEWLINE> array = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> zero = [ 0 for i in range ( n ) ] <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = a [ 2 : ] <NEWLINE> for j in a : <NEWLINE> <INDENT> zero [ j - 1 ] = 1 <NEWLINE> <DEDENT> array . append ( zero ) <NEWLINE> <DEDENT> return array <NEWLINE> <DEDENT> def dfs ( array , i , d , f ) : <NEWLINE> <INDENT> global t <NEWLINE> if i == n : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( d [ i ] == 0 ) : <NEWLINE> <INDENT> d [ i ] = t <NEWLINE> t += 1 <NEWLINE> for ( j , x ) in enumerate ( array [ i ] ) : <NEWLINE> <INDENT> if x == 1 : <NEWLINE> <INDENT> dfs ( array , j , d , f ) <NEWLINE> <DEDENT> <DEDENT> f [ i ] = t <NEWLINE> t += 1 <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> array = adjacent_matrix ( ) <NEWLINE> d = [ 0 for i in range ( n ) ] <NEWLINE> f = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dfs ( array , i , d , f ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i + 1 , d [ i ] , f [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 10 ** 18 <NEWLINE> <NL> for i in range ( 1 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> b = N // i <NEWLINE> ans = min ( ans , max ( len ( str ( i ) ) , len ( str ( b ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> import math <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> <NL> a = math . floor ( x ** 0.2 ) + 1 <NEWLINE> <NL> b5 = a ** 5 - x <NEWLINE> <NL> if x == 1 : <NEWLINE> <INDENT> a = 0 <NEWLINE> b = - 1 <NEWLINE> <DEDENT> elif b5 == 0 : <NEWLINE> <INDENT> b = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = ( 10 ** 9 ) <NEWLINE> left = - 1 * ( 10 ** 9 ) <NEWLINE> pre_right = ( 10 ** 9 ) <NEWLINE> pre_left = - 1 * ( 10 ** 9 ) <NEWLINE> <NL> b = 0 <NEWLINE> pre_mid = 10 ** 9 <NEWLINE> while 1 : <NEWLINE> <INDENT> mid = ( right + left ) // 2 <NEWLINE> ans = mid ** 5 <NEWLINE> <COMMENT> <NL> <NL> if ans > b5 : <NEWLINE> <INDENT> right = mid - 1 <NEWLINE> <DEDENT> elif ans < b5 : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = mid <NEWLINE> break <NEWLINE> <NL> <DEDENT> if [ pre_right , pre_left ] == [ right , left ] : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b5 = a ** 5 - x <NEWLINE> right = ( 10 ** 9 ) <NEWLINE> left = - 1 * ( 10 ** 9 ) <NEWLINE> <NL> <DEDENT> pre_right = right <NEWLINE> pre_left = left <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a , b , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <DEDENT> def test_入力例_1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <DEDENT> def test_入力例_2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if A . count ( 0 ) >= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> answer = 1 <NEWLINE> for _ in A : <NEWLINE> <INDENT> answer *= _ <NEWLINE> if answer > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( max ( 1000 , 10 ** 9 ) ) <NEWLINE> write = lambda x : sys . stdout . write ( x + <STRING> ) <NEWLINE> <NL> <NL> h , w = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> data = [ ] <NEWLINE> rs = [ ] <NEWLINE> cs = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> c = input ( ) <NEWLINE> if <STRING> in c : <NEWLINE> <INDENT> start = ( i , c . index ( <STRING> ) ) <NEWLINE> <DEDENT> if <STRING> in c : <NEWLINE> <INDENT> goal = ( i , c . index ( <STRING> ) ) <NEWLINE> <DEDENT> for j in range ( w ) : <NEWLINE> <INDENT> if c [ j ] in ( <STRING> ) : <COMMENT> <NEWLINE> <INDENT> data . append ( 1 ) <NEWLINE> rs . append ( i ) <NEWLINE> cs . append ( h + j ) <NEWLINE> data . append ( 1 ) <NEWLINE> rs . append ( h + j ) <NEWLINE> cs . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> s = h + w <NEWLINE> t = h + w + 1 <NEWLINE> V = 10 ** 9 <NEWLINE> data . append ( V ) <NEWLINE> rs . append ( s ) <NEWLINE> cs . append ( start [ 0 ] ) <NEWLINE> data . append ( V ) <NEWLINE> rs . append ( start [ 0 ] ) <NEWLINE> cs . append ( s ) <NEWLINE> <NL> data . append ( V ) <NEWLINE> rs . append ( s ) <NEWLINE> cs . append ( start [ 1 ] + h ) <NEWLINE> data . append ( V ) <NEWLINE> rs . append ( start [ 1 ] + h ) <NEWLINE> cs . append ( s ) <NEWLINE> <NL> data . append ( V ) <NEWLINE> rs . append ( goal [ 0 ] ) <NEWLINE> cs . append ( t ) <NEWLINE> data . append ( V ) <NEWLINE> rs . append ( t ) <NEWLINE> cs . append ( goal [ 0 ] ) <NEWLINE> <NL> data . append ( V ) <NEWLINE> rs . append ( t ) <NEWLINE> cs . append ( goal [ 1 ] + h ) <NEWLINE> data . append ( V ) <NEWLINE> rs . append ( goal [ 1 ] + h ) <NEWLINE> cs . append ( t ) <NEWLINE> <NL> import scipy . sparse <NEWLINE> m = scipy . sparse . csr_matrix ( ( data , ( rs , cs ) ) , shape = ( h + w + 2 , h + w + 2 ) ) <NEWLINE> val = scipy . sparse . csgraph . maximum_flow ( m , s , t ) . flow_value <NEWLINE> if val >= 10 ** 9 : <NEWLINE> <INDENT> val = - 1 <NEWLINE> <DEDENT> print ( val ) <NEWLINE>
import sys <NEWLINE> <NL> n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> d = { <STRING> : a , <STRING> : b , <STRING> : c } <NEWLINE> <NL> s = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <NL> <INDENT> if d [ s [ i ] [ 0 ] ] <= 0 and d [ s [ i ] [ 1 ] ] <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if d [ s [ i ] [ 0 ] ] < d [ s [ i ] [ 1 ] ] : <NEWLINE> <INDENT> d [ s [ i ] [ 1 ] ] -= 1 <NEWLINE> d [ s [ i ] [ 0 ] ] += 1 <NEWLINE> ans . append ( s [ i ] [ 0 ] ) <NEWLINE> <DEDENT> elif d [ s [ i ] [ 0 ] ] > d [ s [ i ] [ 1 ] ] : <NEWLINE> <INDENT> d [ s [ i ] [ 0 ] ] -= 1 <NEWLINE> d [ s [ i ] [ 1 ] ] += 1 <NEWLINE> ans . append ( s [ i ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i < n - 1 and s [ i + 1 ] . strip ( s [ i ] ) != <STRING> and d [ s [ i + 1 ] . strip ( s [ i ] ) ] == 0 : <NEWLINE> <INDENT> string = s [ i + 1 ] . strip ( s [ i + 1 ] . strip ( s [ i ] ) ) <NEWLINE> d [ string ] += 1 <NEWLINE> d [ s [ i ] . strip ( string ) ] -= 1 <NEWLINE> ans . append ( s [ i + 1 ] . strip ( s [ i + 1 ] . strip ( s [ i ] ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s [ i ] [ 0 ] ] += 1 <NEWLINE> d [ s [ i ] [ 1 ] ] -= 1 <NEWLINE> ans . append ( s [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> s = [ ] <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if not s in dic : <NEWLINE> <INDENT> dic [ s ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( dic ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> l = sorted ( a ) <NEWLINE> <NL> count = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if l [ i ] != l [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> ans = min ( S . count ( <STRING> ) , S . count ( <STRING> ) ) <NEWLINE> <NL> print ( ans * 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> prime = [ ] <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while n % i == 0 : <NEWLINE> <INDENT> n //= i <COMMENT> <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> prime . append ( cnt ) <COMMENT> <NEWLINE> if n == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if n > 1 : <NEWLINE> <INDENT> prime . append ( 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for x in prime : <NEWLINE> <INDENT> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> if x >= i : <COMMENT> <NEWLINE> <INDENT> ans += 1 <NEWLINE> x -= i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lis = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> lis . append ( a ) <NEWLINE> <NL> <DEDENT> m = 0 <NEWLINE> lis . sort ( ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if lis [ i ] == lis [ i + 1 ] : <NEWLINE> <INDENT> m += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( n - m ) ) <NEWLINE>
from itertools import combinations_with_replacement as combi <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * Q <NEWLINE> b = [ 0 ] * Q <NEWLINE> c = [ 0 ] * Q <NEWLINE> d = [ 0 ] * Q <NEWLINE> l = [ i + 1 for i in range ( M ) ] <NEWLINE> point = 0 <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> for v in combi ( l , N ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for j in range ( Q ) : <NEWLINE> <INDENT> if v [ b [ j ] - 1 ] - v [ a [ j ] - 1 ] == c [ j ] : <NEWLINE> <INDENT> tmp += d [ j ] <NEWLINE> <DEDENT> <DEDENT> point = max ( point , tmp ) <NEWLINE> <NL> <DEDENT> print ( point ) <NEWLINE>
num = int ( input ( ) . rstrip ( ) ) <NEWLINE> m = input ( ) . rstrip ( ) . split ( ) <NEWLINE> main = [ ] <NEWLINE> for i in m : <NEWLINE> <INDENT> main . append ( int ( i ) ) <NEWLINE> <DEDENT> sample = sorted ( main , reverse = True ) <NEWLINE> result = 0 <NEWLINE> for i in range ( 2 , num + 1 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> y = i / 2 - 1 <NEWLINE> result += sample [ int ( y ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = ( i + 1 ) / 2 - 1 <NEWLINE> result += sample [ int ( y ) ] <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> zero = False <NEWLINE> minus = False <NEWLINE> li = input ( ) . split ( ) <NEWLINE> for i in li : <NEWLINE> <INDENT> a = int ( i ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> zero = True <NEWLINE> break <NEWLINE> <DEDENT> if minus : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans *= a <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> minus = True <NEWLINE> <NL> <DEDENT> <DEDENT> if minus : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> if zero : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = sorted ( arr , reverse = True , key = lambda x : abs ( x ) ) <NEWLINE> if k == n : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= arr [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k % 2 == 1 and max ( arr ) < 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= arr [ n - 1 - i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if arr [ i ] < 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> ans *= arr [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> if cnt % 2 == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_plus = - 1 <NEWLINE> min_minus = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if arr [ i ] >= 0 : <NEWLINE> <INDENT> min_plus = arr [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_minus = arr [ i ] <NEWLINE> <DEDENT> <DEDENT> max_plus = - 1 <NEWLINE> max_minus = 1 <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if arr [ i ] >= 0 and max_plus == - 1 : <NEWLINE> <INDENT> max_plus = arr [ i ] <NEWLINE> <DEDENT> if arr [ i ] < 0 and max_minus == 1 : <NEWLINE> <INDENT> max_minus = arr [ i ] <NEWLINE> <DEDENT> <DEDENT> if min_plus == - 1 : <NEWLINE> <INDENT> arr . remove ( min_minus ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> ans *= arr [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> ans *= max_plus <NEWLINE> ans %= mod <NEWLINE> <DEDENT> elif min_minus == 1 : <NEWLINE> <INDENT> arr . remove ( min_plus ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> ans *= arr [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> ans *= max_minus <NEWLINE> ans %= mod <NEWLINE> <DEDENT> elif min_plus * max_plus >= min_minus * max_minus : <NEWLINE> <INDENT> arr . remove ( min_minus ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> ans *= arr [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> ans *= max_plus <NEWLINE> ans %= mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr . remove ( min_plus ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> ans *= arr [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> ans *= max_minus <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> rcount = S . count ( <STRING> ) <NEWLINE> gcount = S . count ( <STRING> ) <NEWLINE> bcount = N - rcount - gcount <NEWLINE> <NL> <NL> <NL> count = rcount * gcount * bcount <NEWLINE> k = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < N : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] * ( n + 1 ) <NEWLINE> check = [ False ] * ( n + 1 ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> l [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if x . count ( x [ 0 ] ) == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> a = sum ( x ) / len ( x ) <NEWLINE> d = [ ] <NEWLINE> for i in range ( min ( x ) , max ( x ) ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in x : <NEWLINE> <INDENT> c += ( i - j ) ** 2 <NEWLINE> <DEDENT> d . append ( c ) <NEWLINE> <NL> <DEDENT> print ( min ( d ) ) <NEWLINE>
<COMMENT> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> A = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> judge = [ - 1 ] * N <NEWLINE> judge [ 0 ] = 0 <NEWLINE> <COMMENT> <NL> a = 0 <NEWLINE> <COMMENT> <NL> step = 1 <NEWLINE> <NL> while step != K + 1 : <NEWLINE> <COMMENT> <NL> <INDENT> a = A [ a ] <NEWLINE> if judge [ a ] > - 1 : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> judge [ a ] = step <NEWLINE> step = step + 1 <NEWLINE> <NL> <DEDENT> if step == K + 1 : <NEWLINE> <INDENT> print ( a + 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> width = step - judge [ a ] <NEWLINE> s = ( K - judge [ a ] ) % width <NEWLINE> print ( judge . index ( judge [ a ] + s ) + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> S = input ( ) . strip ( ) <NEWLINE> c1 = S . count ( <STRING> ) <NEWLINE> c0 = S . count ( <STRING> ) <NEWLINE> print ( min ( c0 , c1 ) * 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i in A : <NEWLINE> <INDENT> ans [ i - 1 ] = ans [ i - 1 ] + 1 <NEWLINE> <DEDENT> for i in range ( 0 , N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> n = N // i <COMMENT> <NEWLINE> cnt = ( n * ( 2 * i + ( n - 1 ) * i ) ) // 2 <COMMENT> <NEWLINE> ans += cnt <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> index = 1 <NEWLINE> route = [ index ] <NEWLINE> node = { index } <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> index = A [ index - 1 ] <NEWLINE> if index in node : <NEWLINE> <INDENT> pre = route . index ( index ) <NEWLINE> loop = len ( route ) <NEWLINE> route_idx = ( K - pre ) % ( loop - pre ) + pre <NEWLINE> print ( route [ route_idx ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> route . append ( index ) <NEWLINE> node . add ( index ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( index ) <NEWLINE> <DEDENT>
from itertools import product <NEWLINE> from itertools import combinations <NEWLINE> import numpy as np <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , M , X = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> books = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> CA = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> books . append ( CA ) <NEWLINE> <NL> <DEDENT> books = np . array ( books ) <NEWLINE> <NL> <NL> if N == 1 : <NEWLINE> <INDENT> if np . all ( books [ : , 1 : ] >= X ) : <NEWLINE> <INDENT> print ( books [ 0 ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT> books_index_pattarns = [ list ( x ) for i in range ( 1 , N + 1 ) for x in combinations ( range ( 0 , N ) , i ) ] <NEWLINE> books_result = np . array ( [ np . sum ( books [ x ] , axis = 0 ) for x in books_index_pattarns ] ) <NEWLINE> books_result = books_result [ np . all ( books_result [ : , 1 : ] >= X , axis = 1 ) ] <NEWLINE> <NL> if len ( books_result ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return True <NEWLINE> <DEDENT> elif len ( books_result ) == 1 : <NEWLINE> <INDENT> print ( books_result [ 0 ] [ 0 ] ) <NEWLINE> return True <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> print ( books_result [ : , : 1 ] . min ( ) ) <NEWLINE> return True <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> S = list ( input ( ) ) <NEWLINE> S . reverse ( ) <NEWLINE> MOD = 2019 <NEWLINE> <NL> t = [ 0 ] <NEWLINE> r = 1 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> q = ( t [ - 1 ] + ( int ( S [ i ] ) * r ) % MOD ) % MOD <NEWLINE> t . append ( q ) <NEWLINE> r *= 10 <NEWLINE> r %= MOD <NEWLINE> <NL> <DEDENT> cnt = Counter ( t ) <NEWLINE> cnt_mc = cnt . most_common ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for _ , j in cnt_mc : <NEWLINE> <INDENT> if j >= 2 : <NEWLINE> <INDENT> ans += j * ( j - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , k , d = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> x = abs ( x ) <NEWLINE> if k * d <= x : <NEWLINE> <INDENT> print ( x - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = x <NEWLINE> x %= d <NEWLINE> k = k - ( t - x ) // d <NEWLINE> if k & 1 : <NEWLINE> <INDENT> print ( abs ( d - x ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tmp = 0 <NEWLINE> ca = [ 0 ] <NEWLINE> for ai in a : <NEWLINE> <INDENT> tmp += ai <NEWLINE> ca . append ( tmp ) <NEWLINE> <DEDENT> tmp = 0 <NEWLINE> cb = [ 0 ] <NEWLINE> for bi in b : <NEWLINE> <INDENT> tmp += bi <NEWLINE> cb . append ( tmp ) <NEWLINE> <DEDENT> import bisect <NEWLINE> s = bisect . bisect_right ( ca , k ) - 1 <NEWLINE> ans = ca [ s ] <NEWLINE> now_a = s <NEWLINE> z = k - ca [ now_a ] <NEWLINE> now_b = bisect . bisect_right ( cb , z ) - 1 <NEWLINE> t = ca [ now_a ] + cb [ now_b ] <NEWLINE> <COMMENT> <NL> ans = now_a + now_b <NEWLINE> for i in range ( s ) : <NEWLINE> <INDENT> now_a -= 1 <NEWLINE> t -= a [ now_a ] <NEWLINE> while now_b < m and t + b [ now_b ] <= k : <NEWLINE> <INDENT> t += b [ now_b ] <NEWLINE> now_b += 1 <NEWLINE> <DEDENT> ans = max ( ans , now_a + now_b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> def is_prime ( a ) : <NEWLINE> <INDENT> if a == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( 2 , 1 + int ( a ** 0.5 ) ) : <NEWLINE> <INDENT> if a % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> divisors = make_divisors ( n ) <NEWLINE> for d in divisors [ 1 : ] : <NEWLINE> <INDENT> if d > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if is_prime ( n ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> tmp_divisors = make_divisors ( d ) <NEWLINE> for p in tmp_divisors [ 1 : ] : <NEWLINE> <INDENT> if not is_prime ( p ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> tmp = np . log ( d ) / np . log ( p ) <NEWLINE> if tmp > 0 and tmp == int ( tmp ) and n % d == 0 : <NEWLINE> <INDENT> n = n / d <NEWLINE> ans += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> for i in range ( 0 , 2 * max ( X , Y ) + 1 , 2 ) : <NEWLINE> <INDENT> ans = min ( ans , int ( A * max ( 0 , X - i / 2 ) + B * max ( 0 , Y - i / 2 ) + C * i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> INF = 1000000000000000000 <NEWLINE> ans = 1 <NEWLINE> flag = 0 <NEWLINE> <NL> for cnt in range ( n ) : <NEWLINE> <INDENT> if a [ cnt ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> for cnt in range ( n ) : <NEWLINE> <INDENT> ans *= a [ cnt ] <NEWLINE> if ans > INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> tree = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> tree [ A ] . append ( B ) <NEWLINE> tree [ B ] . append ( A ) <NEWLINE> <NL> <DEDENT> ans_arr = [ - 1 ] * ( N ) <NEWLINE> q = deque ( ) <NEWLINE> ans_arr [ 0 ] = 0 <NEWLINE> q . append ( 0 ) <NEWLINE> <NL> while len ( q ) > 0 : <NEWLINE> <INDENT> n = q . popleft ( ) <NEWLINE> for i in tree [ n ] : <NEWLINE> <INDENT> if ans_arr [ i ] == - 1 : <NEWLINE> <INDENT> ans_arr [ i ] = n + 1 <NEWLINE> q . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> for i in ans_arr [ 1 : ] : <NEWLINE> <INDENT> if i == - 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == <STRING> : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> for i in ans_arr [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( n * ( n - 1 ) // 2 ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> root = [ - 1 ] * n <NEWLINE> <NL> def r ( x ) : <NEWLINE> <INDENT> if root [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root [ x ] = r ( root [ x ] ) <NEWLINE> return root [ x ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = r ( x ) <NEWLINE> y = r ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> root [ x ] += root [ y ] <NEWLINE> root [ y ] = x <NEWLINE> <NL> <NL> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> x = r ( x ) <NEWLINE> return - root [ x ] <NEWLINE> <NL> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> unite ( x , y ) <NEWLINE> <NL> <DEDENT> <STRING> <NEWLINE> max_size = max ( map ( size , range ( n ) ) ) <NEWLINE> <NL> print ( max_size ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for a in range ( 1 , 10 ** 5 + 1 ) : <NEWLINE> <INDENT> if N % a == 0 : <NEWLINE> <INDENT> b = N // a <NEWLINE> s = max ( len ( str ( a ) ) , len ( str ( b ) ) ) <NEWLINE> l . append ( int ( s ) ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( l ) ) <NEWLINE>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> s_list = list ( map ( int , list ( S ) ) ) [ : : - 1 ] <NEWLINE> MOD = 2019 <NEWLINE> <NL> sum_v = 0 <NEWLINE> cnt = [ 0 ] * MOD <NEWLINE> cnt [ 0 ] = 1 <NEWLINE> for i , s in enumerate ( s_list ) : <NEWLINE> <INDENT> sum_v += s * pow ( 10 , i , MOD ) <NEWLINE> sum_v %= MOD <NEWLINE> cnt [ sum_v ] += 1 <NEWLINE> <DEDENT> print ( sum ( [ c * ( c - 1 ) // 2 for c in cnt if c > 1 ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> elif X not in p : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = sorted ( p ) <NEWLINE> p2 = [ abs ( i - X ) for i in p ] <NEWLINE> <NL> for i in range ( p [ p2 . index ( min ( p2 ) ) ] , 102 ) : <NEWLINE> <INDENT> if i not in p : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( p [ p2 . index ( min ( p2 ) ) ] , - 100 , - 1 ) : <NEWLINE> <INDENT> if i not in p : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = sorted ( ans ) <NEWLINE> ans2 = [ abs ( i - X ) for i in ans ] <NEWLINE> print ( ans [ ans2 . index ( min ( ans2 ) ) ] ) <NEWLINE> <DEDENT>
<NL> def submit ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> thr = 10 ** 18 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for e in a : <NEWLINE> <INDENT> ans *= e <NEWLINE> if ans > thr : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> submit ( ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> print ( s [ : k - 1 ] + s [ k - 1 ] . lower ( ) + s [ k : ] ) <NEWLINE>
d = { } <NEWLINE> for i in range ( 1 , 1000 ) : <NEWLINE> <INDENT> if i ** 5 - ( i - 1 ) ** 5 > 10 ** 9 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( i - 1 , - i - 1 , - 1 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 > 10 ** 9 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> d [ i ** 5 - j ** 5 ] = ( i , j ) <NEWLINE> <DEDENT> <DEDENT> print ( * d [ int ( input ( ) ) ] ) <NEWLINE>
import heapq <NEWLINE> <NL> max_v , m = input ( ) . split ( ) <NEWLINE> max_v = int ( max_v ) <NEWLINE> m = int ( m ) <NEWLINE> <NL> class Edge ( object ) : <NEWLINE> <INDENT> def __init__ ( self , to , cost ) : <NEWLINE> <INDENT> self . to = to <NEWLINE> self . cost = cost <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> edges = [ [ ] for j in range ( max_v ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> edges [ a - 1 ] . append ( Edge ( b - 1 , 1 ) ) <NEWLINE> edges [ b - 1 ] . append ( Edge ( a - 1 , 1 ) ) <NEWLINE> <NL> <DEDENT> d = [ float ( <STRING> ) ] * max_v <NEWLINE> fire = [ - 1 ] * max_v <NEWLINE> <COMMENT> <NL> def dijkstra ( s ) : <NEWLINE> <INDENT> h = [ ] <NEWLINE> d [ s ] = 0 <NEWLINE> heapq . heappush ( h , [ 0 , 0 ] ) <NEWLINE> while ( len ( h ) != 0 ) : <NEWLINE> <INDENT> p = heapq . heappop ( h ) <NEWLINE> v = p [ 1 ] <NEWLINE> if d [ v ] < p [ 0 ] : continue <NEWLINE> for i in range ( len ( edges [ v ] ) ) : <NEWLINE> <INDENT> e = edges [ v ] [ i ] <NEWLINE> if d [ e . to ] > d [ v ] + e . cost : <NEWLINE> <INDENT> d [ e . to ] = d [ v ] + e . cost <NEWLINE> heapq . heappush ( h , [ d [ e . to ] , e . to ] ) <NEWLINE> fire [ e . to ] = v <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dijkstra ( 0 ) <NEWLINE> if 2 <= fire . count ( - 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , max_v ) : <NEWLINE> <INDENT> print ( fire [ i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> a . sort ( ) <NEWLINE> if a [ 0 ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> minimum = 2019 <NEWLINE> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> if minimum == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> if ( i * j ) % 2019 == 0 : <NEWLINE> <INDENT> minimum = 0 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( i * j ) % 2019 < minimum : <NEWLINE> <INDENT> minimum = ( i * j ) % 2019 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( minimum ) <NEWLINE>
def f ( a ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> res *= int ( a [ i ] ) <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> if zer ( i ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def zer ( i ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> if a [ j ] == <STRING> : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> <NL> print ( f ( a ) ) <NEWLINE>
import math <NEWLINE> N , start = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> _x = [ int ( y ) for y in input ( ) . split ( ) ] <NEWLINE> x = [ 0 for y in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x [ i ] = abs ( _x [ i ] - start ) <NEWLINE> <DEDENT> g = x [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> g = math . gcd ( g , x [ i ] ) <NEWLINE> <DEDENT> print ( g ) <NEWLINE> ans = 1 <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> t = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <COMMENT> <NL> if n == 1 : <NEWLINE> <INDENT> print ( t [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> lcm = ( t [ i ] * t [ i + 1 ] ) // math . gcd ( t [ i ] , t [ i + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lcm = ( lcm * t [ i + 1 ] ) // math . gcd ( lcm , t [ i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( lcm ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> answer = 1 <NEWLINE> if len ( s ) == 1 : <NEWLINE> <INDENT> answer = s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> answer = s [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def fnc ( x ) : <NEWLINE> <INDENT> return math . floor ( A * x * 1.0 / B ) - A * math . floor ( x * 1.0 / B ) <NEWLINE> <NL> <DEDENT> if B == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif N < B : <NEWLINE> <INDENT> print ( fnc ( N ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( B - 1 , N + 1 , B ) : <NEWLINE> <INDENT> s = fnc ( i ) <NEWLINE> if s > ans : <NEWLINE> <INDENT> ans = s <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S , T = input ( ) . split ( ) <NEWLINE> S = list ( S ) <NEWLINE> T = list ( T ) <NEWLINE> ans = [ ] <NEWLINE> for s , t in zip ( S , T ) : <NEWLINE> <INDENT> ans . append ( s ) <NEWLINE> ans . append ( t ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> left = [ None for i in range ( n ) ] <NEWLINE> right = [ None for i in range ( n ) ] <NEWLINE> root = sum ( range ( n ) ) - n - 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> i , l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> left [ i ] = l <NEWLINE> right [ i ] = r <NEWLINE> root -= ( l + r ) <NEWLINE> <NL> <DEDENT> def Preorder ( i ) : <NEWLINE> <INDENT> if i == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> Preorder ( left [ i ] ) <NEWLINE> Preorder ( right [ i ] ) <NEWLINE> <NL> <DEDENT> def Inorder ( i ) : <NEWLINE> <INDENT> if i == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> Inorder ( left [ i ] ) <NEWLINE> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> Inorder ( right [ i ] ) <NEWLINE> <NL> <DEDENT> def Postorder ( i ) : <NEWLINE> <INDENT> if i == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> Postorder ( left [ i ] ) <NEWLINE> Postorder ( right [ i ] ) <NEWLINE> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> Preorder ( root ) <NEWLINE> print ( ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> Inorder ( root ) <NEWLINE> print ( ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> Postorder ( root ) <NEWLINE> print ( ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> c = Counter ( s ) <NEWLINE> ans = 1 <NEWLINE> for i in c . values ( ) : <NEWLINE> <INDENT> ans = ( ans * ( i + 1 ) ) % 1000000007 <NEWLINE> <DEDENT> print ( ans - 1 ) <NEWLINE>
<COMMENT> <NL> from functools import reduce <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> n , k , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> a . sort ( key = lambda x : abs ( x ) ) <NEWLINE> ans = reduce ( lambda a , b : ( a * b ) % mod , a [ - k : ] ) <NEWLINE> <NL> c = a [ - k : ] <NEWLINE> j = sum ( i < 0 for i in c ) % 2 <NEWLINE> if j : <NEWLINE> <INDENT> c = a [ - k : ] <NEWLINE> neg = [ i for i in c if i < 0 ] <NEWLINE> pos = [ i for i in c if i > 0 ] <NEWLINE> b = sorted ( a [ : n - k ] ) <NEWLINE> if b == [ ] : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if neg == [ ] : <NEWLINE> <INDENT> if pos [ 0 ] * b [ 0 ] < 0 : <NEWLINE> <INDENT> ans = ans * pow ( pos [ 0 ] , mod - 2 , mod ) * b [ 0 ] % mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = reduce ( lambda a , b : ( a * b ) % mod , a [ : k ] ) <NEWLINE> <DEDENT> <DEDENT> elif pos == [ ] : <NEWLINE> <INDENT> if neg [ 0 ] * b [ - 1 ] < 0 : <NEWLINE> <INDENT> ans = ans * pow ( neg [ 0 ] , mod - 2 , mod ) * b [ - 1 ] % mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = reduce ( lambda a , b : ( a * b ) % mod , a [ : k ] ) <NEWLINE> <DEDENT> <DEDENT> elif pos [ 0 ] * b [ - 1 ] < neg [ 0 ] * b [ 0 ] and pos [ 0 ] * b [ 0 ] < 0 : <NEWLINE> <INDENT> ans = ans * pow ( pos [ 0 ] , mod - 2 , mod ) * b [ 0 ] % mod <NEWLINE> <DEDENT> elif 0 > b [ - 1 ] * neg [ 0 ] : <NEWLINE> <INDENT> ans = ans * pow ( neg [ 0 ] , mod - 2 , mod ) * b [ - 1 ] % mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = reduce ( lambda a , b : ( a * b ) % mod , a [ : k ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , n = input ( ) . split ( <STRING> ) <NEWLINE> line = input ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> x = int ( x ) <NEWLINE> <NL> alist = line . split ( <STRING> ) <NEWLINE> for i in range ( int ( n ) ) : <NEWLINE> <INDENT> alist [ i ] = int ( alist [ i ] ) <NEWLINE> <DEDENT> if not x in alist : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> blist = [ i for i in range ( 0 , 102 ) ] <NEWLINE> bset = set ( blist ) <NEWLINE> aset = set ( alist ) <NEWLINE> cset = bset - aset <NEWLINE> clist = list ( cset ) <NEWLINE> clist . append ( x ) <NEWLINE> clist . sort ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for i , v in enumerate ( clist ) : <NEWLINE> <INDENT> if v == x : <NEWLINE> <INDENT> count = i <NEWLINE> <DEDENT> <DEDENT> if count == 0 : <NEWLINE> <INDENT> print ( clist [ 1 ] ) <NEWLINE> <DEDENT> elif count == len ( clist ) - 1 : <NEWLINE> <INDENT> print ( clist [ - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minx = x - clist [ count - 1 ] <NEWLINE> maxx = clist [ count + 1 ] - x <NEWLINE> if minx > maxx : <NEWLINE> <INDENT> print ( clist [ count + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( clist [ count - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x = <STRING> if a == b else 1 <NEWLINE> if x == 1 : <NEWLINE> <INDENT> x = <STRING> if a > b else <STRING> <NEWLINE> <DEDENT> print ( x ) <NEWLINE> <NL>
def abc166_d ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> for i in range ( - 126 , 127 ) : <NEWLINE> <INDENT> for j in range ( - 126 , 127 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( <STRING> . format ( i , j ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> abc166_d ( ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> <COMMENT> <NL> <NL> D = int ( readline ( ) ) <NEWLINE> C = list ( map ( int , readline ( ) . split ( ) ) ) <COMMENT> <NEWLINE> S = [ None ] * D <NEWLINE> sortS = [ None ] * D <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> s = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> S [ i ] = s . copy ( ) <NEWLINE> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> s [ j ] = ( s [ j ] , j ) <NEWLINE> <DEDENT> sortS [ i ] = sorted ( s , key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> <NL> <DEDENT> def make_ans ( D , C , limiter = 4 , threshold = 2 , balance = 0.5 ) : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> last_submit = [ 0 ] * 26 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> info = sortS [ i ] <NEWLINE> <NL> <COMMENT> <NL> if i - min ( last_submit ) >= limiter : <NEWLINE> <INDENT> ind = - 1 <NEWLINE> for j in range ( len ( last_submit ) ) : <NEWLINE> <INDENT> if i - last_submit [ j ] >= threshold : <NEWLINE> <INDENT> if ind == - 1 : <NEWLINE> <INDENT> ind = j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if C [ ind ] < C [ j ] : <NEWLINE> <INDENT> ind = j <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans += [ ind ] <NEWLINE> last_submit [ ind ] = i <NEWLINE> continue <NEWLINE> <NL> <DEDENT> topval = info [ 0 ] [ 0 ] <NEWLINE> for j in range ( len ( info ) ) : <NEWLINE> <INDENT> val = info [ j ] [ 0 ] <NEWLINE> if val < topval * ( balance ) : <NEWLINE> <INDENT> continue <COMMENT> <NEWLINE> <DEDENT> index = info [ j ] [ 1 ] <NEWLINE> if i - last_submit [ index ] < 26 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += [ index ] <NEWLINE> last_submit [ index ] = i <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += [ info [ 0 ] [ 1 ] ] <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def calc_score ( arr ) : <NEWLINE> <INDENT> point = 0 <NEWLINE> last_submit = [ 0 ] * 26 <NEWLINE> for i in range ( len ( arr ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> point += S [ i ] [ arr [ i ] ] <NEWLINE> for j in range ( len ( last_submit ) ) : <NEWLINE> <INDENT> point -= ( i - last_submit [ j ] ) * C [ j ] <NEWLINE> <DEDENT> <DEDENT> return point <NEWLINE> <NL> <DEDENT> ans = make_ans ( D , C ) <NEWLINE> <COMMENT> <NL> best = calc_score ( ans ) <NEWLINE> for limiter in range ( 36 , 52 ) : <NEWLINE> <INDENT> for threshold in range ( 26 , limiter ) : <NEWLINE> <INDENT> for balance in ( 0.25 , 0.5 , 0.75 ) : <NEWLINE> <INDENT> new_ans = make_ans ( D , C , limiter , threshold , balance ) <NEWLINE> new_score = calc_score ( new_ans ) <NEWLINE> if new_score > best : <NEWLINE> <INDENT> ans = new_ans <NEWLINE> best = new_score <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def show ( arr ) : <NEWLINE> <INDENT> for a in arr : <NEWLINE> <INDENT> print ( a + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> show ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * Q <NEWLINE> b = [ 0 ] * Q <NEWLINE> c = [ 0 ] * Q <NEWLINE> d = [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> sequences = [ ] <NEWLINE> <NL> def dfs ( seq ) : <NEWLINE> <INDENT> if len ( seq ) == N + 1 : <NEWLINE> <INDENT> sequences . append ( seq ) <NEWLINE> return <NEWLINE> <DEDENT> tail_num = seq [ - 1 ] <NEWLINE> for nxt_d in range ( tail_num , M + 1 ) : <NEWLINE> <INDENT> dfs ( seq + [ nxt_d ] ) <NEWLINE> <DEDENT> <DEDENT> dfs ( [ 1 ] ) <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> for seq in sequences : <NEWLINE> <INDENT> score = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> if int ( seq [ b [ i ] ] ) - int ( seq [ a [ i ] ] ) == c [ i ] : <NEWLINE> <INDENT> score += d [ i ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , score ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
n , z , w = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( abs ( A [ 0 ] - w ) ) ; exit ( ) <NEWLINE> <DEDENT> print ( max ( abs ( A [ - 1 ] - w ) , abs ( A [ - 2 ] - A [ - 1 ] ) ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> i = 0 <NEWLINE> ai = 0 <NEWLINE> while True : <NEWLINE> <INDENT> ai = ( ai * 10 + 7 ) % k <NEWLINE> i += 1 <NEWLINE> if ai == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
<COMMENT> <NL> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> while X + i <= 101 : <NEWLINE> <INDENT> if X + i not in P : <NEWLINE> <INDENT> ans1 = X + i <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> while X - j >= - 1 : <NEWLINE> <INDENT> if X - j not in P : <NEWLINE> <INDENT> ans2 = X - j <NEWLINE> break <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> if ans1 - X >= X - ans2 : <NEWLINE> <INDENT> print ( ans2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans1 ) <NEWLINE> <DEDENT>
M , a , t , p = 2019 , 0 , 0 , 1 ; l = [ 0 ] * M <NEWLINE> for i in input ( ) [ : : - 1 ] : l [ t % M ] += 1 ; t += int ( i ) * p ; a += l [ t % M ] ; p = p * 10 % M <NEWLINE> print ( a ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> x = int ( input ( ) ) <NEWLINE> for a in range ( - 500 , 501 ) : <NEWLINE> <INDENT> for b in range ( - 500 , 501 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( 3 / 0 ) <COMMENT> <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> <NL> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> ans , j = 0 , m <NEWLINE> <NL> <COMMENT> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> aMax = max ( a ) <NEWLINE> <NL> answer = 0 <NEWLINE> countOld = 0 <NEWLINE> <NL> for i , v in enumerate ( a ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> count = 0 <NEWLINE> count = a [ i - 1 ] + countOld - v <NEWLINE> if count < 0 : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> answer += count <NEWLINE> countOld = count <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 1 , ( n - 1 ) // 2 + 1 , 1 ) : <NEWLINE> <INDENT> if i + 2 * j < n : <NEWLINE> <INDENT> if s [ i ] != s [ i + j ] and s [ i ] != s [ i + 2 * j ] and s [ i + j ] != s [ i + 2 * j ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <DEDENT> def test_入力例_1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <DEDENT> def test_入力例_2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> allcnt = r * g * b <NEWLINE> <NL> sub = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if S [ i ] == S [ j ] : <NEWLINE> <INDENT> None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= N or S [ i ] == S [ k ] or S [ j ] == S [ k ] : <NEWLINE> <INDENT> None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sub += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( allcnt - sub ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> d = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> c_d = collections . Counter ( d ) <NEWLINE> c_t = collections . Counter ( t ) <NEWLINE> ans = <STRING> <NEWLINE> for e in c_t : <NEWLINE> <INDENT> if c_t [ e ] <= c_d [ e ] : <NEWLINE> <INDENT> next <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> if ans == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Xa = min ( K , A ) <NEWLINE> K2 = K - Xa <NEWLINE> Xb = min ( K2 , B ) <NEWLINE> Xc = K2 - Xb <NEWLINE> <NL> print ( Xa - Xc ) <NEWLINE>
<COMMENT> <NL> <NL> class Dice : <NEWLINE> <INDENT> def __init__ ( self , a1 , a2 , a3 , a4 , a5 , a6 ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . face = [ a1 , a2 , a3 , a4 , a5 , a6 ] <NEWLINE> self . v = [ a5 , a1 , a2 , a6 ] <COMMENT> <NEWLINE> self . h = [ a4 , a1 , a3 , a6 ] <COMMENT> <NEWLINE> self . det = 1 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> def top ( self ) : <NEWLINE> <INDENT> return self . v [ 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def north ( self ) : <NEWLINE> <INDENT> newV = [ self . v [ 1 ] , self . v [ 2 ] , self . v [ 3 ] , self . v [ 0 ] ] <NEWLINE> self . v = newV <NEWLINE> self . h [ 1 ] = self . v [ 1 ] <NEWLINE> self . h [ 3 ] = self . v [ 3 ] <NEWLINE> return self . v , self . h <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def south ( self ) : <NEWLINE> <INDENT> newV = [ self . v [ 3 ] , self . v [ 0 ] , self . v [ 1 ] , self . v [ 2 ] ] <NEWLINE> self . v = newV <NEWLINE> self . h [ 1 ] = self . v [ 1 ] <NEWLINE> self . h [ 3 ] = self . v [ 3 ] <NEWLINE> return self . v , self . h <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def east ( self ) : <NEWLINE> <INDENT> newH = [ self . h [ 3 ] , self . h [ 0 ] , self . h [ 1 ] , self . h [ 2 ] ] <NEWLINE> self . h = newH <NEWLINE> self . v [ 1 ] = self . h [ 1 ] <NEWLINE> self . v [ 3 ] = self . h [ 3 ] <NEWLINE> return self . v , self . h <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def west ( self ) : <NEWLINE> <INDENT> newH = [ self . h [ 1 ] , self . h [ 2 ] , self . h [ 3 ] , self . h [ 0 ] ] <NEWLINE> self . h = newH <NEWLINE> self . v [ 1 ] = self . h [ 1 ] <NEWLINE> self . v [ 3 ] = self . h [ 3 ] <NEWLINE> return self . v , self . h <NEWLINE> <NL> <DEDENT> def searchFace ( self , a ) : <NEWLINE> <INDENT> b = 0 <NEWLINE> for i in range ( 6 ) : <NEWLINE> <INDENT> if a == self . face [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> b = i + 1 <NEWLINE> <DEDENT> <DEDENT> return b <NEWLINE> <NL> <DEDENT> def detJudge ( self , x ) : <COMMENT> <NEWLINE> <INDENT> y = int ( 7 / 2 - abs ( x - 7 / 2 ) ) <NEWLINE> if x != y : <NEWLINE> <INDENT> self . det *= - 1 <NEWLINE> <COMMENT> <NL> <DEDENT> return y <NEWLINE> <NL> <DEDENT> def rightSide ( self , top , front ) : <NEWLINE> <INDENT> r = 0 <NEWLINE> if top == 1 and front == 2 : <NEWLINE> <INDENT> r = 3 <NEWLINE> <DEDENT> elif top == 2 and front == 3 : <NEWLINE> <INDENT> r = 1 <NEWLINE> <DEDENT> elif top == 3 and front == 1 : <NEWLINE> <INDENT> r = 2 <NEWLINE> <DEDENT> elif top == 1 and front == 3 : <NEWLINE> <INDENT> r = 5 <NEWLINE> <DEDENT> elif top == 3 and front == 2 : <NEWLINE> <INDENT> r = 6 <NEWLINE> <DEDENT> elif top == 2 and front == 1 : <NEWLINE> <INDENT> r = 4 <NEWLINE> <DEDENT> if self . det == - 1 : <NEWLINE> <INDENT> r = 7 - r <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> <DEDENT> diceAmount = int ( input ( ) ) <NEWLINE> dices = [ ] <NEWLINE> for i in range ( diceAmount ) : <NEWLINE> <INDENT> d = [ int ( j ) for j in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> dice = Dice ( d [ 0 ] , d [ 1 ] , d [ 2 ] , d [ 3 ] , d [ 4 ] , d [ 5 ] ) <NEWLINE> dices . append ( dice ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> import random <NEWLINE> match = 0 <NEWLINE> diceCount = 1 <NEWLINE> while match == 0 and diceCount < diceAmount : <NEWLINE> <INDENT> for d2 in range ( 1 , diceAmount ) : <NEWLINE> <COMMENT> <NL> <INDENT> i = 0 <NEWLINE> while match == 0 and i < 21 : <NEWLINE> <INDENT> j = random . randint ( 0 , 3 ) <NEWLINE> if j == 0 : <NEWLINE> <INDENT> dices [ d2 ] . north ( ) <NEWLINE> <DEDENT> elif j == 1 : <NEWLINE> <INDENT> dices [ d2 ] . south ( ) <NEWLINE> <DEDENT> elif j == 2 : <NEWLINE> <INDENT> dices [ d2 ] . east ( ) <NEWLINE> <DEDENT> elif j == 3 : <NEWLINE> <INDENT> dices [ d2 ] . west ( ) <NEWLINE> <DEDENT> for d1 in range ( d2 ) : <NEWLINE> <INDENT> if ( dices [ d1 ] . v == dices [ d2 ] . v and dices [ d1 ] . h == dices [ d2 ] . h ) : <NEWLINE> <INDENT> match += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> diceCount += 1 <NEWLINE> <DEDENT> if match >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> hw = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> hc = [ 0 ] * h <NEWLINE> wc = [ 0 ] * w <NEWLINE> d = { } <NEWLINE> for _h , _w in hw : <NEWLINE> <INDENT> hc [ _h - 1 ] += 1 <NEWLINE> wc [ _w - 1 ] += 1 <NEWLINE> d [ ( _h - 1 , _w - 1 ) ] = 1 <NEWLINE> <NL> <DEDENT> maxh = max ( hc ) <NEWLINE> maxw = max ( wc ) <NEWLINE> <NL> <NL> hoge = True <NEWLINE> wi = [ i for i in range ( w ) if wc [ i ] == maxw ] <NEWLINE> for h in [ i for i in range ( h ) if hc [ i ] == maxh ] : <NEWLINE> <INDENT> for w in wi : <NEWLINE> <INDENT> if ( h , w ) not in d : <NEWLINE> <INDENT> hoge = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if hoge : <NEWLINE> <INDENT> print ( maxh + maxw - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( maxh + maxw ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> crane = 0 <NEWLINE> while crane <= x : <NEWLINE> <INDENT> turtle = x - crane <NEWLINE> if 2 * crane + 4 * turtle == y : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> crane += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l . append ( input ( ) ) <NEWLINE> <DEDENT> k = sorted ( l ) <NEWLINE> ans = 0 <NEWLINE> a = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if k [ i ] != a : <NEWLINE> <INDENT> ans += 1 <NEWLINE> a = k [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> def maxHeapify ( A , i ) : <NEWLINE> <INDENT> l = 2 * i <NEWLINE> r = 2 * i + 1 <NEWLINE> <NL> if l <= H and A [ l ] > A [ i ] : <NEWLINE> <INDENT> largest = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest = i <NEWLINE> <NL> <DEDENT> if r <= H and A [ r ] > A [ largest ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <NL> <DEDENT> if largest != i : <NEWLINE> <INDENT> A [ i ] , A [ largest ] = A [ largest ] , A [ i ] <NEWLINE> maxHeapify ( A , largest ) <NEWLINE> <NL> <DEDENT> <DEDENT> def buildMaxHeap ( A ) : <NEWLINE> <INDENT> for i in range ( H // 2 , 0 , - 1 ) : <NEWLINE> <INDENT> maxHeapify ( A , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> H = int ( input ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> buildMaxHeap ( A ) <NEWLINE> A . pop ( 0 ) <NEWLINE> print ( <STRING> + <STRING> . join ( [ str ( num ) for num in A ] ) ) <NEWLINE> <NL>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> m = max ( a ) + 1 <NEWLINE> <NL> numbers = [ 0 ] * m <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> numbers [ i ] += 1 <NEWLINE> <NL> if numbers [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( 2 * i , m , i ) : <NEWLINE> <INDENT> numbers [ j ] += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( numbers . count ( 1 ) ) <NEWLINE>
moji_lis = [ [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , [ <STRING> , <STRING> , <STRING> ] , [ <STRING> , <STRING> , <STRING> ] , [ <STRING> , <STRING> , <STRING> ] , [ <STRING> , <STRING> , <STRING> ] , [ <STRING> , <STRING> , <STRING> ] , [ <STRING> , <STRING> , <STRING> , <STRING> ] , [ <STRING> , <STRING> , <STRING> ] , [ <STRING> , <STRING> , <STRING> , <STRING> ] ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> N_lis = list ( input ( ) ) <NEWLINE> N_lis = list ( map ( int , N_lis ) ) <NEWLINE> <NL> a_0 = N_lis [ 0 ] <NEWLINE> n_num = 1 <NEWLINE> moji = <STRING> <NEWLINE> for j in range ( 1 , len ( N_lis ) ) : <NEWLINE> <NL> <INDENT> a_1 = N_lis [ j ] <NEWLINE> <NL> if a_0 == a_1 : <NEWLINE> <INDENT> n_num += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a_0 == 1 : <NEWLINE> <INDENT> moji += moji_lis [ 0 ] [ ( n_num - 1 ) % 5 ] <NEWLINE> <NL> <DEDENT> elif a_0 == 7 or a_0 == 9 : <NEWLINE> <NL> <INDENT> moji += moji_lis [ a_0 - 1 ] [ ( n_num - 1 ) % 4 ] <NEWLINE> <NL> <NL> <DEDENT> elif a_0 != 0 : <NEWLINE> <NL> <INDENT> moji += moji_lis [ a_0 - 1 ] [ ( n_num - 1 ) % 3 ] <NEWLINE> <NL> <DEDENT> <DEDENT> a_0 = a_1 <NEWLINE> if a_1 == 0 : <NEWLINE> <INDENT> n_num = 1 <NEWLINE> <DEDENT> <DEDENT> print ( moji ) <NEWLINE> <DEDENT>
import math <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <NL> <COMMENT> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> n = readInt ( ) <NEWLINE> a = readInts ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> d = defaultdict ( int ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <NL> <DEDENT> for k in d : <NEWLINE> <INDENT> ans *= k ** d [ k ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> while A [ i ] % 2 == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> A [ i ] = A [ i ] // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> aas = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> diff = pow ( 10 , - 6 ) <NEWLINE> left = 1 <NEWLINE> right = 10 ** 9 <NEWLINE> def judge ( mid ) : <NEWLINE> <INDENT> cut = 0 <NEWLINE> for i in aas : <NEWLINE> <INDENT> cut += math . ceil ( i / mid ) - 1 <NEWLINE> <DEDENT> if cut <= k : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> while left < right : <NEWLINE> <INDENT> mid = ( left + right ) / 2 <NEWLINE> if ( left <= right <= left + diff ) or ( right <= left <= right + diff ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif judge ( mid ) : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid <NEWLINE> <DEDENT> <DEDENT> print ( math . ceil ( left ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> sub = np . bincount ( A , weights = None , minlength = N + 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( sub [ i + 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> maxA = max ( A ) <NEWLINE> <COMMENT> <NL> C = { a : 0 for a in A } <NEWLINE> for a in A : <NEWLINE> <INDENT> C [ a ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> D = { a : 0 for a in A } <NEWLINE> for a in A : <NEWLINE> <INDENT> if C [ a ] > 0 : <NEWLINE> <INDENT> t = 2 <NEWLINE> while a * t <= maxA : <NEWLINE> <INDENT> D [ a * t ] = 1 <NEWLINE> t += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if C [ a ] == 1 and D [ a ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
input ( ) <NEWLINE> print ( <STRING> . join ( input ( ) . split ( ) [ : : - 1 ] ) ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> input = sys . stdin . readline <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> g = defaultdict ( list ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <DEDENT> que = [ 1 ] <NEWLINE> ans = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> while len ( que ) > 0 : <NEWLINE> <INDENT> current = que . pop ( 0 ) <NEWLINE> for next in g [ current ] : <NEWLINE> <INDENT> if ans [ next ] == 0 : <NEWLINE> <INDENT> que . append ( next ) <NEWLINE> ans [ next ] = current <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i + K ] > A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def fanction ( n ) : <NEWLINE> <INDENT> listIn = [ ] <NEWLINE> tmp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if tmp % i == 0 : <NEWLINE> <INDENT> cnt_in = 0 <NEWLINE> while tmp % i == 0 : <NEWLINE> <INDENT> cnt_in += 1 <NEWLINE> tmp //= i <NEWLINE> <DEDENT> listIn . append ( [ i , cnt_in ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if tmp != 1 : <NEWLINE> <INDENT> listIn . append ( [ tmp , 1 ] ) <NEWLINE> <NL> <DEDENT> return listIn <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> arr = fanction ( N ) <NEWLINE> <NL> tmp = 1 <NEWLINE> count = 0 <NEWLINE> for a , b in arr : <NEWLINE> <INDENT> while <STRING> : <NEWLINE> <INDENT> if b >= tmp : <NEWLINE> <INDENT> b -= tmp <NEWLINE> count += 1 <NEWLINE> tmp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<NL> def c ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = [ <STRING> ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s [ i ] = input ( ) <NEWLINE> <DEDENT> s . sort ( ) <NEWLINE> count = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i - 1 ] != s [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> def b ( ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> c -= b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> a -= d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def a ( ) : <NEWLINE> <INDENT> s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> c ( ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if x < 0 : <NEWLINE> <INDENT> x = - 1 * x <NEWLINE> <NL> <DEDENT> if x == 0 : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if x - d * k < 0 : <NEWLINE> <INDENT> a = x % d <NEWLINE> b = x % d - d <NEWLINE> if ( ( x - x % d ) // d ) % 2 == k % 2 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 * b ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( x - d * k ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if x == i ** 5 - j ** 5 : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = deque ( ) <NEWLINE> for i in range ( 1 , 200001 ) : <NEWLINE> <INDENT> d . append ( i ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == d [ 0 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> d . popleft ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if count == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - count ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( B - 1 , N ) <NEWLINE> <NL> print ( ( A * x ) // B - A * ( x // B ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ ] <NEWLINE> A = [ ] <NEWLINE> setA = set ( A ) <NEWLINE> ListN = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ListN . append ( i ) <NEWLINE> <DEDENT> setN = set ( ListN ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> d . append ( input ( ) ) <NEWLINE> setA = setA | set ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> print ( len ( setA ^ setN ) ) <NEWLINE>
t = 0 <NEWLINE> while t == 0 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b , e , c , d , f = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = ( d * e - b * f ) / ( a * d - b * c ) + 0 <NEWLINE> y = ( a * f - c * e ) / ( a * d - b * c ) + 0 <NEWLINE> print ( <STRING> . format ( x ) + <STRING> + <STRING> . format ( y ) ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( n , b - 1 ) <NEWLINE> print ( math . floor ( a * x / b ) - a * math . floor ( x / b ) ) <NEWLINE>
import math <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = sorted ( A ) <NEWLINE> left = 0 <NEWLINE> right = max ( A ) <NEWLINE> mid = max ( ( left + right ) // 2 , 1 ) <NEWLINE> <NL> while ( right - left >= 1 ) : <NEWLINE> <INDENT> numofcut = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] % mid == 0 : <NEWLINE> <INDENT> numofcut += ( A [ i ] // mid ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> numofcut += A [ i ] // mid <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if numofcut > K : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> mid = max ( ( left + right ) // 2 , 1 ) <NEWLINE> if mid == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( mid ) <NEWLINE>
import collections as col <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def binp ( arr , val ) : <NEWLINE> <INDENT> left , right = 0 , len ( arr ) - 1 <NEWLINE> while left <= right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if val == arr [ mid ] : return 1 <NEWLINE> elif val >= arr [ mid ] : left = mid + 1 <NEWLINE> else : right = mid - 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> ap = [ a [ i ] + i for i in range ( 1 , n + 1 ) ] <NEWLINE> an = [ i - a [ i ] for i in range ( 1 , n + 1 ) ] <NEWLINE> counter = col . Counter ( an ) <NEWLINE> <NL> ans = 0 <NEWLINE> for ele in ap : <NEWLINE> <INDENT> ans += counter [ ele ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_humidai = 0 <NEWLINE> max_front_person = 0 <NEWLINE> <NL> for person_idx , person_height in enumerate ( As ) : <NEWLINE> <NL> <INDENT> if person_idx == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> max_front_person = max ( max_front_person , As [ person_idx - 1 ] ) <NEWLINE> if max_front_person > person_height : <NEWLINE> <INDENT> humidai = max_front_person - person_height <NEWLINE> sum_humidai += humidai <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum_humidai ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = [ - 1 ] <NEWLINE> P += list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> mini = 10 ** 9 <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if P [ i ] <= mini : <NEWLINE> <INDENT> mini = P [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_s = sorted ( a ) <NEWLINE> res = 1 <NEWLINE> for i in a_s : <NEWLINE> <INDENT> res *= i <NEWLINE> if res == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if res > 0 and res <= 10 ** 18 : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> list_c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list_d = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> list_d . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> now = [ 0 ] * 26 <NEWLINE> <NL> max_happy = - 100000000 <NEWLINE> index_max = - 1 <NEWLINE> yesterday = - 1 <NEWLINE> <NL> for day in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> max_happy = - 100000000 <NEWLINE> index_max = - 1 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> if i != yesterday : <NEWLINE> <INDENT> score = list_d [ day - 1 ] [ i ] <NEWLINE> for batu in range ( 26 ) : <NEWLINE> <INDENT> if batu != i : <NEWLINE> <INDENT> score -= list_c [ i ] * ( day - now [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if score > max_happy : <NEWLINE> <INDENT> index_max = i <NEWLINE> max_happy = score <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> now [ index_max ] = day <NEWLINE> yesterday = index_max <NEWLINE> <NL> print ( index_max + 1 ) <NEWLINE> <NL> <NL> <DEDENT>
import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> <NL> <NL> import math <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for x in range ( 1 , int ( math . sqrt ( n ) ) ) : <NEWLINE> <INDENT> for y in range ( 1 , int ( math . sqrt ( n ) ) ) : <NEWLINE> <INDENT> for z in range ( 1 , int ( math . sqrt ( n ) ) ) : <NEWLINE> <NL> <INDENT> e = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if e >= 1 and e <= n : <NEWLINE> <INDENT> ans [ int ( e ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( ans ) - 1 ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <NL> <NL> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> white = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> s = str ( input ( ) ) <NEWLINE> S . append ( s ) <NEWLINE> white += s . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> def main ( h , w ) : <NEWLINE> <INDENT> global H <NEWLINE> global W <NEWLINE> global S <NEWLINE> global l <NEWLINE> tmp = [ ] <NEWLINE> if h < H - 1 : <NEWLINE> <INDENT> if ( S [ h + 1 ] [ w ] == <STRING> ) and ( [ h + 1 , w ] not in l ) : <NEWLINE> <INDENT> tmp . append ( [ h + 1 , w ] ) <NEWLINE> <DEDENT> <DEDENT> if w < W - 1 : <NEWLINE> <INDENT> if ( S [ h ] [ w + 1 ] == <STRING> ) and ( [ h , w + 1 ] not in l ) : <NEWLINE> <INDENT> tmp . append ( [ h , w + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if 0 < h : <NEWLINE> <INDENT> if ( S [ h - 1 ] [ w ] == <STRING> ) and ( [ h - 1 , w ] not in l ) : <NEWLINE> <INDENT> tmp . append ( [ h - 1 , w ] ) <NEWLINE> <DEDENT> <DEDENT> if 0 < w : <NEWLINE> <INDENT> if ( S [ h ] [ w - 1 ] == <STRING> ) and ( [ h , w - 1 ] not in l ) : <NEWLINE> <INDENT> tmp . append ( [ h , w - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> return tmp <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> l = [ [ 0 , 0 ] ] <NEWLINE> tmp = [ [ 0 , 0 ] ] <NEWLINE> for i in range ( 10000 ) : <NEWLINE> <INDENT> t = [ ] <NEWLINE> for n in tmp : <NEWLINE> <INDENT> u = main ( n [ 0 ] , n [ 1 ] ) <NEWLINE> l += u <NEWLINE> t += u <NEWLINE> <DEDENT> if t == [ ] : <NEWLINE> <INDENT> ans = white + 1 <NEWLINE> <DEDENT> elif [ H - 1 , W - 1 ] in t : <NEWLINE> <INDENT> ans = i + 2 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = t <NEWLINE> <DEDENT> <DEDENT> print ( white - ans ) <NEWLINE>
import sys <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> a = abs ( N - K * ( N // K + 1 ) ) <NEWLINE> print ( min ( a , abs ( a - K ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MAX_A = max ( a ) <NEWLINE> divide_minimam_prime = [ i for i in range ( MAX_A + 1 ) ] <NEWLINE> is_prime = [ True for i in range ( MAX_A + 1 ) ] <NEWLINE> is_prime [ 0 ] = False <NEWLINE> is_prime [ 1 ] = False <NEWLINE> for div in range ( 2 , int ( MAX_A ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if is_prime [ div ] : <NEWLINE> <COMMENT> <NL> <INDENT> k = div <NEWLINE> divide_minimam_prime [ k ] = k <NEWLINE> k += div <NEWLINE> while k <= MAX_A : <NEWLINE> <INDENT> is_prime [ k ] = False <NEWLINE> if divide_minimam_prime [ k ] == k : <NEWLINE> <INDENT> divide_minimam_prime [ k ] = div <NEWLINE> <DEDENT> k += div <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> pairwise_coprime = True <NEWLINE> use_divnum = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> k = a [ i ] <NEWLINE> while k != 1 : <NEWLINE> <INDENT> if divide_minimam_prime [ k ] in use_divnum : <NEWLINE> <INDENT> pairwise_coprime = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> use_divnum . add ( divide_minimam_prime [ k ] ) <NEWLINE> <DEDENT> div = divide_minimam_prime [ k ] <NEWLINE> while k % div == 0 and k > 1 : <NEWLINE> <INDENT> k = k // div <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if pairwise_coprime : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> from math import gcd <NEWLINE> gcd_of_a = a [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> gcd_of_a = gcd ( gcd_of_a , a [ i ] ) <NEWLINE> <DEDENT> if gcd_of_a == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , x ) : <NEWLINE> <INDENT> self . key = x <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <DEDENT> <DEDENT> class BinaryTree : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def insert ( self , x ) : <NEWLINE> <INDENT> if self . root is None : <NEWLINE> <INDENT> self . root = Node ( x ) <NEWLINE> return self <NEWLINE> <NL> <DEDENT> node = self . root <NEWLINE> while True : <NEWLINE> <INDENT> if x > node . key : <NEWLINE> <INDENT> if node . right is None : <NEWLINE> <INDENT> node . right = Node ( x ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node = node . right <NEWLINE> <DEDENT> <DEDENT> elif x < node . key : <NEWLINE> <INDENT> if node . left is None : <NEWLINE> <INDENT> node . left = Node ( x ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node = node . left <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return self <NEWLINE> <NL> <DEDENT> def pre_order ( self ) : <NEWLINE> <INDENT> keys = [ ] <NEWLINE> self . do_pre_order ( self . root , keys ) <NEWLINE> print ( <STRING> + <STRING> . join ( map ( str , keys ) ) ) <NEWLINE> <NL> <DEDENT> def do_pre_order ( self , node , keys ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> keys . append ( node . key ) <NEWLINE> self . do_pre_order ( node . left , keys ) <NEWLINE> self . do_pre_order ( node . right , keys ) <NEWLINE> <NL> <DEDENT> def in_order ( self ) : <NEWLINE> <INDENT> keys = [ ] <NEWLINE> self . do_in_order ( self . root , keys ) <NEWLINE> print ( <STRING> + <STRING> . join ( map ( str , keys ) ) ) <NEWLINE> <NL> <DEDENT> def do_in_order ( self , node , keys ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> self . do_in_order ( node . left , keys ) <NEWLINE> keys . append ( node . key ) <NEWLINE> self . do_in_order ( node . right , keys ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> tree = BinaryTree ( ) <NEWLINE> lines = sys . stdin . readlines ( ) <NEWLINE> <NL> for line in lines [ 1 : ] : <NEWLINE> <INDENT> if len ( line . rstrip ( ) ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> command = line . rstrip ( ) . split ( <STRING> ) <NEWLINE> <NL> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree . insert ( int ( command [ 1 ] ) ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree . in_order ( ) <NEWLINE> tree . pre_order ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise <STRING> + command [ 0 ] <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for k , v in Counter ( a ) . items ( ) : <NEWLINE> <INDENT> if k > v : <NEWLINE> <INDENT> cnt += v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += ( v - k ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import sys <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sa_min = 1000000 <NEWLINE> for i in range ( - 110 , 210 ) : <NEWLINE> <INDENT> if i not in p_list : <NEWLINE> <INDENT> if sa_min > abs ( i - x ) : <NEWLINE> <INDENT> sa_min = abs ( i - x ) <NEWLINE> ans = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> pai = math . pi <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> print ( <STRING> . format ( pai * r ** 2 , 2 * pai * r ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> sum = 0 <NEWLINE> minsum = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> minsum += x [ i ] <NEWLINE> <DEDENT> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> minsum -= x [ i ] <NEWLINE> sum += x [ i ] * minsum <NEWLINE> if ( sum > 10 ** 9 + 7 ) : <NEWLINE> <INDENT> sum %= ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if min ( a ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> <NL> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> count = count + int ( ( N - 1 ) / ( i + 1 ) ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> que = collections . deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> <NL> if line [ 0 ] == <STRING> : <NEWLINE> <INDENT> que . appendleft ( int ( line [ 7 : ] ) ) <NEWLINE> <DEDENT> elif line [ 6 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> que . remove ( int ( line [ 7 : ] ) ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif line [ 6 ] == <STRING> : <NEWLINE> <INDENT> que . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> que . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * que ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> def popcount ( x ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> while x : <NEWLINE> <INDENT> if x % 2 == 1 : ret += 1 <NEWLINE> x //= 2 <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT> def f ( x ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> while x : <NEWLINE> <INDENT> x %= popcount ( x ) <NEWLINE> ret += 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT> from collections import Counter <NEWLINE> xpop = Counter ( x ) [ 1 ] <NEWLINE> xint_mi , xint_pl = 0 , 0 <NEWLINE> <NL> for i , y in enumerate ( x ) : <NEWLINE> <INDENT> if xpop > 1 : <NEWLINE> <INDENT> xint_mi += ( pow ( 2 , n - i - 1 , xpop - 1 ) * y ) % ( xpop - 1 ) <NEWLINE> xint_mi %= ( xpop - 1 ) <NEWLINE> <DEDENT> xint_pl += ( pow ( 2 , n - i - 1 , xpop + 1 ) * y ) % ( xpop + 1 ) <NEWLINE> xint_pl %= ( xpop + 1 ) <NEWLINE> <NL> <DEDENT> for i , y in enumerate ( x ) : <NEWLINE> <INDENT> if y and xpop > 1 : <NEWLINE> <INDENT> yint = xint_mi - pow ( 2 , n - i - 1 , xpop - 1 ) <NEWLINE> ypop = xpop - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> yint = xint_pl + pow ( 2 , n - i - 1 , xpop + 1 ) <NEWLINE> ypop = xpop + 1 <NEWLINE> <DEDENT> if y == 1 and xpop == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> yint %= ypop <NEWLINE> <COMMENT> <NL> print ( f ( yint ) + 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ input ( ) for i in range ( N ) ] <NEWLINE> B = [ input ( ) for i in range ( M ) ] <NEWLINE> <NL> <NL> def serch ( x0 , y0 ) : <NEWLINE> <INDENT> for i in range ( M ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> if x0 + i >= N or y0 + j >= N : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if A [ x0 + i ] [ y0 + j ] != B [ i ] [ j ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if M > N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> for x in range ( N ) : <NEWLINE> <INDENT> for y in range ( N ) : <NEWLINE> <INDENT> if not serch ( x , y ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> nei_L = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> nei_L [ a - 1 ] . append ( b - 1 ) <NEWLINE> nei_L [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> ans = [ - 1 ] * N <NEWLINE> queue = deque ( ) <NEWLINE> <NL> <NL> def bfs ( ) : <NEWLINE> <INDENT> queue . append ( 0 ) <NEWLINE> while queue : <NEWLINE> <INDENT> now = queue . popleft ( ) <NEWLINE> <NL> for c in nei_L [ now ] : <NEWLINE> <INDENT> if ans [ c ] == - 1 : <NEWLINE> <INDENT> ans [ c ] = now <NEWLINE> queue . append ( c ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> bfs ( ) <NEWLINE> <NL> if - 1 in ans [ 1 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( ans [ i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> box = [ 0 ] * ( k + 1 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> box [ math . gcd ( a , b ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( a , c ) * box [ a ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> elements = input ( ) . split ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> actions = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> actions . append ( input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> dict = { } <NEWLINE> for e in elements : <NEWLINE> <INDENT> count = dict . get ( e , 0 ) <NEWLINE> count += 1 <NEWLINE> dict [ e ] = count <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> for key in dict . keys ( ) : <NEWLINE> <INDENT> sum += int ( key ) * dict [ key ] <NEWLINE> <NL> <DEDENT> for act in actions : <NEWLINE> <INDENT> count = dict . get ( act [ 0 ] , 0 ) <NEWLINE> sum += ( int ( act [ 1 ] ) - int ( act [ 0 ] ) ) * count <NEWLINE> count += dict . get ( act [ 1 ] , 0 ) <NEWLINE> dict [ act [ 1 ] ] = count <NEWLINE> dict [ act [ 0 ] ] = 0 <NEWLINE> <NL> print ( str ( sum ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> INT = lambda : int ( input ( ) ) <NEWLINE> INTM = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> STRM = lambda : map ( str , input ( ) . split ( ) ) <NEWLINE> STR = lambda : str ( input ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LISTS = lambda : list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> def do ( ) : <NEWLINE> <INDENT> k = INT ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for h in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( math . gcd ( i , j ) , h ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> do ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> def div ( n ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> y = int ( n / i ) <NEWLINE> a += y * ( y + 1 ) * i / 2 <NEWLINE> <DEDENT> return int ( a ) <NEWLINE> <NL> <DEDENT> print ( div ( n ) ) <NEWLINE>
L , R , d = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> a = R // d <NEWLINE> b = ( L - 1 ) // d <NEWLINE> print ( a - b ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> <NL> mod_number = 10 ** 9 + 7 <NEWLINE> sum_A = sum ( A ) <NEWLINE> total = 0 <NEWLINE> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> sum_A = sum_A - A [ i ] <NEWLINE> total += A [ i ] * sum_A <NEWLINE> <NL> <DEDENT> ans = total % mod_number <NEWLINE> <NL> print ( ans ) <NEWLINE>
<COMMENT> <NL> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( h ) ] <NEWLINE> ans = [ ] <NEWLINE> c = 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> * w : <NEWLINE> <INDENT> if ans : <NEWLINE> <INDENT> ans . append ( ans [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( [ 0 ] * w ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> f = i . index ( <STRING> ) <NEWLINE> ans . append ( [ c ] * ( f + 1 ) ) <NEWLINE> for j in i [ f + 1 : ] : <NEWLINE> <INDENT> if j == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> ans [ - 1 ] . append ( c ) <NEWLINE> <DEDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if ans [ i ] != [ 0 ] * w : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> ans [ j ] = ans [ i ] <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( * i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> t = int ( x , 2 ) <NEWLINE> c = x . count ( <STRING> ) <NEWLINE> a = t % - ~ c <NEWLINE> b = 0 if c < 2 else t % ~ - c <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if int ( x [ i ] ) : <NEWLINE> <INDENT> if c < 2 : print ( 0 ) ; continue <NEWLINE> else : t = ( b - pow ( 2 , n - i - 1 , c - 1 ) ) % ~ - c <NEWLINE> <DEDENT> else : t = ( a + pow ( 2 , n - i - 1 , c + 1 ) ) % - ~ c <NEWLINE> z = 1 <NEWLINE> while t : <NEWLINE> <INDENT> d = bin ( t ) . count ( <STRING> ) <NEWLINE> t %= d <NEWLINE> z += 1 <NEWLINE> <DEDENT> print ( z ) <NEWLINE> <DEDENT>
import sys ; <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> if ( line . find ( <STRING> ) != - 1 ) | ( line . find ( <STRING> ) != - 1 ) | ( line . find ( <STRING> ) != - 1 ) : <NEWLINE> <INDENT> print ( line [ 0 : len ( line ) - 1 ] ) ; <NEWLINE> continue ; <NEWLINE> <NL> <DEDENT> alpha = <STRING> ; <NEWLINE> for i in range ( 1 , 26 ) : <NEWLINE> <INDENT> str = <STRING> ; <NEWLINE> for j in range ( len ( line ) - 1 ) : <NEWLINE> <INDENT> if ( ( line [ j ] == <STRING> ) | ( line [ j ] == <STRING> ) ) : <NEWLINE> <INDENT> str += line [ j ] ; <NEWLINE> continue ; <NEWLINE> <NL> <DEDENT> index = alpha . find ( line [ j ] ) ; <NEWLINE> str += alpha [ ( index + i ) % 26 ] ; <NEWLINE> <NL> <DEDENT> if ( str . find ( <STRING> ) != - 1 ) | ( str . find ( <STRING> ) != - 1 ) | ( str . find ( <STRING> ) != - 1 ) : <NEWLINE> <INDENT> print ( str ) ; <NEWLINE> break ; <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = n // ( a + b ) * a <NEWLINE> rem = n % ( a + b ) <NEWLINE> ans += min ( a , rem ) <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> f = [ 0 ] * ( 10050 ) <NEWLINE> for j in range ( int ( math . sqrt ( N ) ) ) : <NEWLINE> <INDENT> for k in range ( int ( math . sqrt ( N ) ) ) : <NEWLINE> <INDENT> for l in range ( int ( math . sqrt ( N ) ) ) : <NEWLINE> <INDENT> i = ( j + 1 ) * ( j + 1 ) + ( k + 1 ) * ( k + 1 ) + ( l + 1 ) * ( l + 1 ) + ( j + 1 ) * ( k + 1 ) + ( k + 1 ) * ( l + 1 ) + ( l + 1 ) * ( j + 1 ) <NEWLINE> if i < 10050 : <NEWLINE> <INDENT> f [ i ] = f [ i ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( f [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> mod , ans = 7 + 10 ** 9 , 0 <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] <NEWLINE> for l in range ( n ) : <NEWLINE> <INDENT> b . append ( b [ l ] + a [ l ] ) <NEWLINE> <DEDENT> for k in range ( n - 1 ) : <NEWLINE> <INDENT> s = ( b [ n ] - b [ k + 1 ] ) % mod <NEWLINE> ans += a [ k ] * s <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> ans = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> <NL> fin = [ ] <NEWLINE> num = [ 0 ] * w <NEWLINE> <NL> for l in lis : <NEWLINE> <INDENT> if l . count ( <STRING> ) != w : <NEWLINE> <INDENT> fin . append ( l ) <NEWLINE> <DEDENT> for i in range ( w ) : <NEWLINE> <INDENT> if l [ i ] == <STRING> : <NEWLINE> <INDENT> num [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for f in fin : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for i in range ( len ( num ) ) : <NEWLINE> <INDENT> if num [ i ] != h : <NEWLINE> <INDENT> ans . append ( f [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> Agents = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> L = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = i + 1 + Agents [ i ] <NEWLINE> if s in L : <NEWLINE> <INDENT> L [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ s ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> R = { } <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> s = j + 1 - Agents [ j ] <NEWLINE> if s in R : <NEWLINE> <INDENT> R [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R [ s ] = 1 <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> <NL> for key , value in L . items ( ) : <NEWLINE> <INDENT> cnt += R . get ( key , 0 ) * value <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> print ( cnt ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> for a in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for b in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> L = dict ( ) ; R = dict ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l = i + A [ i ] <NEWLINE> if l in L : <NEWLINE> <INDENT> L [ l ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ l ] = 1 <NEWLINE> <DEDENT> r = i - A [ i ] <NEWLINE> if r in R : <NEWLINE> <INDENT> R [ r ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R [ r ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for x in R : <NEWLINE> <INDENT> if x in L : <NEWLINE> <INDENT> ans += L [ x ] * R [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> rate = set ( ) <NEWLINE> free = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a < 3200 : <NEWLINE> <INDENT> rate . add ( a // 400 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> free += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( rate ) == 0 : <NEWLINE> <INDENT> color_min , color_max = 1 , n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> color_min , color_max = len ( rate ) , len ( rate ) + free <NEWLINE> <NL> <DEDENT> print ( color_min , color_max ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> <COMMENT> <NL> N = 999999 <NEWLINE> searchList = list ( range ( 3 , N + 1 , 2 ) ) <NEWLINE> primes = [ 2 ] <NEWLINE> while True : <NEWLINE> <INDENT> top = searchList . pop ( 0 ) <NEWLINE> primes . append ( top ) <NEWLINE> if top > math . sqrt ( N ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> searchList = [ s for s in searchList if s % top != 0 ] <NEWLINE> <DEDENT> primes . extend ( searchList ) <NEWLINE> <NL> <COMMENT> <NL> for line in sys . stdin : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( line ) <NEWLINE> ans = [ i for i in primes if i <= n ] <NEWLINE> print ( len ( ans ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> d = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> d [ a [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , len ( d ) ) : print ( d [ i ] ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> H , W , D = map ( int , readline ( ) . split ( ) ) <NEWLINE> X = [ ( 0 , 0 ) for _ in range ( H * W ) ] <NEWLINE> Y = [ 0 for _ in range ( H * W ) ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> A = [ int ( x ) - 1 for x in readline ( ) . split ( ) ] <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> X [ A [ j ] ] = ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , H * W - D ) : <NEWLINE> <INDENT> Y [ i + D ] = Y [ i ] + abs ( X [ i + D ] [ 0 ] - X [ i ] [ 0 ] ) + abs ( X [ i + D ] [ 1 ] - X [ i ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> Q = int ( readline ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> L , R = map ( int , readline ( ) . split ( ) ) <NEWLINE> print ( Y [ R - 1 ] - Y [ L - 1 ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> a = set ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s = int ( input ( ) ) <NEWLINE> a . add ( s ) <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % mod <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( n != 0 ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = [ ] <NEWLINE> <NL> <DEDENT> if x not in a : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . sort ( ) <NEWLINE> idx = a . index ( x ) <NEWLINE> i = max ( idx - 1 , 0 ) <NEWLINE> j = min ( idx + 1 , n - 1 ) <NEWLINE> d = 1 <NEWLINE> ans = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if ( a [ i ] != x - d ) : <NEWLINE> <INDENT> ans = x - d <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = max ( i - 1 , 0 ) <NEWLINE> <DEDENT> if ( a [ j ] != x + d ) : <NEWLINE> <INDENT> ans = x + d <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = min ( j + 1 , n - 1 ) <NEWLINE> <DEDENT> d += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> s = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> ss = math . gcd ( i + 1 , j + 1 ) <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> s += math . gcd ( ss , k + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
def Get_leafs_list ( T , p ) : <NEWLINE> <INDENT> l = p . l <NEWLINE> ans = [ ] <NEWLINE> while ( T [ l ] . r != - 1 ) : <NEWLINE> <INDENT> ans . append ( T [ l ] . r ) <NEWLINE> l = T [ l ] . r <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def rec ( T , node , p ) : <NEWLINE> <INDENT> T [ node ] . d = p <NEWLINE> if ( T [ node ] . r != - 1 ) : <NEWLINE> <INDENT> rec ( T , T [ node ] . r , p ) <NEWLINE> <DEDENT> if ( T [ node ] . l != - 1 ) : <NEWLINE> <INDENT> rec ( T , T [ node ] . l , p + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , i ) : <NEWLINE> <INDENT> self . p = - 1 <NEWLINE> self . l = - 1 <NEWLINE> self . r = - 1 <NEWLINE> self . d = 0 <NEWLINE> self . n = i <NEWLINE> <NL> <DEDENT> def Get_leafs_list ( self , T ) : <NEWLINE> <INDENT> l = self . l <NEWLINE> if l != - 1 : <NEWLINE> <INDENT> ans = [ l ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> <DEDENT> while ( T [ l ] . r != - 1 ) : <NEWLINE> <INDENT> ans . append ( T [ l ] . r ) <NEWLINE> l = T [ l ] . r <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def print_ans ( self ) : <NEWLINE> <INDENT> print ( <STRING> , self . n , end = <STRING> ) <NEWLINE> print ( <STRING> , self . p , end = <STRING> ) <NEWLINE> print ( <STRING> , self . d , end = <STRING> ) <NEWLINE> if self . l == - 1 and self . p != - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . p == - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> ans = self . Get_leafs_list ( T ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> T = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> T . append ( Node ( i ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> data = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> k = data [ 0 ] <NEWLINE> if ( data [ 1 ] != 0 ) : <COMMENT> <NEWLINE> <INDENT> for j in range ( 0 , data [ 1 ] ) : <COMMENT> <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> T [ k ] . l = data [ 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ l ] . r = data [ 2 + j ] <NEWLINE> <DEDENT> l = data [ 2 + j ] <NEWLINE> T [ l ] . p = data [ 0 ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for x in range ( 0 , n ) : <NEWLINE> <INDENT> if ( T [ x ] . p == - 1 ) : <NEWLINE> <INDENT> root = x <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> rec ( T , root , 0 ) <NEWLINE> <NL> <DEDENT> except : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> T [ i ] . d = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for x in T : <NEWLINE> <INDENT> x . print_ans ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> list_A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if list_A [ i ] < list_A [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( n * ( n - 1 ) // 2 ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif K <= A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A + ( K - A - B ) * - 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> eastNumber = S . count ( <STRING> ) <NEWLINE> westNumber = 0 <NEWLINE> minimum = N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> eastNumber -= 1 <NEWLINE> number = eastNumber + westNumber <NEWLINE> if minimum > number : <NEWLINE> <INDENT> minimum = number <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> number = eastNumber + westNumber <NEWLINE> if minimum > number : <NEWLINE> <INDENT> minimum = number <NEWLINE> <DEDENT> westNumber += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( minimum ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A == B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif B == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A > B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> a = input ( ) . split ( ) <NEWLINE> N = int ( a [ 0 ] ) <NEWLINE> M = int ( a [ 1 ] ) <NEWLINE> tm = int ( 0 ) <NEWLINE> tmp = int ( 0 ) <NEWLINE> <NL> <NL> k = [ input ( ) . split ( ) for i in range ( M ) ] <NEWLINE> <NL> uf = UnionFind ( N + 1 ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> tm = int ( k [ i ] [ 0 ] ) <NEWLINE> tmp = int ( k [ i ] [ 1 ] ) <NEWLINE> uf . union ( tm , tmp ) <NEWLINE> tm = 0 <NEWLINE> tmp = 0 <NEWLINE> <NL> <DEDENT> print ( int ( uf . group_count ( ) ) - 2 ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> <NL> N_MAX = 200000 + 5 <NEWLINE> INF = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( N_MAX ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> A = [ int ( x ) for x in sys . stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> maxA = max ( A ) <NEWLINE> <NL> <COMMENT> <NL> C = [ 0 ] * ( maxA + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> C [ a ] += 1 <NEWLINE> <NL> <DEDENT> pc = True <NEWLINE> <NL> <COMMENT> <NL> for p in range ( 2 , maxA + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for k in range ( maxA // p + 1 ) : <NEWLINE> <INDENT> cnt += C [ k * p ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if cnt > 1 : <NEWLINE> <INDENT> pc = False <NEWLINE> <NL> <DEDENT> <DEDENT> if pc : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> GCD = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> GCD = math . gcd ( GCD , A [ i ] ) <NEWLINE> <NL> <DEDENT> if GCD == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> if 400 <= x <= 599 : <NEWLINE> <INDENT> print ( 8 ) <NEWLINE> <DEDENT> elif 600 <= x <= 799 : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> elif 800 <= x <= 999 : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT> elif 1000 <= x <= 1199 : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif 1200 <= x <= 1399 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif 1400 <= x <= 1599 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif 1600 <= x <= 1799 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif 1800 <= x <= 1999 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , point ) : <NEWLINE> <INDENT> self . n = point <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <DEDENT> <DEDENT> def insert ( t , z ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = t <NEWLINE> while x != None : <NEWLINE> <INDENT> y = x <NEWLINE> if z . n < x . n : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> if y == None : <NEWLINE> <INDENT> return z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if z . n < y . n : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <DEDENT> return t <NEWLINE> <NL> <DEDENT> <DEDENT> def Pre ( t , l ) : <NEWLINE> <INDENT> l . append ( str ( t . n ) ) <NEWLINE> if t . left != None : <NEWLINE> <INDENT> Pre ( t . left , l ) <NEWLINE> <DEDENT> if t . right != None : <NEWLINE> <INDENT> Pre ( t . right , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> def In ( t , l ) : <NEWLINE> <INDENT> if t . left != None : <NEWLINE> <INDENT> In ( t . left , l ) <NEWLINE> <DEDENT> l . append ( str ( t . n ) ) <NEWLINE> if t . right != None : <NEWLINE> <INDENT> In ( t . right , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> def BST1 ( A , n ) : <NEWLINE> <INDENT> tree = None <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] == <STRING> : <NEWLINE> <INDENT> PreAns = [ ] <NEWLINE> InAns = [ ] <NEWLINE> Pre ( tree , PreAns ) <NEWLINE> In ( tree , InAns ) <NEWLINE> print ( <STRING> + <STRING> . join ( InAns ) ) <NEWLINE> print ( <STRING> + <STRING> . join ( PreAns ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = Node ( int ( A [ i ] . split ( <STRING> ) [ 1 ] ) ) <NEWLINE> tree = insert ( tree , z ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( input ( ) ) <NEWLINE> <DEDENT> BST1 ( A , n ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from sys import stdin <NEWLINE> <NL> n = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> NUMBER_OF_BUILDING = 4 <NEWLINE> FLOORS_PER_BUILDING = 3 <NEWLINE> ROOMS_PER_FLOOR = 10 <NEWLINE> <NL> official_house = [ <NEWLINE> <INDENT> [ <NEWLINE> <INDENT> [ <NEWLINE> <INDENT> 0 for _ in range ( ROOMS_PER_FLOOR ) <NEWLINE> ] for _ in range ( FLOORS_PER_BUILDING ) <NEWLINE> <DEDENT> ] for _ in range ( NUMBER_OF_BUILDING ) <NEWLINE> <DEDENT> ] <NEWLINE> <NL> <DEDENT> for cnt in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = ( int ( n ) for n in stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> official_house [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for no , building in enumerate ( official_house ) : <NEWLINE> <INDENT> if no != 0 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <NL> <DEDENT> for floor in building : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , floor ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> count = 0 <NEWLINE> l = [ 0 ] * 2019 <NEWLINE> l [ 0 ] = 1 <NEWLINE> mod = 2019 <NEWLINE> tmp = 0 <NEWLINE> <NL> for i in range ( 1 , len ( S ) + 1 ) : <NEWLINE> <INDENT> tmp = ( tmp + int ( S [ len ( S ) - i ] ) * pow ( 10 , i - 1 , mod ) ) % mod <NEWLINE> l [ tmp ] += 1 <NEWLINE> <NL> <NL> <DEDENT> for j in range ( 2019 ) : <NEWLINE> <INDENT> if l [ j ] >= 2 : <NEWLINE> <INDENT> count += l [ j ] * ( l [ j ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> x = [ ] <NEWLINE> y = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] not in x : <NEWLINE> <INDENT> x . append ( s [ i ] ) <NEWLINE> <DEDENT> if t [ i ] not in y : <NEWLINE> <INDENT> y . append ( t [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> s = s . replace ( x [ i ] , str ( i ) ) <NEWLINE> <DEDENT> for i in range ( len ( y ) ) : <NEWLINE> <INDENT> t = t . replace ( y [ i ] , str ( i ) ) <NEWLINE> <DEDENT> print ( <STRING> if s == t else <STRING> ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> from collections import Counter <NEWLINE> <NL> S = input ( ) <NEWLINE> <NL> P = 2019 <NEWLINE> N = len ( S ) <NEWLINE> <NL> def solve_2 ( S ) : <NEWLINE> <INDENT> ind = ( i for i , x in enumerate ( S , 1 ) if x % 2 == 0 ) <NEWLINE> return sum ( ind ) <NEWLINE> <NL> <DEDENT> def solve_5 ( S ) : <NEWLINE> <INDENT> ind = ( i for i , x in enumerate ( S , 1 ) if x % 5 == 0 ) <NEWLINE> return sum ( ind ) <NEWLINE> <NL> <DEDENT> def solve ( S , P ) : <NEWLINE> <INDENT> if P == 2 : <NEWLINE> <INDENT> return solve_2 ( S ) <NEWLINE> <DEDENT> if P == 5 : <NEWLINE> <INDENT> return solve_5 ( S ) <NEWLINE> <DEDENT> S = S [ : : - 1 ] <NEWLINE> T = [ 0 ] * len ( S ) <NEWLINE> T [ 0 ] = int ( S [ 0 ] ) % P <NEWLINE> power = 1 <NEWLINE> for i in range ( 1 , len ( S ) ) : <NEWLINE> <INDENT> power *= 10 <NEWLINE> power %= P <NEWLINE> T [ i ] = T [ i - 1 ] + power * int ( S [ i ] ) <NEWLINE> T [ i ] %= P <NEWLINE> <DEDENT> counter = Counter ( T ) <NEWLINE> return sum ( x * ( x - 1 ) // 2 for x in counter . values ( ) ) + counter [ 0 ] <NEWLINE> <NL> <NL> <DEDENT> print ( solve ( S , P ) ) <NEWLINE>
s = input ( ) <NEWLINE> res = 0 <NEWLINE> t = 1 <NEWLINE> p = [ 0 ] * 2019 <NEWLINE> for i in map ( int , s [ : : - 1 ] ) : <NEWLINE> <INDENT> res += i * t <NEWLINE> res %= 2019 <NEWLINE> p [ res ] += 1 <NEWLINE> t *= 10 <NEWLINE> t %= 2019 <NEWLINE> <DEDENT> print ( p [ 0 ] + sum ( ( i * ( i - 1 ) // 2 ) for i in p ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( n * m ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , W , H = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> X = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( n ) ] <NEWLINE> <NL> imos_h = [ 0 ] * ( H + 2 ) <NEWLINE> imos_w = [ 0 ] * ( W + 2 ) <NEWLINE> <NL> for x , y , w in X : <NEWLINE> <INDENT> imos_h [ max ( 0 , y - w ) ] += 1 <NEWLINE> imos_h [ min ( H + 1 , y + w ) ] -= 1 <NEWLINE> imos_w [ max ( 0 , x - w ) ] += 1 <NEWLINE> imos_w [ min ( W + 1 , x + w ) ] -= 1 <NEWLINE> <NL> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> imos_h [ h + 1 ] += imos_h [ h ] <NEWLINE> <NL> <DEDENT> for w in range ( W ) : <NEWLINE> <INDENT> imos_w [ w + 1 ] += imos_w [ w ] <NEWLINE> <NL> <DEDENT> is_w = all ( imos_w [ w ] >= 1 for w in range ( W ) ) <NEWLINE> is_h = all ( imos_h [ h ] >= 1 for h in range ( H ) ) <NEWLINE> <NL> if is_h or is_w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = list ( map ( float , input ( ) . split ( <STRING> ) ) ) <NEWLINE> ans = pow ( ( pow ( x [ 0 ] - x [ 2 ] , 2 ) + pow ( x [ 1 ] - x [ 3 ] , 2 ) ) , 0.5 ) <NEWLINE> print ( <STRING> . format ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x_list = [ ] <NEWLINE> y_list = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x_list . append ( x - y ) <NEWLINE> y_list . append ( x + y ) <NEWLINE> <DEDENT> x_list . sort ( ) <NEWLINE> y_list . sort ( ) <NEWLINE> ans = max ( x_list [ - 1 ] - x_list [ 0 ] , y_list [ - 1 ] - y_list [ 0 ] ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> l = [ i + a [ i ] for i in range ( n ) ] <NEWLINE> r = [ i - a [ i ] for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> x = { } <NEWLINE> y = { } <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x [ l [ i ] ] = 0 <NEWLINE> y [ l [ i ] ] = 0 <NEWLINE> y [ r [ i ] ] = 0 <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> x [ l [ i ] ] += 1 <NEWLINE> y [ r [ i ] ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for i in set ( x . keys ( ) ) : <NEWLINE> <INDENT> ans += x [ i ] * y [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt_h = [ 0 ] * h <NEWLINE> cnt_w = [ 0 ] * w <NEWLINE> dic = defaultdict ( int ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> h_m , w_m = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt_h [ h_m - 1 ] += 1 <NEWLINE> cnt_w [ w_m - 1 ] += 1 <NEWLINE> dic [ ( h_m - 1 , w_m - 1 ) ] += 1 <NEWLINE> <NL> <DEDENT> max_h = max ( cnt_h ) <NEWLINE> max_w = max ( cnt_w ) <NEWLINE> <NL> mh = [ ] <NEWLINE> mw = [ ] <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> if max_h == cnt_h [ i ] : <NEWLINE> <INDENT> mh . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( w ) : <NEWLINE> <INDENT> if max_w == cnt_w [ i ] : <NEWLINE> <INDENT> mw . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> flag = False <NEWLINE> for i in mh : <NEWLINE> <INDENT> for j in mw : <NEWLINE> <INDENT> if dic [ ( i , j ) ] == 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( max_h + max_w ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max_h + max_w - 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> index = 0 <NEWLINE> s = input ( ) . rstrip ( <STRING> ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> ans = s [ i ] <NEWLINE> index = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans == <STRING> or k < index + 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> cs = [ 0 ] <NEWLINE> for a in A : <NEWLINE> <INDENT> cs . append ( cs [ - 1 ] + a ) <NEWLINE> <DEDENT> cs = cs [ 1 : ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += A [ i ] * ( cs [ - 1 ] - cs [ i ] ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import copy <NEWLINE> def bfs ( count , x , y , cheese ) : <NEWLINE> <INDENT> queue = [ ( count , x , y ) ] <NEWLINE> tempVisited = copy . deepcopy ( visited ) <NEWLINE> tempVisited [ x ] [ y ] = True <NEWLINE> <NL> while len ( queue ) > 0 : <NEWLINE> <INDENT> tempc , tempx , tempy = queue . pop ( 0 ) <NEWLINE> if geo [ tempx ] [ tempy ] == cheese : <NEWLINE> <INDENT> return tempc , tempx , tempy <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> neox = tempx + dx [ i ] <NEWLINE> neoy = tempy + dy [ i ] <NEWLINE> if canGoTo ( neox , neoy , tempVisited ) : <NEWLINE> <INDENT> if ( tempc + 1 , neox , neoy ) not in queue : <NEWLINE> <INDENT> queue . append ( ( tempc + 1 , neox , neoy ) ) <NEWLINE> tempVisited [ neox ] [ neoy ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ( - 1 , - 1 , - 1 ) <NEWLINE> <NL> <DEDENT> def canGoTo ( x , y , tempVisited ) : <NEWLINE> <INDENT> if 0 <= x < H and 0 <= y < W : <NEWLINE> <INDENT> return not tempVisited [ x ] [ y ] <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> dx = [ 0 , 1 , 0 , - 1 ] <NEWLINE> dy = [ - 1 , 0 , 1 , 0 ] <NEWLINE> <NL> data = input ( ) . split ( <STRING> ) <NEWLINE> H , W , N = map ( int , data ) <NEWLINE> <NL> <COMMENT> <NL> geo = [ [ None for i in range ( W ) ] for j in range ( H ) ] <NEWLINE> visited = [ [ False for i in range ( W ) ] for j in range ( H ) ] <NEWLINE> <NL> x , y = - 1 , - 1 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> p = line [ j : j + 1 ] <NEWLINE> geo [ i ] [ j ] = p <NEWLINE> if p == <STRING> : <NEWLINE> <INDENT> visited [ i ] [ j ] = True <NEWLINE> <DEDENT> elif p == <STRING> : <NEWLINE> <INDENT> x , y , = i , j <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> count = 0 <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> count , x , y = bfs ( count , x , y , str ( n ) ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cl = [ 0 for i in range ( n + 1 ) ] <NEWLINE> for i in a : <NEWLINE> <INDENT> cl [ i ] += 1 <NEWLINE> <DEDENT> for i in cl [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> <NL> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . root ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> rx = self . root ( x ) <NEWLINE> ry = self . root ( y ) <NEWLINE> if rx == ry : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> rx , ry = ry , rx <NEWLINE> <DEDENT> self . parents [ rx ] += self . parents [ ry ] <NEWLINE> self . parents [ ry ] = rx <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> rx = self . root ( x ) <NEWLINE> ry = self . root ( y ) <NEWLINE> return rx == ry <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . root ( x ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> bridges = [ tuple ( ( int ( i ) - 1 for i in input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> islands = UnionFind ( n ) <NEWLINE> res = [ n * ( n - 1 ) // 2 ] <NEWLINE> for a , b in bridges [ : 0 : - 1 ] : <NEWLINE> <INDENT> if islands . same ( a , b ) : <NEWLINE> <INDENT> res . append ( res [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res . append ( res [ - 1 ] - islands . size ( a ) * islands . size ( b ) ) <NEWLINE> islands . unite ( a , b ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , res [ : : - 1 ] ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> while True : <NEWLINE> <INDENT> h , w = [ int ( val ) for val in sys . stdin . readline ( ) . split ( <STRING> ) ] <NEWLINE> if 0 == h and 0 == w : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> pa = [ <STRING> , <STRING> ] <NEWLINE> ouput = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> ouput . append ( pa [ ( i + j ) & 1 ] ) <NEWLINE> <DEDENT> ouput . append ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ouput ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> B = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> B [ ( A [ i ] - 1 ) ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> print ( B [ j ] ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> row = n <NEWLINE> tab = [ ] <NEWLINE> for i in range ( row ) : <NEWLINE> <INDENT> r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r . append ( sum ( r ) ) <NEWLINE> tab . append ( r ) <NEWLINE> <NL> <DEDENT> bel = [ ] <NEWLINE> for i in range ( row ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for j in range ( row ) : <NEWLINE> <INDENT> tmp += tab [ j ] [ i ] <NEWLINE> <DEDENT> bel . append ( tmp ) <NEWLINE> <DEDENT> bel . append ( sum ( bel ) ) <NEWLINE> tab . append ( bel ) <NEWLINE> <NL> for i in range ( row + 1 ) : <NEWLINE> <INDENT> for j in range ( row + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> print ( <STRING> . format ( str ( tab [ i ] [ j ] ) ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
from numpy import * <NEWLINE> def main ( ) : <NEWLINE> <INDENT> c = zeros ( ( 50 , 50 ) , int_ ) <NEWLINE> r = 0 <NEWLINE> for a in [ * open ( 0 ) ] [ 1 : ] : <NEWLINE> <INDENT> a = round ( float ( a ) * 1e9 ) <NEWLINE> y = 0 <NEWLINE> while a % 5 < 1 : <NEWLINE> <INDENT> a //= 5 <NEWLINE> y += 1 <NEWLINE> <DEDENT> x = int ( log2 ( a & - a ) ) <NEWLINE> r += sum ( c [ max ( 0 , 18 - x ) : , max ( 0 , 18 - y ) : ] ) <NEWLINE> c [ x ] [ y ] += 1 <NEWLINE> <DEDENT> print ( r ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> powlis = [ 7 * pow ( 10 , i , K ) for i in range ( K ) ] <NEWLINE> for i in range ( K - 1 ) : <NEWLINE> <INDENT> powlis [ i + 1 ] = ( powlis [ i ] + powlis [ i + 1 ] ) % K <NEWLINE> <DEDENT> powlis [ 0 ] %= K <NEWLINE> <NL> <NL> try : <NEWLINE> <INDENT> print ( powlis . index ( 0 ) + 1 ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import math <NEWLINE> import collections <NEWLINE> import fractions <NEWLINE> import itertools <NEWLINE> import functools <NEWLINE> import operator <NEWLINE> <NL> def ncr ( n , r ) : <NEWLINE> <INDENT> if n < r : return 0 <NEWLINE> r = min ( r , n - r ) <NEWLINE> if r == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> numer = functools . reduce ( operator . mul , range ( n , n - r , - 1 ) , 1 ) <NEWLINE> denom = functools . reduce ( operator . mul , range ( 1 , r + 1 ) , 1 ) <NEWLINE> return numer // denom % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans = ( ncr ( k - 1 , i - 1 ) * ncr ( n - k + 1 , i ) ) % ( 10 ** 9 + 7 ) <NEWLINE> print ( int ( ans ) ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = 1000000007 <NEWLINE> <NL> fac = [ 0 ] * ( N + 1 ) <NEWLINE> fac [ 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> fac [ i + 1 ] = fac [ i ] * ( i + 1 ) % m <NEWLINE> <NL> <NL> <DEDENT> def mcomb ( n , k ) : <NEWLINE> <INDENT> if n == 0 and k == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if n < k or k < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return fac [ n ] * pow ( fac [ n - k ] , m - 2 , m ) * pow ( fac [ k ] , m - 2 , m ) % m <NEWLINE> <NL> <NL> <DEDENT> A . sort ( reverse = True ) <NEWLINE> maxX = 0 <NEWLINE> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> maxX += A [ i ] * mcomb ( N - ( i + 1 ) , K - 1 ) <NEWLINE> maxX %= m <NEWLINE> <NL> <DEDENT> A . sort ( ) <NEWLINE> minX = 0 <NEWLINE> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> minX += A [ i ] * mcomb ( N - ( i + 1 ) , K - 1 ) <NEWLINE> minX %= m <NEWLINE> <NL> <DEDENT> print ( ( maxX - minX ) % m ) <NEWLINE>
from heapq import heappop , heappush <NEWLINE> from math import sqrt <NEWLINE> def distf ( xyr , i , j ) : <NEWLINE> <INDENT> x , y , r = xyr [ i ] <NEWLINE> x1 , y1 , r1 = xyr [ j ] <NEWLINE> d = max ( 0 , sqrt ( ( x - x1 ) ** 2 + ( y - y1 ) ** 2 ) - r - r1 ) <NEWLINE> return d <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> xs , ys , xt , yt = map ( int , input ( ) . split ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> xyr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> xyr . append ( [ xs , ys , 0 ] ) <NEWLINE> xyr . append ( [ xt , yt , 0 ] ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> dist = [ [ inf ] * ( n + 2 ) for _ in range ( n + 2 ) ] <NEWLINE> for i in range ( n + 2 ) : <NEWLINE> <INDENT> dist [ i ] [ i ] = 0 <NEWLINE> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 2 ) : <NEWLINE> <INDENT> dist [ i ] [ j ] = distf ( xyr , i , j ) <NEWLINE> dist [ j ] [ i ] = dist [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> seen = [ inf ] * ( n + 2 ) <NEWLINE> seen [ n ] = 0 <NEWLINE> mi = set ( range ( n + 2 ) ) <NEWLINE> while mi : <NEWLINE> <INDENT> d , v = inf , - 1 <NEWLINE> for j in mi : <NEWLINE> <INDENT> if d > seen [ j ] : <NEWLINE> <INDENT> d = seen [ j ] <NEWLINE> v = j <NEWLINE> <DEDENT> <DEDENT> mi . remove ( v ) <NEWLINE> for nv in mi : <NEWLINE> <INDENT> nd = dist [ v ] [ nv ] <NEWLINE> if seen [ nv ] > seen [ v ] + nd : <NEWLINE> <INDENT> seen [ nv ] = seen [ v ] + nd <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( seen [ n + 1 ] ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for a in A : <NEWLINE> <INDENT> ans [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> u = UnionFind ( n ) <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> u . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , u . size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL>
import collections <NEWLINE> S = input ( ) [ : : - 1 ] <NEWLINE> l = len ( S ) <NEWLINE> T , d = 0 , 1 <NEWLINE> A = [ 0 ] * 2019 <NEWLINE> A [ 0 ] = 1 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> T += int ( S [ i ] ) * d <NEWLINE> d *= 10 <NEWLINE> T %= 2019 <NEWLINE> d %= 2019 <NEWLINE> A [ T ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for cnt in A : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> rc = s . count ( <STRING> ) <NEWLINE> gc = s . count ( <STRING> ) <NEWLINE> bc = s . count ( <STRING> ) <NEWLINE> ans = rc * gc * bc <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = j * 2 - i <NEWLINE> if k >= n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
[ a , b ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if X == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> tx = X % M <NEWLINE> tl = [ ] <NEWLINE> ts = set ( ) <NEWLINE> ttl = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tl . append ( tx ) <NEWLINE> ts . add ( tx ) <NEWLINE> tx = pow ( tx , 2 , M ) <NEWLINE> if tx in ts : <NEWLINE> <INDENT> ttl = tl [ tl . index ( tx ) : ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> ans = sum ( tl ) <NEWLINE> if len ( ttl ) > 0 : <NEWLINE> <INDENT> d , m = divmod ( N - len ( tl ) , len ( ttl ) ) <NEWLINE> ans += sum ( ttl ) * d + sum ( ttl [ : m ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 1 ] <NEWLINE> a = 1 <NEWLINE> check = [ 0 ] * len ( A ) <NEWLINE> while True : <NEWLINE> <INDENT> a = A [ a - 1 ] <NEWLINE> if check [ a - 1 ] == 1 : <NEWLINE> <INDENT> x = B . index ( a ) <NEWLINE> roop = B [ x : ] <NEWLINE> print ( roop [ ( K - x ) % len ( roop ) ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> B . append ( a ) <NEWLINE> check [ a - 1 ] += 1 <NEWLINE> if len ( B ) >= K + 1 : <NEWLINE> <INDENT> print ( B [ K ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> print ( s [ : r ] . count ( <STRING> ) ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> class Daise : <NEWLINE> <INDENT> def __init__ ( self , info_list ) : <NEWLINE> <INDENT> self . T = info_list [ 0 ] <NEWLINE> self . S = info_list [ 1 ] <NEWLINE> self . E = info_list [ 2 ] <NEWLINE> self . W = info_list [ 3 ] <NEWLINE> self . N = info_list [ 4 ] <NEWLINE> self . B = info_list [ 5 ] <NEWLINE> <NL> <DEDENT> def change ( self , axis ) : <NEWLINE> <INDENT> if axis == <STRING> : <NEWLINE> <INDENT> self . T , self . B , self . S , self . N = self . N , self . S , self . T , self . B <NEWLINE> <NL> <DEDENT> elif axis == <STRING> : <NEWLINE> <INDENT> self . T , self . B , self . E , self . W = self . W , self . E , self . T , self . B <NEWLINE> <NL> <DEDENT> elif axis == <STRING> : <NEWLINE> <INDENT> self . T , self . B , self . W , self . E = self . E , self . W , self . T , self . B <NEWLINE> <NL> <DEDENT> elif axis == <STRING> : <NEWLINE> <INDENT> self . T , self . B , self . N , self . S = self . S , self . N , self . T , self . B <NEWLINE> <NL> <DEDENT> elif axis == <STRING> : <NEWLINE> <INDENT> self . S , self . E , self . N , self . W = self . E , self . N , self . W , self . S <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def output ( self ) : <NEWLINE> <INDENT> return [ self . T , self . S , self . E , self . W , self . N , self . B ] <NEWLINE> <NL> <NL> <DEDENT> def set_info ( self , top , front ) : <NEWLINE> <INDENT> if front in ( self . T , self . B ) : <NEWLINE> <INDENT> self . change ( <STRING> ) <NEWLINE> <NL> <DEDENT> while self . S != front : <NEWLINE> <INDENT> self . change ( <STRING> ) <NEWLINE> <NL> <DEDENT> while self . T != top : <NEWLINE> <INDENT> self . change ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> daiseA = Daise ( list ( map ( str , input ( ) . split ( ) ) ) ) <NEWLINE> daiseB = Daise ( list ( map ( str , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> for _ in range ( 4 ) : <NEWLINE> <INDENT> for _ in range ( 4 ) : <NEWLINE> <INDENT> if daiseA . output ( ) == daiseB . output ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for _ in range ( 4 ) : <NEWLINE> <INDENT> if daiseA . output ( ) == daiseB . output ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> daiseB . change ( <STRING> ) <NEWLINE> <DEDENT> daiseB . change ( <STRING> ) <NEWLINE> <DEDENT> daiseB . change ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = X <NEWLINE> x = X <NEWLINE> <NL> C = [ 0 , x ] <NEWLINE> Xd = [ - 1 ] * ( M + 1 ) <NEWLINE> Xd [ x ] = 0 <NEWLINE> i = 1 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> x = x ** 2 % M <NEWLINE> <NL> if Xd [ x ] > - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> Xd [ x ] = i <NEWLINE> ans += x <NEWLINE> C . append ( ans ) <NEWLINE> <NL> <DEDENT> loop_len = i - Xd [ x ] <NEWLINE> if loop_len > 0 : <NEWLINE> <INDENT> S = C [ i ] - C [ Xd [ x ] ] <NEWLINE> loop_num = ( N - i ) // loop_len <NEWLINE> ans += loop_num * S <NEWLINE> m = N - loop_num * loop_len - i <NEWLINE> ans += C [ Xd [ x ] + m ] - C [ Xd [ x ] ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def g ( x , y , z ) : <NEWLINE> <INDENT> g_xyz = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> return g_xyz <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> ans_list = [ 0 for _ in range ( 60000 ) ] <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> ans_list [ g ( x = x , y = y , z = z ) - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans_list [ i ] ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> A [ i ] = A [ i - 1 ] + a [ i - 1 ] <NEWLINE> <NL> <DEDENT> B = [ 0 ] * ( m + 1 ) <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> B [ i ] = B [ i - 1 ] + b [ i - 1 ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> best = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( best , - 1 , - 1 ) : <NEWLINE> <INDENT> t = A [ i ] + B [ j ] <NEWLINE> if t <= k : <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> best = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> <NL> def g ( nx , ny , nz ) : <NEWLINE> <INDENT> return nx ** 2 + ny ** 2 + nz ** 2 + nx * ny + ny * nz + nz * nx <NEWLINE> <NL> <NL> <DEDENT> def solve ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> max_z = max ( 1 , int ( math . sqrt ( n - 2 ) - 1 ) if n > 2 else 1 ) <NEWLINE> <COMMENT> <NL> <NL> counter = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> <NL> for z in range ( 1 , max_z + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , max_z + 1 ) : <NEWLINE> <INDENT> for x in range ( 1 , max_z + 1 ) : <NEWLINE> <INDENT> gn = g ( x , y , z ) <NEWLINE> if gn <= n : <NEWLINE> <INDENT> counter [ gn ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( counter [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> solve ( N ) <NEWLINE> <NL>
from math import ceil , floor , comb , factorial , gcd , pow , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heappop , heappush <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> n , m = MAP ( ) <NEWLINE> a = LIST ( ) <NEWLINE> b = [ LIST ( ) for i in range ( m ) ] <NEWLINE> b . sort ( key = itemgetter ( 1 ) , reverse = True ) <NEWLINE> <NL> c = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> c += [ b [ i ] [ 1 ] ] * b [ i ] [ 0 ] <NEWLINE> if len ( c ) > n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> a += c <NEWLINE> a . sort ( reverse = True ) <NEWLINE> print ( sum ( a [ : n ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> klist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> plist = [ ] <NEWLINE> i = 0 <NEWLINE> k = 1 <NEWLINE> a = 2 ** i - 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> if klist [ a : a + 2 ** i ] != [ ] : <NEWLINE> <INDENT> plist . append ( klist [ a : a + 2 ** i ] ) <NEWLINE> <DEDENT> else : break <NEWLINE> a += 2 ** i <NEWLINE> i += 1 <NEWLINE> <DEDENT> for i in range ( len ( plist ) ) : <NEWLINE> <INDENT> for j in range ( len ( plist [ i ] ) ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( <STRING> + str ( k ) + <STRING> + str ( plist [ 0 ] [ 0 ] ) + <NEWLINE> <INDENT> <STRING> + str ( plist [ 1 ] [ 0 ] ) + <NEWLINE> <STRING> + str ( plist [ 1 ] [ 1 ] ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> l = int ( j / 2 ) <NEWLINE> print ( <STRING> + str ( k ) + <STRING> + str ( plist [ i ] [ j ] ) + <NEWLINE> <INDENT> <STRING> + str ( plist [ i - 1 ] [ l ] ) + <STRING> + <NEWLINE> str ( plist [ i + 1 ] [ 2 * j ] ) , end = <STRING> ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> print ( <STRING> + str ( plist [ i + 1 ] [ 2 * j + 1 ] ) + <STRING> ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> l = int ( j / 2 ) <NEWLINE> print ( <STRING> + str ( k ) + <STRING> + str ( plist [ i ] [ j ] ) + <NEWLINE> <INDENT> <STRING> + str ( plist [ i - 1 ] [ l ] ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> k += 1 <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> largest = N // i * i <NEWLINE> ans += ( ( largest + i ) * ( N // i ) ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ls = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if 0 in ls : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> res = 1 <NEWLINE> for x in ls : <NEWLINE> <INDENT> if res <= 1000000000000000000 : <NEWLINE> <INDENT> res *= x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res if res <= 1000000000000000000 else - 1 ) <NEWLINE>
from collections import deque <NEWLINE> A = deque ( map ( str , input ( ) ) ) <NEWLINE> B = deque ( map ( str , input ( ) ) ) <NEWLINE> C = deque ( map ( str , input ( ) ) ) <NEWLINE> x = A . popleft ( ) <NEWLINE> for _ in range ( 10000000 ) : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> if A : <NEWLINE> <INDENT> x = A . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> if B : <NEWLINE> <INDENT> x = B . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if C : <NEWLINE> <INDENT> x = C . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> numW = 0 <NEWLINE> numR = c . count ( <STRING> ) <NEWLINE> W = n - numR <NEWLINE> a = [ ] <NEWLINE> if numR == 0 or W == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> numW += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> numR -= 1 <NEWLINE> <DEDENT> a . append ( max ( numR , numW ) ) <NEWLINE> <DEDENT> print ( min ( a ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_sum = sum ( A ) <NEWLINE> <NL> value = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> A_sum -= A [ i ] <NEWLINE> value += A [ i ] * A_sum <NEWLINE> <NL> <DEDENT> ans = value % ( 1 * 10 ** 9 + 7 ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> blank = [ 0 ] * n <NEWLINE> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> blank [ arr [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in blank : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> k = S - i - j <NEWLINE> if i + j + k == S : <NEWLINE> <INDENT> if 0 <= k <= K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> history = { } <NEWLINE> cycle = [ ] <NEWLINE> pos = 1 <NEWLINE> isEnd = False <NEWLINE> for i in range ( 2 * N ) : <NEWLINE> <INDENT> if pos in history : <NEWLINE> <INDENT> for j in range ( len ( cycle ) ) : <NEWLINE> <INDENT> if cycle [ j ] == pos : <NEWLINE> <INDENT> head = cycle [ : j ] <NEWLINE> cycle = cycle [ j : ] <NEWLINE> isEnd = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if isEnd : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> history [ pos ] = 1 <NEWLINE> cycle . append ( pos ) <NEWLINE> pos = As [ pos - 1 ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> if K < len ( head ) : <NEWLINE> <INDENT> print ( head [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mod = ( K - len ( head ) ) % len ( cycle ) <NEWLINE> print ( cycle [ mod ] ) <NEWLINE> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> total = sum ( A ) <NEWLINE> <NL> l = [ [ i , 0 ] for i in range ( 10 ** 5 + 1 ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> l [ A [ _ ] ] [ 1 ] += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> total -= ( l [ b ] [ 0 ] * l [ b ] [ 1 ] ) <NEWLINE> tmp = ( l [ c ] [ 0 ] * ( l [ c ] [ 1 ] + l [ b ] [ 1 ] ) ) <NEWLINE> total -= ( l [ c ] [ 0 ] * l [ c ] [ 1 ] ) <NEWLINE> total += tmp <NEWLINE> print ( total ) <NEWLINE> l [ c ] [ 1 ] += l [ b ] [ 1 ] <NEWLINE> l [ b ] [ 1 ] = 0 <NEWLINE> <COMMENT> <NL> <DEDENT>
<COMMENT> <NL> import sys , math , collections , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = input ( ) . rstrip ( ) <NEWLINE> <NL> stand = [ ] <NEWLINE> s_or_r = [ ] <NEWLINE> <NL> s_bf = <STRING> <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if s_bf != S [ i ] and i != 0 : <NEWLINE> <INDENT> stand . append ( cnt ) <NEWLINE> s_or_r . append ( s_bf ) <NEWLINE> cnt = 1 <NEWLINE> s_bf = S [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> s_bf = S [ i ] <NEWLINE> <DEDENT> <DEDENT> stand . append ( cnt ) <NEWLINE> s_or_r . append ( s_bf ) <NEWLINE> <NL> <NL> <COMMENT> <NL> if s_or_r . count ( <STRING> ) <= K : <NEWLINE> <INDENT> print ( len ( S ) ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> if s_or_r [ 0 ] == <STRING> : <NEWLINE> <INDENT> s_or_r = [ <STRING> ] + s_or_r <NEWLINE> stand = [ 0 ] + stand <NEWLINE> <DEDENT> if s_or_r [ - 1 ] == <STRING> : <NEWLINE> <INDENT> s_or_r . append ( <STRING> ) <NEWLINE> stand . append ( 0 ) <NEWLINE> <COMMENT> <NL> <DEDENT> tmp = sum ( stand [ 0 : 2 * K + 1 ] ) <NEWLINE> ans = tmp <NEWLINE> for i in range ( 2 , len ( stand ) - 2 * K , 2 ) : <NEWLINE> <INDENT> tmp += - ( stand [ i - 1 ] + stand [ i - 2 ] ) + stand [ i + 2 * K - 1 ] + stand [ i + 2 * K ] <NEWLINE> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
import bisect <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( lambda x : int ( x ) , input ( ) . split ( ) ) <NEWLINE> w = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> cumulative_sum = [ 0 ] <NEWLINE> for weight in w : <NEWLINE> <INDENT> cumulative_sum . append ( cumulative_sum [ - 1 ] + weight ) <NEWLINE> <DEDENT> p_min , p_max = max ( w ) , cumulative_sum [ - 1 ] <NEWLINE> <NL> while p_min != p_max : <NEWLINE> <INDENT> p_mid = ( p_min + p_max ) // 2 <NEWLINE> left_track = k <NEWLINE> index = 1 <NEWLINE> while left_track > 0 : <NEWLINE> <INDENT> left_track -= 1 <NEWLINE> index = bisect . bisect_right ( cumulative_sum , cumulative_sum [ index - 1 ] + p_mid ) <NEWLINE> if index == len ( cumulative_sum ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> p_min = p_mid + 1 <NEWLINE> continue <NEWLINE> <DEDENT> p_max = p_mid <NEWLINE> <NL> <DEDENT> print ( p_min ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> <NL> N , C = MAP ( ) <NEWLINE> <NL> n = [ [ ] for _ in range ( C ) ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> s , t , c = MAP ( ) <NEWLINE> n [ c - 1 ] . append ( ( s , t ) ) <NEWLINE> <NL> <DEDENT> m = [ [ ] for _ in range ( C ) ] <NEWLINE> <NL> for i in range ( C ) : <NEWLINE> <INDENT> if n [ i ] == [ ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> n [ i ] . sort ( key = lambda y : y [ 0 ] ) <NEWLINE> s = n [ i ] [ 0 ] [ 0 ] <NEWLINE> t = n [ i ] [ 0 ] [ 1 ] <NEWLINE> L = len ( n [ i ] ) <NEWLINE> n [ i ] . append ( ( 0 , 0 ) ) <NEWLINE> for j in range ( L ) : <NEWLINE> <INDENT> if j < L and n [ i ] [ j ] [ 1 ] == n [ i ] [ j + 1 ] [ 0 ] : <NEWLINE> <INDENT> t = n [ i ] [ j + 1 ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m [ i ] . append ( ( s , t ) ) <NEWLINE> s = n [ i ] [ j + 1 ] [ 0 ] <NEWLINE> t = n [ i ] [ j + 1 ] [ 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> cnt = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> <NL> for x in m : <NEWLINE> <INDENT> for s , t in x : <NEWLINE> <INDENT> cnt [ s - 1 ] += 1 <NEWLINE> cnt [ t ] -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> cnt = list ( accumulate ( cnt ) ) <NEWLINE> <COMMENT> <NL> print ( max ( cnt ) ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 9999999999 <NEWLINE> lists = [ ] <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if not i in p : <NEWLINE> <INDENT> lists . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in lists : <NEWLINE> <INDENT> if ans > abs ( x - i ) : <NEWLINE> <INDENT> ans = abs ( x - i ) <NEWLINE> m = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
import collections <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = <STRING> . join ( [ <STRING> . join ( input ( ) . split ( ) ) for _ in range ( h ) ] ) <NEWLINE> <NL> ctr = collections . Counter ( s ) <NEWLINE> if h % 2 == 0 and w % 2 == 0 : <NEWLINE> <INDENT> four , two = h * w // 4 , 0 <NEWLINE> <DEDENT> elif h % 2 == 0 : <NEWLINE> <INDENT> four , two = ( h * w - h ) // 4 , h // 2 <NEWLINE> <DEDENT> elif w % 2 == 0 : <NEWLINE> <INDENT> four , two = ( h * w - w ) // 4 , w // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> four , two = ( h * w - h - w + 1 ) // 4 , ( h + w - 1 ) // 2 <NEWLINE> <NL> <DEDENT> cf = sum ( [ c // 4 for c in ctr . values ( ) ] ) <NEWLINE> ct = sum ( [ ( c % 4 ) // 2 for c in ctr . values ( ) ] ) <NEWLINE> <NL> if cf >= four and ct + 2 * ( cf - four ) >= two : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> X = [ - 1 ] * m <NEWLINE> P = [ ] <NEWLINE> sum_p = 0 <NEWLINE> while X [ x ] == - 1 : <COMMENT> <NEWLINE> <INDENT> X [ x ] = len ( P ) <COMMENT> <NEWLINE> P . append ( sum_p ) <COMMENT> <NEWLINE> sum_p += x <COMMENT> <NEWLINE> x = x * x % m <NEWLINE> <DEDENT> P . append ( sum_p ) <COMMENT> <NEWLINE> <NL> p_len = len ( P ) - 1 <NEWLINE> if n <= p_len : <NEWLINE> <INDENT> print ( P [ n ] ) <COMMENT> <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> cyc_times , nxt_len = divmod ( n - X [ x ] , p_len - X [ x ] ) <NEWLINE> cyc = ( sum_p - P [ X [ x ] ] ) * cyc_times <NEWLINE> remain = P [ X [ x ] + nxt_len ] <NEWLINE> print ( cyc + remain ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> <NL> sys . setrecursionlimit ( 10000 ) <NEWLINE> <NL> def solve ( n , start ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> for i in range ( start , int ( math . sqrt ( n + 1 ) ) ) : <NEWLINE> <INDENT> sys . stderr . write ( <STRING> . format ( i ) ) <NEWLINE> <NL> if n % i == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> sys . stderr . write ( <STRING> . format ( n , i ) ) <NEWLINE> sys . stderr . write ( <STRING> . format ( i ) ) <NEWLINE> cnt = 1 <NEWLINE> tmp = n // i <NEWLINE> while ( tmp % ( i ** ( cnt + 1 ) ) == 0 ) : <NEWLINE> <INDENT> sys . stderr . write ( <STRING> . format ( i , cnt + 1 ) ) <NEWLINE> tmp = tmp // ( i ** ( cnt + 1 ) ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> while ( tmp % i == 0 ) : <NEWLINE> <INDENT> tmp = tmp // i <NEWLINE> <NL> <DEDENT> return solve ( tmp , i + 1 ) + cnt <NEWLINE> <NL> <DEDENT> <DEDENT> return 1 <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> ans = solve ( N , 2 ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> sys . exit ( main ( ) ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> N = len ( S ) <NEWLINE> <NL> mod = 2019 <NEWLINE> d = [ 0 for i in range ( 2019 ) ] <NEWLINE> d [ 0 ] = 1 <NEWLINE> t = 1 <NEWLINE> rem = 0 <NEWLINE> <NL> for i in reversed ( S ) : <NEWLINE> <INDENT> rem += int ( i ) * t <NEWLINE> rem %= mod <NEWLINE> t *= 10 <NEWLINE> t %= mod <NEWLINE> d [ rem ] += 1 <NEWLINE> <NL> <DEDENT> print ( int ( sum ( [ i * ( i - 1 ) / 2 for i in d ] ) ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> ans = [ <NEWLINE> 1 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 76 , <NEWLINE> 141 , <NEWLINE> 267 , <NEWLINE> 400 , <NEWLINE> 624 , <NEWLINE> 885 , <NEWLINE> 1249 , <NEWLINE> 1590 , <NEWLINE> 2208 , <NEWLINE> 2689 , <NEWLINE> 3411 , <NEWLINE> 4248 , <NEWLINE> 5248 , <NEWLINE> 6081 , <NEWLINE> 7485 , <NEWLINE> 8530 , <NEWLINE> 10248 , <NEWLINE> 11889 , <NEWLINE> 13687 , <NEWLINE> 15228 , <NEWLINE> 17988 , <NEWLINE> 20053 , <NEWLINE> 22569 , <NEWLINE> 25242 , <NEWLINE> 28588 , <NEWLINE> 31053 , <NEWLINE> 35463 , <NEWLINE> 38284 , <NEWLINE> 42540 , <NEWLINE> 46581 , <NEWLINE> 50893 , <NEWLINE> 55362 , <NEWLINE> 61824 , <NEWLINE> 65857 , <NEWLINE> 71247 , <NEWLINE> 76884 , <NEWLINE> 84388 , <NEWLINE> 89349 , <NEWLINE> 97881 , <NEWLINE> 103342 , <NEWLINE> 111528 , <NEWLINE> 120141 , <NEWLINE> 128047 , <NEWLINE> 134580 , <NEWLINE> 146316 , <NEWLINE> 154177 , <NEWLINE> 164817 , <NEWLINE> 174438 , <NEWLINE> 185836 , <NEWLINE> 194157 , <NEWLINE> 207927 , <NEWLINE> 218812 , <NEWLINE> 233268 , <NEWLINE> 245277 , <NEWLINE> 257857 , <NEWLINE> 268182 , <NEWLINE> 288216 , <NEWLINE> 299257 , <NEWLINE> 313635 , <NEWLINE> 330204 , <NEWLINE> 347836 , <NEWLINE> 362973 , <NEWLINE> 383709 , <NEWLINE> 397042 , <NEWLINE> 416448 , <NEWLINE> 434025 , <NEWLINE> 456967 , <NEWLINE> 471948 , <NEWLINE> 499740 , <NEWLINE> 515581 , <NEWLINE> 536073 , <NEWLINE> 559758 , <NEWLINE> 583960 , <NEWLINE> 604833 , <NEWLINE> 633651 , <NEWLINE> 652216 , <NEWLINE> 683712 , <NEWLINE> 709065 , <NEWLINE> 734233 , <NEWLINE> 754734 , <NEWLINE> 793188 , <NEWLINE> 818917 , <NEWLINE> 846603 , <NEWLINE> 874512 , <NEWLINE> 909496 , <NEWLINE> 933081 , <NEWLINE> 977145 , <NEWLINE> 1006126 , <NEWLINE> 1041504 , <NEWLINE> 1073385 , <NEWLINE> 1106467 , <NEWLINE> 1138536 , <NEWLINE> 1187112 , <NEWLINE> 1215145 , <NEWLINE> 1255101 , <NEWLINE> 1295142 , <NEWLINE> 1342852 , <NEWLINE> 1373253 , <NEWLINE> 1422195 , <NEWLINE> 1453816 , <NEWLINE> 1502376 , <NEWLINE> 1553361 , <NEWLINE> 1595437 , <NEWLINE> 1629570 , <NEWLINE> 1691292 , <NEWLINE> 1726717 , <NEWLINE> 1782111 , <NEWLINE> 1827492 , <NEWLINE> 1887772 , <NEWLINE> 1925853 , <NEWLINE> 1986837 , <NEWLINE> 2033674 , <NEWLINE> 2089776 , <NEWLINE> 2145333 , <NEWLINE> 2197483 , <NEWLINE> 2246640 , <NEWLINE> 2332104 , <NEWLINE> 2379085 , <NEWLINE> 2434833 , <NEWLINE> 2490534 , <NEWLINE> 2554600 , <NEWLINE> 2609625 , <NEWLINE> 2693919 , <NEWLINE> 2742052 , <NEWLINE> 2813988 , <NEWLINE> 2875245 , <NEWLINE> 2952085 , <NEWLINE> 3003306 , <NEWLINE> 3096024 , <NEWLINE> 3157249 , <NEWLINE> 3224511 , <NEWLINE> 3306240 , <NEWLINE> 3388576 , <NEWLINE> 3444609 , <NEWLINE> 3533637 , <NEWLINE> 3591322 , <NEWLINE> 3693924 , <NEWLINE> 3767085 , <NEWLINE> 3842623 , <NEWLINE> 3912324 , <NEWLINE> 4027884 , <NEWLINE> 4102093 , <NEWLINE> 4181949 , <NEWLINE> 4270422 , <NEWLINE> 4361548 , <NEWLINE> 4427853 , <NEWLINE> 4548003 , <NEWLINE> 4616104 , <NEWLINE> 4718640 , <NEWLINE> 4812789 , <NEWLINE> 4918561 , <NEWLINE> 5003286 , <NEWLINE> 5131848 , <NEWLINE> 5205481 , <NEWLINE> 5299011 , <NEWLINE> 5392008 , <NEWLINE> 5521384 , <NEWLINE> 5610705 , <NEWLINE> 5739009 , <NEWLINE> 5818390 , <NEWLINE> 5930196 , <NEWLINE> 6052893 , <NEWLINE> 6156139 , <NEWLINE> 6239472 , <NEWLINE> 6402720 , <NEWLINE> 6493681 , <NEWLINE> 6623853 , <NEWLINE> 6741078 , <NEWLINE> 6864016 , <NEWLINE> 6953457 , <NEWLINE> 7094451 , <NEWLINE> 7215016 , <NEWLINE> 7359936 , <NEWLINE> 7475145 , <NEWLINE> 7593865 , <NEWLINE> 7689630 , <NEWLINE> 7886244 , <NEWLINE> 7984165 , <NEWLINE> 8130747 , <NEWLINE> 8253888 , <NEWLINE> 8403448 , <NEWLINE> 8523897 , <NEWLINE> 8684853 , <NEWLINE> 8802826 , <NEWLINE> 8949612 , <NEWLINE> 9105537 , <NEWLINE> 9267595 , <NEWLINE> 9376656 , <NEWLINE> 9574704 , <NEWLINE> 9686065 , <NEWLINE> 9827097 , <NEWLINE> 9997134 , <NEWLINE> 10174780 , <NEWLINE> 10290813 , <NEWLINE> 10493367 , <NEWLINE> 10611772 , <NEWLINE> 10813692 <NEWLINE> ] <NEWLINE> <NL> print ( ans [ k - 1 ] ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> d = defaultdict ( list ) <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> d [ s ] . append ( i ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( 1000 ) : <NEWLINE> <INDENT> T = <STRING> % i <NEWLINE> j = - 1 <NEWLINE> for t in T : <NEWLINE> <INDENT> flag = True <NEWLINE> for k in d [ t ] : <NEWLINE> <INDENT> if k > j : <NEWLINE> <INDENT> flag = False <NEWLINE> j = k <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if not ( flag ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x1 , y1 , x2 , y2 = [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print ( ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ** ( 1 / 2 ) ) <NEWLINE> <NL>
from sys import stdin <NEWLINE> import sys <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> import functools <NEWLINE> import itertools <NEWLINE> from collections import deque , Counter <NEWLINE> from operator import mul <NEWLINE> import copy <NEWLINE> <NL> n , k , l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> road = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> rail = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> p , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> road [ p ] . append ( q ) <NEWLINE> road [ q ] . append ( p ) <NEWLINE> <NL> <DEDENT> for i in range ( l ) : <NEWLINE> <INDENT> r , s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> rail [ r ] . append ( s ) <NEWLINE> rail [ s ] . append ( r ) <NEWLINE> <NL> <DEDENT> seen = [ 0 for i in range ( n + 1 ) ] <NEWLINE> <NL> def dfs_stack ( u , al , al_c , d ) : <NEWLINE> <INDENT> stack = deque ( [ u ] ) <NEWLINE> seen [ u ] = 1 <NEWLINE> <NL> while len ( stack ) > 0 : <NEWLINE> <INDENT> v = stack . pop ( ) <NEWLINE> <COMMENT> <NL> al_c [ v ] = d <NEWLINE> <COMMENT> <NL> <NL> for w in al [ v ] : <NEWLINE> <INDENT> if seen [ w ] == 0 : <NEWLINE> <INDENT> stack . append ( w ) <NEWLINE> seen [ w ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if stack == [ ] : break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> road_c = [ - 1 for i in range ( n + 1 ) ] <NEWLINE> rail_c = [ - 1 for i in range ( n + 1 ) ] <NEWLINE> <NL> d = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if seen [ i ] == 0 : <NEWLINE> <INDENT> dfs_stack ( i , road , road_c , d ) <NEWLINE> d += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> seen = [ 0 for i in range ( n + 1 ) ] <NEWLINE> <NL> d = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if seen [ i ] == 0 : <NEWLINE> <INDENT> dfs_stack ( i , rail , rail_c , d ) <NEWLINE> d += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> dict = { } <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ( road_c [ i ] , rail_c [ i ] ) not in dict : <NEWLINE> <INDENT> dict [ ( road_c [ i ] , rail_c [ i ] ) ] = [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict [ ( road_c [ i ] , rail_c [ i ] ) ] . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ 0 for i in range ( n + 1 ) ] <NEWLINE> <NL> for dd in dict . items ( ) : <NEWLINE> <INDENT> for j in dd [ 1 ] : <NEWLINE> <INDENT> ans [ j ] = str ( len ( dd [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( ans [ 1 : ] ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if data [ i ] < data [ k + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> <NL> nums = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> <NL> a = nums [ 0 ] <NEWLINE> b = nums [ 1 ] <NEWLINE> n = nums [ 2 ] <NEWLINE> <NL> max_score = - 1 <NEWLINE> score = - 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if b > n : <NEWLINE> <INDENT> max_score = math . floor ( a * n / b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_score = math . floor ( a * ( b - 1 ) / b ) <NEWLINE> <NL> <DEDENT> print ( max_score ) <NEWLINE>
import sys <NEWLINE> a = list ( sys . stdin . read ( ) . split ( ) ) <NEWLINE> t = list ( zip ( * [ [ int ( n [ : - 1 ] or 0 ) , int ( n [ - 1 ] ) ] for n in a ] ) ) <NEWLINE> print ( ( sum ( t [ 0 ] ) + len ( ( u : = sorted ( filter ( lambda n : n > 0 , t [ 1 ] ) ) ) [ : 0 : - 1 ] ) ) * 10 + ( u and u [ 0 ] or 0 ) ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt_plus = 0 <NEWLINE> cnt_zero = 0 <NEWLINE> cnt_minus = 0 <NEWLINE> arr_plus = [ ] <NEWLINE> arr_minus = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if arr [ i ] > 0 : <NEWLINE> <INDENT> cnt_plus += 1 <NEWLINE> arr_plus . append ( arr [ i ] ) <NEWLINE> <DEDENT> elif arr [ i ] < 0 : <NEWLINE> <INDENT> cnt_minus += 1 <NEWLINE> arr_minus . append ( - arr [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt_zero += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt_plus + cnt_minus < k : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if k == n : <NEWLINE> <INDENT> if cnt_zero != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( cnt_plus ) : <NEWLINE> <INDENT> ans *= arr_plus [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> for i in range ( cnt_minus ) : <NEWLINE> <INDENT> ans *= arr_minus [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> if cnt_minus % 2 == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( - ans ) % mod ) <NEWLINE> <DEDENT> <DEDENT> exit ( ) <NEWLINE> <DEDENT> if cnt_plus == 0 and k % 2 == 1 : <NEWLINE> <INDENT> if cnt_zero != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr_minus = sorted ( arr_minus ) <NEWLINE> tmp = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> tmp *= arr_minus [ i ] <NEWLINE> tmp %= mod <NEWLINE> <DEDENT> print ( ( - tmp ) % mod ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr_plus = sorted ( arr_plus , reverse = True ) <NEWLINE> arr_minus = sorted ( arr_minus , reverse = True ) <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> pos_plus = 0 <NEWLINE> pos_minus = 0 <NEWLINE> cnt = 0 <NEWLINE> while cnt < k : <NEWLINE> <INDENT> cand1 = 0 <NEWLINE> if pos_plus <= cnt_plus - 2 : <NEWLINE> <INDENT> cand1 = arr_plus [ pos_plus ] * arr_plus [ pos_plus + 1 ] <NEWLINE> <DEDENT> cand2 = 0 <NEWLINE> if pos_minus <= cnt_minus - 2 : <NEWLINE> <INDENT> cand2 = arr_minus [ pos_minus ] * arr_minus [ pos_minus + 1 ] <NEWLINE> <DEDENT> if cand1 >= cand2 : <NEWLINE> <INDENT> pos_plus += 2 <NEWLINE> ans *= cand1 <NEWLINE> ans %= mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pos_minus += 2 <NEWLINE> ans *= cand2 <NEWLINE> ans %= mod <NEWLINE> <DEDENT> cnt += 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = arr_plus [ 0 ] <NEWLINE> pos_plus = 1 <NEWLINE> pos_minus = 0 <NEWLINE> cnt = 1 <NEWLINE> while cnt < k : <NEWLINE> <INDENT> cand1 = 0 <NEWLINE> if pos_plus <= cnt_plus - 2 : <NEWLINE> <INDENT> cand1 = arr_plus [ pos_plus ] * arr_plus [ pos_plus + 1 ] <NEWLINE> <DEDENT> cand2 = 0 <NEWLINE> if pos_minus <= cnt_minus - 2 : <NEWLINE> <INDENT> cand2 = arr_minus [ pos_minus ] * arr_minus [ pos_minus + 1 ] <NEWLINE> <DEDENT> if cand1 >= cand2 : <NEWLINE> <INDENT> pos_plus += 2 <NEWLINE> ans *= cand1 <NEWLINE> ans %= mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pos_minus += 2 <NEWLINE> ans *= cand2 <NEWLINE> ans %= mod <NEWLINE> <DEDENT> cnt += 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT>
nk = input ( ) . split ( ) <NEWLINE> index = int ( nk [ 1 ] ) - 1 <NEWLINE> s = input ( ) <NEWLINE> c = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if c == index : print ( i . lower ( ) , end = <STRING> ) <NEWLINE> else : print ( i , end = <STRING> ) <NEWLINE> c += 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> read = sys . stdin . read <NEWLINE> <NL> n , = map ( int , readline ( ) . split ( ) ) <NEWLINE> * a , = map ( int , readline ( ) . split ( ) ) <NEWLINE> * b , = map ( int , readline ( ) . split ( ) ) <NEWLINE> b = b [ : : - 1 ] <NEWLINE> from collections import Counter <NEWLINE> d = Counter ( a + b ) <NEWLINE> if max ( d . values ( ) ) > n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> same = set ( i for i in range ( n ) if a [ i ] == b [ i ] ) <NEWLINE> from random import randrange <NEWLINE> while same : <NEWLINE> <INDENT> i = same . pop ( ) <NEWLINE> while True : <NEWLINE> <INDENT> j = randrange ( 0 , n ) <NEWLINE> if a [ j ] != b [ i ] and a [ i ] != b [ j ] : <NEWLINE> <INDENT> b [ i ] , b [ j ] = b [ j ] , b [ i ] <NEWLINE> same . discard ( j ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * b ) <NEWLINE>
a = reversed ( input ( ) ) <NEWLINE> <COMMENT> <NL> mod_list = [ 1 ] + [ 0 ] * 2019 <NEWLINE> moji_int = 0 <NEWLINE> Sn = 0 <NEWLINE> tens = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> tmp = int ( i ) * ( tens ) <NEWLINE> Sn = ( Sn + tmp ) % 2019 <NEWLINE> mod = Sn <NEWLINE> tens = tens * 10 % 2019 <NEWLINE> mod_list [ mod ] += 1 <NEWLINE> <DEDENT> res = 0 <NEWLINE> for i in mod_list : <NEWLINE> <INDENT> res += int ( i * ( i - 1 ) / 2 ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i + K ] > A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ None ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> road = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> count = 0 <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> road [ a ] . append ( b ) <NEWLINE> road [ b ] . append ( a ) <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> max_hight = 0 <NEWLINE> for j in road [ i ] : <NEWLINE> <INDENT> max_hight = max ( max_hight , h [ j ] ) <NEWLINE> <DEDENT> if h [ i ] > max_hight : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import bisect <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> time = 0 <NEWLINE> cnt = 0 <NEWLINE> C = [ ] <NEWLINE> SA = [ 0 ] <NEWLINE> SB = [ 0 ] <NEWLINE> for a in A : <NEWLINE> <INDENT> SA . append ( SA [ - 1 ] + a ) <NEWLINE> <DEDENT> for b in B : <NEWLINE> <INDENT> SB . append ( SB [ - 1 ] + b ) <NEWLINE> <DEDENT> for x in range ( N + 1 ) : <NEWLINE> <INDENT> L = K - SA [ x ] <NEWLINE> if L < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> y_max = bisect . bisect_right ( SB , L ) - 1 <NEWLINE> <NL> C . append ( y_max + x ) <NEWLINE> <DEDENT> print ( max ( C ) ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> d = dict ( ) <NEWLINE> count = 0 <NEWLINE> ar = [ ( a [ i ] + i + 1 ) for i in range ( n ) ] <NEWLINE> br = [ ( i + 1 - a [ i ] ) for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if d . get ( ar [ i ] ) is not None : <NEWLINE> <INDENT> d [ ar [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ ar [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> c = dict ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if c . get ( br [ i ] ) is not None : <NEWLINE> <INDENT> c [ br [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ br [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> for no in c . keys ( ) : <NEWLINE> <INDENT> if d . get ( no ) is not None : <NEWLINE> <INDENT> count += ( c [ no ] * d [ no ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
import bisect <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Asums = [ 0 ] * ( N + 1 ) <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> Asums [ i + 1 ] = Asums [ i ] + a <NEWLINE> <NL> <DEDENT> Bsums = [ 0 ] * ( M + 1 ) <NEWLINE> for i , b in enumerate ( B ) : <NEWLINE> <INDENT> Bsums [ i + 1 ] = Bsums [ i ] + b <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for anum in range ( N + 1 ) : <NEWLINE> <INDENT> t = Asums [ anum ] <NEWLINE> if K < t : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> bnum = bisect . bisect_right ( Bsums , K - t ) - 1 <NEWLINE> ans = max ( ans , anum + bnum ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
debug = False <NEWLINE> <NL> if debug : import time <NEWLINE> if debug : start = time . time ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> R = [ 0 ] * n <NEWLINE> R_min = 10 ** 9 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> R [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> maximum_profit = - 10 ** 9 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> R_min = R [ i - 1 ] if R [ i - 1 ] < R_min else R_min <NEWLINE> profit = R [ i ] - R_min <NEWLINE> maximum_profit = profit if profit > maximum_profit else maximum_profit <NEWLINE> <DEDENT> print ( maximum_profit ) <NEWLINE> <NL> if debug : print ( time . time ( ) - start ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for a in range ( 0 , 1000 ) : <NEWLINE> <INDENT> for b in range ( 0 , 1000 ) : <NEWLINE> <INDENT> if pow ( a , 5 ) - pow ( b , 5 ) == x : <NEWLINE> <INDENT> print ( a , end = <STRING> ) <NEWLINE> print ( b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif pow ( a , 5 ) - pow ( b * - 1 , 5 ) == x : <NEWLINE> <INDENT> print ( a , end = <STRING> ) <NEWLINE> print ( b * - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif pow ( - 1 * a , 5 ) - pow ( b , 5 ) == x : <NEWLINE> <INDENT> print ( - 1 * a , end = <STRING> ) <NEWLINE> print ( b * - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif pow ( - 1 * a , 5 ) - pow ( b * - 1 , 5 ) == x : <NEWLINE> <INDENT> print ( - 1 * a , end = <STRING> ) <NEWLINE> print ( b * - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = A [ 0 ] <NEWLINE> if A . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> d = collections . Counter ( a ) <NEWLINE> ans = sum ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += d [ b ] * ( c - b ) <NEWLINE> d [ c ] += d [ b ] <NEWLINE> d [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H = [ h ] <NEWLINE> ans = 0 <NEWLINE> while len ( H ) > 0 : <NEWLINE> <INDENT> for e in H : <NEWLINE> <INDENT> if len ( e ) == 0 : <NEWLINE> <INDENT> H . remove ( e ) <NEWLINE> <DEDENT> elif 0 in e : <NEWLINE> <INDENT> a = e [ : e . index ( 0 ) ] <NEWLINE> b = e [ e . index ( 0 ) + 1 : ] <NEWLINE> H . append ( a ) <NEWLINE> H . append ( b ) <NEWLINE> H . remove ( e ) <NEWLINE> if [ ] in H : <NEWLINE> <INDENT> H . remove ( [ ] ) <NEWLINE> if len ( H ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += min ( e ) <NEWLINE> c = [ e [ j ] - min ( e ) for j in range ( len ( e ) ) ] <NEWLINE> a = c [ : c . index ( 0 ) ] <NEWLINE> b = c [ c . index ( 0 ) + 1 : ] <NEWLINE> H . append ( a ) <NEWLINE> H . append ( b ) <NEWLINE> H . remove ( e ) <NEWLINE> if [ ] in H : <NEWLINE> <INDENT> H . remove ( [ ] ) <NEWLINE> if len ( H ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if [ ] in H : <NEWLINE> <INDENT> H . remove ( [ ] ) <NEWLINE> if len ( H ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> <NL> sum_of_digits = 0 <NEWLINE> <NL> cnts = [ 0 ] * 2019 <NEWLINE> cnts [ 0 ] = 1 <NEWLINE> <NL> d = 1 <NEWLINE> <NL> for c in s : <NEWLINE> <INDENT> sum_of_digits += int ( c ) * d <NEWLINE> sum_of_digits %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> cnts [ sum_of_digits ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for cnt in cnts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> g = 998244353 <NEWLINE> r = 1 <NEWLINE> p = pow ( m - 1 , n - 1 , g ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> r = ( r * ( n - i ) * pow ( i , g - 2 , g ) ) % g <NEWLINE> p = ( p + r * pow ( m - 1 , n - 1 - i , g ) ) % g <NEWLINE> <DEDENT> print ( ( m * p ) % g ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> M = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> s = [ ] <NEWLINE> l = [ ] <NEWLINE> top = 2 * ( 10 ** 9 ) + 1 <NEWLINE> low = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> t = sum ( M [ j ] ) <NEWLINE> if low == t : <NEWLINE> <INDENT> s . append ( M [ j ] ) <NEWLINE> <DEDENT> elif low < t : <NEWLINE> <INDENT> low = t <NEWLINE> s = [ ] <NEWLINE> s . append ( M [ j ] ) <NEWLINE> <NL> <DEDENT> if top == t : <NEWLINE> <INDENT> l . append ( M [ j ] ) <NEWLINE> <DEDENT> elif top > t : <NEWLINE> <INDENT> top = t <NEWLINE> l = [ ] <NEWLINE> l . append ( M [ j ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def cal_man ( a , b ) : <NEWLINE> <INDENT> return abs ( a [ 0 ] - b [ 0 ] ) + abs ( a [ 1 ] - b [ 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> s . sort ( ) <NEWLINE> l . sort ( ) <NEWLINE> <NL> <NL> high = [ ] <NEWLINE> small = [ ] <NEWLINE> lowest = 2 * ( 10 ** 9 ) + 1 <NEWLINE> topest = - 2 * ( 10 ** 9 ) + 1 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> t = M [ j ] [ 1 ] - M [ j ] [ 0 ] <NEWLINE> if lowest > t : <NEWLINE> <INDENT> lowest = t <NEWLINE> small = [ ] <NEWLINE> small . append ( M [ j ] ) <NEWLINE> <DEDENT> elif lowest == t : <NEWLINE> <INDENT> small . append ( M [ j ] ) <NEWLINE> <NL> <DEDENT> if topest < t : <NEWLINE> <INDENT> topest = t <NEWLINE> high = [ ] <NEWLINE> high . append ( M [ j ] ) <NEWLINE> <DEDENT> elif topest == t : <NEWLINE> <INDENT> high . append ( M [ j ] ) <NEWLINE> <DEDENT> <DEDENT> high . sort ( ) <NEWLINE> small . sort ( ) <NEWLINE> <NL> <NL> print ( max ( [ cal_man ( s [ 0 ] , l [ - 1 ] ) , cal_man ( s [ - 1 ] , l [ 0 ] ) , <NEWLINE> <INDENT> cal_man ( high [ 0 ] , small [ - 1 ] ) , cal_man ( high [ - 1 ] , small [ 0 ] ) ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n , k = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> w = [ 0 for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> w [ i ] = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> count = 0 <NEWLINE> <NL> def check ( P ) : <NEWLINE> <INDENT> m = 0 <NEWLINE> ik = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> global count <NEWLINE> count += 1 <NEWLINE> new = m + w [ i ] <NEWLINE> if new > P : <NEWLINE> <INDENT> m = w [ i ] <NEWLINE> ik += 1 <NEWLINE> if ik > k : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> m = new <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> s = max ( sum ( w ) // k , max ( w ) ) <NEWLINE> e = sum ( w ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> P = ( s + e ) // 2 <NEWLINE> <COMMENT> <NL> if s == e : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if check ( P ) : <NEWLINE> <INDENT> e = P <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = P + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( P ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = { } <NEWLINE> c = 0 <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if i + a not in d : <NEWLINE> <INDENT> d [ i + a ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i + a ] += 1 <NEWLINE> <DEDENT> if i - a in d : <NEWLINE> <INDENT> c += d [ i - a ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( math . pi * ( r ** 2 ) , 2 * math . pi * r ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> if N > 3 : <NEWLINE> <INDENT> n = int ( ( N - 3 ) ** ( 0.5 ) ) + 1 <NEWLINE> nums = [ i for i in range ( 1 , n ) ] <NEWLINE> for x in range ( 1 , n ) : <NEWLINE> <INDENT> for y in range ( 1 , n ) : <NEWLINE> <INDENT> for z in range ( 1 , n ) : <NEWLINE> <INDENT> i = x ** 2 + y ** 2 + z ** 2 + x * y + x * z + y * z <NEWLINE> if i > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> card_deck = { <STRING> : [ ] , <STRING> : [ ] , <STRING> : [ ] , <STRING> : [ ] } <NEWLINE> card_symbols = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lst = [ card for card in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> card_deck [ lst [ 0 ] ] . append ( lst [ 1 ] ) <NEWLINE> <NL> <DEDENT> for key , value in card_deck . items ( ) : <NEWLINE> <INDENT> card_deck [ key ] . sort ( ) <NEWLINE> <NL> <DEDENT> for i in card_symbols : <NEWLINE> <INDENT> for card in range ( 1 , 14 ) : <NEWLINE> <INDENT> if not str ( card ) in card_deck [ i ] : <NEWLINE> <INDENT> print ( i , card ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> from functools import reduce <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MAP1 ( ) : return map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> def LIST1 ( ) : return list ( MAP1 ( ) ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> h , w , m = MAP ( ) <NEWLINE> s = [ LIST1 ( ) for i in range ( m ) ] <NEWLINE> ay = [ 0 ] * h <NEWLINE> ax = [ 0 ] * w <NEWLINE> for x in s : <NEWLINE> <INDENT> ay [ x [ 0 ] ] += 1 <NEWLINE> ax [ x [ 1 ] ] += 1 <NEWLINE> <NL> <DEDENT> my = max ( ay ) <NEWLINE> mx = max ( ax ) <NEWLINE> <NL> by = bx = 0 <NEWLINE> for y in ay : <NEWLINE> <INDENT> if y == my : <NEWLINE> <INDENT> by += 1 <NEWLINE> <DEDENT> <DEDENT> for x in ax : <NEWLINE> <INDENT> if x == mx : <NEWLINE> <INDENT> bx += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = my + mx <NEWLINE> tmp = 0 <NEWLINE> for x in s : <NEWLINE> <INDENT> if ay [ x [ 0 ] ] + ax [ x [ 1 ] ] == ans : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> <DEDENT> if tmp == by * bx : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import bisect <NEWLINE> a . sort ( ) <NEWLINE> <NL> idx = bisect . bisect_left ( a , 0 ) <NEWLINE> sm = [ abs ( x ) for x in a ] <NEWLINE> if idx % 2 == 0 : <NEWLINE> <INDENT> print ( sum ( sm ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( sm ) - 2 * min ( sm ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> B = int ( 1 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> B *= i <NEWLINE> if ( B > 10 ** 18 ) : <NEWLINE> <INDENT> B = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( B ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> from sys import stdin <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> <COMMENT> <NL> input = stdin . readline <NEWLINE> <NL> p = 998244353 <NEWLINE> <NL> def cmb ( n , r , p ) : <NEWLINE> <INDENT> if ( r < 0 ) or ( n < r ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return fact [ n ] * factinv [ r ] * factinv [ n - r ] % p <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> N = 10 ** 6 <COMMENT> <NEWLINE> fact = [ 1 , 1 ] <COMMENT> <NEWLINE> factinv = [ 1 , 1 ] <COMMENT> <NEWLINE> inv = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % p ) <NEWLINE> inv . append ( ( - inv [ p % i ] * ( p // i ) ) % p ) <NEWLINE> factinv . append ( ( factinv [ - 1 ] * inv [ - 1 ] ) % p ) <NEWLINE> <NL> <DEDENT> def pow_k ( x , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> K = 1 <NEWLINE> while n > 1 : <NEWLINE> <INDENT> if n % 2 != 0 : <NEWLINE> <INDENT> K *= x <NEWLINE> K = K % p <NEWLINE> <DEDENT> x *= x <NEWLINE> n //= 2 <NEWLINE> <NL> <DEDENT> return ( K * x ) % p <NEWLINE> <NL> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == 1 : <NEWLINE> <INDENT> if k < n - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> first = pow_k ( m - 1 , n - k - 1 ) <NEWLINE> for i in range ( k , - 1 , - 1 ) : <NEWLINE> <INDENT> first_cmb = cmb ( n - 1 , i , p ) <NEWLINE> ans += ( first_cmb * first ) % p <NEWLINE> first = ( first * ( m - 1 ) ) % p <NEWLINE> <COMMENT> <NL> <NL> <NL> <NL> <DEDENT> ans = ans * m <NEWLINE> print ( ans % p ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , T , * AB = map ( int , read ( ) . split ( ) ) <NEWLINE> D = [ ( a , b ) for a , b in zip ( * [ iter ( AB ) ] * 2 ) ] <NEWLINE> <NL> D . sort ( ) <NEWLINE> <NL> dp = [ 0 ] * T <NEWLINE> ans = 0 <NEWLINE> <NL> for i , ( a , b ) in enumerate ( D [ : - 1 ] ) : <NEWLINE> <INDENT> for t in range ( T - 1 , a - 1 , - 1 ) : <NEWLINE> <INDENT> if dp [ t ] < dp [ t - a ] + b : <NEWLINE> <INDENT> dp [ t ] = dp [ t - a ] + b <NEWLINE> <DEDENT> <DEDENT> if ans < dp [ T - 1 ] + D [ i + 1 ] [ 1 ] : <NEWLINE> <INDENT> ans = dp [ T - 1 ] + D [ i + 1 ] [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import string <NEWLINE> <NL> s = list ( input ( ) ) <NEWLINE> flag = True <NEWLINE> if s [ 0 ] != <STRING> : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] in string . ascii_uppercase : <NEWLINE> <INDENT> if i == 1 or i == len ( s ) - 1 or s [ i ] != <STRING> : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag and count == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from bisect import bisect_left , bisect_right <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> n , * s = map ( int , input ( ) . split ( ) ) <NEWLINE> toidx = { <STRING> : ( 0 , 1 ) , <STRING> : ( 1 , 2 ) , <STRING> : ( 0 , 2 ) } <NEWLINE> toalp = lambda x : chr ( ord ( <STRING> ) + x ) <NEWLINE> m = sum ( s ) <NEWLINE> q = [ toidx [ input ( ) ] for _ in range ( n ) ] <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> if m == 0 or ( not s [ q [ 0 ] [ 0 ] ] and not s [ q [ 0 ] [ 1 ] ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> elif m == 1 : <NEWLINE> <INDENT> for i , j in q : <NEWLINE> <INDENT> if not s [ i ] and not s [ j ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> elif s [ i ] : <NEWLINE> <INDENT> s [ j ] += 1 ; s [ i ] -= 1 <NEWLINE> res . append ( toalp ( j ) ) <NEWLINE> <DEDENT> elif s [ j ] : <NEWLINE> <INDENT> s [ i ] += 1 ; s [ j ] -= 1 <NEWLINE> res . append ( toalp ( i ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif m == 2 : <NEWLINE> <INDENT> d = { ( 0 , 1 ) : [ ] , ( 0 , 2 ) : [ ] , ( 1 , 2 ) : [ ] } <NEWLINE> for i in range ( n ) : d [ q [ i ] ] . append ( i ) <NEWLINE> for key in d . keys ( ) : d [ key ] . append ( INF ) <NEWLINE> for idx , ( i , j ) in enumerate ( q ) : <NEWLINE> <INDENT> if s [ i ] and s [ j ] : <NEWLINE> <INDENT> k = [ x for x in range ( 3 ) if i != x and j != x ] [ 0 ] <NEWLINE> key1 = tuple ( sorted ( [ i , k ] ) ) <NEWLINE> key2 = tuple ( sorted ( [ j , k ] ) ) <NEWLINE> nik = d [ key1 ] [ bisect_left ( d [ key1 ] , idx ) ] <NEWLINE> njk = d [ key2 ] [ bisect_left ( d [ key2 ] , idx ) ] <NEWLINE> if nik <= njk : <NEWLINE> <INDENT> s [ i ] += 1 ; s [ j ] -= 1 <NEWLINE> res . append ( toalp ( i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ j ] += 1 ; s [ i ] -= 1 <NEWLINE> res . append ( toalp ( j ) ) <NEWLINE> <DEDENT> <DEDENT> elif s [ i ] : <NEWLINE> <INDENT> s [ j ] += 1 ; s [ i ] -= 1 <NEWLINE> res . append ( toalp ( j ) ) <NEWLINE> <DEDENT> elif s [ j ] : <NEWLINE> <INDENT> s [ i ] += 1 ; s [ j ] -= 1 <NEWLINE> res . append ( toalp ( i ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i , j in q : <NEWLINE> <INDENT> if s [ i ] >= s [ j ] : <NEWLINE> <INDENT> s [ j ] += 1 ; s [ i ] -= 1 <NEWLINE> res . append ( toalp ( j ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ i ] += 1 ; s [ j ] -= 1 <NEWLINE> res . append ( toalp ( i ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * res , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> for a in range ( - 119 , 119 ) : <NEWLINE> <INDENT> for b in range ( - 119 , 119 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT>
import queue <NEWLINE> <NL> q = queue . Queue ( ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = [ - 1 for i in range ( N + 1 ) ] <NEWLINE> path = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> path [ A ] . append ( B ) <NEWLINE> path [ B ] . append ( A ) <NEWLINE> <DEDENT> q . put ( 1 ) <NEWLINE> COUNTER = 0 <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> now = q . get ( ) <NEWLINE> for p in path [ now ] : <NEWLINE> <INDENT> if ans [ p ] == - 1 : <NEWLINE> <INDENT> ans [ p ] = now <NEWLINE> q . put ( p ) <NEWLINE> <COMMENT> <NL> COUNTER += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in ans [ 2 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
arr = input ( ) . split ( ) <NEWLINE> a = int ( arr [ 0 ] ) <NEWLINE> b = int ( arr [ 1 ] ) <NEWLINE> c = int ( arr [ 2 ] ) <NEWLINE> k = int ( arr [ 3 ] ) <NEWLINE> <NL> if k <= a : print ( k ) <NEWLINE> <NL> elif k <= ( a + b ) : print ( a ) <NEWLINE> <NL> else : print ( a - ( k - a - b ) ) <NEWLINE>
a , b , c = map ( int , ( input ( ) . split ( ) ) ) <NEWLINE> d = ( a // ( b + c ) ) * b + min ( ( a % ( b + c ) ) , b ) <NEWLINE> print ( d ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = n <NEWLINE> s = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . add ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( s ) ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> if ( 0 in a ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = n % k <NEWLINE> s2 = k - s <NEWLINE> print ( min ( s , s2 ) ) <NEWLINE>
import numpy as np <NEWLINE> import math <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> aaa = np . array ( list ( map ( float , input ( ) . split ( ) ) ) , dtype = <STRING> ) <NEWLINE> l = 0 <NEWLINE> r = 10 ** 9 <NEWLINE> while r != l : <NEWLINE> <INDENT> mid = ( r + l ) // 2 <NEWLINE> bbb = aaa / mid <NEWLINE> bbb -= 1 <NEWLINE> bbb = np . ceil ( bbb ) <NEWLINE> if bbb . sum ( ) <= K : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid + 1 <NEWLINE> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> root = [ ] <COMMENT> <NEWLINE> already = [ - 1 ] * ( n + 1 ) <COMMENT> <NEWLINE> <NL> c = 1 <COMMENT> <NEWLINE> l = 0 <COMMENT> <NEWLINE> <NL> v = 1 <COMMENT> <NEWLINE> while ( already [ v ] == - 1 ) : <COMMENT> <NEWLINE> <INDENT> already [ v ] = len ( root ) <COMMENT> <NEWLINE> root . append ( v ) <NEWLINE> v = a [ v - 1 ] <NEWLINE> <NL> <DEDENT> c = len ( root ) - already [ v ] <NEWLINE> l = already [ v ] <NEWLINE> <NL> if k < l : <COMMENT> <NEWLINE> <INDENT> ans = root [ k ] <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> k -= l <NEWLINE> ans = root [ k % c + l ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> A = n [ 0 ] <NEWLINE> V = n [ 1 ] <NEWLINE> <NL> B = r [ 0 ] <NEWLINE> W = r [ 1 ] <NEWLINE> <NL> T = t <NEWLINE> <NL> after_a = A + V * T <NEWLINE> after_b = B + W * T <NEWLINE> <NL> after_a_min = A - V * T <NEWLINE> after_b_min = B - W * T <NEWLINE> <NL> if ( after_a == after_b ) or ( after_a_min == after_b_min ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if A < B and after_a > after_b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if A < B and after_a < after_b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> if A > B and after_a_min < after_b_min : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if A > B and after_a_min > after_b_min : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> l = [ ] <NEWLINE> for i in sys . stdin : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <NL> <DEDENT> for i in range ( 0 , len ( l ) ) : <NEWLINE> <INDENT> l [ i ] = l [ i ] . split ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 0 , len ( l ) - 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , int ( l [ i ] [ 0 ] ) ) : <NEWLINE> <INDENT> print ( <STRING> * int ( l [ i ] [ 1 ] ) ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> flg = False <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <NL> <INDENT> count += int ( N / i ) <NEWLINE> if N % i == 0 : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys , bisect , math , itertools , string , queue , copy <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> from collections import Counter , defaultdict , deque <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def inp ( ) : return int ( input ( ) ) <NEWLINE> def inpm ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def inpls ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def inplm ( n ) : return list ( int ( input ( ) ) for _ in range ( n ) ) <NEWLINE> def inplL ( n ) : return [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inplT ( n ) : return [ tuple ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inpll ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> def inplls ( n ) : return sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ) <NEWLINE> <NL> s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> ql = [ input ( ) . split ( ) for i in range ( q ) ] <NEWLINE> <NL> ans = deque ( s ) <NEWLINE> isrev = False <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if ql [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> isrev = not isrev <NEWLINE> continue <NEWLINE> <DEDENT> if ( ql [ i ] [ 1 ] == <STRING> ) == isrev : <NEWLINE> <INDENT> ans . appendleft ( ql [ i ] [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( ql [ i ] [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if isrev : <NEWLINE> <INDENT> ans . reverse ( ) <NEWLINE> <NL> <DEDENT> s = <STRING> . join ( ans ) <NEWLINE> <NL> print ( s ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = [ 0 for i in range ( N ) ] <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in List : <NEWLINE> <INDENT> ans [ j - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> <NL> for i in ans : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( str ( input ( ) ) ) <NEWLINE> R = 0 <NEWLINE> G = 0 <NEWLINE> B = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> G += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += 1 <NEWLINE> <DEDENT> <DEDENT> ans = G * B * R <NEWLINE> for a in range ( N - 1 ) : <NEWLINE> <INDENT> for d in range ( 1 , ( N - a - 1 ) // 2 + 1 ) : <NEWLINE> <INDENT> if S [ a ] != S [ a + d ] and S [ a + d ] != S [ a + d * 2 ] and S [ a ] != S [ a + d * 2 ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import sys <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> <NL> def make_grid ( h , w , num ) : return [ [ int ( num ) ] * w for _ in range ( h ) ] <NEWLINE> <NL> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . par = [ - 1 for i in range ( n ) ] <NEWLINE> self . n = n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> if self . par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def is_same ( self , x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : return <NEWLINE> <NL> <COMMENT> <NL> if self . par [ x ] > self . par [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . par [ x ] += self . par [ y ] <NEWLINE> self . par [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . par [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . par ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def make_adjlist_nond ( n , edges ) : <NEWLINE> <INDENT> res = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for edge in edges : <NEWLINE> <INDENT> res [ edge [ 0 ] ] . append ( edge [ 1 ] ) <NEWLINE> res [ edge [ 1 ] ] . append ( edge [ 0 ] ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = NMI ( ) <NEWLINE> edges = [ NLI ( ) for _ in range ( M ) ] <NEWLINE> <NL> uf = UnionFind ( N ) <NEWLINE> ans = [ 0 ] * ( M + 1 ) <NEWLINE> for i in range ( M , 0 , - 1 ) : <NEWLINE> <INDENT> if i == M : <NEWLINE> <INDENT> ans [ i ] = N * ( N - 1 ) // 2 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> x , y = edges [ i ] [ 0 ] - 1 , edges [ i ] [ 1 ] - 1 <NEWLINE> if uf . is_same ( x , y ) : <NEWLINE> <INDENT> ans [ i ] = ans [ i + 1 ] <NEWLINE> continue <NEWLINE> <DEDENT> num = uf . size ( x ) * uf . size ( y ) <NEWLINE> uf . unite ( x , y ) <NEWLINE> ans [ i ] = ans [ i + 1 ] - num <NEWLINE> <NL> <DEDENT> for a in ans [ 1 : ] : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( b ) <NEWLINE> n , m = zip ( * c . most_common ( ) ) <NEWLINE> n , m = list ( n ) , list ( m ) <NEWLINE> o = c . most_common ( ) <NEWLINE> <NL> result = [ 0 ] * a <NEWLINE> for i in range ( len ( o ) ) : <NEWLINE> <INDENT> result [ o [ i ] [ 0 ] - 1 ] = o [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> for i in result : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
( n , m , k ) , * A , = [ list ( map ( int , i . split ( ) ) ) for i in open ( 0 ) ] <NEWLINE> a = A [ 0 ] <NEWLINE> b = A [ 1 ] <NEWLINE> <NL> aa = [ 0 ] <NEWLINE> bb = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> aa . append ( aa [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> bb . append ( bb [ i ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if aa [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while bb [ m ] > k - aa [ i ] : <NEWLINE> <INDENT> m -= 1 <NEWLINE> <DEDENT> ans = max ( ans , m + i ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> mod = 1000000007 <NEWLINE> s = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s [ i + 1 ] = s [ i ] + a [ i ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans += a [ i ] * ( s [ n ] - s [ i + 1 ] ) <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
import sys <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> line = line . strip ( ) <NEWLINE> print ( line [ : : - 1 ] ) <NEWLINE> <DEDENT>
S = input ( ) . strip ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for c in S : <NEWLINE> <INDENT> cnt += int ( c ) <NEWLINE> <NL> <DEDENT> if ( cnt % 9 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b = { i : 0 for i in range ( 1 , n + 1 ) } <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> b [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in b . values ( ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if ( N % 9 ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> ans = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> l = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( k , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from numba import njit <NEWLINE> from sys import maxsize <NEWLINE> <NL> <NL> @ njit <NEWLINE> def solve ( n , k , p , c ) : <NEWLINE> <INDENT> used = [ 0 ] * n <NEWLINE> ss = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if used [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> now = i <NEWLINE> s = [ ] <NEWLINE> while not used [ now ] : <NEWLINE> <INDENT> used [ now ] = 1 <NEWLINE> s . append ( c [ now ] ) <NEWLINE> now = p [ now ] <NEWLINE> <DEDENT> ss . append ( s ) <NEWLINE> <NL> <DEDENT> res = - maxsize <NEWLINE> for s in ss : <NEWLINE> <INDENT> s_len = len ( s ) <NEWLINE> cumsum = [ 0 ] <NEWLINE> <COMMENT> <NL> for i in range ( 2 * s_len ) : <NEWLINE> <INDENT> cumsum . append ( cumsum [ - 1 ] + s [ i % s_len ] ) <NEWLINE> <NL> <DEDENT> max_sum = [ - maxsize ] * s_len <NEWLINE> for i in range ( s_len ) : <NEWLINE> <INDENT> for j in range ( s_len ) : <NEWLINE> <INDENT> max_sum [ j ] = max ( max_sum [ j ] , cumsum [ i + j ] - cumsum [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( s_len ) : <NEWLINE> <INDENT> if i > k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v = ( k - i ) // s_len <NEWLINE> if i == 0 and v == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if cumsum [ s_len ] > 0 : <NEWLINE> <INDENT> res = max ( res , max_sum [ i ] + cumsum [ s_len ] * v ) <NEWLINE> <DEDENT> elif i > 0 : <NEWLINE> <INDENT> res = max ( res , max_sum [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> solve ( n , k , p , c ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = { int ( input ( ) ) for _ in range ( m ) } <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x = dp [ i - 1 ] <NEWLINE> if i > 1 : <NEWLINE> <INDENT> x += dp [ i - 2 ] <NEWLINE> <DEDENT> dp [ i ] = x % mod <NEWLINE> <DEDENT> ans = dp [ n ] <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += ( i + N // i * i ) * ( N // i ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> mod = 1000000007 <NEWLINE> zeroes = 0 <NEWLINE> counter1 = defaultdict ( int ) <NEWLINE> counter2 = defaultdict ( int ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , y = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if x == y == 0 : <NEWLINE> <INDENT> zeroes += 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> denominator = math . gcd ( x , y ) <NEWLINE> x , y = x // denominator , y // denominator <NEWLINE> <NL> if y < 0 : <NEWLINE> <COMMENT> <NL> <INDENT> x , y = - x , - y <NEWLINE> <NL> <DEDENT> if x <= 0 : <NEWLINE> <COMMENT> <NL> <INDENT> x , y = y , - x <NEWLINE> counter2 [ ( x , y ) ] += 1 <NEWLINE> counter1 [ ( x , y ) ] += 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counter1 [ ( x , y ) ] += 1 <NEWLINE> counter2 [ ( x , y ) ] += 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for k , v in counter1 . items ( ) : <NEWLINE> <INDENT> now = 1 <NEWLINE> now += pow ( 2 , v , mod ) - 1 <NEWLINE> now += pow ( 2 , counter2 [ k ] , mod ) - 1 <NEWLINE> ans = ans * now % mod <NEWLINE> <DEDENT> ans += zeroes <NEWLINE> ans -= 1 <COMMENT> <NEWLINE> return ans % mod <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> V , E = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> A = [ [ ] for i in range ( V ) ] <NEWLINE> for i in range ( E ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ s ] . append ( t ) <NEWLINE> A [ t ] . append ( s ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> prenum = [ None for i in range ( V ) ] <NEWLINE> <COMMENT> <NL> parent = [ None for i in range ( V ) ] <NEWLINE> <COMMENT> <NL> lowest = [ None for i in range ( V ) ] <NEWLINE> <COMMENT> <NL> visited = [ False for i in range ( V ) ] <NEWLINE> <NL> def DFS ( u = 0 , prev = - 1 , timer = 0 ) : <NEWLINE> <INDENT> prenum [ u ] = timer <NEWLINE> lowest [ u ] = timer <NEWLINE> timer += 1 <NEWLINE> visited [ u ] = True <NEWLINE> <NL> for v in A [ u ] : <NEWLINE> <INDENT> if not visited [ v ] : <NEWLINE> <INDENT> parent [ v ] = u <NEWLINE> DFS ( v , u , timer ) <NEWLINE> lowest [ u ] = min ( lowest [ u ] , lowest [ v ] ) <NEWLINE> <DEDENT> elif v != prev : <NEWLINE> <INDENT> lowest [ u ] = min ( lowest [ u ] , prenum [ v ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> DFS ( ) <NEWLINE> <NL> ans = set ( ) <NEWLINE> <NL> for u in range ( 1 , V ) : <NEWLINE> <INDENT> p = parent [ u ] <NEWLINE> if prenum [ p ] <= lowest [ u ] : <NEWLINE> <INDENT> ans . add ( p ) <NEWLINE> <NL> <DEDENT> <DEDENT> if parent . count ( 0 ) >= 2 : <NEWLINE> <INDENT> ans . add ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . discard ( 0 ) <NEWLINE> <NL> <DEDENT> ans = list ( ans ) <NEWLINE> ans . sort ( ) <NEWLINE> <NL> if ans : <NEWLINE> <INDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> def calcSum ( n , A ) : <NEWLINE> <INDENT> return n <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K + 1 , N + 1 ) : <COMMENT> <NEWLINE> <INDENT> if ( A [ i - K - 1 ] < A [ i - 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> max_a = max ( a ) <NEWLINE> flag = [ True for i in range ( max_a + 1 ) ] <NEWLINE> <NL> dup = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] in dup : <NEWLINE> <INDENT> flag [ a [ i ] ] = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dup . add ( a [ i ] ) <NEWLINE> <DEDENT> for j in range ( 2 * a [ i ] , max_a + 1 , a [ i ] ) : <NEWLINE> <INDENT> flag [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans += flag [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> num = abs ( X ) // D <NEWLINE> if num >= K : <NEWLINE> <INDENT> X = abs ( X ) - K * D <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if num % 2 == K % 2 : <NEWLINE> <INDENT> X = abs ( X ) - D * num <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X = abs ( X ) - D * ( num + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( abs ( X ) ) <NEWLINE>
<COMMENT> <NL> q = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> q = sorted ( q ) <NEWLINE> for i in range ( len ( q ) ) : <NEWLINE> <INDENT> print ( q [ i ] , end = <STRING> ) <NEWLINE> if ( i != ( len ( q ) ) - 1 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> class SegmentTree ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . height = math . ceil ( math . log2 ( n ) ) <NEWLINE> self . nodes = [ 0 for i in range ( pow ( 2 , self . height + 1 ) - 1 ) ] <NEWLINE> self . leaf_start = pow ( 2 , self . height ) - 1 <NEWLINE> <NL> <DEDENT> def update ( self , i , x ) : <NEWLINE> <INDENT> pntr = self . leaf_start + i <NEWLINE> self . nodes [ pntr ] += x <NEWLINE> while True : <NEWLINE> <INDENT> pntr = ( pntr - 1 ) // 2 <NEWLINE> if pntr == - 1 : break <NEWLINE> self . nodes [ pntr ] += x <NEWLINE> <NL> <DEDENT> <DEDENT> def __query ( self , s , t , k , l , r ) : <NEWLINE> <INDENT> if t - s <= 0 : return 0 <NEWLINE> if r <= s or t <= l : return 0 <NEWLINE> if l == s and t == r : return self . nodes [ k ] <NEWLINE> else : <NEWLINE> <INDENT> m = ( l + r ) // 2 <NEWLINE> if t <= m : <NEWLINE> <INDENT> return self . __query ( s , t , k * 2 + 1 , l , m ) <NEWLINE> <DEDENT> elif m <= s : <NEWLINE> <INDENT> return self . __query ( s , t , k * 2 + 2 , m , r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> vl = self . __query ( s , m , k * 2 + 1 , l , m ) <NEWLINE> vr = self . __query ( m , t , k * 2 + 2 , m , r ) <NEWLINE> return vl + vr <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def find ( self , s , t ) : <NEWLINE> <INDENT> return self . __query ( s , t + 1 , 0 , 0 , pow ( 2 , self . height ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> st = SegmentTree ( n ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> com , x , y = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if com == 0 : <NEWLINE> <INDENT> st . update ( x - 1 , y ) <NEWLINE> <DEDENT> elif com == 1 : <NEWLINE> <INDENT> print ( st . find ( x - 1 , y - 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + k - 1 >= b - k + 1 : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , a + k ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
import sys <NEWLINE> import copy <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import numpy as np <NEWLINE> S = input ( ) <NEWLINE> N = len ( S ) + 1 <NEWLINE> a = [ 0 ] * N <NEWLINE> b = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in reversed ( range ( N - 1 ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> b [ i ] = b [ i + 1 ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] < b [ i ] : <NEWLINE> <INDENT> a [ i ] = b [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> import math <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> miti = [ [ ] for _ in range ( N ) ] <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b - 1 != 0 : <NEWLINE> <INDENT> miti [ a - 1 ] . append ( b - 1 ) <NEWLINE> <DEDENT> if a - 1 != 0 : <NEWLINE> <INDENT> miti [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> <DEDENT> visit = [ 0 ] * N <NEWLINE> point = [ - 1 for _ in range ( N ) ] <NEWLINE> <NL> def bfs ( ) : <NEWLINE> <INDENT> nextV = [ 0 ] <NEWLINE> visit [ 0 ] = 1 <NEWLINE> total = 1 <NEWLINE> while True : <NEWLINE> <INDENT> G = nextV <NEWLINE> <COMMENT> <NL> nextV = [ ] <NEWLINE> for m in G : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <INDENT> for n in miti [ m ] : <NEWLINE> <INDENT> if visit [ n ] == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> visit [ n ] = 1 <NEWLINE> point [ n ] = m <NEWLINE> <COMMENT> <NL> nextV . append ( n ) <NEWLINE> total += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if total == N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> bfs ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> for a in point [ 1 : : ] : <NEWLINE> <INDENT> print ( a + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <NL> <DEDENT>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if S [ i ] != <STRING> : <NEWLINE> <INDENT> print ( S [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> if i == K - 1 : <NEWLINE> <INDENT> print ( S [ K - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
import sys ; <NEWLINE> import heapq <NEWLINE> <NL> def iterative ( i , j ) : <NEWLINE> <INDENT> q = [ ] <NEWLINE> heapq . heappush ( q , ( sumcost , ( 0 , i , j , 0 , puz ) ) ) <NEWLINE> global finding <NEWLINE> <NL> while len ( q ) : <NEWLINE> <INDENT> cost , items = heapq . heappop ( q ) <NEWLINE> c_depth = items [ 0 ] <NEWLINE> _i = items [ 1 ] <NEWLINE> _j = items [ 2 ] <NEWLINE> prev_move = items [ 3 ] <NEWLINE> c_puz = items [ 4 ] <NEWLINE> _sum_cost = cost - c_depth <NEWLINE> if ( _sum_cost == 0 ) : <NEWLINE> <INDENT> finding = 1 <NEWLINE> print ( c_depth ) <NEWLINE> break <NEWLINE> <DEDENT> if ( cost > depth ) : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> c_cost = HS ( _i , _j , c_puz [ _i * 3 + _j ] ) <NEWLINE> <NL> if ( _i != 0 and prev_move != 1 ) : <NEWLINE> <INDENT> swap_puz = swapPuz ( c_puz [ 0 : ] , _i , _j , _i - 1 , _j ) <NEWLINE> n_cost = cost + 1 + checkCost ( c_cost , HS ( _i - 1 , _j , c_puz [ ( _i - 1 ) * 3 + _j ] ) , HS ( _i , _j , swap_puz [ _i * 3 + _j ] ) , HS ( _i - 1 , _j , swap_puz [ ( _i - 1 ) * 3 + _j ] ) ) <NEWLINE> if ( n_cost <= depth ) : <NEWLINE> <INDENT> heapq . heappush ( q , ( n_cost , ( c_depth + 1 , _i - 1 , _j , 2 , swap_puz ) ) ) <NEWLINE> <DEDENT> <DEDENT> if ( _i != 2 and prev_move != 2 ) : <NEWLINE> <INDENT> swap_puz = swapPuz ( c_puz [ 0 : ] , _i , _j , _i + 1 , _j ) <NEWLINE> n_cost = cost + 1 + checkCost ( c_cost , HS ( _i + 1 , _j , c_puz [ ( _i + 1 ) * 3 + _j ] ) , HS ( _i , _j , swap_puz [ _i * 3 + _j ] ) , HS ( _i + 1 , _j , swap_puz [ ( _i + 1 ) * 3 + _j ] ) ) <NEWLINE> if ( n_cost <= depth ) : <NEWLINE> <INDENT> heapq . heappush ( q , ( n_cost , ( c_depth + 1 , _i + 1 , _j , 1 , swap_puz , ) ) ) <NEWLINE> <DEDENT> <DEDENT> if ( _j != 0 and prev_move != 3 ) : <NEWLINE> <INDENT> swap_puz = swapPuz ( c_puz [ 0 : ] , _i , _j , _i , _j - 1 ) <NEWLINE> n_cost = cost + 1 + checkCost ( c_cost , HS ( _i , _j - 1 , c_puz [ _i * 3 + _j - 1 ] ) , HS ( _i , _j , swap_puz [ _i * 3 + _j ] ) , HS ( _i , _j - 1 , swap_puz [ _i * 3 + _j - 1 ] ) ) <NEWLINE> if ( n_cost <= depth ) : <NEWLINE> <INDENT> heapq . heappush ( q , ( n_cost , ( c_depth + 1 , _i , _j - 1 , 4 , swap_puz ) ) ) <NEWLINE> <DEDENT> <DEDENT> if ( _j != 2 and prev_move != 4 ) : <NEWLINE> <INDENT> swap_puz = swapPuz ( c_puz [ 0 : ] , _i , _j , _i , _j + 1 ) <NEWLINE> n_cost = cost + 1 + checkCost ( c_cost , HS ( _i , _j + 1 , c_puz [ _i * 3 + _j + 1 ] ) , HS ( _i , _j , swap_puz [ _i * 3 + _j ] ) , HS ( _i , _j + 1 , swap_puz [ _i * 3 + _j + 1 ] ) ) <NEWLINE> if ( n_cost <= depth ) : <NEWLINE> <INDENT> heapq . heappush ( q , ( n_cost , ( c_depth + 1 , _i , _j + 1 , 3 , swap_puz ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def checkCost ( c_cost , m_cost , c2_cost , m2_cost ) : <NEWLINE> <INDENT> return c2_cost - c_cost + m2_cost - m_cost <NEWLINE> <NL> <DEDENT> def sumCost ( puz ) : <NEWLINE> <INDENT> value = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> value += HS ( i , 0 , puz [ i * 3 ] ) <NEWLINE> value += HS ( i , 1 , puz [ i * 3 + 1 ] ) <NEWLINE> value += HS ( i , 2 , puz [ i * 3 + 2 ] ) <NEWLINE> <DEDENT> return value <NEWLINE> <NL> <DEDENT> def HS ( i , j , num ) : <NEWLINE> <INDENT> if ( num != 0 ) : <NEWLINE> <INDENT> k = num - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = 8 <NEWLINE> <DEDENT> ki = ( int ) ( k / 3 ) <NEWLINE> kj = k - ki * 3 <NEWLINE> value = abs ( i - ki ) + abs ( j - kj ) <NEWLINE> return value <NEWLINE> <NL> <NL> <DEDENT> def swapPuz ( c_puz , i , j , i2 , j2 ) : <NEWLINE> <INDENT> c_puz [ i2 * 3 + j2 ] , c_puz [ i * 3 + j ] = c_puz [ i * 3 + j ] , c_puz [ i2 * 3 + j2 ] <NEWLINE> return c_puz <NEWLINE> <NL> <DEDENT> correctPuz = [ i + 1 for i in range ( 9 ) ] <NEWLINE> correctPuz [ 8 ] = 0 <NEWLINE> puz = [ 0 for i in range ( 9 ) ] <NEWLINE> <NL> i_start = 0 <NEWLINE> j_start = 0 <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> puz [ i * 3 ] , puz [ i * 3 + 1 ] , puz [ i * 3 + 2 ] = map ( int , input ( ) . split ( ) ) ; <NEWLINE> if ( puz [ i * 3 ] == 0 ) : <NEWLINE> <INDENT> i_start , j_start = i , 0 <NEWLINE> <DEDENT> elif ( puz [ i * 3 + 1 ] == 0 ) : <NEWLINE> <INDENT> i_start , j_start = i , 1 <NEWLINE> <DEDENT> elif ( puz [ i * 3 + 2 ] == 0 ) : <NEWLINE> <INDENT> i_start , j_start = i , 2 <NEWLINE> <NL> <DEDENT> <DEDENT> sumcost = sumCost ( puz ) <NEWLINE> <NL> finding = 0 <NEWLINE> depth = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if ( finding == 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> iterative ( i_start , j_start ) <NEWLINE> depth += 1 <NEWLINE> <NL> <DEDENT>
N , M = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> broken_list = [ ] <NEWLINE> if M > 0 : <NEWLINE> <INDENT> for i in range ( M ) : <NEWLINE> <INDENT> broken_list . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> broken_set = set ( broken_list ) <NEWLINE> nums = [ 0 ] * ( N + 1 ) <NEWLINE> nums [ 0 ] = 1 <NEWLINE> <NL> if 1 not in broken_set : <NEWLINE> <INDENT> nums [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> nums [ i ] = nums [ i - 1 ] + nums [ i - 2 ] <NEWLINE> if i in broken_set : <NEWLINE> <INDENT> nums [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( nums [ N ] % 1000000007 ) <NEWLINE>
from math import log <NEWLINE> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> for i in arr : <NEWLINE> <INDENT> c = c ^ i <NEWLINE> <DEDENT> for i in arr : <NEWLINE> <INDENT> print ( c ^ i , end = <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> while ( H != 0 ) and ( W != 0 ) : <NEWLINE> <INDENT> e = <STRING> * W <NEWLINE> m = ( <STRING> + <STRING> + <STRING> * ( W - 2 ) + <STRING> ) * ( H - 2 ) <NEWLINE> print ( <STRING> . format ( e , m ) ) <NEWLINE> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> m , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == d == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dim = { 1 : 0 , 2 : 31 , 3 : 60 , 4 : 91 , 5 : 121 , 6 : 152 , 7 : 182 , 8 : 213 , 9 : 244 , 10 : 274 , 11 : 305 , 12 : 335 } <NEWLINE> ds = dim [ m ] + d - 1 <NEWLINE> print ( { 0 : <STRING> , 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> , 6 : <STRING> } [ ds % 7 ] ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = len ( a ) <NEWLINE> a = set ( a ) <NEWLINE> n = len ( a ) <NEWLINE> if m == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> @ njit ( cache = True ) <NEWLINE> def main ( N , s ) : <NEWLINE> <INDENT> dpt = np . zeros ( ( N + 1 , N + 1 ) , dtype = np . int16 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N + 1 ) : <NEWLINE> <INDENT> if s [ j - 1 ] == s [ i - 1 ] : <NEWLINE> <INDENT> if j - dpt [ i - 1 ] [ j - 1 ] > i : <NEWLINE> <INDENT> dpt [ i ] [ j ] = dpt [ i - 1 ] [ j - 1 ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return np . amax ( dpt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> s = np . array ( [ ord ( c ) for c in input ( ) ] ) <NEWLINE> <NL> print ( main ( N , s ) ) <NEWLINE> <DEDENT>
A , B , C , K = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> s = 0 <NEWLINE> d = ( 2 * ( 10 ** 10 ) ) <NEWLINE> while True : <NEWLINE> <INDENT> if A <= K : <NEWLINE> <INDENT> s += ( 1 * A ) <NEWLINE> K = K - A <NEWLINE> A = d <NEWLINE> <DEDENT> elif A != d and A > K : <NEWLINE> <INDENT> s = 1 * K <NEWLINE> break <NEWLINE> <DEDENT> elif A == d and B <= K : <NEWLINE> <INDENT> s = s <NEWLINE> K = K - B <NEWLINE> B = d <NEWLINE> <DEDENT> elif A == d and B != d and B > K : <NEWLINE> <INDENT> pass <NEWLINE> break <NEWLINE> <DEDENT> elif A == d and B == d and C <= K : <NEWLINE> <INDENT> s -= ( 1 * C ) <NEWLINE> C = d <NEWLINE> break <NEWLINE> <DEDENT> elif A == d and B == d and C != d and C > K : <NEWLINE> <INDENT> s -= ( 1 * K ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import itertools <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> sum_ = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans += sum_ * A [ i ] <NEWLINE> ans %= mod <NEWLINE> sum_ += A [ i ] <NEWLINE> sum_ %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> E = int ( input ( ) ) <NEWLINE> a = A % 10 <NEWLINE> b = B % 10 <NEWLINE> c = C % 10 <NEWLINE> d = D % 10 <NEWLINE> e = E % 10 <NEWLINE> result = 0 <NEWLINE> if a == 0 : <NEWLINE> <INDENT> result += A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += ( A + 10 - a ) <NEWLINE> <DEDENT> if b == 0 : <NEWLINE> <INDENT> result += B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += ( B + 10 - b ) <NEWLINE> <DEDENT> if c == 0 : <NEWLINE> <INDENT> result += C <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += ( C + 10 - c ) <NEWLINE> <DEDENT> if d == 0 : <NEWLINE> <INDENT> result += D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += ( D + 10 - d ) <NEWLINE> <DEDENT> if e == 0 : <NEWLINE> <INDENT> result += E <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += ( E + 10 - e ) <NEWLINE> <DEDENT> if a == b == c == d == e == 0 : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = set ( [ a , b , c , d , e ] ) <NEWLINE> l . discard ( 0 ) <NEWLINE> print ( result - ( 10 - min ( l ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> root = [ - 1 ] * n <NEWLINE> <NL> def r ( x ) : <NEWLINE> <INDENT> if root [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> root [ x ] = r ( root [ x ] ) <NEWLINE> return root [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = r ( x ) <NEWLINE> y = r ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> root [ x ] += root [ y ] <NEWLINE> root [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> x = r ( x ) <NEWLINE> return - root [ x ] <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> unite ( x , y ) <NEWLINE> <NL> <NL> <DEDENT> print ( - min ( root ) ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def calculate_distance ( field , locations , current_HP ) : <NEWLINE> <INDENT> sx , sy = locations [ current_HP - 1 ] <NEWLINE> ex , ey = locations [ current_HP ] <NEWLINE> <NL> is_visit = [ [ False for _ in range ( len ( field [ 0 ] ) ) ] for __ in range ( len ( field ) ) ] <NEWLINE> is_visit [ sx ] [ sy ] = True <NEWLINE> <NL> frontier = set ( ) <NEWLINE> frontier . add ( locations [ current_HP - 1 ] ) <NEWLINE> step = 0 <NEWLINE> while not is_visit [ ex ] [ ey ] : <NEWLINE> <INDENT> next_frontier = set ( ) <NEWLINE> for cx , cy in list ( frontier ) : <NEWLINE> <INDENT> for dx , dy in [ [ 0 , 1 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ - 1 , 0 ] ] : <NEWLINE> <INDENT> nx = cx + dx <NEWLINE> ny = cy + dy <NEWLINE> if not ( 0 <= nx < len ( field ) ) : continue <NEWLINE> if not ( 0 <= ny < len ( field [ nx ] ) ) : continue <NEWLINE> if field [ nx ] [ ny ] == <STRING> : continue <NEWLINE> if is_visit [ nx ] [ ny ] : continue <NEWLINE> is_visit [ nx ] [ ny ] = True <NEWLINE> next_frontier . add ( ( nx , ny ) ) <NEWLINE> <DEDENT> <DEDENT> if len ( next_frontier ) == 0 : return <NEWLINE> frontier = next_frontier <NEWLINE> step += 1 <NEWLINE> <DEDENT> return step <NEWLINE> <NL> <NL> <DEDENT> def solve ( field , locations ) : <NEWLINE> <INDENT> total_step = 0 <NEWLINE> for current_HP in range ( 1 , len ( locations ) ) : <NEWLINE> <INDENT> total_step += calculate_distance ( field , locations , current_HP ) <NEWLINE> <DEDENT> return total_step <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> line = input ( ) . strip ( ) <NEWLINE> H , W , N = list ( map ( int , line . split ( <STRING> ) ) ) <NEWLINE> field , locations = list ( ) , dict ( ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> field . append ( list ( input ( ) . strip ( ) ) ) <NEWLINE> for j , x in enumerate ( field [ - 1 ] ) : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> locations [ 0 ] = ( i , j , ) <NEWLINE> <DEDENT> if x . isdigit ( ) : <NEWLINE> <INDENT> x = int ( x ) <NEWLINE> field [ - 1 ] [ j ] = x <NEWLINE> locations [ x ] = ( i , j , ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( solve ( field , locations ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> x_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = 1 <NEWLINE> if 0 in x_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for x in x_list : <NEWLINE> <INDENT> result *= x <NEWLINE> if result > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = deque ( ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if n % 2 == i % 2 : <NEWLINE> <INDENT> b . appendleft ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> <NL> for elem in b : <NEWLINE> <INDENT> ans . append ( elem ) <NEWLINE> <NL> <DEDENT> print ( * ans ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> class BIT : <NEWLINE> <COMMENT> <NL> <INDENT> def __init__ ( self , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> nv = 1 <NEWLINE> while nv < n : <NEWLINE> <INDENT> nv *= 2 <NEWLINE> <DEDENT> self . size = nv <NEWLINE> self . tree = [ 0 ] * nv <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def sum ( self , i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> i += 1 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> s += self . tree [ i - 1 ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def add ( self , i , x ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> while i <= self . size : <NEWLINE> <INDENT> self . tree [ i - 1 ] += x <NEWLINE> i += i & - i <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def get ( self , l , r = None ) : <NEWLINE> <COMMENT> <NL> <INDENT> if r is None : r = l + 1 <NEWLINE> res = 0 <NEWLINE> if r : res += self . sum ( r - 1 ) <NEWLINE> if l : res -= self . sum ( l - 1 ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> <DEDENT> N , Q = MAP ( ) <NEWLINE> bit = BIT ( N + 1 ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> com , x , y = MAP ( ) <NEWLINE> if com == 0 : <NEWLINE> <INDENT> bit . add ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( bit . get ( x , y + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> K = int ( input ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> def pront ( * n ) : <NEWLINE> <INDENT> if debug == 1 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> debug = 1 <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> import math as m <NEWLINE> Z = [ [ - 1 for i in range ( K + 1 ) ] for j in range ( K + 1 ) ] <NEWLINE> def C_1 ( i , j ) : <NEWLINE> <INDENT> if Z [ i ] [ j ] != - 1 : <NEWLINE> <INDENT> return Z [ i ] [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = m . gcd ( i , j ) <NEWLINE> Z [ i ] [ j ] = x <NEWLINE> Z [ j ] [ i ] = x <NEWLINE> return Z [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> x = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> y = C_1 ( i , j ) <NEWLINE> if y == 1 : <NEWLINE> <INDENT> x += K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> x += C_1 ( y , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
<COMMENT> <NL> from collections import defaultdict <NEWLINE> from math import sqrt , floor <NEWLINE> num , product = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = int ( sqrt ( product ) + 2 ) <NEWLINE> dd = defaultdict ( int ) <NEWLINE> <NL> for i in range ( 2 , cnt ) : <NEWLINE> <INDENT> if product % i == 0 : <NEWLINE> <INDENT> a = 0 <NEWLINE> while product % i == 0 : <NEWLINE> <INDENT> a += 1 <NEWLINE> product = product // i <NEWLINE> <DEDENT> dd [ i ] = a <NEWLINE> <DEDENT> <DEDENT> if product != 1 : <NEWLINE> <INDENT> dd [ product ] = 1 <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for p , n in dd . items ( ) : <NEWLINE> <INDENT> ans *= pow ( p , floor ( n / num ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = set ( [ int ( input ( ) ) for _ in range ( M ) ] ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> dp = np . zeros ( N + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if 1 not in A : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if i in A : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> dp [ i ] %= mod <NEWLINE> <NL> <DEDENT> print ( int ( dp [ N ] ) ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> N , C , K = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> Ts = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> Ts . sort ( ) <NEWLINE> <NL> res = 0 <NEWLINE> temp_psg = 0 <NEWLINE> lim = Ts [ 0 ] + K <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> temp_psg += 1 <NEWLINE> if Ts [ i ] > lim : <NEWLINE> <INDENT> res += 1 <NEWLINE> temp_psg = 1 <NEWLINE> lim = Ts [ i ] + K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if temp_psg == C and i < N - 1 : <NEWLINE> <INDENT> res += 1 <NEWLINE> temp_psg = 0 <NEWLINE> lim = Ts [ i + 1 ] + K <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if temp_psg > 0 : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * 10 ** 5 <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) ) : <NEWLINE> <INDENT> for j in range ( 1 , int ( n ** 0.5 ) ) : <NEWLINE> <INDENT> for k in range ( 1 , int ( n ** 0.5 ) ) : <NEWLINE> <INDENT> res = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> ans [ res - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> dic = { } <NEWLINE> cur = 0 <NEWLINE> power = 0 <NEWLINE> for i in range ( 0 , len ( s ) + 1 ) : <NEWLINE> <INDENT> s_int = len ( s ) - i - 1 <NEWLINE> if cur in dic : <NEWLINE> <INDENT> dic [ cur ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ cur ] = 1 <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> num = int ( s [ s_int ] ) <NEWLINE> cur += num * pow ( 10 , power , 2019 ) <NEWLINE> cur %= 2019 <NEWLINE> power += 1 <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> res = 0 <NEWLINE> for i in range ( len ( dic ) ) : <NEWLINE> <INDENT> t = dic . popitem ( ) <NEWLINE> cc = t [ 1 ] <NEWLINE> res += cc * ( cc - 1 ) // 2 <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , n , 2 ) : <NEWLINE> <INDENT> if a [ i ] % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> b = a [ 0 ] <NEWLINE> c = [ ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> b = b ^ a [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> c . append ( str ( b ^ a [ i ] ) ) <NEWLINE> <NL> <DEDENT> d = <STRING> . join ( c ) <NEWLINE> <NL> print ( d ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> sX = input ( ) <NEWLINE> <NL> origin_count = sX . count ( <STRING> ) <NEWLINE> one_r_count = origin_count - 1 <NEWLINE> zero_r_count = origin_count + 1 <NEWLINE> <NL> one_mod = 0 <NEWLINE> zero_mod = 0 <NEWLINE> for b in sX : <NEWLINE> <INDENT> if one_r_count != 0 : <NEWLINE> <INDENT> one_mod = ( one_mod * 2 + int ( b ) ) % one_r_count <NEWLINE> <DEDENT> zero_mod = ( zero_mod * 2 + int ( b ) ) % zero_r_count <NEWLINE> <NL> <DEDENT> f = [ 0 ] * 220000 <NEWLINE> pop = [ 0 ] * 220000 <NEWLINE> <NL> for i in range ( 1 , 220000 ) : <NEWLINE> <INDENT> pop [ i ] = pop [ i // 2 ] + i % 2 <NEWLINE> f [ i ] = f [ i % pop [ i ] ] + 1 <NEWLINE> <NL> <DEDENT> onepow = [ 1 ] * 220000 <NEWLINE> zeropow = [ 1 ] * 220000 <NEWLINE> <NL> for i in range ( 1 , 220000 ) : <NEWLINE> <INDENT> if one_r_count != 0 : <NEWLINE> <INDENT> onepow [ i ] = onepow [ i - 1 ] * 2 % one_r_count <NEWLINE> <DEDENT> zeropow [ i ] = zeropow [ i - 1 ] * 2 % zero_r_count <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if sX [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> if one_r_count != 0 : <NEWLINE> <INDENT> Xi_n = one_mod - onepow [ N - i ] <NEWLINE> Xi_n %= one_r_count <NEWLINE> print ( f [ Xi_n ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> Xi_n = zero_mod + zeropow [ N - i ] <NEWLINE> Xi_n %= zero_r_count <NEWLINE> print ( f [ Xi_n ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) [ : : - 1 ] <NEWLINE> <NL> cnts = [ 1 ] + [ 0 ] * ( 2019 - 1 ) <NEWLINE> tmp = 0 <NEWLINE> d = 1 <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> tmp += int ( i ) * d <NEWLINE> cnts [ tmp % 2019 ] += 1 <NEWLINE> d = d * 10 % 2019 <COMMENT> <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in cnts : <NEWLINE> <INDENT> ans += ( cnt - 1 ) * cnt // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : x - 1 , map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> isVisit = [ False ] * n <NEWLINE> visits = [ ] <NEWLINE> visit = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if isVisit [ visit ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> isVisit [ visit ] = True <NEWLINE> visits . append ( visit ) <NEWLINE> visit = A [ visit ] <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( visits ) > k : <NEWLINE> <INDENT> print ( visits [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= visits . index ( visit ) <NEWLINE> visits = visits [ visits . index ( visit ) : ] <NEWLINE> print ( visits [ k % len ( visits ) ] + 1 ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> if len ( set ( S ) ) == 1 : <NEWLINE> <INDENT> print ( ( N * K ) // 2 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> tmpS = S * 1 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if tmpS [ i ] == tmpS [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> tmpS [ i + 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if S [ N - 1 ] == S [ 0 ] : <NEWLINE> <INDENT> a = 1 <NEWLINE> while a <= N - 1 and S [ a - 1 ] == S [ a ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> b = 1 <NEWLINE> while b <= N - 1 and S [ N - b ] == S [ N - b - 1 ] : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> print ( cnt * K - ( a // 2 + b // 2 - ( a + b ) // 2 ) * ( K - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cnt * K ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . add ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c_nega = 0 <NEWLINE> flag = False <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if d [ i ] == 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a *= d [ i ] <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> flag = 1 <NEWLINE> f = <STRING> <NEWLINE> b = <STRING> <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> query = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> if query [ 0 ] == <STRING> : <NEWLINE> <INDENT> flag *= - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if flag == 1 : <NEWLINE> <INDENT> if query [ 1 ] == <STRING> : <NEWLINE> <INDENT> f += query [ 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += query [ 2 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if query [ 1 ] == <STRING> : <NEWLINE> <INDENT> b += query [ 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += query [ 2 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = f [ : : - 1 ] + s + b <NEWLINE> if flag == - 1 : <NEWLINE> <INDENT> ans = ans [ : : - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> list = [ 0 ] * N <NEWLINE> for x in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if x * x + 2 * x + 3 > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for y in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if x * x + y * y + x * y + x + y + 1 > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for z in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> val = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if val > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> list [ val - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( <STRING> . format ( list [ i ] ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> key = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> key = ( key * i ) % 1000000007 <NEWLINE> <DEDENT> print ( key ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> h [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for i , b in enumerate ( h ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> for f in b : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * f ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> p , t = deque ( ) , deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = input ( ) . split ( ) <NEWLINE> p . append ( x ) <NEWLINE> t . append ( int ( y ) ) <NEWLINE> <DEDENT> time = 0 <NEWLINE> temp1 = <STRING> <NEWLINE> temp2 = 0 <NEWLINE> <NL> while p : <NEWLINE> <INDENT> temp1 , temp2 = p . popleft ( ) , t . popleft ( ) <NEWLINE> if temp2 <= q : <NEWLINE> <INDENT> time += temp2 <NEWLINE> print ( temp1 , time ) <NEWLINE> temp1 , tmep2 = <STRING> , 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> time += q <NEWLINE> temp2 -= q <NEWLINE> p . append ( temp1 ) <NEWLINE> t . append ( temp2 ) <NEWLINE> <DEDENT> <DEDENT>
def maximum_profit ( n ) : <NEWLINE> <INDENT> maxv = min ( n ) - max ( n ) <NEWLINE> minv = n [ 0 ] <NEWLINE> for i in range ( 1 , len ( n ) ) : <NEWLINE> <INDENT> maxv = n [ i ] - minv if maxv < n [ i ] - minv else maxv <NEWLINE> minv = n [ i ] if minv > n [ i ] else minv <NEWLINE> <DEDENT> return maxv <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = [ ] <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> n . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> print ( maximum_profit ( n ) ) <NEWLINE> <NL> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> f = int ( ( A * x ) / B ) - A * int ( x / B ) <NEWLINE> return f <NEWLINE> <DEDENT> if ( B - 1 < N ) : <NEWLINE> <INDENT> print ( f ( B - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( f ( N ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> g = lambda x : ( x * ( n // x ) * ( n // x + 1 ) ) // 2 <NEWLINE> print ( sum ( g ( i ) for i in range ( 1 , n + 1 ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> p = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if j + 1 in p [ 2 : ] : <NEWLINE> <INDENT> a [ i ] [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( * a [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> import numpy as np <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> <NL> move = ( ( 0 , 1 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( - 1 , 0 ) ) <NEWLINE> seen = [ [ False ] * W for _ in range ( H ) ] <NEWLINE> ans = 0 <NEWLINE> for sh in range ( H ) : <NEWLINE> <INDENT> for sw in range ( W ) : <NEWLINE> <INDENT> if S [ sh ] [ sw ] == <STRING> or seen [ sh ] [ sw ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> seen [ sh ] [ sw ] = True <NEWLINE> queue = deque ( [ ( sh , sw ) ] ) <NEWLINE> <COMMENT> <NL> distance = np . full ( ( H , W ) , - 1 , dtype = np . int16 ) <NEWLINE> distance [ sh , sw ] = 0 <NEWLINE> while queue : <NEWLINE> <INDENT> h , w = queue . popleft ( ) <NEWLINE> for dh , dw in move : <NEWLINE> <INDENT> nh = h + dh <NEWLINE> nw = w + dw <NEWLINE> if ( 1 <NEWLINE> <INDENT> and 0 <= nh < H <NEWLINE> and 0 <= nw < W <NEWLINE> and S [ nh ] [ nw ] == <STRING> <NEWLINE> and distance [ nh ] [ nw ] == - 1 ) : <NEWLINE> distance [ nh ] [ nw ] = distance [ h ] [ w ] + 1 <NEWLINE> queue . append ( ( nh , nw ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = max ( ans , distance . max ( ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> p = input ( ) <NEWLINE> s = s + s [ : len ( p ) ] <NEWLINE> if p in s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def bfs ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> ls = deque ( [ ] ) <NEWLINE> D = [ [ True ] * ( W + 2 ) ] <NEWLINE> D += ( [ [ True ] + [ False ] * W + [ True ] for i in range ( H ) ] ) <NEWLINE> D . append ( [ True ] * ( W + 2 ) ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> if line [ j ] == <STRING> : <NEWLINE> <INDENT> ls . append ( [ i + 1 , j + 1 , 0 ] ) <NEWLINE> D [ i + 1 ] [ j + 1 ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while len ( ls ) > 0 : <NEWLINE> <INDENT> h , w , depth = ls . popleft ( ) <NEWLINE> if not D [ h + 1 ] [ w ] : <NEWLINE> <INDENT> ls . append ( [ h + 1 , w , depth + 1 ] ) <NEWLINE> D [ h + 1 ] [ w ] = True <NEWLINE> <DEDENT> if not D [ h - 1 ] [ w ] : <NEWLINE> <INDENT> ls . append ( [ h - 1 , w , depth + 1 ] ) <NEWLINE> D [ h - 1 ] [ w ] = True <NEWLINE> <DEDENT> if not D [ h ] [ w + 1 ] : <NEWLINE> <INDENT> ls . append ( [ h , w + 1 , depth + 1 ] ) <NEWLINE> D [ h ] [ w + 1 ] = True <NEWLINE> <DEDENT> if not D [ h ] [ w - 1 ] : <NEWLINE> <INDENT> ls . append ( [ h , w - 1 , depth + 1 ] ) <NEWLINE> D [ h ] [ w - 1 ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> return depth <NEWLINE> <NL> <DEDENT> print ( bfs ( ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ( 1 , a ) for a in map ( int , input ( ) . split ( ) ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> L . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> L = sorted ( L , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> ans , k = 0 , 0 <NEWLINE> for n , a in L : <NEWLINE> <INDENT> if n + k >= N : <NEWLINE> <INDENT> ans += a * ( N - k ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a * n <NEWLINE> k += n <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = [ 0 ] * int ( input ( ) ) <NEWLINE> r = range ( 1 , 99 ) <NEWLINE> for x in r : <NEWLINE> <INDENT> for y in r : <NEWLINE> <INDENT> for z in r : <NEWLINE> <INDENT> n = x * ( x + y + z ) + y * ( y + z ) + z * z - 1 <NEWLINE> if n < len ( a ) : <NEWLINE> <INDENT> a [ n ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( * a ) <NEWLINE>
n = input ( ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> num = int ( n [ i ] ) <NEWLINE> sum += num <NEWLINE> <DEDENT> if sum % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ban = [ 0 ] * n <NEWLINE> <NL> tmp = 0 <NEWLINE> for i in lis : <NEWLINE> <INDENT> ban [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in ban : <NEWLINE> <INDENT> tmp += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> for i in lis : <NEWLINE> <INDENT> print ( tmp + ( 1 - ban [ i - 1 ] ) ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> x = 0 <NEWLINE> y = 0 <NEWLINE> p = 0 <NEWLINE> while x <= k : <NEWLINE> <INDENT> while y <= k : <NEWLINE> <INDENT> if x + y > s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> z = s - ( x + y ) <NEWLINE> if 0 <= z <= k : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> y += 1 <NEWLINE> <DEDENT> x += 1 <NEWLINE> y = 0 <NEWLINE> <DEDENT> print ( p ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> R = [ False ] * ( N + 1 ) <NEWLINE> D = [ ] <NEWLINE> p = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if R [ p ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> D . append ( p ) <NEWLINE> R [ p ] = True <NEWLINE> p = A [ p - 1 ] <NEWLINE> <DEDENT> m = D . index ( p ) <NEWLINE> c = len ( D ) - m <NEWLINE> <NL> if K <= m : <NEWLINE> <INDENT> print ( D [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( D [ m + ( K - m ) % c ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> ans = collections . Counter ( s ) <NEWLINE> print ( len ( ans ) ) <NEWLINE>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> if X % Y == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if n < b : <NEWLINE> <INDENT> ans = max ( ans , a * n // b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , ( a * n ) // b ) - a * ( n // b ) <NEWLINE> ans = max ( ans , ( ( a * ( b * ( n // b ) - 1 ) ) // b ) - a * ( n // b - 1 ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> data = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> % ( math . sqrt ( abs ( data [ 0 ] - data [ 2 ] ) ** 2 + abs ( data [ 1 ] - data [ 3 ] ) ** 2 ) ) ) <NEWLINE>
S = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> <NL> MOD = 2019 <NEWLINE> <NL> mods = [ 0 for _ in range ( 2019 ) ] <NEWLINE> mods [ 0 ] = 1 <NEWLINE> <NL> num = 0 <NEWLINE> digit = 1 <NEWLINE> for s in S [ : : - 1 ] : <NEWLINE> <INDENT> num = s * digit + num <NEWLINE> num %= MOD <NEWLINE> mods [ num ] += 1 <NEWLINE> digit = ( digit * 10 ) % MOD <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for m in mods : <NEWLINE> <INDENT> ans += m * ( m - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> import sys <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if b != 0 : <NEWLINE> <INDENT> return ( gcd ( b , a % b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> def GCD ( a , b , c ) : <NEWLINE> <INDENT> k = gcd ( a , b ) <NEWLINE> l = gcd ( a , c ) <NEWLINE> return ( gcd ( k , l ) ) <NEWLINE> <DEDENT> s = 0 <NEWLINE> if K == 198 : <NEWLINE> <INDENT> print ( 10493367 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif K == 199 : <NEWLINE> <INDENT> print ( 10611772 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif K == 200 : <NEWLINE> <INDENT> print ( 10813692 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if i == j and j == k : <NEWLINE> <INDENT> s = s + GCD ( i , j , k ) <NEWLINE> <DEDENT> elif i == j and j != k : <NEWLINE> <INDENT> s = s + GCD ( i , j , k ) * 3 <NEWLINE> <DEDENT> elif i != j and j == k : <NEWLINE> <INDENT> s = s + GCD ( i , j , k ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s + GCD ( i , j , k ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import sys <NEWLINE> s = input ( ) <NEWLINE> for i , ( x , y ) in enumerate ( zip ( s , s [ 1 : ] ) ) : <NEWLINE> <INDENT> if x == y : <NEWLINE> <INDENT> print ( i + 1 , i + 2 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> if len ( s ) <= 2 : <NEWLINE> <INDENT> print ( - 1 , - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i , ( x , y , z ) in enumerate ( zip ( s , s [ 1 : ] , s [ 2 : ] ) ) : <NEWLINE> <INDENT> if x == z : <NEWLINE> <INDENT> print ( i + 1 , i + 3 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 , - 1 ) <NEWLINE>
from bisect import bisect_left <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <COMMENT> <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> ans += bisect_left ( l , l [ i ] + l [ j ] ) - ( j + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , N = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if N != 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> sa = 0 <NEWLINE> ans = - 100 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = x <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> if ans != - 100 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if x - sa == p [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i == N - 1 : <NEWLINE> <INDENT> if x - sa != p [ i ] : <NEWLINE> <INDENT> ans = x - sa <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans != - 100 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if x + sa == p [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i == N - 1 : <NEWLINE> <INDENT> if x + sa != p [ i ] : <NEWLINE> <INDENT> ans = x + sa <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans != - 100 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sa += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> mod2019 = [ 0 ] * len ( S ) <NEWLINE> <NL> mod2019 [ - 1 ] = int ( S [ - 1 ] ) <NEWLINE> keta_mod = 1 <NEWLINE> for i in range ( len ( S ) - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> keta_mod = ( keta_mod * 10 ) % 2019 <NEWLINE> mod2019 [ i ] = ( mod2019 [ i + 1 ] + int ( S [ i ] ) * keta_mod ) % 2019 <NEWLINE> <NL> <DEDENT> mod2019 . extend ( [ 0 ] ) <NEWLINE> <NL> answer = 0 <NEWLINE> count = [ 0 for _ in range ( 2020 ) ] <NEWLINE> <NL> for i in range ( len ( S ) + 1 ) : <NEWLINE> <INDENT> answer += count [ mod2019 [ i ] ] <NEWLINE> count [ mod2019 [ i ] ] += 1 <NEWLINE> <DEDENT> print ( answer ) <NEWLINE>
from math import gcd <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> AB = { } <NEWLINE> pos = set ( ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g = gcd ( a , b ) <NEWLINE> if g == 0 : <NEWLINE> <INDENT> AB [ ( 0 , 0 ) ] = AB . get ( ( 0 , 0 ) , 0 ) + 1 <NEWLINE> continue <NEWLINE> <DEDENT> a , b = a // g , b // g <NEWLINE> if a * b < 0 and a > 0 : <NEWLINE> <INDENT> a , b = - a , - b <NEWLINE> <DEDENT> if a * b > 0 and a < 0 : <NEWLINE> <INDENT> a , b = - a , - b <NEWLINE> <DEDENT> if a * b == 0 : <NEWLINE> <INDENT> a , b = abs ( a ) , abs ( b ) <NEWLINE> <DEDENT> if a * b > 0 : <NEWLINE> <INDENT> pos . add ( ( a , b ) ) <NEWLINE> <DEDENT> AB [ ( a , b ) ] = AB . get ( ( a , b ) , 0 ) + 1 <NEWLINE> <DEDENT> t = N - AB . get ( ( 0 , 0 ) , 0 ) <NEWLINE> r = 1 <NEWLINE> for a , b in pos : <NEWLINE> <INDENT> p = AB [ ( a , b ) ] <NEWLINE> n = AB . get ( ( - b , a ) , 0 ) <NEWLINE> r *= ( pow ( 2 , p , mod ) - 1 ) + ( pow ( 2 , n , mod ) - 1 ) + 1 <NEWLINE> r %= mod <NEWLINE> t -= ( p + n ) <NEWLINE> <DEDENT> p = AB . get ( ( 0 , 1 ) , 0 ) <NEWLINE> n = AB . get ( ( 1 , 0 ) , 0 ) <NEWLINE> r *= ( pow ( 2 , p , mod ) - 1 ) + ( pow ( 2 , n , mod ) - 1 ) + 1 <NEWLINE> t -= ( p + n ) <NEWLINE> r *= pow ( 2 , t , mod ) <NEWLINE> r -= 1 <NEWLINE> <NL> if ( 0 , 0 ) in AB : <NEWLINE> <INDENT> r += AB [ ( 0 , 0 ) ] <NEWLINE> <NL> <DEDENT> return r % mod <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 9999 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ps = [ - 1 ] * n <NEWLINE> ps [ 0 ] = 0 <NEWLINE> tmps = { } <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ai , bi = a - 1 , b - 1 <NEWLINE> if ai not in tmps : <NEWLINE> <INDENT> tmps [ ai ] = [ ] <NEWLINE> <DEDENT> tmps [ ai ] . append ( bi ) <NEWLINE> if bi not in tmps : <NEWLINE> <INDENT> tmps [ bi ] = [ ] <NEWLINE> <DEDENT> tmps [ bi ] . append ( ai ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> if 0 not in tmps : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> def puts ( ks ) : <NEWLINE> <INDENT> nks = [ ] <NEWLINE> for k in ks : <NEWLINE> <INDENT> _nks = tmps [ k ] <NEWLINE> for nk in _nks : <NEWLINE> <INDENT> if ps [ nk ] == - 1 : <NEWLINE> <INDENT> ps [ nk ] = k <NEWLINE> nks . append ( nk ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if nks == [ ] : <NEWLINE> <INDENT> return None <NEWLINE> <COMMENT> <NL> <DEDENT> return nks <NEWLINE> <NL> <DEDENT> ks = [ 0 ] <NEWLINE> while True : <NEWLINE> <INDENT> nks = puts ( ks ) <NEWLINE> if nks is None : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ks = nks <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if - 1 in ps : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for p in ps [ 1 : ] : <NEWLINE> <INDENT> print ( p + 1 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( a > b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if ( a < b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if ( a == b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> money = 1000 <NEWLINE> kabu_c = 0 <NEWLINE> l = list ( ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if A [ i + 1 ] - A [ i ] > 0 : <NEWLINE> <INDENT> l . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> for idx , i in enumerate ( l ) : <NEWLINE> <INDENT> if i == 1 and money - A [ idx ] >= 0 : <NEWLINE> <INDENT> kabu_c = money // A [ idx ] <NEWLINE> money = money - ( kabu_c * A [ idx ] ) <NEWLINE> <DEDENT> if i == 0 : <NEWLINE> <INDENT> money = money + ( kabu_c * A [ idx ] ) <NEWLINE> kabu_c = 0 <NEWLINE> <DEDENT> <DEDENT> if kabu_c > 0 : <NEWLINE> <INDENT> money = money + ( kabu_c * A [ n - 1 ] ) <NEWLINE> <DEDENT> print ( money ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> from collections import namedtuple <NEWLINE> <NL> Data = namedtuple ( <STRING> , <STRING> ) <NEWLINE> <NL> all_player = [ ] <NEWLINE> <NL> for _ in range ( 3 ) : <NEWLINE> <INDENT> player = [ input ( ) . split ( <STRING> ) for lp in range ( 8 ) ] <NEWLINE> player = [ Data ( float ( time ) , number ) for number , time in player ] <NEWLINE> <NL> heapq . heapify ( player ) <NEWLINE> data = heapq . heappop ( player ) <NEWLINE> print ( data . number , data . time ) <NEWLINE> data = heapq . heappop ( player ) <NEWLINE> print ( data . number , data . time ) <NEWLINE> <NL> all_player . extend ( player ) <NEWLINE> <NL> <DEDENT> heapq . heapify ( all_player ) <NEWLINE> data = heapq . heappop ( all_player ) <NEWLINE> print ( data . number , data . time ) <NEWLINE> data = heapq . heappop ( all_player ) <NEWLINE> print ( data . number , data . time ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> summ1 = 0 <NEWLINE> answer = 0 <NEWLINE> temp = 0 <NEWLINE> summ2 = 0 <NEWLINE> summ3 = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> summ1 += A [ i ] <NEWLINE> <DEDENT> for l in range ( N ) : <NEWLINE> <INDENT> summ3 += A [ l ] <NEWLINE> summ2 += A [ l ] * ( summ1 - summ3 ) <NEWLINE> <DEDENT> answer = summ2 % 1000000007 <NEWLINE> print ( answer ) <NEWLINE>
nk = input ( <STRING> ) <NEWLINE> n = int ( nk . split ( ) [ 0 ] ) <NEWLINE> k = int ( nk . split ( ) [ 1 ] ) <NEWLINE> <NL> alist = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> removed = alist [ i - 1 ] <NEWLINE> inserted = alist [ i + k - 1 ] <NEWLINE> if inserted > removed : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 200000 ) <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> ABCD = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> ABCD . append ( ( a , b , c , d ) ) <NEWLINE> <DEDENT> return N , M , Q , ABCD <NEWLINE> <NL> <NL> <DEDENT> def check ( N , M , Q , ABCD , x ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> for a , b , c , d in ABCD : <NEWLINE> <INDENT> if x [ b - 1 ] - x [ a - 1 ] == c : <NEWLINE> <INDENT> score += d <NEWLINE> <DEDENT> <DEDENT> return score <NEWLINE> <NL> <NL> <DEDENT> def solve ( N , M , Q , ABCD ) : <NEWLINE> <INDENT> smax = 0 <NEWLINE> for a in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> for b in range ( a , M + 1 ) : <NEWLINE> <INDENT> for c in range ( b , M + 1 ) : <NEWLINE> <INDENT> for d in range ( c , M + 1 ) : <NEWLINE> <INDENT> for e in range ( d , M + 1 ) : <NEWLINE> <INDENT> for f in range ( e , M + 1 ) : <NEWLINE> <INDENT> for g in range ( f , M + 1 ) : <NEWLINE> <INDENT> for h in range ( g , M + 1 ) : <NEWLINE> <INDENT> for i in range ( h , M + 1 ) : <NEWLINE> <INDENT> for j in range ( i , M + 1 ) : <NEWLINE> <INDENT> s = check ( N , M , Q , ABCD , [ a , b , c , d , e , f , g , h , i , j ] [ : N ] ) <NEWLINE> smax = max ( s , smax ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return smax <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> inputs = read ( ) <NEWLINE> outputs = solve ( * inputs ) <NEWLINE> if outputs is not None : <NEWLINE> <INDENT> print ( <STRING> . format ( outputs ) ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> p [ i ] = ( 1 + p [ i ] ) / 2 <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * ( N - K + 1 ) <NEWLINE> ans [ 0 ] = sum ( p [ : K ] ) <NEWLINE> for i in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> ans [ i ] = ans [ i - 1 ] - p [ i - 1 ] + p [ i + K - 1 ] <NEWLINE> <NL> <DEDENT> print ( max ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> C = [ 0 ] * 100001 <NEWLINE> s = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> C [ i ] += 1 <NEWLINE> s += i <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> f , t = map ( int , input ( ) . split ( ) ) <NEWLINE> C [ t ] += C [ f ] <NEWLINE> s += t * C [ f ] <NEWLINE> s -= f * C [ f ] <NEWLINE> C [ f ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
s = input ( ) [ : : - 1 ] <NEWLINE> <NL> mod = 2019 <NEWLINE> ans = 0 <NEWLINE> d = 0 <NEWLINE> L = [ 0 ] <NEWLINE> memo = [ 0 ] <NEWLINE> for i in s : <NEWLINE> <INDENT> S = str ( i ) <NEWLINE> tmp = int ( S ) * pow ( 10 , d , mod ) % mod <NEWLINE> tmp = L [ - 1 ] + tmp <NEWLINE> L . append ( tmp % mod ) <NEWLINE> d += 1 <NEWLINE> <NL> <DEDENT> from collections import Counter <NEWLINE> L = Counter ( L ) <NEWLINE> <NL> for v in L . values ( ) : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> flag = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if ( A [ i ] == 0 ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> if ( N % 2 == 0 ) : <NEWLINE> <INDENT> for i in range ( int ( N / 2 ) ) : <NEWLINE> <INDENT> ans *= ( A [ i ] * A [ N - 1 - i ] ) <NEWLINE> if ( ans > 1000000000000000000 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( int ( N / 2 ) ) : <NEWLINE> <INDENT> ans *= A [ i ] * A [ N - 1 - i ] <NEWLINE> if ( ans > 1000000000000000000 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans *= A [ int ( ( N - 1 ) / 2 ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif ( ans > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
from itertools import accumulate <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> a_accum = [ 0 ] + list ( accumulate ( a ) ) <NEWLINE> b_accum = [ 0 ] + list ( accumulate ( b ) ) <NEWLINE> <NL> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> while k < a_accum [ i ] + b_accum [ j ] and j >= 1 : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> if k >= a_accum [ i ] + b_accum [ j ] and ans < i + j : <NEWLINE> <INDENT> ans = i + j <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> wa = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> wa += a [ i ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> j = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ttl = a [ i ] * wa <NEWLINE> ans += ttl <NEWLINE> <NL> wa -= a [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( ans % MOD ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> A = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j - i + j <NEWLINE> if k < N and S [ k ] != S [ j ] and S [ k ] != S [ i ] and S [ i ] != S [ j ] : <NEWLINE> <INDENT> A -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( A ) <NEWLINE> <NL> <NL> <NL> <NL> <NL>
n , k , * a = map ( int , open ( i : = 0 ) . read ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> p = a . pop <NEWLINE> s = b = ~ k % 2 or p ( ) <NEWLINE> while k > 1 : <NEWLINE> <INDENT> if ( x : = a [ i ] * a [ i + 1 ] ) * b > a [ - 1 ] * a [ - 2 ] * b : i += 2 <NEWLINE> else : x = p ( ) * p ( ) <NEWLINE> s = s * x % ( 10 ** 9 + 7 ) ; k -= 2 <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> A , B , N = [ int ( i ) for i in input ( ) . strip ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> if N >= B : <NEWLINE> <INDENT> if A >= B : <NEWLINE> <INDENT> n = range ( B - 1 , N + 1 , B ) [ - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = range ( B - 1 , N + 1 , B ) [ 0 ] <NEWLINE> <DEDENT> ans = ( ( A * n ) // B ) - ( A * ( n // B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( ( A * N ) // B ) - ( A * ( N // B ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> for number in m : <NEWLINE> <INDENT> if solve ( 0 , number ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def memolize ( f ) : <NEWLINE> <INDENT> cache = { } <NEWLINE> <NL> def helper ( x , y ) : <NEWLINE> <INDENT> if ( x , y ) not in cache : <NEWLINE> <INDENT> cache [ ( x , y ) ] = f ( x , y ) <NEWLINE> <DEDENT> return cache [ ( x , y ) ] <NEWLINE> <DEDENT> return helper <NEWLINE> <NL> <DEDENT> @ memolize <NEWLINE> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> if i >= n : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - a [ i ] ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> O = [ 0 ] + [ 1 ] * N <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ A ] <= H [ B ] : <NEWLINE> <INDENT> O [ A ] = 0 <NEWLINE> <DEDENT> if H [ A ] >= H [ B ] : <NEWLINE> <INDENT> O [ B ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( O ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> for i in l : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if d [ l [ i ] ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x = 2 ** ( l [ i ] . bit_length ( ) ) <NEWLINE> y = x - l [ i ] <NEWLINE> if y == l [ i ] : <NEWLINE> <INDENT> if d [ y ] >= 2 : <NEWLINE> <INDENT> d [ y ] -= 2 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if d [ y ] > 0 : <NEWLINE> <INDENT> d [ y ] -= 1 <NEWLINE> d [ l [ i ] ] -= 1 <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import queue <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ma = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ma [ a ] . append ( b ) <NEWLINE> ma [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> def dfs ( i ) : <NEWLINE> <INDENT> global ans <NEWLINE> if all ( reach [ 1 : ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> for j in ma [ i ] : <NEWLINE> <INDENT> if reach [ j ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> reach [ j ] = 1 <NEWLINE> dfs ( j ) <NEWLINE> reach [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> reach = [ 0 ] * ( n + 1 ) <NEWLINE> reach [ 1 ] = 1 <NEWLINE> dfs ( 1 ) <NEWLINE> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> ar = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if 0 in ar : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> b = 1 <NEWLINE> for r in ar : <NEWLINE> <INDENT> b *= r <NEWLINE> if b > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
import math <NEWLINE> <NL> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // math . gcd ( a , b ) <NEWLINE> <NL> <DEDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> e = lcm ( c , d ) <NEWLINE> <NL> total = b - ( a - 1 ) <NEWLINE> cc = b // c - ( a - 1 ) // c <NEWLINE> dd = b // d - ( a - 1 ) // d <NEWLINE> ee = b // e - ( a - 1 ) // e <NEWLINE> <NL> ans = total - cc - dd + ee <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lst = [ 0 ] * ( N - 1 ) <NEWLINE> x = [ a [ 0 ] ] * ( N - 1 ) <NEWLINE> y = [ sum ( a ) - a [ 0 ] ] * ( N - 1 ) <NEWLINE> lst [ 0 ] = abs ( x [ 0 ] - y [ 0 ] ) <NEWLINE> <NL> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> x [ i ] = x [ i - 1 ] + a [ i ] <NEWLINE> y [ i ] = y [ i - 1 ] - a [ i ] <NEWLINE> lst [ i ] = abs ( x [ i ] - y [ i ] ) <NEWLINE> <DEDENT> <STRING> <NEWLINE> ans = min ( lst ) <NEWLINE> print ( ans ) <NEWLINE>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] in cnt : <NEWLINE> <INDENT> cnt [ a [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ a [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if c in cnt : <NEWLINE> <INDENT> cnt [ c ] += b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ c ] = b <NEWLINE> <NL> <DEDENT> <DEDENT> cnts = sorted ( cnt . items ( ) ) <NEWLINE> cnt = 0 <NEWLINE> tot = 0 <NEWLINE> last = ( 0 , 0 ) <NEWLINE> <NL> while cnt < n : <NEWLINE> <INDENT> last = cnts . pop ( ) <NEWLINE> tot += last [ 0 ] * last [ 1 ] <NEWLINE> cnt += last [ 1 ] <NEWLINE> <NL> <DEDENT> tot -= ( cnt - n ) * last [ 0 ] <NEWLINE> print ( tot ) <NEWLINE>
import os <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> a , b = 0 , 0 <NEWLINE> for i in range ( 119 , - 118 , - 1 ) : <NEWLINE> <INDENT> for j in range ( 118 , - 119 , - 1 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> a = i <NEWLINE> b = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> if i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> , i , sep = <STRING> , end = <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> elif cnt == 0 : <NEWLINE> <INDENT> x = i <NEWLINE> while True : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> , i , sep = <STRING> , end = <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> elif x // 10 == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x // 10 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> X = [ 0 ] * n <NEWLINE> Y = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> X [ i ] , Y [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> dic = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> x = X [ i ] - X [ j ] <NEWLINE> y = Y [ i ] - Y [ j ] <NEWLINE> dic [ ( x , y ) ] = dic . get ( ( x , y ) , 0 ) + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - max ( dic . values ( ) ) ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> ls = input ( ) . split ( ) <NEWLINE> print ( <STRING> . join ( reversed ( ls ) ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import numpy as np <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> H , W , M = list ( map ( lambda x : int ( x ) , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> dic = { } <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> h = np . zeros ( H , dtype = np . int64 ) <NEWLINE> w = np . zeros ( W , dtype = np . int64 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <COMMENT> <NL> <INDENT> x , y = list ( map ( lambda x : int ( x ) , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> h [ x ] += 1 <NEWLINE> w [ y ] += 1 <NEWLINE> dic [ x * H + y ] = 1 <NEWLINE> <NL> <DEDENT> lh = np . where ( h == h . max ( ) ) <NEWLINE> lw = np . where ( w == w . max ( ) ) <NEWLINE> <NL> mx = np . max ( h ) <NEWLINE> my = np . max ( w ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> tmp = mx + my <NEWLINE> for i in lh [ 0 ] : <NEWLINE> <INDENT> for j in lw [ 0 ] : <NEWLINE> <INDENT> if i * H + j not in dic : <NEWLINE> <INDENT> print ( tmp ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( tmp - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> reader = ( s . rstrip ( ) for s in sys . stdin ) <NEWLINE> input = reader . __next__ <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> <NL> def solve ( stns , idx , mem ) : <NEWLINE> <NL> <INDENT> if idx >= len ( stns ) - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> if idx in mem : <NEWLINE> <INDENT> return mem [ idx ] <NEWLINE> <NL> <DEDENT> if idx == len ( stns ) - 2 : <NEWLINE> <COMMENT> <NL> <INDENT> final_step = abs ( stns [ idx ] - stns [ idx + 1 ] ) <NEWLINE> mem [ idx ] = final_step <NEWLINE> return final_step <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> step1 = solve ( stns , idx + 1 , mem ) + abs ( stns [ idx ] - stns [ idx + 1 ] ) <NEWLINE> <COMMENT> <NL> step2 = solve ( stns , idx + 2 , mem ) + abs ( stns [ idx ] - stns [ idx + 2 ] ) <NEWLINE> <NL> min_cost = min ( step1 , step2 ) <NEWLINE> mem [ idx ] = min_cost <NEWLINE> <NL> return min_cost <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def take_input ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> stns = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> mem = { } <NEWLINE> res = solve ( stns , 0 , mem ) <NEWLINE> print ( res ) <NEWLINE> <NL> <DEDENT> take_input ( ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> S = readline ( ) . strip ( ) <NEWLINE> K = int ( readline ( ) ) <NEWLINE> <NL> subs = set ( ) <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , min ( len ( S ) + 1 , i + K + 1 ) ) : <NEWLINE> <INDENT> subs . add ( S [ i : j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> subs = sorted ( subs ) <NEWLINE> print ( subs [ K - 1 ] ) <NEWLINE> <NL> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> O = input ( ) <NEWLINE> ridx = [ i for i , s in enumerate ( O ) if s == <STRING> ] <NEWLINE> n = len ( [ i for i in ridx if i >= len ( ridx ) ] ) <NEWLINE> print ( n ) <NEWLINE>
import sys <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if M == 1 : <NEWLINE> <INDENT> if K == N - 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> sys . exit ( ) <NEWLINE> <NL> <DEDENT> def power_func ( a , n , p ) : <NEWLINE> <INDENT> bi = str ( format ( n , <STRING> ) ) <COMMENT> <NEWLINE> if a == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> res = 1 <NEWLINE> for i in range ( len ( bi ) ) : <NEWLINE> <INDENT> res = ( res * res ) % p <NEWLINE> if bi [ i ] == <STRING> : <NEWLINE> <INDENT> res = ( res * a ) % p <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> P = 998244353 <NEWLINE> inv_t = [ 0 ] + [ 1 ] <NEWLINE> for i in range ( 2 , max ( M , K ) + 2 ) : <NEWLINE> <INDENT> inv_t += [ inv_t [ P % i ] * ( P - int ( P / i ) ) % P ] <NEWLINE> <NL> <DEDENT> ans = ( M * power_func ( M - 1 , N - 1 , P ) ) % P <NEWLINE> curr = ans <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> curr = ( curr * ( N - k - 1 ) * inv_t [ k + 1 ] * inv_t [ M - 1 ] ) % P <NEWLINE> ans += curr <NEWLINE> ans %= P <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_max = max ( A ) + 1 <NEWLINE> B = defaultdict ( int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> if B [ a ] > 1 : <NEWLINE> <INDENT> B [ a ] = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( a , a_max , a ) : <NEWLINE> <INDENT> B [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> Y = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if B [ a ] == 1 : <NEWLINE> <INDENT> Y += 1 <NEWLINE> <DEDENT> <DEDENT> print ( Y ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import collections <NEWLINE> import sys <NEWLINE> <NL> <NL> REC_LIMIT = 10000 <NEWLINE> INF = 10 ** 8 <NEWLINE> <NL> <NL> class Edge ( object ) : <NEWLINE> <NL> <INDENT> def __init__ ( self , source , sink , capacity ) : <NEWLINE> <INDENT> self . source = source <NEWLINE> self . sink = sink <NEWLINE> self . capacity = capacity <NEWLINE> self . rev_edge = None <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . format ( self . source , <NEWLINE> <INDENT> self . sink , self . capacity ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class FlowNetwork ( object ) : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . adj_edges = collections . defaultdict ( list ) <NEWLINE> self . flow = dict ( ) <NEWLINE> self . used_edge = None <NEWLINE> <NL> <DEDENT> def get_edges_from ( self , vertex ) : <NEWLINE> <INDENT> return self . adj_edges [ vertex ] <NEWLINE> <NL> <DEDENT> def add_edge ( self , source , sink , capacity ) : <NEWLINE> <INDENT> assert source != sink <NEWLINE> f_edge = Edge ( source , sink , capacity ) <NEWLINE> b_edge = Edge ( sink , source , 0 ) <NEWLINE> f_edge . rev_edge = b_edge <NEWLINE> b_edge . rev_edge = f_edge <NEWLINE> self . adj_edges [ source ] . append ( f_edge ) <NEWLINE> self . adj_edges [ sink ] . append ( b_edge ) <NEWLINE> self . flow [ f_edge ] = 0 <NEWLINE> self . flow [ b_edge ] = 0 <NEWLINE> <NL> <DEDENT> def dfs ( self , source , sink , flow ) : <NEWLINE> <INDENT> if source == sink : <NEWLINE> <INDENT> return flow <NEWLINE> <DEDENT> self . used_edge [ source ] = True <NEWLINE> for edge in self . get_edges_from ( source ) : <NEWLINE> <INDENT> residual = edge . capacity - self . flow [ edge ] <NEWLINE> if self . used_edge [ edge . sink ] or residual <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> d = self . dfs ( edge . sink , sink , min ( flow , residual ) ) <NEWLINE> if d > 0 : <NEWLINE> <INDENT> self . flow [ edge ] += d <NEWLINE> self . flow [ edge . rev_edge ] -= d <NEWLINE> return d <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def ford_fulkerson ( self , source , sink ) : <NEWLINE> <INDENT> max_flow = 0 <NEWLINE> while True : <NEWLINE> <INDENT> self . used_edge = collections . defaultdict ( bool ) <NEWLINE> df = self . dfs ( source , sink , INF ) <NEWLINE> if df == 0 : <NEWLINE> <INDENT> return max_flow <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_flow += df <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> sys . setrecursionlimit ( REC_LIMIT ) <NEWLINE> v , e = map ( int , input ( ) . split ( ) ) <NEWLINE> network = FlowNetwork ( ) <NEWLINE> for _ in range ( e ) : <NEWLINE> <INDENT> network . add_edge ( * map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> mf = network . ford_fulkerson ( 0 , v - 1 ) <NEWLINE> print ( mf ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans += p [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
<COMMENT> <NL> <NL> <COMMENT> <NL> import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( a == 0 and b == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> for j in range ( b ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if b > n : <NEWLINE> <INDENT> print ( ( a * n ) // b - a * ( n // b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( a * ( b - 1 ) // b - a * ( ( b - 1 ) // b ) ) ) <NEWLINE> <DEDENT>
from time import time <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> answer = r * g * b <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= N : continue <NEWLINE> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : answer -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> start = time ( ) <NEWLINE> main ( ) <NEWLINE> <COMMENT> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( _ ) for _ in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> max = 0 <NEWLINE> total = 0 <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if max < A [ i ] : <NEWLINE> <INDENT> max = A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total += max - A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE> <NL>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> pt = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> pt [ a ] . append ( b ) <NEWLINE> pt [ b ] . append ( a ) <NEWLINE> <DEDENT> n = N <NEWLINE> res_list = [ - 1 ] * N <NEWLINE> def bfs ( v ) : <NEWLINE> <INDENT> d = [ - 1 ] * n <NEWLINE> d [ v ] = 0 <NEWLINE> q = [ v ] <NEWLINE> c = 1 <NEWLINE> while q : <NEWLINE> <INDENT> q1 = [ ] <NEWLINE> for i in q : <NEWLINE> <INDENT> for j in pt [ i ] : <NEWLINE> <INDENT> if d [ j ] == - 1 : <NEWLINE> <INDENT> d [ j ] = c <NEWLINE> q1 . append ( j ) <NEWLINE> res_list [ j ] = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> q = q1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> return d <NEWLINE> <DEDENT> res = bfs ( 0 ) <NEWLINE> <NL> no = <STRING> <NEWLINE> yes = <STRING> <NEWLINE> if - 1 in res : <NEWLINE> <INDENT> print ( no ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( yes ) <NEWLINE> <NL> <DEDENT> for i , x in enumerate ( res_list ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> print ( x + 1 ) <NEWLINE> <DEDENT>
import datetime <NEWLINE> y1 , m1 , d1 , y2 , m2 , d2 = map ( int , input ( ) . split ( ) ) <NEWLINE> qq , y1 = divmod ( y1 , 400 ) <NEWLINE> y1 += 400 <NEWLINE> qq -= 1 <NEWLINE> q = ( y2 - y1 ) // 400 <NEWLINE> y2 -= 400 * q <NEWLINE> a = 688 * ( q - qq ) <NEWLINE> d = datetime . date ( y1 , m1 , d1 ) <NEWLINE> while d <= datetime . date ( y2 , m2 , d2 ) : <NEWLINE> <INDENT> if d . day == 13 and d . weekday ( ) == 4 : a += 1 <NEWLINE> d += datetime . timedelta ( days = 1 ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> out = 0 <NEWLINE> for X in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> Y = N // X <NEWLINE> out += Y * ( Y + 1 ) * X / 2 <NEWLINE> <DEDENT> print ( int ( out ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> rs = [ i ** 5 for i in range ( 300 ) ] <NEWLINE> <NL> for r in rs : <NEWLINE> <INDENT> if r <= x : <NEWLINE> <INDENT> if x - r in rs : <NEWLINE> <INDENT> print ( rs . index ( r ) , - rs . index ( x - r ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if r > x : <NEWLINE> <INDENT> if r - x in rs : <NEWLINE> <INDENT> print ( rs . index ( r ) , rs . index ( r - x ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> r = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> ans = r * b * g <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for s in range ( N ) : <NEWLINE> <INDENT> j = i + s <NEWLINE> k = j + s <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
sentinel = 1000000001 <NEWLINE> <NL> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> L = A [ left : mid ] <NEWLINE> n1 = len ( L ) <NEWLINE> L . append ( sentinel ) <NEWLINE> R = A [ mid : right ] <NEWLINE> R . append ( sentinel ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> global cnt <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> cnt += ( n1 - i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> mergeSort ( S , 0 , n ) <NEWLINE> <NL> print ( cnt ) <NEWLINE>
<NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mflg = [ - 1 ] * m <NEWLINE> mflg [ x ] = 0 <NEWLINE> ltot = [ x ] <NEWLINE> <NL> tot = x <NEWLINE> a = x <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a = a ** 2 % m <NEWLINE> <NL> if mflg [ a ] >= 0 : <NEWLINE> <INDENT> b = mflg [ a ] <NEWLINE> z = ( n - i ) // ( i - b ) <NEWLINE> y = ( n - i ) % ( i - b ) <NEWLINE> if b == 0 and y == 0 : <NEWLINE> <INDENT> tot += ltot [ i - 1 ] * z <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> tot += ltot [ b - 1 + y ] + ltot [ i - 1 ] * z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tot += ( ltot [ b - 1 + y ] - ltot [ b - 1 ] ) + ( ltot [ i - 1 ] - ltot [ b - 1 ] ) * z <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> mflg [ a ] = i <NEWLINE> tot += a <NEWLINE> ltot . append ( tot ) <NEWLINE> <NL> <DEDENT> print ( tot ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] < a [ k + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def fact ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> a = int ( input ( ) ) <NEWLINE> li = [ ] <NEWLINE> li = fact ( a ) <NEWLINE> count = 0 <NEWLINE> i = 0 <NEWLINE> dif = 1 <NEWLINE> <NL> while i < len ( li ) : <NEWLINE> <INDENT> if a == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if li [ i ] [ 1 ] >= dif : <NEWLINE> <INDENT> count += 1 <NEWLINE> li [ i ] [ 1 ] -= dif <NEWLINE> dif += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dif = 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> x = input ( ) <NEWLINE> while <STRING> in x : <NEWLINE> <INDENT> x = x . replace ( <STRING> , <STRING> ) <NEWLINE> <COMMENT> <NL> n = len ( x ) // 2 <NEWLINE> if ( <STRING> not in x [ : n ] ) and ( <STRING> not in x [ n : ] ) : <NEWLINE> <INDENT> x = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( len ( x ) ) <NEWLINE>
from functools import lru_cache <NEWLINE> <NL> <NL> <NL> S = input ( ) <NEWLINE> count = [ 0 for i in range ( 2019 ) ] <NEWLINE> length = len ( S ) <NEWLINE> <COMMENT> <NL> S = S + <STRING> <NEWLINE> S = S [ : : - 1 ] <NEWLINE> _S = 0 <NEWLINE> <NL> base = 1 <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> _S = base * int ( s ) + _S <NEWLINE> count [ _S % 2019 ] += 1 <NEWLINE> base *= 10 <NEWLINE> base = base % 2019 <NEWLINE> _S = _S % 2019 <NEWLINE> <NL> <NL> <NL> <DEDENT> retval = 0 <NEWLINE> for key in range ( 2019 ) : <NEWLINE> <INDENT> retval += count [ key ] * ( count [ key ] - 1 ) // 2 <NEWLINE> <NL> <NL> <DEDENT> print ( retval ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> N , K = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> A_list = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> <NL> bit_k = bin ( K ) [ 2 : ] <NEWLINE> <NL> telepo_list = [ A_list ] <NEWLINE> <NL> for _ in range ( len ( bit_k ) - 1 ) : <NEWLINE> <INDENT> temp_list = telepo_list [ - 1 ] <NEWLINE> new_telep = [ temp_list [ i - 1 ] for i in temp_list ] <NEWLINE> telepo_list . append ( new_telep ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> goto = 1 <NEWLINE> for i in range ( len ( bit_k ) ) : <NEWLINE> <INDENT> temp_list = telepo_list [ i ] <NEWLINE> if ( ( K >> i ) & 1 ) : <NEWLINE> <INDENT> goto = temp_list [ goto - 1 ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( goto ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> <NL> low = 0 <NEWLINE> high = 10 ** 9 + 1 <NEWLINE> <NL> while high - low != 1 : <NEWLINE> <INDENT> mid = ( high + low ) // 2 <NEWLINE> cut_temp = 0 <NEWLINE> ans = - 1 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> cut_temp += - ( - a // mid ) - 1 <NEWLINE> <DEDENT> if cut_temp > K : <NEWLINE> <INDENT> low = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> high = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( high ) <NEWLINE>
import os <NEWLINE> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> IINF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> DIGIT = ( 10 ** 18 ) . bit_length ( ) <NEWLINE> <NL> <NL> def solve_f2 ( mat , last_col , rank ) : <NEWLINE> <COMMENT> <NL> <INDENT> for col in range ( last_col , mat . shape [ 1 ] - 1 ) : <NEWLINE> <INDENT> if rank >= DIGIT : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> last_col = col <NEWLINE> row = mat [ rank : , col ] . argmax ( ) + rank <NEWLINE> if not mat [ row , col ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> pivot = mat [ row ] . copy ( ) <NEWLINE> mat [ mat [ : , col ] ] ^= pivot <NEWLINE> mat [ row ] = mat [ rank ] <NEWLINE> mat [ rank ] = pivot <NEWLINE> rank += 1 <NEWLINE> <NL> <DEDENT> if rank < DIGIT and mat [ rank : ] . any ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> return False , last_col , rank <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True , last_col , rank <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solve ( N , A , S ) : <NEWLINE> <INDENT> if S [ - 1 ] == <STRING> : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> S = ( np . array ( list ( S ) , dtype = int ) == 1 ) [ : : - 1 ] <NEWLINE> A = np . array ( A , dtype = int ) [ : : - 1 ] <NEWLINE> <NL> a_mat = [ ] <NEWLINE> for d in reversed ( range ( DIGIT ) ) : <NEWLINE> <INDENT> a_mat . append ( A >> d & 1 ) <NEWLINE> <DEDENT> mat = np . array ( a_mat ) . astype ( bool ) <NEWLINE> <NL> rank = 0 <NEWLINE> for col in range ( N ) : <NEWLINE> <INDENT> if S [ col ] : <NEWLINE> <COMMENT> <NL> <INDENT> if mat [ rank : , col ] . any ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> if rank >= DIGIT : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> row = mat [ rank : , col ] . argmax ( ) + rank <NEWLINE> if not mat [ row , col ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> pivot = mat [ row ] . copy ( ) <NEWLINE> mat [ mat [ : , col ] ] ^= pivot <NEWLINE> mat [ row ] = mat [ rank ] <NEWLINE> mat [ rank ] = pivot <NEWLINE> rank += 1 <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> T = int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> for _ in range ( T ) : <NEWLINE> <INDENT> N = int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> A = list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> S = sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> ans = solve ( N , A , S ) <NEWLINE> print ( int ( ans ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> letter_counts = [ 0 ] * 26 <COMMENT> <NEWLINE> for line in sys . stdin : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> lower_text = line . lower ( ) <NEWLINE> <NL> <COMMENT> <NL> for c in lower_text : <NEWLINE> <INDENT> if <STRING> <= c <= <STRING> : <NEWLINE> <INDENT> letter_counts [ ord ( c ) - ord ( <STRING> ) ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for i , n in enumerate ( letter_counts ) : <NEWLINE> <INDENT> print ( <STRING> . format ( chr ( ord ( <STRING> ) + i ) , n ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans == 0 or ans > 1000000000000000000 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( ans > 1000000000000000000 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ip = [ 0 ] * n <NEWLINE> jm = dict ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ip [ i ] = i + a [ i ] <NEWLINE> if i - a [ i ] in jm : <NEWLINE> <INDENT> jm [ i - a [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> jm [ i - a [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> icnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ip [ i ] in jm : <NEWLINE> <INDENT> icnt += jm [ ip [ i ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( icnt ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 1 , K - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K ) : <NEWLINE> <INDENT> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> gcd_ij_1 = math . gcd ( i , j ) <NEWLINE> gcd_ijk_1 = math . gcd ( gcd_ij_1 , k ) <NEWLINE> ans = ans + gcd_ijk_1 * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for l in range ( 1 , K ) : <NEWLINE> <INDENT> for m in range ( l + 1 , K + 1 ) : <NEWLINE> <INDENT> gcd_lm_1 = math . gcd ( l , m ) <NEWLINE> ans = ans + gcd_lm_1 * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> for n in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans = ans + n <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = max ( A_list ) + 1 <NEWLINE> cnt = [ 0 for _ in range ( M ) ] <NEWLINE> <NL> for i in A_list : <NEWLINE> <INDENT> if cnt [ i ] != 0 : <NEWLINE> <INDENT> cnt [ i ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> for j in range ( i , M , i ) : cnt [ j ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for k in A_list : <NEWLINE> <INDENT> if cnt [ k ] == 1 : ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> a , b , c , d = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( math . sqrt ( ( ( c - a ) ** 2 ) + ( ( d - b ) ** 2 ) ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K - 1 , N - 1 ) : <NEWLINE> <INDENT> if A [ i - ( K - 1 ) ] < A [ i + 1 ] : <NEWLINE> <NL> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> A , B , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = int ( ) <NEWLINE> if B - 1 > N : <NEWLINE> <INDENT> i = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = B - 1 <NEWLINE> <DEDENT> c = math . floor ( A * i / B ) - ( A * math . floor ( i / B ) ) <NEWLINE> <NL> print ( c ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> input = sys . stdin . readline <NEWLINE> S = list ( input ( ) . rstrip ( ) ) <NEWLINE> S = deque ( S ) <NEWLINE> input ( ) <NEWLINE> rev = 0 <NEWLINE> for line in readlines ( ) : <NEWLINE> <INDENT> q , * query , = line . split ( ) <NEWLINE> if q == <STRING> : <NEWLINE> <INDENT> rev ^= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f , c = query <NEWLINE> if f == <STRING> : <NEWLINE> <INDENT> if not rev : <NEWLINE> <INDENT> S . appendleft ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . append ( c ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if not rev : <NEWLINE> <INDENT> S . append ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . appendleft ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( S ) if not rev else <STRING> . join ( S ) [ : : - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> zero = A . count ( 0 ) <NEWLINE> one = A . count ( 1 ) <NEWLINE> <NL> if zero >= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif ( N - one ) > 100 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> a = max ( A ) <NEWLINE> prime_num = [ 2 ] <NEWLINE> sgn = [ 0 for _ in range ( max ( int ( a ** 0.5 ) + 1 , 4 ) ) ] <NEWLINE> sgn [ 2 ] = 1 <NEWLINE> for k in range ( 3 , len ( sgn ) , 2 ) : <NEWLINE> <INDENT> if sgn [ k ] == 0 : <NEWLINE> <INDENT> prime_num . append ( k ) <NEWLINE> for j in range ( k , a + 1 , k ** 2 ) : <NEWLINE> <INDENT> sgn [ k ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> baisu = [ ] <NEWLINE> count = [ 0 for _ in range ( a + 1 ) ] <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> b = 0 + A [ k ] <NEWLINE> for p in prime_num : <NEWLINE> <INDENT> if p ** 2 <= b : <NEWLINE> <INDENT> if b % p == 0 : <NEWLINE> <INDENT> if count [ p ] == 0 : <NEWLINE> <INDENT> baisu . append ( p ) <NEWLINE> <DEDENT> c = 0 <NEWLINE> while b % p == 0 : <NEWLINE> <INDENT> b //= p <NEWLINE> c += 1 <NEWLINE> <DEDENT> if c > count [ p ] : <NEWLINE> <INDENT> count [ p ] = c <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if b != 1 : <NEWLINE> <INDENT> if count [ b ] == 0 : <NEWLINE> <INDENT> count [ b ] = 1 <NEWLINE> baisu . append ( b ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> product = 1 <NEWLINE> for item in baisu : <NEWLINE> <INDENT> product *= pow ( item , count [ item ] , mod ) <NEWLINE> product %= mod <NEWLINE> <NL> <DEDENT> b = mod - 2 <NEWLINE> blis = [ ] <NEWLINE> c = 0 <NEWLINE> while b > 0 : <NEWLINE> <INDENT> if b & 1 == 1 : <NEWLINE> <INDENT> blis . append ( c ) <NEWLINE> <DEDENT> c += 1 <NEWLINE> b >>= 1 <NEWLINE> <NL> <DEDENT> def modinv ( a ) : <NEWLINE> <INDENT> if a == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = 1 <NEWLINE> li = [ ] <NEWLINE> for _ in range ( c ) : <NEWLINE> <INDENT> li . append ( a % mod ) <NEWLINE> a = a * a % mod <NEWLINE> <DEDENT> for item in blis : <NEWLINE> <INDENT> res = res * li [ item ] % mod <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> ans += product * modinv ( A [ k ] ) <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> <NL> ab_list = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> ans_list = uf . roots ( ) <NEWLINE> for i in range ( len ( ans_list ) ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( ans_list [ i ] ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> check = [ 0 ] * n <NEWLINE> for i in li : <NEWLINE> <INDENT> check [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( check [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def dfs ( l , r ) : <NEWLINE> <NL> <INDENT> if l == r : <NEWLINE> <INDENT> return A [ l ] <NEWLINE> <DEDENT> mid = ( l + r ) // 2 <NEWLINE> ans = 1 <NEWLINE> ans = ans * dfs ( l , mid ) <NEWLINE> ans = ans * dfs ( mid + 1 , r ) <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> ans = dfs ( 0 , len ( A ) - 1 ) <NEWLINE> <NL> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> Ms = [ ] <NEWLINE> <NL> h_scores = [ 0 for i in range ( h ) ] <NEWLINE> w_scores = [ 0 for i in range ( w ) ] <NEWLINE> <NL> record = set ( ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> record . add ( ( h - 1 , w - 1 ) ) <NEWLINE> h_scores [ h - 1 ] += 1 <NEWLINE> w_scores [ w - 1 ] += 1 <NEWLINE> <NL> <DEDENT> max_h = max ( h_scores ) <NEWLINE> max_w = max ( w_scores ) <NEWLINE> max_h_poss = [ i for i , v in enumerate ( h_scores ) if v == max_h ] <NEWLINE> max_w_poss = [ i for i , v in enumerate ( w_scores ) if v == max_w ] <NEWLINE> <NL> out_pos_count = 0 <NEWLINE> <NL> c = False <NEWLINE> <NL> for i in max_h_poss : <NEWLINE> <INDENT> for j in max_w_poss : <NEWLINE> <INDENT> if ( i , j ) not in record : <NEWLINE> <INDENT> c = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if c : <NEWLINE> <INDENT> print ( max ( h_scores ) + max ( w_scores ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( h_scores ) + max ( w_scores ) - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> res *= a [ i ] <NEWLINE> <NL> if a [ i ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if res > 10 ** 18 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> K = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> S = sum ( K ) <NEWLINE> total = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S -= K [ i ] <NEWLINE> total += K [ i ] * S <NEWLINE> <DEDENT> print ( total % ( 10 ** 9 + 7 ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> ans = list ( ) <NEWLINE> r = 0 <NEWLINE> alp = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> d = - 1 <NEWLINE> <NL> <NL> while N > 26 ** count + d : <NEWLINE> <INDENT> count += 1 <NEWLINE> d = 26 ** ( count - 1 ) + d <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> count = count - 1 <NEWLINE> count2 = count <NEWLINE> <NL> while count > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> N = N - 26 ** count <NEWLINE> <COMMENT> <NL> count = count - 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> N = N - 1 <NEWLINE> <COMMENT> <NL> A = 1 <NEWLINE> while N > 0 : <NEWLINE> <INDENT> A = N // 26 <NEWLINE> B = N % 26 <NEWLINE> <COMMENT> <NL> ans . append ( B ) <NEWLINE> <COMMENT> <NL> N = A <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> while len ( ans ) < count2 + 1 : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans . reverse ( ) <NEWLINE> <COMMENT> <NL> <NL> for i in range ( 0 , len ( ans ) ) : <NEWLINE> <INDENT> ans [ i ] = alp [ ans [ i ] ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if B - A <= 2 * ( K - 1 ) : <NEWLINE> <INDENT> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( A , A + K ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for j in range ( B - K + 1 , B + 1 ) : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT> <DEDENT>
from decimal import * <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> vec = [ Decimal ( input ( ) ) for i in range ( n ) ] <NEWLINE> vec25 = [ [ 0 for i in range ( 50 ) ] for i in range ( 50 ) ] <COMMENT> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( vec [ i ] * 1000000000 ) <NEWLINE> num2 = - 9 <NEWLINE> num5 = - 9 <NEWLINE> while a % 2 == 0 : <NEWLINE> <INDENT> a //= 2 <NEWLINE> num2 += 1 <NEWLINE> <DEDENT> while a % 5 == 0 : <NEWLINE> <INDENT> a //= 5 <NEWLINE> num5 += 1 <NEWLINE> <DEDENT> vec25 [ num2 ] [ num5 ] += 1 <NEWLINE> <DEDENT> for i in range ( - 9 , 40 ) : <NEWLINE> <INDENT> for j in range ( - 9 , 20 ) : <NEWLINE> <INDENT> for k in range ( max ( - 9 , - i ) , 40 ) : <NEWLINE> <INDENT> for l in range ( max ( - 9 , - j ) , 20 ) : <NEWLINE> <INDENT> if i + k >= 0 and j + l >= 0 : <NEWLINE> <INDENT> if i != k or j != l : <NEWLINE> <INDENT> ans += vec25 [ i ] [ j ] * vec25 [ k ] [ l ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += vec25 [ i ] [ j ] * ( vec25 [ i ] [ j ] - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans //= 2 <NEWLINE> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <NL> <DEDENT> sum = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> sum = sum + 6 * gcd ( i , j , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> sum = sum + 6 * math . gcd ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> sum = sum + K * ( K + 1 ) // 2 <NEWLINE> <NL> print ( sum ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i - k ] < a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> from math import ceil <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , k , * a = map ( int , read ( ) . split ( ) ) <NEWLINE> def isOK ( x ) : <NEWLINE> <INDENT> kaisu = 0 <NEWLINE> for ae in a : <NEWLINE> <INDENT> kaisu += ceil ( ae / x ) - 1 <NEWLINE> <DEDENT> if kaisu <= k : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> ng = 0 <NEWLINE> ok = max ( a ) <NEWLINE> while abs ( ok - ng ) > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if isOK ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> print ( ok ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> r = 26 <NEWLINE> count = 1 <NEWLINE> result = <STRING> <NEWLINE> moji = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> while a == 0 : <NEWLINE> <INDENT> if r < n : <NEWLINE> <INDENT> n -= r <NEWLINE> r *= 26 <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> <DEDENT> zenbu = 26 ** count <NEWLINE> <NL> def kaidan ( zenbu , n ) : <NEWLINE> <INDENT> global moji <NEWLINE> for i in range ( 26 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ( zenbu / 26 ) * i < n <= ( zenbu / 26 ) * ( i + 1 ) : <NEWLINE> <INDENT> return ( moji [ i ] , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for l in range ( count ) : <NEWLINE> <INDENT> kotae , s = kaidan ( zenbu / ( 26 ** l ) , n ) <NEWLINE> result += kotae <NEWLINE> n -= 26 ** ( count - l - 1 ) * s <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
import sys <NEWLINE> from bisect import bisect_right <NEWLINE> from itertools import chain , compress <NEWLINE> <NL> ub = 50000 <NEWLINE> is_prime = [ 0 , 0 , 1 , 1 ] + [ 0 ] * ( ub - 3 ) <NEWLINE> is_prime [ 5 : : 6 ] = is_prime [ 7 : : 6 ] = [ 1 ] * int ( ub / 6 ) <NEWLINE> primes = [ 2 , 3 ] <NEWLINE> append = primes . append <NEWLINE> <NL> for n in chain ( range ( 5 , ub , 6 ) , range ( 7 , ub , 6 ) ) : <NEWLINE> <INDENT> if is_prime [ n ] : <NEWLINE> <INDENT> append ( n ) <NEWLINE> is_prime [ n * 3 : : n * 2 ] = [ 0 ] * ( ( ub - n ) // ( n * 2 ) ) <NEWLINE> <DEDENT> <DEDENT> primes . sort ( ) <NEWLINE> <NL> for n in map ( int , sys . stdin ) : <NEWLINE> <INDENT> if not n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n % 2 : <NEWLINE> <INDENT> print ( is_prime [ n - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( [ 1 for p in primes [ : bisect_right ( primes , n / 2 ) ] if is_prime [ n - p ] ] ) ) <NEWLINE> <DEDENT> <DEDENT>
from sys import exit <NEWLINE> from itertools import product <NEWLINE> import numpy as np <NEWLINE> HWK , * sss = open ( 0 ) . read ( ) . splitlines ( ) <NEWLINE> H , W , K = map ( int , HWK . split ( ) ) <NEWLINE> sss = [ list ( map ( int , list ( ss ) ) ) for ss in sss ] <NEWLINE> sss = np . cumsum ( sss , axis = 0 ) <NEWLINE> <NL> if H == 1 or W == 1 : <NEWLINE> <INDENT> print ( 0 - - sss [ - 1 ] [ - 1 ] // K ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = float ( <STRING> ) <NEWLINE> for flgs in product ( [ False , True ] , repeat = H - 1 ) : <NEWLINE> <INDENT> cnt = sum ( flgs ) <NEWLINE> tsss = sss [ [ * flgs , True ] ] <NEWLINE> tsss = np . concatenate ( ( tsss [ : 1 ] , np . diff ( tsss , axis = 0 ) ) , axis = 0 ) . T <NEWLINE> <NL> tmp = 0 <NEWLINE> succ = True <NEWLINE> for cur in tsss : <NEWLINE> <INDENT> new = tmp + cur <NEWLINE> if new . max ( ) <= K : <NEWLINE> <INDENT> tmp = new <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cur . max ( ) > K : <NEWLINE> <INDENT> succ = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = cur <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if succ : <NEWLINE> <INDENT> ans = min ( ans , cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> _2K , _4K = 2 * K , 4 * K <NEWLINE> shape = ( _2K + 1 , _4K + 1 ) <COMMENT> <NEWLINE> Grd = np . zeros ( shape , dtype = <STRING> ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , y , c = input ( ) . split ( ) <NEWLINE> x , y = int ( x ) , int ( y ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> x , y = x % _2K , y % _2K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x , y = ( x + K ) % _2K , y % _2K <NEWLINE> <COMMENT> <NL> <DEDENT> if x >= K and y >= K : x -= K ; y -= K <NEWLINE> if x < K and y >= K : x += K ; y -= K <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> Grd [ y , x ] += 1 <NEWLINE> Grd [ y + K , x + K ] += 1 <NEWLINE> Grd [ y + K , x ] += - 1 <NEWLINE> Grd [ y , x + K ] += - 1 <NEWLINE> <DEDENT> del x , y , c <NEWLINE> <NL> <COMMENT> <NL> Grd = Grd . cumsum ( axis = 1 ) . cumsum ( axis = 0 ) <NEWLINE> <COMMENT> <NL> Grd = Grd [ : , : _2K ] + Grd [ : , _2K : _4K ] <NEWLINE> Grd = Grd [ : K , : ] + np . concatenate ( ( Grd [ K : _2K , K : _2K ] , Grd [ K : _2K , : K ] ) , axis = 1 ) <NEWLINE> <NL> ans = Grd . max ( ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> print ( line . rstrip ( ) [ : : - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> s = list ( input ( ) ) <NEWLINE> ls = len ( s ) <NEWLINE> T = [ 0 ] * ( ls + 1 ) <NEWLINE> modL = [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> pad = 1 <NEWLINE> <NL> for i in reversed ( range ( 0 , ls ) ) : <NEWLINE> <INDENT> T [ i ] = T [ i + 1 ] + int ( s [ i ] ) * pad <NEWLINE> modL . append ( T [ i ] % 2019 ) <NEWLINE> pad = pad * 10 % 2019 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for c in Counter ( modL ) . values ( ) : <NEWLINE> <INDENT> ans += c * ( c - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from heapq import heappush , heappop <NEWLINE> <NL> n , m , s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> u , v , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ u ] . append ( ( v , a , b ) ) <NEWLINE> G [ v ] . append ( ( u , a , b ) ) <NEWLINE> <NL> <NL> <DEDENT> def dijkstra ( start , mode ) : <NEWLINE> <INDENT> INF = 10 ** 15 <NEWLINE> dist = [ INF ] * ( n + 1 ) <NEWLINE> dist [ start ] = 0 <NEWLINE> q = [ ( 0 , start ) ] <NEWLINE> while q : <NEWLINE> <INDENT> d , v = heappop ( q ) <NEWLINE> if dist [ v ] < d : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for w , * a in G [ v ] : <NEWLINE> <INDENT> d1 = d + a [ mode ] <NEWLINE> if dist [ w ] > d1 : <NEWLINE> <INDENT> dist [ w ] = d1 <NEWLINE> heappush ( q , ( d1 , w ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dist <NEWLINE> <NL> <NL> <DEDENT> d1 = np . array ( dijkstra ( s , 0 ) ) <NEWLINE> d2 = np . array ( dijkstra ( t , 1 ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> d = [ ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> d . append ( d1 [ i ] + d2 [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> ans = [ ] <NEWLINE> B = 10 ** 15 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> B = min ( B , d [ n - i ] ) <NEWLINE> ans . append ( B ) <NEWLINE> <DEDENT> ans = ans [ : : - 1 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( 10 ** 15 - ans [ i ] ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> from collections import deque <NEWLINE> <NL> X = int ( input ( ) ) <NEWLINE> s = { } <NEWLINE> q = deque ( ) <NEWLINE> q . append ( ( 1 , 0 ) ) <NEWLINE> done = { ( 1 , 0 ) } <NEWLINE> <NL> while True : <NEWLINE> <INDENT> ab = q . popleft ( ) <NEWLINE> tx = ab [ 0 ] ** 5 - ab [ 1 ] ** 5 <NEWLINE> <COMMENT> <NL> if ( tx == X ) : <NEWLINE> <INDENT> print ( ab [ 0 ] , ab [ 1 ] ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> elif ( tx > X ) : <NEWLINE> <INDENT> if ( ( ab [ 0 ] - 1 , ab [ 1 ] ) not in done ) : <NEWLINE> <INDENT> q . append ( ( ab [ 0 ] - 1 , ab [ 1 ] ) ) <NEWLINE> done . add ( ( ab [ 0 ] - 1 , ab [ 1 ] ) ) <NEWLINE> <DEDENT> if ( ab [ 1 ] > 0 or ( ab [ 0 ] , ab [ 1 ] + 1 ) not in done ) : <NEWLINE> <INDENT> q . append ( ( ab [ 0 ] , ab [ 1 ] + 1 ) ) <NEWLINE> done . add ( ( ab [ 0 ] , ab [ 1 ] + 1 ) ) <NEWLINE> <DEDENT> if ( ab [ 1 ] <= 0 or ( ab [ 0 ] , ab [ 1 ] - 1 ) not in done ) : <NEWLINE> <INDENT> q . append ( ( ab [ 0 ] , ab [ 1 ] - 1 ) ) <NEWLINE> done . add ( ( ab [ 0 ] , ab [ 1 ] - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( ( ab [ 0 ] + 1 , ab [ 1 ] ) not in done ) : <NEWLINE> <INDENT> q . append ( ( ab [ 0 ] + 1 , ab [ 1 ] ) ) <NEWLINE> done . add ( ( ab [ 0 ] + 1 , ab [ 1 ] ) ) <NEWLINE> <DEDENT> if ( ab [ 1 ] <= 0 or ( ab [ 0 ] , ab [ 1 ] - 1 ) not in done ) : <NEWLINE> <INDENT> q . append ( ( ab [ 0 ] , ab [ 1 ] - 1 ) ) <NEWLINE> done . add ( ( ab [ 0 ] , ab [ 1 ] - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = 7 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> if S % K == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = S % K <NEWLINE> S = S * 10 + 7 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r , g , b = set ( ) , set ( ) , set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . add ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g . add ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . add ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = len ( r ) * len ( b ) * len ( g ) <NEWLINE> for i in r : <NEWLINE> <INDENT> for j in g : <NEWLINE> <INDENT> chk = j - i <NEWLINE> if chk + j in b : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if i - chk in b : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if ( i + j ) / 2 in b : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> x = 0 <NEWLINE> M = N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if i == M - 1 - j : <NEWLINE> <INDENT> M = i <NEWLINE> break <NEWLINE> <DEDENT> elif c [ M - 1 - j ] == <STRING> : <NEWLINE> <INDENT> x += 1 <NEWLINE> c [ M - 1 - j ] = <STRING> <NEWLINE> M = M - j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if i == M : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
from collections import defaultdict <NEWLINE> from math import gcd <NEWLINE> import time <NEWLINE> import sys <NEWLINE> from collections import Counter <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> start = time . time ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> big = 0 <NEWLINE> s = 2 ** N <NEWLINE> l = [ ] <NEWLINE> <NL> moto = list ( range ( 1 , Q + 1 ) ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> AA = [ ] <NEWLINE> if A : <NEWLINE> <INDENT> for k in A : <NEWLINE> <INDENT> for j in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if k [ - 1 ] <= j : <NEWLINE> <INDENT> AA . append ( k + [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> A = AA <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> A . append ( [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in A : <NEWLINE> <INDENT> wa = 0 <NEWLINE> for j in l : <NEWLINE> <INDENT> if ( i [ j [ 1 ] - 1 ] - i [ j [ 0 ] - 1 ] ) == j [ 2 ] : <NEWLINE> <INDENT> wa += j [ 3 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if big < wa : <NEWLINE> <INDENT> big = wa <NEWLINE> <DEDENT> <DEDENT> print ( big ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> a = 0 <NEWLINE> b = 0 <NEWLINE> flg = True <NEWLINE> <NL> while True : <NEWLINE> <INDENT> a += 1 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if a ** 5 - i ** 5 == x : <NEWLINE> <INDENT> a = a <NEWLINE> b = i <NEWLINE> flg = False <NEWLINE> break <NEWLINE> <DEDENT> elif a ** 5 + i ** 5 == x : <NEWLINE> <INDENT> a = a <NEWLINE> b = - i <NEWLINE> flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg == False : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> a = str ( a ) <NEWLINE> b = str ( b ) <NEWLINE> print ( a + <STRING> + b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> listn = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> min1 = listn [ 0 ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if ( listn [ i ] > min1 ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min1 = listn [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import itertools <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> cnt = [ 0 for _ in range ( 5 ) ] <NEWLINE> for s in S : <NEWLINE> <INDENT> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt [ 0 ] += 1 <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt [ 1 ] += 1 <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt [ 2 ] += 1 <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt [ 3 ] += 1 <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt [ 4 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i , j , k in itertools . combinations ( cnt , r = 3 ) : <NEWLINE> <INDENT> ans += i * j * k <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> while n > 0 : <NEWLINE> <INDENT> re = n % 26 <NEWLINE> if re != 0 : <NEWLINE> <INDENT> ans = chr ( ord ( <STRING> ) + ( re - 1 ) ) + ans <NEWLINE> n = n // 26 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> + ans ; <NEWLINE> n = n // 26 - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> r = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> a = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> b = math . gcd ( a , k ) <NEWLINE> r += b <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> ans = 10 ** 7 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> sw = [ 0 ] * m <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> count += a [ j ] [ 0 ] <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> sw [ k ] += a [ j ] [ k + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> q = 1 <NEWLINE> for L in range ( m ) : <NEWLINE> <INDENT> if sw [ L ] < x : <NEWLINE> <INDENT> q = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if q == 1 : <NEWLINE> <INDENT> ans = min ( ans , count ) <NEWLINE> <DEDENT> <DEDENT> if ans == 10 ** 7 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LLI ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> n = I ( ) <NEWLINE> li = LI ( ) <NEWLINE> ans = 1 <NEWLINE> if 0 in li : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in li : <NEWLINE> <INDENT> ans *= k <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 5 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ i - 1 ] = i <NEWLINE> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE> <NL>
<COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lst = [ 1 for i in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ A - 1 ] <= H [ B - 1 ] : <NEWLINE> <INDENT> lst [ A - 1 ] = 0 <NEWLINE> <DEDENT> if H [ B - 1 ] <= H [ A - 1 ] : <NEWLINE> <INDENT> lst [ B - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( lst ) ) <NEWLINE> <NL> <NL>
x = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> <NL> for i in range ( 1000 ) : <NEWLINE> <INDENT> for j in range ( 1 , 1000 ) : <NEWLINE> <INDENT> tmp = ( i * i * i * i * i ) + ( j * j * j * j * j ) <NEWLINE> if x == tmp : <NEWLINE> <INDENT> a = i <NEWLINE> b = - j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1000 ) : <NEWLINE> <INDENT> for j in range ( 1 , 1000 ) : <NEWLINE> <INDENT> tmp = ( i * i * i * i * i ) - ( j * j * j * j * j ) <NEWLINE> if x == tmp : <NEWLINE> <INDENT> a = i <NEWLINE> b = j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = 1 <NEWLINE> if k <= n : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> p = a [ p - 1 ] <NEWLINE> <DEDENT> print ( p ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> t = [ - 1 ] * n <NEWLINE> t [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> p = a [ p - 1 ] <NEWLINE> if t [ p - 1 ] != - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t [ p - 1 ] = i <NEWLINE> <NL> <DEDENT> d = i - t [ p - 1 ] <NEWLINE> k -= i <NEWLINE> k %= d <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> p = a [ p - 1 ] <NEWLINE> <DEDENT> print ( p ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <STRING> <NEWLINE> A = sorted ( A ) <NEWLINE> <NL> ans = 1 <NEWLINE> for x in A : <NEWLINE> <INDENT> ans *= x <NEWLINE> if ans == 0 or ans > 1.0e+18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if ans > 1.0e+18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> print ( <STRING> if a [ i ] > a [ i - k ] else <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> path = [ 1 ] <NEWLINE> dic = [ 0 ] * n <NEWLINE> dic [ 0 ] = 1 <NEWLINE> current = 0 <NEWLINE> looping = False <NEWLINE> loop_st = - 1 <NEWLINE> loop_ed = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> _next = a [ current ] <NEWLINE> if dic [ _next - 1 ] == 1 : <NEWLINE> <INDENT> loop_st = path . index ( _next ) <NEWLINE> loop_ed = len ( path ) <NEWLINE> looping = True <NEWLINE> break <NEWLINE> <DEDENT> dic [ _next - 1 ] = 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> path . append ( _next ) <NEWLINE> current = _next - 1 <NEWLINE> <NL> <DEDENT> if looping : <NEWLINE> <INDENT> if loop_ed - 1 >= k : <NEWLINE> <INDENT> print ( path [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> len_loop = loop_ed - loop_st <NEWLINE> z = ( k - loop_st ) % len_loop <NEWLINE> print ( path [ loop_st + z ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( path [ k ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n , c , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> t = sorted ( [ int ( input ( ) ) for i in range ( n ) ] ) <NEWLINE> total = 0 <NEWLINE> count = 0 <NEWLINE> while ( count != n ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> <COMMENT> <NL> for i in range ( c ) : <NEWLINE> <INDENT> if count + i >= n : <NEWLINE> <COMMENT> <NL> <INDENT> if t [ - 1 ] - t [ count ] <= k : <NEWLINE> <COMMENT> <NL> <INDENT> count = n <NEWLINE> total += 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = 0 <NEWLINE> while ( count != n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if t [ count + temp ] - t [ count ] <= k : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += temp + 1 <NEWLINE> total += 1 <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> if t [ count + i ] - t [ count ] > k : <NEWLINE> <COMMENT> <NL> <INDENT> count += i <NEWLINE> total += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> count += c <NEWLINE> total += 1 <NEWLINE> if count == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> A . sort ( ) <NEWLINE> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans <= 10 ** 18 and ans != 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D . sort ( ) <NEWLINE> <NL> M = N // 2 <NEWLINE> ans = D [ M ] - D [ M - 1 ] <NEWLINE> <NL> if D [ M ] == D [ M - 1 ] : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> from numba import jit <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = np . array ( a , dtype = <STRING> ) <NEWLINE> <NL> @ jit <NEWLINE> def imo ( a ) : <NEWLINE> <INDENT> imos = np . zeros ( n + 1 , dtype = <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> imos [ max ( 0 , i - a [ i ] ) ] += 1 <NEWLINE> imos [ min ( n , i + a [ i ] + 1 ) ] -= 1 <NEWLINE> <NL> <DEDENT> immo = np . zeros ( n + 1 , dtype = <STRING> ) <NEWLINE> immo = np . cumsum ( imos ) <NEWLINE> return immo [ : n ] <NEWLINE> <NL> <NL> <DEDENT> for _ in range ( min ( k , 41 ) ) : <NEWLINE> <INDENT> a = imo ( a ) <NEWLINE> <NL> <DEDENT> print ( * a ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans_ = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( ans_ , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> x = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> xi = math . floor ( x / 5.5 ) <NEWLINE> <COMMENT> <NL> for i in range ( xi , 10000000000000000000000000000 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ( x <= 6 * i - math . floor ( i / 2 ) ) : <NEWLINE> <INDENT> xa = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( xa ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> if N % 2 == 0 : <NEWLINE> <INDENT> for i in range ( ( N + 2 ) // 2 - 1 ) : <NEWLINE> <INDENT> if A [ 2 * i ] % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( ( N + 2 ) // 2 ) : <NEWLINE> <INDENT> if A [ 2 * i ] % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> a = float ( input ( ) ) <NEWLINE> print ( str ( <STRING> . format ( ( a * a ) * math . pi ) ) + <STRING> + str ( <STRING> . format ( ( a + a ) * math . pi ) ) ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> t = input ( ) <NEWLINE> if <STRING> in t : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( int ( eval ( t ) ) ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> import numpy as np <NEWLINE> import numba <NEWLINE> import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> @ numba . jit <NEWLINE> def main ( n ) : <NEWLINE> <INDENT> lis = np . zeros ( ( n , n , n ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> for k in range ( n ) : <NEWLINE> <INDENT> lis [ i ] [ j ] [ k ] = math . gcd ( math . gcd ( i + 1 , j + 1 ) , k + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return int ( np . sum ( lis ) ) <NEWLINE> <NL> <DEDENT> print ( main ( n ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> from collections import Counter <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> j_Aj = Counter ( [ j - Aj for j , Aj in enumerate ( A , start = 1 ) ] ) <NEWLINE> ans = 0 <NEWLINE> for i , a in enumerate ( A [ : - 1 ] , start = 1 ) : <NEWLINE> <INDENT> if a > N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += j_Aj [ a + i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> number = int ( input ( ) ) <NEWLINE> numcount = defaultdict ( int ) <NEWLINE> for x in input ( ) . split ( ) : <NEWLINE> <INDENT> numcount [ int ( x ) ] += 1 <NEWLINE> <DEDENT> queries = int ( input ( ) ) <NEWLINE> ans = sum ( num * count for num , count in numcount . items ( ) ) <NEWLINE> for _ in range ( queries ) : <NEWLINE> <INDENT> before , after = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> tmp = numcount [ before ] <NEWLINE> numcount [ before ] -= tmp <NEWLINE> numcount [ after ] += tmp <NEWLINE> ans += ( after - before ) * tmp <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = [ 0 ] * n <NEWLINE> y = [ 0 ] * n <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x [ i ] = a <NEWLINE> y [ i ] = b <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( x [ i ] + ans ) % y [ i ] != 0 : <NEWLINE> <INDENT> ans += y [ i ] - ( x [ i ] + ans ) % y [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> t = [ 0 ] * 2019 <NEWLINE> t [ 0 ] = 1 <NEWLINE> d = 1 <NEWLINE> tkk = 0 <NEWLINE> for k in reversed ( range ( n ) ) : <NEWLINE> <INDENT> tk = tkk + int ( s [ k ] ) * d <NEWLINE> tk = tk % 2019 <NEWLINE> t [ tk ] = t [ tk ] + 1 <NEWLINE> tkk = tk <NEWLINE> d = d * 10 <NEWLINE> d = d % 2019 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in t : <NEWLINE> <INDENT> ans = ans + i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_a = sum ( A ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> sum_a -= A [ i ] <NEWLINE> ans += A [ i ] * sum_a <NEWLINE> ans = ans % ( int ( 1e9 + 7 ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def i ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> S = s ( ) <NEWLINE> N = len ( S ) <NEWLINE> num = 1 <NEWLINE> num2 = 1 <NEWLINE> ans = 0 <NEWLINE> Flag = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == S [ i + 1 ] : <NEWLINE> <INDENT> ans += num <NEWLINE> num += 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += max ( num , num2 ) <NEWLINE> num = 1 <NEWLINE> Flag = 0 <NEWLINE> <DEDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> num2 = num <NEWLINE> num = 1 <NEWLINE> Flag = 1 <NEWLINE> <DEDENT> <DEDENT> if Flag : <NEWLINE> <INDENT> ans += max ( num2 , num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += num <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> def debug ( x , table ) : <NEWLINE> <INDENT> for name , val in table . items ( ) : <NEWLINE> <INDENT> if x is val : <NEWLINE> <INDENT> print ( <STRING> . format ( name , val ) , file = sys . stderr ) <NEWLINE> return None <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def paint_col ( adj , cols , i , col ) : <NEWLINE> <INDENT> nxt = deque ( [ i ] ) <NEWLINE> <NL> while nxt : <NEWLINE> <INDENT> u = nxt . popleft ( ) <NEWLINE> cols [ u ] = col <NEWLINE> for child in adj [ u ] : <NEWLINE> <INDENT> if cols [ child ] == 0 : <NEWLINE> <INDENT> nxt . append ( child ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> adj = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> adj [ s ] . append ( t ) <NEWLINE> adj [ t ] . append ( s ) <NEWLINE> <NL> <DEDENT> cols = [ 0 ] * n <NEWLINE> col = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if cols [ i ] == 0 : <NEWLINE> <INDENT> paint_col ( adj , cols , i , col ) <NEWLINE> col += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if cols [ s ] == cols [ t ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
w = sorted ( input ( ) ) <NEWLINE> total = False <NEWLINE> if len ( w ) == 1 : <NEWLINE> <INDENT> total = True <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , len ( w ) , 2 ) : <NEWLINE> <INDENT> if w [ i ] != w [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> total = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if total == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> num_lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c1 = True <NEWLINE> c2 = True <NEWLINE> <NL> def osa_k ( max_num ) : <NEWLINE> <INDENT> lis = [ i for i in range ( max_num + 1 ) ] <NEWLINE> p = 2 <NEWLINE> while p ** 2 <= max_num : <NEWLINE> <INDENT> if lis [ p ] == p : <NEWLINE> <INDENT> for q in range ( 2 * p , max_num + 1 , p ) : <NEWLINE> <INDENT> if lis [ q ] == q : <NEWLINE> <INDENT> lis [ q ] = p <NEWLINE> <DEDENT> <DEDENT> <DEDENT> p += 1 <NEWLINE> <DEDENT> return lis <NEWLINE> <NL> <DEDENT> hoge = 0 <NEWLINE> for i in num_lis : <NEWLINE> <INDENT> hoge = gcd ( hoge , i ) <NEWLINE> <DEDENT> if hoge > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> d_lis = osa_k ( max ( num_lis ) ) <NEWLINE> tmp = set ( ) <NEWLINE> for i in num_lis : <NEWLINE> <INDENT> num = i <NEWLINE> new_tmp = set ( ) <NEWLINE> while num > 1 : <NEWLINE> <INDENT> d = d_lis [ num ] <NEWLINE> new_tmp . add ( d ) <NEWLINE> num //= d <NEWLINE> <DEDENT> for j in new_tmp : <NEWLINE> <INDENT> if j in tmp : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp . add ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def solve ( N : int , S : <STRING> ) : <NEWLINE> <NL> <INDENT> S = set ( S ) <NEWLINE> <NL> print ( len ( S ) ) <NEWLINE> <NL> return <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> S = [ next ( tokens ) for _ in range ( N ) ] <COMMENT> <NEWLINE> solve ( N , S ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = map ( str , input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( <STRING> . format ( a + b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( <STRING> . format ( a - b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( <STRING> . format ( a * b ) ) <NEWLINE> <DEDENT> else : print ( <STRING> . format ( int ( a / b ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for a in alist : <NEWLINE> <INDENT> ans = ans * a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if 0 in alist : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> all_xor = 0 <NEWLINE> for a in a_array : <NEWLINE> <INDENT> all_xor ^= a <NEWLINE> <DEDENT> print ( <STRING> . join ( [ str ( all_xor ^ a ) for a in a_array ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ 0 for _ in range ( n ) ] <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> c [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for j in range ( len ( c ) ) : <NEWLINE> <INDENT> print ( c [ j ] ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> plus = [ ] <NEWLINE> minus = [ ] <NEWLINE> for a in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> if a >= 0 : <NEWLINE> <INDENT> plus . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus . append ( a ) <NEWLINE> <DEDENT> <DEDENT> ans = sum ( plus ) - sum ( minus ) <NEWLINE> if len ( minus ) % 2 == 1 : <NEWLINE> <INDENT> if plus == [ ] : <NEWLINE> <INDENT> ans = ans + 2 * max ( minus ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans - 2 * min ( abs ( max ( minus ) ) , min ( plus ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = Counter ( data ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans = count [ i ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
from __future__ import division , print_function <NEWLINE> import sys <NEWLINE> from collections import deque <NEWLINE> INFTY = 1 << 30 <NEWLINE> a = [ None ] * 2000001 <NEWLINE> h = 0 <NEWLINE> ret = deque ( [ ] ) <NEWLINE> <NL> def maxHeapify ( i ) : <NEWLINE> <INDENT> global a , h <NEWLINE> l = 2 * i <NEWLINE> r = 2 * i + 1 <NEWLINE> if l <= h and a [ l ] > a [ i ] : <NEWLINE> <INDENT> largest = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest = i <NEWLINE> <DEDENT> if r <= h and a [ r ] > a [ largest ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <DEDENT> if largest != i : <NEWLINE> <INDENT> a [ i ] , a [ largest ] = a [ largest ] , a [ i ] <NEWLINE> maxHeapify ( largest ) <NEWLINE> <NL> <DEDENT> <DEDENT> def extract ( ) : <NEWLINE> <INDENT> global a , h <NEWLINE> if h < 1 : <NEWLINE> <INDENT> return - INFTY <NEWLINE> <DEDENT> maxv = a [ 1 ] <NEWLINE> a [ 1 ] = a [ h ] <NEWLINE> h -= 1 <NEWLINE> maxHeapify ( 1 ) <NEWLINE> return maxv <NEWLINE> <NL> <DEDENT> def increaseKey ( i , k ) : <NEWLINE> <INDENT> global a <NEWLINE> if k < a [ i ] : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> a [ i ] = k <NEWLINE> while i > 1 and a [ i // 2 ] < a [ i ] : <NEWLINE> <INDENT> a [ i ] , a [ i // 2 ] = a [ i // 2 ] , a [ i ] <NEWLINE> i = i // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> def insert ( k ) : <NEWLINE> <INDENT> global a , h <NEWLINE> h += 1 <NEWLINE> a [ h ] = - INFTY <NEWLINE> increaseKey ( h , k ) <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> for com in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> if com [ 0 ] == <STRING> : <NEWLINE> <INDENT> insert ( int ( com [ 7 : ] ) ) <NEWLINE> <DEDENT> elif com [ 1 ] == <STRING> : <NEWLINE> <INDENT> ret . append ( extract ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout . writelines ( <STRING> . join ( [ str ( s ) for s in ret ] ) ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> mi = 2019 <NEWLINE> c = 0 <NEWLINE> <NL> for i in range ( l , r ) : <NEWLINE> <INDENT> a = ( i * i ) % 2019 <NEWLINE> for _ in range ( min ( r - l - c , 2019 ) ) : <NEWLINE> <INDENT> a = ( a + i ) % 2019 <NEWLINE> <NL> if a < mi : <NEWLINE> <INDENT> mi = a <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT> c += 1 <NEWLINE> <NL> <DEDENT> print ( mi ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> R = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> minv = float ( <STRING> ) <NEWLINE> maxv = - float ( <STRING> ) <NEWLINE> for r in R : <NEWLINE> <INDENT> maxv = max ( maxv , r - minv ) <NEWLINE> minv = min ( minv , r ) <NEWLINE> <DEDENT> print ( maxv ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import sys <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> from bisect import bisect_left <NEWLINE> <NL> def readString ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) <NEWLINE> <NL> <DEDENT> def readInteger ( ) : <NEWLINE> <INDENT> return int ( readString ( ) ) <NEWLINE> <NL> <DEDENT> def readStringSet ( n ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . split ( <STRING> ) [ : n ] <NEWLINE> <NL> <DEDENT> def readIntegerSet ( n ) : <NEWLINE> <INDENT> return list ( map ( int , readStringSet ( n ) ) ) <NEWLINE> <NL> <DEDENT> def readIntegerMatrix ( n , m ) : <NEWLINE> <INDENT> return reduce ( lambda acc , _ : acc + [ readIntegerSet ( m ) ] , range ( 0 , n ) , [ ] ) <NEWLINE> <NL> <DEDENT> def main ( N , A ) : <NEWLINE> <INDENT> M = pow ( 10 , 9 ) + 7 <NEWLINE> result = 0 <NEWLINE> S = sum ( A ) <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> S = S - A [ i ] <NEWLINE> result = ( result + A [ i ] * S ) % M <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _N = readInteger ( ) <NEWLINE> _A = readIntegerSet ( _N ) <NEWLINE> <NL> print ( main ( _N , _A ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <COMMENT> <NL> def calc ( x , y , z ) : <NEWLINE> <INDENT> return x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> i = calc ( x , y , z ) <NEWLINE> <NL> if i > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> gcd_a_b = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> gcd_a_b = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( gcd_a_b , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> [ h , w ] = map ( int , ( input ( ) . split ( ) ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( <STRING> * w + <STRING> ) * h ) <NEWLINE> <DEDENT> <DEDENT>
n , = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> def check ( x ) : <NEWLINE> <INDENT> for a in range ( 200 ) : <NEWLINE> <INDENT> b = a - x <NEWLINE> c = a ** 4 + a ** 3 * b + a ** 2 * b ** 2 + a * b ** 3 + b ** 4 <NEWLINE> d = x * c <NEWLINE> if d == n : <NEWLINE> <INDENT> return [ a , b ] <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> res = check ( i ) <NEWLINE> if res : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> r1 , r2 = res <NEWLINE> print ( r1 , r2 ) <NEWLINE>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> l = input ( ) <NEWLINE> l2 = [ ] <NEWLINE> for o in range ( len ( l ) ) : <NEWLINE> <INDENT> l2 . append ( l [ o ] ) <NEWLINE> <DEDENT> x . append ( l2 ) <NEWLINE> <DEDENT> n = 2 ** ( h + w ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> q = i <NEWLINE> num = [ 0 ] * ( h + w ) <NEWLINE> p = 0 <NEWLINE> while q > 0 : <NEWLINE> <INDENT> if q % 2 != 0 : <NEWLINE> <INDENT> num [ p ] = 1 <NEWLINE> <DEDENT> q = q // 2 <NEWLINE> p += 1 <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for tat in range ( h ) : <NEWLINE> <INDENT> if num [ tat ] == 0 : <NEWLINE> <INDENT> for yok in range ( w ) : <NEWLINE> <INDENT> if num [ yok + h ] == 0 and x [ tat ] [ yok ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if cnt == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<STRING> <NEWLINE> from sys import stdin <NEWLINE> <NL> n = int ( stdin . readline ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> ans = np . zeros ( int ( 1e+5 ) , dtype = int ) <NEWLINE> for x in range ( 1 , int ( N ** 0.5 + 1 ) ) : <NEWLINE> <INDENT> for y in range ( x , int ( ( N - x ** 2 ) ** 0.5 + 1 ) ) : <NEWLINE> <INDENT> for z in range ( y , int ( ( N - x ** 2 - y ** 2 ) ** 0.5 + 1 ) ) : <NEWLINE> <INDENT> n = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> num = len ( { x , y , z } ) <NEWLINE> if num == 1 : <NEWLINE> <INDENT> ans [ n ] += 1 <NEWLINE> <DEDENT> elif num == 2 : <NEWLINE> <INDENT> ans [ n ] += 3 <NEWLINE> <DEDENT> elif num == 3 : <NEWLINE> <INDENT> ans [ n ] += 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from bisect import bisect_right <NEWLINE> <NL> n , * L = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> L . sort ( ) <NEWLINE> ans = 0 <NEWLINE> c = [ 0 ] * ( 2 * 10 ** 3 + 1 ) <NEWLINE> for i in range ( 2 * 10 ** 3 + 1 ) : <NEWLINE> <INDENT> c [ i ] = bisect_right ( L , i ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> ans += c [ L [ i ] + L [ j ] - 1 ] - c [ L [ j ] - L [ i ] ] - 1 - ( L [ j ] - L [ i ] * 2 < 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans // 3 ) <NEWLINE>
<NL> <NL> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Hmax_temp = [ 0 ] * ( H + 1 ) <NEWLINE> Wmax_temp = [ 0 ] * ( W + 1 ) <NEWLINE> Hmax = 0 <NEWLINE> Wmax = 0 <NEWLINE> Bomb = dict ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> H_M , W_M = map ( int , input ( ) . split ( ) ) <NEWLINE> Hmax_temp [ H_M ] += 1 <NEWLINE> Wmax_temp [ W_M ] += 1 <NEWLINE> Bomb [ ( H_M , W_M ) ] = 1 <NEWLINE> <NL> <DEDENT> Hmax = max ( Hmax_temp ) <NEWLINE> Wmax = max ( Wmax_temp ) <NEWLINE> <NL> <COMMENT> <NL> y_max = [ ] <NEWLINE> for i in range ( H + 1 ) : <NEWLINE> <INDENT> if Hmax == Hmax_temp [ i ] : <NEWLINE> <INDENT> y_max . append ( i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> x_max = [ ] <NEWLINE> for j in range ( W + 1 ) : <NEWLINE> <INDENT> if Wmax == Wmax_temp [ j ] : <NEWLINE> <INDENT> x_max . append ( j ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> flag = False <NEWLINE> for i in y_max : <NEWLINE> <INDENT> for j in x_max : <NEWLINE> <INDENT> if ( i , j ) not in Bomb : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> ans = Wmax + Hmax <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = Wmax + Hmax - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
data = [ <NEWLINE> <INDENT> [ [ 0 for k in range ( 10 ) ] for j in range ( 3 ) ] for i in range ( 4 ) <NEWLINE> ] <NEWLINE> <NL> <DEDENT> count = int ( input ( ) ) <NEWLINE> <NL> for x in range ( count ) : <NEWLINE> <INDENT> ( b , f , r , v ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> data [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> for r in range ( 10 ) : <NEWLINE> <INDENT> if r == 9 : <NEWLINE> <INDENT> print ( data [ b ] [ f ] [ r ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( data [ b ] [ f ] [ r ] , <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> if b == 3 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for x in range ( 20 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
from itertools import combinations_with_replacement as c <NEWLINE> n , m , q = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> abc = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( q ) ] <NEWLINE> aa = list ( range ( 1 , m + 1 ) ) <NEWLINE> ans = 0 <NEWLINE> for bb in c ( aa , n ) : <NEWLINE> <INDENT> cc = 0 <NEWLINE> for a , b , c , d in abc : <NEWLINE> <INDENT> if bb [ b - 1 ] - bb [ a - 1 ] == c : <NEWLINE> <INDENT> cc += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , cc ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> f = { } <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i - h [ i ] in f : <NEWLINE> <INDENT> ans += f [ i - h [ i ] ] <NEWLINE> <DEDENT> if i + h [ i ] in f : <NEWLINE> <INDENT> f [ i + h [ i ] ] += 1 <NEWLINE> <DEDENT> else : f [ i + h [ i ] ] = 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = input ( ) . split ( ) <NEWLINE> l = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> l [ int ( x [ i ] ) - 1 ] = l [ int ( x [ i ] ) - 1 ] + 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans_list = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans_list [ a_list [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * ans_list ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ahaha = n // i <NEWLINE> res += ( i + ahaha * i ) * ahaha // 2 <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
import math <NEWLINE> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> count1 = 0 <NEWLINE> count2 = 0 <NEWLINE> ans1 = B - B // C - B // D + B // ( ( C * D ) // math . gcd ( C , D ) ) <NEWLINE> A = A - 1 <NEWLINE> ans2 = A - A // C - A // D + A // ( ( C * D ) // math . gcd ( C , D ) ) <NEWLINE> print ( ans1 - ans2 ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] * n <NEWLINE> r = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l [ i ] = i + a [ i ] <NEWLINE> r [ i ] = i - a [ i ] <NEWLINE> <NL> <DEDENT> l = Counter ( l ) <NEWLINE> r = Counter ( r ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( max ( r . keys ( ) ) + 1 ) : <NEWLINE> <INDENT> ans += l [ i ] * r [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
data = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for h in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for o in range ( n ) : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> b = int ( a [ 0 ] ) <NEWLINE> f = int ( a [ 1 ] ) <NEWLINE> r = int ( a [ 2 ] ) <NEWLINE> v = int ( a [ 3 ] ) <NEWLINE> data [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> for r in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> , data [ b ] [ f ] [ r ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> if b < 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import numpy as np <NEWLINE> link = set ( ) <NEWLINE> next = a [ 0 ] <NEWLINE> link . add ( 1 ) <NEWLINE> while next not in link : <NEWLINE> <INDENT> link . add ( next ) <NEWLINE> next = a [ next - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> link2 = set ( ) <NEWLINE> next2 = a [ 0 ] <NEWLINE> link2 . add ( 1 ) <NEWLINE> while next not in link2 : <NEWLINE> <INDENT> link2 . add ( next2 ) <NEWLINE> next2 = a [ next2 - 1 ] <NEWLINE> <NL> <DEDENT> link2 . remove ( next ) <NEWLINE> ans = 0 <NEWLINE> <NL> rep = len ( link ) - len ( link2 ) <NEWLINE> <COMMENT> <NL> if ( len ( link2 ) == 0 ) : <NEWLINE> <INDENT> p = k % rep <NEWLINE> <COMMENT> <NL> for i in range ( p + rep ) : <NEWLINE> <INDENT> next = a [ next - 1 ] <NEWLINE> <DEDENT> <DEDENT> elif ( k > len ( link2 ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> p = ( k - len ( link2 ) ) % rep <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for i in range ( p + rep ) : <NEWLINE> <INDENT> next = a [ next - 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> next = a [ 0 ] <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> next = a [ next - 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = next <NEWLINE> <COMMENT> <NL> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = Counter ( input ( ) ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> s &= Counter ( input ( ) ) <NEWLINE> <DEDENT> print ( <STRING> . join ( sorted ( s . elements ( ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> num = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> cont = 0 <NEWLINE> ans = 1 <NEWLINE> <NL> for j in num : <NEWLINE> <INDENT> if j == 0 : cont += 1 <NEWLINE> <NL> <DEDENT> if cont > 0 : print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> for i in num : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N , M = ( int ( X ) for X in input ( ) . split ( ) ) <NEWLINE> Shop = np . zeros ( ( N , 2 ) , dtype = int ) <NEWLINE> for T in range ( 0 , N ) : <NEWLINE> <INDENT> Shop [ T , : ] = ( np . array ( [ int ( X ) for X in input ( ) . split ( ) ] ) ) <NEWLINE> <DEDENT> Shop = Shop [ np . argsort ( Shop [ : , 0 ] ) ] <NEWLINE> Rest = M <NEWLINE> Pric = 0 <NEWLINE> for T in range ( 0 , N ) : <NEWLINE> <INDENT> Pric += Shop [ T , 0 ] * Shop [ T , 1 ] <NEWLINE> Rest -= Shop [ T , 1 ] <NEWLINE> if Rest < 0 : <NEWLINE> <INDENT> Pric += Rest * Shop [ T , 0 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( Pric ) <NEWLINE>
ss = input ( ) <NEWLINE> <NL> S1 = [ ] <NEWLINE> S2 = [ ] <NEWLINE> <NL> a = 0 <NEWLINE> for ind , s in enumerate ( ss ) : <NEWLINE> <INDENT> if <STRING> == s : <NEWLINE> <INDENT> S1 . append ( ind ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> if len ( S1 ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> i = S1 . pop ( ) <NEWLINE> a += ind - i <NEWLINE> t = 0 <NEWLINE> while len ( S2 ) > 0 and S2 [ - 1 ] [ 0 ] > i - 1 : <NEWLINE> <INDENT> v = S2 . pop ( ) <NEWLINE> t += v [ 1 ] <NEWLINE> <DEDENT> S2 . append ( ( i , ind - i + t ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a ) <NEWLINE> if len ( S2 ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( S2 ) , <STRING> . join ( map ( lambda x : str ( x [ 1 ] ) , S2 ) ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> step = [ ] <NEWLINE> <NL> now = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> next = int ( input ( ) ) - 1 <NEWLINE> step . append ( next - now ) <NEWLINE> now = next + 2 <NEWLINE> <NL> <DEDENT> step . append ( n - now ) <NEWLINE> step . sort ( ) <NEWLINE> <NL> def fibo ( ) : <NEWLINE> <INDENT> s = [ ] <NEWLINE> a = 1 <NEWLINE> b = 1 <NEWLINE> s . append ( a ) <NEWLINE> s . append ( b ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = a + b <NEWLINE> a = b <NEWLINE> b = c <NEWLINE> s . append ( c ) <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> <NL> if step [ 0 ] < 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> f = fibo ( ) <NEWLINE> for i in step : <NEWLINE> <INDENT> ans *= f [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans % 1000000007 ) <NEWLINE>
import math <NEWLINE> <NL> a , b , n = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> i = min ( [ b - 1 , n ] ) <NEWLINE> print ( math . floor ( a * i / b ) - a * math . floor ( i / b ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 1 <NEWLINE> counter = Counter ( list ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( counter [ i ] ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = sum ( A ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i == M - 1 : <NEWLINE> <INDENT> if ( s / ( 4 * M ) ) > A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n - 1 == m : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if n < 2 * ( n - m - 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> uf = UnionFind ( n ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( x , y ) <NEWLINE> <DEDENT> v = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> v [ uf . find ( i ) ] . append ( ( a [ i ] , i ) ) <NEWLINE> <DEDENT> flag = set ( ) <NEWLINE> ans , cnt = 0 , 0 <NEWLINE> for t in v : <NEWLINE> <INDENT> if t : <NEWLINE> <INDENT> t . sort ( ) <NEWLINE> c , idx = t [ 0 ] <NEWLINE> flag . add ( idx ) <NEWLINE> cnt += 1 <NEWLINE> ans += c <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = ( a [ i ] , i ) <NEWLINE> <DEDENT> a . sort ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if cnt == 2 * ( n - m - 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c , idx = a [ i ] <NEWLINE> if idx not in flag : <NEWLINE> <INDENT> ans += c <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import copy <NEWLINE> import random <NEWLINE> import bisect <COMMENT> <NEWLINE> import fractions <COMMENT> <NEWLINE> import math <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> from decimal import Decimal <COMMENT> <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( mod ) <COMMENT> <NEWLINE> <NL> d = collections . deque ( ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> weights = { } <NEWLINE> <NL> roots = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = LI ( ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> roots [ a ] . append ( b ) <NEWLINE> roots [ b ] . append ( a ) <NEWLINE> weights [ ( a , b ) ] = c <NEWLINE> weights [ ( b , a ) ] = c <NEWLINE> <NL> <DEDENT> Q , K = LI ( ) <NEWLINE> K -= 1 <NEWLINE> xy = [ 0 for i in range ( Q ) ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> x , y = LI ( ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> xy [ i ] = [ x , y ] <NEWLINE> <DEDENT> <STRING> <NEWLINE> <NL> visited = [ - 1 for i in range ( N ) ] <NEWLINE> queue = collections . deque ( ) <NEWLINE> queue . append ( K ) <NEWLINE> visited [ K ] = 0 <NEWLINE> <NL> while len ( queue ) > 0 : <NEWLINE> <INDENT> node = queue . popleft ( ) <NEWLINE> cnt = visited [ node ] <NEWLINE> for n_node in roots [ node ] : <NEWLINE> <INDENT> if visited [ n_node ] == - 1 : <NEWLINE> <INDENT> visited [ n_node ] = cnt + weights [ ( node , n_node ) ] <NEWLINE> queue . append ( n_node ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for x , y in xy : <NEWLINE> <INDENT> print ( visited [ x ] + visited [ y ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import heapq <NEWLINE> a = list ( map ( lambda x : x * ( - 1 ) , a ) ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> b = heapq . heappop ( a ) <NEWLINE> heapq . heappush ( a , - ( - b // 2 ) ) <NEWLINE> <NL> <DEDENT> print ( sum ( a ) * ( - 1 ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from collections import deque , defaultdict <NEWLINE> from math import sqrt , factorial <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> d = defaultdict ( int ) <NEWLINE> for e in a : <NEWLINE> <INDENT> d [ e ] += 1 <NEWLINE> <DEDENT> sm = 0 <NEWLINE> xd = defaultdict ( int ) <NEWLINE> for k in d : <NEWLINE> <INDENT> if d [ k ] >= 2 : <NEWLINE> <INDENT> xd [ k ] = ( d [ k ] * ( d [ k ] - 1 ) ) // 2 <NEWLINE> <DEDENT> sm += xd [ k ] <NEWLINE> <DEDENT> for e in a : <NEWLINE> <INDENT> d [ e ] -= 1 <NEWLINE> sm -= xd [ e ] <NEWLINE> x = 0 <NEWLINE> if d [ e ] >= 2 : <NEWLINE> <INDENT> x = ( d [ e ] * ( d [ e ] - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( sm + x ) <NEWLINE> sm += xd [ e ] <NEWLINE> d [ e ] += 1 <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> t = 1 <NEWLINE> <COMMENT> <NL> for case in range ( 1 , t + 1 ) : <NEWLINE> <INDENT> ans = solve ( ) <NEWLINE> <NL> <NL> <DEDENT> <STRING> <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> from typing import Any , Callable , Deque , Dict , List , Mapping , Optional , Sequence , Set , Tuple , TypeVar , Union <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> Num = Union [ int , float ] <NEWLINE> mod = 1000000007 <COMMENT> <NEWLINE> inf = float ( <STRING> ) <COMMENT> <NEWLINE> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 6 ) <COMMENT> <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def ii ( ) : return int ( input ( ) ) <NEWLINE> def isp ( ) : return input ( ) . split ( ) <NEWLINE> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def mi_0 ( ) : return map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> def lmi ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lmi_0 ( ) : return list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> def li ( ) : return list ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> def check_palindrome ( s ) : <NEWLINE> <INDENT> n = len ( s ) <NEWLINE> for i in range ( n // 2 ) : <NEWLINE> <INDENT> if s [ i ] != s [ n - 1 - i ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def find_center ( s , cnt ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> n = len ( s ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> if num == cnt : <NEWLINE> <INDENT> return i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def find_center_even ( s , cnt ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> n = len ( s ) <NEWLINE> left , right = - 1 , - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> if num == cnt : <NEWLINE> <INDENT> if left == - 1 : <NEWLINE> <INDENT> left = i <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if num == cnt + 1 : <NEWLINE> <INDENT> right = i <NEWLINE> <COMMENT> <NL> return ( left + right ) / 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def not_x_split ( s ) : <NEWLINE> <INDENT> buf = [ ] <NEWLINE> s += <STRING> <NEWLINE> n = len ( s ) <NEWLINE> x_cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> buf . append ( x_cnt ) <NEWLINE> x_cnt = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x_cnt += 1 <NEWLINE> <DEDENT> <DEDENT> return buf <NEWLINE> <NL> <NL> <NL> <DEDENT> def solve ( s , buf ) : <NEWLINE> <INDENT> bufsize = len ( buf ) <NEWLINE> if bufsize % 2 == 0 : <NEWLINE> <INDENT> cnt = bufsize // 2 <NEWLINE> ind = find_center_even ( s , cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = ( bufsize + 1 ) // 2 <NEWLINE> ind = find_center ( s , cnt ) <NEWLINE> <NL> <DEDENT> if ind % 1 == 0 : <NEWLINE> <INDENT> left_s = s [ : int ( ind ) ] [ : : - 1 ] <NEWLINE> right_s = s [ int ( ind ) + 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left_s = s [ : int ( ind ) + 1 ] [ : : - 1 ] <NEWLINE> right_s = s [ int ( ind ) + 1 : ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> left = not_x_split ( left_s ) <NEWLINE> right = not_x_split ( right_s ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> assert len ( left ) == len ( right ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( left ) ) : <NEWLINE> <INDENT> ans += max ( left [ i ] , right [ i ] ) - min ( left [ i ] , right [ i ] ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> s = input ( ) <NEWLINE> if check_palindrome ( s ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> buf = [ char for char in s if char != <STRING> ] <NEWLINE> if not check_palindrome ( buf ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> print ( solve ( s , buf ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mapa = { } <NEWLINE> strings = [ 0 ] * h <NEWLINE> rows = [ 0 ] * w <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> h1 , w1 = map ( int , input ( ) . split ( ) ) <NEWLINE> if not mapa . get ( h1 - 1 , 0 ) : <NEWLINE> <INDENT> mapa [ h1 - 1 ] = [ ] <NEWLINE> <DEDENT> mapa [ h1 - 1 ] . append ( w1 - 1 ) <NEWLINE> strings [ h1 - 1 ] += 1 <NEWLINE> rows [ w1 - 1 ] += 1 <NEWLINE> <NL> <DEDENT> max_s = max ( strings ) <NEWLINE> max_r = max ( rows ) <NEWLINE> strings_max = [ ] <NEWLINE> rows_max = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if strings [ i ] == max_s : <NEWLINE> <INDENT> strings_max . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( w ) : <NEWLINE> <INDENT> if rows [ i ] == max_r : <NEWLINE> <INDENT> rows_max . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> forbidden_positions = set ( mapa [ strings_max [ 0 ] ] ) <NEWLINE> for item in strings_max [ 1 : ] : <NEWLINE> <INDENT> forbidden_positions . intersection_update ( set ( mapa [ item ] ) ) <NEWLINE> <NL> <DEDENT> answer_set = set ( rows_max ) . difference ( forbidden_positions ) <NEWLINE> if answer_set : <NEWLINE> <INDENT> print ( max_s + max_r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max_s + max_r - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <NL> count = 0 <NEWLINE> backslash_index = [ ] <NEWLINE> area_pond = [ ] <NEWLINE> pending_area = [ ] <NEWLINE> for index , symbol in enumerate ( input ( ) ) : <NEWLINE> <INDENT> if symbol == <STRING> : <NEWLINE> <INDENT> backslash_index += [ index ] <NEWLINE> <DEDENT> elif symbol == <STRING> and backslash_index : <NEWLINE> <INDENT> last_bs_index = backslash_index . pop ( ) <NEWLINE> diff = index - last_bs_index <NEWLINE> count += diff <NEWLINE> while area_pond and area_pond [ - 1 ] > last_bs_index : <NEWLINE> <INDENT> diff += pending_area . pop ( ) <NEWLINE> area_pond . pop ( ) <NEWLINE> <NL> <DEDENT> area_pond += [ last_bs_index ] <NEWLINE> pending_area += [ diff ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> print ( len ( area_pond ) , * ( pending_area ) ) <NEWLINE> <COMMENT> <NL> <NL>
def calc ( a , n ) : <NEWLINE> <INDENT> for x in range ( n ) : <NEWLINE> <INDENT> if a [ x ] == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> result = 1 <NEWLINE> max = 10 ** 18 <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> result *= a [ x ] <NEWLINE> if result > max : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( calc ( a , n ) ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : a . append ( a [ i ] + A [ i ] ) <NEWLINE> for i in range ( M ) : b . append ( b [ i ] + B [ i ] ) <NEWLINE> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . reverse ( ) <NEWLINE> for i , elem in enumerate ( a ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( elem , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> root = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> root [ a - 1 ] . append ( b ) <NEWLINE> root [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> q = deque ( ) <NEWLINE> q . append ( 1 ) <NEWLINE> ans = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> while len ( q ) > 0 : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for ike in root [ v - 1 ] : <NEWLINE> <INDENT> q . append ( ike ) <NEWLINE> if ( ans [ ike - 1 ] == 0 ) : <NEWLINE> <INDENT> ans [ ike - 1 ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> root [ v - 1 ] . clear ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for a in ans [ 1 : : ] : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
D = int ( 1e9 + 7 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> R = sum ( M [ 1 : ] ) <NEWLINE> <NL> sum_ = 0 <NEWLINE> for i , x in enumerate ( M [ : - 1 ] ) : <NEWLINE> <INDENT> sum_ += R * x <NEWLINE> sum_ %= D <NEWLINE> R -= M [ i + 1 ] <NEWLINE> <NL> <DEDENT> print ( sum_ ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> li_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic_a = { } <NEWLINE> <NL> for a in li_a : <NEWLINE> <INDENT> dic_a [ a ] = dic_a . get ( a , 0 ) + 1 <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> li_bc = list ( ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> li_bc . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT> answer = sum ( li_a ) <NEWLINE> for l in li_bc : <NEWLINE> <INDENT> b = l [ 0 ] <NEWLINE> c = l [ 1 ] <NEWLINE> <NL> diff = ( c - b ) * dic_a . get ( b , 0 ) <NEWLINE> if b in dic_a . keys ( ) : <NEWLINE> <INDENT> dic_a [ c ] = dic_a . get ( c , 0 ) + dic_a . get ( b , 0 ) <NEWLINE> dic_a [ b ] = 0 <NEWLINE> answer += diff <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> print ( answer ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> input_list = input ( ) . split ( ) <NEWLINE> result = 1 <NEWLINE> max = 10 ** 18 <NEWLINE> if <STRING> in input_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in input_list : <NEWLINE> <INDENT> result *= int ( i ) <NEWLINE> if result > max : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> s = <STRING> <NEWLINE> for i in n : <NEWLINE> <INDENT> if i == <STRING> or i == <STRING> : <NEWLINE> <INDENT> s += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( s ) > 0 : <NEWLINE> <INDENT> s = s [ 0 : - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N = int ( readline ( ) . rstrip ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> d1 = { } <NEWLINE> d2 = { } <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> x1 = n + A [ n - 1 ] <NEWLINE> if x1 in d1 : <NEWLINE> <INDENT> d1 [ x1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d1 [ x1 ] = 1 <NEWLINE> <NL> <DEDENT> x2 = n - A [ n - 1 ] <NEWLINE> if x2 in d2 : <NEWLINE> <INDENT> d2 [ x2 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d2 [ x2 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for d in d1 : <NEWLINE> <INDENT> if d in d2 : <NEWLINE> <INDENT> ans += ( d1 [ d ] * d2 [ d ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> div = n <NEWLINE> result = 10 ** 12 <NEWLINE> <NL> for i in range ( 1 , 1000001 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> div = n // i <NEWLINE> result = min ( result , i + div ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( result - 2 ) ) <NEWLINE> <NL>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b != 0 : <NEWLINE> <INDENT> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = B . copy ( ) <NEWLINE> for i in range ( b ) : <NEWLINE> <INDENT> A [ i ] = abs ( A [ i ] - a ) <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> for i in range ( A [ - 1 ] + 2 ) : <NEWLINE> <INDENT> if A . count ( i ) == 1 : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> if a - i in B : <NEWLINE> <INDENT> result = a + i <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = a - i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif A . count ( i ) == 0 : <NEWLINE> <INDENT> result = a - i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> result = a <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 998244353 <NEWLINE> <NL> fac = [ 1 , 1 ] <COMMENT> <NEWLINE> facinv = [ 1 , 1 ] <COMMENT> <NEWLINE> inv = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> fac . append ( ( fac [ - 1 ] * i ) % MOD ) <NEWLINE> inv . append ( ( - inv [ MOD % i ] * ( MOD // i ) ) % MOD ) <NEWLINE> facinv . append ( ( facinv [ - 1 ] * inv [ - 1 ] ) % MOD ) <NEWLINE> <NL> <DEDENT> def cmb ( n , r ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return fac [ n ] * facinv [ r ] * facinv [ n - r ] % MOD <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> for k in range ( K + 1 ) : <NEWLINE> <INDENT> sum += M * pow ( M - 1 , N - 1 - k , MOD ) * cmb ( N - 1 , k ) % MOD <NEWLINE> sum %= MOD <NEWLINE> <NL> <DEDENT> print ( sum % MOD ) <NEWLINE>
S = input ( ) <NEWLINE> mod = 2019 <NEWLINE> <NL> cs_mods = { 0 : 1 } <NEWLINE> cumsum = 0 <NEWLINE> count = 0 <NEWLINE> for i , s in enumerate ( S [ : : - 1 ] ) : <NEWLINE> <INDENT> cumsum = ( cumsum + int ( s ) * pow ( 10 , i , mod ) ) % mod <NEWLINE> cs_mods . setdefault ( cumsum , 0 ) <NEWLINE> <COMMENT> <NL> cs_mods [ cumsum ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for k , v in cs_mods . items ( ) : <NEWLINE> <INDENT> count += v * ( v - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_sum = [ 0 ] <NEWLINE> B_sum = [ 0 ] <NEWLINE> A_sum . extend ( A ) <NEWLINE> B_sum . extend ( B ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> A_sum [ i ] += A_sum [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> B_sum [ i ] += B_sum [ i - 1 ] <NEWLINE> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if A_sum [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while B_sum [ j ] + A_sum [ i ] > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
flag = 0 <NEWLINE> while flag == 0 : <NEWLINE> <INDENT> a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * b ) <NEWLINE> for i in range ( a - 2 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> * ( b - 2 ) , end = <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * b ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> def permutation ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> return 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 6 <NEWLINE> <NL> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 ) : <NEWLINE> <INDENT> for k in range ( j , n + 1 ) : <NEWLINE> <INDENT> diff = 1 <NEWLINE> if j != k : <NEWLINE> <INDENT> diff += 1 <NEWLINE> <DEDENT> if i != j : <NEWLINE> <INDENT> diff += 1 <NEWLINE> <DEDENT> s += gcd ( i , gcd ( j , k ) ) * permutation ( diff ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE> return s <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s1 = <STRING> . join ( sorted ( input ( ) ) ) <NEWLINE> s . append ( s1 ) <NEWLINE> <DEDENT> s = Counter ( s ) . most_common ( ) <NEWLINE> num = 0 <NEWLINE> for i , h in s : <NEWLINE> <INDENT> num += ( h * ( h - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( num ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( int ( 1e9 ) ) <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . p = list ( range ( n ) ) <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . p [ x ] == x : return x <NEWLINE> self . p [ x ] = self . find ( self . p [ x ] ) <NEWLINE> return self . p [ x ] <NEWLINE> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x , y = self . find ( x ) , self . find ( y ) <NEWLINE> if x != y : self . p [ x ] = y <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . unite ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if uf . find ( 0 ) != uf . find ( i ) : <NEWLINE> <INDENT> uf . unite ( 0 , i ) <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> import itertools <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> c . sort ( ) <NEWLINE> bc = [ ] <NEWLINE> ans = 0 <NEWLINE> count = 0 <NEWLINE> <NL> <NL> for i in b : <NEWLINE> <INDENT> indc = bisect . bisect_right ( c , i ) <NEWLINE> bc . append ( ( n - indc ) ) <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> BC = [ 0 ] + list ( itertools . accumulate ( bc ) ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> indb = bisect . bisect_right ( b , i ) <NEWLINE> ans += BC [ - 1 ] - BC [ indb ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> G = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <DEDENT> S = - 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if len ( G [ i ] ) == 1 : <NEWLINE> <INDENT> S = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> visited = [ False for i in range ( N + 1 ) ] <NEWLINE> parent = [ - 1 for i in range ( N + 1 ) ] <NEWLINE> count = [ 1 for i in range ( N + 1 ) ] <NEWLINE> <NL> ans = N * pow ( 2 , N - 1 , mod ) <NEWLINE> stack = deque ( ) <NEWLINE> <NL> <NL> def dfs ( node ) : <NEWLINE> <INDENT> visited [ node ] = True <NEWLINE> for child in G [ node ] : <NEWLINE> <INDENT> if visited [ child ] == False : <NEWLINE> <INDENT> parent [ child ] = node <NEWLINE> stack . append ( ( node , child ) ) <NEWLINE> dfs ( child ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> powers = [ 1 for i in range ( 2 * 10 ** 5 + 1 ) ] <NEWLINE> for i in range ( 1 , 2 * 10 ** 5 + 1 ) : <NEWLINE> <INDENT> powers [ i ] = powers [ i - 1 ] * 2 % mod <NEWLINE> <NL> <DEDENT> dfs ( S ) <NEWLINE> while stack : <NEWLINE> <INDENT> mom , child = stack . pop ( ) <NEWLINE> count [ mom ] += count [ child ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if len ( G [ i ] ) > 1 : <NEWLINE> <INDENT> ans += powers [ N - 1 ] <NEWLINE> for x in G [ i ] : <NEWLINE> <INDENT> if x != parent [ i ] : <NEWLINE> <INDENT> ans -= powers [ count [ x ] ] <NEWLINE> <DEDENT> <DEDENT> ans -= powers [ N - count [ i ] ] <NEWLINE> ans += len ( G [ i ] ) - 1 <NEWLINE> ans %= mod <NEWLINE> <DEDENT> <DEDENT> D = pow ( 2 , N , mod ) <NEWLINE> print ( ans * pow ( D , mod - 2 , mod ) % mod ) <NEWLINE>
import numpy as np <NEWLINE> p = 998244353 <NEWLINE> <NL> N , S = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> dp = np . zeros ( S + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> if S < a : <NEWLINE> <INDENT> dp *= 2 <NEWLINE> dp %= p <NEWLINE> continue <NEWLINE> <DEDENT> tmp = 2 * dp <NEWLINE> dp = np . append ( np . zeros ( a ) , dp [ : S - a + 1 ] ) <NEWLINE> dp += tmp <NEWLINE> dp %= p <NEWLINE> <DEDENT> print ( int ( dp [ S ] ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( ) <NEWLINE> B = list ( ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a - 1 ) <NEWLINE> B . append ( b - 1 ) <NEWLINE> <NL> <DEDENT> kyuryo = [ set ( ) for _ in range ( N ) ] <NEWLINE> for michi in range ( M ) : <NEWLINE> <INDENT> kyuryo [ A [ michi ] ] . add ( B [ michi ] ) <NEWLINE> kyuryo [ B [ michi ] ] . add ( A [ michi ] ) <NEWLINE> <NL> <DEDENT> nice_count = 0 <NEWLINE> for tenbodai in range ( N ) : <NEWLINE> <INDENT> for neighbor in kyuryo [ tenbodai ] : <NEWLINE> <INDENT> if H [ neighbor ] >= H [ tenbodai ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> nice_count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( nice_count ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> TD = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> TD . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> <NL> import heapq <NEWLINE> hq = [ ] <NEWLINE> heapq . heapify ( hq ) <NEWLINE> selected = set ( ) <NEWLINE> ans = 0 <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> t , d = TD . pop ( ) <NEWLINE> if t in selected : <NEWLINE> <INDENT> heapq . heappush ( hq , d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> selected . add ( t ) <NEWLINE> <DEDENT> ans += d <NEWLINE> <DEDENT> ans += len ( selected ) ** 2 <NEWLINE> <NL> tmp = ans <NEWLINE> while TD : <NEWLINE> <INDENT> t , d = TD . pop ( ) <NEWLINE> if t in selected : continue <NEWLINE> selected . add ( t ) <NEWLINE> if len ( hq ) == 0 : break <NEWLINE> tmp -= heapq . heappop ( hq ) <NEWLINE> tmp += d <NEWLINE> tmp += len ( selected ) * 2 - 1 <NEWLINE> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> num = 0 <NEWLINE> last = 0 <NEWLINE> d = 1 <NEWLINE> count = { } <NEWLINE> for k in range ( 2019 ) : <NEWLINE> <INDENT> count [ k ] = 0 <NEWLINE> <NL> <DEDENT> count [ 0 ] = 1 <COMMENT> <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> num = ( int ( i ) * d + num ) % 2019 <NEWLINE> <NL> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> count [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for j in range ( 2019 ) : <NEWLINE> <INDENT> ans += count [ j ] * ( count [ j ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def f ( A , B , x ) : <NEWLINE> <INDENT> return math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> <NL> <NL> <DEDENT> def main ( A , B , N ) : <NEWLINE> <INDENT> if N < B : <NEWLINE> <INDENT> return f ( A , B , N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return f ( A , B , B - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( main ( A , B , N ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = a [ 0 ] <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if ans < 10 ** 18 : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> left = s [ 0 ] <NEWLINE> ans = 10 ** 6 <NEWLINE> left = { } <NEWLINE> left . setdefault ( <STRING> , 0 ) <NEWLINE> left . setdefault ( <STRING> , 0 ) <NEWLINE> right = { } <NEWLINE> right . setdefault ( <STRING> , 0 ) <NEWLINE> right . setdefault ( <STRING> , 0 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> right [ s [ i ] ] += 1 <NEWLINE> <DEDENT> ans = 10 ** 6 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> right [ s [ i ] ] -= 1 <NEWLINE> ans = min ( ans , left [ <STRING> ] + right [ <STRING> ] ) <NEWLINE> <COMMENT> <NL> left [ s [ i ] ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> c = dict ( c ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i + 1 in c . keys ( ) : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> while ( True ) : <NEWLINE> <INDENT> c -= b <NEWLINE> if ( c <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> a -= d <NEWLINE> if ( a <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] * ( N + 1 ) <NEWLINE> b = [ 0 ] * ( M + 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] + A [ i ] <NEWLINE> <DEDENT> for j in range ( M ) : <NEWLINE> <INDENT> b [ j + 1 ] = b [ j ] + B [ j ] <NEWLINE> <NL> <DEDENT> n_b = M <NEWLINE> best = 0 <NEWLINE> <NL> for n_a in range ( N + 1 ) : <NEWLINE> <INDENT> if K < a [ n_a ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> while K < a [ n_a ] + b [ n_b ] : <NEWLINE> <INDENT> n_b -= 1 <NEWLINE> <NL> <DEDENT> best = max ( n_a + n_b , best ) <NEWLINE> <NL> <DEDENT> print ( int ( best ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> p = 1 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> s = sum ( 1 for b in a if b & p ) <NEWLINE> ans += s * ( n - s ) * p <NEWLINE> ans %= mod <NEWLINE> p <<= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> RGB = [ 0 , 0 , 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> RGB [ 0 ] += 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> RGB [ 1 ] += 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> RGB [ 2 ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = RGB [ 0 ] * RGB [ 1 ] * RGB [ 2 ] <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> s1 = S [ i ] <NEWLINE> for k in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> s2 = S [ k ] <NEWLINE> t = k + k - i <NEWLINE> if s1 == s2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if t <= N - 1 : <NEWLINE> <INDENT> s3 = S [ t ] <NEWLINE> if s3 != s1 and s3 != s2 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = a * b <NEWLINE> if c % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import numpy as np <NEWLINE> S = input ( ) <NEWLINE> cand = np . zeros ( 2019 , dtype = int ) <NEWLINE> rem = 0 <NEWLINE> order = 1 <NEWLINE> mod = 2019 <NEWLINE> for s in S [ : : - 1 ] : <NEWLINE> <INDENT> rem += ( int ( s ) * order ) % mod <NEWLINE> rem %= mod <NEWLINE> cand [ rem ] += 1 <NEWLINE> order *= 10 <NEWLINE> order %= mod <NEWLINE> <DEDENT> ans = cand [ 0 ] <NEWLINE> cand = cand [ cand > 1 ] <NEWLINE> for c in cand : <NEWLINE> <INDENT> ans += c * ( c - 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
from collections import Counter <NEWLINE> import time <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> line = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = Counter ( line ) <NEWLINE> nums = 0 <NEWLINE> for num , cnt in dic . items ( ) : <NEWLINE> <INDENT> if cnt > 1 : <NEWLINE> <INDENT> nums += ( cnt * ( cnt - 1 ) ) // 2 <NEWLINE> <DEDENT> <DEDENT> for i in line : <NEWLINE> <INDENT> print ( nums - ( dic [ i ] - 1 ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> for _ in range ( W ) : <NEWLINE> <INDENT> s = s + <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
import collections <NEWLINE> import copy <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , ( input ( ) . split ( ) ) ) ) <NEWLINE> ans = sum ( A ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> col = collections . Counter ( A ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> L , R = map ( int , ( input ( ) . split ( ) ) ) <NEWLINE> sa = ( R - L ) * col [ L ] <NEWLINE> col [ R ] += copy . copy ( col [ L ] ) <NEWLINE> col [ L ] = 0 <NEWLINE> ans = ans + sa <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_ = [ 0 ] <NEWLINE> b_ = [ 0 ] <NEWLINE> tmp = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> tmp += i <NEWLINE> a_ . append ( tmp ) <NEWLINE> <DEDENT> tmp = 0 <NEWLINE> for i in b : <NEWLINE> <INDENT> tmp += i <NEWLINE> b_ . append ( tmp ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a_ [ i ] > k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> while b_ [ j ] + a_ [ i ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = [ ] <NEWLINE> m = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> m . append ( abs ( a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> M . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> i = 0 <NEWLINE> j = 0 <NEWLINE> tmp = 1 <NEWLINE> P = 10 ** 9 + 7 <NEWLINE> <NL> if ( K % 2 == 0 and ( len ( m ) // 2 * 2 + len ( M ) // 2 * 2 ) >= K ) or ( K % 2 == 1 and ( len ( M ) + len ( m ) // 2 * 2 ) >= K and len ( M ) > 0 ) : <NEWLINE> <INDENT> m . sort ( reverse = True ) <NEWLINE> M . sort ( reverse = True ) <NEWLINE> while K > 0 : <NEWLINE> <INDENT> if K >= 2 : <NEWLINE> <INDENT> if j + 2 <= len ( M ) and i + 2 <= len ( m ) : <NEWLINE> <INDENT> if m [ i ] * m [ i + 1 ] < M [ j ] * M [ j + 1 ] : <NEWLINE> <INDENT> tmp *= M [ j ] <NEWLINE> j += 1 <NEWLINE> K -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp *= m [ i ] * m [ i + 1 ] <NEWLINE> i += 2 <NEWLINE> K -= 2 <NEWLINE> <DEDENT> <DEDENT> elif j + 2 <= len ( M ) : <NEWLINE> <INDENT> tmp *= M [ j ] <NEWLINE> j += 1 <NEWLINE> K -= 1 <NEWLINE> <DEDENT> elif i + 2 <= len ( m ) : <NEWLINE> <INDENT> tmp *= m [ i ] * m [ i + 1 ] <NEWLINE> i += 2 <NEWLINE> K -= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp *= m [ i ] * M [ j ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tmp *= M [ j ] <NEWLINE> K -= 1 <NEWLINE> <DEDENT> tmp %= P <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> m . sort ( ) <NEWLINE> M . sort ( ) <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> if j + 1 <= len ( M ) and i + 1 <= len ( m ) : <NEWLINE> <INDENT> if M [ j ] < m [ i ] : <NEWLINE> <INDENT> tmp *= M [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp *= m [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> elif j + 1 <= len ( M ) : <NEWLINE> <INDENT> tmp *= M [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp *= m [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> tmp %= P <NEWLINE> <DEDENT> tmp *= - 1 <NEWLINE> tmp %= P <NEWLINE> <NL> <DEDENT> print ( tmp ) <NEWLINE> <NL> <NL> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> uf = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( x - 1 , y - 1 ) <NEWLINE> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def check ( x ) : <NEWLINE> <INDENT> if x <= 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return N + K >= sum ( map ( lambda a : math . ceil ( a / x ) , A ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> s = max ( A ) // 2 <NEWLINE> h = s // 2 <NEWLINE> c = check ( s ) <NEWLINE> last = c <NEWLINE> while True : <NEWLINE> <INDENT> if c : <NEWLINE> <INDENT> s -= max ( 1 , h ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += max ( 1 , h ) <NEWLINE> <DEDENT> h //= 2 <NEWLINE> last = c <NEWLINE> c = check ( s ) <NEWLINE> if h <= 0 and last != c : <NEWLINE> <INDENT> if last : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = np . array ( A ) . cumsum ( ) <NEWLINE> B = np . array ( B ) . cumsum ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if A [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while B [ j ] > K - A [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def comb ( n ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return n * ( n - 1 ) // 2 <NEWLINE> <NL> <NL> <DEDENT> def check ( L ) : <NEWLINE> <INDENT> r = { } <NEWLINE> a = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( len ( L ) ) : <NEWLINE> <INDENT> if a != L [ i ] : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> r [ a ] = [ comb ( c ) , comb ( c - 1 ) ] <NEWLINE> <DEDENT> a = L [ i ] <NEWLINE> c = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> r [ a ] = [ comb ( c ) , comb ( c - 1 ) ] <NEWLINE> <COMMENT> <NL> return r <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( n ) for n in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> D = { } <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> D [ i ] = A [ i ] <NEWLINE> <NL> <DEDENT> D = sorted ( D . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> V = { } <NEWLINE> for i in range ( len ( D ) ) : <NEWLINE> <INDENT> V [ D [ i ] [ 0 ] ] = i <NEWLINE> <NL> <DEDENT> AA = sorted ( A ) <NEWLINE> rr = check ( AA ) <NEWLINE> ss = 0 <NEWLINE> for k , v in rr . items ( ) : <NEWLINE> <INDENT> ss += v [ 0 ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for k in range ( N ) : <NEWLINE> <INDENT> index = A [ k ] <NEWLINE> a = rr [ index ] [ 0 ] - rr [ index ] [ 1 ] <NEWLINE> print ( ss - a ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> <NL> original_pop_count = x . count ( <STRING> ) <NEWLINE> one_pop_count = original_pop_count - 1 <NEWLINE> zero_pop_count = original_pop_count + 1 <NEWLINE> <NL> one_mod = 0 <NEWLINE> zero_mod = 0 <NEWLINE> <NL> for b in x : <NEWLINE> <COMMENT> <NL> <INDENT> if one_pop_count != 0 : <NEWLINE> <INDENT> one_mod = ( one_mod * 2 + int ( b ) ) % one_pop_count <NEWLINE> <DEDENT> zero_mod = ( zero_mod * 2 + int ( b ) ) % zero_pop_count <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> f = [ 0 ] * 220000 <NEWLINE> pop_count = [ 0 ] * 220000 <NEWLINE> for i in range ( 1 , 220000 ) : <NEWLINE> <INDENT> pop_count [ i ] = pop_count [ i // 2 ] + i % 2 <COMMENT> <NEWLINE> f [ i ] = f [ i % pop_count [ i ] ] + 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> one_pow2 = [ 1 ] * 220000 <NEWLINE> zero_pow2 = [ 1 ] * 220000 <NEWLINE> for i in range ( 1 , 220000 ) : <NEWLINE> <INDENT> if one_pop_count != 0 : <NEWLINE> <INDENT> one_pow2 [ i ] = one_pow2 [ i - 1 ] * 2 % one_pop_count <NEWLINE> <DEDENT> zero_pow2 [ i ] = zero_pow2 [ i - 1 ] * 2 % zero_pop_count <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if x [ n - 1 - i ] == <STRING> : <NEWLINE> <INDENT> if one_pop_count != 0 : <NEWLINE> <INDENT> nxt = one_mod <NEWLINE> nxt -= one_pow2 [ i ] <NEWLINE> nxt %= one_pop_count <COMMENT> <NEWLINE> print ( f [ nxt ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if x [ n - 1 - i ] == <STRING> : <NEWLINE> <INDENT> nxt = zero_mod <NEWLINE> nxt += zero_pow2 [ i ] <NEWLINE> nxt %= zero_pop_count <NEWLINE> print ( f [ nxt ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> p = math . factorial ( n ) <NEWLINE> print ( p % ( 10 ** 9 + 7 ) ) <NEWLINE>
import collections <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> WA_CNT = { } <NEWLINE> CLEAR = { } <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> P , S = input ( ) . split ( ) <NEWLINE> if P in CLEAR : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S == <STRING> : <NEWLINE> <INDENT> CLEAR [ P ] = 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if not P in WA_CNT : <NEWLINE> <INDENT> WA_CNT [ P ] = 0 <NEWLINE> <DEDENT> WA_CNT [ P ] += 1 <NEWLINE> <NL> <NL> <DEDENT> num = len ( CLEAR ) <NEWLINE> try_num = 0 <NEWLINE> for i in CLEAR : <NEWLINE> <INDENT> if i in WA_CNT : <NEWLINE> <INDENT> try_num += WA_CNT [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( num , try_num ) ) <NEWLINE>
o = list ( input ( ) ) <NEWLINE> e = input ( ) <NEWLINE> for i in range ( len ( e ) ) : <NEWLINE> <INDENT> o . insert ( 2 * i + 1 , e [ i ] ) <NEWLINE> <DEDENT> print ( * o , sep = <STRING> ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> L = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> ans += bisect . bisect_left ( L , L [ i ] + L [ j ] ) - ( j + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> t = 0 <NEWLINE> import math <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> t = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( t , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
from functools import lru_cache <NEWLINE> <NL> @ lru_cache ( maxsize = 1 << 10 ) <NEWLINE> def solve ( p , q , a , n ) : <NEWLINE> <INDENT> def _solve ( num , dem , d , m , s ) : <NEWLINE> <INDENT> if num == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if d == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if num * a // m < dem : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return sum ( ( _solve ( num * i - dem , dem * i , d - 1 , m * i , i ) <NEWLINE> <INDENT> for i in range ( s , min ( dem * n // num , a // m ) + 1 ) ) , 0 ) <NEWLINE> <DEDENT> <DEDENT> return _solve ( p , q , n , 1 , 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> p , q , a , n = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if p == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans . append ( solve ( p , q , a , n ) ) <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> cnt_list = Counter ( A ) <NEWLINE> <NL> total = sum ( [ cnt * ( cnt - 1 ) // 2 if cnt > 1 else 0 for cnt in cnt_list . values ( ) ] ) <NEWLINE> print ( * [ total - cnt_list [ a ] + 1 for a in A ] , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> R_max = - 10 ** 9 <NEWLINE> R_min = int ( input ( ) ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> R = int ( input ( ) ) <NEWLINE> if R_max < R - R_min : <NEWLINE> <INDENT> R_max = R - R_min <NEWLINE> <NL> <DEDENT> if R < R_min : <NEWLINE> <INDENT> R_min = R <NEWLINE> <NL> <DEDENT> <DEDENT> print ( R_max ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> total1 = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> total1 += math . gcd ( i , math . gcd ( j , k ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> total1 = 6 * total1 <NEWLINE> <NL> total2 = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> total2 += math . gcd ( i , j ) <NEWLINE> <DEDENT> <DEDENT> total2 = 6 * total2 <NEWLINE> <NL> total3 = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> total3 += i <NEWLINE> <NL> <DEDENT> print ( total1 + total2 + total3 ) <NEWLINE>
count = 0 <NEWLINE> coins = [ 10 , 50 , 100 , 500 ] <NEWLINE> while 1 : <NEWLINE> <INDENT> price = int ( input ( ) ) <NEWLINE> if price == 0 : break <NEWLINE> if count != 0 : print ( <STRING> ) <NEWLINE> wallet = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> cash = wallet [ 0 ] * 10 + wallet [ 1 ] * 50 + wallet [ 2 ] * 100 + wallet [ 3 ] * 500 <NEWLINE> charge = cash - price <NEWLINE> chargecoins = ( ( charge % 50 ) // 10 , ( charge % 100 ) // 50 , ( charge % 500 ) // 100 , charge // 500 ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if wallet [ i ] > chargecoins [ i ] : print ( <STRING> . format ( coins [ i ] , wallet [ i ] - chargecoins [ i ] ) ) <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> i = 0 <NEWLINE> while i < N - K : <NEWLINE> <INDENT> if A [ i ] < A [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> B [ A [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , B ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> LIST = [ X ] <NEWLINE> SET = { X } <NEWLINE> <NL> a = X <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if a * a % M in SET : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = a * a % M <NEWLINE> LIST . append ( a ) <NEWLINE> SET . add ( a ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> start = LIST . index ( a * a % M ) <NEWLINE> LEN = len ( LIST ) <NEWLINE> <NL> if N <= LEN : <NEWLINE> <INDENT> print ( sum ( LIST [ : N ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> LoopTimes , Excess = divmod ( N - LEN , LEN - start ) <NEWLINE> LoopSum = sum ( LIST [ start : ] ) * LoopTimes <NEWLINE> ExSum = sum ( LIST [ start : start + Excess ] ) <NEWLINE> print ( sum ( LIST [ : ] ) + LoopSum + ExSum ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> C *= A [ i ] <NEWLINE> if C > 10 ** 18 : <NEWLINE> <INDENT> C = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( C ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> h = int ( a ) <NEWLINE> w = int ( b ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( w * <STRING> ) <NEWLINE> if h >= 3 and h >= 3 : <NEWLINE> <INDENT> for i in range ( h - 2 ) : <NEWLINE> <INDENT> print ( 1 * <STRING> + ( w - 2 ) * <STRING> + 1 * <STRING> ) <NEWLINE> <NL> <DEDENT> print ( w * <STRING> ) <NEWLINE> <DEDENT> elif h == 2 : <NEWLINE> <INDENT> print ( w * <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s_li_ = [ ] <NEWLINE> c_li_ = [ ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s_li_ . append ( s ) <NEWLINE> c_li_ . append ( c ) <NEWLINE> <NL> <DEDENT> def func ( n , m , s_li , c_li ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 10 ** ( n - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> if ( s_li [ 0 ] == 1 ) & ( c_li [ 0 ] == 0 ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 10 ** ( n - 1 ) , 10 ** n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for s , c in zip ( s_li , c_li ) : <NEWLINE> <INDENT> if str ( i ) [ s - 1 ] == str ( c ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt == m : <NEWLINE> <INDENT> return i <NEWLINE> <NL> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <DEDENT> print ( func ( n , m , s_li_ , c_li_ ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ll = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ll . append ( l ) <NEWLINE> <NL> <DEDENT> ll . sort ( ) <NEWLINE> <NL> t = 0 <NEWLINE> cst = 0 <NEWLINE> i = 0 <NEWLINE> while t < m : <NEWLINE> <INDENT> t += ll [ i ] [ 1 ] <NEWLINE> cst += ll [ i ] [ 0 ] * ll [ i ] [ 1 ] <NEWLINE> if t > m : <NEWLINE> <INDENT> cst -= ll [ i ] [ 0 ] * ( t - m ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( cst ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> N_list = [ 0 ] * ( 100001 ) <NEWLINE> sumn = 0 <NEWLINE> <NL> for a in a_list : <NEWLINE> <INDENT> N_list [ a ] += 1 <NEWLINE> sumn += a <NEWLINE> <NL> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> henka = ( c - b ) * N_list [ b ] <NEWLINE> <NL> sumn += henka <NEWLINE> <NL> N_list [ c ] += N_list [ b ] <NEWLINE> N_list [ b ] = 0 <NEWLINE> <NL> print ( sumn ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> count = 0 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> count = 1 <NEWLINE> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if count == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> cnt = 1 <NEWLINE> ans = 7 <NEWLINE> mul = 70 % k <NEWLINE> ans %= k <NEWLINE> flags = [ False ] * k <NEWLINE> flags [ ans ] = True <NEWLINE> while ans != 0 : <NEWLINE> <INDENT> ans += mul <NEWLINE> cnt += 1 <NEWLINE> ans %= k <NEWLINE> mul *= 10 <NEWLINE> mul %= k <NEWLINE> if flags [ ans ] : <NEWLINE> <INDENT> cnt = - 1 <NEWLINE> break <NEWLINE> <DEDENT> flags [ ans ] = True <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> x = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> t = 1 <NEWLINE> for num in x : <NEWLINE> <INDENT> t = t * num <NEWLINE> if t > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ( t > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if 0 <= z <= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> T = str ( input ( ) ) <NEWLINE> mini = [ ] <NEWLINE> <NL> if len ( S ) != len ( T ) : <NEWLINE> <INDENT> for i in range ( len ( S ) - len ( T ) ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ j ] == S [ j + i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> mini . append ( len ( T ) - count ) <NEWLINE> <DEDENT> print ( min ( mini ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if T [ i ] == S [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( len ( T ) - count ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> N = int ( N ) <NEWLINE> l = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> flg = 1 <NEWLINE> ma = 0 <NEWLINE> mi = 0 <NEWLINE> for i in range ( 1 , len ( l ) ) : <NEWLINE> <INDENT> if ( mi > l [ i - 1 ] or flg == 1 ) : <NEWLINE> <INDENT> mi = l [ i - 1 ] <NEWLINE> <DEDENT> if ( ma < l [ i ] - mi or flg == 1 ) : <NEWLINE> <INDENT> ma = l [ i ] - mi <NEWLINE> flg = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ma ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> input = sys . stdin . readline <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = ( np . array ( [ list ( input ( ) . strip ( ) ) for _ in range ( h ) ] ) == <STRING> ) . astype ( np . int ) <NEWLINE> l , r , u , d = s . copy ( ) , s . copy ( ) , s . copy ( ) , s . copy ( ) <NEWLINE> for i in range ( 1 , w ) : <NEWLINE> <INDENT> l [ : , i ] *= l [ : , i - 1 ] + 1 <NEWLINE> r [ : , w - i - 1 ] *= r [ : , w - i ] + 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , h ) : <NEWLINE> <INDENT> u [ i ] *= u [ i - 1 ] + 1 <NEWLINE> d [ h - i - 1 ] *= d [ h - i ] + 1 <NEWLINE> <DEDENT> print ( max ( [ max ( i ) for i in l + r + u + d - 3 ] ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> def is_loadable ( load , num_truck , w_list ) : <NEWLINE> <NL> <INDENT> excess = load * num_truck - sum ( w_list ) <NEWLINE> <COMMENT> <NL> cur_load = 0 <NEWLINE> <COMMENT> <NL> for w in w_list : <NEWLINE> <COMMENT> <NL> <INDENT> if cur_load + w < load : <NEWLINE> <INDENT> cur_load += w <NEWLINE> <DEDENT> elif cur_load + w == load : <NEWLINE> <COMMENT> <NL> <INDENT> cur_load = 0 <NEWLINE> num_truck -= 1 <NEWLINE> if num_truck < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> num_truck -= 1 <NEWLINE> if num_truck < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> excess += load - cur_load <NEWLINE> if excess < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> cur_load = w <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if ( cur_load and num_truck == 0 ) : <NEWLINE> <INDENT> return False <NEWLINE> <COMMENT> <NL> <DEDENT> return True <NEWLINE> <NL> <DEDENT> n , num_truck = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> weight = list ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> weight . append ( int ( sys . stdin . readline ( ) ) ) <NEWLINE> <NL> <DEDENT> ave_w = sum ( weight ) / num_truck <NEWLINE> max_w = max ( weight ) <NEWLINE> load = max ( max_w , math . ceil ( ave_w ) ) <NEWLINE> max_ng = load - 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if is_loadable ( load , num_truck , weight ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> min_ng = load <NEWLINE> load += 1024 <NEWLINE> <NL> <DEDENT> min_ok = load <NEWLINE> while True : <NEWLINE> <INDENT> if min_ok == max_ng + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> load = ( max_ng + min_ok ) // 2 <NEWLINE> if is_loadable ( load , num_truck , weight ) : <NEWLINE> <INDENT> min_ok = load <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_ng = load <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min_ok ) <NEWLINE> <NL>
MAX = 10 ** 18 <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N = map ( int , input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > MAX : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def test ( m ) : <NEWLINE> <INDENT> if m <= 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> needed = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> needed += ( a - 1 ) // m <NEWLINE> if needed > K : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> lb = 1 <NEWLINE> ub = max ( A ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> m = ( lb + ub ) // 2 <NEWLINE> if test ( m ) : <NEWLINE> <INDENT> if test ( m - 1 ) : <NEWLINE> <INDENT> ub = m - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> lb = m + 1 <NEWLINE> <DEDENT> <DEDENT>
import queue <NEWLINE> def allvisited ( ) : <NEWLINE> <INDENT> for i in range ( w ) : <NEWLINE> <INDENT> for j in range ( h ) : <NEWLINE> <INDENT> if ( visited [ i ] [ j ] == False and s [ i ] [ j ] == <STRING> ) : <NEWLINE> <INDENT> return ( False , i , j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return ( True , - 1 , - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def legal ( pos ) : <NEWLINE> <INDENT> if ( 0 <= pos [ 0 ] < w ) and ( 0 <= pos [ 1 ] < h ) and s [ pos [ 0 ] ] [ pos [ 1 ] ] == <STRING> and visited [ pos [ 0 ] ] [ pos [ 1 ] ] == False : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> d = [ [ 0 , 1 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ - 1 , 0 ] , [ 1 , 1 ] , [ - 1 , 1 ] , [ 1 , - 1 ] , [ - 1 , - 1 ] ] <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> h , w = map ( eval , input ( ) . split ( ) ) <NEWLINE> if ( w == 0 and h == 0 ) : break <NEWLINE> s = [ ] <NEWLINE> for i in range ( w ) : <NEWLINE> <INDENT> s . append ( input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> Q = queue . Queue ( ) <NEWLINE> visited = [ ] <NEWLINE> for i in range ( w ) : <NEWLINE> <INDENT> visited . append ( [ False ] * h ) <NEWLINE> <COMMENT> <NL> <DEDENT> count = 0 <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> a = allvisited ( ) <NEWLINE> if ( a [ 0 ] == False ) : <NEWLINE> <INDENT> Q . put ( ( a [ 1 ] , a [ 2 ] ) ) <NEWLINE> visited [ a [ 1 ] ] [ a [ 2 ] ] = True <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while ( not Q . empty ( ) ) : <NEWLINE> <INDENT> now = Q . get ( ) <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> new = ( now [ 0 ] + d [ i ] [ 0 ] , now [ 1 ] + d [ i ] [ 1 ] ) <NEWLINE> if ( legal ( new ) ) : <NEWLINE> <INDENT> Q . put ( new ) <NEWLINE> visited [ new [ 0 ] ] [ new [ 1 ] ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
z = input ( ) <NEWLINE> a , b = z . split ( ) <NEWLINE> a1 = int ( a ) <NEWLINE> b1 = int ( b ) <NEWLINE> <NL> if a1 < b1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif a1 > b1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = [ float ( temp ) for temp in input ( ) . split ( ) ] <NEWLINE> from math import sqrt <NEWLINE> dis = sqrt ( ( c - a ) ** 2 + ( d - b ) ** 2 ) <NEWLINE> print ( <STRING> % dis ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd , log <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> N = INT ( ) <NEWLINE> a = LIST ( ) <NEWLINE> <NL> all_xor = a [ 0 ] <NEWLINE> for x in a [ 1 : ] : <NEWLINE> <INDENT> all_xor ^= x <NEWLINE> <NL> <DEDENT> for x in a : <NEWLINE> <INDENT> print ( all_xor ^ x , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> connect = [ [ ] for i in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> connect [ A - 1 ] . append ( H [ B - 1 ] ) <NEWLINE> connect [ B - 1 ] . append ( H [ A - 1 ] ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if not connect [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> elif H [ i ] > max ( connect [ i ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from collections import deque <NEWLINE> n , m , * AB = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n ) ] <NEWLINE> for a , b in zip ( AB [ : : 2 ] , AB [ 1 : : 2 ] ) : <NEWLINE> <INDENT> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> d = [ 0 ] * n <NEWLINE> queue = deque ( [ 0 ] ) <NEWLINE> while queue : <NEWLINE> <INDENT> current_node = queue . popleft ( ) <NEWLINE> for next_node in graph [ current_node ] : <NEWLINE> <INDENT> if d [ next_node ] == 0 : <NEWLINE> <INDENT> d [ next_node ] = current_node + 1 <NEWLINE> queue . append ( next_node ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * d [ 1 : ] , sep = <STRING> ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( A ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
import functools <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> while ( n ) : <NEWLINE> <INDENT> bottom_record = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . append ( functools . reduce ( lambda x , y : x + y , l ) ) <NEWLINE> bottom_record = [ x + y for ( x , y ) in zip ( bottom_record , l ) ] <NEWLINE> print ( <STRING> . join ( map ( <STRING> . format , l ) ) ) <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( <STRING> . format , bottom_record ) ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> <DEDENT>
from bisect import bisect_right <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> p2D = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> def II ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def SI ( ) : return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> def pf ( x ) : <NEWLINE> <INDENT> ee = [ ] <NEWLINE> pp = [ ] <NEWLINE> if x & 1 == 0 : <NEWLINE> <INDENT> k = ( x & - x ) . bit_length ( ) - 1 <NEWLINE> pp . append ( 2 ) <NEWLINE> ee . append ( k ) <NEWLINE> x >>= k <NEWLINE> <DEDENT> d = 3 <NEWLINE> while d ** 2 <= x : <NEWLINE> <INDENT> while x % d == 0 : <NEWLINE> <INDENT> x //= d <NEWLINE> if pp and pp [ - 1 ] == d : ee [ - 1 ] += 1 <NEWLINE> else : <NEWLINE> <INDENT> pp . append ( d ) <NEWLINE> ee . append ( 1 ) <NEWLINE> <DEDENT> <DEDENT> d += 2 <NEWLINE> <NL> <DEDENT> if x > 1 : <NEWLINE> <INDENT> if pp and pp [ - 1 ] == x : ee [ - 1 ] += 1 <NEWLINE> else : ee . append ( 1 ) <NEWLINE> <NL> <DEDENT> return ee <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = II ( ) <NEWLINE> ss = [ 1 ] <NEWLINE> for a in range ( 2 , 45 ) : ss . append ( ss [ - 1 ] + a ) <NEWLINE> <COMMENT> <NL> ee = pf ( n ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> for e in ee : <NEWLINE> <INDENT> i = bisect_right ( ss , e ) <NEWLINE> ans += i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> list1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> ss = sum ( list1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = list1 [ i ] <NEWLINE> ss = ss - a <NEWLINE> p = a * ss <NEWLINE> s += p <NEWLINE> <DEDENT> print ( s % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> R = [ ] <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> R . insert ( i , int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> m = min ( R [ 0 : 2 ] ) <NEWLINE> MAX = R [ 1 ] - R [ 0 ] <NEWLINE> for r in range ( 2 , n ) : <NEWLINE> <INDENT> if ( R [ r - 1 ] < m ) : <NEWLINE> <INDENT> m = R [ r - 1 ] <NEWLINE> <DEDENT> MAX2 = R [ r ] - m <NEWLINE> if ( MAX2 > MAX ) : <NEWLINE> <INDENT> MAX = MAX2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( MAX ) <NEWLINE>
<COMMENT> <NL> def hanbun ( L ) : <NEWLINE> <INDENT> N = len ( L ) <NEWLINE> flag = N % 2 <NEWLINE> N = N // 2 <NEWLINE> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans . append ( L [ 2 * i ] * L [ 2 * i + 1 ] ) <NEWLINE> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> ans . append ( L [ - 1 ] ) <NEWLINE> <DEDENT> return ( ans ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> while len ( A ) > 1 : <NEWLINE> <INDENT> A = hanbun ( A ) <NEWLINE> <DEDENT> ans = A [ 0 ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num = 1 <NEWLINE> li = [ 1 ] <NEWLINE> flag = [ True ] * n <NEWLINE> flag [ 0 ] = False <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> num = a [ num ] <NEWLINE> if flag [ num - 1 ] : <NEWLINE> <INDENT> li . append ( num ) <NEWLINE> flag [ num - 1 ] = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> d = li . index ( num ) <NEWLINE> ans = ( k - d ) % ( len ( li ) - d ) + d <NEWLINE> <NL> print ( li [ ans ] ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> def ii ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def mi ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def li2 ( N ) : return [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> def dp2 ( ini , i , j ) : return [ [ ini ] * i for i2 in range ( j ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from itertools import accumulate <COMMENT> <NEWLINE> import math <NEWLINE> <NL> N , K = mi ( ) <NEWLINE> A = li ( ) <NEWLINE> <NL> if K == 0 : <NEWLINE> <INDENT> print ( max ( A ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> left = 0 <NEWLINE> right = max ( A ) <NEWLINE> <NL> def count ( num ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> cnt += math . ceil ( A [ i ] / num ) - 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if mid == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> tmp = count ( mid ) <NEWLINE> if right - left <= 1 : <NEWLINE> <INDENT> mid = right <NEWLINE> break <NEWLINE> <DEDENT> elif tmp > K : <NEWLINE> <INDENT> left = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = mid <NEWLINE> <NL> <DEDENT> <DEDENT> right = mid <NEWLINE> <NL> while True : <NEWLINE> <INDENT> tmp = count ( mid ) <NEWLINE> if tmp == K and tmp != count ( mid - 1 ) : <NEWLINE> <INDENT> print ( mid ) <NEWLINE> break <NEWLINE> <DEDENT> elif tmp == K : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if left == mid : <NEWLINE> <INDENT> print ( right ) <NEWLINE> break <NEWLINE> <DEDENT> left = mid <NEWLINE> <DEDENT> mid = ( left + right ) // 2 <NEWLINE> if mid == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
def cal ( S ) : <NEWLINE> <INDENT> N = len ( S ) <NEWLINE> num , cnt = 0 , 0 <NEWLINE> mod = 2019 <NEWLINE> rem = [ 0 for _ in range ( mod ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> num = ( num + int ( S [ N - 1 - i ] ) * pow ( 10 , i , mod ) ) % mod <NEWLINE> rem [ num ] += 1 <NEWLINE> <NL> <DEDENT> output = rem [ 0 ] * ( rem [ 0 ] + 1 ) // 2 <NEWLINE> for i in range ( 1 , mod ) : <NEWLINE> <INDENT> output += rem [ i ] * ( rem [ i ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> return output <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> <NL> print ( cal ( S ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ A ] . append ( B ) <NEWLINE> graph [ B ] . append ( A ) <NEWLINE> <NL> <DEDENT> dist = [ - 1 ] * ( N + 1 ) <NEWLINE> dist [ 0 ] = 0 <NEWLINE> dist [ 1 ] = 0 <NEWLINE> <NL> D = deque ( ) <NEWLINE> D . append ( 1 ) <NEWLINE> <NL> while D : <NEWLINE> <INDENT> V = D . popleft ( ) <NEWLINE> for i in graph [ V ] : <NEWLINE> <INDENT> if dist [ i ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ i ] = V <NEWLINE> D . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for j in dist [ 2 : ] : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <NL> n = int ( readline ( ) ) <NEWLINE> csf = [ tuple ( map ( int , readline ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> now = 0 <NEWLINE> for c , s , f in csf [ i : : ] : <NEWLINE> <INDENT> if now <= s : <NEWLINE> <INDENT> now = s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if now % f == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now = ( now // f + 1 ) * f <NEWLINE> <DEDENT> <DEDENT> now += c <NEWLINE> <DEDENT> print ( now ) <NEWLINE> <DEDENT>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> visited = [ 1 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> next = a [ visited [ - 1 ] ] <NEWLINE> visited . append ( next ) <NEWLINE> <NL> <DEDENT> loop_end = n <NEWLINE> loop_start = n - 1 <NEWLINE> while visited [ loop_start ] != visited [ loop_end ] : <NEWLINE> <INDENT> loop_start -= 1 <NEWLINE> <DEDENT> period = loop_end - loop_start <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if k < n + 1 : <NEWLINE> <INDENT> print ( visited [ k ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( visited [ n - period + ( k - n ) % period ] ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> L = len ( S ) <NEWLINE> <NL> if L != 26 : <NEWLINE> <COMMENT> <NL> <INDENT> USED = [ False ] * 26 <NEWLINE> for s in S : <NEWLINE> <INDENT> USED [ ord ( s ) - 97 ] = True <NEWLINE> <NL> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> if not USED [ i ] : <NEWLINE> <INDENT> S . append ( chr ( 97 + i ) ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( S ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> prev = - 1 <NEWLINE> k = - 1 <NEWLINE> USED = [ ] <NEWLINE> for i in range ( 26 ) [ : : - 1 ] : <NEWLINE> <INDENT> d = ord ( S [ i ] ) - 97 <NEWLINE> if prev < d : <NEWLINE> <INDENT> prev = d <NEWLINE> USED . append ( S [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if k == - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nxt = min ( [ s for s in USED if s > S [ k ] ] ) <NEWLINE> S = S [ : k ] + [ nxt ] <NEWLINE> print ( <STRING> . join ( S ) ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> As = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> flgs = np . full ( 10 ** 6 + 1 , False ) <NEWLINE> flgs [ As ] = True <NEWLINE> <NL> for i , A in enumerate ( As ) : <NEWLINE> <INDENT> if flgs [ A ] == True : <NEWLINE> <INDENT> flgs [ : : A ] = False <NEWLINE> if i + 1 == len ( As ) or As [ i + 1 ] != A : <NEWLINE> <INDENT> flgs [ A ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( np . count_nonzero ( flgs ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> dp = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> P = int ( input ( ) ) <NEWLINE> dp_p = list ( map ( lambda x : x + P , dp ) ) <NEWLINE> dp = list ( set ( dp + dp_p ) ) <NEWLINE> <NL> <DEDENT> P_List = [ 0 ] + [ i for i in dp if i % 10 != 0 ] <NEWLINE> print ( max ( P_List ) ) <NEWLINE>
import math as f <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ij = f . gcd ( i , j ) <NEWLINE> if ij == 1 : <NEWLINE> <INDENT> total += K <NEWLINE> continue <NEWLINE> <DEDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> total += f . gcd ( ij , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> amax = max ( A ) <NEWLINE> AA = sorted ( A , key = lambda x : abs ( amax / 2 - x ) ) <NEWLINE> if AA [ 0 ] == amax : <NEWLINE> <INDENT> print ( amax , AA [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( amax , AA [ 0 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> <NL> <DEDENT> A2 = sorted ( A ) <NEWLINE> mx1 = A2 [ - 1 ] <NEWLINE> mx2 = A2 [ - 2 ] <NEWLINE> ind = A . index ( mx1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i != ind : <NEWLINE> <INDENT> print ( mx1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mx2 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * ( i + 1 ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ 0 ] * n <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> s [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in s : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = round ( n ** 0.5 ) <NEWLINE> <NL> while n % x != 0 : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> y = n // x <NEWLINE> print ( len ( str ( max ( x , y ) ) ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = [ 0 ] * ( ( 10 ** 6 ) + 1 ) <NEWLINE> <NL> for elem in a : <NEWLINE> <INDENT> cnt [ elem ] += 1 <NEWLINE> <NL> <DEDENT> unique = [ ] <NEWLINE> <NL> for i in range ( ( 10 ** 6 ) + 1 ) : <NEWLINE> <INDENT> if cnt [ i ] == 1 : <NEWLINE> <INDENT> unique . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = [ 0 ] * ( ( 10 ** 6 ) + 1 ) <NEWLINE> <NL> a = list ( set ( a ) ) <NEWLINE> <NL> for elem in a : <NEWLINE> <INDENT> for m in range ( elem * 2 , ( 10 ** 6 ) + 1 , elem ) : <NEWLINE> <INDENT> cnt [ m ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for elem in unique : <NEWLINE> <INDENT> if cnt [ elem ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for x in arr : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in arr : <NEWLINE> <INDENT> ans *= x <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> def itrsum ( arr ) : <NEWLINE> <INDENT> n = len ( arr ) <NEWLINE> tri = np . array ( [ [ i >= j for i in range ( n ) ] for j in range ( n + 1 ) ] ) <NEWLINE> return np . dot ( tri , arr ) . astype ( <STRING> ) <NEWLINE> <DEDENT> n , w = map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> t = [ list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> w1 = t [ 0 ] [ 0 ] <NEWLINE> <COMMENT> <NL> arr = [ [ x for x in t if x [ 0 ] == w1 + i ] for i in range ( 4 ) ] <NEWLINE> arr = [ l for l in arr ] <NEWLINE> lenarr = list ( map ( len , arr ) ) <NEWLINE> arr0 = [ itrsum ( np . array ( sorted ( [ x [ 0 ] for x in l ] ) , dtype = <STRING> ) ) for l in arr ] <NEWLINE> arr1 = [ itrsum ( np . array ( sorted ( [ x [ 1 ] for x in l ] ) , dtype = <STRING> ) ) for l in arr ] <NEWLINE> <COMMENT> <NL> arr = np . array ( arr ) <NEWLINE> arrw = 0 <NEWLINE> arrv = 0 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> arrw = np . ravel ( arr0 [ i ] . reshape ( lenarr [ i ] + 1 , 1 ) + np . array ( [ arrw ] ) ) <NEWLINE> arrv = np . ravel ( arr1 [ i ] . reshape ( lenarr [ i ] + 1 , 1 ) + np . array ( [ arrv ] ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ansarr = arrv [ arrw <= w ] <NEWLINE> print ( np . max ( ansarr ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ans = ( 1 + ( N - 1 ) ) * ( N - 1 ) // 2 <NEWLINE> <NL> print ( ans ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ 0 for i in range ( 10 ** 5 + 2 ) ] <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> cnt [ i + 1 ] += 1 <NEWLINE> cnt [ i + 2 ] += 1 <NEWLINE> <NL> <DEDENT> print ( max ( cnt ) ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> from collections import Counter <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> As = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> <NL> i_plus_As = [ ( i + 1 ) + As [ i ] for i in range ( N ) ] <NEWLINE> counter = Counter ( i_plus_As ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> i_value = ( i + 1 ) - As [ i ] <NEWLINE> if i_value <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> ans += counter [ i_value ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> sys . exit ( main ( ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import numpy as np <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> T_Height = [ int ( h ) for h in input ( ) . split ( ) ] <NEWLINE> <NL> Roads = [ 0 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> b_h = T_Height [ b - 1 ] <NEWLINE> a_h = T_Height [ a - 1 ] <NEWLINE> if b_h > Roads [ a - 1 ] : <NEWLINE> <INDENT> Roads [ a - 1 ] = b_h <NEWLINE> <DEDENT> if a_h > Roads [ b - 1 ] : <NEWLINE> <INDENT> Roads [ b - 1 ] = a_h <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> i = 0 <NEWLINE> ans = 0 <NEWLINE> for e in Roads : <NEWLINE> <INDENT> if T_Height [ i ] > e : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> total += gcd ( gcd ( i , j ) , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
N = 5 <NEWLINE> ARR = [ 24 , 11 , 8 , 3 , 16 ] <NEWLINE> <NL> <NL> N = 4 <NEWLINE> ARR = [ 5 , 5 , 5 , 5 ] <NEWLINE> <NL> <NL> N = 10 <NEWLINE> ARR = [ 33 , 18 , 45 , 28 , 8 , 19 , 89 , 86 , 2 , 4 ] <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> ARR = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def calculate ( n , arr ) : <NEWLINE> <NL> <INDENT> prr = [ 0 for i in range ( 2000005 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> start = arr [ i ] <NEWLINE> <COMMENT> <NL> if prr [ start ] > 0 : <NEWLINE> <INDENT> prr [ start ] = 2 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> for j in range ( start , 2000005 , start ) : <NEWLINE> <INDENT> prr [ j ] = prr [ j ] + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> result = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> start = arr [ i ] <NEWLINE> if prr [ start ] == 1 : <NEWLINE> <INDENT> result += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <DEDENT> calculate ( N , ARR ) <NEWLINE>
def hondan ( w , m ) : <NEWLINE> <INDENT> m_sum = b_lis [ 0 ] <NEWLINE> num = 0 <NEWLINE> if w < max ( b_lis ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( b_lis ) - 1 ) : <NEWLINE> <INDENT> m_sum += b_lis [ i + 1 ] <NEWLINE> if m_sum > w : <NEWLINE> <NL> <INDENT> m_sum = b_lis [ i + 1 ] <NEWLINE> num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if num < m : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def nibutan ( f_id , e_id , m ) : <NEWLINE> <NL> <NL> <INDENT> m_id = int ( ( f_id + e_id ) / 2 ) <NEWLINE> m_bo = hondan ( m_id , m ) <NEWLINE> <NL> <NL> if ( f_id > e_id ) : <NEWLINE> <INDENT> return m_id + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if m_bo : <NEWLINE> <INDENT> return ( nibutan ( f_id , m_id - 1 , m ) ) <NEWLINE> <DEDENT> elif not m_bo : <NEWLINE> <INDENT> return ( nibutan ( m_id + 1 , e_id , m ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return m_id + 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> global w_lis <NEWLINE> b_lis = [ ] <NEWLINE> w_lis = [ ] <NEWLINE> dan_num = [ 0 ] <NEWLINE> <NL> m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> b_lis . append ( num ) <NEWLINE> <DEDENT> s_num = int ( sum ( b_lis ) / m ) <NEWLINE> <NL> print ( nibutan ( s_num , 1500000 , m ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def BinarySearch ( S , n , t ) : <NEWLINE> <INDENT> bottom = 0 <NEWLINE> top = n - 1 <NEWLINE> <NL> while bottom <= top : <NEWLINE> <INDENT> center = ( bottom + top ) // 2 <NEWLINE> <NL> if S [ center ] == t : <NEWLINE> <INDENT> return center <NEWLINE> <DEDENT> elif S [ center ] < t : <NEWLINE> <INDENT> bottom = center + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> top = center - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <NL> <DEDENT> n = int ( sys . stdin . readline ( ) ) <NEWLINE> S = [ int ( s ) for s in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> <NL> q = int ( sys . stdin . readline ( ) ) <NEWLINE> T = { int ( t ) for t in sys . stdin . readline ( ) . split ( ) } <NEWLINE> <NL> ans = sum ( BinarySearch ( S , n , t ) != - 1 for t in T ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
import sys , os , math , bisect , itertools , collections , heapq , queue , copy , array <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N , M = il ( ) <NEWLINE> <NL> ret = 0 <NEWLINE> if N * 2 <= M : <NEWLINE> <INDENT> ret += N <NEWLINE> ret += ( M - N * 2 ) // 4 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret += M // 2 <NEWLINE> <DEDENT> print ( ret ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
dic = set ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> cmd = [ list ( input ( ) . split ( ) ) for i in range ( n ) ] <NEWLINE> for c , l in cmd : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> dic . add ( l ) <NEWLINE> <DEDENT> if c == <STRING> : <NEWLINE> <INDENT> if l in dic : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> def isPrime ( x ) : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> if x < 2 or x % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> i = 3 <NEWLINE> while i <= math . sqrt ( x ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i += 2 <NEWLINE> <NL> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> nums = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> nums . append ( x ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for num in nums : <NEWLINE> <INDENT> if isPrime ( num ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> from sys import stdin <NEWLINE> from collections import deque <NEWLINE> input = stdin . readline <NEWLINE> <NL> <NL> def fb_gen ( count = 1 ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if count % 15 == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif count % 5 == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif count % 3 == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = str ( count ) <NEWLINE> <DEDENT> yield ans <NEWLINE> count += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( args ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == 0 and n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> players = deque ( range ( 1 , m + 1 ) ) <NEWLINE> fb = fb_gen ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> p = input ( ) . strip ( ) <NEWLINE> if p != fb . __next__ ( ) : <NEWLINE> <INDENT> if len ( players ) > 1 : <NEWLINE> <INDENT> players . popleft ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> players . rotate ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> result = list ( players ) <NEWLINE> result . sort ( ) <NEWLINE> print ( * result ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> ksum = 0 <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> m = n // k <NEWLINE> ksum += k * m * ( m + 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ksum ) <NEWLINE>
class Trees ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . nodes = { } <NEWLINE> <DEDENT> def add_nodes ( self , id ) : <NEWLINE> <INDENT> if id not in self . nodes : <NEWLINE> <INDENT> self . nodes [ id ] = Node ( id ) <NEWLINE> <DEDENT> <DEDENT> def add_child ( self , id , child_id1 , child_id2 ) : <NEWLINE> <INDENT> for child_id in [ child_id1 , child_id2 ] : <NEWLINE> <INDENT> if child_id != - 1 : <NEWLINE> <INDENT> self . add_nodes ( child_id ) <NEWLINE> self . nodes [ id ] . add_child_id ( self . nodes [ child_id ] ) <NEWLINE> <DEDENT> <DEDENT> if child_id1 != - 1 : <NEWLINE> <INDENT> self . nodes [ child_id1 ] . sibling = child_id2 <NEWLINE> <DEDENT> if child_id2 != - 1 : <NEWLINE> <INDENT> self . nodes [ child_id2 ] . sibling = child_id1 <NEWLINE> <DEDENT> self . nodes [ id ] . left = child_id1 <NEWLINE> self . nodes [ id ] . right = child_id2 <NEWLINE> <DEDENT> def setheight ( self , id ) : <NEWLINE> <INDENT> h1 , h2 = 0 , 0 <NEWLINE> if self . nodes [ id ] . right != - 1 : <NEWLINE> <INDENT> h1 = self . setheight ( self . nodes [ id ] . right ) + 1 <NEWLINE> <DEDENT> if self . nodes [ id ] . left != - 1 : <NEWLINE> <INDENT> h2 = self . setheight ( self . nodes [ id ] . left ) + 1 <NEWLINE> <DEDENT> self . nodes [ id ] . height = max ( h1 , h2 ) <NEWLINE> return max ( h1 , h2 ) <NEWLINE> <DEDENT> def preorder ( self , u ) : <NEWLINE> <INDENT> if u == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> self . preorder ( self . nodes [ u ] . left ) <NEWLINE> self . preorder ( self . nodes [ u ] . right ) <NEWLINE> <NL> <DEDENT> def inorder ( self , u ) : <NEWLINE> <INDENT> if u == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> self . inorder ( self . nodes [ u ] . left ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> self . inorder ( self . nodes [ u ] . right ) <NEWLINE> <DEDENT> def postorder ( self , u ) : <NEWLINE> <INDENT> if u == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> self . postorder ( self . nodes [ u ] . left ) <NEWLINE> self . postorder ( self . nodes [ u ] . right ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , id ) : <NEWLINE> <INDENT> self . node = id <NEWLINE> self . parent = None <NEWLINE> self . depth = 0 <NEWLINE> self . nodetype = <STRING> <NEWLINE> self . children = [ ] <NEWLINE> self . sibling = - 1 <NEWLINE> self . degree = 0 <NEWLINE> self . height = 0 <NEWLINE> self . left = - 1 <NEWLINE> self . right = - 1 <NEWLINE> <NL> <DEDENT> def add_child_id ( self , child ) : <NEWLINE> <INDENT> child . parent = self <NEWLINE> self . children . append ( child ) <NEWLINE> child . update_depth ( ) <NEWLINE> self . update_nodetype ( ) <NEWLINE> child . update_nodetype ( ) <NEWLINE> self . degree += 1 <NEWLINE> <NL> <NL> <DEDENT> def update_depth ( self ) : <NEWLINE> <INDENT> depth = self . depth <NEWLINE> if self . parent : <NEWLINE> <INDENT> self . depth = self . parent . depth + 1 <NEWLINE> <DEDENT> if depth != self . depth : <NEWLINE> <INDENT> for child in self . children : <NEWLINE> <INDENT> child . update_depth ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def update_nodetype ( self ) : <NEWLINE> <INDENT> if self . depth == 0 : <NEWLINE> <INDENT> self . nodetype = <STRING> <NEWLINE> <DEDENT> elif len ( self . children ) > 0 : <NEWLINE> <INDENT> self . nodetype = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . nodetype = <STRING> <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> parent = self . parent . node if self . parent else - 1 <NEWLINE> return <STRING> . format ( <NEWLINE> <INDENT> self . node , parent , self . sibling , self . degree , self . depth , self . height , self . nodetype ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> tree = Trees ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> top = [ 0 for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tree . add_nodes ( a [ 0 ] ) <NEWLINE> tree . add_child ( id = a [ 0 ] , child_id1 = a [ 1 ] , child_id2 = a [ 2 ] ) <NEWLINE> if a [ 1 ] != - 1 : <NEWLINE> <INDENT> top [ a [ 1 ] ] += 1 <NEWLINE> <DEDENT> if a [ 2 ] != - 1 : <NEWLINE> <INDENT> top [ a [ 2 ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for id in range ( n ) : <NEWLINE> <INDENT> tree . setheight ( id ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if top [ i ] == 0 : <NEWLINE> <INDENT> b = i <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> tree . preorder ( b ) <NEWLINE> print ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> tree . inorder ( b ) <NEWLINE> print ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> tree . postorder ( b ) <NEWLINE> print ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 1 <NEWLINE> <NL> if 0 in num_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in num_list : <NEWLINE> <NL> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> i = str ( i ) <NEWLINE> sum = str ( sum ) <NEWLINE> <NL> if len ( i ) + len ( sum ) > 21 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> i = int ( i ) <NEWLINE> sum = int ( sum ) <NEWLINE> sum = sum * i <NEWLINE> if sum > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( list ( A ) ) <NEWLINE> <NL> import bisect <NEWLINE> <NL> ans = A [ - 1 ] / 2 <NEWLINE> b = bisect . bisect_left ( A , ans ) <NEWLINE> <NL> if abs ( ans - A [ b ] ) < abs ( ans - A [ max ( 0 , b - 1 ) ] ) : <NEWLINE> <INDENT> print ( A [ - 1 ] , A [ b ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A [ - 1 ] , A [ b - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> s = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> ls = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if s [ i ] % 10 != 0 : <NEWLINE> <INDENT> ls . append ( s [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ls . sort ( ) <NEWLINE> <NL> base = sum ( s ) <NEWLINE> <NL> if base % 10 != 0 : <NEWLINE> <INDENT> print ( base ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if ls : <NEWLINE> <INDENT> print ( base - ls [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A_list : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for A in A_list : <NEWLINE> <INDENT> ans *= A <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> SUM = sum ( A ) <NEWLINE> res = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> SUM -= A [ i ] <NEWLINE> res += A [ i ] * SUM <NEWLINE> <DEDENT> print ( res % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cumsum_a = a . copy ( ) <NEWLINE> <NL> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> cumsum_a [ i ] += cumsum_a [ i + 1 ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> childable_node = 1 <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > childable_node : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> ans += childable_node <NEWLINE> <NL> if i < n : <NEWLINE> <INDENT> b_max1 = 2 * ( childable_node - a [ i ] ) <NEWLINE> b_max2 = cumsum_a [ i + 1 ] <NEWLINE> childable_node = min ( b_max1 , b_max2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> ans = list ( ) <NEWLINE> for a in range ( 0 , n + 1 , 1 ) : <NEWLINE> <INDENT> for b in range ( 0 , n + 1 , 1 ) : <NEWLINE> <INDENT> if a + b <= n : <NEWLINE> <INDENT> c = n - ( a + b ) <NEWLINE> total = a * 10000 + b * 5000 + c * 1000 <NEWLINE> if total == y : <NEWLINE> <INDENT> lists = [ a , b , c ] <NEWLINE> ans . append ( lists ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans == [ ] : <NEWLINE> <INDENT> answer = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> answer = <STRING> . join ( answer ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = [ str ( i ) for i in ans [ 0 ] ] <NEWLINE> answer = <STRING> . join ( answer ) <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flag = 0 <NEWLINE> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if flag == 0 : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> <DEDENT> if ans > 10 ** 18 and flag != 2 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> flag = 2 <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> elif flag == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> S = sum ( A ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S -= A [ i ] <NEWLINE> ans += A [ i ] * S % P <NEWLINE> <DEDENT> print ( ans % P ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> pi = math . pi <NEWLINE> print ( <STRING> % ( r * r * pi , 2 * r * pi ) ) <NEWLINE>
import sys <NEWLINE> import bisect <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n , c , k = [ int ( w ) for w in input ( ) . split ( ) ] <NEWLINE> la = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> la . sort ( ) <NEWLINE> lak = [ a + k for a in la ] <NEWLINE> <NL> ind = 0 <NEWLINE> ans = 0 <NEWLINE> while ind < n : <NEWLINE> <INDENT> ride = bisect . bisect_right ( la , lak [ ind ] ) - ind <NEWLINE> ind += min ( ride , c ) <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> n , m , S , T = open ( 0 ) . read ( ) . split ( ) <NEWLINE> n , m = int ( n ) , int ( m ) <NEWLINE> l = n * m // gcd ( n , m ) <NEWLINE> <NL> d = { } <NEWLINE> t = l // n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d [ i * t ] = S [ i ] <NEWLINE> <DEDENT> t = l // m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if i * t not in d or d [ i * t ] == T [ i ] : <NEWLINE> <INDENT> d [ i * t ] = T [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> res = 0 <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i + k ] - a [ i ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import heapq <NEWLINE> def main ( ) : <NEWLINE> <INDENT> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> bn_h = { } <NEWLINE> bn_v = { } <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> bn_h . setdefault ( h , set ( ) ) <NEWLINE> bn_h [ h ] . add ( w ) <NEWLINE> bn_v . setdefault ( w , set ( ) ) <NEWLINE> bn_v [ w ] . add ( h ) <NEWLINE> <NL> <DEDENT> b1 = sorted ( bn_h . items ( ) , key = lambda x : len ( x [ 1 ] ) , reverse = True ) <NEWLINE> b2 = sorted ( bn_v . items ( ) , key = lambda x : len ( x [ 1 ] ) , reverse = True ) <NEWLINE> <NL> m1 = len ( b1 [ 0 ] [ 1 ] ) <NEWLINE> m2 = len ( b2 [ 0 ] [ 1 ] ) <NEWLINE> <NL> flag = False <NEWLINE> max_result = 0 <NEWLINE> for i in b1 : <NEWLINE> <INDENT> h , sh = i <NEWLINE> if len ( sh ) < m1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in b2 : <NEWLINE> <INDENT> v , sv = j <NEWLINE> if len ( sv ) < m2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> result = len ( sh ) + len ( sv ) - 1 <NEWLINE> if h not in sv : <NEWLINE> <INDENT> result += 1 <NEWLINE> flag = True <NEWLINE> <DEDENT> max_result = max ( max_result , result ) <NEWLINE> if flag == True : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( max_result ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import numba <NEWLINE> import math <NEWLINE> <NL> @ numba . njit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> dpt = np . array ( [ math . inf ] * ( 10 ** 3 * N + 1 ) ) <NEWLINE> dpt [ 0 ] = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( len ( dpt ) - 1 , items [ i ] [ 1 ] - 1 , - 1 ) : <NEWLINE> <INDENT> dpt [ j ] = min ( dpt [ j ] , dpt [ j - items [ i ] [ 1 ] ] + items [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( dpt ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if dpt [ i ] <= W : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> items = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] ) <NEWLINE> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> z_max = 0 <NEWLINE> z_min = 2 * 10 ** 9 <NEWLINE> <NL> w_max = - 10 ** 9 <NEWLINE> w_min = 10 ** 9 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> z = xy [ i ] [ 0 ] + xy [ i ] [ 1 ] <NEWLINE> w = xy [ i ] [ 0 ] - xy [ i ] [ 1 ] <NEWLINE> z_max = max ( z_max , z ) <NEWLINE> z_min = min ( z_min , z ) <NEWLINE> w_max = max ( w_max , w ) <NEWLINE> w_min = min ( w_min , w ) <NEWLINE> <NL> <DEDENT> res = max ( z_max - z_min , w_max - w_min ) <NEWLINE> <NL> print ( res ) <NEWLINE> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] + a [ i + 1 ] > x : <NEWLINE> <INDENT> y = a [ i ] + a [ i + 1 ] - x <NEWLINE> count += y <NEWLINE> a [ i + 1 ] = max ( 0 , a [ i + 1 ] - y ) <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from itertools import accumulate <NEWLINE> n = int ( input ( ) ) <NEWLINE> * a , = map ( int , input ( ) . split ( ) ) <NEWLINE> cumsum = [ 0 ] + list ( accumulate ( a ) ) <NEWLINE> ans = sum ( a [ i ] * cumsum [ i ] for i in range ( n ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> print ( ans % mod ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> x = 10 <NEWLINE> y = int ( x * 8 / 100 ) <NEWLINE> z = int ( x * 10 / 100 ) <NEWLINE> i = 0 <NEWLINE> while x < 10000 : <NEWLINE> <INDENT> if int ( x * 8 / 100 ) == a and int ( x * 10 / 100 ) == b : <NEWLINE> <INDENT> print ( x ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x + 1 <NEWLINE> <DEDENT> <DEDENT> if x == 10000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t1 = [ ] <NEWLINE> t2 = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t1 . append ( l [ i ] + i ) <NEWLINE> t2 . append ( i - l [ i ] ) <NEWLINE> <DEDENT> count = { } <NEWLINE> for i in t1 : count [ i ] = 0 <NEWLINE> for i in t2 : count [ i ] = 0 <NEWLINE> for i in t1 : count [ i ] -= - 1 <NEWLINE> ans = 0 <NEWLINE> for i in t2 : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> if count [ i ] != 0 : <NEWLINE> <INDENT> ans += count [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
t = input ( ) <NEWLINE> if ( len ( t ) == 1 ) : <NEWLINE> <INDENT> if ( t [ 0 ] == <STRING> ) : t = <STRING> <NEWLINE> <DEDENT> if ( t [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> if ( t [ 1 ] == <STRING> ) : t = <STRING> . join ( [ <STRING> , t [ 1 : ] ] ) <NEWLINE> elif ( t [ 1 ] == <STRING> ) : t = <STRING> . join ( [ <STRING> , t [ 2 : ] ] ) <NEWLINE> else : t = <STRING> . join ( [ <STRING> , t [ 1 : ] ] ) <NEWLINE> <DEDENT> if ( t [ - 1 ] == <STRING> ) : <NEWLINE> <INDENT> t = <STRING> . join ( [ t [ : - 1 ] , <STRING> ] ) <NEWLINE> <DEDENT> for i in range ( len ( t ) - 1 ) : <NEWLINE> <INDENT> if ( t [ i ] == <STRING> ) : <NEWLINE> <INDENT> if ( t [ i - 1 ] == <STRING> ) : t = <STRING> . join ( [ t [ : i ] , <STRING> , t [ i + 1 : ] ] ) <NEWLINE> elif ( t [ i + 1 ] == <STRING> ) : t = <STRING> . join ( [ t [ : i ] , <STRING> , t [ i + 1 : ] ] ) <NEWLINE> elif ( t [ i + 1 ] == <STRING> ) : t = <STRING> . join ( [ t [ : i ] , <STRING> , t [ i + 1 : ] ] ) <NEWLINE> elif ( t [ i + 1 ] == <STRING> ) : t = <STRING> . join ( [ t [ : i ] , <STRING> , t [ i + 2 : ] ] ) <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
import collections <NEWLINE> <NL> def main ( N , A ) : <NEWLINE> <INDENT> c = collections . Counter ( A ) <NEWLINE> [ print ( c [ i + 1 ] ) for i in range ( max ( c . keys ( ) ) ) ] <NEWLINE> [ print ( 0 ) for i in range ( max ( c . keys ( ) ) , N ) ] <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> main ( N , A ) <NEWLINE> <DEDENT>
def solve ( string ) : <NEWLINE> <INDENT> n , * a = map ( int , string . split ( ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> ans = 1 <NEWLINE> for _a in a : <NEWLINE> <INDENT> ans *= _a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> return str ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> print ( solve ( sys . stdin . read ( ) . strip ( ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> memo = { } <NEWLINE> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= n : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if memo . get ( ( i , m ) , None ) == None : <NEWLINE> <INDENT> memo [ ( i , m ) ] = solve ( i + 1 , m ) or solve ( i + 1 , m - A [ i ] ) <NEWLINE> <DEDENT> return memo [ ( i , m ) ] <NEWLINE> <DEDENT> for m in M : <NEWLINE> <INDENT> if solve ( 0 , m ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , string <NEWLINE> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> n = INT ( ) <NEWLINE> d = LIST ( ) <NEWLINE> m = INT ( ) <NEWLINE> t = LIST ( ) <NEWLINE> d . sort ( ) <NEWLINE> t . sort ( ) <NEWLINE> j = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( d [ i ] == t [ j ] ) : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> if ( j == m ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ( j == m ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> cnt = [ 0 for _ in range ( 10 ** 5 + 1 ) ] <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> cnt [ a ] += 1 <NEWLINE> cnt [ a + 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ a - 1 ] += 1 <NEWLINE> cnt [ a ] += 1 <NEWLINE> cnt [ a + 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( cnt ) ) <NEWLINE>
<COMMENT> <NL> <NL> iim = lambda : map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> X = int ( input ( ) ) <NEWLINE> <NL> if X == 1 : <NEWLINE> <INDENT> print ( 1 , 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> ii = 2 if X % 2 else 1 <NEWLINE> <NL> N = 10 ** 9 <NEWLINE> <NL> for x in range ( 1 , N , ii ) : <NEWLINE> <INDENT> if X % x : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> j = i - x <NEWLINE> <NL> ij = i ** 5 - j ** 5 <NEWLINE> diff = ij - X <NEWLINE> if diff == 0 : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> return <NEWLINE> <DEDENT> elif j > 0 and diff > 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> from math import ceil as C , floor as F , sqrt <NEWLINE> from collections import defaultdict as D , Counter as CNT <NEWLINE> from functools import reduce as R <NEWLINE> <NL> ALP = <STRING> <NEWLINE> alp = <STRING> <NEWLINE> def _X ( ) : return sys . stdin . readline ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> def _S ( ss ) : return tuple ( ss ) if len ( ss ) > 1 else ss [ 0 ] <NEWLINE> def S ( ) : return _S ( _X ( ) ) <NEWLINE> def Ss ( ) : return list ( S ( ) ) <NEWLINE> def _I ( ss ) : return tuple ( [ int ( s ) for s in ss ] ) if isinstance ( ss , tuple ) else int ( ss ) <NEWLINE> def I ( ) : return _I ( S ( ) ) <NEWLINE> def _Is ( ss ) : return list ( ss ) if isinstance ( ss , tuple ) else [ ss ] <NEWLINE> def Is ( ) : return _Is ( I ( ) ) <NEWLINE> <NL> _ , e = I ( ) <NEWLINE> hs = Is ( ) <NEWLINE> <NL> obs = sorted ( [ ( i , h ) for i , h in enumerate ( hs , 1 ) ] , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> seen = D ( bool ) <NEWLINE> <NL> roads = D ( set ) <NEWLINE> for _ in range ( e ) : <NEWLINE> <INDENT> a , b = I ( ) <NEWLINE> roads [ a ] . add ( b ) <NEWLINE> roads [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for ob in obs : <NEWLINE> <INDENT> if not seen [ ob [ 0 ] ] : <NEWLINE> <INDENT> if all ( ob [ 1 ] > hs [ r - 1 ] for r in roads [ ob [ 0 ] ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> seen [ ob [ 0 ] ] = True <NEWLINE> for r in roads [ ob [ 0 ] ] : <NEWLINE> <INDENT> seen [ r ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> <NL> A1 = [ 0 ] * N <NEWLINE> A2 = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> A1 [ i ] = A [ i ] + i <NEWLINE> A2 [ i ] = i - A [ i ] <NEWLINE> <NL> <DEDENT> c = Counter ( A2 ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> cnt += c [ A1 [ i ] ] <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> b = n // a <NEWLINE> if b * a == n : <NEWLINE> <INDENT> b -= 1 <NEWLINE> <DEDENT> ans += b <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> x = l [ 0 ] <NEWLINE> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> x *= l [ i ] <NEWLINE> if x > + 1000000000000000000 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> sur_list = [ 0 for i in range ( 2019 ) ] <NEWLINE> sur = 0 <NEWLINE> keta = 1 <NEWLINE> ans = 0 <NEWLINE> <NL> s . reverse ( ) <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> keta = ( keta * 10 ) % 2019 <NEWLINE> sur_list [ sur ] += 1 <NEWLINE> sur = ( int ( s [ i ] ) * keta + sur ) % 2019 <NEWLINE> ans += sur_list [ sur ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def solve ( N , A ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( A [ i ] == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> solve ( N , A ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = [ int ( w ) for w in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> s = sum ( x ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans += ( ( x [ i ] ) ** 2 ) <NEWLINE> <NL> <DEDENT> ans = ( s ** 2 - ans ) // 2 <NEWLINE> print ( ans % mod ) <NEWLINE>
