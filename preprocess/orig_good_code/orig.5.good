import numba as nb <NEWLINE> import sys <NEWLINE> import numpy as np <NEWLINE> @ nb . njit <NEWLINE> def solve ( w , weight , value ) : <NEWLINE> <INDENT> total = w <NEWLINE> dp = np . zeros ( shape = ( n + 1 , w + 1 ) , dtype = np . int64 ) <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> for w in range ( total + 1 ) : <NEWLINE> <INDENT> if weight [ i ] <= w : <NEWLINE> <INDENT> dp [ i ] [ w ] = max ( value [ i ] + dp [ i - 1 ] [ w - weight [ i ] ] , dp [ i - 1 ] [ w ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ w ] = dp [ i - 1 ] [ w ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ l - 1 ] [ total ] ) <NEWLINE> <DEDENT> n , w = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> weight = [ 0 ] * n <NEWLINE> value = [ 0 ] * n <NEWLINE> total = w <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> weight [ i ] = x <NEWLINE> value [ i ] = y <NEWLINE> <DEDENT> l = len ( weight ) <NEWLINE> solve ( w , weight , value ) <NEWLINE>
from sys import stdin <NEWLINE> nii = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> lnii = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y , h = nii ( ) <NEWLINE> l . append ( [ x , y , h ] ) <NEWLINE> if h != 0 : <NEWLINE> <INDENT> ini_x = x <NEWLINE> ini_y = y <NEWLINE> ini_h = h <NEWLINE> <NL> <DEDENT> <DEDENT> for tx in range ( 101 ) : <NEWLINE> <INDENT> for ty in range ( 101 ) : <NEWLINE> <INDENT> n_h = abs ( tx - ini_x ) + abs ( ty - ini_y ) + ini_h <NEWLINE> for x , y , h in l : <NEWLINE> <INDENT> t_h = max ( n_h - ( abs ( tx - x ) + abs ( ty - y ) ) , 0 ) <NEWLINE> if h != t_h : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( tx , ty , n_h ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <NL> <INDENT> sat_z = s - x - y <NEWLINE> <NL> if sat_z >= 0 and sat_z <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> res = <STRING> <NEWLINE> for i in range ( ( len ( S ) + W - 1 ) // W ) : <NEWLINE> <INDENT> res = <STRING> . join ( ( res , S [ W * i ] ) ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> if N < 10 : <NEWLINE> <INDENT> print ( N ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> n = N - int ( ( len ( str ( N ) ) - 1 ) * <STRING> ) <NEWLINE> tmp = ( len ( str ( N ) ) - 1 ) * <STRING> <NEWLINE> if len ( str ( n ) ) > ( len ( str ( N ) ) - 1 ) : <NEWLINE> <INDENT> tmp = str ( n ) [ 0 ] + tmp <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for t in tmp : <NEWLINE> <INDENT> res += int ( t ) <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = NI ( ) <NEWLINE> h = NLI ( ) <NEWLINE> <NL> dp = [ 0 for _ in range ( ( 10 ** 5 ) + 10 ) ] <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> <NL> for n in range ( 2 , N ) : <NEWLINE> <INDENT> dp [ n ] = min ( dp [ n - 2 ] + abs ( h [ n ] - h [ n - 2 ] ) , dp [ n - 1 ] + abs ( h [ n ] - h [ n - 1 ] ) ) <NEWLINE> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ke = list ( Counter ( L ) . values ( ) ) <NEWLINE> val = list ( Counter ( L ) . keys ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( val ) ) : <NEWLINE> <INDENT> if val [ i ] > ke [ i ] : <NEWLINE> <INDENT> ans += ke [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ke [ i ] - val [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> s = input ( ) <NEWLINE> <COMMENT> <NL> l = [ - 1 for _ in range ( len ( s ) + 1 ) ] <NEWLINE> def aa ( ix , v ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> if ( ix >= len ( s ) and v == 1 ) or ( ix == 0 and v == 0 - 1 ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if v == 1 and s [ ix ] == <STRING> and l [ ix + 1 ] <= l [ ix ] : <NEWLINE> <INDENT> l [ ix + 1 ] = l [ ix ] + 1 <NEWLINE> aa ( ix + 1 , 1 ) <NEWLINE> <DEDENT> elif v == - 1 and s [ ix - 1 ] == <STRING> and l [ ix - 1 ] <= l [ ix ] : <NEWLINE> <INDENT> l [ ix - 1 ] = l [ ix ] + 1 <NEWLINE> aa ( ix - 1 , - 1 ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> for i in range ( 0 , len ( s ) ) : <NEWLINE> <INDENT> if i == 0 and s [ 0 ] == <STRING> : <NEWLINE> <INDENT> l [ 0 ] = 0 <NEWLINE> aa ( i , 1 ) <NEWLINE> <DEDENT> elif i == len ( s ) - 1 and s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> l [ - 1 ] = 0 <NEWLINE> aa ( i + 1 , - 1 ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> l [ i + 1 ] = 0 <NEWLINE> aa ( i + 1 , 1 ) <NEWLINE> aa ( i + 1 , - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( l ) ) <NEWLINE> <NL>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> flag = False <NEWLINE> <NL> for x in range ( N + 1 ) : <NEWLINE> <INDENT> if flag == True : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for y in range ( N - x + 1 ) : <NEWLINE> <INDENT> if 10000 * x + 5000 * y + 1000 * ( N - x - y ) == Y : <NEWLINE> <INDENT> print ( x , y , N - x - y ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag == False : <NEWLINE> <INDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ - 1 ] * ( N + 1 ) <NEWLINE> <NL> def rec ( i ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if dp [ i ] != - 1 : <NEWLINE> <INDENT> return dp [ i ] <NEWLINE> <DEDENT> dp [ i ] = 2 ** 60 <COMMENT> <NEWLINE> if i - 1 >= 0 : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i ] , rec ( i - 1 ) + abs ( h [ i - 1 ] - h [ i ] ) ) <NEWLINE> <DEDENT> if i - 2 >= 0 : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i ] , rec ( i - 2 ) + abs ( h [ i - 2 ] - h [ i ] ) ) <NEWLINE> <DEDENT> return dp [ i ] <NEWLINE> <NL> <DEDENT> print ( rec ( N - 1 ) ) <NEWLINE>
def count ( list ) : <NEWLINE> <INDENT> dict = { } <NEWLINE> for i in range ( len ( list ) ) : <NEWLINE> <INDENT> dict [ list [ i ] ] = dict . get ( list [ i ] , 0 ) + 1 <NEWLINE> <DEDENT> return dict <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = count ( a ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i , x in dic . items ( ) : <NEWLINE> <INDENT> differ = x - i <NEWLINE> if differ > 0 : <NEWLINE> <INDENT> ans += differ <NEWLINE> <DEDENT> elif differ < 0 : <NEWLINE> <INDENT> ans += x <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> a_max = max ( a ) <NEWLINE> a_max_cnt = a . count ( a_max ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if ( a [ i ] != a_max or a_max_cnt > 1 ) : <NEWLINE> <INDENT> print ( a_max ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( a [ : i ] + a [ i + 1 : ] ) ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ll = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ll . append ( l ) <NEWLINE> <NL> <DEDENT> ll . sort ( ) <NEWLINE> <NL> t = 0 <NEWLINE> cst = 0 <NEWLINE> i = 0 <NEWLINE> while t < m : <NEWLINE> <INDENT> t += ll [ i ] [ 1 ] <NEWLINE> cst += ll [ i ] [ 0 ] * ll [ i ] [ 1 ] <NEWLINE> if t > m : <NEWLINE> <INDENT> cst -= ll [ i ] [ 0 ] * ( t - m ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( cst ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> input = sys . stdin . buffer . readline <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> return a if b == 0 else gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // gcd ( a , b ) <NEWLINE> <NL> <DEDENT> def prime_factorize ( n ) : <NEWLINE> <INDENT> pf = { } <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> pf [ i ] = pf . get ( i , 0 ) + 1 <NEWLINE> n //= i <NEWLINE> <DEDENT> <DEDENT> if n > 1 : pf [ n ] = 1 <NEWLINE> return pf <NEWLINE> <NL> <DEDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> pf = prime_factorize ( gcd ( A , B ) ) <NEWLINE> print ( len ( pf ) + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> . join ( ( a [ 0 : : 2 ] [ : : - 1 ] + a [ 1 : : 2 ] ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( ( a [ 1 : : 2 ] [ : : - 1 ] + a [ 0 : : 2 ] ) ) ) <NEWLINE> <DEDENT>
n , m = map ( int , ( input ( ) . split ( ) ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = sorted ( x ) <NEWLINE> diff = [ ] <NEWLINE> for i in range ( m - 1 ) : <NEWLINE> <INDENT> diff . append ( x [ i + 1 ] - x [ i ] ) <NEWLINE> <NL> <DEDENT> diff = sorted ( diff , reverse = True ) <NEWLINE> <NL> dist = x [ - 1 ] - x [ 0 ] <NEWLINE> if dist < n : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if m < n : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> dist -= diff [ i ] <NEWLINE> <NL> <DEDENT> print ( dist ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> root = [ [ ] for _ in range ( N ) ] <NEWLINE> ans = [ 0 ] * N <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> root [ a ] . append ( b ) <NEWLINE> root [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> visited = [ False ] * N <NEWLINE> def dfs ( v ) : <NEWLINE> <INDENT> visited [ v ] = True <NEWLINE> for go in root [ v ] : <NEWLINE> <INDENT> if visited [ go ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ go ] += ans [ v ] <NEWLINE> dfs ( go ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * ans ) <NEWLINE>
from collections import Counter as c <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( input ( ) . split ( ) ) <NEWLINE> if c ( A ) . most_common ( ) [ 0 ] [ 1 ] == 1 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
N , K , Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> scores = [ K - Q ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> scores [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for score in scores : <NEWLINE> <INDENT> if score > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> r = range ( a , b + 1 ) <NEWLINE> for i in sorted ( set ( r [ : k ] ) | set ( r [ - k : ] ) ) : print ( i ) <NEWLINE>
o = list ( input ( ) ) <NEWLINE> e = list ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> if len ( o ) != len ( e ) : <NEWLINE> <INDENT> e += [ <STRING> ] <NEWLINE> <NL> <DEDENT> for i in range ( len ( o ) ) : <NEWLINE> <INDENT> ans += [ o [ i ] , e [ i ] ] <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000000 ) <NEWLINE> <NL> n , u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> G = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> distT = [ - 1 ] * n <NEWLINE> distA = [ - 1 ] * n <NEWLINE> distT [ u ] = 0 <NEWLINE> distA [ v ] = 0 <NEWLINE> def dfs ( now , dist ) : <NEWLINE> <INDENT> for nxt in G [ now ] : <NEWLINE> <INDENT> if dist [ nxt ] != - 1 : continue <NEWLINE> dist [ nxt ] = dist [ now ] + 1 <NEWLINE> dfs ( nxt , dist ) <NEWLINE> <DEDENT> <DEDENT> dfs ( u , distT ) <NEWLINE> dfs ( v , distA ) <NEWLINE> <NL> mx = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if distT [ i ] < distA [ i ] : <NEWLINE> <INDENT> mx = max ( mx , distA [ i ] ) <NEWLINE> <DEDENT> <DEDENT> ans = mx - 1 <NEWLINE> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> zero = s . count ( <STRING> ) <NEWLINE> one = s . count ( <STRING> ) <NEWLINE> print ( min ( zero , one ) * 2 ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> W = [ 0 ] * N <NEWLINE> E = [ 0 ] * N <NEWLINE> L = 0 <NEWLINE> R = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> L += 1 <NEWLINE> <DEDENT> if S [ N - 1 - i ] == <STRING> : <NEWLINE> <INDENT> R += 1 <NEWLINE> <DEDENT> W [ i ] = L <NEWLINE> E [ N - 1 - i ] = R <NEWLINE> <NL> <DEDENT> ans = float ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = min ( ans , E [ i ] + W [ i ] - 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a - 1 ] . append ( b - 1 ) <NEWLINE> g [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> costs = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> costs [ p - 1 ] += x <NEWLINE> <DEDENT> visited = [ 0 ] * n <NEWLINE> <NL> def dfs ( idx ) : <NEWLINE> <INDENT> visited [ idx ] = 1 <NEWLINE> for i in g [ idx ] : <NEWLINE> <INDENT> if visited [ i ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> costs [ i ] += costs [ idx ] <NEWLINE> dfs ( i ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * costs ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> w = S . count ( <STRING> ) <NEWLINE> b = 0 <NEWLINE> ans = min ( w , N - w ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> w -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> ans = min ( ans , w + b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for a in range ( 10 ) : <NEWLINE> <INDENT> s_index = s . find ( str ( a ) ) <NEWLINE> if s_index == - 1 : <NEWLINE> <INDENT> continue <COMMENT> <NEWLINE> <DEDENT> for b in range ( 10 ) : <NEWLINE> <INDENT> t_index = s . find ( str ( b ) , s_index + 1 ) <NEWLINE> if t_index == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for c in range ( 10 ) : <NEWLINE> <INDENT> u_index = s . find ( str ( c ) , t_index + 1 ) <NEWLINE> if u_index != - 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> import bisect <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import queue <NEWLINE> import array <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> <NL> def ii ( ) : return int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> def il ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> def fl ( ) : return list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> def iln ( n ) : return [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> <INDENT> for _ in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> def iss ( ) : return sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> def sl ( ) : return list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> def isn ( n ) : return [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> <INDENT> for _ in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> def lcm ( x , y ) : return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> S = iss ( ) <NEWLINE> K = ii ( ) <NEWLINE> <NL> substring = set ( ) <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , i + K + 1 ) : <NEWLINE> <INDENT> substring . add ( S [ i : j ] ) <NEWLINE> <DEDENT> <DEDENT> ret = sorted ( list ( substring ) ) <NEWLINE> print ( ret [ K - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> class common_function ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def lcm ( self , x : int , y : int ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> common = common_function ( ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> lengthX = common . lcm ( N , M ) <NEWLINE> XdivS = lengthX // N <NEWLINE> XdivT = lengthX // M <NEWLINE> X = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> j = XdivS * i <NEWLINE> X . append ( ( j , S [ i ] ) ) <NEWLINE> <DEDENT> X . sort ( key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> <NL> k , x = X . pop ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> j = XdivT * i <NEWLINE> for a in range ( lengthX ) : <NEWLINE> <INDENT> if len ( X ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if k < j : <NEWLINE> <INDENT> k , x = X . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if k == j : <NEWLINE> <INDENT> if x != T [ i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( lengthX ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> h [ i ] = int ( input ( ) ) <NEWLINE> <DEDENT> h = sorted ( h ) <NEWLINE> ans = 10 ** 10 <NEWLINE> for i in range ( N - ( K - 1 ) ) : <NEWLINE> <INDENT> tmp = h [ i + K - 1 ] - h [ i ] <NEWLINE> ans = min ( tmp , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> <NL> ans = S [ 1 : ] . count ( <STRING> ) <NEWLINE> tmp = S [ 1 : ] . count ( <STRING> ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> tmp -= 1 <NEWLINE> <DEDENT> ans = min ( ans , tmp ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , l = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( [ x - l , x + l ] ) <NEWLINE> <DEDENT> L . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> L = deque ( L ) <NEWLINE> s , ans = - 10 ** 8 , 0 <NEWLINE> while L : <NEWLINE> <INDENT> l = deque . popleft ( L ) <NEWLINE> if s <= l [ 0 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> s = l [ 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
c = [ 0 ] * 3 <NEWLINE> c_max = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> c [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c_max = max ( c_max , max ( c [ i ] ) ) <NEWLINE> <DEDENT> c_max += 1 <NEWLINE> for a1 in range ( c_max ) : <NEWLINE> <INDENT> b1 = c [ 0 ] [ 0 ] - a1 <NEWLINE> b2 = c [ 0 ] [ 1 ] - a1 <NEWLINE> b3 = c [ 0 ] [ 2 ] - a1 <NEWLINE> a2 = c [ 1 ] [ 0 ] - b1 <NEWLINE> a3 = c [ 2 ] [ 0 ] - b1 <NEWLINE> if a1 + b1 == c [ 0 ] [ 0 ] and a1 + b2 == c [ 0 ] [ 1 ] and a1 + b3 == c [ 0 ] [ 2 ] and a2 + b1 == c [ 1 ] [ 0 ] and a2 + b2 == c [ 1 ] [ 1 ] and a2 + b3 == c [ 1 ] [ 2 ] and a3 + b1 == c [ 2 ] [ 0 ] and a3 + b2 == c [ 2 ] [ 1 ] and a3 + b3 == c [ 2 ] [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = ( n - 1 ) * n // 2 <NEWLINE> <NL> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def dfs ( G , v ) : <NEWLINE> <INDENT> seen [ v ] = True <NEWLINE> <NL> for nv in G [ v ] : <NEWLINE> <INDENT> if seen [ nv ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> point [ nv ] += point [ v ] <NEWLINE> dfs ( G , nv ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x , y = x - 1 , y - 1 <NEWLINE> G [ x ] . append ( y ) <NEWLINE> G [ y ] . append ( x ) <NEWLINE> <NL> <DEDENT> seen = [ False for _ in range ( n ) ] <NEWLINE> root = 0 <NEWLINE> point = [ 0 for _ in range ( n ) ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> point [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> dfs ( G , root ) <NEWLINE> print ( * point ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( int ( input ( ) ) for i in range ( n ) ) <NEWLINE> <NL> s . sort ( ) <NEWLINE> <NL> ans = sum ( s ) <NEWLINE> <NL> if ans % 10 != 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in s : <NEWLINE> <INDENT> if x % 10 != 0 : <NEWLINE> <INDENT> ans -= x <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> from math import sqrt <NEWLINE> from collections import Counter <NEWLINE> <NL> <NL> def prime_factors ( p , prime_box ) : <NEWLINE> <INDENT> while p % 2 == 0 : <NEWLINE> <INDENT> prime_box . append ( 2 ) <NEWLINE> p //= 2 <NEWLINE> <NL> <DEDENT> for i in range ( 3 , int ( sqrt ( p ) ) + 1 , 2 ) : <NEWLINE> <INDENT> while p % i == 0 : <NEWLINE> <INDENT> prime_box . append ( i ) <NEWLINE> p //= i <NEWLINE> <DEDENT> <DEDENT> if p > 2 : <NEWLINE> <INDENT> prime_box . append ( p ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( p ) <NEWLINE> return <NEWLINE> <DEDENT> prime_box = [ ] <NEWLINE> prime_factors ( p , prime_box ) <NEWLINE> prime_box = list ( map ( list , Counter ( prime_box ) . items ( ) ) ) <NEWLINE> prime_box = [ [ s , t // n ] for s , t in prime_box ] <NEWLINE> ans = 1 <NEWLINE> for s , t in prime_box : <NEWLINE> <INDENT> ans *= s ** t <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import queue <NEWLINE> import numpy as np <NEWLINE> import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = np . array ( A , np . int64 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 60 + 1 ) : <NEWLINE> <INDENT> a = ( A >> i ) & 1 <NEWLINE> count1 = np . count_nonzero ( a ) <NEWLINE> count0 = len ( A ) - count1 <NEWLINE> ans += count1 * count0 * pow ( 2 , i ) <NEWLINE> ans %= 1000000007 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ls . sort ( ) <NEWLINE> di = ls [ : ] <NEWLINE> di . append ( ls [ - 1 ] // 2 ) <NEWLINE> di . sort ( ) <NEWLINE> ind = di . index ( ls [ - 1 ] // 2 ) <NEWLINE> il , ir = - 1 , - 1 <NEWLINE> if ind > 0 : <NEWLINE> <INDENT> il = ind - 1 <NEWLINE> <DEDENT> if ind < n - 1 : <NEWLINE> <INDENT> ir = ind + 1 <NEWLINE> <DEDENT> if il < 0 or ir < 0 : <NEWLINE> <INDENT> now = max ( ir , il ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ls [ - 1 ] % 2 == 0 : <NEWLINE> <INDENT> if abs ( ls [ - 1 ] // 2 - di [ ir ] ) < abs ( ls [ - 1 ] // 2 - di [ il ] ) : <NEWLINE> <INDENT> now = di [ ir ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now = di [ il ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if min ( abs ( ls [ - 1 ] // 2 - di [ ir ] ) , abs ( ls [ - 1 ] // 2 + 1 - di [ ir ] ) ) < min ( abs ( ls [ - 1 ] // 2 - di [ il ] ) , abs ( ls [ - 1 ] // 2 + 1 - di [ il ] ) ) : <NEWLINE> <INDENT> now = di [ ir ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now = di [ il ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ls [ - 1 ] , now ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> sm = 1 <NEWLINE> color = [ 0 , 0 , 0 ] <NEWLINE> for x in lst : <NEWLINE> <INDENT> if x not in color : sm = 0 ; break <NEWLINE> sm *= color . count ( x ) <NEWLINE> sm %= mod <NEWLINE> color [ color . index ( x ) ] += 1 <NEWLINE> <DEDENT> print ( sm ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> for h in range ( N ) : <NEWLINE> <INDENT> Cx , Cy , h = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( [ h , Cx , Cy ] ) <NEWLINE> <DEDENT> L . sort ( reverse = True ) <NEWLINE> <NL> for x in range ( 101 ) : <NEWLINE> <INDENT> for y in range ( 101 ) : <NEWLINE> <INDENT> cond = True <NEWLINE> H = L [ 0 ] [ 0 ] + abs ( x - L [ 0 ] [ 1 ] ) + abs ( y - L [ 0 ] [ 2 ] ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> h = L [ i ] [ 0 ] + abs ( x - L [ i ] [ 1 ] ) + abs ( y - L [ i ] [ 2 ] ) <NEWLINE> if L [ i ] [ 0 ] > 0 : <NEWLINE> <INDENT> if h != H : <NEWLINE> <INDENT> cond = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if h < H : <NEWLINE> <INDENT> cond = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if cond : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if cond : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x , y , H ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = 1 <NEWLINE> B = 1 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> A = max ( A , B ) <NEWLINE> B = max ( A , B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A % a == 0 : <NEWLINE> <INDENT> aa = A // a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> aa = A // a + 1 <NEWLINE> <DEDENT> if B % b == 0 : <NEWLINE> <INDENT> bb = B // b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bb = B // b + 1 <NEWLINE> <DEDENT> tmp = max ( aa , bb ) <NEWLINE> A = tmp * a <NEWLINE> B = tmp * b <NEWLINE> <NL> <DEDENT> <DEDENT> print ( A + B ) <NEWLINE> <NL>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , M = LI ( ) <NEWLINE> <NL> M_div = [ ] <NEWLINE> for i in range ( 1 , int ( M ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if M % i == 0 : <NEWLINE> <INDENT> M_div . append ( i ) <NEWLINE> M_div . append ( M // i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for i in M_div : <NEWLINE> <INDENT> if M // i >= N : <NEWLINE> <INDENT> ans = max ( i , ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ input ( ) for _ in range ( H ) ] <NEWLINE> <NL> def BFS ( H , W , grid ) : <NEWLINE> <INDENT> visited = [ [ True for _ in range ( W + 2 ) ] for _ in range ( H + 2 ) ] <NEWLINE> que = deque ( ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> visited [ i + 1 ] [ 1 : - 1 ] = map ( lambda _ : _ == <STRING> , grid [ i ] ) <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> if ( grid [ i ] [ j ] == <STRING> ) : <NEWLINE> <INDENT> que . append ( ( i + 1 , j + 1 , 0 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dist = [ ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) , ( 1 , 0 ) ] <NEWLINE> <NL> while que : <NEWLINE> <INDENT> x , y , c = que . popleft ( ) <NEWLINE> for dx , dy in dist : <NEWLINE> <INDENT> nx = x + dx <NEWLINE> ny = y + dy <NEWLINE> <NL> if ( not visited [ nx ] [ ny ] ) : <NEWLINE> <INDENT> que . append ( ( nx , ny , c + 1 ) ) <NEWLINE> visited [ nx ] [ ny ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return c <NEWLINE> <NL> <DEDENT> print ( BFS ( H , W , grid ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def Cost ( a , Sum ) : <NEWLINE> <INDENT> if Sum > 0 : <NEWLINE> <INDENT> if Sum + a < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return abs ( Sum + a ) + 1 <NEWLINE> <DEDENT> <DEDENT> if Sum < 0 : <NEWLINE> <INDENT> if Sum + a > 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return abs ( Sum + a ) + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> Sum = lambda a , preSum : preSum + a if Cost ( a , preSum ) == 0 else ( - 1 ) ** int ( preSum > 0 ) <NEWLINE> <NL> pCost , pSum = ( lambda : ( 0 , A [ 0 ] ) if A [ 0 ] > 0 else ( abs ( A [ 0 ] ) + 1 , 1 ) ) ( ) <NEWLINE> nCost , nSum = ( lambda : ( 0 , A [ 0 ] ) if A [ 0 ] < 0 else ( abs ( A [ 0 ] ) + 1 , - 1 ) ) ( ) <NEWLINE> for a in A [ 1 : ] : <NEWLINE> <INDENT> pCost += Cost ( a , pSum ) <NEWLINE> pSum = Sum ( a , pSum ) <NEWLINE> nCost += Cost ( a , nSum ) <NEWLINE> nSum = Sum ( a , nSum ) <NEWLINE> <DEDENT> print ( min ( pCost , nCost ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def dfs ( tree , n , ans ) : <NEWLINE> <INDENT> for i in tree [ n ] : <NEWLINE> <INDENT> ans [ i ] += ans [ n ] <NEWLINE> tree [ i ] . remove ( n ) <NEWLINE> dfs ( tree , i , ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> px = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> g [ ab [ i ] [ 0 ] - 1 ] . append ( ab [ i ] [ 1 ] - 1 ) <NEWLINE> g [ ab [ i ] [ 1 ] - 1 ] . append ( ab [ i ] [ 0 ] - 1 ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> ans [ px [ i - 1 ] [ 0 ] - 1 ] += px [ i - 1 ] [ 1 ] <NEWLINE> <DEDENT> dfs ( g , 0 , ans ) <NEWLINE> <NL> print ( * ans ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> tmp = 0 <NEWLINE> length = [ ] <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> or s [ i ] == <STRING> or s [ i ] == <STRING> or s [ i ] == <STRING> : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> if i == len ( s ) - 1 : <NEWLINE> <INDENT> length . append ( tmp ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> length . append ( tmp ) <NEWLINE> tmp = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max ( length ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for i in range ( N ) ] <NEWLINE> cnt = [ 0 ] * N <NEWLINE> <NL> <COMMENT> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> v = [ False ] * N <NEWLINE> <NL> <COMMENT> <NL> def dfs ( n , prv ) : <NEWLINE> <COMMENT> <NL> <INDENT> if v [ n ] : return <NEWLINE> cnt [ n ] += prv <NEWLINE> v [ n ] = True <NEWLINE> for nv in graph [ n ] : <NEWLINE> <INDENT> dfs ( nv , cnt [ n ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 , 0 ) <NEWLINE> print ( * cnt ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
import heapq <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> I = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> t , d = map ( int , input ( ) . split ( ) ) <NEWLINE> I . append ( ( d , t ) ) <NEWLINE> <NL> <DEDENT> I . sort ( reverse = True ) <NEWLINE> <NL> <COMMENT> <NL> h_d = [ ] <NEWLINE> <COMMENT> <NL> h_a = [ ] <NEWLINE> <NL> wk = 0 <NEWLINE> kind = 0 <NEWLINE> <COMMENT> <NL> ap = set ( ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d , t = I [ i ] <NEWLINE> wk += d <NEWLINE> if t not in ap : <NEWLINE> <INDENT> ap . add ( t ) <NEWLINE> kind += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> heapq . heappush ( h_d , ( d , t ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( K , N ) : <NEWLINE> <INDENT> d , t = I [ i ] <NEWLINE> if t not in ap : <NEWLINE> <INDENT> ap . add ( t ) <NEWLINE> <COMMENT> <NL> heapq . heappush ( h_a , ( ( - 1 ) * d , t ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = wk + kind ** 2 <NEWLINE> while len ( h_d ) > 0 and len ( h_a ) > 0 : <NEWLINE> <INDENT> d1 , t1 = heapq . heappop ( h_d ) <NEWLINE> d2 , t2 = heapq . heappop ( h_a ) <NEWLINE> d2 = ( - 1 ) * d2 <NEWLINE> wk = wk - d1 + d2 <NEWLINE> kind += 1 <NEWLINE> ans = max ( ans , wk + kind ** 2 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
<NL> def solve ( ) : <NEWLINE> <INDENT> i = ( L // 2019 ) + 1 <NEWLINE> ans = 0 <NEWLINE> if L <= 2019 * i <= R : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 2020 <NEWLINE> for n in range ( L , R ) : <NEWLINE> <INDENT> for m in range ( n + 1 , R + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , ( n * m ) % 2019 ) <NEWLINE> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> L , R = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> solve ( ) <NEWLINE> <DEDENT>
import copy <NEWLINE> <NL> <NL> def prepare ( n , MOD ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> f = 1 <NEWLINE> factorials = [ 1 ] <COMMENT> <NEWLINE> for m in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> f *= m <NEWLINE> f %= MOD <NEWLINE> factorials . append ( f ) <NEWLINE> <COMMENT> <NL> <DEDENT> inv = pow ( f , MOD - 2 , MOD ) <NEWLINE> <COMMENT> <NL> invs = [ 1 ] * ( n + 1 ) <NEWLINE> invs [ n ] = inv <NEWLINE> for m in range ( n , 1 , - 1 ) : <NEWLINE> <INDENT> inv *= m <NEWLINE> inv %= MOD <NEWLINE> invs [ m - 1 ] = inv <NEWLINE> <NL> <DEDENT> return factorials , invs <NEWLINE> <NL> <DEDENT> def func ( r , c ) : <NEWLINE> <INDENT> return f [ r + 1 + c + 1 ] * i [ r + 1 ] % MOD * i [ c + 1 ] % MOD <NEWLINE> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> f , i = prepare ( 2 * 10 ** 6 + 2 , MOD ) <NEWLINE> <NL> <NL> r1 , c1 , r2 , c2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> combi = func ( r2 , c2 ) - func ( r2 , c1 - 1 ) - func ( r1 - 1 , c2 ) + func ( r1 - 1 , c1 - 1 ) <NEWLINE> print ( combi % MOD ) <NEWLINE>
import collections <NEWLINE> import itertools <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = [ input ( ) [ 0 ] for _ in range ( N ) ] <NEWLINE> A = [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in S : <NEWLINE> <INDENT> if i == <STRING> or i == <STRING> or i == <STRING> or i == <STRING> or i == <STRING> : <NEWLINE> <INDENT> A . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( A ) != 0 : <NEWLINE> <INDENT> C = collections . Counter ( A ) . most_common ( ) <NEWLINE> v , c = zip ( * C ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> for a , b , c in itertools . combinations ( c , 3 ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += a * b * c <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( p ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif p == 1 or n >= 60 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( int ( p ** ( 1 / n ) ) + 2 ) [ : : - 1 ] : <NEWLINE> <INDENT> if p % ( i ** n ) == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( 1 , math . floor ( math . sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> if i * i <= N : <NEWLINE> <INDENT> ans = i * i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from functools import reduce <NEWLINE> def nCr ( n , r , DIV ) : <NEWLINE> <INDENT> if r < n - r : <NEWLINE> <INDENT> r = n - r <NEWLINE> <DEDENT> if r == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> f = lambda x , y : x * y % DIV <NEWLINE> X = reduce ( f , range ( n - r + 1 , n + 1 ) ) <NEWLINE> Y = reduce ( f , range ( 1 , r + 1 ) ) <NEWLINE> return X * pow ( Y , DIV - 2 , DIV ) % DIV <NEWLINE> <NL> <DEDENT> mod = pow ( 10 , 9 ) + 7 <NEWLINE> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> left , right = 0 , 0 <NEWLINE> a , b = max ( x , y ) , min ( x , y ) <NEWLINE> <NL> if ( 2 * b - a ) % 3 == 0 : <NEWLINE> <INDENT> d , s = a - b , ( 2 * b - a ) // 3 <NEWLINE> p , q = d + s , s <NEWLINE> print ( nCr ( p + q , p , mod ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> <NL> stdin = sys . stdin <NEWLINE> <NL> nm = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> a , b = nm ( ) <NEWLINE> <NL> n = math . gcd ( a , b ) <NEWLINE> <NL> count = 1 <COMMENT> <NEWLINE> for i in range ( 2 , int ( n ** ( 1 / 2 ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> while n % i == 0 : <NEWLINE> <INDENT> n = n / i <NEWLINE> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
from sys import stdin , stdout <NEWLINE> from time import perf_counter <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> print ( ( ( b // x ) - ( ( a - 1 ) // x ) ) ) <NEWLINE>
import collections <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> c = collections . Counter ( a ) <NEWLINE> if len ( c ) < k : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> l = c . most_common ( ) <NEWLINE> for i in range ( 1 , - k + len ( c ) + 1 ) : <NEWLINE> <INDENT> ans += l [ - i ] [ 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if M == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> INF = 10 ** 6 <NEWLINE> pqc = [ tuple ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> to1d = { v : { } for v in range ( N ) } <NEWLINE> count = 2 <NEWLINE> for p , q , c in pqc : <NEWLINE> <INDENT> if not to1d [ p ] . get ( c ) : <NEWLINE> <INDENT> to1d [ p ] [ c ] = count <NEWLINE> count += 1 <NEWLINE> <DEDENT> if not to1d [ q ] . get ( c ) : <NEWLINE> <INDENT> to1d [ q ] [ c ] = count <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> G = [ { } for _ in range ( N + count ) ] <NEWLINE> for p , q , c in pqc : <NEWLINE> <INDENT> v1 , v2 = to1d [ p ] [ c ] , to1d [ q ] [ c ] <NEWLINE> G [ v1 ] [ v2 ] = G [ v2 ] [ v1 ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if len ( to1d [ i ] ) <= 1 : continue <NEWLINE> for c in to1d [ i ] . keys ( ) : <NEWLINE> <INDENT> v = to1d [ i ] [ c ] <NEWLINE> G [ v ] [ count ] = 1 <NEWLINE> G [ count ] [ v ] = 0 <NEWLINE> <DEDENT> count += 1 <NEWLINE> <NL> <DEDENT> def dijkstra ( start = 0 , goal = 1 ) : <NEWLINE> <INDENT> from heapq import heappop , heappush <NEWLINE> NN = len ( G ) <NEWLINE> d = [ INF ] * NN <NEWLINE> d [ start ] = 0 <NEWLINE> que = [ ] <NEWLINE> heappush ( que , start ) <NEWLINE> while que : <NEWLINE> <INDENT> p = divmod ( heappop ( que ) , NN ) <NEWLINE> v = p [ 1 ] <NEWLINE> if d [ v ] < p [ 0 ] : continue <NEWLINE> for u in G [ v ] . keys ( ) : <NEWLINE> <INDENT> if d [ u ] > d [ v ] + G [ v ] [ u ] : <NEWLINE> <INDENT> d [ u ] = d [ v ] + G [ v ] [ u ] <NEWLINE> heappush ( que , d [ u ] * NN + u ) <NEWLINE> <DEDENT> <DEDENT> if v == goal : return d [ goal ] <NEWLINE> <DEDENT> return d [ goal ] <NEWLINE> <NL> <DEDENT> for c in to1d [ 0 ] . keys ( ) : <NEWLINE> <INDENT> v = to1d [ 0 ] [ c ] <NEWLINE> G [ 0 ] [ v ] = 1 <NEWLINE> <DEDENT> for c in to1d [ N - 1 ] . keys ( ) : <NEWLINE> <INDENT> v = to1d [ N - 1 ] [ c ] <NEWLINE> G [ v ] [ 1 ] = 0 <NEWLINE> <NL> <DEDENT> ans = dijkstra ( 0 , 1 ) <NEWLINE> print ( ans if ans < INF else - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> S = list ( input ( ) ) <NEWLINE> s = list ( set ( S ) ) <NEWLINE> s . sort ( ) <NEWLINE> alfa = list ( <STRING> ) <NEWLINE> ans = 0 <NEWLINE> if ( len ( s ) == len ( alfa ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if ( s [ i ] != alfa [ i ] ) : <NEWLINE> <INDENT> print ( alfa [ i ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( alfa [ len ( s ) ] ) <NEWLINE> <DEDENT>
( h , n ) , * c = [ [ * map ( int , i . split ( ) ) ] for i in open ( 0 ) ] <NEWLINE> dp = [ 0 ] * 20002 <NEWLINE> for i in range ( h ) : dp [ i ] = min ( dp [ i - a ] + b for a , b in c ) <NEWLINE> print ( dp [ h - 1 ] ) <NEWLINE>
import copy <NEWLINE> import math <NEWLINE> import time <NEWLINE> <NL> <COMMENT> <NL> def get_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_string ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_int_list ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> <DEDENT> def get_string_list ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_int_multi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_string_char_list ( ) : <NEWLINE> <INDENT> return list ( str ( input ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <STRING> <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> start = time . time ( ) <NEWLINE> <NL> n = get_int ( ) <NEWLINE> s_list = get_string_char_list ( ) <NEWLINE> s_list = [ int ( x ) for x in s_list ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 0 , 1000 ) : <NEWLINE> <INDENT> a = i // 100 <NEWLINE> b = ( i % 100 ) // 10 <NEWLINE> c = i % 10 <NEWLINE> <NL> find_a = False <NEWLINE> find_b = False <NEWLINE> for ii in s_list : <NEWLINE> <NL> <INDENT> if ( find_a == False ) and ( ii == a ) : <NEWLINE> <INDENT> find_a = True <NEWLINE> <DEDENT> elif ( find_a == True ) and ( find_b == False ) and ( ii == b ) : <NEWLINE> <INDENT> find_b = True <NEWLINE> <DEDENT> elif ( find_b == True ) and ( ii == c ) : <NEWLINE> <NL> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h . sort ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if h [ i ] >= k : <NEWLINE> <INDENT> ans = n - i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
arr = [ ] <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> arr . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> arr2 = arr . copy ( ) <NEWLINE> arr2 . sort ( ) <NEWLINE> z = arr2 [ - 1 ] <NEWLINE> zz = arr2 [ - 2 ] <NEWLINE> for k in arr : <NEWLINE> <INDENT> if k != z : <NEWLINE> <INDENT> print ( z ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( zz ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( n * ( n - 1 ) // 2 ) <NEWLINE>
import copy <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = sum ( p [ : k ] ) <NEWLINE> smax = copy . deepcopy ( s ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> s += p [ i + k ] - p [ i ] <NEWLINE> smax = max ( smax , s ) <NEWLINE> <NL> <DEDENT> print ( ( smax + k ) / 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = [ 0 ] * ( n - 1 ) <NEWLINE> k = 0 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if h [ i ] - h [ i + 1 ] >= 0 : <NEWLINE> <INDENT> d [ k ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> <DEDENT> print ( max ( d ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( m ) ] <NEWLINE> a . sort ( ) <NEWLINE> b = sorted ( b , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> d = [ ] <NEWLINE> j = 0 <NEWLINE> while ( n <= len ( a ) or j < m ) : <NEWLINE> <INDENT> C = b [ j ] [ 1 ] <NEWLINE> B = b [ j ] [ 0 ] <NEWLINE> for i in range ( B ) : <NEWLINE> <INDENT> d . append ( C ) <NEWLINE> <DEDENT> j += 1 <NEWLINE> if j >= m or len ( d ) > len ( a ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( min ( len ( d ) , len ( a ) ) ) : <NEWLINE> <INDENT> if a [ i ] < d [ i ] : <NEWLINE> <INDENT> a [ i ] = d [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def dfs ( tree , n , ans ) : <NEWLINE> <INDENT> for i in tree [ n ] : <NEWLINE> <INDENT> ans [ i ] += ans [ n ] <NEWLINE> tree [ i ] . remove ( n ) <NEWLINE> dfs ( tree , i , ans ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> px = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> g [ ab [ i ] [ 0 ] - 1 ] . append ( ab [ i ] [ 1 ] - 1 ) <NEWLINE> g [ ab [ i ] [ 1 ] - 1 ] . append ( ab [ i ] [ 0 ] - 1 ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> ans [ px [ i - 1 ] [ 0 ] - 1 ] += px [ i - 1 ] [ 1 ] <NEWLINE> <DEDENT> dfs ( g , 0 , ans ) <NEWLINE> <NL> print ( * ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
a = list ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> for i , j in enumerate ( a ) : <NEWLINE> <INDENT> if j == str ( <STRING> ) : <NEWLINE> <INDENT> b += str ( <STRING> ) <NEWLINE> <DEDENT> elif j == str ( <STRING> ) : <NEWLINE> <INDENT> b += str ( <STRING> ) <NEWLINE> <DEDENT> elif j == str ( <STRING> ) : <NEWLINE> <INDENT> if not b : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> del b [ len ( b ) - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( b ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> par = { i : [ ] for i in range ( 1 , N + 1 ) } <NEWLINE> q = [ 1 ] <NEWLINE> l = [ ] <NEWLINE> dp = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> par [ a ] . append ( i ) <NEWLINE> <NL> <DEDENT> while q : <NEWLINE> <INDENT> s = q . pop ( ) <NEWLINE> l . append ( s ) <NEWLINE> for t in par [ s ] : <NEWLINE> <INDENT> q . append ( t ) <NEWLINE> <NL> <DEDENT> <DEDENT> for s in l [ : : - 1 ] : <NEWLINE> <INDENT> depth = 1 <NEWLINE> res = sorted ( [ dp [ t ] for t in par [ s ] ] ) [ : : - 1 ] <NEWLINE> for i , j in enumerate ( res ) : <NEWLINE> <INDENT> depth = max ( depth , i + j + 1 ) <NEWLINE> <DEDENT> dp [ s ] = depth <NEWLINE> <NL> <DEDENT> print ( dp [ 1 ] - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> gcd = math . gcd ( m , n ) <NEWLINE> i = 1 <NEWLINE> ans = [ ] <NEWLINE> max = int ( math . sqrt ( gcd ) ) <NEWLINE> for i in range ( 2 , max + 2 ) : <NEWLINE> <INDENT> while gcd % i == 0 : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> gcd //= i <NEWLINE> <DEDENT> <DEDENT> if gcd > 1 : <NEWLINE> <INDENT> ans . append ( n ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( ans ) ) + 1 ) <NEWLINE>
from math import ceil <NEWLINE> from numba import njit <NEWLINE> <NL> @ njit ( cache = True ) <NEWLINE> def solve ( rm , gm , bm , R , G , B , n ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for r in range ( rm + 1 ) : <NEWLINE> <INDENT> for g in range ( gm + 1 ) : <NEWLINE> <INDENT> x = n - ( r * R + g * G ) <NEWLINE> if x >= 0 : <NEWLINE> <INDENT> ans += ( x % B == 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> R , G , B , n = map ( int , input ( ) . split ( ) ) <NEWLINE> rm = ceil ( n / R ) <NEWLINE> gm = ceil ( n / G ) <NEWLINE> bm = ceil ( n / B ) <NEWLINE> <NL> print ( solve ( rm , gm , bm , R , G , B , n ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> li = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> s . sort ( ) <NEWLINE> li . append ( s ) <NEWLINE> <DEDENT> li . sort ( ) <NEWLINE> temp = 1 <NEWLINE> for j in range ( N - 1 ) : <NEWLINE> <INDENT> if li [ j ] == li [ j + 1 ] : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += temp * ( temp - 1 ) // 2 <NEWLINE> temp = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans += temp * ( temp - 1 ) // 2 <NEWLINE> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> cnt_l = [ 0 ] * ( len ( s ) + 1 ) <NEWLINE> cnt_r = [ 0 ] * ( len ( s ) + 1 ) <NEWLINE> <NL> for i in range ( 1 , len ( s ) + 1 ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> cnt_l [ i ] = cnt_l [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt_l [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( s ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt_r [ i ] = cnt_r [ i + 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt_r [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for l , r in zip ( cnt_l , cnt_r ) : <NEWLINE> <INDENT> ans += max ( l , r ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> connect = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> connect [ a ] . append ( b ) <NEWLINE> connect [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> color = [ - 1 ] * n <NEWLINE> color [ 0 ] = 0 <NEWLINE> explored = { 0 } <NEWLINE> next = deque ( [ 0 ] ) <NEWLINE> exploring = deque ( ) <NEWLINE> Yes = True <NEWLINE> explored . add ( 0 ) <NEWLINE> while next : <NEWLINE> <INDENT> now = next . popleft ( ) <NEWLINE> for a in connect [ now ] : <NEWLINE> <INDENT> if color [ a ] != - 1 : <NEWLINE> <INDENT> if color [ a ] != ( color [ now ] + 1 ) % 2 : <NEWLINE> <INDENT> Yes = False <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> color [ a ] = ( color [ now ] + 1 ) % 2 <NEWLINE> next . append ( a ) <NEWLINE> <NL> <NL> <DEDENT> <STRING> <NEWLINE> <DEDENT> if Yes : <NEWLINE> <INDENT> s = sum ( color ) <NEWLINE> print ( s * ( n - s ) - m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n * ( n - 1 ) // 2 - m ) <NEWLINE> <DEDENT>
import unittest <NEWLINE> <NL> <NL> def solve_small ( n ) : <NEWLINE> <INDENT> total = 0 <NEWLINE> for m in range ( 1 , n ) : <NEWLINE> <INDENT> if n // m == n % m : <NEWLINE> <INDENT> total += m <NEWLINE> <DEDENT> <DEDENT> return total <NEWLINE> <NL> <NL> <DEDENT> def solve ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> conds = set ( ) <NEWLINE> conds . add ( n - 1 ) <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> conds . add ( i - 1 ) <NEWLINE> conds . add ( n // i - 1 ) <NEWLINE> <DEDENT> <DEDENT> total = 0 <NEWLINE> for m in list ( conds ) : <NEWLINE> <INDENT> if n // m == n % m : <NEWLINE> <INDENT> total += m <NEWLINE> <DEDENT> <DEDENT> return total <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> result = solve ( n ) <NEWLINE> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <DEDENT> class Test ( unittest . TestCase ) : <NEWLINE> <INDENT> def test_solve_1 ( self ) : <NEWLINE> <INDENT> n = 8 <NEWLINE> actual = solve ( n ) <NEWLINE> expected = 10 <NEWLINE> self . assertEqual ( actual , expected ) <NEWLINE> <NL> <DEDENT> def test_solve_2 ( self ) : <NEWLINE> <INDENT> n = 1000000000000 <NEWLINE> actual = solve ( n ) <NEWLINE> expected = 2499686339916 <NEWLINE> self . assertEqual ( actual , expected ) <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = max ( a ) <NEWLINE> t = ( 10 ** 9 ) + 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> if abs ( i - ( m // 2 ) ) < t and i != m : <NEWLINE> <INDENT> t = abs ( i - ( m // 2 ) ) <NEWLINE> s = i <NEWLINE> <DEDENT> <DEDENT> print ( m , s ) <NEWLINE>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L = [ K ] * N <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> L [ A - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in L : <NEWLINE> <INDENT> if i - Q > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> path = [ [ ] for i in range ( N ) ] <NEWLINE> ans = [ 0 ] * N <NEWLINE> def dfs ( v , p = - 1 ) : <NEWLINE> <INDENT> for to in path [ v ] : <NEWLINE> <INDENT> if to == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ to ] += ans [ v ] <NEWLINE> dfs ( to , v ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> path [ a ] . append ( b ) <NEWLINE> path [ b ] . append ( a ) <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> P , X = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ P - 1 ] += X <NEWLINE> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * ans ) <NEWLINE>
import heapq <NEWLINE> import math <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( lambda x : x * ( - 1 ) , a ) ) <NEWLINE> ticket_num = m <NEWLINE> heapq . heapify ( a ) <NEWLINE> <NL> if n > 1 : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> MAX = heapq . heappop ( a ) <NEWLINE> MAX = math . ceil ( MAX / 2 ) <NEWLINE> heapq . heappush ( a , MAX ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> MAX = heapq . heappop ( a ) <NEWLINE> MAX = math . ceil ( MAX / ( 2 ** m ) ) <NEWLINE> heapq . heappush ( a , MAX ) <NEWLINE> <NL> <DEDENT> print ( sum ( a ) * ( - 1 ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> <NL> def factorize ( n ) : <NEWLINE> <INDENT> facts = defaultdict ( int ) <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> n //= 2 <NEWLINE> facts [ 2 ] += 1 <NEWLINE> <DEDENT> m = 3 <NEWLINE> while m * m <= n : <NEWLINE> <INDENT> while n % m == 0 : <NEWLINE> <INDENT> facts [ m ] += 1 <NEWLINE> n //= m <NEWLINE> <DEDENT> m += 2 <NEWLINE> <DEDENT> if 1 < n : <NEWLINE> <INDENT> facts [ n ] += 1 <NEWLINE> <DEDENT> return facts <NEWLINE> <NL> <NL> <DEDENT> MOD = 10 ** 9 + 7 <COMMENT> <NEWLINE> MAX = 10 ** 5 + 100 <NEWLINE> FACTS = [ 1 ] * ( MAX + 1 ) <NEWLINE> for i in range ( 1 , MAX + 1 ) : <NEWLINE> <INDENT> FACTS [ i ] = FACTS [ i - 1 ] * i % MOD <NEWLINE> <DEDENT> FACTINVS = [ 1 ] * ( MAX + 1 ) <NEWLINE> INVS = [ 1 ] * ( MAX + 1 ) <NEWLINE> for i in range ( 2 , MAX + 1 ) : <NEWLINE> <INDENT> q , r = divmod ( MOD , i ) <NEWLINE> INVS [ i ] = - INVS [ r ] * q % MOD <NEWLINE> FACTINVS [ i ] = FACTINVS [ i - 1 ] * INVS [ i ] % MOD <NEWLINE> <NL> <NL> <DEDENT> def nCr ( n , r ) : <NEWLINE> <INDENT> return FACTS [ n ] * FACTINVS [ r ] * FACTINVS [ n - r ] <NEWLINE> <NL> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> factors = factorize ( M ) <NEWLINE> ans = 1 <NEWLINE> for p , e in factors . items ( ) : <NEWLINE> <INDENT> ans = ans * nCr ( N - 1 + e , e ) % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from sys import setrecursionlimit <NEWLINE> setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> x , y = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> graph [ x ] . append ( y ) <NEWLINE> <NL> <DEDENT> dp = [ - 1 ] * N <NEWLINE> def rec ( v ) : <NEWLINE> <INDENT> if dp [ v ] != - 1 : <NEWLINE> <INDENT> return dp [ v ] <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for nv in graph [ v ] : <NEWLINE> <INDENT> res = max ( res , rec ( nv ) + 1 ) <NEWLINE> <DEDENT> dp [ v ] = res <NEWLINE> return res <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for v in range ( N ) : <NEWLINE> <INDENT> res = max ( res , rec ( v ) ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> n = A [ - 1 ] <NEWLINE> mid = bisect . bisect ( A , n / 2 ) <NEWLINE> <NL> if abs ( n / 2 - A [ mid - 1 ] ) > abs ( n / 2 - A [ mid ] ) : <NEWLINE> <INDENT> print ( n , A [ mid ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n , A [ mid - 1 ] ) <NEWLINE> <DEDENT>
N , A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> maxint = 50 * N <NEWLINE> <NL> dp = [ [ [ 0 ] * ( maxint + 1 ) for _ in range ( N + 1 ) ] for _ in range ( N + 1 ) ] <NEWLINE> <NL> dp [ 0 ] [ 0 ] [ 0 ] = 1 <NEWLINE> <NL> for xi , xe in enumerate ( x , 1 ) : <NEWLINE> <INDENT> for j in range ( xi + 1 ) : <NEWLINE> <INDENT> for k in range ( maxint + 1 ) : <NEWLINE> <INDENT> dp [ xi ] [ j ] [ k ] = dp [ xi - 1 ] [ j ] [ k ] <NEWLINE> <NL> if j >= 0 and k >= xe : <NEWLINE> <INDENT> dp [ xi ] [ j ] [ k ] += dp [ xi - 1 ] [ j - 1 ] [ k - xe ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> res = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> res += dp [ N ] [ i ] [ i * A ] <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> def range_strip ( S , i , j ) : <NEWLINE> <INDENT> return S [ : i ] + S [ j : ] <NEWLINE> <NL> <DEDENT> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> for j in range ( i , len ( S ) ) : <NEWLINE> <INDENT> if range_strip ( S , i , j ) == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> def calc ( x , y ) : <NEWLINE> <INDENT> a = fac [ x ] <NEWLINE> b = fac [ y ] <NEWLINE> c = fac [ x - y ] <NEWLINE> ret = ( ( a % p ) * pow ( b , p - 2 , p ) * pow ( c , p - 2 , p ) ) % p <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> <NL> fac = [ 1 ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> fac . append ( ( fac [ - 1 ] * i ) % p ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i <= N - K : <NEWLINE> <INDENT> nokori = N - 1 - i <NEWLINE> kumi = calc ( nokori , K - 1 ) <NEWLINE> ans -= ( A [ i ] * kumi ) % p <NEWLINE> <DEDENT> if i >= K - 1 : <NEWLINE> <INDENT> nokori = i <NEWLINE> kumi = calc ( nokori , K - 1 ) <NEWLINE> ans += ( A [ i ] * kumi ) % p <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans % p ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> aa = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> list1 = [ ] <NEWLINE> ma = aa [ - 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d = abs ( aa [ i ] - ( ma + 1 ) // 2 ) <NEWLINE> list1 . append ( [ d , i ] ) <NEWLINE> <DEDENT> md = min ( list1 , key = lambda x : x [ 0 ] ) <NEWLINE> <NL> print ( ma , aa [ md [ 1 ] ] ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 200_000 ) <NEWLINE> <NL> def solve ( N : int , a : <STRING> , b : <STRING> ) : <NEWLINE> <INDENT> from itertools import count <NEWLINE> edges = [ [ ] for _ in range ( N ) ] <NEWLINE> for i , ( aa , bb ) in enumerate ( zip ( a , b ) ) : <NEWLINE> <INDENT> edges [ aa - 1 ] . append ( ( bb - 1 , i ) ) <NEWLINE> edges [ bb - 1 ] . append ( ( aa - 1 , i ) ) <NEWLINE> <DEDENT> ans = [ None ] * ( N - 1 ) <NEWLINE> visited = set ( ) <NEWLINE> def dfs ( n , c ) : <NEWLINE> <INDENT> if n in visited : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> visited . add ( n ) <NEWLINE> for ( nn , i ) , cc in zip ( filter ( lambda x : x [ 0 ] not in visited , edges [ n ] ) , <NEWLINE> <INDENT> filter ( lambda y : y != c , count ( 1 ) ) ) : <NEWLINE> ans [ i ] = cc <NEWLINE> dfs ( nn , cc ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 , None ) <NEWLINE> return [ max ( ans ) ] + ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> a = [ int ( ) ] * ( N - 1 ) <COMMENT> <NEWLINE> b = [ int ( ) ] * ( N - 1 ) <COMMENT> <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a [ i ] = int ( next ( tokens ) ) <NEWLINE> b [ i ] = int ( next ( tokens ) ) <NEWLINE> <DEDENT> print ( * solve ( N , a , b ) , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> def test ( ) : <NEWLINE> <INDENT> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> VW = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> <NL> ans = [ ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> for v , w in VW : <NEWLINE> <INDENT> ans . append ( min ( v , w ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for v , w in VW : <NEWLINE> <INDENT> while v != w : <NEWLINE> <INDENT> if v > w : v , w = w , v <NEWLINE> w = ( w + N - 2 ) // N <NEWLINE> <DEDENT> ans . append ( v ) <NEWLINE> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
import numpy as np <NEWLINE> import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> ixy = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> for j in range ( a ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ixy . append ( [ i , x - 1 , y ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> ixy = np . array ( ixy ) <NEWLINE> p = itertools . product ( [ True , False ] , repeat = n ) <NEWLINE> for p_i in p : <NEWLINE> <INDENT> f = True <NEWLINE> for i , x , y in ixy : <NEWLINE> <INDENT> if not p_i [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if p_i [ x ] != y : <NEWLINE> <INDENT> f = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> ans = max ( sum ( p_i ) , ans ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ list ( input ( ) ) for i in range ( H ) ] <NEWLINE> l_count = [ [ 0 ] * W for i in range ( H ) ] <NEWLINE> from collections import deque <NEWLINE> def answer ( st_X , st_Y ) : <COMMENT> <NEWLINE> <INDENT> tmp_X , tmp_Y = st_X , st_Y <NEWLINE> que = deque ( [ [ tmp_X , tmp_Y ] ] ) <NEWLINE> after = set ( ) <NEWLINE> while que : <COMMENT> <NEWLINE> <INDENT> tmp_X , tmp_Y = que . popleft ( ) <NEWLINE> nu = l_count [ tmp_Y ] [ tmp_X ] <NEWLINE> after . add ( ( tmp_X , tmp_Y ) ) <NEWLINE> if tmp_X > 0 and l [ tmp_Y ] [ tmp_X - 1 ] == <STRING> and ( tmp_X - 1 , tmp_Y ) not in after and [ tmp_X - 1 , tmp_Y ] not in que : <NEWLINE> <INDENT> l_count [ tmp_Y ] [ tmp_X - 1 ] = nu + 1 <NEWLINE> que . append ( [ tmp_X - 1 , tmp_Y ] ) <NEWLINE> <DEDENT> if tmp_Y > 0 and l [ tmp_Y - 1 ] [ tmp_X ] == <STRING> and ( tmp_X , tmp_Y - 1 ) not in after and [ tmp_X , tmp_Y - 1 ] not in que : <NEWLINE> <INDENT> l_count [ tmp_Y - 1 ] [ tmp_X ] = nu + 1 <NEWLINE> que . append ( [ tmp_X , tmp_Y - 1 ] ) <NEWLINE> <DEDENT> if tmp_X < W - 1 and l [ tmp_Y ] [ tmp_X + 1 ] == <STRING> and ( tmp_X + 1 , tmp_Y ) not in after and [ tmp_X + 1 , tmp_Y ] not in que : <NEWLINE> <INDENT> l_count [ tmp_Y ] [ tmp_X + 1 ] = nu + 1 <NEWLINE> que . append ( [ tmp_X + 1 , tmp_Y ] ) <NEWLINE> <DEDENT> if tmp_Y < H - 1 and l [ tmp_Y + 1 ] [ tmp_X ] == <STRING> and ( tmp_X , tmp_Y + 1 ) not in after and [ tmp_X , tmp_Y + 1 ] not in que : <NEWLINE> <INDENT> l_count [ tmp_Y + 1 ] [ tmp_X ] = nu + 1 <NEWLINE> que . append ( [ tmp_X , tmp_Y + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if l [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> l_count = [ [ 0 ] * W for i in range ( H ) ] <NEWLINE> answer ( j , i ) <NEWLINE> tmp = max ( sum ( l_count , [ ] ) ) <NEWLINE> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i < K : <NEWLINE> <INDENT> times = math . ceil ( math . log2 ( K / i ) ) <NEWLINE> p = p + ( 1 / N ) * ( 1 / 2 ) ** times <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = p + ( 1 / N ) <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE> <NL>
import numpy as np <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = np . zeros ( ( H , W ) ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> Si = np . array ( [ int ( s == <STRING> ) for s in input ( ) ] ) <NEWLINE> S [ i ] = Si <NEWLINE> <NL> <DEDENT> top = S . copy ( ) <NEWLINE> bottom = S . copy ( ) <NEWLINE> left = S . copy ( ) <NEWLINE> right = S . copy ( ) <NEWLINE> <NL> for i in range ( 1 , H ) : <NEWLINE> <INDENT> top [ i ] = ( top [ i - 1 ] + 1 ) * S [ i ] <NEWLINE> bottom [ - i - 1 ] = ( bottom [ - i ] + 1 ) * S [ - i - 1 ] <NEWLINE> <NL> <DEDENT> for j in range ( 1 , W ) : <NEWLINE> <INDENT> left [ : , j ] = ( left [ : , j - 1 ] + 1 ) * S [ : , j ] <NEWLINE> right [ : , - j - 1 ] = ( right [ : , - j ] + 1 ) * S [ : , - j - 1 ] <NEWLINE> <NL> <DEDENT> print ( np . max ( ( top + bottom + left + right - 3 ) . astype ( np . int ) ) ) <NEWLINE>
from math import sqrt <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cand = [ ] <NEWLINE> <NL> for i in range ( 1 , int ( sqrt ( M ) ) + 1 ) : <NEWLINE> <INDENT> if M % i == 0 : <NEWLINE> <INDENT> cand . append ( i ) <NEWLINE> u = M // i <NEWLINE> if u != i : <NEWLINE> <INDENT> cand . append ( u ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> cand . sort ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> for j in cand : <NEWLINE> <INDENT> if N * j <= M : <NEWLINE> <INDENT> ans = max ( ans , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nums = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> tmp = [ i for i in nums if i % 2 == 0 ] <NEWLINE> count = 0 <NEWLINE> for i in tmp : <NEWLINE> <NL> <INDENT> while i % 2 == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> i //= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> N_square_root = math . floor ( math . sqrt ( N ) ) <NEWLINE> result = 0 <NEWLINE> for i in range ( N_square_root + 1 ) : <NEWLINE> <INDENT> result = i * i <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = set ( int ( input ( ) ) for m in range ( M ) ) <NEWLINE> dp = ( N + 1 ) * [ 0 ] <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if n not in A : <NEWLINE> <INDENT> dp [ n ] = ( dp [ n - 2 ] + dp [ n - 1 ] ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> while a % b != 0 : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return b <NEWLINE> <NL> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> x = gcd ( N , M ) <NEWLINE> n = N // x <NEWLINE> m = M // x <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> if S [ n * i ] != T [ m * i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( N * M // x ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( a + b if a + b < 10 else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> a . sort ( ) <NEWLINE> <NL> ans = sum ( a ) <NEWLINE> if ans % 10 != 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> flg = False <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] % 10 != 0 : <NEWLINE> <INDENT> ans -= a [ i ] <NEWLINE> flg = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) if flg else print ( 0 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> b = a [ 0 ] <NEWLINE> c = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> if b == 2 : <NEWLINE> <INDENT> print ( len ( c ) + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if len ( c ) > n : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c . append ( b ) <NEWLINE> b = a [ c [ - 1 ] - 1 ] <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AN = [ 0 ] * 100002 <COMMENT> <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> AN [ a ] += 1 <NEWLINE> AN [ a + 1 ] += 1 <NEWLINE> AN [ a + 2 ] += 1 <NEWLINE> <DEDENT> print ( max ( AN ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ ( A [ i ] , 1 ) for i in range ( N ) ] <NEWLINE> <NL> changes = [ None ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> changes [ i ] = ( c , b ) <NEWLINE> <NL> <DEDENT> allVals = A + changes <NEWLINE> <NL> allVals . sort ( key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> <COMMENT> <NL> <NL> i = 0 <NEWLINE> j = - 1 <NEWLINE> res = 0 <NEWLINE> while True : <NEWLINE> <INDENT> j += 1 <NEWLINE> res += allVals [ j ] [ 0 ] * allVals [ j ] [ 1 ] <NEWLINE> i += allVals [ j ] [ 1 ] <NEWLINE> <NL> if i >= N : <NEWLINE> <INDENT> res -= allVals [ j ] [ 0 ] * ( i - N ) <NEWLINE> break <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> X = int ( input ( ) ) <NEWLINE> counter = 0 <NEWLINE> <NL> for a in range ( A + 1 ) : <NEWLINE> <INDENT> a_total = a * 500 <NEWLINE> for b in range ( B + 1 ) : <NEWLINE> <INDENT> b_total = b * 100 <NEWLINE> for c in range ( C + 1 ) : <NEWLINE> <INDENT> c_total = c * 50 <NEWLINE> total_amount = ( a_total + b_total + c_total ) <NEWLINE> if X == total_amount : <NEWLINE> <INDENT> counter = counter + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> a = { s } <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> for j in range ( len ( s ) - i ) : a . add ( s [ j : j + i + 1 ] ) <NEWLINE> <DEDENT> print ( sorted ( list ( a ) ) [ k - 1 ] ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 1000000007 <NEWLINE> a = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> dp = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> a [ b ] = 1 <NEWLINE> <DEDENT> dp [ 0 ] = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if a [ i ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] += dp [ i - 1 ] <NEWLINE> if i > 1 : <NEWLINE> <INDENT> dp [ i ] += dp [ i - 2 ] <NEWLINE> <DEDENT> dp [ i ] = dp [ i ] % mod <NEWLINE> <DEDENT> print ( dp [ N ] % mod ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> P_sum = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> P [ i ] = ( P [ i ] + 1 ) / 2 <NEWLINE> <NL> <DEDENT> for j in range ( K ) : <NEWLINE> <INDENT> P_sum += P [ j ] <NEWLINE> <NL> <DEDENT> ans = P_sum <NEWLINE> for t in range ( K , N ) : <NEWLINE> <INDENT> P_sum -= P [ t - K ] <NEWLINE> P_sum += P [ t ] <NEWLINE> ans = max ( ans , P_sum ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if i != K - 1 : <NEWLINE> <INDENT> print ( S [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( chr ( ord ( S [ i ] ) + 32 ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> x = 800 * n <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> y = 0 <NEWLINE> if n >= 15 : <NEWLINE> <INDENT> y = 200 * ( n // 15 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = x - y <NEWLINE> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , M = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> PY = np . array ( [ list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) for _ in range ( M ) ] ) <NEWLINE> <NL> l = [ [ ] for n in range ( N ) ] <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> l [ PY [ m , 0 ] - 1 ] . append ( PY [ m , 1 ] ) <NEWLINE> <NL> <DEDENT> dp = { } <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> if l [ n ] : <NEWLINE> <INDENT> l [ n ] . sort ( ) <NEWLINE> for i in range ( len ( l [ n ] ) ) : <NEWLINE> <INDENT> city = <STRING> + str ( n + 1 ) <NEWLINE> num = <STRING> + str ( i + 1 ) <NEWLINE> dp [ ( n , l [ n ] [ i ] - 1 ) ] = str ( city [ - 6 : ] + num [ - 6 : ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for m in range ( M ) : <NEWLINE> <INDENT> print ( dp [ ( PY [ m , 0 ] - 1 , PY [ m , 1 ] - 1 ) ] ) <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K > ( B - A ) / 2 : <NEWLINE> <INDENT> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( A , A + K ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( B - K + 1 , B + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < k : <NEWLINE> <INDENT> k -= a <NEWLINE> a = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= k <NEWLINE> k = 0 <NEWLINE> <NL> <DEDENT> b = max ( 0 , b - k ) <NEWLINE> print ( a , b ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xp = [ i for i in x if i >= 0 ] <NEWLINE> xn = [ i for i in x if i < 0 ] <NEWLINE> xn . reverse ( ) <NEWLINE> lp = len ( xp ) <NEWLINE> ln = len ( xn ) <NEWLINE> if lp == 0 : <NEWLINE> <INDENT> print ( - xn [ K - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ln == 0 : <NEWLINE> <INDENT> print ( xp [ K - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> pc = min ( K , lp ) <NEWLINE> pp = xp [ pc - 1 ] <NEWLINE> if K > lp : <NEWLINE> <INDENT> nc = K - lp <NEWLINE> np = - xn [ nc - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nc = 0 <NEWLINE> np = 0 <NEWLINE> <DEDENT> ans = pp + np + min ( pp , np ) <NEWLINE> for i in range ( pc - 1 ) : <NEWLINE> <INDENT> if nc == ln : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> pp = xp [ pc - i - 2 ] <NEWLINE> np = - xn [ nc ] <NEWLINE> nc += 1 <NEWLINE> ans = min ( ans , pp + np + min ( pp , np ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> count = [ 0 ] * ( m + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> count [ i [ 0 ] ] += 1 <NEWLINE> <DEDENT> l = [ 0 ] * n <NEWLINE> ans = max ( count ) <NEWLINE> s = set ( ) <NEWLINE> for i in range ( m - 1 ) : <NEWLINE> <INDENT> M = max ( count ) <NEWLINE> ind = count . index ( M ) <NEWLINE> s . add ( ind ) <NEWLINE> <NL> for j in range ( n ) : <NEWLINE> <INDENT> if a [ j ] [ l [ j ] ] == ind : <NEWLINE> <NL> <INDENT> count [ ind ] -= 1 <NEWLINE> while a [ j ] [ l [ j ] ] in s : <NEWLINE> <INDENT> l [ j ] += 1 <NEWLINE> <DEDENT> count [ a [ j ] [ l [ j ] ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , max ( count ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> q , ll = l // 2019 , l % 2019 <NEWLINE> rr = r % 2019 <NEWLINE> rng = [ * range ( ll , rr + 1 ) ] if r - l < ( 2019 * q - ll ) % 2019 else [ * range ( ll , 2019 ) ] + [ * range ( rr + 1 ) ] <NEWLINE> lenrng = len ( rng ) <NEWLINE> ans = 2020 <NEWLINE> for i in range ( lenrng - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , lenrng ) : <NEWLINE> <INDENT> tmp = rng [ i ] * rng [ j ] % 2019 <NEWLINE> if tmp < ans : <NEWLINE> <INDENT> ans = tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> m = 0 <NEWLINE> if s [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> m = 1 <NEWLINE> <DEDENT> t [ i + 1 ] = t [ i ] + m <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = A [ - 1 ] <NEWLINE> print ( B , min ( A , key = lambda x : abs ( B - 2 * x ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if n == 2 : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a + b ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> war = [ ] <NEWLINE> for i in range ( 1 , max ( a , b ) + 1 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> war . append ( i ) <NEWLINE> <DEDENT> <DEDENT> war . reverse ( ) <NEWLINE> <NL> print ( war [ k - 1 ] ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * ( n ) <NEWLINE> if k + 1 <= n : <NEWLINE> <INDENT> max = k + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max = n <NEWLINE> <NL> <DEDENT> for i in range ( 1 , max ) : <NEWLINE> <INDENT> dp [ i ] = abs ( h [ 0 ] - h [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( k , n ) : <NEWLINE> <INDENT> li = [ abs ( h [ i ] - h [ ik ] ) + dp [ ik ] for ik in range ( i - 1 , i - k - 1 , - 1 ) ] <NEWLINE> dp [ i ] = min ( li ) <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = p [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for i in p : <NEWLINE> <INDENT> if i <= l : <NEWLINE> <INDENT> ans += 1 <NEWLINE> l = i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( b - a ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit , i8 <NEWLINE> <NL> <NL> @ njit ( i8 ( i8 , i8 , i8 [ : ] , i8 [ : ] ) , cache = True ) <NEWLINE> def solve ( N , W , weights , values ) : <NEWLINE> <INDENT> dp = np . full ( ( N + 1 , W + 1 ) , 0 , dtype = np . int64 ) <NEWLINE> dp [ 0 ] [ 0 ] = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( W + 1 ) : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] = max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j ] ) <NEWLINE> if j + weights [ i ] <= W : <NEWLINE> <INDENT> dp [ i + 1 ] [ j + weights [ i ] ] = max ( <NEWLINE> <INDENT> dp [ i + 1 ] [ j + weights [ i ] ] , dp [ i ] [ j ] + values [ i ] <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp [ - 1 ] . max ( ) <NEWLINE> <NL> <NL> <DEDENT> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> weights = np . zeros ( N , dtype = np . int64 ) <NEWLINE> values = np . zeros ( N , dtype = np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> weights [ i ] = w <NEWLINE> values [ i ] = v <NEWLINE> <DEDENT> print ( solve ( N , W , weights , values ) ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - i - j <= k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> class Unionfind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = [ - 1 ] * n <NEWLINE> self . dist = [ 0 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return self . dist [ x ] , x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = self . find ( self . parents [ x ] ) <NEWLINE> self . dist [ x ] += tmp [ 0 ] <NEWLINE> self . parents [ x ] = tmp [ 1 ] <NEWLINE> <DEDENT> return self . dist [ x ] , self . parents [ x ] <NEWLINE> <NL> <DEDENT> def union ( self , x , y , d ) : <NEWLINE> <INDENT> rx = self . find ( x ) [ 1 ] <NEWLINE> ry = self . find ( y ) [ 1 ] <NEWLINE> diff = self . dist [ y ] - self . dist [ x ] - d <NEWLINE> if rx == ry : <NEWLINE> <INDENT> if diff != 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> if diff < 0 : <NEWLINE> <INDENT> rx , ry = ry , rx <NEWLINE> diff = - diff <NEWLINE> <DEDENT> self . parents [ ry ] = min ( self . parents [ ry ] , self . parents [ rx ] - diff ) <NEWLINE> self . parents [ rx ] = ry <NEWLINE> self . dist [ rx ] = diff <NEWLINE> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m , * lrd = map ( int , read ( ) . split ( ) ) <NEWLINE> v = Unionfind ( n ) <NEWLINE> for l , r , d in zip ( * [ iter ( lrd ) ] * 3 ) : <NEWLINE> <INDENT> if v . union ( l - 1 , r - 1 , d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if max ( - d - 1 for d in v . parents if d < 0 ) > 10 ** 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = [ int ( s ) for s in input ( ) . split ( <STRING> ) ] <NEWLINE> ac = 0 <NEWLINE> wa = 0 <NEWLINE> result = dict ( ) <NEWLINE> fail = dict ( ) <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( <STRING> ) <NEWLINE> if p in result and result [ p ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> fail [ p ] = fail . get ( p , 0 ) + 1 <NEWLINE> result [ p ] = s <NEWLINE> <DEDENT> elif s == <STRING> : <COMMENT> <NEWLINE> <INDENT> ac += 1 <NEWLINE> wa += fail . get ( p , 0 ) <NEWLINE> result [ p ] = s <NEWLINE> <NL> <DEDENT> <DEDENT> print ( str ( ac ) + <STRING> + str ( wa ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> import copy <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 10 ** 16 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> ni = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> na1 = lambda : list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = ns ( ) <NEWLINE> e = [ [ ] for _ in range ( n ) ] <NEWLINE> root = [ True for _ in range ( n ) ] <NEWLINE> prnt_cnt = [ 0 for _ in range ( n ) ] <NEWLINE> ans = [ - 1 for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( n - 1 + m ) : <NEWLINE> <INDENT> a , b = ns ( ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> e [ a ] . append ( b ) <NEWLINE> root [ b ] = False <NEWLINE> prnt_cnt [ b ] += 1 <NEWLINE> <NL> <DEDENT> root_idx = root . index ( True ) <NEWLINE> <NL> que = collections . deque ( [ root_idx ] ) <NEWLINE> <NL> while que : <NEWLINE> <INDENT> q = que . popleft ( ) <NEWLINE> <NL> for ei in e [ q ] : <NEWLINE> <INDENT> ans [ ei ] = q <NEWLINE> prnt_cnt [ ei ] -= 1 <NEWLINE> if prnt_cnt [ ei ] == 0 : <NEWLINE> <INDENT> que . append ( ei ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for ansi in ans : <NEWLINE> <INDENT> print ( ansi + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = np . zeros ( N + 1 , dtype = <STRING> ) <COMMENT> <NEWLINE> D = { 0 : 1 } <COMMENT> <NEWLINE> for i in range ( 1 , N + 1 ) : <COMMENT> <NEWLINE> <INDENT> S [ i ] = S [ i - 1 ] + A [ i - 1 ] <NEWLINE> if S [ i ] in D : D [ S [ i ] ] += 1 <NEWLINE> else : D [ S [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in D : <NEWLINE> <INDENT> ans += int ( D [ i ] * ( D [ i ] - 1 ) / 2 ) <COMMENT> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> bad = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> bad . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> dp = [ 0 for x in range ( n + 1 ) ] <NEWLINE> dp [ 0 ] = 1 <NEWLINE> idx = 0 <NEWLINE> if m > 0 and bad [ 0 ] == 1 : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> idx = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if idx < m and i == bad [ idx ] : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> idx += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % 1000000007 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE> <NL> <NL> <NL>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> def gdc ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return gdc ( b , a % b ) <NEWLINE> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // gdc ( a , b ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> T = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> return print ( T [ 0 ] ) <NEWLINE> <DEDENT> ans = lcm ( max ( T [ 0 ] , T [ 1 ] ) , min ( T [ 0 ] , T [ 1 ] ) ) <NEWLINE> if N == 2 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> return <NEWLINE> <DEDENT> for i in range ( 2 , N ) : <NEWLINE> <INDENT> ans = lcm ( max ( ans , T [ i ] ) , min ( ans , T [ i ] ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> lamps = [ list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) [ 1 : ] for _ in range ( m ) ] <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 << n ) : <NEWLINE> <INDENT> for r in range ( m ) : <NEWLINE> <INDENT> on_sum = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if i >> j & 1 and j in lamps [ r ] : <NEWLINE> <INDENT> on_sum += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if on_sum % 2 != p [ r ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( n * ( n - 1 ) // 2 ) <NEWLINE>
import sys <NEWLINE> <NL> H , W , A , B = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if i < B : <NEWLINE> <INDENT> if j < A : <NEWLINE> <INDENT> print ( 0 , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if j < A : <NEWLINE> <INDENT> print ( 1 , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> A = [ - a for a in A ] <NEWLINE> import heapq <NEWLINE> heapq . heapify ( A ) <NEWLINE> import bisect <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a = heapq . heappop ( A ) <NEWLINE> new = a / 2 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> heapq . heappush ( A , new ) <NEWLINE> <DEDENT> import numpy as np <NEWLINE> A = np . array ( A , dtype = np . int64 ) <NEWLINE> print ( - A . sum ( ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> s = [ sorted ( input ( ) ) for i in range ( N ) ] <NEWLINE> s . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> start = i <NEWLINE> end = N - 1 <NEWLINE> while start != end : <NEWLINE> <INDENT> center = ( start + end ) // 2 <NEWLINE> if s [ center ] == s [ i ] : <NEWLINE> <INDENT> if s [ center + 1 ] == s [ i ] : <NEWLINE> <INDENT> start = center + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start = end = center <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> end = center <NEWLINE> <DEDENT> <DEDENT> ans += start - i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from itertools import accumulate <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> fromleft = list ( accumulate ( a , math . gcd ) ) <NEWLINE> fromright = list ( accumulate ( a [ : : - 1 ] , math . gcd ) ) [ : : - 1 ] <NEWLINE> <NL> gcd = [ ] <NEWLINE> <NL> gcd . append ( fromright [ 1 ] ) <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> gcd . append ( math . gcd ( fromleft [ i - 1 ] , fromright [ i + 1 ] ) ) <NEWLINE> <DEDENT> gcd . append ( fromleft [ n - 2 ] ) <NEWLINE> <NL> print ( max ( gcd ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if s [ a ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( a + 1 , a + b ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from sys import setrecursionlimit <NEWLINE> <NL> <NL> def dfs ( i , j , c ) : <NEWLINE> <INDENT> visited [ i ] [ j ] = 1 <NEWLINE> current . append ( ( i , j ) ) <NEWLINE> for di , dj in ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) : <NEWLINE> <INDENT> ni , nj = i + di , j + dj <NEWLINE> if not ( 0 <= ni < H and 0 <= nj < W and not visited [ ni ] [ nj ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ ni ] [ nj ] == c : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( ni , nj , not c ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> setrecursionlimit ( 2 * 10 ** 5 ) <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ [ c == <STRING> for c in input ( ) ] for _ in range ( H ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> visited = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if S [ i ] [ j ] and not visited [ i ] [ j ] : <NEWLINE> <INDENT> current = [ ] <NEWLINE> dfs ( i , j , True ) <NEWLINE> b , w = 0 , 0 <NEWLINE> for k , l in current : <NEWLINE> <INDENT> if S [ k ] [ l ] : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w += 1 <NEWLINE> <DEDENT> <DEDENT> ans += b * w <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> march = [ 0 ] * 5 <NEWLINE> <NL> march_dic = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 , <STRING> : 3 , <STRING> : 4 } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> name = input ( ) <NEWLINE> if name [ 0 ] in <STRING> : <NEWLINE> <INDENT> march [ march_dic [ name [ 0 ] ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def count_type ( march ) : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for i in march : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> ans . sort ( ) <NEWLINE> return len ( ans ) , ans <NEWLINE> <NL> <DEDENT> type_num , each_num = count_type ( march ) <NEWLINE> if type_num < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( type_num - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , type_num - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , type_num ) : <NEWLINE> <INDENT> ans += each_num [ i ] * each_num [ j ] * each_num [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> head_s = [ ] <NEWLINE> back_s = [ ] <NEWLINE> n2 = 1 <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> n2 = 0 <NEWLINE> <DEDENT> for h in range ( n - 1 , - 1 , - 2 ) : <NEWLINE> <INDENT> head_s . append ( a [ h ] ) <NEWLINE> <DEDENT> for b in range ( n2 , n , 2 ) : <NEWLINE> <INDENT> back_s . append ( a [ b ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> ans_h = ( <STRING> . join ( map ( str , head_s ) ) ) <NEWLINE> ans_b = ( <STRING> . join ( map ( str , back_s ) ) ) <NEWLINE> print ( ans_h , ans_b ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> while A [ i ] % 2 == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> A [ i ] = A [ i ] // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> minnum = min ( a , b ) <NEWLINE> maxnum = max ( a , b ) <NEWLINE> lis = [ ] <NEWLINE> for mi in reversed ( range ( 1 , minnum + 1 ) ) : <NEWLINE> <INDENT> if minnum % mi == 0 and maxnum % mi == 0 : <NEWLINE> <INDENT> lis . append ( mi ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( lis [ k - 1 ] ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pos = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 10 ** 13 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> a1 = abs ( pos [ i ] ) + abs ( pos [ i ] - pos [ i + k - 1 ] ) <NEWLINE> a2 = abs ( pos [ i + k - 1 ] ) + abs ( pos [ i ] - pos [ i + k - 1 ] ) <NEWLINE> ans = min ( ans , a1 , a2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> cnt = [ 0 for _ in range ( 10 ** 5 + 1 ) ] <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> cnt [ a ] += 1 <NEWLINE> cnt [ a + 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ a - 1 ] += 1 <NEWLINE> cnt [ a ] += 1 <NEWLINE> cnt [ a + 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( cnt ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> XYH_list = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> XYH_list = sorted ( XYH_list , key = lambda x : x [ 2 ] , reverse = True ) <NEWLINE> <NL> for xi in range ( 0 , 101 ) : <NEWLINE> <INDENT> for yi in range ( 0 , 101 ) : <NEWLINE> <INDENT> tmpH = 0 <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> x , y , h = XYH_list [ k ] <NEWLINE> if k == 0 : <NEWLINE> <INDENT> tmpH = h + abs ( x - xi ) + abs ( y - yi ) <NEWLINE> <DEDENT> if h == max ( ( tmpH - abs ( x - xi ) - abs ( y - yi ) ) , 0 ) : <NEWLINE> <INDENT> if k == N - 1 : <NEWLINE> <INDENT> ans = [ str ( xi ) , str ( yi ) , str ( tmpH ) ] <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
q = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> MAX = 10 ** 5 + 1 <NEWLINE> l = [ 0 ] * MAX <NEWLINE> <NL> def is_prime ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for i in range ( 1 , MAX , 2 ) : <NEWLINE> <INDENT> if is_prime ( i ) and is_prime ( ( i + 1 ) / 2 ) : <NEWLINE> <INDENT> l [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> l2 = [ 0 ] * ( MAX + 1 ) <NEWLINE> for i in range ( 0 , MAX ) : <NEWLINE> <INDENT> l2 [ i + 1 ] = l2 [ i ] + l [ i ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> r += 1 <NEWLINE> print ( l2 [ r ] - l2 [ l ] ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ( 1 , a ) for a in map ( int , input ( ) . split ( ) ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> L . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> L = sorted ( L , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> ans , k = 0 , 0 <NEWLINE> for n , a in L : <NEWLINE> <INDENT> if n + k >= N : <NEWLINE> <INDENT> ans += a * ( N - k ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a * n <NEWLINE> k += n <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
ProNum = int ( input ( ) ) <NEWLINE> time = input ( ) <NEWLINE> time = ( time . split ( ) ) <NEWLINE> TotalTime = 0 <NEWLINE> <NL> for t in time : <NEWLINE> <INDENT> TotalTime += int ( t ) <NEWLINE> <NL> <DEDENT> DrinkNum = int ( input ( ) ) <NEWLINE> <NL> for d in range ( DrinkNum ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> line = line . split ( ) <NEWLINE> diff = int ( line [ 1 ] ) - int ( time [ int ( line [ 0 ] ) - 1 ] ) <NEWLINE> print ( TotalTime + diff ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = sorted ( [ ( i + 1 , a [ i ] ) for i in range ( n ) ] , key = lambda x : - x [ 1 ] ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> m = float ( <STRING> ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> m = min ( m , b [ i ] [ 0 ] ) <NEWLINE> if b [ i ] [ 1 ] == b [ i + 1 ] [ 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ m ] += ( i + 1 ) * ( b [ i ] [ 1 ] - b [ i + 1 ] [ 1 ] ) <NEWLINE> <DEDENT> ans [ 1 ] += sum ( a ) - sum ( ans ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = sum ( arr ) <NEWLINE> mt = [ 0 ] * N <NEWLINE> <NL> for j in range ( N - 1 ) : <NEWLINE> <INDENT> mt [ j + 1 ] = arr [ j ] * 2 - mt [ j ] <NEWLINE> <DEDENT> a = total - sum ( mt ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> mt [ i ] += a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mt [ i ] -= a <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * mt ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> INF = 10 ** 12 <NEWLINE> dp = [ INF ] * N <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - j ] + abs ( h [ i ] - h [ i - j ] ) for j in range ( 1 , min ( K , i ) + 1 ) ) <NEWLINE> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> if a == b : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( ( n - 2 ) * b - ( n - 2 ) * a ) + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> h , w = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> smat = [ input ( ) for _ in range ( h ) ] <NEWLINE> <NL> def bfs ( x0 , y0 ) : <NEWLINE> <INDENT> visited = [ [ 0 for _ in range ( w ) ] for _ in range ( h ) ] <NEWLINE> deq = collections . deque ( ) <NEWLINE> deq . append ( ( x0 , y0 , - 1 ) ) <NEWLINE> <NL> mx = 0 <NEWLINE> while len ( deq ) > 0 : <NEWLINE> <INDENT> x , y , d = deq . popleft ( ) <NEWLINE> nd = d + 1 <NEWLINE> visited [ x ] [ y ] = 1 <NEWLINE> mx = max ( mx , nd ) <NEWLINE> <NL> for dx , dy in [ ( - 1 , 0 ) , ( 0 , - 1 ) , ( + 1 , 0 ) , ( 0 , + 1 ) ] : <NEWLINE> <INDENT> nx = x + dx <NEWLINE> ny = y + dy <NEWLINE> if not ( 0 <= nx < h ) or not ( 0 <= ny < w ) : <NEWLINE> <COMMENT> <NL> <INDENT> continue <NEWLINE> <DEDENT> if smat [ nx ] [ ny ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> continue <NEWLINE> <DEDENT> if visited [ nx ] [ ny ] == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> continue <NEWLINE> <DEDENT> v = ( nx , ny , nd ) <NEWLINE> deq . append ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> return mx <NEWLINE> <NL> <DEDENT> if all ( all ( col == <STRING> for col in row ) for row in smat ) : <NEWLINE> <INDENT> print ( ( w - 1 ) + ( h - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mxall = 0 <NEWLINE> for x0 in range ( h ) : <NEWLINE> <INDENT> for y0 in range ( w ) : <NEWLINE> <INDENT> if smat [ x0 ] [ y0 ] == <STRING> : <NEWLINE> <INDENT> mx = bfs ( x0 , y0 ) <NEWLINE> mxall = max ( mxall , mx ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( mxall ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ a [ i ] - 1 ] == i + 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt // 2 ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> def main ( i , A ) : <NEWLINE> <INDENT> global N <NEWLINE> global ans <NEWLINE> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> if i == N - 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> return ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return main ( i + 1 , A ) <NEWLINE> <DEDENT> <DEDENT> elif A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> while i < N - 1 : <NEWLINE> <INDENT> if A [ i ] <= A [ i + 1 ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if i == N - 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> return ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return main ( i + 1 , A ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> return ans <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> while i < N - 1 : <NEWLINE> <INDENT> if A [ i ] >= A [ i + 1 ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if i == N - 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> return ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return main ( i + 1 , A ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( main ( 0 , A ) ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( H ) - 1 ) : <NEWLINE> <INDENT> if H [ i ] >= H [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( count ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> <DEDENT> if count != 0 : <NEWLINE> <INDENT> ans . append ( count ) <NEWLINE> <DEDENT> print ( max ( ans ) ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> word = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , i + k + 1 ) : <NEWLINE> <INDENT> word . append ( s [ i : j ] ) <NEWLINE> <DEDENT> <DEDENT> word = sorted ( list ( set ( word ) ) ) <NEWLINE> print ( word [ k - 1 ] ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x % y == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
n = <STRING> <NEWLINE> s = input ( ) <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> if n [ 0 ] == i : <COMMENT> <NEWLINE> <INDENT> n = n [ 1 : ] <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> n = n [ : : - 1 ] <NEWLINE> <NL> for i in s [ : : - 1 ] : <NEWLINE> <INDENT> if n == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif n [ 0 ] == i : <NEWLINE> <INDENT> n = n [ 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ False ] * ( k + 1 ) <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i - a_list [ j ] >= 0 : <NEWLINE> <INDENT> dp [ i ] |= not ( dp [ i - a_list [ j ] ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if dp [ k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> H , W , K = LI ( ) <NEWLINE> s = [ SS ( ) for _ in range ( H ) ] <NEWLINE> <NL> ans = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> <NL> <COMMENT> <NL> cnt = 1 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> is_first = True <NEWLINE> if s [ i ] . count ( <STRING> ) >= 1 : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> if is_first : <NEWLINE> <INDENT> is_first = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ans [ i ] [ j ] = cnt <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> first_strawberry_row = - 1 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> if s [ i ] . count ( <STRING> ) >= 1 : <NEWLINE> <INDENT> first_strawberry_row = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( first_strawberry_row , H ) : <NEWLINE> <INDENT> if s [ i ] . count ( <STRING> ) == 0 : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> ans [ i ] [ j ] = ans [ i - 1 ] [ j ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( first_strawberry_row ) : <NEWLINE> <INDENT> r = first_strawberry_row - 1 - i <NEWLINE> if s [ r ] . count ( <STRING> ) == 0 : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> ans [ r ] [ j ] = ans [ r + 1 ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( * i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> print ( <STRING> . join ( sorted ( S ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> L = list ( ) <NEWLINE> R = list ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( [ a , b ] ) <NEWLINE> <DEDENT> k = dict ( ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> a , b = L [ i ] <NEWLINE> c , d = L [ j ] <NEWLINE> R . append ( [ a - c , b - d ] ) <NEWLINE> n = str ( a - c ) + <STRING> + str ( b - d ) <NEWLINE> if n in k : <NEWLINE> <INDENT> k [ n ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k [ n ] = 1 <NEWLINE> <DEDENT> R . append ( [ c - a , d - b ] ) <NEWLINE> n = str ( c - a ) + <STRING> + str ( d - b ) <NEWLINE> if n in k : <NEWLINE> <INDENT> k [ n ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k [ n ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> op = max ( k . values ( ) ) <NEWLINE> print ( N - op ) <NEWLINE>
<COMMENT> <NL> from collections import defaultdict <NEWLINE> from math import sqrt , floor <NEWLINE> num , product = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = int ( sqrt ( product ) + 2 ) <NEWLINE> dd = defaultdict ( int ) <NEWLINE> <NL> for i in range ( 2 , cnt ) : <NEWLINE> <INDENT> if product % i == 0 : <NEWLINE> <INDENT> a = 0 <NEWLINE> while product % i == 0 : <NEWLINE> <INDENT> a += 1 <NEWLINE> product = product // i <NEWLINE> <DEDENT> dd [ i ] = a <NEWLINE> <DEDENT> <DEDENT> if product != 1 : <NEWLINE> <INDENT> dd [ product ] = 1 <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for p , n in dd . items ( ) : <NEWLINE> <INDENT> ans *= pow ( p , floor ( n / num ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> a = 0 <NEWLINE> count = [ ] <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> count . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> count . append ( a ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( list ( map ( int , count ) ) ) ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = [ ] <NEWLINE> a = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> add = 0 <NEWLINE> check = False <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if check and s [ i ] == <STRING> : <NEWLINE> <INDENT> add += 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> check = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> check = False <NEWLINE> <NL> <DEDENT> a [ i ] += add <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans . append ( a [ c - 1 ] - a [ b - 1 ] ) <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> x = input ( ) <NEWLINE> final = deque ( [ ] ) <NEWLINE> final . append ( x [ 0 ] ) <NEWLINE> for i in range ( 1 , len ( x ) ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> final . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not final : <NEWLINE> <INDENT> final . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> last = final . pop ( ) <NEWLINE> if last == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> final . append ( <STRING> ) <NEWLINE> final . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( final ) ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> data = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , l = map ( int , input ( ) . split ( ) ) <NEWLINE> data . append ( [ x , l ] ) <NEWLINE> <DEDENT> data = sorted ( data , key = lambda x : x [ 0 ] + x [ 1 ] ) <NEWLINE> ans = 0 <NEWLINE> pre = - ( 10 ** 10 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if data [ i ] [ 0 ] - data [ i ] [ 1 ] >= pre : <NEWLINE> <INDENT> ans += 1 <NEWLINE> pre = data [ i ] [ 0 ] + data [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , c = map ( int , input ( ) . split ( ) ) <NEWLINE> d = { e : [ 0 ] * ( c + 1 ) for e in range ( 100001 ) } <NEWLINE> d1 = [ 0 ] * 100001 <NEWLINE> m = map ( int , read ( ) . split ( ) ) <NEWLINE> stc = zip ( m , m , m ) <NEWLINE> for s , t , c in stc : <NEWLINE> <INDENT> if d [ s ] [ c ] : <NEWLINE> <INDENT> d1 [ s - 1 ] -= 1 <NEWLINE> d1 [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s ] [ c ] = 1 <NEWLINE> <DEDENT> if d [ t ] [ c ] : <NEWLINE> <INDENT> d1 [ t - 1 ] -= 1 <NEWLINE> d1 [ t ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ t ] [ c ] = 1 <NEWLINE> <DEDENT> d1 [ s - 1 ] += 1 <NEWLINE> d1 [ t ] -= 1 <NEWLINE> <NL> <DEDENT> cur = 0 <NEWLINE> r = 0 <NEWLINE> for i1 in range ( 100001 ) : <NEWLINE> <INDENT> cur += d1 [ i1 ] <NEWLINE> r = max ( r , cur ) <NEWLINE> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> d = dict ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> S = <STRING> . join ( sorted ( list ( S ) ) ) <NEWLINE> if S in d . keys ( ) : <NEWLINE> <INDENT> d [ S ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ S ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for n in d . values ( ) : <NEWLINE> <INDENT> ans += n * ( n - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> A = sorted ( AB , key = lambda x : x [ 0 ] ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> buy = min ( M , A [ i ] [ 1 ] ) <NEWLINE> ans += buy * A [ i ] [ 0 ] <NEWLINE> M -= buy <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <NL> def dfs ( tree , p , cnt , visited ) : <NEWLINE> <INDENT> visited [ p ] = True <NEWLINE> cnt_here = cnt [ p ] <NEWLINE> for c in tree . get ( p ) : <NEWLINE> <INDENT> if visited [ c ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt [ c ] += cnt_here <NEWLINE> dfs ( tree , c , cnt , visited ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> tree = defaultdict ( list ) <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ a ] . append ( b ) <NEWLINE> tree [ b ] . append ( a ) <NEWLINE> <DEDENT> tree = dict ( tree ) <NEWLINE> cnt = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ p ] += x <NEWLINE> <DEDENT> visited = [ False ] * ( n + 1 ) <NEWLINE> dfs ( tree , 1 , cnt , visited ) <NEWLINE> print ( * cnt [ 1 : ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> stairs = [ ] <NEWLINE> is_continuous = False <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> stairs . append ( int ( input ( ) ) ) <NEWLINE> if i > 0 and stairs [ i ] - 1 == stairs [ i - 1 ] : <NEWLINE> <INDENT> is_continuous = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if is_continuous : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> countup_num = [ 0 ] * ( n + 1 ) <NEWLINE> countup_num [ 0 ] = 1 <NEWLINE> countup_num [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> countup_num [ i ] = ( countup_num [ i - 1 ] + countup_num [ i - 2 ] ) % 1000000007 <NEWLINE> <DEDENT> res = 1 <NEWLINE> diff = 0 <NEWLINE> now = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> diff = stairs [ i ] - now - 1 <NEWLINE> now = stairs [ i ] + 1 <NEWLINE> res *= ( countup_num [ diff ] ) % 1000000007 <NEWLINE> <COMMENT> <NL> <DEDENT> if m == 0 : <NEWLINE> <INDENT> res = countup_num [ n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = n - stairs [ - 1 ] - 1 <NEWLINE> res *= ( countup_num [ diff ] ) % 1000000007 <NEWLINE> <NL> <DEDENT> res %= 1000000007 <NEWLINE> <COMMENT> <NL> print ( res ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> n = int ( s ) <NEWLINE> <NL> x = 1 <NEWLINE> <NL> for num in range ( n ) : <NEWLINE> <INDENT> x *= num + 1 <NEWLINE> x = x % ( ( 1000000000 ) + 7 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( x ) <NEWLINE>
import itertools <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( itertools . accumulate ( a ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in reversed ( range ( 1 , n ) ) : <NEWLINE> <INDENT> if b [ i - 1 ] * 2 < a [ i ] : <NEWLINE> <INDENT> return n - i <NEWLINE> <DEDENT> <DEDENT> return n <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> cb = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> cb . append ( [ c , b ] ) <NEWLINE> <DEDENT> cb . sort ( reverse = True ) <NEWLINE> k = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> while j < cb [ i ] [ 1 ] and k + j < n and a [ k + j ] < cb [ i ] [ 0 ] : <NEWLINE> <INDENT> a [ k + j ] = cb [ i ] [ 0 ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> k += j <NEWLINE> if k == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
from collections import Counter <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> dis_list = [ ] <NEWLINE> my_count = Counter ( ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> my_count [ i ] = 0 <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> my_count [ a ] += 1 <NEWLINE> my_count [ b ] += 1 <NEWLINE> <DEDENT> my_count = sorted ( my_count . items ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( my_count [ i ] [ 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_list = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> cp_list = a_list . copy ( ) <NEWLINE> cp_list . sort ( ) <NEWLINE> second_ans = cp_list [ - 2 ] <NEWLINE> ans = cp_list [ - 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a_list [ i ] == ans : <NEWLINE> <INDENT> print ( second_ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> lr_list = [ list ( map ( int , input ( ) . split ( ) ) ) for nesya in range ( q ) ] <NEWLINE> hoge = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> hoge [ i + 1 ] = hoge [ i ] + ( 1 if s [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <DEDENT> for lr in lr_list : <NEWLINE> <INDENT> l = lr [ 0 ] <NEWLINE> r = lr [ 1 ] <NEWLINE> print ( hoge [ r - 1 ] - hoge [ l - 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> dp = [ 1 ] <NEWLINE> col = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> col . append ( 1 ) <NEWLINE> dp . append ( dp [ - 1 ] * ( 4 - len ( col ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = 0 <NEWLINE> for c in range ( len ( col ) ) : <NEWLINE> <INDENT> if col [ c ] == A [ i ] : <NEWLINE> <INDENT> p += 1 <NEWLINE> if p == 1 : <NEWLINE> <INDENT> col [ c ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dp . append ( dp [ - 1 ] * p % mod ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ - 1 ] % mod ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> setA = set ( i for i in range ( a , min ( a + k , b + 1 ) ) ) <NEWLINE> setB = set ( j for j in range ( b , max ( b - k , a - 1 ) , - 1 ) ) <NEWLINE> l = list ( setA | setB ) <NEWLINE> l . sort ( ) <NEWLINE> for m in l : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> def divisor ( n ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> table = [ ] <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> table . append ( i ) <NEWLINE> table . append ( n // i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> table = list ( set ( table ) ) <NEWLINE> return table <NEWLINE> <NL> <DEDENT> a = divisor ( n ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> b = sorted ( a , reverse = True ) <NEWLINE> <NL> c = [ ] <NEWLINE> for i in range ( len ( a ) // 2 + 1 ) : <NEWLINE> <INDENT> d = a [ i ] - 1 + b [ i ] - 1 <NEWLINE> c . append ( d ) <NEWLINE> <NL> <DEDENT> print ( min ( c ) ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> s = list ( readline ( ) . rstrip ( ) ) <NEWLINE> sumS = 0 <NEWLINE> m = s . count ( <STRING> ) <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> sumS += ( len ( s ) - m ) - i <NEWLINE> m -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( sumS ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> ab_list = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> ab_list . append ( [ a , b ] ) <NEWLINE> <NL> <DEDENT> ans_list = [ 0 for i in range ( M ) ] <NEWLINE> for i in range ( M , 0 , - 1 ) : <NEWLINE> <INDENT> if i == M : <NEWLINE> <INDENT> ans_list [ i - 1 ] = N * ( N - 1 ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if uf . find ( ab_list [ i ] [ 0 ] ) != uf . find ( ab_list [ i ] [ 1 ] ) : <NEWLINE> <INDENT> ans_list [ i - 1 ] = ans_list [ i ] - uf . size ( ab_list [ i ] [ 0 ] ) * uf . size ( ab_list [ i ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_list [ i - 1 ] = ans_list [ i ] <NEWLINE> <DEDENT> uf . union ( ab_list [ i ] [ 0 ] , ab_list [ i ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( * ans_list ) <NEWLINE>
def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if len ( make_divisors ( i ) ) == 8 and i % 2 == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> n = 0 <NEWLINE> <NL> for y in range ( a + 1 ) : <NEWLINE> <INDENT> for z in range ( a + 1 ) : <NEWLINE> <INDENT> p = b - y - z <NEWLINE> if 0 <= p and p <= a : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( n ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) - 1 ) <NEWLINE> <NL> <DEDENT> ans = - 1 <NEWLINE> push = 0 <NEWLINE> count = [ False ] * N <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <NL> <INDENT> if A [ push ] == 1 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> elif count [ push ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> count [ push ] = True <NEWLINE> push = A [ push ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> T = T // math . gcd ( T , t ) * t <NEWLINE> <DEDENT> print ( T ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = [ ] <NEWLINE> j = 0 <NEWLINE> st = 0 <COMMENT> <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> while j < W : <NEWLINE> <INDENT> while 0 < a [ st ] and j < W : <NEWLINE> <INDENT> res . append ( str ( st + 1 ) ) <NEWLINE> j += 1 <NEWLINE> a [ st ] -= 1 <NEWLINE> <DEDENT> if a [ st ] == 0 : <NEWLINE> <INDENT> st += 1 <NEWLINE> <DEDENT> <DEDENT> if i % 2 == 1 : <NEWLINE> <INDENT> res . reverse ( ) <NEWLINE> <DEDENT> print ( <STRING> . join ( res ) ) <NEWLINE> res = [ ] <NEWLINE> <DEDENT>
H = int ( input ( ) ) <NEWLINE> def f ( H ) : <NEWLINE> <INDENT> if H == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif H > 1 : <NEWLINE> <INDENT> return 2 * f ( H // 2 ) + 1 <NEWLINE> <DEDENT> <DEDENT> re = 0 <NEWLINE> re = f ( H ) <NEWLINE> print ( re ) <NEWLINE>
d , g = map ( int , input ( ) . split ( ) ) <NEWLINE> pc = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( d ) ] <NEWLINE> <NL> ans = float ( <STRING> ) <NEWLINE> <NL> for bit in range ( 1 << d ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> sum = 0 <NEWLINE> nokori = set ( range ( 1 , d + 1 ) ) <NEWLINE> <NL> for i in range ( d ) : <NEWLINE> <INDENT> if bit & ( 1 << i ) : <NEWLINE> <INDENT> sum += pc [ i ] [ 0 ] * ( i + 1 ) * 100 + pc [ i ] [ 1 ] <NEWLINE> count += pc [ i ] [ 0 ] <NEWLINE> nokori . discard ( i + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if sum < g : <NEWLINE> <INDENT> use = max ( nokori ) <NEWLINE> n = min ( pc [ use - 1 ] [ 0 ] , - ( - ( g - sum ) // ( use * 100 ) ) ) <NEWLINE> count += n <NEWLINE> sum += n * use * 100 <NEWLINE> <NL> <DEDENT> if sum >= g : <NEWLINE> <INDENT> ans = min ( ans , count ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> if k == 1 or len ( s ) == 1 : <NEWLINE> <INDENT> ans = list ( s ) [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = None <NEWLINE> for i , j in enumerate ( list ( s ) ) : <NEWLINE> <INDENT> if i < k - 1 : <NEWLINE> <INDENT> if j != <STRING> : <NEWLINE> <INDENT> ans = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> elif i == k - 1 : <NEWLINE> <INDENT> ans = j <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( list ( s ) ) - 2 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> and s [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> T = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> T [ a - 1 ] . append ( ( b - 1 , c ) ) <NEWLINE> T [ b - 1 ] . append ( ( a - 1 , c ) ) <NEWLINE> <NL> <DEDENT> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> D = [ - 1 ] * N <NEWLINE> D [ K - 1 ] = 0 <NEWLINE> def dfs ( start , nowd ) : <NEWLINE> <INDENT> to = T [ start ] <NEWLINE> for t in to : <NEWLINE> <INDENT> next_node , c = t <NEWLINE> if D [ next_node ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> nextd = nowd + c <NEWLINE> D [ next_node ] = nextd <NEWLINE> dfs ( next_node , nextd ) <NEWLINE> <DEDENT> <DEDENT> dfs ( K - 1 , 0 ) <NEWLINE> <COMMENT> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( D [ x - 1 ] + D [ y - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from itertools import accumulate <NEWLINE> <NL> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n , k = rm ( ) <NEWLINE> a = [ ( i + 1 ) / 2 for i in rl ( ) ] <NEWLINE> a = [ 0 ] + list ( accumulate ( a ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , a [ i + k ] - a [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> data = [ 0 ] * 3 <NEWLINE> ans = 1 <NEWLINE> mod = pow ( 10 , 9 ) + 7 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans *= data . count ( i ) <NEWLINE> ans %= mod <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> data [ data . index ( i ) ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b = input ( ) . split ( <STRING> ) <NEWLINE> if int ( a ) >= 13 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif int ( a ) in range ( 6 , 13 ) : <NEWLINE> <INDENT> print ( int ( b ) // 2 ) <NEWLINE> <DEDENT> elif int ( a ) <= 5 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> def readinput ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> nList = [ ] <NEWLINE> for _ in range ( n + 1 ) : <NEWLINE> <INDENT> nList . append ( [ ] ) <NEWLINE> <DEDENT> edges = [ ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges . append ( ( a , b ) ) <NEWLINE> nList [ a ] . append ( b ) <NEWLINE> <COMMENT> <NL> <DEDENT> return n , nList , edges <NEWLINE> <NL> <DEDENT> def bfs ( s , nList ) : <NEWLINE> <COMMENT> <NL> <INDENT> WHITE = 0 <NEWLINE> GRAY = 1 <NEWLINE> BLACK = 2 <NEWLINE> status = [ WHITE ] * ( n + 1 ) <NEWLINE> parent = [ 0 ] * ( n + 1 ) <NEWLINE> color = [ 0 ] * ( n + 1 ) <NEWLINE> maxcolor = 0 <NEWLINE> Q = deque ( [ ] ) <NEWLINE> Q . append ( s ) <NEWLINE> while ( len ( Q ) > 0 ) : <NEWLINE> <INDENT> u = Q . popleft ( ) <NEWLINE> usedcolor = color [ u ] <NEWLINE> col = 1 <NEWLINE> for t in nList [ u ] : <NEWLINE> <INDENT> if status [ t ] == WHITE : <NEWLINE> <INDENT> status [ t ] = GRAY <NEWLINE> parent [ t ] = u <NEWLINE> if col == usedcolor : <NEWLINE> <INDENT> col += 1 <NEWLINE> <DEDENT> color [ t ] = col <NEWLINE> Q . append ( t ) <NEWLINE> col += 1 <NEWLINE> <DEDENT> <DEDENT> maxcolor = max ( maxcolor , col - 1 ) <NEWLINE> status [ u ] = BLACK <NEWLINE> <COMMENT> <NL> <DEDENT> return color , maxcolor <NEWLINE> <NL> <NL> <DEDENT> def main ( n , nList , edges ) : <NEWLINE> <INDENT> color , maxcolor = bfs ( 1 , nList ) <NEWLINE> print ( maxcolor ) <NEWLINE> for a , b in edges : <NEWLINE> <INDENT> print ( color [ b ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , nList , edges = readinput ( ) <NEWLINE> main ( n , nList , edges ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> in_n = lambda : int ( readline ( ) ) <NEWLINE> in_nn = lambda : map ( int , readline ( ) . split ( ) ) <NEWLINE> in_nl = lambda : list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> in_na = lambda : map ( int , read ( ) . split ( ) ) <NEWLINE> in_s = lambda : readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> <NL> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> N , X = in_nn ( ) <NEWLINE> <NL> blen = [ 0 ] * ( N + 1 ) <NEWLINE> blen [ 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> blen [ i + 1 ] = blen [ i ] * 2 + 3 <NEWLINE> <NL> <DEDENT> pcount = [ 0 ] * ( N + 1 ) <NEWLINE> pcount [ 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> pcount [ i + 1 ] = pcount [ i ] * 2 + 1 <NEWLINE> <NL> <NL> <DEDENT> def count ( L , X ) : <NEWLINE> <NL> <INDENT> if L == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> if X == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> if X <= blen [ L ] // 2 : <NEWLINE> <INDENT> ret += count ( L - 1 , X - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret += pcount [ L - 1 ] + 1 <NEWLINE> if X > blen [ L ] // 2 + 1 : <NEWLINE> <INDENT> X -= blen [ L ] // 2 + 1 <NEWLINE> X = min ( X , blen [ L - 1 ] ) <NEWLINE> ret += count ( L - 1 , X ) <NEWLINE> <NL> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> ans = count ( N , X ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> a = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> ans = [ ] <NEWLINE> c = 0 <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += [ c ] <NEWLINE> c = 0 <NEWLINE> <DEDENT> <DEDENT> ans += [ c ] <NEWLINE> if ans == [ ] : <NEWLINE> <INDENT> print ( len ( s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( ans ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lrs = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> cards = [ lrs [ 0 ] [ 0 ] , lrs [ 0 ] [ 1 ] ] <COMMENT> <NEWLINE> <NL> for lr in lrs [ 1 : ] : <NEWLINE> <INDENT> if ( lr [ 1 ] < cards [ 0 ] ) or ( lr [ 0 ] > cards [ 1 ] ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> cards [ 0 ] = max ( cards [ 0 ] , lr [ 0 ] ) <NEWLINE> cards [ 1 ] = min ( cards [ 1 ] , lr [ 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> print ( cards [ 1 ] - cards [ 0 ] + 1 ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> x = 0 <NEWLINE> c = 0 <NEWLINE> x1 = 0 <NEWLINE> t = [ ] <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if c > x : <NEWLINE> <INDENT> x = c <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> c -= 1 <NEWLINE> <DEDENT> if c > x1 : <NEWLINE> <INDENT> x1 = c <NEWLINE> <NL> <DEDENT> t . append ( max ( x1 , x ) ) <NEWLINE> <DEDENT> print ( max ( t ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> lb = 0 <NEWLINE> ub = 3 * n - 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lb += 1 <NEWLINE> ub -= 1 <NEWLINE> ans += a [ ub ] <NEWLINE> ub -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> keep = [ 0 ] * ( n ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> keep [ i ] = keep [ i - 1 ] <NEWLINE> l , r = i - 1 , i + 1 <NEWLINE> if s [ l : r ] == <STRING> : <NEWLINE> <INDENT> keep [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( keep [ r - 1 ] - keep [ l - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> h . sort ( reverse = True ) <NEWLINE> <NL> if len ( h ) <= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> del h [ 0 : k ] <NEWLINE> <NL> <DEDENT> a = sum ( h ) <NEWLINE> <NL> print ( a ) <NEWLINE>
from itertools import product <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> ans = n - 1 <NEWLINE> for a in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % a == 0 : <NEWLINE> <INDENT> b = n // a <NEWLINE> ans = min ( ans , b + a - 2 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> S = [ i for i in str ( input ( ) ) ] <NEWLINE> c = Counter ( S ) <NEWLINE> m = c . most_common ( ) <NEWLINE> <NL> n = len ( S ) // 3 <NEWLINE> if len ( S ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( S ) == 2 : <NEWLINE> <INDENT> if len ( m ) == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif len ( m ) < 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( S ) % 3 == 0 : <NEWLINE> <INDENT> if ( m [ 0 ] [ 1 ] == n ) and ( m [ 1 ] [ 1 ] == n ) and ( m [ 2 ] [ 1 ] == n ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif len ( S ) % 3 == 1 : <NEWLINE> <INDENT> if ( m [ 0 ] [ 1 ] == n + 1 ) and ( m [ 1 ] [ 1 ] == n ) and ( m [ 2 ] [ 1 ] == n ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( m [ 0 ] [ 1 ] == n + 1 ) and ( m [ 1 ] [ 1 ] == n + 1 ) and ( m [ 2 ] [ 1 ] == n ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) . rstrip ( <STRING> ) <NEWLINE> count = [ 0 ] * ( N + 2 ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> count [ i + 1 ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> count [ i ] += count [ i - 1 ] <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( count [ r - 1 ] - count [ l - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> from sys import setrecursionlimit <NEWLINE> setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> xl = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xl = list ( map ( lambda y : abs ( y - x ) , xl ) ) <NEWLINE> <NL> ans = - 1 <NEWLINE> if len ( xl ) == 1 : <NEWLINE> <INDENT> ans = xl [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = gcd ( * xl ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import collections <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> maze = [ [ None for _ in range ( W ) ] for _ in range ( H ) ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> maze [ i ] = list ( input ( ) ) <NEWLINE> <NL> <DEDENT> dx = [ 1 , 0 , - 1 , 0 ] <NEWLINE> dy = [ 0 , 1 , 0 , - 1 ] <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for j in range ( H ) : <NEWLINE> <INDENT> for k in range ( W ) : <NEWLINE> <INDENT> if maze [ j ] [ k ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sy = j <NEWLINE> sx = k <NEWLINE> <NL> seen = [ [ - 1 for _ in range ( W ) ] for _ in range ( H ) ] <NEWLINE> seen [ sy ] [ sx ] = 0 <NEWLINE> <NL> que = collections . deque ( ) <COMMENT> <NEWLINE> que . append ( [ sy , sx ] ) <NEWLINE> <NL> while ( len ( que ) != 0 ) : <NEWLINE> <INDENT> p = que . popleft ( ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> ny = p [ 0 ] + dy [ i ] <NEWLINE> nx = p [ 1 ] + dx [ i ] <NEWLINE> if ( ny >= 0 and nx >= 0 and ny < H and nx < W and seen [ ny ] [ nx ] == - 1 and maze [ ny ] [ nx ] != <STRING> ) : <NEWLINE> <INDENT> seen [ ny ] [ nx ] = seen [ p [ 0 ] ] [ p [ 1 ] ] + 1 <NEWLINE> que . append ( [ ny , nx ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> cnt = max ( cnt , max ( [ x for row in seen for x in row ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> if S [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> acgt_list = [ 0 ] <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( S ) + 1 ) : <NEWLINE> <INDENT> slen = len ( S [ i : j ] ) <NEWLINE> temp = 0 <NEWLINE> for s in S [ i : j ] : <NEWLINE> <INDENT> if s == <STRING> or s == <STRING> or s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> <DEDENT> if temp == slen : <NEWLINE> <INDENT> acgt_list . append ( slen ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max ( acgt_list ) ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> bb = b // x <NEWLINE> aa = a // x <NEWLINE> ans = bb - aa <NEWLINE> if a % x == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<NL> <NL> <NL> a , b , c , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> price = a * x + b * y <NEWLINE> <NL> <NL> for i in range ( max ( x , y ) + 1 ) : <NEWLINE> <INDENT> ab = 2 * i <NEWLINE> cand = ab * c + a * max ( 0 , x - i ) + b * max ( 0 , y - i ) <NEWLINE> <NL> price = min ( price , cand ) <NEWLINE> <NL> <DEDENT> print ( price ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> al = [ ] <NEWLINE> bl = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> al . append ( [ a , b ] ) <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> bl . append ( [ c , d ] ) <NEWLINE> <NL> <DEDENT> def check ( a , b ) : <NEWLINE> <INDENT> x = a [ 0 ] - b [ 0 ] <NEWLINE> y = a [ 1 ] - b [ 1 ] <NEWLINE> if x < 0 : <NEWLINE> <INDENT> x = - x <NEWLINE> <DEDENT> if y < 0 : <NEWLINE> <INDENT> y = - y <NEWLINE> <DEDENT> return x + y <NEWLINE> <NL> <DEDENT> for a in al : <NEWLINE> <INDENT> min = 1000000000 <NEWLINE> cnt = 1 <NEWLINE> for b in bl : <NEWLINE> <INDENT> tmp = check ( a , b ) <NEWLINE> if tmp < min : <NEWLINE> <INDENT> ans = cnt <NEWLINE> min = tmp <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if ( i + 1 ) * i // 2 >= x : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = defaultdict ( int ) <NEWLINE> <NL> for x in arr : <NEWLINE> <INDENT> d [ x ] += 1 <NEWLINE> d [ x - 1 ] += 1 <NEWLINE> d [ x + 1 ] += 1 <NEWLINE> <NL> <DEDENT> result = [ y for x , y in d . items ( ) ] <NEWLINE> <NL> print ( max ( result ) ) <NEWLINE>
try : <NEWLINE> <INDENT> n = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> lis1 = [ ] <NEWLINE> for i in range ( 0 , len ( n ) ) : <NEWLINE> <INDENT> for a in range ( 0 , len ( n ) ) : <NEWLINE> <INDENT> if a != i : <NEWLINE> <INDENT> z = ( int ( n [ a ] ) + int ( n [ i ] ) ) <NEWLINE> lis1 . append ( z ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> minscore = <STRING> <NEWLINE> for i in range ( 0 , len ( lis1 ) ) : <NEWLINE> <INDENT> if float ( minscore ) > float ( lis1 [ i ] ) : <NEWLINE> <INDENT> minscore = lis1 [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( minscore ) <NEWLINE> <NL> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
h = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if h == 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> ans = ans * 2 + 1 <NEWLINE> h //= 2 <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m > 0 : <NEWLINE> <INDENT> p , s = zip ( * [ input ( ) . split ( ) for _ in range ( m ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = [ ] <NEWLINE> s = [ ] <NEWLINE> <NL> <DEDENT> ac_dict = { str ( i ) : False for i in range ( 1 , n + 1 ) } <NEWLINE> wa_dict = { str ( i ) : 0 for i in range ( 1 , n + 1 ) } <NEWLINE> ac_num = 0 <NEWLINE> wa_num = 0 <NEWLINE> for p_i , s_i in zip ( p , s ) : <NEWLINE> <INDENT> if ac_dict [ p_i ] == False : <NEWLINE> <INDENT> if s_i == <STRING> : <NEWLINE> <INDENT> ac_num += 1 <NEWLINE> wa_num += wa_dict [ p_i ] <NEWLINE> ac_dict [ p_i ] = True <NEWLINE> <DEDENT> elif s_i == <STRING> : <NEWLINE> <INDENT> wa_dict [ p_i ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . format ( ac_num , wa_num ) ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> a = <STRING> <NEWLINE> b = <STRING> <NEWLINE> if 0 < int ( s [ 0 : 2 ] ) < 13 : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> <DEDENT> if 0 < int ( s [ 2 : 5 ] ) < 13 : <NEWLINE> <INDENT> b = <STRING> <NEWLINE> <NL> <DEDENT> if a == b == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif a == <STRING> and b == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif a == <STRING> and b == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
h , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( w ) ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> tmp_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( w ) : <NEWLINE> <INDENT> g [ i ] . append ( tmp_list [ i ] ) <NEWLINE> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> qs = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> loc = [ 0 ] * ( h * w + 1 ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> loc [ g [ j ] [ i ] ] = ( i , j ) <NEWLINE> <DEDENT> <DEDENT> roots = [ 0 ] * ( h * w + 1 ) <NEWLINE> for i in range ( 1 , d + 1 ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> while j < h * w + 1 : <NEWLINE> <INDENT> cost = abs ( loc [ j ] [ 0 ] - loc [ j - d ] [ 0 ] ) + abs ( loc [ j ] [ 1 ] - loc [ j - d ] [ 1 ] ) <NEWLINE> roots [ j ] = cost + roots [ j - d ] <NEWLINE> j += d <NEWLINE> <DEDENT> <DEDENT> for i in qs : <NEWLINE> <INDENT> l , r = i [ 0 ] , i [ 1 ] <NEWLINE> print ( roots [ r ] - roots [ l ] ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> ls = len ( s ) <NEWLINE> r = [ 0 ] * ls <NEWLINE> c = 0 <NEWLINE> for ii in range ( ls - 1 ) : <NEWLINE> <INDENT> if s [ ii ] == <STRING> and s [ ii + 1 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> elif s [ ii ] == <STRING> and s [ ii + 1 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> r [ ii ] += c // 2 + c % 2 <NEWLINE> r [ ii + 1 ] += c // 2 <NEWLINE> c = 0 <NEWLINE> <DEDENT> elif s [ ii ] == <STRING> and s [ ii + 1 ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif s [ ii ] == <STRING> and s [ ii + 1 ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> c = 0 <NEWLINE> for jj in range ( ls - 1 ) : <NEWLINE> <INDENT> ii = ls - 1 - jj <NEWLINE> if s [ ii - 1 ] == <STRING> and s [ ii ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif s [ ii - 1 ] == <STRING> and s [ ii ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> r [ ii - 1 ] += c // 2 <NEWLINE> r [ ii ] += c // 2 + c % 2 <NEWLINE> c = 0 <NEWLINE> <DEDENT> elif s [ ii - 1 ] == <STRING> and s [ ii ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> elif s [ ii - 1 ] == <STRING> and s [ ii ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( * r ) <NEWLINE>
import os , sys , re , math <NEWLINE> <NL> <NL> def get_exp_value ( number ) : <NEWLINE> <INDENT> if number == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> a = ( number + 1 ) / number <NEWLINE> exp = a * ( number // 2 ) <NEWLINE> if number % 2 != 0 : <NEWLINE> <INDENT> exp += a / 2 <NEWLINE> <NL> <DEDENT> return exp <NEWLINE> <NL> <NL> <DEDENT> ( N , K ) = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> P = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> exps = [ get_exp_value ( i ) for i in range ( 200001 ) ] <NEWLINE> <NL> s = sum ( P [ 0 : K ] ) <NEWLINE> max_sum = 0 <NEWLINE> max_pos = 0 <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> s = s - P [ i - K ] + P [ i ] <NEWLINE> if s > max_sum : <NEWLINE> <INDENT> max_sum = s <NEWLINE> max_pos = i <NEWLINE> <NL> <DEDENT> <DEDENT> answer = 0 <NEWLINE> for i in range ( max_pos - K , max_pos ) : <NEWLINE> <INDENT> answer += exps [ P [ i + 1 ] ] <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
from bisect import bisect <NEWLINE> k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> rekkyo = [ ] <NEWLINE> for i in range ( 0 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - i - j <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> dic = { } <NEWLINE> def ADD ( x ) : <NEWLINE> <INDENT> if x in dic : <NEWLINE> <INDENT> dic [ x ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ x ] = 1 <NEWLINE> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 2 , int ( m ** 0.5 + 2 ) ) : <NEWLINE> <INDENT> while m % i == 0 : <NEWLINE> <INDENT> ADD ( i ) <NEWLINE> m //= i <NEWLINE> <DEDENT> <DEDENT> if m > 1 : <NEWLINE> <INDENT> ADD ( m ) <NEWLINE> <DEDENT> dic = tuple ( dic . values ( ) ) <NEWLINE> ans = 1 <NEWLINE> fac = [ 1 ] <NEWLINE> for i in range ( 10 ** 6 ) : <NEWLINE> <INDENT> fac . append ( fac [ - 1 ] * ( i + 1 ) % mod ) <NEWLINE> <DEDENT> def c ( a , b ) : <NEWLINE> <INDENT> r = pow ( fac [ b ] * fac [ a - b ] % mod , mod - 2 , mod ) <NEWLINE> return fac [ a ] * r % mod <NEWLINE> <DEDENT> for x in dic : <NEWLINE> <INDENT> ans *= c ( x + n - 1 , x ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 10 ** 18 <NEWLINE> <NL> for i in range ( 1 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> b = N // i <NEWLINE> ans = min ( ans , max ( len ( str ( i ) ) , len ( str ( b ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> l = [ abs ( li [ i ] - li [ j ] ) + ans [ j ] for j in range ( max ( 0 , i - k ) , i ) ] <NEWLINE> <COMMENT> <NL> ans [ i ] = min ( l ) <NEWLINE> <DEDENT> print ( ans [ - 1 ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> RW_cnt = S . count ( <STRING> ) <NEWLINE> RE_cnt = S . count ( <STRING> ) <NEWLINE> LW_cnt = 0 <NEWLINE> LE_cnt = 0 <NEWLINE> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> RW_cnt -= 1 <NEWLINE> LW_cnt = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> RE_cnt -= 1 <NEWLINE> LE_cnt = 1 <NEWLINE> <DEDENT> ans = RE_cnt <NEWLINE> <COMMENT> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> cnt = LW_cnt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = LW_cnt + RE_cnt <NEWLINE> <DEDENT> if cnt < ans : <NEWLINE> <INDENT> ans = cnt <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> LE_cnt += 1 <NEWLINE> RE_cnt -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> LW_cnt += 1 <NEWLINE> RW_cnt -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> result = 0 <NEWLINE> cnt = collections . Counter ( a ) <NEWLINE> for i in cnt . values ( ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> result += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> counter = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> str_i = str ( i ) <NEWLINE> i_dig = s . find ( str_i ) <NEWLINE> if i_dig == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> str_j = str ( j ) <NEWLINE> j_dig = s . find ( str_j , i_dig + 1 ) <NEWLINE> if j_dig == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> str_k = str ( k ) <NEWLINE> k_dig = s . find ( str_k , j_dig + 1 ) <NEWLINE> if k_dig != - 1 : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d [ i + 1 ] = a [ i ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if d [ d [ i + 1 ] ] == i + 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> ans //= 2 <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <COMMENT> <NL> <NL> INF = 10 ** 9 <NEWLINE> <NL> <COMMENT> <NL> def solve ( n ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s += i + 1 <NEWLINE> l += [ i + 1 ] <NEWLINE> if s > n : <NEWLINE> <INDENT> l . remove ( s - n ) <NEWLINE> return l <NEWLINE> <DEDENT> elif s == n : <NEWLINE> <INDENT> return l <NEWLINE> <NL> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( * solve ( N ) , sep = <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> dp = [ - 1 ] * N <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> idx = bisect . bisect_left ( dp , a ) <NEWLINE> dp [ idx - 1 ] = a <NEWLINE> <DEDENT> print ( len ( dp [ bisect . bisect_left ( dp , 0 ) : ] ) ) <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = False <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for j in range ( N + 1 - i ) : <NEWLINE> <INDENT> if Y == 10000 * i + 5000 * j + 1000 * ( N - i - j ) : <NEWLINE> <INDENT> a = [ str ( i ) , str ( j ) , str ( N - i - j ) ] <NEWLINE> print ( <STRING> . join ( a ) ) <NEWLINE> c = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if c : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if not c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for i in range ( n ) ] <NEWLINE> counter = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a - 1 ] . append ( b - 1 ) <NEWLINE> edges [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> counter [ p - 1 ] += x <NEWLINE> <DEDENT> def dfs ( now , prev ) : <NEWLINE> <INDENT> for next in edges [ now ] : <NEWLINE> <INDENT> if next == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> counter [ next ] += counter [ now ] <NEWLINE> dfs ( next , now ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> print ( * counter ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for p in range ( 10 ) : <NEWLINE> <INDENT> s = S . find ( str ( p ) ) <NEWLINE> if s == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for q in range ( 10 ) : <NEWLINE> <INDENT> t = S . find ( str ( q ) , s + 1 ) <NEWLINE> if t == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for r in range ( 10 ) : <NEWLINE> <INDENT> u = S . find ( str ( r ) , t + 1 ) <NEWLINE> if u != - 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> if sum ( S ) % 10 != 0 : <NEWLINE> <INDENT> print ( sum ( S ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = sorted ( S ) <NEWLINE> for i in A : <NEWLINE> <INDENT> if ( sum ( S ) - i ) % 10 != 0 : <NEWLINE> <INDENT> print ( sum ( S ) - i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE> <DEDENT>
import copy <NEWLINE> s = input ( ) <NEWLINE> check = <STRING> <NEWLINE> tmp = 6 <NEWLINE> sNow = 0 <NEWLINE> cNow = 0 <NEWLINE> <COMMENT> <NL> for i in s : <NEWLINE> <INDENT> sNow += 1 <NEWLINE> if i == check [ cNow ] : <NEWLINE> <INDENT> cNow += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if cNow == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <STRING> <NEWLINE> if check [ cNow : ] == s [ - 1 * ( 7 - cNow ) : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( [ k - q ] * n ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> def prime_check ( n ) : <NEWLINE> <INDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> if x != 2 : <NEWLINE> <INDENT> if x % 2 == 0 : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> while 1 : <NEWLINE> <INDENT> if prime_check ( x ) == True : <NEWLINE> <INDENT> print ( x ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x += 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> E = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> E . append ( ( P [ i ] + 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> tnt = sum ( E [ : K ] ) <NEWLINE> ans = tnt <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> tnt = tnt + E [ K + i ] - E [ i ] <NEWLINE> ans = max ( ans , tnt ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = [ <STRING> . join ( sorted ( list ( input ( ) ) ) ) for i in range ( N ) ] <NEWLINE> c = collections . Counter ( S ) <NEWLINE> print ( sum ( [ int ( x * ( x - 1 ) / 2 ) for x in c . values ( ) ] ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import heapq <NEWLINE> <NL> n , m = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> <NL> q = [ ] <NEWLINE> a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> heapq . heappush ( q , ( a [ i ] * ( - 1 ) , 1 ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> heapq . heappush ( q , ( c * ( - 1 ) , b ) ) <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> c , b = heapq . heappop ( q ) <NEWLINE> res += c * ( - 1 ) <NEWLINE> if b > 1 : <NEWLINE> <INDENT> b -= 1 <NEWLINE> heapq . heappush ( q , ( c , b ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> hn = [ int ( num ) for num in input ( ) . split ( ) ] <NEWLINE> <NL> hn . sort ( reverse = True ) <NEWLINE> if len ( hn ) > k : <NEWLINE> <INDENT> print ( sum ( hn [ k : ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
from heapq import nlargest <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> b = nlargest ( 2 , a ) <NEWLINE> ma = max ( a ) <NEWLINE> for j in a : <NEWLINE> <INDENT> if j == ma : <NEWLINE> <INDENT> print ( b [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ma ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> N = len ( s ) <NEWLINE> <NL> d = dict ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i , min ( N , i + K ) ) : <NEWLINE> <INDENT> sub = s [ i : j + 1 ] <NEWLINE> if d . get ( sub ) == None : <NEWLINE> <INDENT> d [ sub ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> d2 = sorted ( d . items ( ) ) <NEWLINE> print ( d2 [ K - 1 ] [ 0 ] ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ <STRING> * ( W + 2 ) ] + [ <STRING> + input ( ) + <STRING> for h in range ( H ) ] + [ <STRING> * ( W + 2 ) ] <NEWLINE> <NL> for h in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for w in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if S [ h ] [ w ] == <STRING> and S [ h - 1 ] [ w ] == <STRING> and S [ h + 1 ] [ w ] == <STRING> and S [ h ] [ w - 1 ] == <STRING> and S [ h ] [ w + 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import collections <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> table = [ <STRING> . join ( sorted ( list ( input ( ) ) ) ) for _ in range ( N ) ] <NEWLINE> sort_table = set ( table ) <NEWLINE> cnt_table = collections . Counter ( table ) <NEWLINE> ans = 0 <NEWLINE> for i in sort_table : <NEWLINE> <INDENT> num_of_i = cnt_table [ i ] <NEWLINE> if num_of_i <= 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x = ( num_of_i * ( num_of_i - 1 ) ) // 2 <NEWLINE> ans += x <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from bisect import bisect_left <NEWLINE> from heapq import heappush <NEWLINE> <NL> def cal_divisors ( N ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= N : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != N // i : <NEWLINE> <INDENT> divisors . append ( N // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = cal_divisors ( M ) <NEWLINE> <COMMENT> <NL> i = bisect_left ( ans , N ) <NEWLINE> print ( M // ans [ i ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def delete_head_zeros ( n ) : <NEWLINE> <INDENT> n = str ( n ) <NEWLINE> l = len ( n ) <NEWLINE> if <STRING> in n : <NEWLINE> <INDENT> l = n . find ( <STRING> ) <NEWLINE> <DEDENT> head_zeros = 0 <NEWLINE> for i in range ( l - 1 ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : <NEWLINE> <INDENT> head_zeros += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return n [ head_zeros : ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def bigint_compare ( a , b ) : <NEWLINE> <INDENT> a = delete_head_zeros ( a ) <NEWLINE> b = delete_head_zeros ( b ) <NEWLINE> if len ( a ) > len ( b ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif len ( a ) < len ( b ) : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def bigint_plus ( a , b ) : <NEWLINE> <INDENT> a = str ( a ) <NEWLINE> b = str ( b ) <NEWLINE> <NL> d = max ( [ len ( a ) , len ( b ) ] ) <NEWLINE> a = <STRING> * ( d - len ( a ) ) + a <NEWLINE> b = <STRING> * ( d - len ( b ) ) + b <NEWLINE> <NL> ans = <STRING> <NEWLINE> carry = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s = int ( a [ - i - 1 ] ) + int ( b [ - i - 1 ] ) + carry <NEWLINE> carry = s // 10 <NEWLINE> ans = str ( s % 10 ) + ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if carry : <NEWLINE> <INDENT> ans = str ( carry ) + ans <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def bigint_minus ( a , b ) : <NEWLINE> <INDENT> a = str ( a ) <NEWLINE> b = str ( b ) <NEWLINE> M = [ ] <NEWLINE> m = [ ] <NEWLINE> sign = <STRING> <NEWLINE> <NL> if len ( a ) > len ( b ) or ( len ( a ) == len ( b ) and a >= b ) : <NEWLINE> <INDENT> [ M , m ] = [ a , b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> [ M , m ] = [ b , a ] <NEWLINE> sign = <STRING> <NEWLINE> <DEDENT> m = <STRING> * ( len ( M ) - len ( m ) ) + m <NEWLINE> <NL> ans = <STRING> <NEWLINE> borrow = 0 <NEWLINE> for i in range ( len ( M ) ) : <NEWLINE> <INDENT> s = int ( M [ - i - 1 ] ) - int ( m [ - i - 1 ] ) - borrow <NEWLINE> if s < 0 : <NEWLINE> <INDENT> borrow = 1 <NEWLINE> s += 10 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> borrow = 0 <NEWLINE> <DEDENT> ans = str ( s ) + ans <NEWLINE> <NL> <DEDENT> return sign + delete_head_zeros ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def bigint_multiply ( a , b ) : <NEWLINE> <INDENT> a = str ( a ) <NEWLINE> b = str ( b ) <NEWLINE> <NL> md = [ ] <NEWLINE> for j in range ( len ( b ) ) : <NEWLINE> <INDENT> carry = 0 <NEWLINE> mj = <STRING> <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> m = int ( a [ - i - 1 ] ) * int ( b [ - j - 1 ] ) + carry <NEWLINE> carry = m // 10 <NEWLINE> mj = str ( m % 10 ) + mj <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if carry : <NEWLINE> <INDENT> mj = str ( carry ) + mj <NEWLINE> <DEDENT> <DEDENT> md . append ( mj ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for k in range ( len ( md ) ) : <NEWLINE> <INDENT> ans = bigint_plus ( md [ k ] + <STRING> * k , ans ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def bigint_divide ( a , b , d = 0 ) : <NEWLINE> <INDENT> a = str ( a ) <NEWLINE> b = str ( b ) <NEWLINE> d = int ( d ) <NEWLINE> if d < 0 : <NEWLINE> <INDENT> d = 0 <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> r = <STRING> <NEWLINE> for i in range ( len ( a ) + d ) : <NEWLINE> <INDENT> q = 0 <NEWLINE> if i < len ( a ) : <NEWLINE> <INDENT> r += a [ i ] <NEWLINE> <DEDENT> elif i == len ( a ) : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> r += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r += <STRING> <NEWLINE> <NL> <DEDENT> if bigint_compare ( r , b ) == - 1 : <NEWLINE> <INDENT> ans += str ( q ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while bigint_compare ( r , b ) >= 0 : <NEWLINE> <INDENT> r = bigint_minus ( r , b ) <NEWLINE> q += 1 <NEWLINE> <DEDENT> ans += str ( q ) <NEWLINE> <NL> <DEDENT> <DEDENT> return delete_head_zeros ( ans ) <NEWLINE> <NL> <DEDENT> def gcd ( a , b ) : <NEWLINE> <INDENT> if bigint_compare ( a , b ) >= 0 : <NEWLINE> <INDENT> M = a <NEWLINE> m = b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> M = b <NEWLINE> m = a <NEWLINE> <DEDENT> if m == <STRING> : <NEWLINE> <INDENT> return M <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q = bigint_divide ( M , m ) <NEWLINE> r = bigint_minus ( M , bigint_multiply ( m , q ) ) <NEWLINE> return gcd ( m , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return bigint_divide ( bigint_multiply ( a , b ) , gcd ( a , b ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> T = [ input ( ) for i in range ( N ) ] <NEWLINE> ans = 1 <NEWLINE> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> ans = lcm ( T [ i ] , ans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> aa = list ( sorted ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> bb = list ( sorted ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> cc = list ( sorted ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for b in bb : <NEWLINE> <INDENT> ax = bisect . bisect_left ( aa , b ) <NEWLINE> ci = bisect . bisect ( cc , b ) <NEWLINE> cx = len ( cc ) - ci <NEWLINE> ans += ax * cx <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import copy <NEWLINE> from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_plus1 = copy . copy ( a ) <NEWLINE> a_minus1 = copy . copy ( a ) <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> a_plus1 [ x ] += 1 <NEWLINE> <DEDENT> for y in range ( n ) : <NEWLINE> <INDENT> a_minus1 [ y ] -= 1 <NEWLINE> <DEDENT> a_total = a + a_plus1 + a_minus1 <NEWLINE> cnt = Counter ( a_total ) <NEWLINE> a_max = list ( cnt . values ( ) ) <NEWLINE> print ( max ( a_max ) ) <NEWLINE>
<NL> <NL> def main ( ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> lst = [ ] <NEWLINE> cnt = 1 <NEWLINE> flg = 0 <NEWLINE> ans = 0 <NEWLINE> prev = s [ 0 ] <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if prev == s [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst . append ( cnt ) <NEWLINE> cnt = 1 <NEWLINE> prev = s [ i ] <NEWLINE> flg = 1 <NEWLINE> <DEDENT> <DEDENT> lst . append ( cnt ) <NEWLINE> if len ( lst ) == 1 : <NEWLINE> <INDENT> ans = len ( s ) * k // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += sum ( list ( map ( lambda x : x // 2 , lst [ 1 : len ( lst ) - 1 ] ) ) ) * k <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if s [ - 1 ] == s [ 0 ] : <NEWLINE> <INDENT> ans += ( lst [ 0 ] + lst [ - 1 ] ) // 2 * ( k - 1 ) <NEWLINE> ans += lst [ 0 ] // 2 + lst [ - 1 ] // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ( lst [ 0 ] // 2 + lst [ - 1 ] // 2 ) * k <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a , b = 1 , 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> n = max ( ( a + x - 1 ) // x , ( b + y - 1 ) // y ) <NEWLINE> a = n * x <NEWLINE> b = n * y <NEWLINE> <DEDENT> print ( a + b ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> stdin = sys . stdin <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> MIN = - 10 ** 9 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> IINF = 10 ** 18 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> s = str ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = n <NEWLINE> dp = [ 0 for j in range ( n + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> dp [ i + 1 ] = dp [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] = dp [ i ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = min ( ans , dp [ i ] + ( ( n - i - 1 ) - ( dp [ n ] - dp [ i + 1 ] ) ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i * i <= N : <NEWLINE> <INDENT> ans = max ( ans , i * i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import * <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> g = gcd ( a , b ) <NEWLINE> for i in range ( g ) : <NEWLINE> <INDENT> if s [ a // g * i ] != t [ b // g * i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( a * b // g ) <NEWLINE>
h , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def bupdp ( l , h , k ) : <NEWLINE> <INDENT> dp = [ 0 ] * ( h + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( 0 , h ) : <NEWLINE> <INDENT> if i > k : <NEWLINE> <INDENT> mini = min ( [ dp [ i - j ] + abs ( l [ i ] - l [ i - j ] ) for j in range ( 1 , k + 1 ) ] ) <NEWLINE> dp [ i ] = mini <NEWLINE> <DEDENT> if i <= k and i != 0 : <NEWLINE> <INDENT> minim = min ( [ dp [ i - j ] + abs ( l [ i ] - l [ i - j ] ) for j in range ( 1 , i + 1 ) ] ) <NEWLINE> dp [ i ] = minim <NEWLINE> <DEDENT> if i < 1 : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> return dp [ - 2 ] <NEWLINE> <NL> <DEDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( bupdp ( l , h , k ) ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> tab = set ( [ 1 ] ) <NEWLINE> for i in range ( 1 , X + 1 ) : <NEWLINE> <INDENT> for j in range ( 2 , X + 1 ) : <NEWLINE> <INDENT> if i ** j <= X : <NEWLINE> <INDENT> tab . add ( i ** j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( [ i for i in tab ] ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import datetime <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> arr . append ( input ( ) ) <NEWLINE> <DEDENT> arr . sort ( ) <NEWLINE> print ( <STRING> . join ( arr ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ <STRING> . join ( sorted ( input ( ) ) ) for _ in range ( N ) ] <NEWLINE> d = { } <NEWLINE> count = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s in d : <NEWLINE> <INDENT> count += d [ s ] <NEWLINE> d [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def enum_divisors ( n ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> res . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> divs = filter ( lambda x : x <= M // N , enum_divisors ( M ) ) <NEWLINE> print ( max ( divs ) ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for X in range ( k + 1 ) : <NEWLINE> <INDENT> for Y in range ( k + 1 ) : <NEWLINE> <INDENT> Z = s - X - Y <NEWLINE> if k >= Z >= 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n % m == 0 : <NEWLINE> <INDENT> print ( int ( n / m ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst = make_divisors ( m ) [ : : - 1 ] <NEWLINE> for i in lst : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if m - i * ( n - 1 ) > 0 : <NEWLINE> <INDENT> if ( m - i * ( n - 1 ) ) % i == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * ( W + 1 ) <NEWLINE> def knapsack ( n , w ) : <NEWLINE> <INDENT> for _ in range ( N ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> for wk in range ( W , w - 1 , - 1 ) : <NEWLINE> <INDENT> tv = dp [ wk - w ] + v <NEWLINE> if tv > dp [ wk ] : <NEWLINE> <INDENT> dp [ wk ] = tv <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp [ - 1 ] <NEWLINE> <DEDENT> print ( knapsack ( N , W ) ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( [ n // ( 2 * pow ( 5 , i ) ) for i in range ( 1 , math . ceil ( math . log ( n + 1 , 5 ) ) ) ] ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> m = [ 0 ] * ( N ) <NEWLINE> m [ 0 ] = p [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> m [ i + 1 ] = min ( m [ i ] , p [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if m [ i - 1 ] > p [ i ] : ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> E = C * D // math . gcd ( C , D ) <NEWLINE> def num_mult ( fro , to , mult ) : <NEWLINE> <INDENT> goal = to // mult <NEWLINE> if fro % mult == 0 : <NEWLINE> <INDENT> start = fro // mult <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start = fro // mult + 1 <NEWLINE> <NL> <DEDENT> return goal - start + 1 <NEWLINE> <NL> <DEDENT> ans = B - A + 1 <NEWLINE> <COMMENT> <NL> ans -= num_mult ( A , B , C ) <NEWLINE> <COMMENT> <NL> ans -= num_mult ( A , B , D ) <NEWLINE> <COMMENT> <NL> ans += num_mult ( A , B , E ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> max_val1 = sorted ( A ) [ - 1 ] <NEWLINE> max_val2 = sorted ( A ) [ - 2 ] <NEWLINE> for x in A : <NEWLINE> <INDENT> print ( max_val2 if x == max_val1 else max_val1 ) <NEWLINE> <DEDENT>
N , ma , mb = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * N <NEWLINE> b = [ 0 ] * N <NEWLINE> c = [ 0 ] * N <NEWLINE> NMAX = 40 <NEWLINE> ABMAX = 10 <NEWLINE> INF = 1000000 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> dp = [ [ [ INF ] * ( NMAX * ABMAX + 1 ) for _ in range ( NMAX * ABMAX + 1 ) ] for _ in range ( N + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] [ 0 ] = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for ca in range ( NMAX * ABMAX + 1 ) : <NEWLINE> <INDENT> for cb in range ( NMAX * ABMAX + 1 ) : <NEWLINE> <INDENT> if dp [ i ] [ ca ] [ cb ] == INF : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i + 1 ] [ ca ] [ cb ] = min ( dp [ i + 1 ] [ ca ] [ cb ] , dp [ i ] [ ca ] [ cb ] ) <NEWLINE> dp [ i + 1 ] [ ca + a [ i ] ] [ cb + b [ i ] <NEWLINE> <INDENT> ] = min ( dp [ i + 1 ] [ ca + a [ i ] ] [ cb + b [ i ] ] , dp [ i ] [ ca ] [ cb ] + c [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = INF <NEWLINE> for ca in range ( 1 , NMAX * ABMAX + 1 ) : <NEWLINE> <INDENT> for cb in range ( 1 , NMAX * ABMAX + 1 ) : <NEWLINE> <INDENT> if ca * mb == cb * ma : <NEWLINE> <INDENT> ans = min ( ans , dp [ N ] [ ca ] [ cb ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans if ans != INF else - 1 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a * b <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 1 <= a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( b - a ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> vec = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> now = a [ i + 1 ] - a [ i ] <NEWLINE> if vec * now < 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> vec = 0 <NEWLINE> <DEDENT> elif vec == 0 : <NEWLINE> <INDENT> vec = now <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> dp = [ float ( <STRING> ) ] * ( n + 1 ) <NEWLINE> for i in range ( min ( 6 , n + 1 ) ) : <NEWLINE> <INDENT> dp [ i ] = i <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 1 , n // 6 + 1 ) : <NEWLINE> <INDENT> if i + 6 ** j > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp [ i + 6 ** j ] = min ( dp [ i + 6 ** j ] , dp [ i ] + 1 ) <NEWLINE> <DEDENT> for j in range ( 1 , n // 9 + 1 ) : <NEWLINE> <INDENT> if i + 9 ** j > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp [ i + 9 ** j ] = min ( dp [ i + 9 ** j ] , dp [ i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xy = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for h in itertools . combinations ( range ( 0 , n ) , i ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> y = 0 <NEWLINE> for j in h : <NEWLINE> <INDENT> x += v [ j ] <NEWLINE> y += c [ j ] <NEWLINE> <DEDENT> if xy < x - y : <NEWLINE> <INDENT> xy = x - y <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( xy ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> div = n <NEWLINE> result = 10 ** 12 <NEWLINE> <NL> for i in range ( 1 , 1000001 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> div = n // i <NEWLINE> result = min ( result , i + div ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( result - 2 ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> <NL> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> max = sorted ( A ) [ - 1 ] <NEWLINE> semi_max = sorted ( A ) [ - 2 ] <NEWLINE> <NL> if max != semi_max : <NEWLINE> <INDENT> ex = A . index ( max ) <NEWLINE> <NL> for i in range ( 0 , ex ) : <NEWLINE> <INDENT> print ( max ) <NEWLINE> <NL> <DEDENT> print ( semi_max ) <NEWLINE> <NL> for i in range ( ex + 1 , N ) : <NEWLINE> <INDENT> print ( max ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( max ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> D = [ - 1 ] <COMMENT> <NEWLINE> for i in range ( 2 * N - 1 ) : <NEWLINE> <INDENT> if S [ i ] != S [ i + 1 ] : <NEWLINE> <INDENT> D . append ( D [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D . append ( D [ - 1 ] * ( - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> left = [ ] <NEWLINE> for i in range ( 2 * N ) : <NEWLINE> <INDENT> if D [ i ] < 0 : <NEWLINE> <INDENT> left . append ( i ) <NEWLINE> <DEDENT> <DEDENT> sums = [ 0 for i in range ( 2 * N ) ] <NEWLINE> for i in range ( 2 * N ) : <NEWLINE> <INDENT> if D [ i ] > 0 : <NEWLINE> <INDENT> sums [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 2 * N - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> sums [ i ] += sums [ i + 1 ] <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans %= mod <NEWLINE> <DEDENT> if len ( left ) != N : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= sums [ left [ i ] ] - ( N - 1 - i ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
D , N = map ( int , input ( ) . split ( ) ) <NEWLINE> a = 100 ** ( D ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> A . append ( i * a ) <NEWLINE> <DEDENT> if D == 0 : <NEWLINE> <INDENT> A . remove ( 100 ) <NEWLINE> A . append ( 101 ) <NEWLINE> <DEDENT> elif D == 1 : <NEWLINE> <INDENT> A . remove ( 10000 ) <NEWLINE> A . append ( 10100 ) <NEWLINE> <DEDENT> elif D == 2 : <NEWLINE> <INDENT> A . remove ( 1000000 ) <NEWLINE> A . append ( 1010000 ) <NEWLINE> <DEDENT> print ( A [ N - 1 ] ) <NEWLINE>
import sys <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> BC = sorted ( BC , reverse = True , key = lambda x : x [ 1 ] ) <NEWLINE> D = [ ] <NEWLINE> <NL> for B , C in BC : <NEWLINE> <INDENT> for b in range ( B ) : <NEWLINE> <INDENT> if len ( D ) != N : <NEWLINE> <INDENT> D . append ( C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( len ( D ) ) : <NEWLINE> <INDENT> if A [ i ] < D [ i ] : <NEWLINE> <INDENT> A [ i ] = D [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> tmp1 = [ set ( ) for i in range ( 26 ) ] <NEWLINE> tmp2 = [ set ( ) for i in range ( 26 ) ] <NEWLINE> alpha2num = lambda c : ord ( c ) - ord ( <STRING> ) <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> tmp1 [ alpha2num ( S [ i ] ) ] . add ( T [ i ] ) <NEWLINE> tmp2 [ alpha2num ( T [ i ] ) ] . add ( S [ i ] ) <NEWLINE> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> if len ( tmp1 [ i ] ) > 1 or len ( tmp2 [ i ] ) > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans_box = [ 0 ] * n <NEWLINE> wa = [ 0 ] * n <NEWLINE> ac = 0 <NEWLINE> wa_cnt = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> k , l = input ( ) . split ( ) <NEWLINE> h = int ( k ) - 1 <NEWLINE> if ans_box [ h ] == 0 : <NEWLINE> <INDENT> if l == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> ans_box [ h ] += 1 <NEWLINE> wa_cnt += wa [ h ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wa [ h ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ac , wa_cnt ) <NEWLINE>
n = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> ln = len ( n ) + 1 <NEWLINE> <NL> dp = [ [ [ 0 ] * ( ln ) for _ in range ( 2 ) ] for i in range ( ln ) ] <NEWLINE> dp [ 0 ] [ 0 ] [ 0 ] = 1 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> for smaller in range ( 2 ) : <NEWLINE> <INDENT> x = int ( n [ i ] ) <NEWLINE> t = 9 if smaller else x <NEWLINE> for j in range ( t + 1 ) : <NEWLINE> <INDENT> for knum in range ( ln - 1 ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> dp [ i + 1 ] [ int ( smaller or j < x ) ] [ knum ] += dp [ i ] [ smaller ] [ knum ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] [ int ( smaller or j < x ) ] [ knum + 1 ] += dp [ i ] [ smaller ] [ knum ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> print ( dp [ - 1 ] [ 0 ] [ k ] + dp [ - 1 ] [ 1 ] [ k ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] *= - 1 <NEWLINE> <DEDENT> heapq . heapify ( A ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> x = heapq . heappop ( A ) <NEWLINE> if x % 2 == 0 : <NEWLINE> <INDENT> x //= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x // 2 + 1 <NEWLINE> <DEDENT> heapq . heappush ( A , x ) <NEWLINE> <NL> <DEDENT> ans = - 1 * sum ( A ) <NEWLINE> print ( ans ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> b = [ k - q ] * n <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> ai = int ( input ( ) ) <NEWLINE> b [ ai - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> if b [ j ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 for i in range ( 10 ** 5 + 1 ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] > 10 ** 5 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ a [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 10 ** 5 + 1 ) : <NEWLINE> <INDENT> if 0 < l [ i ] < i : <NEWLINE> <INDENT> ans += l [ i ] <NEWLINE> <DEDENT> if i < l [ i ] : <NEWLINE> <INDENT> t = l [ i ] - i <NEWLINE> ans += t <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S1 = list ( input ( ) ) <NEWLINE> S2 = list ( input ( ) ) <NEWLINE> <NL> if len ( S1 ) == 1 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif len ( S1 ) == 2 : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if S1 [ 0 ] != S2 [ 0 ] : <NEWLINE> <INDENT> t = 2 <NEWLINE> i = 2 <NEWLINE> a = 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = 1 <NEWLINE> i = 1 <NEWLINE> a = 3 <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> if S1 [ i ] != S2 [ i ] : <NEWLINE> <INDENT> if t == 2 : <NEWLINE> <INDENT> a *= 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a *= 2 <NEWLINE> <DEDENT> i += 2 <NEWLINE> t = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t == 2 : <NEWLINE> <INDENT> a *= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a *= 2 <NEWLINE> <DEDENT> i += 1 <NEWLINE> t = 1 <NEWLINE> <DEDENT> a %= 1000000007 <NEWLINE> if i == len ( S1 ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import itertools <NEWLINE> import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( len ( l ) - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( l ) ) : <NEWLINE> <INDENT> k = bisect . bisect_left ( l , l [ i ] + l [ j ] ) <NEWLINE> if k > j : <NEWLINE> <INDENT> ans += k - j - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> imo = [ ] <NEWLINE> xlmin = 0 <NEWLINE> xlmax = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , l = map ( int , input ( ) . split ( ) ) <NEWLINE> imo . append ( [ x - l , x + l - 1 ] ) <NEWLINE> <DEDENT> imo = sorted ( imo , key = lambda x : x [ 1 ] ) <NEWLINE> cnt = 1 <NEWLINE> ls = imo [ 0 ] [ 1 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if imo [ i ] [ 0 ] <= ls : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> ls = imo [ i ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> H , W , D = map ( int , readline ( ) . split ( ) ) <NEWLINE> X = [ ( 0 , 0 ) for _ in range ( H * W ) ] <NEWLINE> Y = [ 0 for _ in range ( H * W ) ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> A = [ int ( x ) - 1 for x in readline ( ) . split ( ) ] <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> X [ A [ j ] ] = ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , H * W - D ) : <NEWLINE> <INDENT> Y [ i + D ] = Y [ i ] + abs ( X [ i + D ] [ 0 ] - X [ i ] [ 0 ] ) + abs ( X [ i + D ] [ 1 ] - X [ i ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> Q = int ( readline ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> L , R = map ( int , readline ( ) . split ( ) ) <NEWLINE> print ( Y [ R - 1 ] - Y [ L - 1 ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ais = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> ai = int ( input ( ) ) <NEWLINE> ais . append ( ai ) <NEWLINE> <DEDENT> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if len ( ais ) > 0 and ais [ 0 ] == 1 : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> ais . pop ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if len ( ais ) > 0 and ais [ 0 ] == i : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> ais . pop ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> <DEDENT> <DEDENT> print ( dp [ n ] % 1000000007 ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> point = [ k ] * ( n ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> point [ a - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if point [ i ] - q > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> result [ A [ i ] - 1 ] = str ( i + 1 ) <NEWLINE> <DEDENT> s = <STRING> . join ( result ) <NEWLINE> print ( s ) <NEWLINE>
ans = 0 <NEWLINE> R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> rl = ( N + R - 1 ) // R + 1 <NEWLINE> gl = ( N + G - 1 ) // G + 1 <NEWLINE> bl = ( N + B - 1 ) // B <NEWLINE> for r in range ( rl ) : <NEWLINE> <INDENT> for g in range ( gl ) : <NEWLINE> <INDENT> tmp = N - ( r * R ) - ( g * G ) <NEWLINE> if tmp < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if tmp == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif tmp % B == 0 and tmp % B <= bl : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> j = 0 <NEWLINE> L = list ( ) <NEWLINE> R = list ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S = <STRING> . join ( sorted ( list ( input ( ) ) ) ) <NEWLINE> L . append ( S ) <NEWLINE> <DEDENT> c = collections . Counter ( L ) <NEWLINE> counts = c . values ( ) <NEWLINE> counts = list ( counts ) <NEWLINE> A = [ i * ( i - 1 ) // 2 for i in counts ] <NEWLINE> print ( sum ( A ) ) <NEWLINE>
import math <NEWLINE> from itertools import accumulate <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> fromright = list ( accumulate ( a , math . gcd ) ) <NEWLINE> a . reverse ( ) <NEWLINE> fromleft = list ( accumulate ( a , math . gcd ) ) <NEWLINE> fromleft . reverse ( ) <NEWLINE> <NL> gcd = [ ] <NEWLINE> <NL> gcd . append ( fromleft [ 1 ] ) <NEWLINE> <NL> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> gcd . append ( math . gcd ( fromright [ i - 1 ] , fromleft [ i + 1 ] ) ) <NEWLINE> <NL> <DEDENT> gcd . append ( fromright [ n - 2 ] ) <NEWLINE> <NL> if n == 2 : <NEWLINE> <INDENT> print ( max ( a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( gcd ) ) <NEWLINE> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> k = S - i - j <NEWLINE> if i + j + k == S : <NEWLINE> <INDENT> if 0 <= k <= K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> E = int ( input ( ) ) <NEWLINE> <NL> def roundup ( n ) : <NEWLINE> <INDENT> return int ( math . ceil ( n / 10 ) ) * 10 <NEWLINE> <DEDENT> def get_digit ( number ) : <NEWLINE> <INDENT> return number % 10 <NEWLINE> <DEDENT> s = 0 <NEWLINE> m = [ ] <NEWLINE> li = [ A , B , C , D , E ] <NEWLINE> for i in range ( len ( li ) ) : <NEWLINE> <INDENT> if get_digit ( li [ i ] ) >= 1 : <NEWLINE> <INDENT> m . append ( get_digit ( li [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> f = False <NEWLINE> m . sort ( ) <NEWLINE> for l in range ( len ( li ) ) : <NEWLINE> <INDENT> if len ( m ) > 0 : <NEWLINE> <INDENT> if m [ 0 ] == get_digit ( li [ l ] ) and f == False : <NEWLINE> <INDENT> s += li [ l ] <NEWLINE> f = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += roundup ( li [ l ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s = sum ( li ) <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> d = [ [ a [ i ] [ 0 ] - a [ i ] [ 1 ] , a [ i ] [ 0 ] + a [ i ] [ 1 ] ] for i in range ( n ) ] <NEWLINE> <NL> d = sorted ( d , key = lambda x : x [ 1 ] ) <NEWLINE> <COMMENT> <NL> <NL> b = [ - 100000000000000000 ] <NEWLINE> c = [ 0 ] <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( len ( b ) ) : <NEWLINE> <INDENT> if d [ i ] [ 0 ] >= b [ j ] : <NEWLINE> <INDENT> b = [ d [ i ] [ 1 ] ] <NEWLINE> c = [ c [ j ] + 1 ] <NEWLINE> break <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max ( c ) ) <NEWLINE> <NL> <NL>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> AB . sort ( key = lambda x : ( - x [ 1 ] , - x [ 0 ] ) ) <COMMENT> <NEWLINE> memo = [ 0 ] * ( 10 ** 5 + 1 ) <COMMENT> <NEWLINE> work = [ float ( <STRING> ) ] * ( 10 ** 5 + 1 ) <COMMENT> <NEWLINE> noMore = float ( <STRING> ) <COMMENT> <NEWLINE> ans = 0 <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> if a < noMore : <COMMENT> <NEWLINE> <INDENT> flag = 1 <NEWLINE> for idx in range ( min ( M - a , work [ a ] ) , - 1 , - 1 ) : <COMMENT> <NEWLINE> <INDENT> if memo [ idx ] == 0 : <COMMENT> <NEWLINE> <INDENT> ans += b <COMMENT> <NEWLINE> memo [ idx ] = 1 <COMMENT> <NEWLINE> flag = 0 <COMMENT> <NEWLINE> work [ a ] = idx <COMMENT> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <COMMENT> <NEWLINE> <INDENT> noMore = a <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
w , h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> b , c , d , e = 0 , w , 0 , h <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y , a = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> b = max ( b , x ) <NEWLINE> <DEDENT> elif a == 2 : <NEWLINE> <INDENT> c = min ( c , x ) <NEWLINE> <DEDENT> elif a == 3 : <NEWLINE> <INDENT> d = max ( d , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e = min ( e , y ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( c - b , 0 ) * max ( e - d , 0 ) ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> V = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> even = { 0 : 0 } <NEWLINE> odd = { 0 : 0 } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> v = V [ i ] <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> if v in even : <NEWLINE> <INDENT> even [ v ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> even [ v ] = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if v in odd : <NEWLINE> <INDENT> odd [ v ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> odd [ v ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> omax = 0 <NEWLINE> emax = 0 <NEWLINE> onext = 0 <NEWLINE> enext = 0 <NEWLINE> <NL> for e in even : <NEWLINE> <INDENT> if even [ e ] > even [ emax ] : <NEWLINE> <INDENT> if even [ emax ] > even [ enext ] : <NEWLINE> <INDENT> enext = emax <NEWLINE> <DEDENT> emax = e <NEWLINE> <DEDENT> elif even [ e ] > even [ enext ] : <NEWLINE> <INDENT> enext = e <NEWLINE> <NL> <DEDENT> <DEDENT> for o in odd : <NEWLINE> <INDENT> if odd [ o ] > odd [ omax ] : <NEWLINE> <INDENT> if odd [ omax ] > odd [ onext ] : <NEWLINE> <INDENT> onext = omax <NEWLINE> <DEDENT> omax = o <NEWLINE> <DEDENT> elif odd [ o ] > odd [ onext ] : <NEWLINE> <INDENT> onext = o <NEWLINE> <NL> <DEDENT> <DEDENT> if omax != emax : <NEWLINE> <INDENT> print ( n - even [ emax ] - odd [ omax ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - even [ emax ] - odd [ omax ] + min ( even [ emax ] - even [ enext ] , odd [ omax ] - odd [ onext ] ) ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = n // 2 <NEWLINE> y = sorted ( x ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if bisect . bisect_right ( y , x [ i ] ) > m : <NEWLINE> <INDENT> print ( y [ m - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y [ m ] ) <NEWLINE> <DEDENT> <DEDENT>
N , Q = ( int ( X ) for X in input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = [ 0 ] * ( N + 1 ) <NEWLINE> for I in range ( 0 , N ) : <NEWLINE> <INDENT> T [ I + 1 ] = T [ I ] + ( S [ I : I + 2 ] == <STRING> ) <NEWLINE> <DEDENT> for J in range ( 0 , Q ) : <NEWLINE> <INDENT> L , R = ( int ( X ) - 1 for X in input ( ) . split ( ) ) <NEWLINE> print ( T [ R ] - T [ L ] ) <NEWLINE> <DEDENT>
a , b , c , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( a * x + b * y , c * 2 * x + b * max ( 0 , y - x ) , c * 2 * y + a * max ( 0 , x - y ) ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> s = input ( ) <NEWLINE> q = deque ( list ( s ) ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> if len ( q ) >= 5 : <NEWLINE> <INDENT> subs = q . popleft ( ) + q . popleft ( ) + q . popleft ( ) + q . popleft ( ) + q . popleft ( ) <NEWLINE> if subs != <STRING> and subs != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if subs == <STRING> and len ( q ) != 0 and q [ 0 ] == <STRING> : <NEWLINE> <INDENT> q . popleft ( ) <NEWLINE> <DEDENT> if subs == <STRING> and len ( q ) == 2 and q [ 0 ] + q [ 1 ] == <STRING> : <NEWLINE> <INDENT> q . popleft ( ) <NEWLINE> q . popleft ( ) <NEWLINE> <DEDENT> if subs == <STRING> and len ( q ) >= 3 and q [ 0 ] + q [ 1 ] == <STRING> and q [ 2 ] != <STRING> : <NEWLINE> <INDENT> q . popleft ( ) <NEWLINE> q . popleft ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <NL> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> Map = [ [ <STRING> ] * ( w + 2 ) ] <NEWLINE> Map += [ [ <STRING> ] + list ( input ( ) ) + [ <STRING> ] for _ in range ( h ) ] <NEWLINE> Map += [ [ <STRING> ] * ( w + 2 ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( h + 2 ) : <NEWLINE> <INDENT> for j in range ( w + 2 ) : <NEWLINE> <INDENT> if Map [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> stack = deque ( [ ( 1 , 1 ) ] ) <NEWLINE> Map [ 1 ] [ 1 ] = 1 <NEWLINE> moved = [ [ 0 , 1 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ - 1 , 0 ] ] <NEWLINE> <NL> while stack : <NEWLINE> <INDENT> x , y = stack . popleft ( ) <NEWLINE> for s , t in moved : <NEWLINE> <INDENT> if Map [ x + s ] [ y + t ] == <STRING> : <NEWLINE> <INDENT> stack . append ( ( x + s , y + t ) ) <NEWLINE> Map [ x + s ] [ y + t ] = Map [ x ] [ y ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> goal = Map [ - 2 ] [ - 2 ] <NEWLINE> if goal == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cnt - goal ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = { } <NEWLINE> ans = <STRING> <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> d [ a [ i ] ] = i + 1 <NEWLINE> <NL> <DEDENT> d_sorted = sorted ( d . items ( ) , key = lambda x : x [ 0 ] ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if ans != <STRING> : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> ans = ans + str ( d_sorted [ i ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> G [ a ] . append ( [ b , c ] ) <NEWLINE> G [ b ] . append ( [ a , c ] ) <NEWLINE> <DEDENT> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> K -= 1 <NEWLINE> dist = [ - 1 for _ in range ( N ) ] <NEWLINE> dist [ K ] = 0 <NEWLINE> q = [ K ] <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> v = q . pop ( ) <NEWLINE> for p in G [ v ] : <NEWLINE> <INDENT> nv = p [ 0 ] <NEWLINE> if dist [ nv ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ nv ] = dist [ v ] + p [ 1 ] <NEWLINE> q . append ( nv ) <NEWLINE> <DEDENT> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( dist [ x - 1 ] + dist [ y - 1 ] ) <NEWLINE> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , K = LI ( ) <NEWLINE> S = SS ( ) <NEWLINE> <NL> <COMMENT> <NL> l = [ ] <NEWLINE> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> l . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( 0 ) <NEWLINE> l . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> l . append ( i + 1 ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> l . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> if S [ - 1 ] == <STRING> : <NEWLINE> <INDENT> l . append ( N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( N ) <NEWLINE> l . append ( N ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> if len ( l ) // 2 - 1 < K : <NEWLINE> <INDENT> ans = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( l ) // 2 - K ) : <NEWLINE> <INDENT> ans = max ( l [ 2 * i + 2 * K + 1 ] - l [ 2 * i ] , ans ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
def fib ( n ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> result = [ 1 , 0 , 0 , 1 ] <NEWLINE> matrix = [ 1 , 1 , 1 , 0 ] <NEWLINE> while n > 0 : <NEWLINE> <INDENT> if n % 2 : <NEWLINE> <INDENT> result = mul ( matrix , result ) <NEWLINE> <DEDENT> matrix = mul ( matrix , matrix ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> return result [ 2 ] <NEWLINE> <NL> <DEDENT> def mul ( a , b ) : <NEWLINE> <INDENT> return [ a [ 0 ] * b [ 0 ] + a [ 1 ] * b [ 2 ] , <NEWLINE> <INDENT> a [ 0 ] * b [ 1 ] + a [ 1 ] * b [ 3 ] , <NEWLINE> a [ 2 ] * b [ 0 ] + a [ 3 ] * b [ 2 ] , <NEWLINE> a [ 2 ] * b [ 1 ] + a [ 3 ] * b [ 3 ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> S = [ - 1 ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> S . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> S . append ( N + 1 ) <NEWLINE> S = [ S [ i + 1 ] - S [ i ] for i in range ( M + 1 ) ] <NEWLINE> if any ( [ x == 1 for x in S ] ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> num = 1 <NEWLINE> for x in S : <NEWLINE> <INDENT> num *= fib ( x - 1 ) <NEWLINE> num = num % 1000000007 <NEWLINE> <DEDENT> print ( num ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <DEDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> point = [ 0 ] * N <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a = a - 1 <NEWLINE> point [ a ] += b <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def dfs ( now , prev = - 1 ) : <NEWLINE> <INDENT> for next in graph [ now ] : <NEWLINE> <COMMENT> <NL> <INDENT> if next == prev : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> point [ next ] += point [ now ] <NEWLINE> <COMMENT> <NL> dfs ( next , now ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * point ) <NEWLINE>
<COMMENT> <NL> import collections , math <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> ls = collections . Counter ( s ) <NEWLINE> lt = collections . Counter ( t ) <NEWLINE> <NL> time_dict = { } <NEWLINE> tmp = 0 <NEWLINE> max_time = 0 <COMMENT> <NEWLINE> for t_key , t_val in lt . items ( ) : <NEWLINE> <INDENT> if t_key not in ls : <COMMENT> <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> tt = list ( t [ : : - 1 ] ) <COMMENT> <NEWLINE> idx = 0 <NEWLINE> ss = s <COMMENT> <NEWLINE> while tt != [ ] : <COMMENT> <NEWLINE> <INDENT> next_t = tt . pop ( ) <COMMENT> <NEWLINE> idx = ss . find ( next_t ) <COMMENT> <NEWLINE> if idx == - 1 : <COMMENT> <NEWLINE> <INDENT> cnt += len ( ss ) <COMMENT> <NEWLINE> idx = s . find ( next_t ) <COMMENT> <NEWLINE> ss = s [ idx + 1 : ] <COMMENT> <NEWLINE> cnt += idx + 1 <COMMENT> <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> cnt += idx + 1 <COMMENT> <NEWLINE> ss = ss [ idx + 1 : ] <COMMENT> <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> root_kouho = set ( list ( range ( n ) ) ) <NEWLINE> leaf = set ( list ( range ( n ) ) ) <NEWLINE> ki = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 + m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> root_kouho . discard ( b ) <NEWLINE> leaf . discard ( a ) <NEWLINE> ki [ b ] . append ( a ) <NEWLINE> <DEDENT> root = root_kouho . pop ( ) <NEWLINE> ans = [ - 1 ] * n <NEWLINE> dp = [ - 1 ] * n <COMMENT> <NEWLINE> ans [ root ] = 0 <NEWLINE> dp [ root ] = 0 <NEWLINE> def func ( v ) : <NEWLINE> <INDENT> if dp [ v ] >= 0 : <NEWLINE> <INDENT> return dp [ v ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = - 1 <NEWLINE> for nv in ki [ v ] : <NEWLINE> <INDENT> tmp = func ( nv ) <NEWLINE> if ret < tmp : <NEWLINE> <INDENT> ret = tmp <NEWLINE> ans [ v ] = nv + 1 <NEWLINE> <DEDENT> <DEDENT> dp [ v ] = ret + 1 <NEWLINE> return ret + 1 <NEWLINE> <DEDENT> <DEDENT> while leaf : <NEWLINE> <INDENT> l = leaf . pop ( ) <NEWLINE> func ( l ) <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> al = <STRING> <NEWLINE> AL = al . upper ( ) <NEWLINE> <NL> a , b , x = I ( ) <NEWLINE> <NL> if a ** 2 * b <= 2 * x : <NEWLINE> <INDENT> ama = a ** 2 * b - x <NEWLINE> ran = 2 * ama / ( a ** 2 ) <NEWLINE> print ( 90 - 180 / math . pi * math . atan2 ( a , ran ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ran = 2 * x / ( a * b ) <NEWLINE> print ( 90 - 180 / math . pi * math . atan2 ( ran , b ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> aL = sorted ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> bcL = sorted ( [ list ( map ( int , <NEWLINE> <INDENT> input ( ) . split ( <STRING> ) ) ) for _ in range ( m ) ] , <NEWLINE> key = lambda x : x [ 1 ] , <NEWLINE> reverse = True ) <NEWLINE> <NL> <DEDENT> csl = 0 <NEWLINE> for cnt , point in bcL : <NEWLINE> <INDENT> for i in range ( cnt ) : <NEWLINE> <INDENT> if csl == n or aL [ csl ] >= point : <NEWLINE> <INDENT> print ( sum ( aL ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> aL [ csl ] = point <NEWLINE> csl += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( aL ) ) <NEWLINE> exit ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans %= ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> T = str ( input ( ) ) <NEWLINE> <NL> s = len ( S ) <NEWLINE> t = len ( T ) <NEWLINE> if s < t : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( s - t + 1 ) : <NEWLINE> <INDENT> num = s - t - i <NEWLINE> tmp = S [ num : num + t ] <NEWLINE> flag = True <NEWLINE> for j in range ( t ) : <NEWLINE> <INDENT> if ( tmp [ j ] != <STRING> ) and ( T [ j ] != tmp [ j ] ) : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> if 0 < num < s - t : <NEWLINE> <INDENT> ans = S [ : num ] + T + S [ num + t : ] <NEWLINE> <DEDENT> elif num == 0 : <NEWLINE> <INDENT> ans = T + S [ num + t : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = S [ : num ] + T <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> ans = ans . replace ( <STRING> , <STRING> ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> alist = [ ] <NEWLINE> gcd1 = a [ 0 ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> gcd1 = math . gcd ( gcd1 , a [ i ] ) <NEWLINE> alist . append ( gcd1 ) <NEWLINE> <DEDENT> blist = [ ] <NEWLINE> gcd2 = a [ n - 1 ] <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> gcd2 = math . gcd ( gcd2 , a [ i ] ) <NEWLINE> blist . append ( gcd2 ) <NEWLINE> <DEDENT> clist = [ alist [ n - 2 ] , blist [ n - 2 ] ] <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> clist . append ( math . gcd ( alist [ i ] , blist [ n - i - 3 ] ) ) <NEWLINE> <DEDENT> print ( max ( clist ) ) <NEWLINE>
r1 , c1 , r2 , c2 = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def comb ( n , k , mod ) : <NEWLINE> <INDENT> if n < k : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if n - k < k : <NEWLINE> <INDENT> k = n - k <NEWLINE> <DEDENT> c = 1 <NEWLINE> for x in range ( n - k + 1 , n + 1 ) : <NEWLINE> <INDENT> c = ( c * x ) % mod <NEWLINE> <DEDENT> d = 1 <NEWLINE> for x in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> d = ( d * x ) % mod <NEWLINE> <DEDENT> c = c * pow ( d , mod - 2 , mod ) <NEWLINE> return c % mod <NEWLINE> <DEDENT> def f ( i , j ) : <NEWLINE> <INDENT> return comb ( i + j , i , mod ) <NEWLINE> <DEDENT> ans = f ( r2 + 1 , c2 + 1 ) - f ( r2 + 1 , c1 ) - f ( r1 , c2 + 1 ) + f ( r1 , c1 ) <NEWLINE> ans %= mod <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans *= i + 1 <NEWLINE> ans %= 1000000007 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> inp = iter ( map ( int , read ( ) . split ( ) ) ) <NEWLINE> <NL> H , W , D = next ( inp ) , next ( inp ) , next ( inp ) <NEWLINE> addr = [ None ] * ( H * W + 1 ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> v = next ( inp ) <NEWLINE> addr [ v ] = ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> cost = [ ] <NEWLINE> for m in range ( D ) : <NEWLINE> <INDENT> arr = [ 0 ] <NEWLINE> for x in range ( ( H * W - m ) // D ) : <NEWLINE> <INDENT> if m + x * D == 0 : <NEWLINE> <INDENT> arr . append ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> r , c = addr [ m + x * D ] <NEWLINE> nr , nc = addr [ m + ( x + 1 ) * D ] <NEWLINE> arr . append ( arr [ - 1 ] + abs ( nr - r ) + abs ( nc - c ) ) <NEWLINE> <DEDENT> cost . append ( arr ) <NEWLINE> <NL> <DEDENT> Q = next ( inp ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> s , t = next ( inp ) , next ( inp ) <NEWLINE> m = s % D <NEWLINE> ans = cost [ m ] [ t // D ] - cost [ m ] [ s // D ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> x = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> n = [ i for i in range ( 2 , int ( math . sqrt ( x ) ) + 1 ) ] <NEWLINE> <NL> for i in n : <NEWLINE> <INDENT> for j in n : <NEWLINE> <INDENT> if j % i == 0 and j / i != 1 : <NEWLINE> <INDENT> n . remove ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while x > 0 : <NEWLINE> <INDENT> for i in n : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> break <NEWLINE> <DEDENT> x += 1 <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , D , A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> monsters = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> monsters . sort ( ) <NEWLINE> X = [ m [ 0 ] for m in monsters ] <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> damages = [ 0 ] * ( N + 1 ) <NEWLINE> for n , monster in enumerate ( monsters ) : <NEWLINE> <INDENT> x , h = monster <NEWLINE> h = max ( 0 , h - damages [ n ] ) <NEWLINE> to_n = bisect . bisect_right ( X , x + 2 * D ) <NEWLINE> cnt = ( h + A - 1 ) // A <COMMENT> <NEWLINE> ans += cnt <NEWLINE> damages [ n ] += A * cnt <NEWLINE> damages [ to_n ] -= A * cnt <NEWLINE> damages [ n + 1 ] += damages [ n ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H_lis = [ ] <NEWLINE> H = lis [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in lis [ 1 : ] : <NEWLINE> <INDENT> if i <= H : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> H = i <NEWLINE> H_lis . append ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> H_lis . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> H = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( H_lis ) ) <NEWLINE>
k , s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - x - y <= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def is_bad_nums ( j : int , d : [ ] ) -> bool : <NEWLINE> <INDENT> while j : <NEWLINE> <INDENT> if j % 10 in d : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> j //= 10 <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> def answer ( n : int , k : int , d : [ ] ) -> int : <NEWLINE> <INDENT> for i in range ( n , 100000 ) : <NEWLINE> <INDENT> if is_bad_nums ( i , d ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> return i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( answer ( n , k , d ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from bisect import bisect_left <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = sorted ( l ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> cnt += bisect_left ( l , l [ i ] + l [ j ] ) - ( j + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> x = 1 <NEWLINE> <NL> while x <= N : <NEWLINE> <INDENT> x *= 2 <NEWLINE> <NL> <NL> <DEDENT> print ( x // 2 ) <NEWLINE> <NL> <NL>
h , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( h ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> b = [ 0 ] * ( h * w + 1 ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> b [ a [ i ] [ j ] ] = ( i , j ) <NEWLINE> <DEDENT> <DEDENT> c = [ 0 ] * ( h * w + 1 ) <NEWLINE> for i in range ( d + 1 , h * w + 1 ) : <NEWLINE> <INDENT> c [ i ] = c [ i - d ] + abs ( b [ i ] [ 0 ] - b [ i - d ] [ 0 ] ) + abs ( b [ i ] [ 1 ] - b [ i - d ] [ 1 ] ) <NEWLINE> <DEDENT> for l , r in lr : <NEWLINE> <INDENT> print ( c [ r ] - c [ l ] ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> z = y // 1000 <NEWLINE> <NL> list = list ( range ( n + 1 ) ) <NEWLINE> for a , b in itertools . product ( list , list ) : <NEWLINE> <INDENT> c = n - a - b <NEWLINE> if c >= 0 : <NEWLINE> <INDENT> v = 10 * a + 5 * b + c <NEWLINE> w = a + b + c <NEWLINE> if v == z and w == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a = - 1 <NEWLINE> b = - 1 <NEWLINE> c = - 1 <NEWLINE> <NL> <DEDENT> print ( str ( a ) , str ( b ) , str ( c ) ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> if h == 1 or w == 1 : <NEWLINE> <INDENT> if h == 1 and w == 1 : <NEWLINE> <INDENT> if s [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> elif h == 1 : <NEWLINE> <INDENT> for i in range ( w ) : <NEWLINE> <INDENT> if s [ 0 ] [ i ] == <STRING> : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ 0 ] [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ 0 ] [ i ] = str ( t ) <NEWLINE> <DEDENT> elif i == w - 1 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ 0 ] [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ 0 ] [ i ] = str ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ 0 ] [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ 0 ] [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ 0 ] [ i ] = str ( t ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> if s [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i + 1 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ 0 ] = str ( t ) <NEWLINE> <DEDENT> elif i == h - 1 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i - 1 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ 0 ] = str ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i + 1 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i - 1 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ 0 ] = str ( t ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> . join ( s [ i ] ) ) <NEWLINE> <DEDENT> exit ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> if i == 0 and j == 0 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ j ] = str ( t ) <NEWLINE> <DEDENT> elif i == 0 and j == w - 1 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ j ] = str ( t ) <NEWLINE> <DEDENT> elif i == h - 1 and j == 0 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i - 1 ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ j ] = str ( t ) <NEWLINE> <DEDENT> elif i == h - 1 and j == w - 1 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i - 1 ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ j ] = str ( t ) <NEWLINE> <DEDENT> elif i == 0 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ j ] = str ( t ) <NEWLINE> <DEDENT> elif j == 0 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i - 1 ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ j ] = str ( t ) <NEWLINE> <DEDENT> elif i == h - 1 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i - 1 ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i - 1 ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ j ] = str ( t ) <NEWLINE> <DEDENT> elif j == w - 1 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i - 1 ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ j ] = str ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i - 1 ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i - 1 ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ j ] = str ( t ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> . join ( s [ i ] ) ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> ai = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> aix2 = list ( map ( lambda x : x * 2 , ai ) ) <NEWLINE> <NL> sum_a = sum ( ai ) <NEWLINE> <NL> def ring_get ( xs , s , e , mod ) : <NEWLINE> <INDENT> ys = [ ] <NEWLINE> i = s % mod <NEWLINE> <NL> while i != ( e % mod ) : <NEWLINE> <INDENT> ys . append ( xs [ i ] ) <NEWLINE> i = ( i + 2 ) % mod <NEWLINE> <NL> <DEDENT> return ys <NEWLINE> <NL> <DEDENT> beforeM = sum_a - sum ( ring_get ( aix2 , 1 , 1 + ( n - 1 ) , n ) ) <NEWLINE> <NL> print ( beforeM ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( aix2 [ i - 1 ] - beforeM ) <NEWLINE> beforeM = aix2 [ i - 1 ] - beforeM <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> s [ k - 1 ] = chr ( ord ( s [ k - 1 ] ) + 32 ) <NEWLINE> t = <STRING> <NEWLINE> for i in s : <NEWLINE> <INDENT> t = t + i <NEWLINE> <DEDENT> print ( t ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
S = input ( ) <NEWLINE> i = 0 <NEWLINE> n = len ( S ) <NEWLINE> while i <= n - 5 : <NEWLINE> <INDENT> if S [ i : i + 5 ] == <STRING> : <NEWLINE> <INDENT> i += 5 <NEWLINE> if S [ i : i + 2 ] == <STRING> and S [ i : i + 5 ] != <STRING> : <NEWLINE> <INDENT> i += 2 <NEWLINE> <DEDENT> <DEDENT> elif S [ i : i + 5 ] == <STRING> : <NEWLINE> <INDENT> i += 5 <NEWLINE> if S [ i : i + 1 ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if i != len ( S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> a = sorted ( a , key = lambda x : x [ 0 ] ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if cnt + a [ i ] [ 1 ] < m : <NEWLINE> <INDENT> ans += a [ i ] [ 0 ] * a [ i ] [ 1 ] <NEWLINE> cnt += a [ i ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a [ i ] [ 0 ] * ( m - cnt ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_list = sorted ( A_list ) <NEWLINE> B_list = sorted ( B_list ) <NEWLINE> C_list = sorted ( C_list ) <NEWLINE> cnt = 0 <NEWLINE> <NL> def is_ok ( arg ) : <COMMENT> <NEWLINE> <INDENT> return A_list [ arg ] < B_list [ i ] <NEWLINE> <NL> <DEDENT> def bisect ( ng , ok ) : <NEWLINE> <INDENT> while ( abs ( ok - ng ) > 1 ) : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if is_ok ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <DEDENT> def is_ok2 ( arg ) : <COMMENT> <NEWLINE> <INDENT> return C_list [ arg ] > B_list [ i ] <NEWLINE> <NL> <DEDENT> def bisect2 ( ng , ok ) : <NEWLINE> <INDENT> while ( abs ( ok - ng ) > 1 ) : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if is_ok2 ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> A_key = bisect ( len ( A_list ) , 0 ) <NEWLINE> if A_list [ A_key ] < B_list [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> C_key = bisect2 ( - 1 , len ( C_list ) - 1 ) <NEWLINE> if B_list [ i ] < C_list [ C_key ] : <NEWLINE> <COMMENT> <NL> <INDENT> cnt += ( n - C_key ) * ( A_key + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<NL> from bisect import bisect_left <NEWLINE> from itertools import accumulate <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> def getCount ( x ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for a in A : <NEWLINE> <COMMENT> <NL> <INDENT> idx = bisect_left ( A , x - a ) <NEWLINE> <COMMENT> <NL> cnt += N - idx <NEWLINE> <COMMENT> <NL> <DEDENT> return cnt >= M <NEWLINE> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ng = 10 ** 9 <NEWLINE> ok = 0 <NEWLINE> <COMMENT> <NL> while ng - ok > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if getCount ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> B = [ 0 ] + list ( accumulate ( A ) ) <NEWLINE> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> idx = bisect_left ( A , ok - A [ i ] ) <NEWLINE> ans += B [ N ] - B [ idx ] + A [ i ] * ( N - idx ) <NEWLINE> cnt += N - idx <NEWLINE> <NL> <DEDENT> rest = ( cnt - M ) * ok <NEWLINE> print ( ans - rest ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> A . sort ( ) <NEWLINE> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <DEDENT> N = 10 ** 5 <NEWLINE> g1 = [ 1 , 1 ] <COMMENT> <NEWLINE> g2 = [ 1 , 1 ] <COMMENT> <NEWLINE> inverse = [ 0 , 1 ] <COMMENT> <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <DEDENT> ans , bns = 0 , 0 <NEWLINE> for j in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = ( ans + ( A [ n - j - 1 ] - A [ j ] ) * cmb ( n - j - 1 , k - 1 , mod ) ) % mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> readline = sys . stdin . readline <NEWLINE> A = [ int ( i ) for i in readline ( ) . split ( ) ] <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> CB = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> b , c = [ int ( i ) for i in readline ( ) . split ( ) ] <NEWLINE> CB . append ( [ c , b ] ) <NEWLINE> <NL> <DEDENT> CB . sort ( reverse = True ) <NEWLINE> <NL> idx = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] < CB [ idx ] [ 0 ] : <NEWLINE> <INDENT> A [ i ] = CB [ idx ] [ 0 ] <NEWLINE> c += 1 <NEWLINE> <DEDENT> if CB [ idx ] [ 1 ] <= c : <NEWLINE> <INDENT> idx += 1 <NEWLINE> c = 0 <NEWLINE> <DEDENT> if idx >= m : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A , B = 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> t , a = 1 , 1 <NEWLINE> if A > x : <NEWLINE> <INDENT> t = A // x <NEWLINE> if A % x != 0 : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> if B > y : <NEWLINE> <INDENT> a = B // y <NEWLINE> if B % y != 0 : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> m = max ( t , a ) <NEWLINE> A = x * m <NEWLINE> B = y * m <NEWLINE> <DEDENT> print ( A + B ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def cmb ( n , r , p ) : <NEWLINE> <INDENT> numerator = 1 <NEWLINE> for i in range ( n - r + 1 , n + 1 ) : <NEWLINE> <INDENT> numerator = numerator * i % p <NEWLINE> <DEDENT> denominator = 1 <NEWLINE> for j in range ( 1 , r + 1 ) : <NEWLINE> <INDENT> denominator = denominator * j % p <NEWLINE> <DEDENT> denominator = pow ( denominator , p - 2 , p ) <NEWLINE> return ( numerator * denominator ) % p <NEWLINE> <NL> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> l = [ ] <NEWLINE> t = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if t % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while t % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> t //= i <NEWLINE> <DEDENT> l . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if t != 1 : <NEWLINE> <INDENT> l . append ( [ t , 1 ] ) <NEWLINE> <DEDENT> if l == [ ] : <NEWLINE> <INDENT> l . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> return l <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> F = factorization ( M ) <NEWLINE> for i in range ( len ( F ) ) : <NEWLINE> <INDENT> f = F [ i ] [ 1 ] <NEWLINE> ans *= cmb ( f + N - 1 , f , MOD ) <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> if M == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N , M = ( int ( X ) for X in input ( ) . split ( ) ) <NEWLINE> Shop = np . zeros ( ( N , 2 ) , dtype = int ) <NEWLINE> for T in range ( 0 , N ) : <NEWLINE> <INDENT> Shop [ T , : ] = ( np . array ( [ int ( X ) for X in input ( ) . split ( ) ] ) ) <NEWLINE> <DEDENT> Shop = Shop [ np . argsort ( Shop [ : , 0 ] ) ] <NEWLINE> Rest = M <NEWLINE> Pric = 0 <NEWLINE> for T in range ( 0 , N ) : <NEWLINE> <INDENT> Pric += Shop [ T , 0 ] * Shop [ T , 1 ] <NEWLINE> Rest -= Shop [ T , 1 ] <NEWLINE> if Rest < 0 : <NEWLINE> <INDENT> Pric += Rest * Shop [ T , 0 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( Pric ) <NEWLINE>
from heapq import heappop , heappush <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> pair = [ i for i in range ( n ) ] <NEWLINE> que = [ ] <NEWLINE> e = [ None ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> e [ i ] = ( i , x , y ) <NEWLINE> <DEDENT> ex = sorted ( e , key = lambda x : x [ 1 ] ) <NEWLINE> ey = sorted ( e , key = lambda x : x [ 2 ] ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> w = ex [ i + 1 ] [ 1 ] - ex [ i ] [ 1 ] <NEWLINE> heappush ( que , ( w , ex [ i ] [ 0 ] , ex [ i + 1 ] [ 0 ] ) ) <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> w = ey [ i + 1 ] [ 2 ] - ey [ i ] [ 2 ] <NEWLINE> heappush ( que , ( w , ey [ i ] [ 0 ] , ey [ i + 1 ] [ 0 ] ) ) <NEWLINE> <DEDENT> def find ( x ) : <NEWLINE> <INDENT> if x == pair [ x ] : return x <NEWLINE> else : <NEWLINE> <INDENT> tmp = find ( pair [ x ] ) <NEWLINE> pair [ x ] = tmp <NEWLINE> return tmp <NEWLINE> <DEDENT> <DEDENT> q = [ ] <NEWLINE> ans = 0 <NEWLINE> while que : <NEWLINE> <INDENT> w , s , t = heappop ( que ) <NEWLINE> root_s = find ( s ) <NEWLINE> root_t = find ( t ) <NEWLINE> if root_s != root_t : <NEWLINE> <INDENT> pair [ root_s ] = root_t <NEWLINE> ans += w <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from scipy . sparse . csgraph import csgraph_from_dense , dijkstra <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> import heapq <NEWLINE> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> N , M , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> G = [ [ - 1 ] * N for i in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> G [ A ] [ B ] = C <NEWLINE> G [ B ] [ A ] = C <NEWLINE> <DEDENT> g = csgraph_from_dense ( G , null_value = - 1 ) <NEWLINE> D = dijkstra ( g ) <NEWLINE> G2 = [ [ - 1 ] * N for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if D [ i ] [ j ] >= 0 and D [ i ] [ j ] <= L : <NEWLINE> <INDENT> G2 [ i ] [ j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> g2 = csgraph_from_dense ( G2 , null_value = - 1 ) <NEWLINE> D = dijkstra ( g2 ) <NEWLINE> <NL> <NL> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> s -= 1 <NEWLINE> t -= 1 <NEWLINE> if D [ s ] [ t ] <= N ** 2 : <NEWLINE> <INDENT> print ( int ( D [ s ] [ t ] ) - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <STRING> <NEWLINE> <NL> count = 0 <NEWLINE> for r in range ( N // R + 1 ) : <NEWLINE> <INDENT> rest = N - r * R <NEWLINE> for g in range ( rest // G + 1 ) : <NEWLINE> <INDENT> n_b = ( rest - g * G ) <NEWLINE> if n_b % B == 0 and n_b >= 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = ( n * ( n - 1 ) ) // 2 <NEWLINE> print ( s ) <NEWLINE>
N , A = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maxX = max ( max ( x ) , A ) <NEWLINE> dp = [ [ [ 0 for _ in range ( N * maxX + 1 ) ] for _ in range ( N + 1 ) ] for _ in range ( N + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] [ 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N + 1 ) : <NEWLINE> <INDENT> for k in range ( N * A + 1 ) : <NEWLINE> <INDENT> if dp [ i ] [ j ] [ k ] == 0 : continue <NEWLINE> dp [ i + 1 ] [ j ] [ k ] += dp [ i ] [ j ] [ k ] <NEWLINE> dp [ i + 1 ] [ j + 1 ] [ k + x [ i ] ] += dp [ i ] [ j ] [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += dp [ N ] [ i ] [ A * i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( reverse = True ) <NEWLINE> num_of_matches = [ 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] <NEWLINE> dp = [ - 1 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> val = - 1 <NEWLINE> for aa in a : <NEWLINE> <INDENT> if i - num_of_matches [ aa ] < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i - num_of_matches [ aa ] == 0 : <NEWLINE> <INDENT> val = 1 <NEWLINE> <DEDENT> elif dp [ i - num_of_matches [ aa ] ] > 0 : <NEWLINE> <INDENT> val = max ( val , dp [ i - num_of_matches [ aa ] ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> dp [ i ] = val <NEWLINE> <NL> <DEDENT> res = <STRING> <NEWLINE> remain = dp [ n ] <NEWLINE> match = n <NEWLINE> while match > 0 : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> if match - num_of_matches [ a [ i ] ] >= 0 and remain - 1 == dp [ match - num_of_matches [ a [ i ] ] ] : <NEWLINE> <INDENT> match -= num_of_matches [ a [ i ] ] <NEWLINE> remain -= 1 <NEWLINE> res += str ( a [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import itertools <NEWLINE> import numpy as np <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> from scipy . sparse . csgraph import floyd_warshall <NEWLINE> <NL> N , * Z = [ int ( _ ) for _ in open ( 0 ) . read ( ) . split ( ) ] <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for z in range ( N * N ) : <NEWLINE> <INDENT> x , y = divmod ( z , N ) <NEWLINE> A += [ x ] <NEWLINE> B += [ y ] <NEWLINE> C += [ Z [ z ] ] <NEWLINE> <DEDENT> G = csr_matrix ( ( C , ( A , B ) ) , ( N , N ) ) <NEWLINE> F = np . array ( floyd_warshall ( G , directed = 1 ) , dtype = np . int64 ) <NEWLINE> Z = np . array ( Z ) . reshape ( N , N ) <NEWLINE> if np . all ( F == Z ) : <NEWLINE> <INDENT> ans = np . sum ( Z ) <NEWLINE> for i , j in itertools . product ( range ( N ) , repeat = 2 ) : <NEWLINE> <INDENT> ans -= Z [ i , j ] * ( np . sum ( Z [ i ] + Z [ j ] == Z [ i , j ] ) > 2 ) <NEWLINE> <DEDENT> ans //= 2 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( 10 ) : <NEWLINE> <INDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> i_index = S . find ( str ( i ) ) <NEWLINE> j_index = S . find ( str ( j ) , i_index + 1 ) <NEWLINE> k_index = S . find ( str ( k ) , j_index + 1 ) <NEWLINE> if i_index != - 1 and j_index != - 1 and k_index != - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> rl = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> rl [ a ] . append ( b ) <NEWLINE> rl [ b ] . append ( a ) <NEWLINE> <DEDENT> cnt = [ 0 ] * N <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> p -= 1 <NEWLINE> cnt [ p ] += x <NEWLINE> <NL> <DEDENT> def dfs ( v , pv ) : <NEWLINE> <INDENT> for next_v in rl [ v ] : <NEWLINE> <INDENT> if next_v == pv : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt [ next_v ] += cnt [ v ] <NEWLINE> dfs ( next_v , v ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> print ( * cnt ) <NEWLINE>
def solve ( N , P ) : <NEWLINE> <INDENT> prime_list = [ ] <NEWLINE> for i in range ( 2 , int ( P ** ( 1 / 2 ) ) + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while P % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> P //= i <NEWLINE> <DEDENT> if cnt : <NEWLINE> <INDENT> prime_list . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if P != 1 : <NEWLINE> <INDENT> prime_list . append ( [ P , 1 ] ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for prime , cnt in prime_list : <NEWLINE> <INDENT> if cnt >= N : <NEWLINE> <INDENT> ans *= prime ** ( cnt // N ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( solve ( n , p ) ) <NEWLINE> <DEDENT>
A = input ( ) <NEWLINE> B = input ( ) <NEWLINE> C = input ( ) <NEWLINE> <NL> l = <STRING> <NEWLINE> <NL> for i in range ( 300 ) : <NEWLINE> <INDENT> if l == <STRING> : <NEWLINE> <INDENT> if len ( A ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif len ( A ) == 1 : <NEWLINE> <INDENT> l = A [ 0 ] <NEWLINE> A = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = A [ 0 ] <NEWLINE> A = A [ 1 : ] <NEWLINE> <DEDENT> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> if len ( B ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif len ( B ) == 1 : <NEWLINE> <INDENT> l = B [ 0 ] <NEWLINE> B = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = B [ 0 ] <NEWLINE> B = B [ 1 : ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if len ( C ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif len ( C ) == 1 : <NEWLINE> <INDENT> l = C [ 0 ] <NEWLINE> C = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = C [ 0 ] <NEWLINE> C = C [ 1 : ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ls = [ ] <NEWLINE> i = 0 <NEWLINE> c = 0 <NEWLINE> while i < N and s [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> if i == N : <NEWLINE> <INDENT> print ( N ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> while i < N : <NEWLINE> <INDENT> l = c <NEWLINE> c = 0 <NEWLINE> while i < N and s [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> m = c <NEWLINE> c = 0 <NEWLINE> while i < N and s [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> r = c <NEWLINE> ls . append ( ( l , m , r ) ) <NEWLINE> <DEDENT> K = min ( K , len ( ls ) ) <NEWLINE> from itertools import accumulate <NEWLINE> acc = list ( accumulate ( [ 0 ] + ls , lambda x , y : x + y [ 1 ] + y [ 2 ] ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( ls ) - K + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , acc [ i + K ] - acc [ i ] + ls [ i ] [ 0 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l_list = [ 2 , 1 ] <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> a = l_list [ i - 1 ] + l_list [ i - 2 ] <NEWLINE> l_list . append ( a ) <NEWLINE> <DEDENT> print ( l_list [ N ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> cd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> ab . sort ( ) <NEWLINE> cd . sort ( ) <NEWLINE> <NL> g = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for i , pab in enumerate ( ab ) : <NEWLINE> <INDENT> for j , pcd in enumerate ( cd ) : <NEWLINE> <INDENT> if pab [ 0 ] < pcd [ 0 ] and pab [ 1 ] < pcd [ 1 ] : <NEWLINE> <INDENT> g [ j ] . append ( [ pab [ 1 ] , i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> s = set ( ) <NEWLINE> <NL> for gg in g : <NEWLINE> <INDENT> gg . sort ( reverse = True ) <NEWLINE> for ggg in gg : <NEWLINE> <INDENT> if ggg [ 1 ] in s : continue <NEWLINE> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> s . add ( ggg [ 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> <NL> c = [ 0 ] * n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> c [ i ] = c [ i - 1 ] + ( s [ i - 1 ] + s [ i ] == <STRING> ) <NEWLINE> <NL> <DEDENT> for x in a : <NEWLINE> <INDENT> print ( c [ x [ 1 ] - 1 ] - c [ x [ 0 ] - 1 ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> D = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> numset = set ( range ( 0 , 10 ) ) <NEWLINE> d = numset . difference ( D ) <NEWLINE> <NL> for n in range ( N , pow ( 10 , 6 ) + 10 ) : <NEWLINE> <INDENT> check = set ( list ( str ( n ) ) ) <NEWLINE> ngflag = False <NEWLINE> for i in check : <NEWLINE> <INDENT> if int ( i ) in D : <NEWLINE> <INDENT> ngflag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not ngflag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( n ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ 0 ] * N <NEWLINE> for _ in range ( Q ) : <NEWLINE> <COMMENT> <NL> <INDENT> A = int ( input ( ) ) <NEWLINE> p [ A - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for ans in p : <NEWLINE> <INDENT> if ans <= Q - K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> from functools import lru_cache <NEWLINE> def Frog1 ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> @ lru_cache ( None ) <NEWLINE> def Solve ( i ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if i == n - 2 : <NEWLINE> <INDENT> return abs ( h [ i ] - h [ i + 1 ] ) <NEWLINE> <DEDENT> return min ( Solve ( i + 1 ) + abs ( h [ i ] - h [ i + 1 ] ) , Solve ( i + 2 ) + abs ( h [ i ] - h [ i + 2 ] ) ) <NEWLINE> <DEDENT> dp = [ 0 ] * n <NEWLINE> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> elif i == n - 2 : <NEWLINE> <INDENT> dp [ i ] = abs ( h [ i ] - h [ i + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i + 1 ] + abs ( h [ i ] - h [ i + 1 ] ) , dp [ i + 2 ] + abs ( h [ i ] - h [ i + 2 ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ 0 ] ) <NEWLINE> <DEDENT> Frog1 ( ) <NEWLINE> <NL> <NL>
s = list ( input ( ) ) <NEWLINE> ls = len ( s ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> lt = len ( t ) <NEWLINE> can = [ ] <NEWLINE> for i in range ( ls - lt , - 1 , - 1 ) : <NEWLINE> <INDENT> ok = 0 <NEWLINE> for j in range ( lt ) : <NEWLINE> <INDENT> if s [ i + j ] == t [ j ] or s [ i + j ] == <STRING> : <NEWLINE> <INDENT> ok += 1 <NEWLINE> <DEDENT> <DEDENT> if ok == lt : <NEWLINE> <INDENT> c = [ 0 ] * ls <NEWLINE> for k in range ( ls ) : <NEWLINE> <INDENT> if s [ k ] == <STRING> : <NEWLINE> <INDENT> if k < i or k >= i + lt : <NEWLINE> <INDENT> c [ k ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ k ] = t [ k - i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> c [ k ] = s [ k ] <NEWLINE> <DEDENT> <DEDENT> can . append ( <STRING> . join ( c ) ) <NEWLINE> <DEDENT> <DEDENT> if len ( can ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sorted ( list ( can ) ) [ 0 ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> s = [ <STRING> . join ( sorted ( input ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> cnt = collections . Counter ( s ) <NEWLINE> for i in cnt . values ( ) : <NEWLINE> <INDENT> if i > 1 : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ 0 ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> a . append ( A ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> b [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in b : <NEWLINE> <INDENT> if i > Q - K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
import math <NEWLINE> x = int ( input ( ) ) <NEWLINE> <NL> def is_prime ( x ) : <NEWLINE> <INDENT> if x < 2 : return False <COMMENT> <NEWLINE> if x == 2 or x == 3 or x == 5 : return True <COMMENT> <NEWLINE> if x % 2 == 0 or x % 3 == 0 or x % 5 == 0 : return False <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> prime = 7 <NEWLINE> step = 4 <NEWLINE> while prime <= math . sqrt ( x ) : <NEWLINE> <INDENT> if x % prime == 0 : return False <NEWLINE> <NL> prime += step <NEWLINE> step = 6 - step <NEWLINE> <NL> <DEDENT> return True <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> if is_prime ( x ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> break <NEWLINE> <DEDENT> x += 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> def f ( N , c ) : <NEWLINE> <INDENT> if N % 2 == 0 : <NEWLINE> <INDENT> n = N // 2 <NEWLINE> c += 1 <NEWLINE> return f ( n , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return c <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> count += f ( a , 0 ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> import copy <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> b . append ( A [ i ] ) <NEWLINE> <DEDENT> b . append ( 0 ) <NEWLINE> <NL> sumb = 0 <NEWLINE> for i in range ( 1 , len ( b ) ) : <NEWLINE> <INDENT> sumb += abs ( b [ i ] - b [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> sumc = sumb <NEWLINE> sumc = sumc - abs ( b [ j + 1 ] - b [ j ] ) - abs ( b [ j ] - b [ j - 1 ] ) + abs ( b [ j + 1 ] - b [ j - 1 ] ) <NEWLINE> print ( sumc ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , read ( ) . split ( ) ) <NEWLINE> s = np . array ( [ [ i == <STRING> for i in read ( ) ] for _ in range ( h ) ] , dtype = int ) <NEWLINE> left = np . zeros ( ( h , w ) , dtype = int ) <NEWLINE> right = np . zeros ( ( h , w ) , dtype = int ) <NEWLINE> up = np . zeros ( ( h , w ) , dtype = int ) <NEWLINE> down = np . zeros ( ( h , w ) , dtype = int ) <NEWLINE> left [ : , 0 ] = s [ : , 0 ] <NEWLINE> right [ : , - 1 ] = s [ : , - 1 ] <NEWLINE> for i in range ( w - 1 ) : <NEWLINE> <INDENT> left [ : , i + 1 ] = ( left [ : , i ] + 1 ) * s [ : , i + 1 ] <NEWLINE> right [ : , - i - 2 ] = ( right [ : , - i - 1 ] + 1 ) * s [ : , - i - 2 ] <NEWLINE> <DEDENT> up [ 0 ] = s [ 0 ] <NEWLINE> down [ - 1 ] = s [ - 1 ] <NEWLINE> for i in range ( h - 1 ) : <NEWLINE> <INDENT> up [ i + 1 ] = ( up [ i ] + 1 ) * s [ i + 1 ] <NEWLINE> down [ - i - 2 ] = ( down [ - i - 1 ] + 1 ) * s [ - i - 2 ] <NEWLINE> <DEDENT> print ( ( left + right + up + down ) . max ( ) - 3 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for r in range ( 0 , N + 1 , R ) : <NEWLINE> <INDENT> for g in range ( 0 , N + 1 , G ) : <NEWLINE> <INDENT> if r + g > N : break <NEWLINE> if ( N - r - g ) % B == 0 : cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> al = <STRING> <NEWLINE> AL = al . upper ( ) <NEWLINE> <NL> S = v ( ) <NEWLINE> T = v ( ) <NEWLINE> len_s = len ( S ) <NEWLINE> len_t = len ( T ) <NEWLINE> check = False <NEWLINE> ans = [ ] <NEWLINE> <NL> if len_s < len_t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( len_s ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt >= len_t : <NEWLINE> <INDENT> aaa = S . replace ( <STRING> , <STRING> ) <NEWLINE> ans . append ( aaa [ : i - len_t + 1 ] + T + aaa [ i + 1 : ] ) <NEWLINE> <DEDENT> <DEDENT> elif S [ i ] in T : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> place = T . index ( S [ i ] ) <NEWLINE> if len_s < len_t + i - place : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( i - place , len_t + i - place ) : <NEWLINE> <INDENT> if T [ j - ( i - place ) ] == S [ j ] or S [ j ] == <STRING> : <NEWLINE> <INDENT> check = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> check = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if check : <NEWLINE> <INDENT> aaa = S . replace ( <STRING> , <STRING> ) <NEWLINE> ans . append ( aaa [ : i - place ] + T + aaa [ len_t + i - place : ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( ans ) > 0 : <NEWLINE> <INDENT> ans . sort ( ) <NEWLINE> print ( ans [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> b . appendleft ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> print ( * reversed ( b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( * b ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> seen = set ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if S [ i ] in seen : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> seen . add ( S [ i ] ) <NEWLINE> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> if S [ i ] + S [ j ] in seen : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> seen . add ( S [ i ] + S [ j ] ) <NEWLINE> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> if S [ i ] + S [ j ] + S [ k ] in seen : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> seen . add ( S [ i ] + S [ j ] + S [ k ] ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for _ in range ( m - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> l = max ( l , a ) <NEWLINE> r = min ( r , b ) <NEWLINE> <NL> <DEDENT> print ( max ( 0 , r - l + 1 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> <NL> lst = [ 0 ] * 3 <NEWLINE> <NL> for aa in a : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> j = - 1 <NEWLINE> for i , l in enumerate ( lst ) : <NEWLINE> <INDENT> if l == aa : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> j = i <NEWLINE> <DEDENT> <DEDENT> if j == - 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> ans *= cnt <NEWLINE> ans %= MOD <NEWLINE> lst [ j ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ <STRING> . join ( sorted ( input ( ) ) ) for _ in range ( N ) ] <NEWLINE> ans = 0 <NEWLINE> import collections <NEWLINE> from math import factorial <NEWLINE> c = collections . Counter ( S ) <NEWLINE> for i in c . values ( ) : <NEWLINE> <INDENT> if 2 <= i : <NEWLINE> <INDENT> ans += factorial ( i ) // ( factorial ( i - 2 ) * factorial ( 2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a , b = [ ] , [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> tmp = input ( ) . split ( ) <NEWLINE> a . append ( int ( tmp [ 0 ] ) ) <NEWLINE> b . append ( int ( tmp [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> cnt = [ 0 ] * ( 100000 + 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> cnt [ a [ i ] ] += b [ i ] <NEWLINE> <NL> <DEDENT> for j in range ( 100000 + 1 ) : <NEWLINE> <INDENT> if K <= cnt [ j ] : <NEWLINE> <INDENT> print ( j ) <NEWLINE> break <NEWLINE> <DEDENT> K -= cnt [ j ] <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> min_ind = a . index ( min ( a ) ) <NEWLINE> <NL> start = [ min_ind - x for x in range ( k ) if min_ind - x >= 0 ] <NEWLINE> end = [ s + k - 1 for s in start ] <NEWLINE> <NL> ans = 10 ** 6 <NEWLINE> for s , e in zip ( start , end ) : <NEWLINE> <INDENT> ans = min ( ans , math . ceil ( s / ( k - 1 ) ) + math . ceil ( ( n - ( e + 1 ) ) / ( k - 1 ) ) ) <NEWLINE> <NL> <DEDENT> print ( ans + 1 ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> exp = [ ( x + 1 ) / 2 for x in p ] <NEWLINE> <NL> sums = 0 <NEWLINE> ls = [ 0 ] <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> sums += exp [ n ] <NEWLINE> ls . append ( sums ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for n in range ( N - K + 1 ) : <NEWLINE> <NL> <INDENT> ans_candidate = ls [ n + K ] - ls [ n ] <NEWLINE> <NL> if ans < ans_candidate : <NEWLINE> <INDENT> ans = ans_candidate <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ - int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> heapq . heapify ( A ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> pop = heapq . heappop ( A ) <NEWLINE> if pop % 2 == 0 : <NEWLINE> <INDENT> num = pop // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = ( pop + 1 ) // 2 <NEWLINE> <DEDENT> heapq . heappush ( A , num ) <NEWLINE> <NL> <DEDENT> print ( - sum ( A ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit , i8 <NEWLINE> <NL> S = input ( ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> dp = np . zeros ( 13 , dtype = int ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> <NL> @ njit ( cache = True ) <NEWLINE> def q_mark ( dp ) : <NEWLINE> <INDENT> new_dp = np . zeros ( 13 , dtype = i8 ) <NEWLINE> for i in range ( 13 ) : <NEWLINE> <INDENT> new_dp [ np . arange ( i , i + 10 ) % 13 ] += dp [ i ] <NEWLINE> new_dp %= MOD <NEWLINE> <DEDENT> return new_dp <NEWLINE> <NL> <NL> <DEDENT> for s in S : <NEWLINE> <COMMENT> <NL> <INDENT> dp = dp [ np . arange ( 0 , 52 , 4 ) % 13 ] <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> dp = q_mark ( dp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp = np . roll ( dp , int ( s ) ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ 5 ] ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> nums = [ 0 ] * len ( s ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : nums [ i ] = nums [ i - 1 ] + 1 <NEWLINE> else : nums [ i ] = nums [ i - 1 ] <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> print ( nums [ r ] - nums [ l ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> dice_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max , s = 0 , 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> s += ( dice_list [ i ] + 1 ) / 2 <NEWLINE> <NL> <DEDENT> max = s <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> s -= ( dice_list [ i ] + 1 ) / 2 <NEWLINE> s += ( dice_list [ i + K ] + 1 ) / 2 <NEWLINE> if s > max : <NEWLINE> <INDENT> max = s <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nums = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> nums [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> nums . sort ( ) <NEWLINE> <NL> nums = deque ( nums ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if nums [ 0 ] == 0 : <NEWLINE> <INDENT> nums . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> nums = list ( nums ) <NEWLINE> if len ( nums ) <= K : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( nums [ : len ( nums ) - K ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( 1 , int ( n ** ( 0.5 ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> a . append ( i ) <NEWLINE> <DEDENT> <DEDENT> m = max ( a ) <NEWLINE> c = int ( n / m ) <NEWLINE> keta = len ( str ( c ) ) <NEWLINE> print ( keta ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <NL> <NL> husoku = [ a - b for a , b in zip ( A , B ) if a - b < 0 ] <NEWLINE> amari = [ a - b for a , b in zip ( A , B ) if a - b > 0 ] <NEWLINE> amari . sort ( reverse = True ) <NEWLINE> <NL> H = abs ( sum ( husoku ) ) <NEWLINE> if len ( husoku ) == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif H > sum ( amari ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i , a in enumerate ( amari , start = 1 ) : <NEWLINE> <INDENT> H -= a <NEWLINE> if H <= 0 : <NEWLINE> <INDENT> ans = len ( husoku ) + i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> print ( ( n * ( n - 1 ) ) // 2 ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = A - B <NEWLINE> if abs ( ans ) > 10 ** 18 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if K % 2 != 0 : <NEWLINE> <INDENT> ans = B - A <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from math import gcd , pi , sqrt <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import itertools <NEWLINE> from collections import Counter , deque <NEWLINE> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <COMMENT> <NEWLINE> t = input ( ) <COMMENT> <NEWLINE> <NL> s_len = len ( s ) <NEWLINE> t_len = len ( t ) <NEWLINE> flg = False <NEWLINE> <NL> for i in range ( s_len - t_len , - 1 , - 1 ) : <NEWLINE> <INDENT> flg = True <NEWLINE> for j in range ( t_len ) : <NEWLINE> <INDENT> if s [ i + j ] != t [ j ] and s [ i + j ] != <STRING> : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg == True : <NEWLINE> <INDENT> trial = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flg == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> for i in s [ : trial ] : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + i <NEWLINE> <DEDENT> <DEDENT> ans = ans + t <NEWLINE> <NL> for i in s [ ( trial + t_len ) : ] : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( len ( list ( filter ( lambda x : len ( make_divisors ( x ) ) == 8 , range ( 1 , n + 1 , 2 ) ) ) ) ) <NEWLINE>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> def divisor ( n ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> table = [ ] <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> table . append ( i ) <NEWLINE> table . append ( n // i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> table = list ( set ( table ) ) <NEWLINE> return table <NEWLINE> <NL> <DEDENT> n , m = MAP ( ) <NEWLINE> a = sorted ( divisor ( m ) ) <NEWLINE> print ( m // a [ bisect_left ( a , n ) ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> for i , a in enumerate ( a_list ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> b . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c . append ( a ) <NEWLINE> <DEDENT> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> d = list ( reversed ( c ) ) + b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = list ( reversed ( b ) ) + c <NEWLINE> <DEDENT> print ( * d ) <NEWLINE>
from bisect import bisect_left <NEWLINE> from itertools import accumulate <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> shop = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> shop . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <NL> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> cnt += shop [ i ] [ 1 ] <NEWLINE> if M <= cnt : <NEWLINE> <INDENT> dif = cnt - M <NEWLINE> ans += shop [ i ] [ 0 ] * shop [ i ] [ 1 ] - dif * shop [ i ] [ 0 ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += shop [ i ] [ 0 ] * shop [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ k - q ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> p [ a - 1 ] += 1 <NEWLINE> <DEDENT> for j in p : <NEWLINE> <INDENT> if 0 < j : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def IslandsWar ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> a . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> removes = [ a [ 0 ] [ 1 ] ] <NEWLINE> <NL> for i , j in a [ 1 : ] : <NEWLINE> <INDENT> check = False <NEWLINE> for k in removes : <NEWLINE> <INDENT> if i < k : <NEWLINE> <INDENT> check = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not check : <NEWLINE> <INDENT> removes . append ( j ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( removes ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> IslandsWar ( ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - i - j <= k : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import itertools <NEWLINE> n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> k = [ i for i in range ( n + 1 ) ] <NEWLINE> ans = 0 <NEWLINE> for a , b in itertools . product ( k , k ) : <NEWLINE> <INDENT> if n >= a + b and a * 10000 + b * 5000 + ( n - a - b ) * 1000 == y : <NEWLINE> <INDENT> print ( a , b , n - a - b ) <NEWLINE> ans = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = list ( sorted ( input ( ) ) for _ in range ( n ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> for li in s : <NEWLINE> <INDENT> st = <STRING> <NEWLINE> for x in li : <NEWLINE> <INDENT> st += x <NEWLINE> <DEDENT> l . append ( st ) <NEWLINE> <NL> <DEDENT> c = collections . Counter ( l ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in c . values ( ) : <NEWLINE> <INDENT> ans += x * ( x - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> cnt = min ( N , M // 2 ) <NEWLINE> N -= cnt <NEWLINE> M -= cnt * 2 <NEWLINE> <NL> if M > 0 : <NEWLINE> <INDENT> cnt += M // 4 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 + 1 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> nodes = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> nodes [ x - 1 ] . append ( y - 1 ) <NEWLINE> <NL> <DEDENT> dp = [ - 1 ] * N <NEWLINE> <NL> def judge ( index ) : <NEWLINE> <INDENT> if dp [ index ] != - 1 : <NEWLINE> <INDENT> return dp [ index ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> edges = 0 <NEWLINE> for i in nodes [ index ] : <NEWLINE> <INDENT> edges = max ( edges , 1 + judge ( i ) ) <NEWLINE> <DEDENT> dp [ index ] = edges <NEWLINE> return edges <NEWLINE> <NL> <DEDENT> <DEDENT> answer = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> answer = max ( answer , judge ( i ) ) <NEWLINE> <DEDENT> print ( answer ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> inputs = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> h , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> inds = { } <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for D , j in enumerate ( input ( ) . split ( ) ) : <NEWLINE> <INDENT> inds [ int ( j ) - 1 ] = ( i , D ) <NEWLINE> <DEDENT> <DEDENT> nows = [ [ 0 ] for c in range ( d ) ] <NEWLINE> <NL> for k in range ( d , h * w ) : <NEWLINE> <INDENT> a , b = inds [ k ] <NEWLINE> x , y = inds [ k - d ] <NEWLINE> k %= d <NEWLINE> nows [ k ] . append ( nows [ k ] [ - 1 ] + abs ( a - x ) + abs ( b - y ) ) <NEWLINE> <DEDENT> q = input ( ) <NEWLINE> for i in inputs ( ) : <NEWLINE> <INDENT> l , r = map ( int , i . split ( ) ) <NEWLINE> l -= 1 ; r -= 1 <NEWLINE> l , b = divmod ( l , d ) <NEWLINE> r , b = divmod ( r , d ) <NEWLINE> print ( nows [ b ] [ r ] - nows [ b ] [ l ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> p = N <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if p >= P [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> p = P [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , K , L = map ( int , input ( ) . split ( ) ) <NEWLINE> uf_road = UnionFind ( N ) <NEWLINE> uf_train = UnionFind ( N ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> p -= 1 <NEWLINE> q -= 1 <NEWLINE> uf_road . union ( p , q ) <NEWLINE> <NL> <DEDENT> for i in range ( L ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> p -= 1 <NEWLINE> q -= 1 <NEWLINE> uf_train . union ( p , q ) <NEWLINE> <NL> <DEDENT> pair_list = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> pair_list . append ( ( uf_road . find ( i ) , uf_train . find ( i ) , i ) ) <NEWLINE> <NL> <DEDENT> pair_list . sort ( ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> <NL> pair = ( pair_list [ 0 ] [ 0 ] , pair_list [ 0 ] [ 1 ] ) <NEWLINE> countup_list = [ pair_list [ 0 ] [ 2 ] ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if pair == ( pair_list [ i ] [ 0 ] , pair_list [ i ] [ 1 ] ) : <NEWLINE> <INDENT> countup_list . append ( pair_list [ i ] [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for c in countup_list : <NEWLINE> <INDENT> ans [ c ] += len ( countup_list ) <NEWLINE> <DEDENT> pair = ( pair_list [ i ] [ 0 ] , pair_list [ i ] [ 1 ] ) <NEWLINE> countup_list = [ pair_list [ i ] [ 2 ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> for c in countup_list : <NEWLINE> <INDENT> ans [ c ] += len ( countup_list ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , M = [ int ( n ) for n in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> if abs ( N - M ) >= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif abs ( N - M ) == 1 : <NEWLINE> <INDENT> print ( ( factorial ( N ) * factorial ( M ) ) % 1000000007 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( factorial ( N ) * factorial ( M ) * 2 ) % 1000000007 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def factorial ( n ) : <NEWLINE> <INDENT> ret = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ret = ( ret * i ) % 1000000007 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> in_n = lambda : int ( readline ( ) ) <NEWLINE> in_nn = lambda : map ( int , readline ( ) . split ( ) ) <NEWLINE> in_s = lambda : readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> in_nl = lambda : list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> in_nl2 = lambda H : [ in_nl ( ) for _ in range ( H ) ] <NEWLINE> in_map = lambda : [ s == ord ( <STRING> ) for s in readline ( ) if s != ord ( <STRING> ) ] <NEWLINE> in_map2 = lambda H : [ in_map ( ) for _ in range ( H ) ] <NEWLINE> in_all = lambda : map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> N = in_n ( ) <NEWLINE> A = in_nl ( ) <NEWLINE> <NL> pa , ma = [ ] , [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] >= 0 : <NEWLINE> <INDENT> pa . append ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ma . append ( A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> pa = deque ( sorted ( pa ) ) <NEWLINE> ma = deque ( sorted ( ma ) [ : : - 1 ] ) <NEWLINE> <NL> max_value = 0 <NEWLINE> ans = [ ] <NEWLINE> while pa or ma : <NEWLINE> <NL> <INDENT> if len ( pa ) >= 1 and len ( ma ) >= 1 : <NEWLINE> <INDENT> if len ( pa ) == 1 and len ( ma ) == 1 : <NEWLINE> <INDENT> p , m = pa . popleft ( ) , ma . popleft ( ) <NEWLINE> ans . append ( ( p , m ) ) <NEWLINE> max_value = p - m <NEWLINE> <DEDENT> elif len ( pa ) >= 2 and len ( ma ) >= 1 : <NEWLINE> <INDENT> p , m = pa . popleft ( ) , ma [ 0 ] <NEWLINE> ans . append ( ( m , p ) ) <NEWLINE> ma [ 0 ] -= p <NEWLINE> <DEDENT> elif len ( pa ) >= 1 and len ( ma ) >= 2 : <NEWLINE> <INDENT> p , m = pa [ 0 ] , ma . popleft ( ) <NEWLINE> ans . append ( ( p , m ) ) <NEWLINE> pa [ 0 ] -= m <NEWLINE> <DEDENT> <DEDENT> elif len ( pa ) >= 2 : <NEWLINE> <INDENT> if len ( pa ) == 2 : <NEWLINE> <INDENT> p1 , p2 = pa . popleft ( ) , pa . popleft ( ) <NEWLINE> p1 , p2 = max ( p1 , p2 ) , min ( p1 , p2 ) <NEWLINE> ans . append ( ( p1 , p2 ) ) <NEWLINE> max_value = p1 - p2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p1 , p2 = pa . popleft ( ) , pa . popleft ( ) <NEWLINE> ans . append ( ( p1 , p2 ) ) <NEWLINE> if ( tp : = p1 - p2 ) >= 0 : <NEWLINE> <INDENT> pa . appendleft ( tp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ma . append ( tp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif len ( ma ) >= 2 : <NEWLINE> <INDENT> if len ( ma ) == 2 : <NEWLINE> <INDENT> m1 , m2 = ma . popleft ( ) , ma . popleft ( ) <NEWLINE> m1 , m2 = max ( m1 , m2 ) , min ( m1 , m2 ) <NEWLINE> ans . append ( ( m1 , m2 ) ) <NEWLINE> max_value = m1 - m2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m1 , m2 = ma . popleft ( ) , ma . popleft ( ) <NEWLINE> ans . append ( ( m1 , m2 ) ) <NEWLINE> pa . appendleft ( m1 - m2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max_value ) <NEWLINE> print ( <STRING> . join ( map ( lambda a : <STRING> . format ( a [ 0 ] , a [ 1 ] ) , ans ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> S = input ( ) <NEWLINE> s = [ ] <NEWLINE> for i in S : <NEWLINE> <INDENT> s += [ i ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> que = [ ] <NEWLINE> que += [ s [ 0 ] ] <NEWLINE> def cube ( i ) : <NEWLINE> <INDENT> global ans <NEWLINE> if i == len ( s ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> que . append ( s [ i ] ) <NEWLINE> flag = True <NEWLINE> while flag : <NEWLINE> <INDENT> if len ( que ) == 0 or len ( que ) == 1 : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> elif que [ - 1 ] == que [ - 2 ] : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> elif que [ - 1 ] != que [ - 2 ] : <NEWLINE> <INDENT> del que [ - 1 ] <NEWLINE> del que [ - 1 ] <NEWLINE> ans += 2 <NEWLINE> <DEDENT> <DEDENT> cube ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> cube ( 1 ) <NEWLINE>
BILLS = [ 10000 , 5000 , 1000 ] <NEWLINE> <NL> <NL> def calc_price ( counts ) : <NEWLINE> <INDENT> return sum ( [ bill * count for bill , count in zip ( BILLS , counts ) ] ) <NEWLINE> <NL> <NL> <DEDENT> def main ( n , y ) : <NEWLINE> <INDENT> for c1 in range ( n + 1 ) : <NEWLINE> <INDENT> for c2 in range ( 0 , n - c1 + 1 ) : <NEWLINE> <INDENT> counts = [ c1 , c2 , n - c1 - c2 ] <NEWLINE> if calc_price ( counts ) == y : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( c ) for c in counts ] ) ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , y = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> main ( n , y ) <NEWLINE> <DEDENT>
c = [ ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> c . append ( x ) <NEWLINE> c . append ( y ) <NEWLINE> c . append ( z ) <NEWLINE> <NL> <DEDENT> for a1 in range ( 101 ) : <NEWLINE> <INDENT> for a2 in range ( 101 ) : <NEWLINE> <INDENT> for a3 in range ( 101 ) : <NEWLINE> <INDENT> b1 = c [ 0 ] - a1 <NEWLINE> b2 = c [ 1 ] - a1 <NEWLINE> b3 = c [ 2 ] - a1 <NEWLINE> if c [ 3 ] == a2 + b1 and c [ 4 ] == a2 + b2 and c [ 5 ] == a2 + b3 and c [ 6 ] == a3 + b1 and c [ 7 ] == a3 + b2 and c [ 8 ] == a3 + b3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = x . copy ( ) <NEWLINE> y . sort ( ) <NEWLINE> z = set ( x ) <NEWLINE> t1 = y [ n // 2 - 1 ] <NEWLINE> t2 = y [ n // 2 ] <NEWLINE> idx = dict ( [ ] ) <NEWLINE> idx [ y [ 0 ] ] = 0 <NEWLINE> l = y [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> for i in y : <NEWLINE> <INDENT> if i == l : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx [ i ] = cnt <NEWLINE> l = i <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in x : <NEWLINE> <INDENT> t = idx [ i ] <NEWLINE> if t < n // 2 : <NEWLINE> <INDENT> print ( t2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t1 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ None for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] = str ( i + 1 ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
from itertools import permutations <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for P in permutations ( range ( N ) , N ) : <NEWLINE> <INDENT> if P [ 0 ] != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if P [ i + 1 ] not in G [ P [ i ] ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 1 <NEWLINE> now = 0 <NEWLINE> flg = True <NEWLINE> while l : <NEWLINE> <INDENT> now += l . pop ( 0 ) <NEWLINE> if now <= x : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> L = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> L = sorted ( L ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> import bisect <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> limit = L [ i ] + L [ j ] <NEWLINE> ok = bisect . bisect_left ( L , limit ) <NEWLINE> <COMMENT> <NL> ans += ok - 1 - j <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> flag = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> w = input ( ) <NEWLINE> l . append ( w ) <NEWLINE> <DEDENT> for k in range ( 1 , n ) : <NEWLINE> <INDENT> if l [ k - 1 ] [ - 1 ] != l [ k ] [ 0 ] : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> for j in range ( k ) : <NEWLINE> <INDENT> if l [ k ] == l [ j ] : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( flag == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = list ( [ input ( ) for i in range ( 2 ) ] ) <NEWLINE> print ( int ( a [ 0 ] ) + int ( a [ 1 ] ) ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> d = [ <STRING> ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , i + 6 ) : <NEWLINE> <INDENT> for k in range ( len ( d ) ) : <NEWLINE> <INDENT> if s [ i : j ] not in d and s [ i : j ] < d [ k ] : <NEWLINE> <INDENT> d . insert ( k , s [ i : j ] ) <NEWLINE> if len ( d ) > 5 : <NEWLINE> <INDENT> d . pop ( ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( d [ K - 1 ] ) <NEWLINE>
s = input ( ) <NEWLINE> res = <STRING> <NEWLINE> if s [ 0 ] != <STRING> : res = <STRING> <NEWLINE> elif s [ 2 : - 1 ] . count ( <STRING> ) != 1 : res = <STRING> <NEWLINE> else : <NEWLINE> <INDENT> li = list ( s ) <NEWLINE> li . remove ( <STRING> ) <NEWLINE> li . remove ( <STRING> ) <NEWLINE> for i in li : <NEWLINE> <INDENT> if i != i . lower ( ) : <NEWLINE> <INDENT> res = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<NL> import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> B = sorted ( [ a - i for i , a in enumerate ( A , start = 1 ) ] ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> if N % 2 == 1 : <NEWLINE> <INDENT> b = B [ N // 2 ] <NEWLINE> ans . append ( sum ( [ abs ( x - b ) for x in B ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b_left = ( B [ N // 2 - 1 ] + B [ N // 2 ] ) // 2 <NEWLINE> b_right = math . ceil ( ( B [ N // 2 - 1 ] + B [ N // 2 ] ) / 2 ) <NEWLINE> ans . append ( sum ( [ abs ( x - b_left ) for x in B ] ) ) <NEWLINE> ans . append ( sum ( [ abs ( x - b_right ) for x in B ] ) ) <NEWLINE> <NL> <DEDENT> print ( min ( ans ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> import heapq <NEWLINE> <NL> a = list ( map ( lambda x : int ( x ) * ( - 1 ) , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> tmp_min = heapq . heappop ( a ) <NEWLINE> heapq . heappush ( a , ( - 1 ) * ( - tmp_min // 2 ) ) <NEWLINE> <DEDENT> print ( - sum ( a ) ) <NEWLINE>
k , s = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - i - j <= k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
string = input ( ) <NEWLINE> index_of_A = string . index ( <STRING> ) <NEWLINE> index_of_Z = string . rfind ( <STRING> ) <NEWLINE> <NL> print ( index_of_Z - index_of_A + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> hn = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ls = [ 0 ] * ( n - 1 ) <NEWLINE> ans = 0 <NEWLINE> count = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if hn [ i + 1 ] <= hn [ i ] : <NEWLINE> <INDENT> ls [ i ] = 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , count ) <NEWLINE> count = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , count ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
<COMMENT> <NL> from collections import defaultdict , deque <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> G = { } <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> G [ i ] = [ ] <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u , v , w = ( int ( n ) for n in input ( ) . split ( ) ) <NEWLINE> G [ u ] . append ( ( v , w ) ) <NEWLINE> G [ v ] . append ( ( u , w ) ) <NEWLINE> <NL> <DEDENT> ret = [ - 1 ] * ( N + 1 ) <NEWLINE> <NL> que = deque ( ) <NEWLINE> que . append ( ( 1 , 0 ) ) <NEWLINE> <NL> while len ( que ) > 0 : <NEWLINE> <INDENT> node , distance = que [ 0 ] <NEWLINE> que . popleft ( ) <NEWLINE> <NL> ret [ node ] = distance % 2 <NEWLINE> for next_node , next_distance in G [ node ] : <NEWLINE> <INDENT> if ret [ next_node ] == - 1 : <NEWLINE> <INDENT> que . append ( ( next_node , distance + next_distance ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ret [ i + 1 ] ) <NEWLINE> <NL> <DEDENT>
import numpy as np <NEWLINE> <NL> <NL> def is_good ( mid , key ) : <NEWLINE> <INDENT> return A_sum - np . minimum ( A , mid // F ) . sum ( ) <= key <NEWLINE> <NL> <NL> <DEDENT> def binary_search ( bad , good , key ) : <NEWLINE> <INDENT> while good - bad > 1 : <NEWLINE> <INDENT> mid = ( bad + good ) // 2 <NEWLINE> if is_good ( mid , key ) : <NEWLINE> <INDENT> good = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bad = mid <NEWLINE> <DEDENT> <DEDENT> return good <NEWLINE> <NL> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> F = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> A . sort ( ) <NEWLINE> F [ : : - 1 ] . sort ( ) <NEWLINE> A_sum = A . sum ( ) <NEWLINE> ans = binary_search ( - 1 , np . max ( A * F ) , K ) <NEWLINE> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ABC = [ ] <NEWLINE> Adake = [ [ ] for _ in range ( N ) ] <NEWLINE> Bdake = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ABC . append ( ( a - 1 , b - 1 , - c ) ) <NEWLINE> Adake [ a - 1 ] . append ( b - 1 ) <NEWLINE> Bdake [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> def dfs ( X , s ) : <NEWLINE> <INDENT> used = { s } <NEWLINE> search = deque ( [ s ] ) <NEWLINE> while search : <NEWLINE> <INDENT> ss = search . pop ( ) <NEWLINE> for sss in X [ ss ] : <NEWLINE> <INDENT> if sss in used : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> used . add ( sss ) <NEWLINE> search . append ( sss ) <NEWLINE> <DEDENT> <DEDENT> return used <NEWLINE> <NL> <DEDENT> U = dfs ( Adake , 0 ) & dfs ( Bdake , N - 1 ) <NEWLINE> ABC = [ ( a , b , c ) for ( a , b , c ) in ABC if a in U and b in U ] <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> dist = [ INF ] * N <NEWLINE> dist [ 0 ] = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for a , b , c in ABC : <NEWLINE> <INDENT> if dist [ b ] > dist [ a ] + c : <NEWLINE> <INDENT> dist [ b ] = dist [ a ] + c <NEWLINE> if i == N - 1 and b == N - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - dist [ - 1 ] ) <NEWLINE>
<COMMENT> <NL> R , G , B , N = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> bingo = 0 <NEWLINE> <NL> for r in range ( 0 , 3001 ) : <NEWLINE> <INDENT> if R * r > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for g in range ( 0 , 3001 ) : <NEWLINE> <INDENT> b = ( N - ( R * r + G * g ) ) // B <NEWLINE> if b < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif R * r + G * g + B * b == N : <NEWLINE> <INDENT> bingo += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( bingo ) <NEWLINE>
from collections import Counter , defaultdict , deque <NEWLINE> from heapq import heappop , heappush , heapify <NEWLINE> import sys , bisect , math , itertools , fractions , pprint <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def inp ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n = inp ( ) <NEWLINE> a = [ inpl ( ) for _ in range ( n ) ] <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> c = [ ] <NEWLINE> for i , ( x , y ) in enumerate ( a ) : <NEWLINE> <INDENT> for j , ( z , w ) in enumerate ( a ) : <NEWLINE> <INDENT> if i == j : continue <NEWLINE> c . append ( ( ( x - z ) , ( y - w ) ) ) <NEWLINE> <DEDENT> <DEDENT> h = Counter ( c ) <NEWLINE> print ( n - max ( h . values ( ) ) ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( a ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( min ( a ) , max ( a ) + 1 ) : <NEWLINE> <INDENT> res = c [ x ] + c [ x + 1 ] + c [ x - 1 ] <NEWLINE> ans = max ( ans , res ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> ) if sum ( a ) >= h else print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> stdin = sys . stdin <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> <NL> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( ns ( ) ) <NEWLINE> def na ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = ni ( ) <NEWLINE> a = na ( ) <NEWLINE> b = na ( ) <NEWLINE> c = na ( ) <NEWLINE> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> c . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> <COMMENT> <NL> for bi in b : <NEWLINE> <INDENT> i = bisect_left ( a , bi ) <NEWLINE> j = bisect_right ( c , bi ) <NEWLINE> cnt += i * ( n - j ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if n [ 1 : ] == <STRING> * ( len ( n ) - 1 ) : <NEWLINE> <INDENT> print ( int ( n [ 0 ] ) + 9 * ( len ( n ) - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( n [ 0 ] ) + 9 * ( len ( n ) - 1 ) - 1 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> upper = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> middle = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lower = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> upper . sort ( ) <NEWLINE> middle . sort ( ) <NEWLINE> lower . sort ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> mid = middle [ i ] <NEWLINE> index_up = bisect . bisect_left ( upper , mid ) <NEWLINE> index_low = bisect . bisect_right ( lower , mid ) <NEWLINE> <NL> cnt += index_up * ( N - index_low ) <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def divisor ( n ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> table = [ ] <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> table . append ( i ) <NEWLINE> table . append ( n // i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> table = list ( set ( table ) ) <NEWLINE> return table <NEWLINE> <NL> <DEDENT> A , B , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> a_divisor = divisor ( A ) <NEWLINE> b_divisor = divisor ( B ) <NEWLINE> <NL> print ( sorted ( list ( set ( a_divisor ) & set ( b_divisor ) ) , reverse = True ) [ K - 1 ] ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> from collections import Counter <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> c = Counter ( a ) <NEWLINE> print ( sum ( sorted ( c . values ( ) , reverse = True ) [ k : len ( c ) ] ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> x = [ p [ 0 ] for p in xy ] <NEWLINE> y = [ p [ 1 ] for p in xy ] <NEWLINE> x . sort ( ) <NEWLINE> y . sort ( ) <NEWLINE> <NL> s1 = [ [ 0 ] * n for _ in range ( n ) ] <NEWLINE> s2 = [ [ 0 ] * n for _ in range ( n ) ] <NEWLINE> s3 = [ [ 0 ] * n for _ in range ( n ) ] <NEWLINE> s4 = [ [ 0 ] * n for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> for p in xy : <NEWLINE> <INDENT> if p [ 0 ] <= x [ i ] and p [ 1 ] <= y [ j ] : <NEWLINE> <INDENT> s1 [ i ] [ j ] += 1 <NEWLINE> s2 [ i ] [ j ] += ( p [ 0 ] < x [ i ] ) <NEWLINE> s3 [ i ] [ j ] += ( p [ 1 ] < y [ j ] ) <NEWLINE> s4 [ i ] [ j ] += ( p [ 0 ] < x [ i ] ) * ( p [ 1 ] < y [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = float ( <STRING> ) <NEWLINE> for s in range ( n ) : <NEWLINE> <INDENT> for t in range ( s + 1 , n ) : <NEWLINE> <INDENT> for u in range ( n ) : <NEWLINE> <INDENT> for v in range ( u + 1 , n ) : <NEWLINE> <INDENT> if s1 [ t ] [ v ] - s3 [ t ] [ u ] - s2 [ s ] [ v ] + s4 [ s ] [ u ] >= k : <NEWLINE> <INDENT> ans = min ( ans , ( x [ t ] - x [ s ] ) * ( y [ v ] - y [ u ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> c = 1 <NEWLINE> for b in range ( 1 , 32 ) : <NEWLINE> <INDENT> for p in range ( 2 , 10 ) : <NEWLINE> <INDENT> if b ** p <= x : <NEWLINE> <INDENT> c = max ( c , b ** p ) <NEWLINE> <DEDENT> else : break <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
from collections import defaultdict <NEWLINE> s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> dd = { } <NEWLINE> if len ( s ) == 1 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> dd [ s [ i ] ] = 1 <NEWLINE> <DEDENT> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( s ) ) : <NEWLINE> <INDENT> if j - i + 1 <= k : <NEWLINE> <INDENT> dd [ s [ i : j + 1 ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> li = [ ] <NEWLINE> for key in dd : <NEWLINE> <INDENT> li . append ( key ) <NEWLINE> <DEDENT> li . sort ( ) <NEWLINE> print ( li [ k - 1 ] ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( N + K ) % 3 == 0 and N * 2 >= K and K * 2 >= N : <NEWLINE> <INDENT> A = max ( N , K ) - min ( N , K ) <NEWLINE> low = ( min ( N , K ) - A ) // 3 <NEWLINE> all_pt = low * 2 + A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> up , down = 1 , 1 <NEWLINE> for i in range ( low ) : <NEWLINE> <INDENT> up = up * ( all_pt - i ) % mod <NEWLINE> down = down * ( i + 1 ) % mod <NEWLINE> <DEDENT> base = pow ( down , mod - 2 , mod ) <NEWLINE> print ( up * base % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> ans = 0 <NEWLINE> while i < n - 1 : <NEWLINE> <INDENT> if p [ i ] == i + 1 : <NEWLINE> <INDENT> p [ i ] , p [ i + 1 ] = p [ i + 1 ] , p [ i ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if p [ n - 1 ] == n : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import copy <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for c in range ( N ) ] <NEWLINE> B = sorted ( copy . deepcopy ( A ) , reverse = True ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == B [ 0 ] : <NEWLINE> <INDENT> print ( B [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> count = [ 0 ] * ( 2 * 10 ** 5 + 1 ) <NEWLINE> l = [ 0 ] + [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if l [ i ] == l [ i - 1 ] : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] <NEWLINE> continue <NEWLINE> <DEDENT> dp [ i ] = ( dp [ i - 1 ] + count [ l [ i ] ] ) % mod <NEWLINE> count [ l [ i ] ] = dp [ i ] <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> N = len ( s ) <NEWLINE> <NL> ref = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lst = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> if s [ i ] in ref : <NEWLINE> <INDENT> while s [ i ] in ref : <NEWLINE> <INDENT> ans = ans + s [ i ] <NEWLINE> i += 1 <NEWLINE> if i >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> lst . append ( ans ) <NEWLINE> <NL> <DEDENT> ans = - float ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , len ( lst [ i ] ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = 0 <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if H [ i ] >= H [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if i == N - 2 : <NEWLINE> <INDENT> res = max ( res , cnt ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res = max ( res , cnt ) <NEWLINE> cnt = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> m = a * b <NEWLINE> lst = [ ] <NEWLINE> for i in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> if m < a * i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> lst . append ( a * i ) <NEWLINE> <NL> <DEDENT> for j in lst : <NEWLINE> <INDENT> if j % b == 0 : <NEWLINE> <INDENT> print ( j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> stdIn1 , stdIn2 = map ( int , input ( ) . split ( ) ) <NEWLINE> stdOut = solve ( stdIn1 , stdIn2 ) <NEWLINE> print ( stdOut ) <NEWLINE> <NL> <NL> <DEDENT> <STRING> <NEWLINE> <NL> <NL> def solve ( k , s ) : <NEWLINE> <INDENT> pattern = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> if x > s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if x + y > s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> z = s - x - y <NEWLINE> if z <= k : <NEWLINE> <INDENT> pattern += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return pattern <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> C = [ 0 ] * N <NEWLINE> c = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . append ( A [ 0 ] ) <NEWLINE> R . append ( A [ 1 ] ) <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> C [ i ] = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C [ i ] = c <NEWLINE> <DEDENT> <DEDENT> C [ N - 1 ] = c <NEWLINE> S += <STRING> <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> if S [ R [ i ] - 1 ] == <STRING> and S [ R [ i ] ] == <STRING> : <NEWLINE> <INDENT> p = C [ R [ i ] - 1 ] - C [ L [ i ] - 1 ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = C [ R [ i ] - 1 ] - C [ L [ i ] - 1 ] <NEWLINE> <DEDENT> if S [ L [ i ] - 1 ] == <STRING> and S [ L [ i ] ] == <STRING> : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> print ( p ) <NEWLINE> <DEDENT>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 0 <NEWLINE> nu = 0 <NEWLINE> for i in range ( 1 , X ) : <NEWLINE> <INDENT> if i == li [ nu ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> nu += 1 <NEWLINE> <DEDENT> if nu == len ( li ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> b = len ( li ) - a <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
from itertools import product <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> d = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> for _ in range ( a ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if i + 1 not in d : <NEWLINE> <INDENT> d [ i + 1 ] = [ ] <NEWLINE> <DEDENT> d [ i + 1 ] . append ( ( x , y ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ret = 0 <NEWLINE> for x in product ( ( 0 , 1 ) , repeat = n ) : <NEWLINE> <INDENT> tmp = [ - 1 ] * n <NEWLINE> ok = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == 1 and i + 1 in d : <NEWLINE> <INDENT> for y in d [ i + 1 ] : <NEWLINE> <INDENT> if tmp [ y [ 0 ] - 1 ] == - 1 : <NEWLINE> <INDENT> tmp [ y [ 0 ] - 1 ] = y [ 1 ] <NEWLINE> <DEDENT> elif tmp [ y [ 0 ] - 1 ] != y [ 1 ] : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if not ok : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ok and all ( a == b or b == - 1 for a , b in zip ( x , tmp ) ) : <NEWLINE> <INDENT> ret = max ( ret , sum ( x ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
nums = [ ] <NEWLINE> nums = input ( ) . split ( ) <NEWLINE> N = int ( nums [ 0 ] ) <NEWLINE> Y = int ( nums [ 1 ] ) <NEWLINE> Right = 0 <NEWLINE> for a in range ( N + 1 ) : <NEWLINE> <INDENT> for b in range ( N + 1 - a ) : <NEWLINE> <INDENT> c = N - a - b <NEWLINE> if ( Y == 10000 * a + 5000 * b + 1000 * c ) : <NEWLINE> <INDENT> if ( N == ( a + b + c ) ) : <NEWLINE> <INDENT> Right = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> if ( Right == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a , b , c ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( input ( ) ) <NEWLINE> wcnt , ecnt , ans , box = 0 , 0 , 0 , [ ] <NEWLINE> W = a . count ( <STRING> ) <NEWLINE> E = a . count ( <STRING> ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] == <STRING> : <NEWLINE> <INDENT> box . append ( E + wcnt ) <NEWLINE> wcnt += 1 <NEWLINE> W -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> box . append ( E + wcnt ) <NEWLINE> ecnt += 1 <NEWLINE> E -= 1 <NEWLINE> <DEDENT> <DEDENT> if a [ n - 1 ] == <STRING> : <NEWLINE> <INDENT> W -= 1 <NEWLINE> box . append ( E + wcnt ) <NEWLINE> wcnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> E -= 1 <NEWLINE> box . append ( E + wcnt ) <NEWLINE> ecnt += 1 <NEWLINE> <DEDENT> print ( min ( box ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> now = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if H [ i - 1 ] >= H [ i ] : <NEWLINE> <INDENT> now += 1 <NEWLINE> ans = max ( ans , now ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> E = [ ( p + 1 ) / 2.0 for p in P ] <NEWLINE> tmp = sum ( E [ 0 : K ] ) <NEWLINE> ans = tmp <NEWLINE> for i in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> tmp = tmp - E [ i - 1 ] + E [ i + K - 1 ] <NEWLINE> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <STRING> <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i < n - 1 and p [ i ] == i + 1 : <NEWLINE> <INDENT> p [ i + 1 ] = p [ i ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> elif i == n - 1 and p [ i ] == i + 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> import numpy as np <NEWLINE> N , K , * XYC = open ( 0 ) . read ( ) . split ( ) <NEWLINE> N = int ( N ) <NEWLINE> K = int ( K ) <NEWLINE> board = np . zeros ( ( 4 * K + 1 , 4 * K + 1 ) , dtype = np . uint16 ) <NEWLINE> for x , y , c in zip ( XYC [ : : 3 ] , XYC [ 1 : : 3 ] , XYC [ 2 : : 3 ] ) : <NEWLINE> <INDENT> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> x += K <NEWLINE> <DEDENT> x = x % ( 2 * K ) <NEWLINE> y = y % ( 2 * K ) <NEWLINE> board [ x , y ] += 1 <NEWLINE> board [ ( x + K ) % ( 2 * K ) , ( y + K ) % ( 2 * K ) ] += 1 <NEWLINE> <DEDENT> board [ 1 + 2 * K : , 1 + 2 * K : ] = board [ : 2 * K , : 2 * K ] <NEWLINE> board [ 1 : 1 + 2 * K , 1 + 2 * K : ] = board [ 1 + 2 * K : , 1 + 2 * K : ] <NEWLINE> board [ 1 + 2 * K : , 1 : 1 + 2 * K ] = board [ 1 + 2 * K : , 1 + 2 * K : ] <NEWLINE> board [ 1 : 1 + 2 * K , 1 : 1 + 2 * K ] = board [ 1 + 2 * K : , 1 + 2 * K : ] <NEWLINE> board [ 0 , : ] = 0 <NEWLINE> board [ : , 0 ] = 0 <NEWLINE> for j in range ( 1 , 1 + 4 * K ) : <NEWLINE> <INDENT> board [ : , j ] += board [ : , j - 1 ] <NEWLINE> <DEDENT> for j in range ( 1 , 1 + 4 * K ) : <NEWLINE> <INDENT> board [ j , : ] += board [ j - 1 , : ] <NEWLINE> <DEDENT> ans = np . max ( board [ K : 3 * K , K : 3 * K ] + board [ : 2 * K , : 2 * K ] - <NEWLINE> <INDENT> board [ : 2 * K , K : 3 * K ] - board [ K : 3 * K , : 2 * K ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( n + 1 - i ) : <NEWLINE> <INDENT> if 10000 * ( n - i - j ) + 5000 * j + 1000 * i == y : <NEWLINE> <INDENT> print ( n - i - j , j , i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE>
import collections <NEWLINE> <NL> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <COMMENT> <NEWLINE> K = 2 * ( 10 ** 5 ) <NEWLINE> g1 = [ 1 , 1 ] <COMMENT> <NEWLINE> g2 = [ 1 , 1 ] <COMMENT> <NEWLINE> inverse = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , K + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( n ) <NEWLINE> nCk = n <NEWLINE> R = list ( ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( L ) <NEWLINE> nikai = c . most_common ( ) [ 0 ] [ 0 ] <COMMENT> <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if L [ i ] == nikai : <NEWLINE> <INDENT> R . append ( i ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> k = n - R [ 1 ] + R [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> nCk = cmb ( n + 1 , i + 1 , mod ) <NEWLINE> a = cmb ( k , i , mod ) <NEWLINE> print ( ( nCk - a ) % mod ) <NEWLINE> <DEDENT> print ( 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> pow = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> pow = pow * i % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( pow ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = [ s [ : k - 1 ] , s [ k - 1 ] . lower ( ) , s [ k : ] ] <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> for h in range ( 1 , 3501 ) : <NEWLINE> <INDENT> for n in range ( 1 , 3501 ) : <NEWLINE> <INDENT> if 4 * h * n - N * n - N * h > 0 : <NEWLINE> <INDENT> if ( N * h * n ) % ( 4 * h * n - N * n - N * h ) == 0 : <NEWLINE> <INDENT> print ( h , n , ( N * h * n ) // ( 4 * h * n - N * n - N * h ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> k = int ( math . log10 ( n ) ) <NEWLINE> <NL> a = n // ( 10 ** k ) <NEWLINE> b = n % ( 10 ** k ) <NEWLINE> <NL> if k == 0 : <NEWLINE> <INDENT> ans = n <NEWLINE> <DEDENT> elif n % 10 == 9 : <NEWLINE> <INDENT> ans = k * 9 + a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = k * 9 + a - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> score = 0 <NEWLINE> i = 0 <NEWLINE> ans_list = [ ] <NEWLINE> <NL> while score <= n : <NEWLINE> <INDENT> i += 1 <NEWLINE> score += i <NEWLINE> ans_list . append ( i ) <NEWLINE> <NL> <DEDENT> ans_list . remove ( score - n ) <NEWLINE> for k in range ( len ( ans_list ) ) : <NEWLINE> <INDENT> print ( ans_list [ k ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> def f ( myList ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> if len ( myList ) % 2 == 0 : <NEWLINE> <INDENT> for i in range ( len ( myList ) ) : <NEWLINE> <INDENT> ans += str ( myList [ i ] ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( myList ) ) : <NEWLINE> <INDENT> ans += str ( myList [ - ( i + 1 ) ] ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> return ans [ : - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = collections . deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . appendleft ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( f ( b ) ) <NEWLINE>
import sys <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> ln1 = [ ] <NEWLINE> ln2 = [ ] <NEWLINE> for i in p : <NEWLINE> <INDENT> if i [ 0 ] == 1 : <NEWLINE> <INDENT> ln1 . append ( i [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> for j in p : <NEWLINE> <INDENT> if j [ 1 ] == n : <NEWLINE> <INDENT> ln2 . append ( j [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( set ( ln1 ) & set ( ln2 ) ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = 4 <NEWLINE> a = [ 1 , 2 , 3 , 4 ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> <NL> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> y = [ a [ j ] for j in range ( 1 , n , 2 ) ] [ : : - 1 ] <NEWLINE> z = [ a [ j ] for j in range ( 0 , n , 2 ) ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> y = [ a [ j ] for j in range ( 0 , n , 2 ) ] [ : : - 1 ] <NEWLINE> z = [ a [ j ] for j in range ( 1 , n , 2 ) ] <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , y + z ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ i for i in range ( N ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> for i in range ( A , min ( A + K , B + 1 ) ) : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> for i in range ( max ( B - K + 1 , A + 1 ) , B + 1 ) : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <NL> <DEDENT> l = list ( set ( l ) ) <NEWLINE> l . sort ( ) <NEWLINE> print ( * l , sep = <STRING> ) <NEWLINE>
ans = 0 <NEWLINE> k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if 0 <= z <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> <NL> num = 0 <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> num += p [ j ] <NEWLINE> <DEDENT> l . append ( num ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> l . append ( l [ i ] - p [ i ] + p [ i + k ] ) <NEWLINE> <NL> <DEDENT> print ( ( max ( l ) + k ) / 2 ) <NEWLINE>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 2018 <NEWLINE> for i in range ( L , R ) : <NEWLINE> <INDENT> for j in range ( L + 1 , R + 1 ) : <NEWLINE> <INDENT> if ans > ( i * j ) % 2019 : <NEWLINE> <INDENT> ans = ( i * j ) % 2019 <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> li = [ int ( input ( ) ) for _ in range ( 5 ) ] <NEWLINE> m , last , ans , lm = 10 , li [ 0 ] , 0 , 0 <NEWLINE> <NL> for i in range ( 5 ) : <NEWLINE> <INDENT> l = li [ i ] <NEWLINE> if 0 < l % 10 < m : <NEWLINE> <INDENT> m = l % 10 <NEWLINE> last = l <NEWLINE> lm = i <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 5 ) : <NEWLINE> <INDENT> l = li [ i ] <NEWLINE> if l == last and i == lm : <NEWLINE> <INDENT> ans += l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += math . ceil ( l / 10 ) * 10 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> <NL> <NL> change = [ ] <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ - 1 * int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> change . append ( [ - c , b ] ) <NEWLINE> <NL> <DEDENT> l = [ ] <NEWLINE> heapq . heapify ( change ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> flg = False <NEWLINE> cnt = 0 <NEWLINE> while cnt < n : <NEWLINE> <INDENT> if change : <NEWLINE> <INDENT> atmp = - 1 * a [ 0 ] <NEWLINE> btmp = - 1 * change [ 0 ] [ 0 ] <NEWLINE> if atmp <= btmp : <NEWLINE> <INDENT> b , c = heapq . heappop ( change ) <NEWLINE> while c > 0 and cnt < n : <NEWLINE> <INDENT> l . append ( b ) <NEWLINE> c -= 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> aa = heapq . heappop ( a ) <NEWLINE> l . append ( aa ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> aa = heapq . heappop ( a ) <NEWLINE> l . append ( aa ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 * sum ( l ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B . append ( A [ i ] - ( i + 1 ) ) <NEWLINE> <DEDENT> B . sort ( ) <NEWLINE> b = B [ N // 2 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += abs ( B [ i ] - b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> par = [ i for i in range ( N ) ] <NEWLINE> <NL> def find ( x , P ) : <NEWLINE> <INDENT> if P [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = find ( P [ x ] , P ) <NEWLINE> P [ x ] = b <NEWLINE> return b <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y , P ) : <NEWLINE> <INDENT> root_x = find ( x , P ) <NEWLINE> root_y = find ( y , P ) <NEWLINE> if root_y > root_x : <NEWLINE> <INDENT> P [ root_x ] = root_y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P [ root_y ] = root_x <NEWLINE> <NL> <DEDENT> <DEDENT> par2 = [ i for i in range ( N ) ] <NEWLINE> <NL> for _ in range ( K ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> unite ( p - 1 , q - 1 , par ) <NEWLINE> <NL> <DEDENT> for _ in range ( L ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> unite ( p - 1 , q - 1 , par2 ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> r = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> r . append ( ( find ( i , par ) , find ( i , par2 ) ) ) <NEWLINE> <NL> <DEDENT> import collections <NEWLINE> count = collections . Counter ( r ) <NEWLINE> <COMMENT> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans = count [ r [ i ] ] <NEWLINE> if i == N - 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import bisect <NEWLINE> import itertools <NEWLINE> <NL> N = int ( input ( ) ) <COMMENT> <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> b_counts = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> b_count = bisect . bisect_left ( A , B [ i ] ) <NEWLINE> b_counts [ i ] = b_count <NEWLINE> <NL> <DEDENT> cumsum_b_counts = list ( itertools . accumulate ( b_counts ) ) <NEWLINE> cumsum_b_counts = [ 0 ] + cumsum_b_counts <NEWLINE> <NL> <COMMENT> <NL> total = 0 <NEWLINE> for c in C : <NEWLINE> <INDENT> count = bisect . bisect_left ( B , c ) <NEWLINE> total += cumsum_b_counts [ count ] <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE> <NL>
s = str ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> dic = { } <NEWLINE> for i in range ( 1 , 6 ) : <NEWLINE> <INDENT> for j in range ( len ( s ) + 1 - i ) : <NEWLINE> <INDENT> dic . setdefault ( s [ j : j + i ] , 0 ) <NEWLINE> dic [ s [ j : j + i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> sort_dic = sorted ( dic ) <NEWLINE> print ( sort_dic [ k - 1 ] ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s [ i ] . sort ( ) <NEWLINE> s [ i ] = <STRING> . join ( s [ i ] ) <NEWLINE> <DEDENT> counter = Counter ( s ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> for val in counter . values ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += val * ( val - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys , math , collections , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> xy = [ ] <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for _ in range ( N ) : <NEWLINE> <INDENT> xy . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> rxy = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> rxy . append ( ( xy [ i ] [ 0 ] - xy [ j ] [ 0 ] , xy [ i ] [ 1 ] - xy [ j ] [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> cr = collections . Counter ( rxy ) <NEWLINE> print ( N - max ( cr . values ( ) ) ) <NEWLINE> <NL>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> X = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Xs = list ( X ) <NEWLINE> Xs . sort ( ) <NEWLINE> for x in X : <NEWLINE> <INDENT> a = bisect . bisect_left ( Xs , x ) <NEWLINE> if a >= n / 2 : <NEWLINE> <INDENT> print ( Xs [ int ( n / 2 ) - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Xs [ int ( n / 2 ) ] ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> li = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> or s [ i ] == <STRING> or s [ i ] == <STRING> or s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> li . append ( cnt ) <NEWLINE> print ( max ( li ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> num_list = [ 0 ] * ( n + 1 ) <NEWLINE> num_list [ 0 ] = 1 <NEWLINE> a_list = set ( [ int ( input ( ) ) for _ in range ( m ) ] ) <NEWLINE> if 1 not in a_list : <NEWLINE> <INDENT> num_list [ 1 ] = 1 <NEWLINE> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i not in a_list : <NEWLINE> <INDENT> num_list [ i ] = num_list [ i - 1 ] + num_list [ i - 2 ] <NEWLINE> <DEDENT> <DEDENT> print ( num_list [ n ] % ( 10 ** 9 + 7 ) ) <NEWLINE>
from collections import Counter <NEWLINE> mod = 998244353 <NEWLINE> n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if d [ 0 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> C = Counter ( d ) <NEWLINE> C = dict ( sorted ( C . items ( ) ) ) <NEWLINE> <NL> memo1 = C [ 1 ] <NEWLINE> memo2 = 1 <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if d [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for key in C : <NEWLINE> <INDENT> if key >= 2 : <NEWLINE> <INDENT> if memo2 + 1 != key : <COMMENT> <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = ( ans * memo1 ** C [ key ] ) % mod <COMMENT> <NEWLINE> memo1 = C [ key ] <NEWLINE> memo2 = key <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> count2 = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if count == 8 and i % 2 != 0 : <NEWLINE> <INDENT> count2 += 1 <NEWLINE> <DEDENT> ans = count2 <NEWLINE> count = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> T = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> <NL> def gcd ( x , y ) : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> t = x <NEWLINE> x = y <NEWLINE> y = t <NEWLINE> <NL> <DEDENT> if y == 0 : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( y , x % y ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if N == 1 : <NEWLINE> <INDENT> print ( T [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> res = T [ 0 ] * T [ 1 ] // gcd ( T [ 0 ] , T [ 1 ] ) <NEWLINE> <NL> if N > 2 : <NEWLINE> <INDENT> for i in range ( 2 , N ) : <NEWLINE> <INDENT> r = res * T [ i ] // gcd ( res , T [ i ] ) <NEWLINE> res = max ( r , res ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> if sum ( b [ i : : i + 1 ] ) % 2 != a [ i ] : <NEWLINE> <INDENT> b [ i ] += 1 <NEWLINE> ans . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( b ) ) <NEWLINE> print ( * sorted ( ans ) ) <NEWLINE>
w = [ str ( input ( ) ) for i in range ( 5 ) ] <NEWLINE> num = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> w1 = [ ] <NEWLINE> m = 0 <NEWLINE> t = 0 <NEWLINE> for h in w : <NEWLINE> <INDENT> for j in num : <NEWLINE> <INDENT> if h [ - 1 ] == j : <NEWLINE> <INDENT> w1 . append ( int ( h ) + num . index ( j ) ) <NEWLINE> if m <= num . index ( j ) : <NEWLINE> <INDENT> m = num . index ( j ) <NEWLINE> k = w . index ( h ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for l in range ( 5 ) : <NEWLINE> <INDENT> if l != k : <NEWLINE> <INDENT> t += w1 [ l ] <NEWLINE> <DEDENT> <DEDENT> print ( t + int ( w [ k ] ) ) <NEWLINE>
import math <NEWLINE> <NL> n , h = map ( int , input ( ) . split ( ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> maxa = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> maxa = max ( x , maxa ) <NEWLINE> b [ i ] = y <NEWLINE> <DEDENT> b . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if b [ i ] < maxa : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> h -= b [ i ] <NEWLINE> ans += 1 <NEWLINE> if h <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if not h <= 0 : <NEWLINE> <INDENT> ans += math . ceil ( h / maxa ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> student = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> cpoint = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> mannmn = 10 ** 10 <NEWLINE> mann = 10 ** 10 <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> mann = abs ( student [ i ] [ 0 ] - cpoint [ j ] [ 0 ] ) + abs ( student [ i ] [ 1 ] - cpoint [ j ] [ 1 ] ) <NEWLINE> if mann < mannmn : <NEWLINE> <INDENT> mannmn = mann <NEWLINE> ref = j <NEWLINE> <DEDENT> <DEDENT> print ( ref + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> s_a = input ( ) <NEWLINE> s_b = input ( ) <NEWLINE> s_c = input ( ) <NEWLINE> s_a = [ s for s in s_a if s != <STRING> ] <NEWLINE> s_b = [ s for s in s_b if s != <STRING> ] <NEWLINE> s_c = [ s for s in s_c if s != <STRING> ] <NEWLINE> s_a = deque ( s_a ) <NEWLINE> s_b = deque ( s_b ) <NEWLINE> s_c = deque ( s_c ) <NEWLINE> if not s_a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> turn = s_a . popleft ( ) <NEWLINE> ans = - 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> if turn == <STRING> and s_a : <NEWLINE> <INDENT> turn = s_a . popleft ( ) <NEWLINE> <DEDENT> elif turn == <STRING> and s_b : <NEWLINE> <INDENT> turn = s_b . popleft ( ) <NEWLINE> <DEDENT> elif turn == <STRING> and s_c : <NEWLINE> <INDENT> turn = s_c . popleft ( ) <NEWLINE> <DEDENT> elif turn == <STRING> and not s_a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> elif turn == <STRING> and not s_b : <NEWLINE> <INDENT> ans = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif turn == <STRING> and not s_c : <NEWLINE> <INDENT> ans = 2 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ans == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> from collections import Counter , deque <NEWLINE> from collections import defaultdict <NEWLINE> from itertools import combinations , permutations , accumulate , groupby , product <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from math import floor , ceil , pi , factorial <NEWLINE> from operator import itemgetter <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LI2 ( ) : return [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> def MXI ( ) : return [ [ LI ( ) ] for i in range ( n ) ] <NEWLINE> def SI ( ) : return input ( ) . rstrip ( ) <NEWLINE> def printns ( x ) : print ( <STRING> . join ( x ) ) <NEWLINE> def printni ( x ) : print ( <STRING> . join ( list ( map ( str , x ) ) ) ) <NEWLINE> inf = 10 ** 17 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> n , m , que = MI ( ) <NEWLINE> lis = [ [ 0 ] * n for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = MI ( ) <NEWLINE> lis [ l - 1 ] [ r - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> lis [ i ] = list ( accumulate ( lis [ i ] ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n - 1 ) : <NEWLINE> <INDENT> lis [ j + 1 ] [ i ] += lis [ j ] [ i ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( que ) : <NEWLINE> <INDENT> p , q = MI ( ) <NEWLINE> if p == 1 : <NEWLINE> <INDENT> ans = lis [ q - 1 ] [ q - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = lis [ q - 1 ] [ q - 1 ] - lis [ p - 2 ] [ q - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import Counter , deque <NEWLINE> <NL> _ , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> d = deque ( sorted ( Counter ( a ) . values ( ) ) ) <NEWLINE> while k < len ( d ) : <NEWLINE> <INDENT> ans += d . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ float ( <STRING> ) ] * n <NEWLINE> ans = float ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> count = x * i <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> l [ j ] = min ( l [ j ] , a [ ( j - i ) % n ] ) <NEWLINE> count += l [ j ] <NEWLINE> <DEDENT> ans = min ( ans , count ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import heapq <NEWLINE> <NL> left = [ 0 ] * ( N + 1 ) <NEWLINE> l = a [ : N ] <NEWLINE> left [ 0 ] = sum ( l ) <NEWLINE> <NL> heapq . heapify ( l ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> c = a [ N + i - 1 ] <NEWLINE> lmin = heapq . heappop ( l ) <NEWLINE> if lmin < c : <NEWLINE> <INDENT> left [ i ] = left [ i - 1 ] + c - lmin <NEWLINE> heapq . heappush ( l , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left [ i ] = left [ i - 1 ] <NEWLINE> heapq . heappush ( l , lmin ) <NEWLINE> <NL> <DEDENT> <DEDENT> a = [ - x for x in a [ : : - 1 ] ] <NEWLINE> right = [ 0 ] * ( N + 1 ) <NEWLINE> r = a [ : N ] <NEWLINE> right [ 0 ] = sum ( r ) <NEWLINE> <NL> heapq . heapify ( r ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> c = - a [ N + i - 1 ] <NEWLINE> rmax = - heapq . heappop ( r ) <NEWLINE> if rmax > c : <NEWLINE> <INDENT> right [ i ] = right [ i - 1 ] - c + rmax <NEWLINE> heapq . heappush ( r , - c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right [ i ] = right [ i - 1 ] <NEWLINE> heapq . heappush ( r , - rmax ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = - 10 ** 20 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , left [ i ] + right [ N - i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = ( n - 1 ) // 2 <NEWLINE> l = sorted ( x ) <NEWLINE> for i in x : <NEWLINE> <INDENT> if i > l [ m ] : print ( l [ m ] ) <NEWLINE> else : print ( l [ m + 1 ] ) <NEWLINE> <DEDENT>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> <COMMENT> <NL> BC . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> temp = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <COMMENT> <NL> <INDENT> temp += [ BC [ i ] [ 1 ] ] * BC [ i ] [ 0 ] <NEWLINE> if len ( temp ) > N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> A += temp <NEWLINE> A . sort ( reverse = True ) <NEWLINE> <NL> print ( sum ( A [ : N ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maxI = 0 <NEWLINE> maxT = 0 <NEWLINE> t = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t += p [ i ] <NEWLINE> if k <= i : <NEWLINE> <INDENT> t -= p [ i - k ] <NEWLINE> <DEDENT> if maxT < t : <NEWLINE> <INDENT> maxT = t <NEWLINE> maxI = i <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> <NL> def calc ( n ) : <NEWLINE> <INDENT> return n * ( n + 1 ) / 2 / n <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += i / n <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> for i in range ( maxI - k + 1 , maxI + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += calc ( p [ i ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> cnt = [ 0 ] * ( 10 ** 5 + 2 ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> cnt [ i + 1 ] += 1 <NEWLINE> cnt [ i + 2 ] += 1 <NEWLINE> <NL> <DEDENT> print ( max ( cnt ) ) <NEWLINE>
m = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans1 = [ ] <NEWLINE> ans = 0 <NEWLINE> if m > 1 : <NEWLINE> <NL> <INDENT> for x in range ( m - 1 ) : <NEWLINE> <INDENT> if h [ x ] < h [ x + 1 ] : <NEWLINE> <INDENT> ans1 . append ( ans ) <NEWLINE> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> ans1 . append ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( max ( ans1 ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> <STRING> <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if p [ i ] == i + 1 : <NEWLINE> <INDENT> p [ i ] , p [ i + 1 ] = p [ i + 1 ] , p [ i ] <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if p [ - 1 ] == n : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> c = [ [ ] for i in range ( N ) ] <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> c [ a - 1 ] . append ( b - 1 ) <NEWLINE> <DEDENT> from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> def f2 ( q ) : <NEWLINE> <INDENT> s = set ( q ) <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> if a in s and b in s : <NEWLINE> <INDENT> i = q . index ( b ) <NEWLINE> if q [ i - 1 ] != a : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if a in s and b in s and q [ i - 1 ] != a : <NEWLINE> <INDENT> q2 = deque ( [ a , b ] ) <NEWLINE> while q [ ( i + 1 ) % len ( q ) ] != a : <NEWLINE> <INDENT> q2 . append ( q [ ( i + 1 ) % len ( q ) ] ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> f2 ( q2 ) <NEWLINE> <DEDENT> print ( len ( q ) , * q , sep = <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> v = [ 0 ] * N <NEWLINE> w = [ 0 ] * N <NEWLINE> def f ( p , v , q ) : <NEWLINE> <INDENT> v [ p ] = 1 <NEWLINE> w [ p ] = 1 <NEWLINE> q . append ( p + 1 ) <NEWLINE> for n in c [ p ] : <NEWLINE> <INDENT> if v [ n ] : <NEWLINE> <INDENT> f2 ( q ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f ( n , v , q ) <NEWLINE> <DEDENT> <DEDENT> q . pop ( ) <NEWLINE> v [ p ] = 0 <NEWLINE> <DEDENT> for p in range ( N ) : <NEWLINE> <INDENT> if w [ p ] == 0 : <NEWLINE> <INDENT> f ( p , v , deque ( ) ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
<COMMENT> <NL> import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cntD = collections . Counter ( D ) <NEWLINE> cntT = collections . Counter ( T ) <NEWLINE> <NL> result = <STRING> <NEWLINE> for t in cntT . keys ( ) : <NEWLINE> <INDENT> if not ( t in cntD ) : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> if cntT [ t ] > cntD [ t ] : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import copy <NEWLINE> n = int ( input ( ) ) <NEWLINE> lst = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> lst . append ( x ) <NEWLINE> <NL> <DEDENT> lst2 = copy . deepcopy ( lst ) <NEWLINE> lst2 . sort ( ) <NEWLINE> max = max ( lst2 ) <NEWLINE> for x in lst : <NEWLINE> <INDENT> if x == max : <NEWLINE> <INDENT> print ( lst2 [ - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> city = { } <NEWLINE> city_name = [ ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> S = input ( ) . split ( ) <NEWLINE> city [ n + 1 ] = S <NEWLINE> city_name . append ( S [ 0 ] ) <NEWLINE> <NL> <DEDENT> city_name = list ( set ( city_name ) ) <NEWLINE> city_name . sort ( ) <NEWLINE> <NL> for c_name in city_name : <NEWLINE> <INDENT> city_temp = { } <NEWLINE> for c_key in city . keys ( ) : <NEWLINE> <INDENT> if city [ c_key ] [ 0 ] == c_name : <NEWLINE> <INDENT> city_temp [ int ( city [ c_key ] [ 1 ] ) ] = c_key <NEWLINE> <NL> <DEDENT> <DEDENT> p_temp = list ( city_temp . keys ( ) ) <NEWLINE> p_temp . sort ( reverse = True ) <NEWLINE> for v in p_temp : <NEWLINE> <INDENT> print ( city_temp [ v ] ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> n = N - 1 <NEWLINE> res = n * ( n + 1 ) // 2 <NEWLINE> print ( res ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> x , y = [ 0 ] * n , [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x [ i ] , y [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> from collections import defaultdict <NEWLINE> xy = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : continue <NEWLINE> xy [ ( x [ i ] - x [ j ] , y [ i ] - y [ j ] ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> if xy == { } : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <DEDENT> p , q = max ( xy , key = lambda x : xy [ x ] ) <NEWLINE> ans = n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : continue <NEWLINE> if x [ i ] - x [ j ] == p and y [ i ] - y [ j ] == q : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if ans : <NEWLINE> <INDENT> ans . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> c = { i for i in a } <NEWLINE> <NL> if len ( a ) == len ( c ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for r in range ( N // R + 1 ) : <NEWLINE> <INDENT> for g in range ( N // G + 1 ) : <NEWLINE> <INDENT> res = N - ( r * R + g * G ) <NEWLINE> if res >= 0 and res % B == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from itertools import accumulate <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> ac_list = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ac_list [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ac_sum = list ( accumulate ( ac_list ) ) <NEWLINE> <NL> for l , r in lr : <NEWLINE> <INDENT> l -= 1 <NEWLINE> r -= 1 <NEWLINE> if l == 0 : <NEWLINE> <INDENT> print ( ac_sum [ r - 1 ] ) <NEWLINE> continue <NEWLINE> <DEDENT> print ( ac_sum [ r - 1 ] - ac_sum [ l - 1 ] ) <NEWLINE> <DEDENT>
import sys , os , math , bisect , itertools , collections , heapq , queue <NEWLINE> <COMMENT> <NL> from decimal import Decimal <NEWLINE> from collections import defaultdict , deque <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N = ii ( ) <NEWLINE> A = il ( ) <NEWLINE> cnt = collections . Counter ( A ) <NEWLINE> <NL> for k , v in cnt . items ( ) : <NEWLINE> <INDENT> if k == 0 and v != 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif k != 0 and v != 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ( 2 ** ( N // 2 ) ) % MOD ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( int ( input ( ) ) for i in range ( n ) ) <NEWLINE> t = [ ] <NEWLINE> o = 1 <NEWLINE> <NL> while o != 2 : <NEWLINE> <INDENT> if len ( t ) > n : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> t . append ( o ) <NEWLINE> o = a [ o - 1 ] <NEWLINE> <NL> <DEDENT> print ( len ( t ) ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> A [ t - 1 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> if Q - A [ i ] < K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<NL> from copy import copy <NEWLINE> N = int ( input ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> di = [ - 1 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ u - 1 ] . append ( [ v - 1 , w ] ) <NEWLINE> G [ v - 1 ] . append ( [ u - 1 , w ] ) <NEWLINE> <NL> <DEDENT> di [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if di [ i ] != - 1 : continue <NEWLINE> seen = [ 0 ] * N <NEWLINE> stack = [ [ 0 , 0 ] ] <NEWLINE> while stack : <NEWLINE> <INDENT> y , d = stack . pop ( ) <NEWLINE> if seen [ y ] == 1 : continue <NEWLINE> seen [ y ] = 1 <NEWLINE> for z , dist in G [ y ] : <NEWLINE> <INDENT> if seen [ z ] == 0 : <NEWLINE> <INDENT> di [ z ] = d + dist <NEWLINE> stack . append ( [ z , d + dist ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if di [ i ] % 2 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> di = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> fi = [ ] <NEWLINE> for i , j in di : <NEWLINE> <INDENT> fi . append ( [ j , i ] ) <NEWLINE> <DEDENT> for k in ls : <NEWLINE> <INDENT> fi . append ( [ k , 1 ] ) <NEWLINE> <DEDENT> fi . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> how = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if how + fi [ cnt ] [ 1 ] < n : <NEWLINE> <INDENT> how += fi [ cnt ] [ 1 ] <NEWLINE> ans += fi [ cnt ] [ 1 ] * fi [ cnt ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ( n - how ) * fi [ cnt ] [ 0 ] <NEWLINE> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if x + y <= s : <NEWLINE> <INDENT> z = s - ( x + y ) <NEWLINE> if z <= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> b = B [ i ] <NEWLINE> a = bisect . bisect_left ( A , b ) <NEWLINE> c = bisect . bisect_right ( C , b ) <NEWLINE> ans += a * ( N - c ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if 0 <= z <= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import collections <NEWLINE> A = input ( ) <NEWLINE> Ac = collections . Counter ( A ) <NEWLINE> cnt = 0 <NEWLINE> for val in Ac . values ( ) : <NEWLINE> <INDENT> cnt += val * ( val - 1 ) // 2 <NEWLINE> <DEDENT> print ( len ( A ) * ( len ( A ) - 1 ) // 2 - cnt + 1 ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> v_max = ( 10 ** 3 ) * N <NEWLINE> inf = float ( <STRING> ) <NEWLINE> dp = [ inf for _ in range ( v_max + 1 ) ] <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( v_max , v - 1 , - 1 ) : <NEWLINE> <INDENT> b = w + dp [ j - v ] <NEWLINE> if b < dp [ j ] : <NEWLINE> <INDENT> dp [ j ] = b <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = None <NEWLINE> for i in range ( v_max + 1 ) : <NEWLINE> <INDENT> z = dp [ i ] <NEWLINE> if z <= W : <NEWLINE> <INDENT> ans = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( h ) ] <NEWLINE> B = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( h ) ] <NEWLINE> abss = [ [ abs ( A [ i ] [ j ] - B [ i ] [ j ] ) for j in range ( w ) ] for i in range ( h ) ] <NEWLINE> dp = [ [ 0 ] * w for i in range ( h ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 1 << ( abss [ 0 ] [ 0 ] + 13000 ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if i != h - 1 : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] = dp [ i + 1 ] [ j ] | dp [ i ] [ j ] << abss [ i + <NEWLINE> <INDENT> 1 ] [ j ] | dp [ i ] [ j ] >> abss [ i + 1 ] [ j ] <NEWLINE> <DEDENT> <DEDENT> if j != w - 1 : <NEWLINE> <INDENT> dp [ i ] [ j + 1 ] = dp [ i ] [ j + 1 ] | dp [ i ] [ j ] << abss [ i ] [ j + <NEWLINE> <INDENT> 1 ] | dp [ i ] [ j ] >> abss [ i ] [ j + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> a = 0 <NEWLINE> ans = dp [ - 1 ] [ - 1 ] <NEWLINE> while True : <NEWLINE> <INDENT> if ( ans & ( 1 << ( 13000 - a ) ) ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( ans & ( 1 << ( 13000 + a ) ) ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> break <NEWLINE> <DEDENT> a += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> di = [ ] <NEWLINE> ans = 0 <NEWLINE> now = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ls [ i ] == i + 1 : <NEWLINE> <INDENT> now += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if now != 0 : <NEWLINE> <INDENT> di . append ( now ) <NEWLINE> now = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if now != 0 : <NEWLINE> <INDENT> di . append ( now ) <NEWLINE> <DEDENT> for j in di : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> ans += j // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ( j // 2 ) + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> li = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> li_len = [ 5 , 7 , 5 , 6 ] <NEWLINE> <NL> while S : <NEWLINE> <INDENT> for i , moji in enumerate ( li ) : <NEWLINE> <INDENT> if S [ - li_len [ i ] : ] == moji : <NEWLINE> <INDENT> S = S [ : - li_len [ i ] ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not S : print ( <STRING> ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> l = set ( [ 1 ] ) <NEWLINE> i = 1 <NEWLINE> while i < x : <NEWLINE> <INDENT> j = 2 <NEWLINE> while j < 10 : <NEWLINE> <INDENT> if i ** j <= x : <NEWLINE> <INDENT> l . add ( i ** j ) <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( max ( l ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( * ( a [ : : - 2 ] + a [ n % 2 : : 2 ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> mydict = { } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> tmp = sorted ( input ( ) , key = str . lower ) <NEWLINE> tmp = <STRING> . join ( sorted ( tmp ) ) <NEWLINE> if tmp in mydict : <NEWLINE> <INDENT> mydict [ tmp ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mydict . setdefault ( tmp , 1 ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in mydict . values ( ) : <NEWLINE> <INDENT> ans += i * ( i - 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE> <NL>
def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // gcd ( a , b ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> t1 = int ( input ( ) ) <NEWLINE> ans = t1 <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> t2 = int ( input ( ) ) <NEWLINE> ans = lcm ( ans , t2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def solve ( N , X , D ) : <NEWLINE> <INDENT> if D == 0 : <NEWLINE> <INDENT> if X == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return N + 1 <NEWLINE> <DEDENT> L = { 0 : [ ( 0 , 1 ) , ( 1 , - 1 ) ] } <NEWLINE> coef_l = 0 <NEWLINE> coef_r = 1 <NEWLINE> for coef_x in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> m = X * coef_x % D <NEWLINE> l = X * coef_x // D + coef_l <NEWLINE> r = X * coef_x // D + coef_x * N - coef_r <NEWLINE> coef_l = coef_r <NEWLINE> coef_r += coef_x + 1 <NEWLINE> if m not in L : <NEWLINE> <INDENT> L [ m ] = [ ] <NEWLINE> <DEDENT> L [ m ] . append ( ( l , 1 ) ) <NEWLINE> L [ m ] . append ( ( r + 1 , - 1 ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for Q in L . values ( ) : <NEWLINE> <INDENT> Q . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> last = None <NEWLINE> for val , sign in Q : <NEWLINE> <INDENT> if cnt > 0 : <NEWLINE> <INDENT> ans += val - last <NEWLINE> <DEDENT> cnt += sign <NEWLINE> last = val <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> N , X , D = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( solve ( N , X , D ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> t = s [ k - 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] != t : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( * s , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> num_node = int ( input ( ) ) <NEWLINE> relation = [ [ [ ] , [ ] ] for i in range ( num_node + 1 ) ] <NEWLINE> for i in range ( num_node - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if w % 2 == 0 : <NEWLINE> <INDENT> relation [ u ] [ 0 ] . append ( v ) <NEWLINE> relation [ v ] [ 0 ] . append ( u ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> relation [ u ] [ 1 ] . append ( v ) <NEWLINE> relation [ v ] [ 1 ] . append ( u ) <NEWLINE> <DEDENT> <DEDENT> colors = [ None ] * ( num_node + 1 ) <NEWLINE> <NL> <NL> def dfs ( n : int , c : int ) : <NEWLINE> <INDENT> colors [ n ] = c <NEWLINE> <COMMENT> <NL> for even_idx in relation [ n ] [ 0 ] : <NEWLINE> <INDENT> if colors [ even_idx ] is not None : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dfs ( even_idx , colors [ n ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for odd_idx in relation [ n ] [ 1 ] : <NEWLINE> <INDENT> if colors [ odd_idx ] is not None : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dfs ( odd_idx , 1 - colors [ n ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> dfs ( 1 , 0 ) <NEWLINE> for ans in list ( map ( int , colors [ 1 : ] ) ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> <NL> ans = a [ 1 ] <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if abs ( a [ 0 ] / 2 - a [ i ] ) > abs ( a [ 0 ] / 2 - a [ i + 1 ] ) : <NEWLINE> <INDENT> ans = a [ i + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( a [ 0 ] , ans ) <NEWLINE>
import collections <NEWLINE> <NL> s = input ( ) <NEWLINE> slen = len ( s ) <NEWLINE> <NL> sl = collections . deque ( list ( s ) ) <NEWLINE> sl_inv = collections . deque ( list ( s [ : : - 1 ] ) ) <NEWLINE> cnt = 0 <NEWLINE> while len ( sl ) > 0 : <NEWLINE> <INDENT> if sl [ 0 ] == sl_inv [ 0 ] : <NEWLINE> <INDENT> sl . popleft ( ) <NEWLINE> sl_inv . popleft ( ) <NEWLINE> <DEDENT> elif sl [ 0 ] == <STRING> and sl_inv [ 0 ] != <STRING> : <NEWLINE> <INDENT> sl . popleft ( ) <NEWLINE> <DEDENT> elif sl [ 0 ] != <STRING> and sl_inv [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> sl_inv . popleft ( ) <NEWLINE> <DEDENT> elif sl [ 0 ] != <STRING> and sl_inv [ 0 ] != <STRING> and sl [ 0 ] != sl_inv [ 0 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if len ( sl_inv ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( cnt + len ( sl_inv ) ) <NEWLINE>
import math <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> score = 0 <NEWLINE> times = [ ] <NEWLINE> for i in range ( 1 , min ( n + 1 , k ) ) : <NEWLINE> <INDENT> times . append ( math . ceil ( math . log2 ( ( k / i ) ) ) ) <NEWLINE> <NL> <DEDENT> if len ( times ) : <NEWLINE> <INDENT> bottom_max = times [ 0 ] <NEWLINE> for t in times : <NEWLINE> <INDENT> score += 2 ** ( bottom_max - t ) <NEWLINE> <DEDENT> score /= 2 ** ( bottom_max ) * n <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> big = [ i for i in range ( k , max ( k , n + 1 ) ) ] <NEWLINE> score += len ( big ) / n <NEWLINE> print ( <STRING> . format ( score ) ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> N , H = MAP ( ) <NEWLINE> ab = [ LIST ( ) for _ in range ( N ) ] <NEWLINE> <NL> a , b = zip ( * ab ) <NEWLINE> b = list ( b ) <NEWLINE> <NL> b . sort ( ) <NEWLINE> A = max ( a ) <NEWLINE> <NL> B = b [ bisect ( b , A ) : ] [ : : - 1 ] <NEWLINE> if B : <NEWLINE> <INDENT> B = list ( accumulate ( B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = [ 0 ] <NEWLINE> <NL> <NL> <DEDENT> if H <= B [ - 1 ] : <NEWLINE> <INDENT> print ( bisect_left ( B , H ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if B [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( ceil ( H / A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( B ) + ceil ( ( H - B [ - 1 ] ) / A ) ) <NEWLINE> <DEDENT> <DEDENT>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = ( a - 1 ) // x <NEWLINE> B = b // x <NEWLINE> <NL> print ( B - A ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( n * ( n - 1 ) // 2 ) <NEWLINE>
s = [ input ( ) for i in range ( 3 ) ] <NEWLINE> l = [ len ( s [ i ] ) for i in range ( 3 ) ] <NEWLINE> abc = [ 0 , 0 , 0 ] <NEWLINE> now = 0 <NEWLINE> while abc [ now ] != l [ now ] : <NEWLINE> <INDENT> s_sub = s [ now ] [ abc [ now ] ] <NEWLINE> abc [ now ] += 1 <NEWLINE> now = ( 0 if s_sub == <STRING> else 1 if s_sub == <STRING> else 2 ) <NEWLINE> <DEDENT> print ( <STRING> if now == 0 else <STRING> if now == 1 else <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans_lis = [ ] <NEWLINE> s_length = len ( s ) <NEWLINE> lis = [ [ ] for i in range ( 26 ) ] <NEWLINE> <NL> for i in range ( s_length ) : <NEWLINE> <INDENT> lis [ ord ( s [ i ] ) - ord ( <STRING> ) ] . append ( i ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> k = 1 <NEWLINE> while k <= K : <NEWLINE> <INDENT> for j in lis [ i ] : <NEWLINE> <INDENT> ans_lis . append ( s [ j : j + k ] ) <NEWLINE> <DEDENT> k += 1 <NEWLINE> ans_lis = sorted ( list ( set ( ans_lis ) ) ) <NEWLINE> <DEDENT> if len ( ans_lis ) >= K : <NEWLINE> <INDENT> print ( ans_lis [ K - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> print ( lcm ( A , B ) ) <NEWLINE>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> b = [ ] <NEWLINE> <NL> b . append ( A . pop ( 0 ) // 2 ) <NEWLINE> for i in range ( 1 , M ) : <NEWLINE> <INDENT> if A == [ ] : <NEWLINE> <INDENT> b . append ( b . pop ( 0 ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A [ 0 ] > b [ 0 ] : <NEWLINE> <INDENT> b . append ( A . pop ( 0 ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( b . pop ( 0 ) // 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( A ) + sum ( b ) ) <NEWLINE>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> L = sorted ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( len ( L ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( L ) ) : <NEWLINE> <INDENT> a = L [ i ] <NEWLINE> b = L [ j ] <NEWLINE> ans += max ( 0 , bisect . bisect_right ( L , a + b - 1 ) - ( j + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> print ( sum ( a [ b - 1 ] == e + 1 for e , b in enumerate ( a ) ) // 2 ) <NEWLINE>
from sys import stdin <NEWLINE> nii = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> lnii = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> h , w , d = nii ( ) <NEWLINE> <NL> a_dict = { } <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> a = lnii ( ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> a_dict [ a [ j ] ] = ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> b_dict = { } <NEWLINE> for i in range ( 1 , d + 1 ) : <NEWLINE> <INDENT> num = i <NEWLINE> cy , cx = a_dict [ num ] <NEWLINE> b_dict [ num ] = 0 <NEWLINE> while num + d <= h * w : <NEWLINE> <INDENT> num += d <NEWLINE> ny , nx = a_dict [ num ] <NEWLINE> b_dict [ num ] = b_dict [ num - d ] + abs ( cy - ny ) + abs ( cx - nx ) <NEWLINE> cy = ny <NEWLINE> cx = nx <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> l , r = nii ( ) <NEWLINE> ans = b_dict [ r ] - b_dict [ l ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> x = y = 0 <NEWLINE> c = A [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if c < A [ i ] : <NEWLINE> <INDENT> x = 1 <NEWLINE> <DEDENT> elif c > A [ i ] : <NEWLINE> <INDENT> y = 1 <NEWLINE> <NL> <DEDENT> if x == 1 and y == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> x = y = 0 <NEWLINE> <NL> <DEDENT> c = A [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from sys import setrecursionlimit <NEWLINE> setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> graph [ x ] . append ( y ) <NEWLINE> <DEDENT> dp = [ - 1 for _ in range ( n ) ] <NEWLINE> <COMMENT> <NL> <NL> def solve ( v ) : <NEWLINE> <INDENT> if dp [ v ] != - 1 : <NEWLINE> <INDENT> return dp [ v ] <NEWLINE> <DEDENT> res = 0 <NEWLINE> for next_v in graph [ v ] : <NEWLINE> <INDENT> res = max ( res , solve ( next_v ) + 1 ) <NEWLINE> <DEDENT> dp [ v ] = res <NEWLINE> return dp [ v ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , solve ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> init = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> next_animal = { ( <STRING> , <STRING> , <STRING> ) : <STRING> , <NEWLINE> <INDENT> ( <STRING> , <STRING> , <STRING> ) : <STRING> , <NEWLINE> ( <STRING> , <STRING> , <STRING> ) : <STRING> , <NEWLINE> ( <STRING> , <STRING> , <STRING> ) : <STRING> , <NEWLINE> ( <STRING> , <STRING> , <STRING> ) : <STRING> , <NEWLINE> ( <STRING> , <STRING> , <STRING> ) : <STRING> , <NEWLINE> ( <STRING> , <STRING> , <STRING> ) : <STRING> , <NEWLINE> ( <STRING> , <STRING> , <STRING> ) : <STRING> } <NEWLINE> <DEDENT> for X in init : <NEWLINE> <INDENT> SW = X <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> SW += next_animal [ SW [ i ] , s [ i ] , SW [ i - 1 ] ] <NEWLINE> <DEDENT> ls = len ( SW ) <NEWLINE> if SW [ 0 ] == SW [ ls - 1 ] and next_animal [ SW [ 0 ] , s [ 0 ] , SW [ ls - 2 ] ] == SW [ 1 ] : <NEWLINE> <INDENT> print ( SW [ : ls - 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import copy <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = 0 <NEWLINE> <NL> y = copy . copy ( x ) <NEWLINE> x . sort ( ) <NEWLINE> num1 = x [ n // 2 - 1 ] <NEWLINE> num2 = x [ n // 2 ] <NEWLINE> <NL> for i in y : <NEWLINE> <INDENT> if i <= num1 : <NEWLINE> <INDENT> print ( num2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( num1 ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = list ( map ( lambda x : int ( x ) - a , input ( ) . split ( ) ) ) <NEWLINE> b = max ( max ( [ x for x in X ] ) + a , a ) <NEWLINE> dp = [ [ 0 ] * ( 2 * b * n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> dp [ 0 ] [ b * n ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 2 * b * n + 1 ) : <NEWLINE> <INDENT> if 0 <= j - X [ i - 1 ] < 2 * b * n : <NEWLINE> <INDENT> dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - X [ i - 1 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = dp [ i - 1 ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n ] [ b * n ] - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import bisect <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n , c , k = [ int ( w ) for w in input ( ) . split ( ) ] <NEWLINE> la = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> la . sort ( ) <NEWLINE> lak = [ a + k for a in la ] <NEWLINE> <NL> ind = 0 <NEWLINE> ans = 0 <NEWLINE> while ind < n : <NEWLINE> <INDENT> ride = bisect . bisect_right ( la , lak [ ind ] ) - ind <NEWLINE> ind += min ( ride , c ) <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> <NL> jougesayuu = [ ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ] <NEWLINE> <NL> check = True <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> flag = False <NEWLINE> for ( n , m ) in jougesayuu : <NEWLINE> <INDENT> ni , nj = i + n , j + m <NEWLINE> if ni < 0 or H <= ni or nj < 0 or W <= nj : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ ni ] [ nj ] == <STRING> : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> <DEDENT> if not flag : <NEWLINE> <INDENT> check = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> if check else <STRING> ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> w = [ A [ 0 ] ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> w . append ( w [ - 1 ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> w1 = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( n - 1 - i ) % 2 == 0 : <NEWLINE> <INDENT> w1 [ i ] = A [ i ] <NEWLINE> <DEDENT> if i > 0 : <NEWLINE> <INDENT> w1 [ i ] += w1 [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def solve ( x ) : <NEWLINE> <INDENT> l = 0 <NEWLINE> r = n + 1 <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> m = ( r + l ) // 2 <NEWLINE> if A [ n - m ] <= x : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if 2 * m - 1 > n : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A [ n - m ] - x >= x - A [ n - 2 * m + 1 ] : <NEWLINE> <INDENT> l = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = w [ - 1 ] - w [ n - l - 1 ] <NEWLINE> if n - 2 * l - 1 >= 0 : <NEWLINE> <INDENT> ans += w1 [ n - 2 * l - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> solve ( int ( input ( ) ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> mincost = [ None ] * n <NEWLINE> <NL> def cost ( n , h ) : <NEWLINE> <INDENT> if ( mincost [ n - 1 ] is not None ) : <NEWLINE> <INDENT> return mincost [ n - 1 ] <NEWLINE> <DEDENT> elif ( n == 1 ) : <NEWLINE> <INDENT> mincost [ n - 1 ] = 0 <NEWLINE> <DEDENT> elif ( n == 2 ) : <NEWLINE> <INDENT> mincost [ n - 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mincost [ n - 1 ] = min ( cost ( n - 1 , h ) + abs ( h [ n - 1 ] - h [ n - 2 ] ) , cost ( n - 2 , h ) + abs ( h [ n - 1 ] - h [ n - 3 ] ) ) <NEWLINE> <DEDENT> return mincost [ n - 1 ] <NEWLINE> <NL> <DEDENT> h = [ None ] * n <NEWLINE> <NL> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( cost ( n , h ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if K % 2 == 0 : <NEWLINE> <INDENT> d1 = N // ( K // 2 ) <NEWLINE> d2 = N // K <NEWLINE> ans = d2 ** 3 + ( d1 - d2 ) ** 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = N // K <NEWLINE> ans = d ** 3 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_even = a [ 0 : : 2 ] <NEWLINE> a_odd = a [ 1 : : 2 ] <NEWLINE> <NL> <COMMENT> <NL> if ( n - 1 ) % 2 == 0 : <COMMENT> <NEWLINE> <INDENT> b = a_even . copy ( ) <NEWLINE> b . reverse ( ) <NEWLINE> b = b + a_odd <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> b = a_odd . copy ( ) <NEWLINE> b . reverse ( ) <NEWLINE> b = b + a_even <NEWLINE> <NL> <DEDENT> b = list ( map ( str , b ) ) <NEWLINE> print ( <STRING> . join ( b ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D_dict = defaultdict ( int ) <NEWLINE> for d in D : <NEWLINE> <INDENT> D_dict [ d ] += 1 <NEWLINE> <DEDENT> M = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> T_dict = defaultdict ( int ) <NEWLINE> for t in T : <NEWLINE> <INDENT> T_dict [ t ] += 1 <NEWLINE> <NL> <DEDENT> for target , t_cnt in T_dict . items ( ) : <NEWLINE> <INDENT> d_cnt = D_dict [ target ] <NEWLINE> if t_cnt > d_cnt : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans >= 10 ** 9 + 7 : <NEWLINE> <INDENT> ans %= 10 ** 9 + 7 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> <NL> A_set = set ( A ) <NEWLINE> <NL> if len ( A ) == len ( A_set ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> from itertools import accumulate <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ( x + 1 ) / 2 for x in p ] <NEWLINE> <COMMENT> <NL> s = list ( accumulate ( s ) ) <NEWLINE> s . insert ( 0 , 0 ) <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , s [ i + k ] - s [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num0 = 0 <NEWLINE> num1 = sum ( a ) <NEWLINE> <NL> ans = 10 ** 10 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> num0 += a [ i ] <NEWLINE> num1 -= a [ i ] <NEWLINE> if ans > abs ( num1 - num0 ) : <NEWLINE> <INDENT> ans = abs ( num1 - num0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> f = False <NEWLINE> count = 0 <NEWLINE> m = P [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> m = min ( m , P [ i ] ) <NEWLINE> if m >= P [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> h = [ * map ( lambda x : int ( x ) , input ( ) . split ( ) ) ] <NEWLINE> <NL> <COMMENT> <NL> def iterative_method ( final ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> min_table = { 0 : 0 } <NEWLINE> <NL> while ( i < final ) : <NEWLINE> <INDENT> if i + 1 in min_table : <NEWLINE> <INDENT> min_table [ i + 1 ] = min ( min_table [ i + 1 ] , min_table [ i ] + abs ( h [ i + 1 ] - h [ i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_table [ i + 1 ] = min_table [ i ] + abs ( h [ i + 1 ] - h [ i ] ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> if i + 2 in min_table : <NEWLINE> <INDENT> min_table [ i + 2 ] = min ( min_table [ i + 2 ] , min_table [ i ] + abs ( h [ i + 2 ] - h [ i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_table [ i + 2 ] = min_table [ i ] + abs ( h [ i + 2 ] - h [ i ] ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <NL> <DEDENT> print ( min_table [ final ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def recursive_method ( n ) : <NEWLINE> <INDENT> memo = [ - 1 ] * n <NEWLINE> memo [ 0 ] = 0 <NEWLINE> memo [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> def recurse ( i ) : <NEWLINE> <INDENT> if memo [ i ] != - 1 : <NEWLINE> <INDENT> return memo [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memo [ i ] = min ( recurse ( i - 1 ) + abs ( h [ i ] - h [ i - 1 ] ) , recurse ( i - 2 ) + abs ( h [ i ] - h [ i - 2 ] ) ) <NEWLINE> return memo [ i ] <NEWLINE> <DEDENT> <DEDENT> return recurse ( n - 1 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( recursive_method ( N ) ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if N == 1 : print ( 1 ) ; exit ( ) ; <NEWLINE> x = [ None ] * N <NEWLINE> y = [ None ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x [ i ] , y [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> diff = [ ] <NEWLINE> nums = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( x [ j ] - x [ i ] , y [ j ] - y [ i ] ) in diff : <NEWLINE> <INDENT> nums [ diff . index ( ( x [ j ] - x [ i ] , y [ j ] - y [ i ] ) ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff . append ( ( x [ j ] - x [ i ] , y [ j ] - y [ i ] ) ) <NEWLINE> nums . append ( 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( N - max ( nums ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> def combinations_count ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> a_ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_csum = [ 0 ] * n <NEWLINE> now = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> now += a_ls [ i ] <NEWLINE> a_csum [ i ] = now <NEWLINE> <DEDENT> a_csum . append ( 0 ) <NEWLINE> a_csum . sort ( ) <NEWLINE> ans = 0 <NEWLINE> now = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a_csum [ i ] == a_csum [ i + 1 ] : <NEWLINE> <INDENT> now += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if now > 0 : <NEWLINE> <INDENT> ans += combinations_count ( now + 1 , 2 ) <NEWLINE> <DEDENT> now = 0 <NEWLINE> <DEDENT> <DEDENT> if now > 0 : <NEWLINE> <INDENT> ans += combinations_count ( now + 1 , 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def aising19_c ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> <NL> h , w = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> color = [ [ s == <STRING> for s in str ( input ( ) ) ] for _ in range ( h ) ] <NEWLINE> used = [ [ False ] * w for _ in range ( h ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if used [ i ] [ j ] : continue <NEWLINE> bk , wt = 0 , 0 <NEWLINE> que = deque ( ) <NEWLINE> used [ i ] [ j ] = True <NEWLINE> que . append ( ( i , j ) ) <NEWLINE> while que : <NEWLINE> <INDENT> ci , cj = que . popleft ( ) <NEWLINE> if color [ ci ] [ cj ] : bk += 1 <NEWLINE> else : wt += 1 <NEWLINE> for di , dj in ( ( - 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) , ( 1 , 0 ) ) : <NEWLINE> <INDENT> ni , nj = ci + di , cj + dj <NEWLINE> if ni < 0 or h <= ni or nj < 0 or w <= nj : continue <NEWLINE> if color [ ci ] [ cj ] == color [ ni ] [ nj ] : continue <NEWLINE> if used [ ni ] [ nj ] : continue <NEWLINE> used [ ni ] [ nj ] = True <NEWLINE> que . append ( ( ni , nj ) ) <NEWLINE> <DEDENT> <DEDENT> ans += bk * wt <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> aising19_c ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> k = math . factorial ( n ) <NEWLINE> print ( k % ( 10 ** 9 + 7 ) ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> frac = [ ] <NEWLINE> for i in range ( 1 , math . floor ( math . sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> frac . append ( len ( str ( int ( N / i ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> if N != 1 : <NEWLINE> <INDENT> print ( min ( frac ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> btn = 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> btn = a [ btn - 1 ] <NEWLINE> cnt += 1 <NEWLINE> if btn == 2 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> break <NEWLINE> <DEDENT> if cnt > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
N , D , A = map ( int , input ( ) . split ( ) ) <NEWLINE> XH = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> XH . sort ( ) <NEWLINE> from math import ceil <NEWLINE> times = ceil ( XH [ 0 ] [ 1 ] / A ) <NEWLINE> ans = times <NEWLINE> damege = [ times * A ] <NEWLINE> coor = [ XH [ 0 ] [ 0 ] + 2 * D ] <NEWLINE> start = 0 <NEWLINE> end = 1 <NEWLINE> dam = sum ( damege [ start : end ] ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> st = start <NEWLINE> while start < end and coor [ start ] < XH [ i ] [ 0 ] : <NEWLINE> <INDENT> start += 1 <NEWLINE> <DEDENT> dam -= sum ( damege [ st : start ] ) <NEWLINE> H = XH [ i ] [ 1 ] - dam <NEWLINE> if H > 0 : <NEWLINE> <INDENT> times = ceil ( H / A ) <NEWLINE> ans += times <NEWLINE> damege . append ( times * A ) <NEWLINE> dam += times * A <NEWLINE> coor . append ( XH [ i ] [ 0 ] + 2 * D ) <NEWLINE> end += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import functools <NEWLINE> import operator <NEWLINE> <NL> def nCr ( n , r ) : <NEWLINE> <INDENT> if n < r : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> if r == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> num = functools . reduce ( operator . mul , range ( n , n - r , - 1 ) ) <NEWLINE> den = functools . reduce ( operator . mul , range ( 1 , r + 1 ) ) <NEWLINE> return num // den % mod <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> print ( nCr ( k - 1 , i - 1 ) * nCr ( n - k + 1 , i ) % mod ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> L = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> <NL> print ( sum ( L [ : K ] ) ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> INF = 1 << 60 <NEWLINE> cost = [ - INF ] * ( N + 1 ) <NEWLINE> cost [ 1 ] = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for n , nn , c in edge : <NEWLINE> <INDENT> if cost [ nn ] < cost [ n ] + c : <NEWLINE> <COMMENT> <NL> <INDENT> if i == N - 1 and nn == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> cost [ nn ] = cost [ n ] + c <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cost [ N ] ) <NEWLINE>
import sys <NEWLINE> from collections import Counter as cc <NEWLINE> from numba import njit <NEWLINE> import numpy as np <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def ii ( ) : return int ( input ( ) ) <NEWLINE> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( mi ( ) ) <NEWLINE> <NL> <COMMENT> <NL> n = ii ( ) <NEWLINE> a = li ( ) <NEWLINE> c = cc ( a ) <NEWLINE> N = sum ( c . values ( ) ) <NEWLINE> cache = np . full ( ( N + 1 , N + 1 , N + 1 ) , - 1 , dtype = float ) <NEWLINE> cache [ 0 ] [ 0 ] [ 0 ] = 0 <NEWLINE> @ njit ( cache = True ) <NEWLINE> def dfs ( x , y , z , N , cache ) : <NEWLINE> <INDENT> if x + y + z == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if cache [ x ] [ y ] [ z ] >= 0 : <NEWLINE> <INDENT> return cache [ x ] [ y ] [ z ] <NEWLINE> <DEDENT> tmp = 1 <NEWLINE> if x > 0 : <NEWLINE> <INDENT> tmp += dfs ( x - 1 , y , z , N , cache ) * x / N <NEWLINE> <DEDENT> if y > 0 : <NEWLINE> <INDENT> tmp += dfs ( x + 1 , y - 1 , z , N , cache ) * y / N <NEWLINE> <DEDENT> if z > 0 : <NEWLINE> <INDENT> tmp += dfs ( x , y + 1 , z - 1 , N , cache ) * z / N <NEWLINE> <DEDENT> tmp *= N / ( x + y + z ) <NEWLINE> cache [ x ] [ y ] [ z ] = tmp <NEWLINE> return tmp <NEWLINE> <NL> <DEDENT> dfs ( c [ 1 ] , c [ 2 ] , c [ 3 ] , N , cache ) <NEWLINE> print ( cache [ c [ 1 ] ] [ c [ 2 ] ] [ c [ 3 ] ] ) <NEWLINE>
import math <NEWLINE> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> t = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> LCM = t [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> LCM = lcm ( LCM , t [ i ] ) <NEWLINE> <NL> <DEDENT> print ( LCM ) <NEWLINE>
<NL> import cmath <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> import random <NEWLINE> from collections import defaultdict <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> PI = cmath . pi <NEWLINE> TAU = cmath . pi * 2 <NEWLINE> EPS = 1e-10 <NEWLINE> <NL> <NL> class Point : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> <COMMENT> <NL> CCW_COUNTER_CLOCKWISE = 1 <NEWLINE> <COMMENT> <NL> CCW_CLOCKWISE = - 1 <NEWLINE> <COMMENT> <NL> CCW_ONLINE_BACK = 2 <NEWLINE> <COMMENT> <NL> CCW_ONLINE_FRONT = - 2 <NEWLINE> <COMMENT> <NL> CCW_ON_SEGMENT = 0 <NEWLINE> <NL> def __init__ ( self , x : float , y : float ) : <NEWLINE> <INDENT> self . c = complex ( x , y ) <NEWLINE> <NL> <DEDENT> @ property <NEWLINE> def x ( self ) : <NEWLINE> <INDENT> return self . c . real <NEWLINE> <NL> <DEDENT> @ property <NEWLINE> def y ( self ) : <NEWLINE> <INDENT> return self . c . imag <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def from_complex ( c : complex ) : <NEWLINE> <INDENT> return Point ( c . real , c . imag ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def from_polar ( r : float , phi : float ) : <NEWLINE> <INDENT> c = cmath . rect ( r , phi ) <NEWLINE> return Point ( c . real , c . imag ) <NEWLINE> <NL> <DEDENT> def __add__ ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> c = self . c + p . c <NEWLINE> return Point ( c . real , c . imag ) <NEWLINE> <NL> <DEDENT> def __iadd__ ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . c += p . c <NEWLINE> return self <NEWLINE> <NL> <DEDENT> def __sub__ ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> c = self . c - p . c <NEWLINE> return Point ( c . real , c . imag ) <NEWLINE> <NL> <DEDENT> def __isub__ ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . c -= p . c <NEWLINE> return self <NEWLINE> <NL> <DEDENT> def __mul__ ( self , f : float ) : <NEWLINE> <INDENT> c = self . c * f <NEWLINE> return Point ( c . real , c . imag ) <NEWLINE> <NL> <DEDENT> def __imul__ ( self , f : float ) : <NEWLINE> <INDENT> self . c *= f <NEWLINE> return self <NEWLINE> <NL> <DEDENT> def __truediv__ ( self , f : float ) : <NEWLINE> <INDENT> c = self . c / f <NEWLINE> return Point ( c . real , c . imag ) <NEWLINE> <NL> <DEDENT> def __itruediv__ ( self , f : float ) : <NEWLINE> <INDENT> self . c /= f <NEWLINE> return self <NEWLINE> <NL> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> return <STRING> . format ( round ( self . x , 10 ) , round ( self . y , 10 ) ) <NEWLINE> <NL> <DEDENT> def __neg__ ( self ) : <NEWLINE> <INDENT> c = - self . c <NEWLINE> return Point ( c . real , c . imag ) <NEWLINE> <NL> <DEDENT> def __eq__ ( self , p ) : <NEWLINE> <INDENT> return abs ( self . c - p . c ) < EPS <NEWLINE> <NL> <DEDENT> def __abs__ ( self ) : <NEWLINE> <INDENT> return abs ( self . c ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def ccw ( a , b , c ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> b = b - a <NEWLINE> c = c - a <NEWLINE> det = b . det ( c ) <NEWLINE> if det > EPS : <NEWLINE> <INDENT> return Point . CCW_COUNTER_CLOCKWISE <NEWLINE> <DEDENT> if det < - EPS : <NEWLINE> <INDENT> return Point . CCW_CLOCKWISE <NEWLINE> <DEDENT> if b . dot ( c ) < - EPS : <NEWLINE> <INDENT> return Point . CCW_ONLINE_BACK <NEWLINE> <DEDENT> if c . norm ( ) - b . norm ( ) > EPS : <NEWLINE> <INDENT> return Point . CCW_ONLINE_FRONT <NEWLINE> <DEDENT> return Point . CCW_ON_SEGMENT <NEWLINE> <NL> <DEDENT> def dot ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . x * p . x + self . y * p . y <NEWLINE> <NL> <DEDENT> def det ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . x * p . y - self . y * p . x <NEWLINE> <NL> <DEDENT> def dist ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return abs ( self . c - p . c ) <NEWLINE> <NL> <DEDENT> def norm ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return abs ( self . c ) <NEWLINE> <NL> <DEDENT> def phase ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return cmath . phase ( self . c ) <NEWLINE> <NL> <DEDENT> def angle ( self , p , q ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ( cmath . phase ( q . c - self . c ) - cmath . phase ( p . c - self . c ) + PI ) % TAU - PI <NEWLINE> <NL> <DEDENT> def area ( self , p , q ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return abs ( ( p - self ) . det ( q - self ) / 2 ) <NEWLINE> <NL> <DEDENT> def projection_point ( self , p , q , allow_outer = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> diff_q = q - p <NEWLINE> <COMMENT> <NL> r = ( self - p ) . dot ( diff_q ) / abs ( diff_q ) <NEWLINE> <COMMENT> <NL> phase = diff_q . phase ( ) <NEWLINE> <NL> ret = Point . from_polar ( r , phase ) + p <NEWLINE> if allow_outer or ( p - ret ) . dot ( q - ret ) < EPS : <NEWLINE> <INDENT> return ret <NEWLINE> <DEDENT> return None <NEWLINE> <NL> <DEDENT> def reflection_point ( self , p , q ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> r = abs ( self - p ) <NEWLINE> <COMMENT> <NL> angle = p . angle ( q , self ) <NEWLINE> <COMMENT> <NL> angle = ( q - p ) . phase ( ) - angle <NEWLINE> return Point . from_polar ( r , angle ) + p <NEWLINE> <NL> <DEDENT> def on_segment ( self , p , q , allow_side = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not allow_side and ( self == p or self == q ) : <NEWLINE> <INDENT> return False <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> return abs ( ( p - self ) . det ( q - self ) ) < EPS and ( p - self ) . dot ( q - self ) < EPS <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def circumstance_of ( p1 , p2 , p3 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if abs ( ( p2 - p1 ) . det ( p3 - p1 ) ) < EPS : <NEWLINE> <COMMENT> <NL> <INDENT> return None <NEWLINE> <COMMENT> <NL> <DEDENT> a = ( p2 . x - p3 . x ) ** 2 + ( p2 . y - p3 . y ) ** 2 <NEWLINE> b = ( p3 . x - p1 . x ) ** 2 + ( p3 . y - p1 . y ) ** 2 <NEWLINE> c = ( p1 . x - p2 . x ) ** 2 + ( p1 . y - p2 . y ) ** 2 <NEWLINE> num = p1 * a * ( b + c - a ) + p2 * b * ( c + a - b ) + p3 * c * ( a + b - c ) <NEWLINE> den = a * ( b + c - a ) + b * ( c + a - b ) + c * ( a + b - c ) <NEWLINE> return num / den <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Line : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , a : float , b : float , c : float ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . a = a <NEWLINE> self . b = b <NEWLINE> self . c = c <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def from_gradient ( grad : float , intercept : float ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return Line ( grad , - 1 , intercept ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def from_segment ( p1 , p2 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> a = p2 . y - p1 . y <NEWLINE> b = p1 . x - p2 . x <NEWLINE> c = p2 . y * ( p2 . x - p1 . x ) - p2 . x * ( p2 . y - p1 . y ) <NEWLINE> return Line ( a , b , c ) <NEWLINE> <NL> <DEDENT> @ property <NEWLINE> def gradient ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return INF if self . b == 0 else - self . a / self . b <NEWLINE> <NL> <DEDENT> @ property <NEWLINE> def intercept ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return INF if self . b == 0 else - self . c / self . b <NEWLINE> <NL> <DEDENT> def is_parallel_to ( self , l ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> return abs ( Point . from_rect ( self . a , self . b ) . det ( Point . from_rect ( l . a , l . b ) ) ) < EPS <NEWLINE> <NL> <DEDENT> def is_orthogonal_to ( self , l ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> return abs ( Point . from_rect ( self . a , self . b ) . dot ( Point . from_rect ( l . a , l . b ) ) ) < EPS <NEWLINE> <NL> <DEDENT> def intersection_point ( self , l ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> a1 , b1 , c1 = self . a , self . b , self . c <NEWLINE> a2 , b2 , c2 = l . a , l . b , l . c <NEWLINE> det = a1 * b2 - a2 * b1 <NEWLINE> if abs ( det ) < EPS : <NEWLINE> <COMMENT> <NL> <INDENT> return None <NEWLINE> <DEDENT> x = ( b1 * c2 - b2 * c1 ) / det <NEWLINE> y = ( a2 * c1 - a1 * c2 ) / det <NEWLINE> return Point . from_rect ( x , y ) <NEWLINE> <NL> <DEDENT> def dist ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> raise NotImplementedError ( ) <NEWLINE> <NL> <DEDENT> def has_point ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return abs ( self . a * p . x + self . b * p . y + self . c ) < EPS <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Segment : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , p1 , p2 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . p1 = p1 <NEWLINE> self . p2 = p2 <NEWLINE> <NL> <DEDENT> def norm ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return abs ( self . p1 - self . p2 ) <NEWLINE> <NL> <DEDENT> def phase ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ( self . p2 - self . p1 ) . phase ( ) <NEWLINE> <NL> <DEDENT> def is_parallel_to ( self , s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> return abs ( ( self . p1 - self . p2 ) . det ( s . p1 - s . p2 ) ) < EPS <NEWLINE> <NL> <DEDENT> def is_orthogonal_to ( self , s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> return abs ( ( self . p1 - self . p2 ) . dot ( s . p1 - s . p2 ) ) < EPS <NEWLINE> <NL> <DEDENT> def intersects_with ( self , s , allow_side = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . is_parallel_to ( s ) : <NEWLINE> <COMMENT> <NL> <INDENT> return ( s . p1 . on_segment ( self . p1 , self . p2 , allow_side ) or <NEWLINE> <INDENT> s . p2 . on_segment ( self . p1 , self . p2 , allow_side ) or <NEWLINE> self . p1 . on_segment ( s . p1 , s . p2 , allow_side ) or <NEWLINE> self . p2 . on_segment ( s . p1 , s . p2 , allow_side ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> det_upper = EPS if allow_side else - EPS <NEWLINE> ok = True <NEWLINE> <COMMENT> <NL> ok &= ( self . p2 - self . p1 ) . det ( s . p1 - self . p1 ) * ( self . p2 - self . p1 ) . det ( s . p2 - self . p1 ) < det_upper <NEWLINE> <COMMENT> <NL> ok &= ( s . p2 - s . p1 ) . det ( self . p1 - s . p1 ) * ( s . p2 - s . p1 ) . det ( self . p2 - s . p1 ) < det_upper <NEWLINE> return ok <NEWLINE> <NL> <DEDENT> <DEDENT> def closest_point ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> d = ( p - self . p1 ) . dot ( self . p2 - self . p1 ) / self . norm ( ) <NEWLINE> <COMMENT> <NL> if d < EPS : <NEWLINE> <INDENT> return self . p1 <NEWLINE> <COMMENT> <NL> <DEDENT> if - EPS < d - self . norm ( ) : <NEWLINE> <INDENT> return self . p2 <NEWLINE> <COMMENT> <NL> <DEDENT> return Point . from_polar ( d , ( self . p2 - self . p1 ) . phase ( ) ) + self . p1 <NEWLINE> <NL> <DEDENT> def dist ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return abs ( p - self . closest_point ( p ) ) <NEWLINE> <NL> <DEDENT> def dist_segment ( self , s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . intersects_with ( s ) : <NEWLINE> <INDENT> return 0.0 <NEWLINE> <DEDENT> return min ( <NEWLINE> <INDENT> self . dist ( s . p1 ) , <NEWLINE> self . dist ( s . p2 ) , <NEWLINE> s . dist ( self . p1 ) , <NEWLINE> s . dist ( self . p2 ) , <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> def has_point ( self , p , allow_side = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return p . on_segment ( self . p1 , self . p2 , allow_side = allow_side ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Polygon : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , points ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . points = points <NEWLINE> <NL> <DEDENT> def iter2 ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return zip ( self . points , self . points [ 1 : ] + self . points [ : 1 ] ) <NEWLINE> <NL> <DEDENT> def iter3 ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return zip ( self . points , <NEWLINE> <INDENT> self . points [ 1 : ] + self . points [ : 1 ] , <NEWLINE> self . points [ 2 : ] + self . points [ : 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def area ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> dets = [ ] <NEWLINE> for p , q in self . iter2 ( ) : <NEWLINE> <INDENT> dets . append ( p . det ( q ) ) <NEWLINE> <DEDENT> return abs ( math . fsum ( dets ) ) / 2 <NEWLINE> <NL> <DEDENT> def is_convex ( self , allow_straight = False , allow_collapsed = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ccw = [ ] <NEWLINE> for a , b , c in self . iter3 ( ) : <NEWLINE> <INDENT> ccw . append ( Point . ccw ( a , b , c ) ) <NEWLINE> <DEDENT> ccw = set ( ccw ) <NEWLINE> if len ( ccw ) == 1 : <NEWLINE> <INDENT> if ccw == { Point . CCW_CLOCKWISE } : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if ccw == { Point . CCW_COUNTER_CLOCKWISE } : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> if allow_straight and len ( ccw ) == 2 : <NEWLINE> <INDENT> if ccw == { Point . CCW_ONLINE_FRONT , Point . CCW_CLOCKWISE } : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if ccw == { Point . CCW_ONLINE_FRONT , Point . CCW_COUNTER_CLOCKWISE } : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> if allow_collapsed and len ( ccw ) == 3 : <NEWLINE> <INDENT> return ccw == { Point . CCW_ONLINE_FRONT , Point . CCW_ONLINE_BACK , Point . CCW_ON_SEGMENT } <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def has_point_on_edge ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for a , b in self . iter2 ( ) : <NEWLINE> <INDENT> if p . on_segment ( a , b ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def contains ( self , p , allow_on_edge = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> angles = [ ] <NEWLINE> for a , b in self . iter2 ( ) : <NEWLINE> <INDENT> if p . on_segment ( a , b ) : <NEWLINE> <INDENT> return allow_on_edge <NEWLINE> <DEDENT> angles . append ( p . angle ( a , b ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> return abs ( math . fsum ( angles ) ) > EPS <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def convex_hull ( points , allow_straight = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> points = points [ : ] <NEWLINE> points . sort ( key = lambda p : ( p . x , p . y ) ) <NEWLINE> <NL> <COMMENT> <NL> det_lower = - EPS if allow_straight else EPS <NEWLINE> <NL> sz = 0 <NEWLINE> <COMMENT> <NL> ret = [ None ] * ( len ( points ) * 2 ) <NEWLINE> for p in points : <NEWLINE> <INDENT> while sz > 1 and ( ret [ sz - 1 ] - ret [ sz - 2 ] ) . det ( p - ret [ sz - 1 ] ) < det_lower : <NEWLINE> <INDENT> sz -= 1 <NEWLINE> <DEDENT> ret [ sz ] = p <NEWLINE> sz += 1 <NEWLINE> <DEDENT> floor = sz <NEWLINE> for p in reversed ( points [ : - 1 ] ) : <NEWLINE> <INDENT> while sz > floor and ( ret [ sz - 1 ] - ret [ sz - 2 ] ) . det ( p - ret [ sz - 1 ] ) < det_lower : <NEWLINE> <INDENT> sz -= 1 <NEWLINE> <DEDENT> ret [ sz ] = p <NEWLINE> sz += 1 <NEWLINE> <DEDENT> ret = ret [ : sz - 1 ] <NEWLINE> <NL> if allow_straight and len ( ret ) > len ( points ) : <NEWLINE> <COMMENT> <NL> <INDENT> ret = points <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def diameter ( points ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> points = Polygon . convex_hull ( points , allow_straight = False ) <NEWLINE> if len ( points ) == 1 : <NEWLINE> <INDENT> return 0.0 <NEWLINE> <DEDENT> if len ( points ) == 2 : <NEWLINE> <INDENT> return abs ( points [ 0 ] - points [ 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> si = points . index ( min ( points , key = lambda p : ( p . x , p . y ) ) ) <NEWLINE> sj = points . index ( max ( points , key = lambda p : ( p . x , p . y ) ) ) <NEWLINE> n = len ( points ) <NEWLINE> <NL> ret = 0.0 <NEWLINE> <COMMENT> <NL> i , j = si , sj <NEWLINE> while i != sj or j != si : <NEWLINE> <INDENT> ret = max ( ret , abs ( points [ i ] - points [ j ] ) ) <NEWLINE> ni = ( i + 1 ) % n <NEWLINE> nj = ( j + 1 ) % n <NEWLINE> <COMMENT> <NL> if ( points [ ni ] - points [ i ] ) . det ( points [ nj ] - points [ j ] ) > 0 : <NEWLINE> <INDENT> j = nj <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = ni <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def convex_cut_by_line ( self , line_p1 , line_p2 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> n = len ( self . points ) <NEWLINE> line = Line . from_segment ( line_p1 , line_p2 ) <NEWLINE> <COMMENT> <NL> on_line_points = [ ] <NEWLINE> for i , p in enumerate ( self . points ) : <NEWLINE> <INDENT> if line . has_point ( p ) : <NEWLINE> <INDENT> on_line_points . append ( i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> has_on_line_edge = False <NEWLINE> if len ( on_line_points ) >= 3 : <NEWLINE> <INDENT> has_on_line_edge = True <NEWLINE> <DEDENT> elif len ( on_line_points ) == 2 : <NEWLINE> <COMMENT> <NL> <INDENT> has_on_line_edge = abs ( on_line_points [ 0 ] - on_line_points [ 1 ] ) in [ 1 , n - 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> if has_on_line_edge : <NEWLINE> <INDENT> for p in self . points : <NEWLINE> <INDENT> ccw = Point . ccw ( line_p1 , line_p2 , p ) <NEWLINE> if ccw == Point . CCW_COUNTER_CLOCKWISE : <NEWLINE> <INDENT> return Polygon ( self . points [ : ] ) , None <NEWLINE> <DEDENT> if ccw == Point . CCW_CLOCKWISE : <NEWLINE> <INDENT> return None , Polygon ( self . points [ : ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ret_lefts = [ ] <NEWLINE> ret_rights = [ ] <NEWLINE> d = line_p2 - line_p1 <NEWLINE> for p , q in self . iter2 ( ) : <NEWLINE> <INDENT> det_p = d . det ( p - line_p1 ) <NEWLINE> det_q = d . det ( q - line_p1 ) <NEWLINE> if det_p > - EPS : <NEWLINE> <INDENT> ret_lefts . append ( p ) <NEWLINE> <DEDENT> if det_p < EPS : <NEWLINE> <INDENT> ret_rights . append ( p ) <NEWLINE> <COMMENT> <NL> <DEDENT> if det_p * det_q < - EPS : <NEWLINE> <INDENT> intersection = line . intersection_point ( Line . from_segment ( p , q ) ) <NEWLINE> ret_lefts . append ( intersection ) <NEWLINE> ret_rights . append ( intersection ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> l = Polygon ( ret_lefts ) if len ( ret_lefts ) > 1 else None <NEWLINE> r = Polygon ( ret_rights ) if len ( ret_rights ) > 1 else None <NEWLINE> return l , r <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Circle : <NEWLINE> <INDENT> def __init__ ( self , o , r ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . o = o <NEWLINE> self . r = r <NEWLINE> <NL> <DEDENT> def __eq__ ( self , other ) : <NEWLINE> <INDENT> return self . o == other . o and abs ( self . r - other . r ) < EPS <NEWLINE> <NL> <DEDENT> def ctc ( self , c ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . o == c . o : <NEWLINE> <INDENT> return INF if abs ( self . r - c . r ) < EPS else 0 <NEWLINE> <COMMENT> <NL> <DEDENT> d = self . o . dist ( c . o ) - self . r - c . r <NEWLINE> if d > EPS : <NEWLINE> <INDENT> return 4 <NEWLINE> <DEDENT> elif d > - EPS : <NEWLINE> <INDENT> return 3 <NEWLINE> <COMMENT> <NL> <DEDENT> elif d + min ( self . r , c . r ) * 2 > EPS : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> elif d + min ( self . r , c . r ) * 2 > - EPS : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def has_point_on_edge ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return abs ( self . o . dist ( p ) - self . r ) < EPS <NEWLINE> <NL> <DEDENT> def contains ( self , p , allow_on_edge = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if allow_on_edge : <NEWLINE> <COMMENT> <NL> <INDENT> return self . o . dist ( p ) - self . r < EPS <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> return self . o . dist ( p ) - self . r < - EPS <NEWLINE> <NL> <DEDENT> <DEDENT> def area ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . r ** 2 * PI <NEWLINE> <NL> <DEDENT> def circular_segment_area ( self , angle ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> sector_area = self . area ( ) * angle / TAU <NEWLINE> <COMMENT> <NL> return sector_area - self . r ** 2 * math . sin ( angle ) / 2 <NEWLINE> <NL> <DEDENT> def intersection_points ( self , other , allow_outer = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if isinstance ( other , Segment ) : <NEWLINE> <INDENT> return self . intersection_points_with_segment ( other , allow_outer = allow_outer ) <NEWLINE> <DEDENT> if isinstance ( other , Circle ) : <NEWLINE> <INDENT> return self . intersection_points_with_circle ( other ) <NEWLINE> <DEDENT> raise NotImplementedError ( ) <NEWLINE> <NL> <DEDENT> def intersection_points_with_segment ( self , s , allow_outer = False ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> projection_point = self . o . projection_point ( s . p1 , s . p2 , allow_outer = True ) <NEWLINE> <COMMENT> <NL> dist = self . o . dist ( projection_point ) <NEWLINE> <COMMENT> <NL> if dist - self . r > EPS : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> if dist - self . r > - EPS : <NEWLINE> <INDENT> if allow_outer or s . has_point ( projection_point ) : <NEWLINE> <INDENT> return [ projection_point ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> diff = Point . from_polar ( math . sqrt ( self . r ** 2 - dist ** 2 ) , s . phase ( ) ) <NEWLINE> ret1 = projection_point + diff <NEWLINE> ret2 = projection_point - diff <NEWLINE> ret = [ ] <NEWLINE> if allow_outer or s . has_point ( ret1 ) : <NEWLINE> <INDENT> ret . append ( ret1 ) <NEWLINE> <DEDENT> if allow_outer or s . has_point ( ret2 ) : <NEWLINE> <INDENT> ret . append ( ret2 ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def intersection_points_with_circle ( self , other ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ctc = self . ctc ( other ) <NEWLINE> if not 1 <= ctc <= 3 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> if ctc == 3 : <NEWLINE> <COMMENT> <NL> <INDENT> return [ Point . from_polar ( self . r , ( other . o - self . o ) . phase ( ) ) + self . o ] <NEWLINE> <DEDENT> if ctc == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> if self . r > other . r : <NEWLINE> <INDENT> return [ Point . from_polar ( self . r , ( other . o - self . o ) . phase ( ) ) + self . o ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ Point . from_polar ( self . r , ( self . o - other . o ) . phase ( ) ) + self . o ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> assert ctc == 2 <NEWLINE> <NL> a = other . r <NEWLINE> b = self . r <NEWLINE> c = self . o . dist ( other . o ) <NEWLINE> <COMMENT> <NL> cos_a = ( b ** 2 + c ** 2 - a ** 2 ) / ( 2 * b * c ) <NEWLINE> angle = math . acos ( cos_a ) <NEWLINE> phi = ( other . o - self . o ) . phase ( ) <NEWLINE> return [ <NEWLINE> <INDENT> self . o + Point . from_polar ( self . r , phi + angle ) , <NEWLINE> self . o + Point . from_polar ( self . r , phi - angle ) , <NEWLINE> <DEDENT> ] <NEWLINE> <NL> <DEDENT> def tangent_points_with_point ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> dist = self . o . dist ( p ) <NEWLINE> <COMMENT> <NL> if dist - self . r < - EPS : <NEWLINE> <COMMENT> <NL> <INDENT> return [ ] <NEWLINE> <DEDENT> if dist - self . r < EPS : <NEWLINE> <COMMENT> <NL> <INDENT> return [ Point ( p . x , p . y ) ] <NEWLINE> <NL> <DEDENT> a = math . sqrt ( dist ** 2 - self . r ** 2 ) <NEWLINE> b = self . r <NEWLINE> c = dist <NEWLINE> <COMMENT> <NL> cos_a = ( b ** 2 + c ** 2 - a ** 2 ) / ( 2 * b * c ) <NEWLINE> angle = math . acos ( cos_a ) <NEWLINE> phi = ( p - self . o ) . phase ( ) <NEWLINE> return [ <NEWLINE> <INDENT> self . o + Point . from_polar ( self . r , phi + angle ) , <NEWLINE> self . o + Point . from_polar ( self . r , phi - angle ) , <NEWLINE> <DEDENT> ] <NEWLINE> <NL> <DEDENT> def tangent_points_with_circle ( self , other ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ctc = self . ctc ( other ) <NEWLINE> if ctc > 4 : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> if ctc == 0 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> if ctc == 1 : <NEWLINE> <INDENT> return self . intersection_points_with_circle ( other ) <NEWLINE> <NL> <DEDENT> assert ctc in ( 2 , 3 , 4 ) <NEWLINE> ret = [ ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if abs ( self . r - other . r ) < EPS : <NEWLINE> <COMMENT> <NL> <INDENT> phi = ( other . o - self . o ) . phase ( ) <NEWLINE> ret . append ( self . o + Point . from_polar ( self . r , phi + PI / 2 ) ) <NEWLINE> ret . append ( self . o + Point . from_polar ( self . r , phi - PI / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> intersection = self . o + ( other . o - self . o ) / ( self . r - other . r ) * self . r <NEWLINE> ret += self . tangent_points_with_point ( intersection ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> intersection = self . o + ( other . o - self . o ) / ( self . r + other . r ) * self . r <NEWLINE> ret += self . tangent_points_with_point ( intersection ) <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def circumscribed_of ( p1 , p2 , p3 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if p1 . on_segment ( p2 , p3 ) : <NEWLINE> <INDENT> return Circle ( ( p2 + p3 ) / 2 , p2 . dist ( p3 ) / 2 ) <NEWLINE> <DEDENT> if p2 . on_segment ( p1 , p3 ) : <NEWLINE> <INDENT> return Circle ( ( p1 + p3 ) / 2 , p1 . dist ( p3 ) / 2 ) <NEWLINE> <DEDENT> if p3 . on_segment ( p1 , p2 ) : <NEWLINE> <INDENT> return Circle ( ( p1 + p2 ) / 2 , p1 . dist ( p2 ) / 2 ) <NEWLINE> <DEDENT> o = Point . circumstance_of ( p1 , p2 , p3 ) <NEWLINE> return Circle ( o , o . dist ( p1 ) ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def min_enclosing_circle ( points , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if len ( points ) <= 1 : <NEWLINE> <INDENT> return Circle ( points [ 0 ] , 0 ) <NEWLINE> <DEDENT> if len ( points ) == 2 : <NEWLINE> <INDENT> return Circle ( ( points [ 0 ] + points [ 1 ] ) / 2 , points [ 0 ] . dist ( points [ 1 ] ) / 2 ) <NEWLINE> <NL> <DEDENT> def mid ( p1 , p2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> return Circle ( ( p1 + p2 ) / 2 , p1 . dist ( p2 ) / 2 ) <NEWLINE> <NL> <DEDENT> points = points [ : ] <NEWLINE> random . shuffle ( points ) <NEWLINE> <COMMENT> <NL> ret = mid ( points [ 0 ] , points [ 1 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if ret . contains ( points [ i ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ret = mid ( points [ 0 ] , points [ i ] ) <NEWLINE> for j in range ( 1 , i ) : <NEWLINE> <INDENT> if ret . contains ( points [ j ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ret = mid ( points [ j ] , points [ i ] ) <NEWLINE> for k in range ( 0 , j ) : <NEWLINE> <INDENT> if ret . contains ( points [ k ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ret = Circle . circumscribed_of ( points [ k ] , points [ j ] , points [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> XY = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> points = [ ] <NEWLINE> for x , y in XY : <NEWLINE> <INDENT> points . append ( Point ( x , y ) ) <NEWLINE> <DEDENT> ans = Circle . min_enclosing_circle ( points , N ) <NEWLINE> print ( ans . r ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> G = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <DEDENT> S = - 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if len ( G [ i ] ) == 1 : <NEWLINE> <INDENT> S = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> visited = [ False for i in range ( N + 1 ) ] <NEWLINE> parent = [ - 1 for i in range ( N + 1 ) ] <NEWLINE> count = [ 1 for i in range ( N + 1 ) ] <NEWLINE> <NL> ans = N * pow ( 2 , N - 1 , mod ) <NEWLINE> stack = deque ( ) <NEWLINE> <NL> <NL> def dfs ( node ) : <NEWLINE> <INDENT> visited [ node ] = True <NEWLINE> for child in G [ node ] : <NEWLINE> <INDENT> if visited [ child ] == False : <NEWLINE> <INDENT> parent [ child ] = node <NEWLINE> stack . append ( ( node , child ) ) <NEWLINE> dfs ( child ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> powers = [ 1 for i in range ( 2 * 10 ** 5 + 1 ) ] <NEWLINE> for i in range ( 1 , 2 * 10 ** 5 + 1 ) : <NEWLINE> <INDENT> powers [ i ] = powers [ i - 1 ] * 2 % mod <NEWLINE> <NL> <DEDENT> dfs ( S ) <NEWLINE> while stack : <NEWLINE> <INDENT> mom , child = stack . pop ( ) <NEWLINE> count [ mom ] += count [ child ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if len ( G [ i ] ) > 1 : <NEWLINE> <INDENT> ans += powers [ N - 1 ] <NEWLINE> for x in G [ i ] : <NEWLINE> <INDENT> if x != parent [ i ] : <NEWLINE> <INDENT> ans -= powers [ count [ x ] ] <NEWLINE> <DEDENT> <DEDENT> ans -= powers [ N - count [ i ] ] <NEWLINE> ans += len ( G [ i ] ) - 1 <NEWLINE> ans %= mod <NEWLINE> <DEDENT> <DEDENT> D = pow ( 2 , N , mod ) <NEWLINE> print ( ans * pow ( D , mod - 2 , mod ) % mod ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> a = [ 0 ] * 4 <NEWLINE> a [ 0 ] = s // 1000 <NEWLINE> s = s - a [ 0 ] * 1000 <NEWLINE> a [ 1 ] = s // 100 <NEWLINE> s = s - a [ 1 ] * 100 <NEWLINE> a [ 2 ] = s // 10 <NEWLINE> s = s - a [ 2 ] * 10 <NEWLINE> a [ 3 ] = s <NEWLINE> if ( a [ 0 ] == a [ 1 ] or a [ 1 ] == a [ 2 ] or a [ 2 ] == a [ 3 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( H ) ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> S [ i ] = list ( S [ i ] ) <NEWLINE> <NL> <DEDENT> if ( H == 1 ) and ( W == 1 ) : <NEWLINE> <INDENT> if S [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> S [ 0 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif ( H == 1 ) and ( W != 1 ) : <NEWLINE> <INDENT> for col in range ( W ) : <NEWLINE> <INDENT> if S [ 0 ] [ col ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if col == 0 : <NEWLINE> <INDENT> S [ 0 ] [ col ] = str ( [ S [ 0 ] [ col + 1 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> elif col == W - 1 : <NEWLINE> <INDENT> S [ 0 ] [ col ] = str ( [ S [ 0 ] [ col - 1 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ 0 ] [ col ] = str ( [ S [ 0 ] [ col - 1 ] , S [ 0 ] [ col + 1 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif ( H != 1 ) and ( W == 1 ) : <NEWLINE> <INDENT> for row in range ( H ) : <NEWLINE> <INDENT> if S [ row ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if row == 0 : <NEWLINE> <INDENT> S [ row ] [ 0 ] = str ( [ S [ row + 1 ] [ 0 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> elif row == H - 1 : <NEWLINE> <INDENT> S [ row ] [ 0 ] = str ( [ S [ row - 1 ] [ 0 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ row ] [ 0 ] = str ( [ S [ row - 1 ] [ 0 ] , S [ row + 1 ] [ 0 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for row in range ( H ) : <NEWLINE> <INDENT> for col in range ( W ) : <NEWLINE> <INDENT> if S [ row ] [ col ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if row == 0 : <NEWLINE> <INDENT> if col == 0 : <NEWLINE> <INDENT> S [ row ] [ col ] = str ( [ S [ row ] [ col + 1 ] , S [ row + 1 ] [ col ] , S [ row + 1 ] [ col + 1 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> elif col == W - 1 : <NEWLINE> <INDENT> S [ row ] [ col ] = str ( [ S [ row ] [ col - 1 ] , S [ row + 1 ] [ col - 1 ] , S [ row + 1 ] [ col ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ row ] [ col ] = str ( [ S [ row ] [ col - 1 ] , S [ row ] [ col + 1 ] , S [ row + 1 ] [ col - 1 ] , <NEWLINE> <INDENT> S [ row + 1 ] [ col ] , S [ row + 1 ] [ col + 1 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif row == H - 1 : <NEWLINE> <INDENT> if col == 0 : <NEWLINE> <INDENT> S [ row ] [ col ] = str ( [ S [ row - 1 ] [ col ] , S [ row - 1 ] [ col + 1 ] , S [ row ] [ col + 1 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> elif col == W - 1 : <NEWLINE> <INDENT> S [ row ] [ col ] = str ( [ S [ row - 1 ] [ col - 1 ] , S [ row - 1 ] [ col ] , S [ row ] [ col - 1 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ row ] [ col ] = str ( [ S [ row - 1 ] [ col - 1 ] , S [ row - 1 ] [ col ] , S [ row - 1 ] [ col + 1 ] , <NEWLINE> <INDENT> S [ row ] [ col - 1 ] , S [ row ] [ col + 1 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if col == 0 : <NEWLINE> <INDENT> S [ row ] [ col ] = str ( [ S [ row - 1 ] [ col ] , S [ row - 1 ] [ col + 1 ] , <NEWLINE> <INDENT> S [ row ] [ col + 1 ] , <NEWLINE> S [ row + 1 ] [ col ] , S [ row + 1 ] [ col + 1 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> elif col == W - 1 : <NEWLINE> <INDENT> S [ row ] [ col ] = str ( [ S [ row - 1 ] [ col - 1 ] , S [ row - 1 ] [ col ] , <NEWLINE> <INDENT> S [ row ] [ col - 1 ] , <NEWLINE> S [ row + 1 ] [ col - 1 ] , S [ row + 1 ] [ col ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> S [ row ] [ col ] = str ( [ S [ row - 1 ] [ col - 1 ] , S [ row - 1 ] [ col ] , S [ row - 1 ] [ col + 1 ] , <NEWLINE> <INDENT> S [ row ] [ col - 1 ] , S [ row ] [ col + 1 ] , <NEWLINE> S [ row + 1 ] [ col - 1 ] , S [ row + 1 ] [ col ] , S [ row + 1 ] [ col + 1 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> print ( <STRING> . join ( S [ i ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> global FLAG_LOG <NEWLINE> FLAG_LOG = False <NEWLINE> <NL> <NL> def log ( value ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if FLAG_LOG : <NEWLINE> <INDENT> print ( str ( value ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def calculation ( lines ) : <NEWLINE> <COMMENT> <NL> <INDENT> s = int ( lines [ 0 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> values = [ s ] <NEWLINE> <NL> for i in range ( 1000000 ) : <NEWLINE> <INDENT> s = func_f ( values [ i ] ) <NEWLINE> if s in values : <NEWLINE> <INDENT> return [ i + 2 ] <NEWLINE> <DEDENT> values . append ( s ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def func_f ( n ) : <NEWLINE> <INDENT> if n % 2 == 0 : <NEWLINE> <INDENT> return int ( n / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 3 * n + 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 5 ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 18 ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 114 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> global FLAG_LOG <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> FLAG_LOG = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> FLAG_LOG = True <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <DEDENT> if FLAG_LOG : <NEWLINE> <INDENT> log ( <STRING> ) <NEWLINE> log ( <STRING> ) <NEWLINE> log ( <STRING> ) <NEWLINE> if lines_result == lines_export : <NEWLINE> <INDENT> log ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> log ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> finished = time . time ( ) <NEWLINE> duration = finished - started <NEWLINE> log ( <STRING> ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> cnt = A [ 0 ] - 1 <NEWLINE> cant_use = 1 <NEWLINE> for a in A [ 1 : ] : <NEWLINE> <INDENT> wk = a <NEWLINE> if wk == cant_use + 1 : <NEWLINE> <COMMENT> <NL> <INDENT> cant_use += 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if wk % ( cant_use + 1 ) == 0 : <NEWLINE> <INDENT> wk -= cant_use + 2 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> cnt += wk // ( cant_use + 1 ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
<NL> def solve ( ) : <NEWLINE> <INDENT> dp = [ 0 ] * N <NEWLINE> L = max ( l ) <NEWLINE> R = min ( r ) <NEWLINE> if L <= R : <NEWLINE> <INDENT> i = list ( range ( L , R + 1 ) ) <NEWLINE> ans = len ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> l , r = [ 0 ] * M , [ 0 ] * M <NEWLINE> for c in range ( M ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l [ c ] = tmp [ 0 ] <NEWLINE> r [ c ] = tmp [ 1 ] <NEWLINE> <DEDENT> solve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> power = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> power = power * i % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( power ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> max_1 = 0 <NEWLINE> max_2 = 0 <NEWLINE> a_list = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> a_list . append ( a ) <NEWLINE> if max_1 < a : <NEWLINE> <INDENT> max_2 = max_1 <NEWLINE> max_1 = a <NEWLINE> <DEDENT> elif max_2 < a : <NEWLINE> <INDENT> max_2 = a <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if a_list [ i ] == max_1 : <NEWLINE> <INDENT> print ( max_2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max_1 ) <NEWLINE> <DEDENT> <DEDENT>
